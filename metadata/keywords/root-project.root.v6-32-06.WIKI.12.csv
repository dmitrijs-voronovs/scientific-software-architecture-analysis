quality_attribute,keyword,matched_word,sentence,source,filename,author,repo,version,wiki,url
Testability,test,tests,". ROOT: bindings/r/tests/ROOTR.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions ; ROOTR.C File Reference. #include <TRInterface.h>. Include dependency graph for ROOTR.C:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Functions; Double_t myFunc (Double_t x);  ; void ROOTR ();  . Function Documentation. ◆ myFunc(). Double_t myFunc ; (; Double_t ; x). Definition at line 4 of file ROOTR.C. ◆ ROOTR(). void ROOTR ; (; ). Definition at line 9 of file ROOTR.C. bindingsrtestsROOTR.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:12 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/ROOTR_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ROOTR_8C.html
Testability,test,tests,". ROOT: bindings/r/tests/ROOTR.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ROOTR.C. Go to the documentation of this file. 1//script to test Modules; 2#include<TRInterface.h>; 3 ; 4Double_t myFunc(Double_t x); 5{; 6 return cos(x);; 7}; 8 ; 9void ROOTR(); 10{; 11 ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; 12 r.SetVerbose(kFALSE);; 13 r.LoadModule(""Gpad"");; 14 r.LoadModule(""Hist"");; 15 r.LoadModule(""Rint"");; 16 ; 17 r<<""x<-seq(0,2*pi,by=.1)"";; 18 r<<""c1<-new(TCanvas,'c1','dlnorm')"";; 19 r<<""u <-new(TGraph,length(x),x,dlnorm(x))"" ;//TGraph(int,double*,double*); 20 r<<""u$Draw()"";; 21 ; 22 r<<""c2<-new(TCanvas,'c2','DiLog from TMath')"";; 23 r<<""o<- new(TF1,'dilog','TMath::DiLog(x)',0,2*pi)"";; 24 r<<""o$Draw()"";; 25// ; 26 r<<""c3<-new(TCanvas,'c3','Custom')"";; 27 r<<""i <- new(TF1,'f2','[0]*myFunc([1]*x)',0,2*pi)""; ; 28 r<<""i$SetRange(0,2*pi)"";; 29 r<<""i$SetParameter(0,4)"";; 30 r<<""i$SetParameter(1,pi/2)"";; 31 r<<""print(i$Eval(0))"";; 32 r<<""print(i$Eval(c(0,pi)))"";; 33 r<<""i$Draw('')"";; 34 ; 35// r<<""gApp<-new(TRint,'ROOTR')"";; 36// r<<""gApp$ProcessLine('cout<<\""Calling cout from TRint\""<<endl;')"";; 37 ; 38}; ROOTRvoid ROOTR()Definition ROOTR.C:9; myFuncDouble_t myFunc(Double_t x)Definition ROOTR.C:4; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TRInterface.h; ROOT::R::TRInterfaceROOT R was implemented using the R Project library and the modules Rcpp and RInsideDefinition TRInterface.h:136; ROOT::R::TRInterface::Instancestatic TRInterface & Instance()static method to get an TRInterface instance referenceDefinition TRInterface.cxx:187; xDouble_t x[n]Definition legend1.C:17. bindingsrtestsROOTR.C. ROOT ",MatchSource.WIKI,doc/master/ROOTR_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ROOTR_8C_source.html
Deployability,update,update,". ROOT: math/genvector/src/RotationZYX.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. RotationZYX.cxx. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: W. Brown, M. Fischler, L. Moneta 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT FNAL MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for rotation in 3 dimensions, represented by RotationZYX; 12//; 13// Created by: Lorenzo Moneta, May 23 2007; 14//; 15// Last update: $Id$; 16//; 17#include ""Math/GenVector/RotationZYX.h""; 18 ; 19#include <cmath>; 20 ; 21#include ""Math/GenVector/Cartesian3D.h""; 22#include ""Math/GenVector/DisplacementVector3D.h""; 23#include ""Math/GenVector/Rotation3D.h""; 24#include ""Math/GenVector/Quaternion.h""; 25#include ""Math/GenVector/RotationX.h""; 26#include ""Math/GenVector/RotationY.h""; 27#include ""Math/GenVector/RotationZ.h""; 28 ; 29#include ""Math/GenVector/AxisAnglefwd.h""; 30 ; 31namespace ROOT {; 32 ; 33namespace Math {; 34 ; 35// ========== Constructors and Assignment =====================; 36 ; 37 ; 38 ; 39// ========== Operations =====================; 40 ; 41// DisplacementVector3D< Cartesian3D<double> >; 42// RotationZYX::; 43// operator() (const DisplacementVector3D< Cartesian3D<double> > & v) const; 44// {; 45// return Rotation3D(*this)(v);; 46// }; 47 ; 48 ; 49RotationZYX RotationZYX::operator * (const Rotation3D & r) const {; 50 // combine with a Rotation3D; 51 return RotationZYX ( Rotation3D(*this) * r );; 52}; 53 ; 54RotationZYX RotationZYX::operator * (const AxisAngle & a) const {; 55 // combine with a AxisAngle; 56 return RotationZYX ( Quaternion(*this) * Quaternion(a) );; 57}; 58 ; 59RotationZYX RotationZYX::operator * (const EulerAngles & e) const {; 60 // combine with EulerAngles; 61 return RotationZYX ( Quaternion(*this) * Quaternion(e) ",MatchSource.WIKI,doc/master/RotationZYX_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RotationZYX_8cxx_source.html
Performance,perform,performance,"return RotationZYX ( Quaternion(*this) * q );; 72}; 73 ; 74RotationZYX RotationZYX::operator * (const RotationX & r) const {; 75 // combine with a RotationX; 76 return RotationZYX ( Quaternion(*this) * r );; 77}; 78 ; 79RotationZYX RotationZYX::operator * (const RotationY & r) const {; 80 // combine with a RotationY; 81 return RotationZYX ( Quaternion(*this) * r );; 82}; 83 ; 84RotationZYX RotationZYX::operator * (const RotationZ & r) const {; 85 // combine with a RotationZ; 86 // TODO -- this can be made much faster because it merely adds; 87 // the r.Angle() to phi.; 88 Scalar newPhi = fPhi + r.Angle();; 89 if ( newPhi <= -Pi()|| newPhi > Pi() ) {; 90 newPhi = newPhi - std::floor( newPhi/(2*Pi()) +.5 ) * 2*Pi();; 91 }; 92 return RotationZYX ( newPhi, fTheta, fPsi );; 93}; 94 ; 95RotationZYX operator * ( RotationX const & r, RotationZYX const & e ) {; 96 return RotationZYX(r) * e; // TODO: improve performance; 97}; 98 ; 99RotationZYX operator * ( RotationY const & r, RotationZYX const & e ) {; 100 return RotationZYX(r) * e; // TODO: improve performance; 101}; 102 ; 103RotationZYX; 104operator * ( RotationZ const & r, RotationZYX const & e ) {; 105 return RotationZYX(r) * e; // TODO: improve performance; 106}; 107 ; 108void RotationZYX::Rectify(); 109{; 110 // rectify . The angle theta must be defined between [-PI/2,PI.2]; 111 // same as Euler- Angles, just here Theta is shifted by PI/2 with respect to; 112 // the theta of the EulerAngles class; 113 ; 114 Scalar theta2 = fTheta + M_PI_2;; 115 if ( theta2 < 0 || theta2 > Pi() ) {; 116 Scalar t = theta2 - std::floor( theta2/(2*Pi() ) ) * 2*Pi();; 117 if ( t <= Pi() ) {; 118 theta2 = t;; 119 } else {; 120 theta2 = 2*Pi() - t;; 121 fPhi = fPhi + Pi();; 122 fPsi = fPsi + Pi();; 123 }; 124 // ftheta is shifted of PI/2 w.r.t theta2; 125 fTheta = theta2 - M_PI_2;; 126 }; 127 ; 128 if ( fPhi <= -Pi()|| fPhi > Pi() ) {; 129 fPhi = fPhi - std::floor( fPhi/(2*Pi()) +.5 ) * 2*Pi();; 130 }; 131 ; 132 if ( fPsi <= -Pi()|| fPsi > P",MatchSource.WIKI,doc/master/RotationZYX_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RotationZYX_8cxx_source.html
Integrability,depend,dependency,". ROOT: tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces ; RPageStorageFile.hxx File ReferenceNTuple-related classes | ROOT7 classes. #include <ROOT/RMiniFile.hxx>; #include <ROOT/RNTuple.hxx>; #include <ROOT/RNTupleSerialize.hxx>; #include <ROOT/RNTupleZip.hxx>; #include <ROOT/RPageStorage.hxx>; #include <ROOT/RRawFile.hxx>; #include <string_view>; #include <array>; #include <cstdio>; #include <memory>; #include <optional>; #include <string>; #include <utility>. Include dependency graph for RPageStorageFile.hxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  ROOT::Experimental::Internal::RPageSinkFile::CommitBatch;  ; class  ROOT::Experimental::Internal::RPageSinkFile;  Storage provider that write ntuple pages into a file. More...;  ; class  ROOT::Experimental::Internal::RPageSourceFile;  Storage provider that reads ntuple pages from a file. More...;  ; struct  ROOT::Experimental::Internal::RPageSourceFile::RStructureBuffer;  Holds the uncompressed header and footer. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Experimental;  ; namespace  ROOT::Experimental::Internal;  ; namespace  ROOT::Internal;  . Detailed Description; AuthorJakob Blomer jblom.nosp@m.er@c.nosp@m.ern.c.nosp@m.h ; Date2019-11-21 ; WarningThis is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome! ; Definition in file RPageStorageFile.hxx. treentuplev7incROOTRPageStorageFile.hxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:26 ",MatchSource.WIKI,doc/master/RPageStorageFile_8hxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RPageStorageFile_8hxx.html
Integrability,depend,dependency,". ROOT: core/base/inc/RQ_OBJECT.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Macros ; RQ_OBJECT.h File Reference. #include <TQObject.h>; #include <Varargs.h>. Include dependency graph for RQ_OBJECT.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Macros; #define RQ_OBJECT(sender_class);  ; #define RQ_OBJECT1(sender_class);  ; #define RQ_OBJECT2(sender_class);  . Macro Definition Documentation. ◆ RQ_OBJECT. #define RQ_OBJECT; (;  ; sender_class). Value: RQ_OBJECT1(sender_class)\; RQ_OBJECT2(sender_class); RQ_OBJECT1#define RQ_OBJECT1(sender_class)Definition RQ_OBJECT.h:66. Definition at line 87 of file RQ_OBJECT.h. ◆ RQ_OBJECT1. #define RQ_OBJECT1; (;  ; sender_class). Value:private:\; TQObjSender fQObject;\; public:\; TList *GetListOfSignals() const {return fQObject.GetListOfSignals();}\; Bool_t Connect(const char *sig,const char *cl,void *rcvr,const char *slt)\; {fQObject.SetSender(this);fQObject.SetSenderClassName(sender_class);return fQObject.Connect(sig,cl,rcvr,slt);}\; Bool_t Disconnect(const char *sig=nullptr,void *rcvr=nullptr,const char *slt=nullptr){return fQObject.Disconnect(sig,rcvr,slt);}\; void HighPriority(const char *signal_name,const char *slot_name=nullptr){fQObject.HighPriority(signal_name,slot_name);}\; void LowPriority(const char *signal_name,const char *slot_name=nullptr){fQObject.LowPriority(signal_name,slot_name);}\; template <typename... T> void EmitVA(const char *signal_name, Int_t nargs, const T&... params) \; { fQObject.EmitVA(signal_name,nargs,params...); } \; void Emit(const char *signal){EmitVA(signal, /*nargs*/0);} \; template <typename T> void Emit(const char *signal, const T& arg) { EmitVA(signal, /*nargs*/ 1, arg); } \; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinitio",MatchSource.WIKI,doc/master/RQ__OBJECT_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RQ__OBJECT_8h.html
Availability,error,error," methods.; 65template <typename T>; 66constexpr auto hasBeginEnd(int) -> decltype(std::begin(std::declval<T>()), std::end(std::declval<T>()), true); 67{; 68 return true;; 69}; 70 ; 71template <typename>; 72constexpr bool hasBeginEnd(...); 73{; 74 return false;; 75}; 76 ; 77template <typename T, typename WrappedIterator_t, bool isDynamic>; 78class TypedIter {; 79 ; 80public:; 81 TypedIter(WrappedIterator_t const &iter) : fIter{iter} {}; 82 ; 83 TypedIter &operator++(); 84 {; 85 ++fIter;; 86 return *this;; 87 }; 88 TypedIter operator++(int); 89 {; 90 TypedIter tmp(*this);; 91 operator++();; 92 return tmp;; 93 }; 94 bool operator==(const TypedIter &rhs) const { return fIter == rhs.fIter; }; 95 bool operator!=(const TypedIter &rhs) const { return fIter != rhs.fIter; }; 96 ; 97 void swap(TypedIter &other) { fIter.swap(other.fIter); }; 98 ; 99 // We want to know at compile time whether dynamic_cast or static_cast is; 100 // used. First of all to avoid overhead, but also to avoid a compiler; 101 // error when using dynamic_cast on a non-polymorphic class. In C++17,; 102 // this can be done easily with `if constexpr`, but for the older; 103 // standards we have to use a more verbose alternative. Both ways are; 104 // explicitely implemented for different standards, so that when the; 105 // minimum C++ standard for ROOT is raised to C++17 it's easy to remember; 106 // that we can avoid much boilerplate code in this file.; 107#if (__cplusplus < 201700L); 108 T operator*() { return ROOT::Internal::RCast<T, isDynamic>::cast(*fIter); }; 109#else; 110 T operator*(); 111 {; 112 if constexpr (isDynamic) {; 113 return dynamic_cast<T>(*fIter);; 114 } else {; 115 if constexpr (std::is_polymorphic<RBaseType<T>>::value) {; 116 assert(dynamic_cast<T>(*fIter));; 117 }; 118 return static_cast<T>(*fIter);; 119 }; 120 }; 121#endif; 122 ; 123private:; 124 WrappedIterator_t fIter;; 125};; 126 ; 127} // namespace Internal; 128 ; 129/// Wraps any collection that can be used in range-based loops a",MatchSource.WIKI,doc/master/RRangeCast_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RRangeCast_8hxx_source.html
Integrability,depend,depending,"in range-based loops and applies; 157/// static_cast<T> to each element. This function can be used for example to; 158/// cast all objects in a RooAbsCollection when iterating over them.; 159/// Example:; 160/// ~~~{.cpp}; 161/// class ClassA {; 162/// public:; 163/// virtual ~ClassA() {}; 164/// };; 165/// class ClassB : public ClassA {; 166/// };; 167///; 168/// B b1, b2, b3;; 169/// std::vector<A const*> vec{&b1, &b2, &b3};; 170///; 171/// for(auto *b : ROOT::RangeStaticCast<B const*>(vec)) {; 172/// // do something with b; 173/// }; 174/// ~~~; 175/// Make sure to not use `auto const&` in the range-based loop, as this will; 176/// cause a range-loop-bind-reference warning with the clang compiler.; 177template <typename T, typename Range_t>; 178RRangeCast<T, false, Range_t> RangeStaticCast(Range_t &&coll); 179{; 180 return std::forward<Range_t>(coll);; 181}; 182// Overload for C-style arrays. It's not possible to make an overload of the; 183// RRangeCast constructor itself, because when the C-style array is forwarded; 184// it might decay depending on the compiler version.; 185template <typename T, typename U, std::size_t N>; 186RRangeCast<T, false, std::span<U>> RangeStaticCast(U (&arr)[N]); 187{; 188 return std::span<U>(arr, arr + N);; 189}; 190 ; 191/// Takes any collection that can be used in range-based loops and applies; 192/// dynamic_cast<T> to each element. This function can be used for example to; 193/// cast all objects in a RooAbsCollection when iterating over them.; 194/// Example:; 195/// ~~~{.cpp}; 196///; 197/// class ClassA {; 198/// public:; 199/// virtual ~ClassA() {}; 200/// };; 201/// class ClassB : public ClassA {; 202/// };; 203///; 204/// A a1, a2;; 205/// B b1, b2, b3;; 206/// std::vector<A const*> vec{&b1, &a1, &b2, &a2, &b3};; 207///; 208/// for(auto *b : ROOT::RangeDynCast<B const*>(vec)) {; 209/// if(b) {; 210/// // do something with b; 211/// }; 212/// }; 213/// ~~~; 214/// Make sure to not use `auto const&` in the range-based loop, ",MatchSource.WIKI,doc/master/RRangeCast_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RRangeCast_8hxx_source.html
Modifiability,polymorphi,polymorphic," methods.; 65template <typename T>; 66constexpr auto hasBeginEnd(int) -> decltype(std::begin(std::declval<T>()), std::end(std::declval<T>()), true); 67{; 68 return true;; 69}; 70 ; 71template <typename>; 72constexpr bool hasBeginEnd(...); 73{; 74 return false;; 75}; 76 ; 77template <typename T, typename WrappedIterator_t, bool isDynamic>; 78class TypedIter {; 79 ; 80public:; 81 TypedIter(WrappedIterator_t const &iter) : fIter{iter} {}; 82 ; 83 TypedIter &operator++(); 84 {; 85 ++fIter;; 86 return *this;; 87 }; 88 TypedIter operator++(int); 89 {; 90 TypedIter tmp(*this);; 91 operator++();; 92 return tmp;; 93 }; 94 bool operator==(const TypedIter &rhs) const { return fIter == rhs.fIter; }; 95 bool operator!=(const TypedIter &rhs) const { return fIter != rhs.fIter; }; 96 ; 97 void swap(TypedIter &other) { fIter.swap(other.fIter); }; 98 ; 99 // We want to know at compile time whether dynamic_cast or static_cast is; 100 // used. First of all to avoid overhead, but also to avoid a compiler; 101 // error when using dynamic_cast on a non-polymorphic class. In C++17,; 102 // this can be done easily with `if constexpr`, but for the older; 103 // standards we have to use a more verbose alternative. Both ways are; 104 // explicitely implemented for different standards, so that when the; 105 // minimum C++ standard for ROOT is raised to C++17 it's easy to remember; 106 // that we can avoid much boilerplate code in this file.; 107#if (__cplusplus < 201700L); 108 T operator*() { return ROOT::Internal::RCast<T, isDynamic>::cast(*fIter); }; 109#else; 110 T operator*(); 111 {; 112 if constexpr (isDynamic) {; 113 return dynamic_cast<T>(*fIter);; 114 } else {; 115 if constexpr (std::is_polymorphic<RBaseType<T>>::value) {; 116 assert(dynamic_cast<T>(*fIter));; 117 }; 118 return static_cast<T>(*fIter);; 119 }; 120 }; 121#endif; 122 ; 123private:; 124 WrappedIterator_t fIter;; 125};; 126 ; 127} // namespace Internal; 128 ; 129/// Wraps any collection that can be used in range-based loops a",MatchSource.WIKI,doc/master/RRangeCast_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RRangeCast_8hxx_source.html
Safety,avoid,avoid," methods.; 65template <typename T>; 66constexpr auto hasBeginEnd(int) -> decltype(std::begin(std::declval<T>()), std::end(std::declval<T>()), true); 67{; 68 return true;; 69}; 70 ; 71template <typename>; 72constexpr bool hasBeginEnd(...); 73{; 74 return false;; 75}; 76 ; 77template <typename T, typename WrappedIterator_t, bool isDynamic>; 78class TypedIter {; 79 ; 80public:; 81 TypedIter(WrappedIterator_t const &iter) : fIter{iter} {}; 82 ; 83 TypedIter &operator++(); 84 {; 85 ++fIter;; 86 return *this;; 87 }; 88 TypedIter operator++(int); 89 {; 90 TypedIter tmp(*this);; 91 operator++();; 92 return tmp;; 93 }; 94 bool operator==(const TypedIter &rhs) const { return fIter == rhs.fIter; }; 95 bool operator!=(const TypedIter &rhs) const { return fIter != rhs.fIter; }; 96 ; 97 void swap(TypedIter &other) { fIter.swap(other.fIter); }; 98 ; 99 // We want to know at compile time whether dynamic_cast or static_cast is; 100 // used. First of all to avoid overhead, but also to avoid a compiler; 101 // error when using dynamic_cast on a non-polymorphic class. In C++17,; 102 // this can be done easily with `if constexpr`, but for the older; 103 // standards we have to use a more verbose alternative. Both ways are; 104 // explicitely implemented for different standards, so that when the; 105 // minimum C++ standard for ROOT is raised to C++17 it's easy to remember; 106 // that we can avoid much boilerplate code in this file.; 107#if (__cplusplus < 201700L); 108 T operator*() { return ROOT::Internal::RCast<T, isDynamic>::cast(*fIter); }; 109#else; 110 T operator*(); 111 {; 112 if constexpr (isDynamic) {; 113 return dynamic_cast<T>(*fIter);; 114 } else {; 115 if constexpr (std::is_polymorphic<RBaseType<T>>::value) {; 116 assert(dynamic_cast<T>(*fIter));; 117 }; 118 return static_cast<T>(*fIter);; 119 }; 120 }; 121#endif; 122 ; 123private:; 124 WrappedIterator_t fIter;; 125};; 126 ; 127} // namespace Internal; 128 ; 129/// Wraps any collection that can be used in range-based loops a",MatchSource.WIKI,doc/master/RRangeCast_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RRangeCast_8hxx_source.html
Testability,assert,assert," 4/// \date 2021-08-04; 5 ; 6/*************************************************************************; 7 * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; 8 * All rights reserved. *; 9 * *; 10 * For the licensing terms see $ROOTSYS/LICENSE. *; 11 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 12 *************************************************************************/; 13 ; 14#ifndef ROOT_RRangeCast; 15#define ROOT_RRangeCast; 16 ; 17#include ""ROOT/RSpan.hxx""; 18 ; 19#include <cassert>; 20#include <iterator>; 21#include <type_traits>; 22#include <utility>; 23 ; 24namespace ROOT {; 25namespace Internal {; 26 ; 27template <typename T>; 28struct RBaseType {; 29 using type = typename std::remove_pointer<typename std::decay<T>::type>::type;; 30};; 31 ; 32#if (__cplusplus < 201700L); 33 ; 34template <typename T, bool isDynamic = true, bool isPolymorphic = std::is_polymorphic<RBaseType<T>>::value>; 35struct RCast {; 36 template <typename U>; 37 static T cast(U &&u); 38 {; 39 return dynamic_cast<T>(u);; 40 }; 41};; 42 ; 43template <typename T>; 44struct RCast<T, false, false> {; 45 template <typename U>; 46 static T cast(U &&u); 47 {; 48 return static_cast<T>(u);; 49 }; 50};; 51 ; 52template <typename T>; 53struct RCast<T, false, true> {; 54 template <typename U>; 55 static T cast(U &&u); 56 {; 57 assert(dynamic_cast<T>(u));; 58 return static_cast<T>(u);; 59 }; 60};; 61 ; 62#endif; 63 ; 64// For SFINAE-based checks for the existence of the `begin` and `end` methods.; 65template <typename T>; 66constexpr auto hasBeginEnd(int) -> decltype(std::begin(std::declval<T>()), std::end(std::declval<T>()), true); 67{; 68 return true;; 69}; 70 ; 71template <typename>; 72constexpr bool hasBeginEnd(...); 73{; 74 return false;; 75}; 76 ; 77template <typename T, typename WrappedIterator_t, bool isDynamic>; 78class TypedIter {; 79 ; 80public:; 81 TypedIter(WrappedIterator_t const &iter) : fIter{iter} {}; 82 ; 83 TypedIter &operator++(); 84 {; 85 ++fIter;; 86 ret",MatchSource.WIKI,doc/master/RRangeCast_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RRangeCast_8hxx_source.html
Availability,avail,available," 81 std::vector<std::string> variationNames{inmap.fKeys};; 82 Erase<std::string>(""nominal"", variationNames);; 83 ; 84 return ROOT::RDF::Experimental::RResultMap<T>(std::move(nominalResult), std::move(variedResults),; 85 std::move(variationNames), *(inmap.fLoopManager),; 86 std::move(nominalAction), std::move(variedAction));; 87}; 88} // namespace RDF; 89} // namespace Internal; 90 ; 91namespace RDF {; 92 ; 93class RResultHandle;; 94 ; 95namespace Experimental {; 96 ; 97template <typename T>; 98class RResultMap {; 99 ; 100 std::vector<std::string> fKeys; // values are the keys available in fMap; 101 std::unordered_map<std::string, std::shared_ptr<T>> fMap; // shared_ptrs are never null; 102 ROOT::Detail::RDF::RLoopManager *fLoopManager; // never null; 103 std::shared_ptr<ROOT::Internal::RDF::RActionBase> fNominalAction; // never null; 104 std::shared_ptr<ROOT::Internal::RDF::RActionBase> fVariedAction; // might be null if there are no variations; 105 ; 106 friend RResultMap; 107 ROOT::Internal::RDF::MakeResultMap<T>(std::shared_ptr<T> nominalResult,; 108 std::vector<std::shared_ptr<T>> &&variedResults,; 109 std::vector<std::string> &&keys, ROOT::Detail::RDF::RLoopManager &lm,; 110 std::shared_ptr<ROOT::Internal::RDF::RActionBase> nominalAction,; 111 std::shared_ptr<ROOT::Internal::RDF::RActionBase> variedAction);; 112 ; 113 friend RResultMap ROOT::Internal::RDF::CloneResultAndAction<T>(const RResultMap<T> &inmap);; 114 friend std::unique_ptr<ROOT::Detail::RDF::RMergeableVariations<T>>; 115 ROOT::Detail::RDF::GetMergeableValue<T>(RResultMap<T> &rmap);; 116 friend class ::ROOT::RDF::RResultHandle;; 117 ; 118 // The preconditions are that results and keys have the same size, are ordered the same way, and keys are unique.; 119 RResultMap(std::shared_ptr<T> &&nominalResult, std::vector<std::shared_ptr<T>> &&variedResults,; 120 std::vector<std::string> &&keys, ROOT::Detail::RDF::RLoopManager &lm,; 121 std::shared_ptr<ROOT::Internal::RDF::RActionBase> nominalAction,; 122 std",MatchSource.WIKI,doc/master/RResultMap_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultMap_8hxx_source.html
Deployability,release,release,"/// is not destroyed in the process and will still retain (shared) ownership of; 201/// the original results.; 202///; 203/// Example usage:; 204/// ~~~{.cpp}; 205/// auto df = ROOT::RDataFrame(10).Define(""x"", [] { return 1; });; 206/// auto h = df.Vary(""x"", [](){return ROOT::RVecI{-1, 2};}, {}, 2).Histo1D<int>(""x"");; 207/// auto hs = ROOT::RDF::Experimental::VariationsFor(h);; 208/// std::unique_ptr<RMergeableVariations<T>> m = ROOT::Detail::RDF::GetMergeableValue(hs);; 209/// ~~~; 210template <typename T>; 211std::unique_ptr<RMergeableVariations<T>> GetMergeableValue(ROOT::RDF::Experimental::RResultMap<T> &rmap); 212{; 213 rmap.RunEventLoopIfNeeded();; 214 ; 215 std::unique_ptr<RMergeableVariationsBase> mVariationsBase;; 216 if (rmap.fVariedAction != nullptr) {; 217 auto mValueBase = rmap.fVariedAction->GetMergeableValue();; 218 mVariationsBase.reset(static_cast<RMergeableVariationsBase *>(mValueBase.release())); // downcast unique_ptr; 219 } else {; 220 mVariationsBase = std::unique_ptr<RMergeableVariationsBase>({}, {});; 221 }; 222 mVariationsBase->AddNominal(rmap.fNominalAction->GetMergeableValue());; 223 ; 224 return std::make_unique<RMergeableVariations<T>>(std::move(*mVariationsBase));; 225}; 226} // namespace RDF; 227} // namespace Detail; 228} // namespace ROOT; 229 ; 230#endif; RActionBase.hxx; RLoopManager.hxx; RMergeableValue.hxx; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Utils.hxx; ROOT::Detail::RDF::RLoopManagerThe head node of a RDF computation graph.Definition RLoopManager.hxx:114; ROOT::Detail::RDF::RMergeableVariationsBaseA container for variation names and variation results.Definition RMergeableValue.hxx:569; ROOT::RDF::Experimental::RResultMapDefinition RResultMap.hxx:98; ROOT::RDF::Experimental::RResultMap::const_iteratortypename decltype(fMap)::const_iterator const_iteratorDefinition RResultMap.hxx:144; ROOT::RDF::Experimental::RResultMap::operator[]T & operator[](const std:",MatchSource.WIKI,doc/master/RResultMap_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultMap_8hxx_source.html
Availability,error,error,";; 92} // namespace RDF; 93} // namespace Detail; 94namespace RDF {; 95namespace RDFInternal = ROOT::Internal::RDF;; 96namespace RDFDetail = ROOT::Detail::RDF;; 97namespace TTraits = ROOT::TypeTraits;; 98 ; 99/// Smart pointer for the return type of actions; 100/**; 101\class ROOT::RDF::RResultPtr; 102\ingroup dataframe; 103\brief A wrapper around the result of RDataFrame actions able to trigger calculations lazily.; 104\tparam T Type of the action result; 105 ; 106A smart pointer which allows to access the result of a RDataFrame action. The; 107methods of the encapsulated object can be accessed via the arrow operator.; 108Upon invocation of the arrow operator or dereferencing (`operator*`), the; 109loop on the events and calculations of all scheduled actions are executed; 110if needed.; 111It is possible to iterate on the result proxy if the proxied object is a collection.; 112~~~{.cpp}; 113for (auto& myItem : myResultProxy) { ... };; 114~~~; 115If iteration is not supported by the type of the proxied object, a compilation error is thrown.; 116 ; 117*/; 118template <typename T>; 119class RResultPtr {; 120 // private using declarations; 121 using SPT_t = std::shared_ptr<T>;; 122 ; 123 // friend declarations; 124 template <typename T1>; 125 friend class RResultPtr;; 126 ; 127 template <typename T1>; 128 friend RResultPtr<T1> RDFDetail::MakeResultPtr(const std::shared_ptr<T1> &, ::ROOT::Detail::RDF::RLoopManager &,; 129 std::shared_ptr<RDFInternal::RActionBase>);; 130 ; 131 template <typename T1>; 132 friend ROOT::RDF::Experimental::RResultMap<T1> ROOT::RDF::Experimental::VariationsFor(RResultPtr<T1> resPtr);; 133 ; 134 template <class T1, class T2>; 135 friend bool operator==(const RResultPtr<T1> &lhs, const RResultPtr<T2> &rhs);; 136 template <class T1, class T2>; 137 friend bool operator!=(const RResultPtr<T1> &lhs, const RResultPtr<T2> &rhs);; 138 template <class T1>; 139 friend bool operator==(const RResultPtr<T1> &lhs, std::nullptr_t rhs);; 140 template <class T1",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
Deployability,release,release,"reated with the result wrapped by; 457/// the RResultPtr argument. The user obtains ownership of the mergeable, which; 458/// in turn holds a copy of the result of the action. The RResultPtr is not; 459/// destroyed in the process and will still retain (shared) ownership of the; 460/// original result.; 461///; 462/// Example usage:; 463/// ~~~{.cpp}; 464/// using namespace ROOT::Detail::RDF;; 465/// ROOT::RDataFrame d(""myTree"", ""file_*.root"");; 466/// auto h = d.Histo1D(""Branch_A"");; 467/// auto mergeablehisto = GetMergeableValue(h);; 468/// ~~~; 469template <typename T>; 470std::unique_ptr<RMergeableValue<T>> GetMergeableValue(RResultPtr<T> &rptr); 471{; 472 rptr.ThrowIfNull();; 473 if (!rptr.fActionPtr->HasRun()); 474 rptr.TriggerRun(); // Prevents from using `const` specifier in parameter; 475 return std::unique_ptr<RMergeableValue<T>>{; 476 static_cast<RMergeableValue<T> *>(rptr.fActionPtr->GetMergeableValue().release())};; 477}; 478} // namespace RDF; 479} // namespace Detail; 480} // namespace ROOT; 481 ; 482#endif // ROOT_TRESULTPROXY; RActionBase.hxx; RLoopManager.hxx; c#define c(i)Definition RSha256.hxx:101; RtypesCore.h; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; operator!=Bool_t operator!=(const TDatime &d1, const TDatime &d2)Definition TDatime.h:104; TError.h; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; TypeTraits.hxx; ROOT::Detail::RDF::RLoopManagerThe head node of a RDF computation graph.Definition RLoopManager.hxx:114; ROOT::Detail::RDF::RLoopManager::Runvoid Run(bool jit=true)Start the event loop with a different mechani",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
Energy Efficiency,schedul,scheduled," &r, RLoopManager &df,; 84 std::shared_ptr<ROOT::Internal::RDF::RActionBase> actionPtr);; 85 ; 86// Fwd decl for GetMergeableValue; 87template <typename T>; 88class RMergeableValue;; 89 ; 90template <typename T>; 91std::unique_ptr<RMergeableValue<T>> GetMergeableValue(RResultPtr<T> &rptr);; 92} // namespace RDF; 93} // namespace Detail; 94namespace RDF {; 95namespace RDFInternal = ROOT::Internal::RDF;; 96namespace RDFDetail = ROOT::Detail::RDF;; 97namespace TTraits = ROOT::TypeTraits;; 98 ; 99/// Smart pointer for the return type of actions; 100/**; 101\class ROOT::RDF::RResultPtr; 102\ingroup dataframe; 103\brief A wrapper around the result of RDataFrame actions able to trigger calculations lazily.; 104\tparam T Type of the action result; 105 ; 106A smart pointer which allows to access the result of a RDataFrame action. The; 107methods of the encapsulated object can be accessed via the arrow operator.; 108Upon invocation of the arrow operator or dereferencing (`operator*`), the; 109loop on the events and calculations of all scheduled actions are executed; 110if needed.; 111It is possible to iterate on the result proxy if the proxied object is a collection.; 112~~~{.cpp}; 113for (auto& myItem : myResultProxy) { ... };; 114~~~; 115If iteration is not supported by the type of the proxied object, a compilation error is thrown.; 116 ; 117*/; 118template <typename T>; 119class RResultPtr {; 120 // private using declarations; 121 using SPT_t = std::shared_ptr<T>;; 122 ; 123 // friend declarations; 124 template <typename T1>; 125 friend class RResultPtr;; 126 ; 127 template <typename T1>; 128 friend RResultPtr<T1> RDFDetail::MakeResultPtr(const std::shared_ptr<T1> &, ::ROOT::Detail::RDF::RLoopManager &,; 129 std::shared_ptr<RDFInternal::RActionBase>);; 130 ; 131 template <typename T1>; 132 friend ROOT::RDF::Experimental::RResultMap<T1> ROOT::RDF::Experimental::VariationsFor(RResultPtr<T1> resPtr);; 133 ; 134 template <class T1, class T2>; 135 friend bool operator==(const RR",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
Integrability,wrap,wrapper,"l::RDF::RLoopManager, void>>;; 63/**; 64 * \brief Creates a new RResultPtr with a cloned Snapshot action.; 65 *; 66 * \param inptr The pointer.; 67 * \param outputFileName A new name for the output file of the cloned action.; 68 * \return A new pointer with a cloned action.; 69 *; 70 * This overload is needed since cloning a Snapshot node usually also involves; 71 * changing the name of the output file, otherwise the cloned Snapshot would; 72 * overwrite the same file.; 73 */; 74SnapshotPtr_t CloneResultAndAction(const SnapshotPtr_t &inptr, const std::string &outputFileName);; 75} // namespace RDF; 76} // namespace Internal; 77 ; 78namespace Detail {; 79namespace RDF {; 80using ROOT::RDF::RResultPtr;; 81// Fwd decl for RResultPtr; 82template <typename T>; 83RResultPtr<T> MakeResultPtr(const std::shared_ptr<T> &r, RLoopManager &df,; 84 std::shared_ptr<ROOT::Internal::RDF::RActionBase> actionPtr);; 85 ; 86// Fwd decl for GetMergeableValue; 87template <typename T>; 88class RMergeableValue;; 89 ; 90template <typename T>; 91std::unique_ptr<RMergeableValue<T>> GetMergeableValue(RResultPtr<T> &rptr);; 92} // namespace RDF; 93} // namespace Detail; 94namespace RDF {; 95namespace RDFInternal = ROOT::Internal::RDF;; 96namespace RDFDetail = ROOT::Detail::RDF;; 97namespace TTraits = ROOT::TypeTraits;; 98 ; 99/// Smart pointer for the return type of actions; 100/**; 101\class ROOT::RDF::RResultPtr; 102\ingroup dataframe; 103\brief A wrapper around the result of RDataFrame actions able to trigger calculations lazily.; 104\tparam T Type of the action result; 105 ; 106A smart pointer which allows to access the result of a RDataFrame action. The; 107methods of the encapsulated object can be accessed via the arrow operator.; 108Upon invocation of the arrow operator or dereferencing (`operator*`), the; 109loop on the events and calculations of all scheduled actions are executed; 110if needed.; 111It is possible to iterate on the result proxy if the proxied object is a collection.; 112~",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
Performance,multi-thread,multi-threading,");; 291 /// TCanvas c(""c"",""x hist"");; 292 /// h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; 293 /// h->Draw(); // event loop runs here, this `Draw` is executed after the event loop is finished; 294 /// \endcode; 295 ///; 296 /// A value of 0 for everyNEvents indicates the callback must be executed only once, before running the event loop.; 297 /// A conveniece definition `kOnce` is provided to make this fact more expressive in user code (see snippet below).; 298 /// Multiple callbacks can be registered with the same RResultPtr (i.e. results of RDataFrame actions) and will; 299 /// be executed sequentially. Callbacks are executed in the order they were registered.; 300 /// The type of the value contained in a RResultPtr is also available as RResultPtr<T>::Value_t, e.g.; 301 /// \code{.cpp}; 302 /// auto h = tdf.Histo1D(""x"");; 303 /// // h.kOnce is 0; 304 /// // decltype(h)::Value_t is TH1D; 305 /// \endcode; 306 ///; 307 /// When implicit multi-threading is enabled, the callback:; 308 /// - will never be executed by multiple threads concurrently: it needs not be thread-safe. For example the snippet; 309 /// above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; 310 /// - will always be executed ""everyNEvents"": partial results will ""contain"" that number of events more from; 311 /// one call to the next; 312 /// - might be executed by a different worker thread at different times: the value of `std::this_thread::get_id()`; 313 /// might change between calls; 314 ///; 315 /// To register a callback that is called by _each_ worker thread (concurrently) every N events one can use; 316 /// OnPartialResultSlot().; 317 // clang-format on; 318 RResultPtr<T> &OnPartialResult(ULong64_t everyNEvents, std::function<void(T &)> callback); 319 {; 320 ThrowIfNull();; 321 const auto nSlots = fLoopManager->GetNSlots();; 322 auto actionPtr = fActionPtr;; 323 auto c = [nSlots, actionPtr, callback](unsigned int slot) ",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
Safety,safe,safe,");; 291 /// TCanvas c(""c"",""x hist"");; 292 /// h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; 293 /// h->Draw(); // event loop runs here, this `Draw` is executed after the event loop is finished; 294 /// \endcode; 295 ///; 296 /// A value of 0 for everyNEvents indicates the callback must be executed only once, before running the event loop.; 297 /// A conveniece definition `kOnce` is provided to make this fact more expressive in user code (see snippet below).; 298 /// Multiple callbacks can be registered with the same RResultPtr (i.e. results of RDataFrame actions) and will; 299 /// be executed sequentially. Callbacks are executed in the order they were registered.; 300 /// The type of the value contained in a RResultPtr is also available as RResultPtr<T>::Value_t, e.g.; 301 /// \code{.cpp}; 302 /// auto h = tdf.Histo1D(""x"");; 303 /// // h.kOnce is 0; 304 /// // decltype(h)::Value_t is TH1D; 305 /// \endcode; 306 ///; 307 /// When implicit multi-threading is enabled, the callback:; 308 /// - will never be executed by multiple threads concurrently: it needs not be thread-safe. For example the snippet; 309 /// above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; 310 /// - will always be executed ""everyNEvents"": partial results will ""contain"" that number of events more from; 311 /// one call to the next; 312 /// - might be executed by a different worker thread at different times: the value of `std::this_thread::get_id()`; 313 /// might change between calls; 314 ///; 315 /// To register a callback that is called by _each_ worker thread (concurrently) every N events one can use; 316 /// OnPartialResultSlot().; 317 // clang-format on; 318 RResultPtr<T> &OnPartialResult(ULong64_t everyNEvents, std::function<void(T &)> callback); 319 {; 320 ThrowIfNull();; 321 const auto nSlots = fLoopManager->GetNSlots();; 322 auto actionPtr = fActionPtr;; 323 auto c = [nSlots, actionPtr, callback](unsigned int slot) ",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
Security,access,access," namespace RDF; 76} // namespace Internal; 77 ; 78namespace Detail {; 79namespace RDF {; 80using ROOT::RDF::RResultPtr;; 81// Fwd decl for RResultPtr; 82template <typename T>; 83RResultPtr<T> MakeResultPtr(const std::shared_ptr<T> &r, RLoopManager &df,; 84 std::shared_ptr<ROOT::Internal::RDF::RActionBase> actionPtr);; 85 ; 86// Fwd decl for GetMergeableValue; 87template <typename T>; 88class RMergeableValue;; 89 ; 90template <typename T>; 91std::unique_ptr<RMergeableValue<T>> GetMergeableValue(RResultPtr<T> &rptr);; 92} // namespace RDF; 93} // namespace Detail; 94namespace RDF {; 95namespace RDFInternal = ROOT::Internal::RDF;; 96namespace RDFDetail = ROOT::Detail::RDF;; 97namespace TTraits = ROOT::TypeTraits;; 98 ; 99/// Smart pointer for the return type of actions; 100/**; 101\class ROOT::RDF::RResultPtr; 102\ingroup dataframe; 103\brief A wrapper around the result of RDataFrame actions able to trigger calculations lazily.; 104\tparam T Type of the action result; 105 ; 106A smart pointer which allows to access the result of a RDataFrame action. The; 107methods of the encapsulated object can be accessed via the arrow operator.; 108Upon invocation of the arrow operator or dereferencing (`operator*`), the; 109loop on the events and calculations of all scheduled actions are executed; 110if needed.; 111It is possible to iterate on the result proxy if the proxied object is a collection.; 112~~~{.cpp}; 113for (auto& myItem : myResultProxy) { ... };; 114~~~; 115If iteration is not supported by the type of the proxied object, a compilation error is thrown.; 116 ; 117*/; 118template <typename T>; 119class RResultPtr {; 120 // private using declarations; 121 using SPT_t = std::shared_ptr<T>;; 122 ; 123 // friend declarations; 124 template <typename T1>; 125 friend class RResultPtr;; 126 ; 127 template <typename T1>; 128 friend RResultPtr<T1> RDFDetail::MakeResultPtr(const std::shared_ptr<T1> &, ::ROOT::Detail::RDF::RLoopManager &,; 129 std::shared_ptr<RDFInternal::RActionBas",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
Usability,simpl,simplify,"nBase> fActionPtr;; 179 ; 180 /// Triggers the event loop in the RLoopManager; 181 void TriggerRun();; 182 ; 183 /// Get the pointer to the encapsulated result.; 184 /// Ownership is not transferred to the caller.; 185 /// Triggers event loop and execution of all actions booked in the associated RLoopManager.; 186 T *Get(); 187 {; 188 if (fActionPtr != nullptr && !fActionPtr->HasRun()); 189 TriggerRun();; 190 return fObjPtr.get();; 191 }; 192 ; 193 void ThrowIfNull(); 194 {; 195 if (fObjPtr == nullptr); 196 throw std::runtime_error(""Trying to access the contents of a null RResultPtr."");; 197 }; 198 ; 199 RResultPtr(std::shared_ptr<T> objPtr, RDFDetail::RLoopManager *lm,; 200 std::shared_ptr<RDFInternal::RActionBase> actionPtr); 201 : fLoopManager(lm), fObjPtr(std::move(objPtr)), fActionPtr(std::move(actionPtr)); 202 {; 203 }; 204 ; 205public:; 206 using Value_t = T; ///< Convenience alias to simplify access to proxied type; 207 static constexpr ULong64_t kOnce = 0ull; ///< Convenience definition to express a callback must be executed once; 208 ; 209 RResultPtr() = default;; 210 RResultPtr(const RResultPtr &) = default;; 211 RResultPtr(RResultPtr &&) = default;; 212 RResultPtr &operator=(const RResultPtr &) = default;; 213 RResultPtr &operator=(RResultPtr &&) = default;; 214 explicit operator bool() const { return bool(fObjPtr); }; 215 ; 216 /// Convert a RResultPtr<T2> to a RResultPtr<T>.; 217 ///; 218 /// Useful e.g. to store a number of RResultPtr<TH1D> and RResultPtr<TH2D> in a std::vector<RResultPtr<TH1>>.; 219 /// The requirements on T2 and T are the same as for conversion between std::shared_ptr<T2> and std::shared_ptr<T>.; 220 template <typename T2,; 221 std::enable_if_t<std::is_constructible<std::shared_ptr<T>, std::shared_ptr<T2>>::value, int> = 0>; 222 RResultPtr(const RResultPtr<T2> &r) : fLoopManager(r.fLoopManager), fObjPtr(r.fObjPtr), fActionPtr(r.fActionPtr); 223 {; 224 }; 225 ; 226 /// Get a const reference to the encapsulated object.; 227 /// Trigger",MatchSource.WIKI,doc/master/RResultPtr_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html
Integrability,depend,dependency,". ROOT: net/auth/src/rsalib.cxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions |; Variables ; rsalib.cxx File Reference. #include <stdio.h>; #include <string.h>; #include <ctype.h>; #include <stdlib.h>; #include <errno.h>; #include ""rsaaux.h""; #include ""rsalib.h"". Include dependency graph for rsalib.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Functions; void num_init ();  ; void rsa_assign (rsa_NUMBER *d, rsa_NUMBER *s);  ; int rsa_cmp (rsa_NUMBER *c1, rsa_NUMBER *c2);  ; int rsa_decode (char *bufin, int lin, rsa_NUMBER n, rsa_NUMBER e);  ; int rsa_encode (char *bufin, int lin, rsa_NUMBER n, rsa_NUMBER e);  ; int rsa_encode_size (rsa_NUMBER n);  ; rsa_NUMBER rsa_genprim (int len, int prob);  ; int rsa_genrsa (rsa_NUMBER p1, rsa_NUMBER p2, rsa_NUMBER *n, rsa_NUMBER *e, rsa_NUMBER *d);  ; int rsa_num_fget (rsa_NUMBER *n, FILE *f);  ; int rsa_num_fput (rsa_NUMBER *n, FILE *f);  ; int rsa_num_sget (rsa_NUMBER *n, char *s);  ; int rsa_num_sput (rsa_NUMBER *n, char *s, int l);  . Variables; static int g_clear_siz;  ; static int g_enc_siz;  ; static rsa_NUMBER gbits [9];  ; static const char * gHEX =""0123456789ABCDEF"";  ; static const char * ghex =""0123456789abcdef"";  ; static int ginit = 0;  ; static rsa_NUMBER gint16 [16];  ; int gLog = 0;  ; int kMAXT = 100;  . Function Documentation. ◆ num_init(). void num_init ; (; ). Definition at line 258 of file rsalib.cxx. ◆ rsa_assign(). void rsa_assign ; (; rsa_NUMBER * ; d, . rsa_NUMBER * ; s . ). Definition at line 487 of file rsalib.cxx. ◆ rsa_cmp(). int rsa_cmp ; (; rsa_NUMBER * ; c1, . rsa_NUMBER * ; c2 . ). Definition at line 476 of file rsalib.cxx. ◆ rsa_decode(). int rsa_decode ; (; char * ; bufin, . int ; lin, . rsa_NUMBER ; n, . rsa_NUMBER ; e . ). Definition at line 177 of file rsalib.cxx. ◆ rsa_encode(). int rsa_encode ; (; char * ; bufin, . int ; lin, . rsa_NUMBER ; n, . rsa_NUMBER ; e . ). Definition at line 13",MatchSource.WIKI,doc/master/rsalib_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rsalib_8cxx.html
Safety,abort,abort,"_NUMBER io; 222 */; 223 ; 224/*; 225 * Funktionen; 226 *; 227 * int num_sput( n, s, l); 228 * rsa_NUMBER *n;; 229 * char s[l];; 230 * schreibt *n als Hex-Zahl in s; 231 *; 232 * int num_fput( n, f ); 233 * rsa_NUMBER *n;; 234 * FILE *f;; 235 * schreibt *n als Hex-Zahl in File f; 236 *; 237 * int num_sget( n, s ); 238 * rsa_NUMBER *n;; 239 * char *s;; 240 * liest Hex-Zahl s in *n ein; 241 *; 242 * int num_fget( n, f ); 243 * rsa_NUMBER *n;; 244 * FILE *f;; 245 * liest eine Hex-Zahl von f in *n ein; 246 *; 247 */; 248 ; 249 ; 250static const char *gHEX=""0123456789ABCDEF"";; 251static const char *ghex=""0123456789abcdef"";; 252 ; 253static rsa_NUMBER gbits[9];; 254static rsa_NUMBER gint16[16];; 255 ; 256static int ginit = 0;; 257 ; 258void num_init(); 259{; 260 int i;; 261 ; 262 if (ginit) return;; 263 ; 264 a_assign( &gbits[0], &a_one );; 265 for ( i=1; i<9; i++); 266 a_add( &gbits[i-1], &gbits[i-1], &gbits[i] );; 267 ; 268 a_assign( &gint16[0], &a_one );; 269 for ( i=1; i<16; i++); 270 a_add( &gint16[i-1], &a_one, &gint16[i] );; 271 ; 272 ginit = 1;; 273}; 274 ; 275 ; 276int rsa_num_sput(rsa_NUMBER *n, char *s, int l); 277{; 278#if rsa_MAXINT == ( (1 << rsa_MAXBIT) - 1 ); 279 rsa_INT *p;; 280 int bi,ab,i;; 281 long b;; 282 int first = 1;; 283 ; 284 bi = rsa_MAXBIT * n->n_len;; 285 ab = 4 - (bi + 3) % 4 -1;; 286 p = &n->n_part[n->n_len -1];; 287 ; 288 if ( (bi+3) / 4 >= l ); 289 return(EOF);; 290 ; 291 b = 0;; 292 while (bi) {; 293 b <<= (rsa_MAXBIT);; 294 b |= (unsigned long)*p--;; 295 bi -= rsa_MAXBIT;; 296 ab += rsa_MAXBIT;; 297 while (ab >= 4) {; 298 i = (b >> (ab - 4));; 299 b &= ( 1L << (ab - 4)) -1L;; 300 ab -= 4;; 301 ; 302 if (first && !i); 303 continue;; 304 first = 0;; 305 *s++ = gHEX[ i ];; 306 }; 307 }; 308 if (b); 309 abort();; 310 *s = '\0';; 311 ; 312 return (0);; 313#else; 314 rsa_NUMBER r,q;; 315 int i,b,p,len,low,high;; 316 char *np;; 317 ; 318 if (! ginit); 319 num_init();; 320 ; 321 a_assign( &q, n);; 322 len = l;; 323 np = s + l;; 324 ; 325 for (; q.",MatchSource.WIKI,doc/master/rsalib_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rsalib_8cxx_source.html
Usability,clear,clear-text,"License along with this library; if not, write to the Free; 20Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,; 21MA 02110-1301 USA; 22******************************************************************************/; 23 ; 24/*******************************************************************************; 25* *; 26* Simple RSA public key code. *; 27* Adaptation in library for ROOT by G. Ganis, July 2003 *; 28* (gerardo.ganis@cern.ch) *; 29* *; 30*******************************************************************************/; 31 ; 32#include <stdio.h>; 33#include <string.h>; 34#include <ctype.h>; 35#include <stdlib.h>; 36#include <errno.h>; 37 ; 38#include ""rsaaux.h""; 39#include ""rsalib.h""; 40 ; 41static int g_clear_siz; /* clear-text blocksize */; 42static int g_enc_siz; /* encoded blocksize */; 43 /* g_clear_siz < g_enc_siz */; 44 ; 45int gLog = 0;; 46int kMAXT = 100;; 47 ; 48rsa_NUMBER rsa_genprim(int len, int prob); 49{; 50 rsa_NUMBER a_three,a_four;; 51 rsa_NUMBER prim;; 52 int i;; 53 ; 54 a_add( &a_one, &a_two, &a_three );; 55 a_add( &a_two, &a_two, &a_four );; 56 ; 57 /* This is done elsewhere to allow different initialization of; 58 rand seed (GGa - Sep 15, 2003) */; 59 /* init_rnd(); */; 60 ; 61 do {; 62 gen_number( len, &prim );; 63 } while ( !prim.n_len );; 64 ; 65 a_mult( &prim, &a_two, &prim );; 66 a_mult( &prim, &a_three, &prim );; 67 a_add( &prim, &a_one, &prim );; 68 ; 69 for (i=1 ;; i++) {; 70 ; 71 if (p_prim( &prim, prob )); 72 break;; 73 if (i % 2); 74 a_add( &prim, &a_four, &prim );; 75 else; 76 a_add( &prim, &a_two, &prim );; 77 }; 78 ; 79 return prim;; 80}; 81 ; 82int rsa_genrsa(rsa_NUMBER p1, rsa_NUMBER p2, rsa_NUMBER *n, rsa_NUMBER *e, rsa_NUMBER *d); 83{; 84 rsa_NUMBER phi, *max_p;; 85 int len;; 86 int ii, jj;; 87 ; 88 if ( !a_cmp( &p1, &p2) ) return 1;; 89 ; 90 if (a_cmp( &p1, &p2) > 0); 91 max_p = &p1;; 92 else; 93 max_p = &p2;; 94 ; 95 ; 96 a_mult( &p1, &p2, n );; 97 a_sub( &p1, &a_one, &phi );; 98 a_sub( &p2, &a_one, e );; 99",MatchSource.WIKI,doc/master/rsalib_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rsalib_8cxx_source.html
Availability,avail,available,"clude <Rtypes.h>; 17 ; 18#include <functional>; 19#include <stdexcept>; 20#include <string>; 21 ; 22#include <tuple>; 23 ; 24namespace ROOT {; 25namespace RDF {; 26 ; 27/// This type represents a sample identifier, to be used in conjunction with RDataFrame features such as; 28/// \ref ROOT::RDF::RInterface< Proxied, DS_t >::DefinePerSample ""DefinePerSample()"" and per-sample callbacks.; 29///; 30/// When the input data comes from a TTree, the string representation of RSampleInfo (which is returned by AsString(); 31/// and that can be queried e.g. with Contains()) is of the form ""<filename>/<treename>"".; 32///; 33/// In multi-thread runs, different tasks might process different entry ranges of the same sample,; 34/// so RSampleInfo also provides methods to inspect which part of a sample is being taken into consideration.; 35class RSampleInfo {; 36 std::string fID;; 37 std::pair<ULong64_t, ULong64_t> fEntryRange;; 38 ; 39 const ROOT::RDF::Experimental::RSample *fSample = nullptr; // non-owning; 40 ; 41 void ThrowIfNoSample() const; 42 {; 43 if (fSample == nullptr) {; 44 const auto msg = ""RSampleInfo: sample data was requested but no samples are available."";; 45 throw std::logic_error(msg);; 46 }; 47 }; 48 ; 49public:; 50 RSampleInfo(std::string_view id, std::pair<ULong64_t, ULong64_t> entryRange,; 51 const ROOT::RDF::Experimental::RSample *sample = nullptr); 52 : fID(id), fEntryRange(entryRange), fSample(sample); 53 {; 54 }; 55 RSampleInfo() = default;; 56 RSampleInfo(const RSampleInfo &) = default;; 57 RSampleInfo &operator=(const RSampleInfo &) = default;; 58 RSampleInfo(RSampleInfo &&) = default;; 59 RSampleInfo &operator=(RSampleInfo &&) = default;; 60 ~RSampleInfo() = default;; 61 ; 62 /// @brief Get the name of the sample as a string.; 63 const std::string &GetSampleName() const; 64 {; 65 ThrowIfNoSample();; 66 return fSample->GetSampleName();; 67 }; 68 ; 69 /// @brief Get the sample id as an int.; 70 unsigned int GetSampleId() const; 71 {; 72 ThrowIfNoSample();;",MatchSource.WIKI,doc/master/RSampleInfo_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSampleInfo_8hxx_source.html
Performance,multi-thread,multi-thread,"* For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11#ifndef ROOT_RDF_RSAMPLEINFO; 12#define ROOT_RDF_RSAMPLEINFO; 13 ; 14#include <ROOT/RDF/RSample.hxx>; 15#include <string_view>; 16#include <Rtypes.h>; 17 ; 18#include <functional>; 19#include <stdexcept>; 20#include <string>; 21 ; 22#include <tuple>; 23 ; 24namespace ROOT {; 25namespace RDF {; 26 ; 27/// This type represents a sample identifier, to be used in conjunction with RDataFrame features such as; 28/// \ref ROOT::RDF::RInterface< Proxied, DS_t >::DefinePerSample ""DefinePerSample()"" and per-sample callbacks.; 29///; 30/// When the input data comes from a TTree, the string representation of RSampleInfo (which is returned by AsString(); 31/// and that can be queried e.g. with Contains()) is of the form ""<filename>/<treename>"".; 32///; 33/// In multi-thread runs, different tasks might process different entry ranges of the same sample,; 34/// so RSampleInfo also provides methods to inspect which part of a sample is being taken into consideration.; 35class RSampleInfo {; 36 std::string fID;; 37 std::pair<ULong64_t, ULong64_t> fEntryRange;; 38 ; 39 const ROOT::RDF::Experimental::RSample *fSample = nullptr; // non-owning; 40 ; 41 void ThrowIfNoSample() const; 42 {; 43 if (fSample == nullptr) {; 44 const auto msg = ""RSampleInfo: sample data was requested but no samples are available."";; 45 throw std::logic_error(msg);; 46 }; 47 }; 48 ; 49public:; 50 RSampleInfo(std::string_view id, std::pair<ULong64_t, ULong64_t> entryRange,; 51 const ROOT::RDF::Experimental::RSample *sample = nullptr); 52 : fID(id), fEntryRange(entryRange), fSample(sample); 53 {; 54 }; 55 RSampleInfo() = default;; 56 RSampleInfo(const RSampleInfo &) = default;; 57 RSampleInfo &operator=(const RSampleInfo &) = default;; 58 RSampleInfo(RSampleInfo &&) = default;; 59 RSampleInfo &operator=(RSampleInfo &&) = default;; 60 ~RSampleInfo() = default;; 61 ; 62 //",MatchSource.WIKI,doc/master/RSampleInfo_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSampleInfo_8hxx_source.html
Integrability,depend,dependency,". ROOT: core/foundation/res/ROOT/RSha256.hxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Macros |; Typedefs |; Functions |; Variables ; RSha256.hxx File Reference. #include ""Rtypes.h""; #include <iostream>; #include <stdlib.h>; #include <stdint.h>. Include dependency graph for RSha256.hxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  ROOT::Internal::SHA256::sha256_t;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  ; namespace  ROOT::Internal::SHA256;  . Macros; #define _SHA256_UNROLL;  ; #define _SHA256_UNROLL2;  ; #define a(i)   T[(0 - (i)) & 7];  ; #define b(i)   T[(1 - (i)) & 7];  ; #define blk0(i)   (W[i] = data[i]);  ; #define blk2(i)   (W[i & 15] += s1(W[(i - 2) & 15]) + W[(i - 7) & 15] + s0(W[(i - 15) & 15]));  ; #define c(i)   T[(2 - (i)) & 7];  ; #define Ch(x, y, z)   (z ^ (x & (y ^ z)));  ; #define d(i)   T[(3 - (i)) & 7];  ; #define e(i)   T[(4 - (i)) & 7];  ; #define f(i)   T[(5 - (i)) & 7];  ; #define g(i)   T[(6 - (i)) & 7];  ; #define h(i)   T[(7 - (i)) & 7];  ; #define Maj(x, y, z)   ((x & y) | (z & (x | y)));  ; #define R(a, b, c, d, e, f, g, h, i);  ; #define ROTL16(v, n)   (U16V((uint16_t)(v) << (n)) | ((uint16_t)(v) >> (16 - (n))));  ; #define ROTL32(v, n)   (U32V((uint32_t)(v) << (n)) | ((uint32_t)(v) >> (32 - (n))));  ; #define ROTL64(v, n)   (U64V((uint64_t)(v) << (n)) | ((uint64_t)(v) >> (64 - (n))));  ; #define ROTL8(v, n)   (U8V((uint8_t)(v) << (n)) | ((uint8_t)(v) >> (8 - (n))));  ; #define ROTR16(v, n)   ROTL16(v, 16 - (n));  ; #define ROTR32(v, n)   ROTL32(v, 32 - (n));  ; #define",MatchSource.WIKI,doc/master/RSha256_8hxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSha256_8hxx.html
Integrability,interface,interface,"; 199#else; 200 for (j = 0; j < 8; j++); 201 state[j] += T[j];; 202#endif; 203 ; 204 /* Wipe variables */; 205 /* memset(W, 0, sizeof(W)); */; 206 /* memset(T, 0, sizeof(T)); */; 207}; 208 ; 209#undef S0; 210#undef S1; 211#undef s0; 212#undef s1; 213 ; 214static void sha256_write_byte_block(sha256_t *p); 215{; 216 uint32_t data32[16];; 217 unsigned i;; 218 for (i = 0; i < 16; i++); 219 data32[i] = ((uint32_t)(p->buffer[i * 4]) << 24) + ((uint32_t)(p->buffer[i * 4 + 1]) << 16) +; 220 ((uint32_t)(p->buffer[i * 4 + 2]) << 8) + ((uint32_t)(p->buffer[i * 4 + 3]));; 221 sha256_transform(p->state, data32);; 222}; 223 ; 224void sha256_update(sha256_t *p, const unsigned char *data, size_t size); 225{; 226 uint32_t curBufferPos = (uint32_t)p->count & 0x3F;; 227 while (size > 0) {; 228 p->buffer[curBufferPos++] = *data++;; 229 p->count++;; 230 size--;; 231 if (curBufferPos == 64) {; 232 curBufferPos = 0;; 233 sha256_write_byte_block(p);; 234 }; 235 }; 236}; 237 ; 238void sha256_final(sha256_t *p, unsigned char *digest); 239{; 240 uint64_t lenInBits = (p->count << 3);; 241 uint32_t curBufferPos = (uint32_t)p->count & 0x3F;; 242 unsigned i;; 243 p->buffer[curBufferPos++] = 0x80;; 244 while (curBufferPos != (64 - 8)) {; 245 curBufferPos &= 0x3F;; 246 if (curBufferPos == 0); 247 sha256_write_byte_block(p);; 248 p->buffer[curBufferPos++] = 0;; 249 }; 250 for (i = 0; i < 8; i++) {; 251 p->buffer[curBufferPos++] = (unsigned char)(lenInBits >> 56);; 252 lenInBits <<= 8;; 253 }; 254 sha256_write_byte_block(p);; 255 ; 256 for (i = 0; i < 8; i++) {; 257 *digest++ = (unsigned char)(p->state[i] >> 24);; 258 *digest++ = (unsigned char)(p->state[i] >> 16);; 259 *digest++ = (unsigned char)(p->state[i] >> 8);; 260 *digest++ = (unsigned char)(p->state[i]);; 261 }; 262 sha256_init(p);; 263}; 264 ; 265} // End NS SHA256; 266 ; 267void Sha256(const unsigned char *data, int len, ULong64_t *fDigest); 268{; 269 // Here the final cast is to match the interface of the C code and; 270 // the data member.",MatchSource.WIKI,doc/master/RSha256_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSha256_8hxx_source.html
Modifiability,variab,variables,"tic void sha256_transform(uint32_t *state, const uint32_t *data); 159{; 160 uint32_t W[16] = {0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U};; 161 unsigned j;; 162#ifdef _SHA256_UNROLL2; 163 uint32_t a, b, c, d, e, f, g, h;; 164 a = state[0];; 165 b = state[1];; 166 c = state[2];; 167 d = state[3];; 168 e = state[4];; 169 f = state[5];; 170 g = state[6];; 171 h = state[7];; 172#else; 173 uint32_t T[8];; 174 for (j = 0; j < 8; j++); 175 T[j] = state[j];; 176#endif; 177 ; 178 for (j = 0; j < 64; j += 16) {; 179#if defined(_SHA256_UNROLL) || defined(_SHA256_UNROLL2); 180 RX_8(0);; 181 RX_8(8);; 182#else; 183 unsigned i;; 184 for (i = 0; i < 16; i++) {; 185 R(i);; 186 }; 187#endif; 188 }; 189 ; 190#ifdef _SHA256_UNROLL2; 191 state[0] += a;; 192 state[1] += b;; 193 state[2] += c;; 194 state[3] += d;; 195 state[4] += e;; 196 state[5] += f;; 197 state[6] += g;; 198 state[7] += h;; 199#else; 200 for (j = 0; j < 8; j++); 201 state[j] += T[j];; 202#endif; 203 ; 204 /* Wipe variables */; 205 /* memset(W, 0, sizeof(W)); */; 206 /* memset(T, 0, sizeof(T)); */; 207}; 208 ; 209#undef S0; 210#undef S1; 211#undef s0; 212#undef s1; 213 ; 214static void sha256_write_byte_block(sha256_t *p); 215{; 216 uint32_t data32[16];; 217 unsigned i;; 218 for (i = 0; i < 16; i++); 219 data32[i] = ((uint32_t)(p->buffer[i * 4]) << 24) + ((uint32_t)(p->buffer[i * 4 + 1]) << 16) +; 220 ((uint32_t)(p->buffer[i * 4 + 2]) << 8) + ((uint32_t)(p->buffer[i * 4 + 3]));; 221 sha256_transform(p->state, data32);; 222}; 223 ; 224void sha256_update(sha256_t *p, const unsigned char *data, size_t size); 225{; 226 uint32_t curBufferPos = (uint32_t)p->count & 0x3F;; 227 while (size > 0) {; 228 p->buffer[curBufferPos++] = *data++;; 229 p->count++;; 230 size--;; 231 if (curBufferPos == 64) {; 232 curBufferPos = 0;; 233 sha256_write_byte_block(p);; 234 }; 235 }; 236}; 237 ; 238void sha256_final(sha256_t *p, unsigned char *digest); 239{; 240 uint64_t lenInBits = (p->count << 3);; 241 uint32_t curBufferPo",MatchSource.WIKI,doc/master/RSha256_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSha256_8hxx_source.html
Performance,optimiz,optimization,"; 44#define ROTL64(v, n) (U64V((uint64_t)(v) << (n)) | ((uint64_t)(v) >> (64 - (n)))); 45 ; 46#define ROTR32(v, n) ROTL32(v, 32 - (n)); 47#define ROTR64(v, n) ROTL64(v, 64 - (n)); 48 ; 49#endif; 50 ; 51#define ROTL8(v, n) (U8V((uint8_t)(v) << (n)) | ((uint8_t)(v) >> (8 - (n)))); 52 ; 53#define ROTL16(v, n) (U16V((uint16_t)(v) << (n)) | ((uint16_t)(v) >> (16 - (n)))); 54 ; 55#define ROTR8(v, n) ROTL8(v, 8 - (n)); 56#define ROTR16(v, n) ROTL16(v, 16 - (n)); 57 ; 58#define SHA256_DIGEST_SIZE 32; 59 ; 60typedef struct sha256_t {; 61 uint32_t stat",MatchSource.WIKI,doc/master/RSha256_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSha256_8hxx_source.html
Security,hash,hash,"[curBufferPos++] = 0x80;; 244 while (curBufferPos != (64 - 8)) {; 245 curBufferPos &= 0x3F;; 246 if (curBufferPos == 0); 247 sha256_write_byte_block(p);; 248 p->buffer[curBufferPos++] = 0;; 249 }; 250 for (i = 0; i < 8; i++) {; 251 p->buffer[curBufferPos++] = (unsigned char)(lenInBits >> 56);; 252 lenInBits <<= 8;; 253 }; 254 sha256_write_byte_block(p);; 255 ; 256 for (i = 0; i < 8; i++) {; 257 *digest++ = (unsigned char)(p->state[i] >> 24);; 258 *digest++ = (unsigned char)(p->state[i] >> 16);; 259 *digest++ = (unsigned char)(p->state[i] >> 8);; 260 *digest++ = (unsigned char)(p->state[i]);; 261 }; 262 sha256_init(p);; 263}; 264 ; 265} // End NS SHA256; 266 ; 267void Sha256(const unsigned char *data, int len, ULong64_t *fDigest); 268{; 269 // Here the final cast is to match the interface of the C code and; 270 // the data member. The length is the same!; 271 SHA256::sha256_t hash;; 272 SHA256::sha256_init(&hash);; 273 SHA256::sha256_update(&hash, data, len);; 274 SHA256::sha256_final(&hash, reinterpret_cast<unsigned char *>(fDigest));; 275}; 276 ; 277} // End NS Internal; 278} // End NS ROOT; 279 ; 280#endif; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; RX_8#define RX_8(i)Definition RSha256.hxx:115; g#define g(i)Definition RSha256.hxx:105; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; Rtypes.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; lenOption_t Option_t TPoint TPoint const char GetTextMag",MatchSource.WIKI,doc/master/RSha256_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSha256_8hxx_source.html
Testability,test,tests,"ha256.hxx. Go to the documentation of this file. 1// Author: Danilo Piparo May 2018; 2// Inspired by public domain code of Igor Pavlov: https://github.com/jb55/sha256.c; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2018, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_RSHA; 13#define ROOT_RSHA; 14 ; 15#include ""Rtypes.h""; 16 ; 17#include <iostream>; 18#include <stdlib.h>; 19#include <stdint.h>; 20 ; 21 ; 22namespace ROOT {; 23namespace Internal {; 24namespace SHA256 {; 25 ; 26#ifdef _MSC_VER; 27 ; 28#define ROTL32(v, n) _rotl((v), (n)); 29#define ROTL64(v, n) _rotl64((v), (n)); 30 ; 31#define ROTR32(v, n) _rotr((v), (n)); 32#define ROTR64(v, n) _rotr64((v), (n)); 33 ; 34#else; 35 ; 36#define U8V(v) ((uint8_t)(v)&0xFFU); 37#define U16V(v) ((uint16_t)(v)&0xFFFFU); 38#define U32V(v) ((uint32_t)(v)&0xFFFFFFFFU); 39#define U64V(v) ((uint64_t)(v)&0xFFFFFFFFFFFFFFFFU); 40 ; 41#define ROTL32(v, n) (U32V((uint32_t)(v) << (n)) | ((uint32_t)(v) >> (32 - (n)))); 42 ; 43// tests fail if we don't have this cast...; 44#define ROTL64(v, n) (U64V((uint64_t)(v) << (n)) | ((uint64_t)(v) >> (64 - (n)))); 45 ; 46#define ROTR32(v, n) ROTL32(v, 32 - (n)); 47#define ROTR64(v, n) ROTL64(v, 64 - (n)); 48 ; 49#endif; 50 ; 51#define ROTL8(v, n) (U8V((uint8_t)(v) << (n)) | ((uint8_t)(v) >> (8 - (n)))); 52 ; 53#define ROTL16(v, n) (U16V((uint16_t)(v) << (n)) | ((uint16_t)(v) >> (16 - (n)))); 54 ; 55#define ROTR8(v, n) ROTL8(v, 8 - (n)); 56#define ROTR16(v, n) ROTL16(v, 16 - (n)); 57 ; 58#define SHA256_DIGEST_SIZE 32; 59 ; 60typedef struct sha256_t {; 61 uint32_t state[8];; 62 uint64_t count;; 63 unsigned char buffer[64];; 64} sha256_t;; 65 ; 66void sha256_init(sha256_t *p);; 67void sha256_update(sha256_t ",MatchSource.WIKI,doc/master/RSha256_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSha256_8hxx_source.html
Availability,avail,available," *************************************************************************/; 10 ; 11#include <ROOT/RSqliteDS.hxx>; 12#include <ROOT/RRawFile.hxx>; 13 ; 14#include ""TError.h""; 15#include ""TRandom.h""; 16#include ""TSystem.h""; 17 ; 18#include <algorithm>; 19#include <cctype>; 20#include <cerrno>; 21#include <cstring> // for memcpy; 22#include <ctime>; 23#include <memory> // for placement new; 24#include <stdexcept>; 25#include <utility>; 26 ; 27#include <sqlite3.h>; 28 ; 29namespace {; 30 ; 31// In order to provide direct access to remote sqlite files through HTTP and HTTPS, this datasource provides a custom; 32// ""SQlite VFS module"" that uses Davix for data access. The SQlite VFS modules are roughly what TSystem is; 33// for ROOT -- an abstraction of the operating system interface.; 34//; 35// SQlite allows for registering custom VFS modules, which are a set of C callback functions that SQlite invokes when; 36// it needs to read from a file, write to a file, etc. More information is available under https://sqlite.org/vfs.html; 37//; 38// In the context of a data source, SQlite will only ever call reading functions from the VFS module, the sqlite; 39// files are not modified. Therefore, only a subset of the callback functions provide a non-trivial implementation.; 40// The custom VFS module uses a RRawFile for the byte access, thereby it can access local and remote files.; 41 ; 42////////////////////////////////////////////////////////////////////////////; 43/// SQlite VFS modules are identified by string names. The name has to be unique for the entire application.; 44constexpr char const *gSQliteVfsName = ""ROOT-Davix-readonly"";; 45 ; 46////////////////////////////////////////////////////////////////////////////; 47/// Holds the state of an open sqlite database. Objects of this struct are created in VfsRdOnlyOpen(); 48/// and then passed by sqlite to the file I/O callbacks (read, close, etc.). This uses C style inheritance; 49/// where the struct starts with a sqlite3_f",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
Energy Efficiency,allocate,allocated,"ersion 1 was introduced with sqlite 3.6, version 2 with sqlite 3.7.8, version 3 with sqlite 3.7.17; 160 sqlite3_io_methods io_methods;; 161 memset(&io_methods, 0, sizeof(io_methods));; 162 io_methods.iVersion = 1;; 163 io_methods.xClose = VfsRdOnlyClose;; 164 io_methods.xRead = VfsRdOnlyRead;; 165 io_methods.xWrite = VfsRdOnlyWrite;; 166 io_methods.xTruncate = VfsRdOnlyTruncate;; 167 io_methods.xSync = VfsRdOnlySync;; 168 io_methods.xFileSize = VfsRdOnlyFileSize;; 169 io_methods.xLock = VfsRdOnlyLock;; 170 io_methods.xUnlock = VfsRdOnlyUnlock;; 171 io_methods.xCheckReservedLock = VfsRdOnlyCheckReservedLock;; 172 io_methods.xFileControl = VfsRdOnlyFileControl;; 173 io_methods.xSectorSize = VfsRdOnlySectorSize;; 174 io_methods.xDeviceCharacteristics = VfsRdOnlyDeviceCharacteristics;; 175 return io_methods;; 176}; 177 ; 178////////////////////////////////////////////////////////////////////////////; 179/// Fills a new VfsRootFile struct enclosing a Davix file; 180int VfsRdOnlyOpen(sqlite3_vfs * /*vfs*/, const char *zName, sqlite3_file *pFile, int flags, int * /*pOutFlags*/); 181{; 182 // Storage for the VfsRootFile structure has been already allocated by sqlite, so we use placement new; 183 VfsRootFile *p = new (pFile) VfsRootFile();; 184 p->pFile.pMethods = nullptr;; 185 ; 186 // This global struct contains the function pointers to all the callback operations that act on an open database.; 187 // It is passed via the pFile struct back to sqlite so that it can call back to the functions provided above.; 188 static const sqlite3_io_methods io_methods = GetSqlite3IoMethods();; 189 ; 190 if (flags & (SQLITE_OPEN_READWRITE | SQLITE_OPEN_DELETEONCLOSE | SQLITE_OPEN_EXCLUSIVE)); 191 return SQLITE_IOERR;; 192 ; 193 p->fRawFile = ROOT::Internal::RRawFile::Create(zName);; 194 if (!p->fRawFile) {; 195 ::Error(""VfsRdOnlyOpen"", ""Cannot open %s\n"", zName);; 196 return SQLITE_IOERR;; 197 }; 198 ; 199 p->pFile.pMethods = &io_methods;; 200 return SQLITE_OK;; 201}; 202 ; 203// The foll",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
Integrability,interface,interface,"****************************************************; 4 * Copyright (C) 1995-2017, Rene Brun and Fons Rademakers. *; 5 * All rights reserved. *; 6 * *; 7 * For the licensing terms see $ROOTSYS/LICENSE. *; 8 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11#include <ROOT/RSqliteDS.hxx>; 12#include <ROOT/RRawFile.hxx>; 13 ; 14#include ""TError.h""; 15#include ""TRandom.h""; 16#include ""TSystem.h""; 17 ; 18#include <algorithm>; 19#include <cctype>; 20#include <cerrno>; 21#include <cstring> // for memcpy; 22#include <ctime>; 23#include <memory> // for placement new; 24#include <stdexcept>; 25#include <utility>; 26 ; 27#include <sqlite3.h>; 28 ; 29namespace {; 30 ; 31// In order to provide direct access to remote sqlite files through HTTP and HTTPS, this datasource provides a custom; 32// ""SQlite VFS module"" that uses Davix for data access. The SQlite VFS modules are roughly what TSystem is; 33// for ROOT -- an abstraction of the operating system interface.; 34//; 35// SQlite allows for registering custom VFS modules, which are a set of C callback functions that SQlite invokes when; 36// it needs to read from a file, write to a file, etc. More information is available under https://sqlite.org/vfs.html; 37//; 38// In the context of a data source, SQlite will only ever call reading functions from the VFS module, the sqlite; 39// files are not modified. Therefore, only a subset of the callback functions provide a non-trivial implementation.; 40// The custom VFS module uses a RRawFile for the byte access, thereby it can access local and remote files.; 41 ; 42////////////////////////////////////////////////////////////////////////////; 43/// SQlite VFS modules are identified by string names. The name has to be unique for the entire application.; 44constexpr char const *gSQliteVfsName = ""ROOT-Davix-readonly"";; 45 ; 46/////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
Modifiability,inherit,inheritance," https://sqlite.org/vfs.html; 37//; 38// In the context of a data source, SQlite will only ever call reading functions from the VFS module, the sqlite; 39// files are not modified. Therefore, only a subset of the callback functions provide a non-trivial implementation.; 40// The custom VFS module uses a RRawFile for the byte access, thereby it can access local and remote files.; 41 ; 42////////////////////////////////////////////////////////////////////////////; 43/// SQlite VFS modules are identified by string names. The name has to be unique for the entire application.; 44constexpr char const *gSQliteVfsName = ""ROOT-Davix-readonly"";; 45 ; 46////////////////////////////////////////////////////////////////////////////; 47/// Holds the state of an open sqlite database. Objects of this struct are created in VfsRdOnlyOpen(); 48/// and then passed by sqlite to the file I/O callbacks (read, close, etc.). This uses C style inheritance; 49/// where the struct starts with a sqlite3_file member (base class) which is extended by members related to; 50/// this particular VFS module. Every callback here thus casts the sqlite3_file input parameter to its ""derived""; 51/// type VfsRootFile.; 52struct VfsRootFile {; 53 VfsRootFile() = default;; 54 ; 55 sqlite3_file pFile;; 56 std::unique_ptr<ROOT::Internal::RRawFile> fRawFile;; 57};; 58 ; 59// The following callbacks implement the I/O operations of an open database; 60 ; 61////////////////////////////////////////////////////////////////////////////; 62/// Releases the resources associated to a file opened with davix; 63int VfsRdOnlyClose(sqlite3_file *pFile); 64{; 65 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 66 // We can't use delete because the storage for p is managed by sqlite; 67 p->~VfsRootFile();; 68 return SQLITE_OK;; 69}; 70 ; 71////////////////////////////////////////////////////////////////////////////; 72/// Issues a byte range request for a chunk to the raw file; 73int VfsRdOnlyRead(sqlite3_file *pFile, ",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
Performance,cache,cached,"/////////////////////////////////////; 81/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 82int VfsRdOnlyWrite(sqlite3_file * /*pFile*/, const void * /*zBuf*/, int /*iAmt*/, sqlite_int64 /*iOfst*/); 83{; 84 return SQLITE_OPEN_READONLY;; 85}; 86 ; 87////////////////////////////////////////////////////////////////////////////; 88/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 89int VfsRdOnlyTruncate(sqlite3_file * /*pFile*/, sqlite_int64 /*size*/); 90{; 91 return SQLITE_OPEN_READONLY;; 92}; 93 ; 94////////////////////////////////////////////////////////////////////////////; 95/// As the database is read-only, syncing data to disc is a no-op and always succeeds; 96int VfsRdOnlySync(sqlite3_file * /*pFile*/, int /*flags*/); 97{; 98 return SQLITE_OK;; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////; 102/// Returns the cached file size; 103int VfsRdOnlyFileSize(sqlite3_file *pFile, sqlite_int64 *pSize); 104{; 105 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 106 *pSize = p->fRawFile->GetSize();; 107 return SQLITE_OK;; 108}; 109 ; 110////////////////////////////////////////////////////////////////////////////; 111/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 112int VfsRdOnlyLock(sqlite3_file * /*pFile*/, int /*level*/); 113{; 114 return SQLITE_OK;; 115}; 116 ; 117////////////////////////////////////////////////////////////////////////////; 118/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 119int VfsRdOnlyUnlock(sqlite3_file * /*pFile*/, int /*level*/); 120{; 121 return SQLITE_OK;; 122}; 123 ; 124////////////////////////////////////////////////////////////////////////////; 125/// As the database is read-only, locks for concurrent access are no-ops and always succeeds; 126int VfsRdOnlyCheckReservedLock",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
Safety,abort,abort,"me;; 469 errmsg += ""\"" does not correspond to column type, which is "";; 470 errmsg += GetTypeName(name);; 471 throw std::runtime_error(errmsg);; 472 }; 473 ; 474 fValues[index].fIsActive = true;; 475 return std::vector<void *>{fNSlots, &fValues[index].fPtr};; 476}; 477 ; 478////////////////////////////////////////////////////////////////////////////; 479/// Returns a range of size 1 as long as more rows are available in the SQL result set.; 480/// This inherently serialized the RDF independent of the number of slots.; 481std::vector<std::pair<ULong64_t, ULong64_t>> RSqliteDS::GetEntryRanges(); 482{; 483 std::vector<std::pair<ULong64_t, ULong64_t>> entryRanges;; 484 int retval = sqlite3_step(fDataSet->fQuery);; 485 switch (retval) {; 486 case SQLITE_DONE: return entryRanges;; 487 case SQLITE_ROW:; 488 entryRanges.emplace_back(fNRow, fNRow + 1);; 489 fNRow++;; 490 return entryRanges;; 491 default:; 492 SqliteError(retval);; 493 // Never here; 494 abort();; 495 }; 496}; 497 ; 498////////////////////////////////////////////////////////////////////////////; 499/// Returns the C++ type for a given column name, implemented as a linear search through all the columns.; 500std::string RSqliteDS::GetTypeName(std::string_view colName) const; 501{; 502 unsigned N = fColumnNames.size();; 503 ; 504 for (unsigned i = 0; i < N; ++i) {; 505 if (colName == fColumnNames[i]) {; 506 return fgTypeNames[static_cast<int>(fColumnTypes[i])];; 507 }; 508 }; 509 throw std::runtime_error(""Unknown column: "" + std::string(colName));; 510}; 511 ; 512////////////////////////////////////////////////////////////////////////////; 513/// A linear search through the columns for the given name; 514bool RSqliteDS::HasColumn(std::string_view colName) const; 515{; 516 return std::find(fColumnNames.begin(), fColumnNames.end(), colName) != fColumnNames.end();; 517}; 518 ; 519////////////////////////////////////////////////////////////////////////////; 520/// Resets the SQlite query engine at the beginning of th",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
Security,access,access," .  . Loading...; Searching...; No Matches. RSqliteDS.cxx. Go to the documentation of this file. 1// Author: Jakob Blomer CERN 07/2018; 2 ; 3/*************************************************************************; 4 * Copyright (C) 1995-2017, Rene Brun and Fons Rademakers. *; 5 * All rights reserved. *; 6 * *; 7 * For the licensing terms see $ROOTSYS/LICENSE. *; 8 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11#include <ROOT/RSqliteDS.hxx>; 12#include <ROOT/RRawFile.hxx>; 13 ; 14#include ""TError.h""; 15#include ""TRandom.h""; 16#include ""TSystem.h""; 17 ; 18#include <algorithm>; 19#include <cctype>; 20#include <cerrno>; 21#include <cstring> // for memcpy; 22#include <ctime>; 23#include <memory> // for placement new; 24#include <stdexcept>; 25#include <utility>; 26 ; 27#include <sqlite3.h>; 28 ; 29namespace {; 30 ; 31// In order to provide direct access to remote sqlite files through HTTP and HTTPS, this datasource provides a custom; 32// ""SQlite VFS module"" that uses Davix for data access. The SQlite VFS modules are roughly what TSystem is; 33// for ROOT -- an abstraction of the operating system interface.; 34//; 35// SQlite allows for registering custom VFS modules, which are a set of C callback functions that SQlite invokes when; 36// it needs to read from a file, write to a file, etc. More information is available under https://sqlite.org/vfs.html; 37//; 38// In the context of a data source, SQlite will only ever call reading functions from the VFS module, the sqlite; 39// files are not modified. Therefore, only a subset of the callback functions provide a non-trivial implementation.; 40// The custom VFS module uses a RRawFile for the byte access, thereby it can access local and remote files.; 41 ; 42////////////////////////////////////////////////////////////////////////////; 43/// SQlite VFS modules are identified by string names. The name has to be unique for the",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
Testability,log,logic,"ile structure has been already allocated by sqlite, so we use placement new; 183 VfsRootFile *p = new (pFile) VfsRootFile();; 184 p->pFile.pMethods = nullptr;; 185 ; 186 // This global struct contains the function pointers to all the callback operations that act on an open database.; 187 // It is passed via the pFile struct back to sqlite so that it can call back to the functions provided above.; 188 static const sqlite3_io_methods io_methods = GetSqlite3IoMethods();; 189 ; 190 if (flags & (SQLITE_OPEN_READWRITE | SQLITE_OPEN_DELETEONCLOSE | SQLITE_OPEN_EXCLUSIVE)); 191 return SQLITE_IOERR;; 192 ; 193 p->fRawFile = ROOT::Internal::RRawFile::Create(zName);; 194 if (!p->fRawFile) {; 195 ::Error(""VfsRdOnlyOpen"", ""Cannot open %s\n"", zName);; 196 return SQLITE_IOERR;; 197 }; 198 ; 199 p->pFile.pMethods = &io_methods;; 200 return SQLITE_OK;; 201}; 202 ; 203// The following callbacks implement operating system specific functionality. In contrast to the previous callbacks,; 204// there is no need to implement any customized logic for the following ones. An implementation has to be; 205// provided nevertheless to have a fully functional VFS module.; 206 ; 207////////////////////////////////////////////////////////////////////////////; 208/// This VFS module cannot remove files; 209int VfsRdOnlyDelete(sqlite3_vfs * /*vfs*/, const char * /*zName*/, int /*syncDir*/); 210{; 211 return SQLITE_IOERR_DELETE;; 212}; 213 ; 214////////////////////////////////////////////////////////////////////////////; 215/// Access control always allows read-only access to databases; 216int VfsRdOnlyAccess(sqlite3_vfs * /*vfs*/, const char * /*zPath*/, int flags, int *pResOut); 217{; 218 *pResOut = 0;; 219 if (flags == SQLITE_ACCESS_READWRITE) {; 220 return SQLITE_OPEN_READONLY;; 221 }; 222 return SQLITE_OK;; 223}; 224 ; 225////////////////////////////////////////////////////////////////////////////; 226/// No distinction between relative and full paths for URLs, returns the input path name; 227int V",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
Usability,simpl,simply,"e; 60 ; 61////////////////////////////////////////////////////////////////////////////; 62/// Releases the resources associated to a file opened with davix; 63int VfsRdOnlyClose(sqlite3_file *pFile); 64{; 65 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 66 // We can't use delete because the storage for p is managed by sqlite; 67 p->~VfsRootFile();; 68 return SQLITE_OK;; 69}; 70 ; 71////////////////////////////////////////////////////////////////////////////; 72/// Issues a byte range request for a chunk to the raw file; 73int VfsRdOnlyRead(sqlite3_file *pFile, void *zBuf, int count, sqlite_int64 offset); 74{; 75 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 76 auto nbytes = p->fRawFile->ReadAt(zBuf, count, offset);; 77 return (nbytes != static_cast<unsigned int>(count)) ? SQLITE_IOERR : SQLITE_OK;; 78}; 79 ; 80////////////////////////////////////////////////////////////////////////////; 81/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 82int VfsRdOnlyWrite(sqlite3_file * /*pFile*/, const void * /*zBuf*/, int /*iAmt*/, sqlite_int64 /*iOfst*/); 83{; 84 return SQLITE_OPEN_READONLY;; 85}; 86 ; 87////////////////////////////////////////////////////////////////////////////; 88/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 89int VfsRdOnlyTruncate(sqlite3_file * /*pFile*/, sqlite_int64 /*size*/); 90{; 91 return SQLITE_OPEN_READONLY;; 92}; 93 ; 94////////////////////////////////////////////////////////////////////////////; 95/// As the database is read-only, syncing data to disc is a no-op and always succeeds; 96int VfsRdOnlySync(sqlite3_file * /*pFile*/, int /*flags*/); 97{; 98 return SQLITE_OK;; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////; 102/// Returns the cached file size; 103int VfsRdOnlyFileSize(sqlite3_file *pFile, sqlite_int64 *pSize); 104{; 105 VfsRootFile *p = reinte",MatchSource.WIKI,doc/master/RSqliteDS_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html
Integrability,depend,dependency,". ROOT: core/foundation/inc/RtypesCore.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Typedefs |; Variables ; RtypesCore.h File Reference. #include <ROOT/RConfig.hxx>; #include ""DllImport.h""; #include <cstddef>. Include dependency graph for RtypesCore.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Typedefs; typedef float Angle_t;  ; typedef double Axis_t;  ; typedef bool Bool_t;  ; typedef unsigned char Byte_t;  ; typedef char Char_t;  ; typedef short Color_t;  ; typedef double Coord_t;  ; typedef double Double32_t;  ; typedef double Double_t;  ; typedef float Float16_t;  ; typedef float Float_t;  ; typedef short Font_t;  ; typedef int Int_t;  ; typedef long long Long64_t;  ; typedef long Long_t;  ; typedef long double LongDouble_t;  ; typedef long Longptr_t;  ; typedef short Marker_t;  ; typedef const char Option_t;  ; typedef float Real_t;  ; typedef short SCoord_t;  ; typedef int Seek_t;  ; typedef short Short_t;  ; typedef float Size_t;  ; typedef int Ssiz_t;  ; typedef double Stat_t;  ; typedef short Style_t;  ; typedef char Text_t;  ; typedef unsigned char UChar_t;  ; typedef unsigned int UInt_t;  ; typedef unsigned long long ULong64_t;  ; typedef unsigned long ULong_t;  ; typedef unsigned long ULongptr_t;  ; typedef unsigned short UShort_t;  ; typedef short Version_t;  ; typedef short Width_t;  . Variables; Int_t gDebug;  ; constexpr ULong_t kBitsPerByte = 8;  ; constexpr Bool_t kFALSE = false;  ; constexpr Int_t kMaxChar = kMaxUChar >> 1;  ; constexpr Int_t kMaxInt = Int_t(kMaxUInt >> 1);  ; constexpr Long_t kMaxLong = Long_t(kMaxULong >> 1);  ; constexpr Long64_t kMaxLong64 = Long64_t(kMaxULong64 >> 1);  ; constexpr Int_t kMaxShort = kMaxUShort >> 1;  ; constexpr Int_t kMaxUChar = 256;  ; constexpr UInt_t kMaxUI",MatchSource.WIKI,doc/master/RtypesCore_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RtypesCore_8h.html
Modifiability,portab,portable,; 32 ; 33class TRootIOCtor;; 34 ; 35//---- types -------------------------------------------------------------------; 36 ; 37typedef char Char_t; //Signed Character 1 byte (char); 38typedef unsigned char UChar_t; //Unsigned Character 1 byte (unsigned char); 39typedef short Short_t; //Signed Short integer 2 bytes (short); 40typedef unsigned short UShort_t; //Unsigned Short integer 2 bytes (unsigned short); 41#ifdef R__INT16; 42typedef long Int_t; //Signed integer 4 bytes; 43typedef unsigned long UInt_t; //Unsigned integer 4 bytes; 44#else; 45typedef int Int_t; //Signed integer 4 bytes (int); 46typedef unsigned int UInt_t; //Unsigned integer 4 bytes (unsigned int); 47#endif; 48#ifdef R__B64 // Note: Long_t and ULong_t are currently not portable types; 49typedef int Seek_t; //File pointer (int); 50typedef long Long_t; //Signed long integer,MatchSource.WIKI,doc/master/RtypesCore_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RtypesCore_8h_source.html
Availability,redundant,redundant," not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  ROOT::Internal::ClassDefGenerateInitInstanceLocalInjector< T >;  ; class  ROOT::Internal::TCDGIILIBase;  ; class  ROOT::Internal::TDefaultInitBehavior;  ; struct  ROOT::Internal::THashConsistencyHolder< T >;  ; class  ROOT::Internal::TInitBehavior;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define _ClassDefBase_(name, id, virtual_keyword, overrd);  Common part being called both by _ClassDefOutline_ and _ClassDefInline_. ;  ; #define _ClassDefInline_(name, id, virtual_keyword, overrd);  ; #define _ClassDefOutline_(name, id, virtual_keyword, overrd);  ; #define BIT(n)   (1ULL << (n));  ; #define ClassDef(name, id);  ; #define ClassDef2T2(name, Tmpl1, Tmpl2);  ; #define ClassDef3T2(name, Tmpl1, Tmpl2, Tmpl3);  ; #define ClassDefInline(name, id);  ; #define ClassDefInlineNV(name, id);  ; #define ClassDefInlineOverride(name, id);  ; #define ClassDefNV(name, id);  ; #define ClassDefOverride(name, id);  ; #define ClassDefT(name, id);  This ClassDefT is strictly redundant and is kept only for backward compatibility. ;  ; #define ClassDefT2(name, Tmpl);  ; #define ClassDefTNV(name, id);  ; #define ClassImp(name)   ClassImpUnique(name,default);  ; #define ClassImp2T(name, Tmpl1, Tmpl2)   templateClassImp(name);  ; #define ClassImp3T(name, Tmpl1, Tmpl2, Tmpl3)   templateClassImp(name);  ; #define ClassImpT(name, Tmpl)   templateClassImp(name);  ; #define ClassImpUnique(name, key);  ; #define CLRBIT(n, i)   ((n) &= ~BIT(i));  ; #define NamespaceImp(name)   NamespaceImpUnique(name,default);  ; #define NamespaceImpUnique(name, key);  Macro for Namespace. ;  ; #define R__ADD_INCLUDE_PATH(PATH);  ; #define R__ADD_LIBRARY_PATH(PATH);  ; #define R__CLING_PTRCHECK(ONOFF);  ; #define R__LOAD_LIBRARY(LIBRARY);  ; #",MatchSource.WIKI,doc/master/Rtypes_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h.html
Deployability,update,update,"mplementation used by ClassDefInline to avoid requirement to include TBuffer.h. ;  ; const TInitBehavior * ROOT::Internal::DefineBehavior (void *, void *);  ; Bool_t ROOT::Internal::HasConsistentHashMember (const char *clName);  Return true is the Hash/RecursiveRemove setup is consistent, i.e. ;  ; Bool_t ROOT::Internal::HasConsistentHashMember (TClass &clRef);  Return true is the Hash/RecursiveRemove setup is consistent, i.e. ;  ; template<class Tmpl > ; TBuffer & operator<< (TBuffer &buf, const Tmpl *obj);  ; template<class Tmpl > ; TBuffer & operator>> (TBuffer &buf, Tmpl *&obj);  ; TNamed * ROOT::RegisterClassTemplate (const char *name, const char *file, Int_t line);  Global function to register the implementation file and line of a class template (i.e. ;  ; void ROOT::RemoveClass (const char *cname, TClass *cl);  Global function called by the dtor of a class's init class (see the ClassImp macro). ;  ; void ROOT::RemoveClassAlternate (ROOT::TClassAlt *);  ; void ROOT::ResetClassVersion (TClass *, const char *, Short_t);  Global function to update the version number. ;  ; template<class RootClass > ; Short_t ROOT::SetClassVersion (RootClass *);  . Macro Definition Documentation. ◆ _ClassDefBase_. #define _ClassDefBase_; (;  ; name, .  ; id, .  ; virtual_keyword, .  ; overrd . ). Value:private: \; static_assert(std::is_integral<decltype(id)>::value, \; ""ClassDef(Inline) macro: the specified class version number is not an integer.""); \; /** \cond HIDDEN_SYMBOLS */ virtual_keyword Bool_t CheckTObjectHashConsistency() const overrd \; { \; static std::atomic<UChar_t> recurseBlocker(0); \; if (R__likely(recurseBlocker >= 2)) { \; return ::ROOT::Internal::THashConsistencyHolder<decltype(*this)>::fgHashConsistency; \; } else if (recurseBlocker == 1) { \; return false; \; } else if (recurseBlocker++ == 0) { \; ::ROOT::Internal::THashConsistencyHolder<decltype(*this)>::fgHashConsistency = \; ::ROOT::Internal::HasConsistentHashMember(_QUOTE_(name)) || \; ::ROOT::Internal::H",MatchSource.WIKI,doc/master/Rtypes_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h.html
Integrability,depend,dependency,". ROOT: core/base/inc/Rtypes.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Macros |; Typedefs |; Enumerations |; Functions ; Rtypes.h File Reference. #include ""RtypesCore.h""; #include <cstdio>; #include ""strtok.h""; #include ""strlcpy.h""; #include ""snprintf.h""; #include <type_traits>; #include <typeinfo>; #include <atomic>; #include ""TGenericClassInfo.h""; #include ""TIsAProxy.h""; #include <string>. Include dependency graph for Rtypes.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  ROOT::Internal::ClassDefGenerateInitInstanceLocalInjector< T >;  ; class  ROOT::Internal::TCDGIILIBase;  ; class  ROOT::Internal::TDefaultInitBehavior;  ; struct  ROOT::Internal::THashConsistencyHolder< T >;  ; class  ROOT::Internal::TInitBehavior;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define _ClassDefBase_(name, id, virtual_keyword, overrd);  Common part being called both by _ClassDefOutline_ and _ClassDefInline_. ;  ; #define _ClassDefInline_(name, id, virtual_keyword, overrd);  ; #define _ClassDefOutline_(name, id, virtual_keyword, overrd);  ; #define BIT(n)   (1ULL << (n));  ; #define ClassDef(name, id);  ; #define ClassDef2T2(name, Tmpl1, Tmpl2);  ; #define ClassDef3T2(name, Tmpl1, Tmpl2, Tmpl3);  ; #define ClassDefInline(name, id);  ; #define ClassDefInlineNV(name, id);  ; #define ClassDefInlineOverride(name, id);  ; #define ClassDefNV(name, id);  ; #define ClassDefOverride(name, id);  ; #define ClassDefT(name, id);  This ClassDefT is strictly redundant and is kept only for backward compatibility. ;  ; #define ClassDefT2(name, Tmpl);  ; #define ClassDefTNV(name, id);  ; #define ClassImp(name)   ClassImpUnique(name,default);  ; #define ClassImp2T(name, Tmpl1, Tmpl",MatchSource.WIKI,doc/master/Rtypes_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h.html
Safety,redund,redundant," not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  ROOT::Internal::ClassDefGenerateInitInstanceLocalInjector< T >;  ; class  ROOT::Internal::TCDGIILIBase;  ; class  ROOT::Internal::TDefaultInitBehavior;  ; struct  ROOT::Internal::THashConsistencyHolder< T >;  ; class  ROOT::Internal::TInitBehavior;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define _ClassDefBase_(name, id, virtual_keyword, overrd);  Common part being called both by _ClassDefOutline_ and _ClassDefInline_. ;  ; #define _ClassDefInline_(name, id, virtual_keyword, overrd);  ; #define _ClassDefOutline_(name, id, virtual_keyword, overrd);  ; #define BIT(n)   (1ULL << (n));  ; #define ClassDef(name, id);  ; #define ClassDef2T2(name, Tmpl1, Tmpl2);  ; #define ClassDef3T2(name, Tmpl1, Tmpl2, Tmpl3);  ; #define ClassDefInline(name, id);  ; #define ClassDefInlineNV(name, id);  ; #define ClassDefInlineOverride(name, id);  ; #define ClassDefNV(name, id);  ; #define ClassDefOverride(name, id);  ; #define ClassDefT(name, id);  This ClassDefT is strictly redundant and is kept only for backward compatibility. ;  ; #define ClassDefT2(name, Tmpl);  ; #define ClassDefTNV(name, id);  ; #define ClassImp(name)   ClassImpUnique(name,default);  ; #define ClassImp2T(name, Tmpl1, Tmpl2)   templateClassImp(name);  ; #define ClassImp3T(name, Tmpl1, Tmpl2, Tmpl3)   templateClassImp(name);  ; #define ClassImpT(name, Tmpl)   templateClassImp(name);  ; #define ClassImpUnique(name, key);  ; #define CLRBIT(n, i)   ((n) &= ~BIT(i));  ; #define NamespaceImp(name)   NamespaceImpUnique(name,default);  ; #define NamespaceImpUnique(name, key);  Macro for Namespace. ;  ; #define R__ADD_INCLUDE_PATH(PATH);  ; #define R__ADD_LIBRARY_PATH(PATH);  ; #define R__CLING_PTRCHECK(ONOFF);  ; #define R__LOAD_LIBRARY(LIBRARY);  ; #",MatchSource.WIKI,doc/master/Rtypes_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h.html
Security,access,accessing," idOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize idDefinition TGWin32VirtualXProxy.cxx:94; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; StreamerNVirtualvoid StreamerNVirtual(TBuffer &ClassDef_StreamerNVirtual_b)Definition TStringLong.h:20; Class_Versionstatic constexpr Version_t Class_Version()Definition TStringLong.h:20; IsATClass * IsA() const overrideDefinition TStringLong.h:20; DeclFileNamestatic const char * DeclFileName()Definition TStringLong.h:20; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; ROOT::Internal::THashConsistencyHolderDefinition Rtypes.h:260. Common part being called both by _ClassDefOutline_ and _ClassDefInline_. ; NoteDeclFileLine() is not part of it, since Cling uses that as trigger for associating as class title the comment string found right after the macro. ; Definition at line 276 of file Rtypes.h. ◆ _ClassDefInline_. #define _ClassDefInline_; (;  ; name, .  ; id, .  ; virtual_keyword, .  ; overrd . ). Value: _ClassDefBase_(name, id, virtual_keyword, overrd) public : \; /** \cond HIDDEN_SYMBOLS \deprecated */ static int ImplFileLine() { return -1; } /** \endcond */ \; /** \cond HIDDEN_SYMBOLS \deprecated */ static const char *ImplFileName() { return nullptr; } /** \endcond */\; /** \return Name of this class */ static const char *Class_Name() \; { \; return ::ROOT::Internal::ClassDefGenerateInitInstanceLocalInjector<name>::Name(); \; } \; /** \cond HIDDEN_SYMBOLS */ static TClass ",MatchSource.WIKI,doc/master/Rtypes_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h.html
Availability,redundant,redundant," __LINE__; } /** \endcond */; 357 ; 358#define ClassDefInlineOverride(name,id) \; 359 _ClassDefInline_(name,id,,override) \; 360 /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */; 361 ; 362#define ClassDefInlineNV(name,id) \; 363 _ClassDefInline_(name,id,,) \; 364 /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */; 365 ; 366//#define _ClassDefInterp_(name,id) ClassDefInline(name,id); 367 ; 368#define R__UseDummy(name) \; 369 class _NAME2_(name,_c) { public: _NAME2_(name,_c)() { if (name) { } } }; 370 ; 371#define ClassImpUnique(name,key) \; 372 namespace ROOT { \; 373 /** \cond HIDDEN_SYMBOLS */ TGenericClassInfo *GenerateInitInstance(const name*); /** \endcond */ \; 374 namespace { \; 375 static int _R__UNIQUE_(_NAME2_(R__dummyint,key)) __attribute__((unused)) = \; 376 GenerateInitInstance((name*)0x0)->SetImplFile(__FILE__, __LINE__); \; 377 R__UseDummy(_R__UNIQUE_(_NAME2_(R__dummyint,key))); \; 378 } \; 379 }; 380 ; 381/// \deprecated; 382#define ClassImp(name) ClassImpUnique(name,default); 383 ; 384/// Macro for Namespace; 385#define NamespaceImpUnique(name,key) \; 386 namespace name { \; 387 namespace ROOTDict { \; 388 /** \cond HIDDEN_SYMBOLS */ \; 389 ::ROOT::TGenericClassInfo *GenerateInitInstance(); /** \endcond */ \; 390 namespace { \; 391 static int _R__UNIQUE_(_NAME2_(R__dummyint,key)) = \; 392 GenerateInitInstance()->SetImplFile(__FILE__, __LINE__); \; 393 R__UseDummy(_R__UNIQUE_(_NAME2_(R__dummyint,key))); \; 394 } \; 395 } \; 396 }; 397 ; 398#define NamespaceImp(name) NamespaceImpUnique(name,default); 399 ; 400//---- ClassDefT macros for templates with one template argument ---------------; 401// ClassDefT corresponds to ClassDef; 402// ClassDefT2 goes in the same header as ClassDefT but must be; 403// outside the class scope; 404// ClassImpT corresponds to ClassImp; 405 ; 406 ; 407/// This ClassDefT is strictly redundant and is kept only for; 408/// backward compatibility.",MatchSource.WIKI,doc/master/Rtypes_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html
Deployability,update,update,"OOT::CreateClassTClass * CreateClass(const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il)Global function called by a class' static Dictionary() method (see the ClassDef macro).Definition TClass.cxx:5936; ROOT::DelFunc_tvoid(* DelFunc_t)(void *)Definition Rtypes.h:116; ROOT::AddClassvoid AddClass(const char *cname, Version_t id, const std::type_info &info, DictFuncPtr_t dict, Int_t pragmabits)Global function called by the ctor of a class's init class (see the ClassImp macro).Definition TClassTable.cxx:896; ROOT::RegisterClassTemplateTNamed * RegisterClassTemplate(const char *name, const char *file, Int_t line)Global function to register the implementation file and line of a class template (i....Definition TClassTable.cxx:1005; ROOT::NewArrFunc_tvoid *(* NewArrFunc_t)(Long_t size, void *arena)Definition Rtypes.h:115; ROOT::Class_ShowMembersvoid Class_ShowMembers(TClass *cl, const void *obj, TMemberInspector &)Indirect call to the implementation of ShowMember allowing [forward] declaration with out a full defi...Definition TClass.cxx:613; ROOT::ResetClassVersionvoid ResetClassVersion(TClass *, const char *, Short_t)Global function to update the version number.Definition TClassTable.cxx:951; ROOT::SetClassVersionShort_t SetClassVersion(RootClass *); ROOT::DelArrFunc_tvoid(* DelArrFunc_t)(void *)Definition Rtypes.h:117; ROOT::NewFunc_tvoid *(* NewFunc_t)(void *)Definition Rtypes.h:114; ROOT::MergeFunc_tLong64_t(* MergeFunc_t)(void *, TCollection *, TFileMergeInfo *)Definition Rtypes.h:120; ROOT::RemoveClassAlternatevoid RemoveClassAlternate(ROOT::TClassAlt *)Definition TClassTable.cxx:931; ROOT::Internal::THashConsistencyHolderDefinition Rtypes.h:260; ROOT::Internal::THashConsistencyHolder::fgHashConsistencystatic Bool_t fgHashConsistencyDefinition Rtypes.h:261. corebaseincRtypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:02 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/Rtypes_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html
Integrability,interface,interface,"onst char *ifil,; 128 Int_t dl, Int_t il);; 129 extern void AddClass(const char *cname, Version_t id, const std::type_info &info,; 130 DictFuncPtr_t dict, Int_t pragmabits);; 131 extern void RemoveClass(const char *cname, TClass *cl);; 132 extern void ResetClassVersion(TClass*, const char*, Short_t);; 133 extern ROOT::TClassAlt* AddClassAlternate(const char *normName, const char *alternate);; 134 extern void RemoveClassAlternate(ROOT::TClassAlt*);; 135 ; 136 extern TNamed *RegisterClassTemplate(const char *name,; 137 const char *file, Int_t line);; 138 ; 139 extern void Class_ShowMembers(TClass *cl, const void *obj, TMemberInspector&);; 140 ; 141#if 0; 142 // This function is only implemented in the dictionary file.; 143 // The parameter is 'only' for overloading resolution.; 144 // Used to be a template <class T> TGenericClassInfo *GenerateInitInstance(const T*);; 145 template <class T> TGenericClassInfo *GetClassInfo(const T* t) {; 146 TGenericClassInfo *GenerateInitInstance(const T*);; 147 return CreateInitInstance(t);; 148 };; 149#endif; 150 ; 151 namespace Internal {; 152 class TInitBehavior {; 153 // This class defines the interface for the class registration and; 154 // the TClass creation. To modify the default behavior, one would; 155 // inherit from this class and overload ROOT::DefineBehavior().; 156 // See TQObject.h and table/inc/Ttypes.h for examples.; 157 public:; 158 virtual ~TInitBehavior() { }; 159 ; 160 virtual void Register(const char *cname, Version_t id,; 161 const std::type_info &info,; 162 DictFuncPtr_t dict, Int_t pragmabits) const = 0;; 163 virtual void Unregister(const char *classname, TClass *cl) const = 0;; 164 virtual TClass *CreateClass(const char *cname, Version_t id,; 165 const std::type_info &info, TVirtualIsAProxy *isa,; 166 const char *dfil, const char *ifil,; 167 Int_t dl, Int_t il) const = 0;; 168 };; 169 ; 170 class TDefaultInitBehavior: public TInitBehavior {; 171 public:; 172 void Register(const char *cname, Version_t id,; 173",MatchSource.WIKI,doc/master/Rtypes_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html
Modifiability,inherit,inherit,"Class*, const char*, Short_t);; 133 extern ROOT::TClassAlt* AddClassAlternate(const char *normName, const char *alternate);; 134 extern void RemoveClassAlternate(ROOT::TClassAlt*);; 135 ; 136 extern TNamed *RegisterClassTemplate(const char *name,; 137 const char *file, Int_t line);; 138 ; 139 extern void Class_ShowMembers(TClass *cl, const void *obj, TMemberInspector&);; 140 ; 141#if 0; 142 // This function is only implemented in the dictionary file.; 143 // The parameter is 'only' for overloading resolution.; 144 // Used to be a template <class T> TGenericClassInfo *GenerateInitInstance(const T*);; 145 template <class T> TGenericClassInfo *GetClassInfo(const T* t) {; 146 TGenericClassInfo *GenerateInitInstance(const T*);; 147 return CreateInitInstance(t);; 148 };; 149#endif; 150 ; 151 namespace Internal {; 152 class TInitBehavior {; 153 // This class defines the interface for the class registration and; 154 // the TClass creation. To modify the default behavior, one would; 155 // inherit from this class and overload ROOT::DefineBehavior().; 156 // See TQObject.h and table/inc/Ttypes.h for examples.; 157 public:; 158 virtual ~TInitBehavior() { }; 159 ; 160 virtual void Register(const char *cname, Version_t id,; 161 const std::type_info &info,; 162 DictFuncPtr_t dict, Int_t pragmabits) const = 0;; 163 virtual void Unregister(const char *classname, TClass *cl) const = 0;; 164 virtual TClass *CreateClass(const char *cname, Version_t id,; 165 const std::type_info &info, TVirtualIsAProxy *isa,; 166 const char *dfil, const char *ifil,; 167 Int_t dl, Int_t il) const = 0;; 168 };; 169 ; 170 class TDefaultInitBehavior: public TInitBehavior {; 171 public:; 172 void Register(const char *cname, Version_t id,; 173 const std::type_info &info,; 174 DictFuncPtr_t dict, Int_t pragmabits) const override {; 175 ROOT::AddClass(cname, id, info, dict, pragmabits);; 176 }; 177 ; 178 void Unregister(const char *classname, TClass *cl) const override {; 179 ROOT::RemoveClass(classname, cl);; ",MatchSource.WIKI,doc/master/Rtypes_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html
Performance,load,load,"05namespace ROOT { namespace Internal {; 206 ; 207class TCDGIILIBase {; 208public:; 209 // All implemented in TGenericClassInfo.cxx.; 210 static void SetInstance(::ROOT::TGenericClassInfo& R__instance,; 211 NewFunc_t, NewArrFunc_t, DelFunc_t, DelArrFunc_t, DesFunc_t);; 212 static void SetName(const std::string& name, std::string& nameMember);; 213 static void SetfgIsA(atomic_TClass_ptr& isA, TClass*(*dictfun)());; 214};; 215 ; 216template <typename T>; 217class ClassDefGenerateInitInstanceLocalInjector:; 218 public TCDGIILIBase {; 219 static atomic_TClass_ptr fgIsA;; 220 static ::ROOT::TGenericClassInfo *fgGenericInfo;; 221 public:; 222 static void *New(void *p) { return p ? new(p) T : new T; };; 223 static void *NewArray(Long_t nElements, void *p) {; 224 return p ? new(p) T[nElements] : new T[nElements]; }; 225 static void Delete(void *p) { delete ((T*)p); }; 226 static void DeleteArray(void *p) { delete[] ((T*)p); }; 227 static void Destruct(void *p) { ((T*)p)->~T(); }; 228 static ::ROOT::TGenericClassInfo *GenerateInitInstanceLocal() {; 229 static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy<T>(nullptr);; 230 static ::ROOT::TGenericClassInfo; 231 R__instance(T::Class_Name(), T::Class_Version(),; 232 T::DeclFileName(), T::DeclFileLine(),; 233 typeid(T), ::ROOT::Internal::DefineBehavior((T*)nullptr, (T*)nullptr),; 234 &T::Dictionary, isa_proxy, 0, sizeof(T) );; 235 SetInstance(R__instance, &New, &NewArray, &Delete, &DeleteArray, &Destruct);; 236 return &R__instance;; 237 }; 238 // We need a reference to the template instance static member in a concrete function in order; 239 // to force its instantiation (even before the function is actually run); 240 // Since we do have a reference to Dictionary (in T::Dictionary), using fgGenericInfo; 241 // here will insure that it is initialized at process start or library load time.; 242 static TClass *Dictionary() { fgIsA = fgGenericInfo->GetClass(); return fgIsA; }; 243 static TClass *Class() { SetfgIsA(fgIsA,",MatchSource.WIKI,doc/master/Rtypes_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html
Safety,redund,redundant," __LINE__; } /** \endcond */; 357 ; 358#define ClassDefInlineOverride(name,id) \; 359 _ClassDefInline_(name,id,,override) \; 360 /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */; 361 ; 362#define ClassDefInlineNV(name,id) \; 363 _ClassDefInline_(name,id,,) \; 364 /** \cond HIDDEN_SYMBOLS */ static int DeclFileLine() { return __LINE__; } /** \endcond */; 365 ; 366//#define _ClassDefInterp_(name,id) ClassDefInline(name,id); 367 ; 368#define R__UseDummy(name) \; 369 class _NAME2_(name,_c) { public: _NAME2_(name,_c)() { if (name) { } } }; 370 ; 371#define ClassImpUnique(name,key) \; 372 namespace ROOT { \; 373 /** \cond HIDDEN_SYMBOLS */ TGenericClassInfo *GenerateInitInstance(const name*); /** \endcond */ \; 374 namespace { \; 375 static int _R__UNIQUE_(_NAME2_(R__dummyint,key)) __attribute__((unused)) = \; 376 GenerateInitInstance((name*)0x0)->SetImplFile(__FILE__, __LINE__); \; 377 R__UseDummy(_R__UNIQUE_(_NAME2_(R__dummyint,key))); \; 378 } \; 379 }; 380 ; 381/// \deprecated; 382#define ClassImp(name) ClassImpUnique(name,default); 383 ; 384/// Macro for Namespace; 385#define NamespaceImpUnique(name,key) \; 386 namespace name { \; 387 namespace ROOTDict { \; 388 /** \cond HIDDEN_SYMBOLS */ \; 389 ::ROOT::TGenericClassInfo *GenerateInitInstance(); /** \endcond */ \; 390 namespace { \; 391 static int _R__UNIQUE_(_NAME2_(R__dummyint,key)) = \; 392 GenerateInitInstance()->SetImplFile(__FILE__, __LINE__); \; 393 R__UseDummy(_R__UNIQUE_(_NAME2_(R__dummyint,key))); \; 394 } \; 395 } \; 396 }; 397 ; 398#define NamespaceImp(name) NamespaceImpUnique(name,default); 399 ; 400//---- ClassDefT macros for templates with one template argument ---------------; 401// ClassDefT corresponds to ClassDef; 402// ClassDefT2 goes in the same header as ClassDefT but must be; 403// outside the class scope; 404// ClassImpT corresponds to ClassImp; 405 ; 406 ; 407/// This ClassDefT is strictly redundant and is kept only for; 408/// backward compatibility.",MatchSource.WIKI,doc/master/Rtypes_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html
Security,access,accessing,"dl, Int_t il) const =0; ROOT::Internal::TInitBehavior::~TInitBehaviorvirtual ~TInitBehavior()Definition Rtypes.h:158; ROOT::Internal::TInitBehavior::Registervirtual void Register(const char *cname, Version_t id, const std::type_info &info, DictFuncPtr_t dict, Int_t pragmabits) const =0; ROOT::TClassAltDefinition TClassTable.cxx:128; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassStreamerDefinition TClassStreamer.h:26; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollectionCollection abstract base class.Definition TCollection.h:65; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileMergeInfoDefinition TFileMergeInfo.h:42; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjectMother of all ROOT objects.Definition TObject.h:41; TStringBasic string class.Definition TString.h:139; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualIsAProxyDefinition TVirtualIsAProxy.h:27; bool; int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Internal::DefaultStreamervoid DefaultStreamer(TBuffer &R__b, const TClass *cl, void *objpointer)Default streamer implementation used by ClassDefInline to avoid requirement to include TBuffer....Definition TBuffer.cxx:30; ROOT::Internal::DefineBehaviorconst TInitBehavior * DefineBehavior(void *, void *)Definition TGenericClassInfo.cxx:45; ROOT::Internal::HasConsistentHashMemberBool_t",MatchSource.WIKI,doc/master/Rtypes_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html
Deployability,update,update,"; .  . Loading...; Searching...; No Matches. runplugin.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Creates and runs a simple iterator plugin connected to TGeoPainter iterator. ; It demonstrates the possibility to dynamically change the color of drawn volumes according some arbitrary criteria WITHOUT changing the color of the same volume drawn on branches that do not match the criteria.; To run:; root[0] .L iterplugin.cxx+; root[1] .x runplugin.C; root[2] select(2,kMagenta);; root[3] select(3,kBlue); ...; kMagenta@ kMagentaDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; iterpluginDefinition iterplugin.cxx:10; ; #include ""iterplugin.cxx""; ; iterplugin *plugin = nullptr;; ; void runplugin(); {; ; ; TString tutdir = gROOT->GetTutorialDir();; gROOT->ProcessLine("".x "" + tutdir + ""/geom/rootgeom.C"");; plugin = new iterplugin();; gGeoManager->GetGeomPainter()->SetIteratorPlugin(plugin);; }; ; void select(Int_t replica=1, Int_t color=kGreen); {; // Change current color. Replica range: 1-4; plugin->Select(replica, color);; gGeoManager->GetGeomPainter()->ModifiedPad();; }; Int_tint Int_tDefinition RtypesCore.h:45; kGreen@ kGreenDefinition Rtypes.h:66; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; gROOT#define gROOTDefinition TROOT.h:406; TGeoManager::GetGeomPainterTVirtualGeoPainter * GetGeomPainter()Make a default painter if none present. Returns pointer to it.Definition TGeoManager.cxx:2916; TStringBasic string class.Definition TString.h:139; TVirtualGeoPainter::ModifiedPadvirtual void ModifiedPad(Bool_t update=kFALSE) const =0; TVirtualGeoPainter::SetIteratorPluginvirtual void SetIteratorPlugin(TGeoIteratorPlugin *plugin)=0; iterplugin::Selectvoid Select(Int_t replica, Int_t color)Definition iterplugin.cxx:16; iterplugin.cxx; AuthorAndrei Gheata ; Definition in file runplugin.C. tutorialsgeomrunplugin.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:28 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/runplugin_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/runplugin_8C.html
Modifiability,plugin,plugin,". ROOT: tutorials/geom/runplugin.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. runplugin.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Creates and runs a simple iterator plugin connected to TGeoPainter iterator. ; It demonstrates the possibility to dynamically change the color of drawn volumes according some arbitrary criteria WITHOUT changing the color of the same volume drawn on branches that do not match the criteria.; To run:; root[0] .L iterplugin.cxx+; root[1] .x runplugin.C; root[2] select(2,kMagenta);; root[3] select(3,kBlue); ...; kMagenta@ kMagentaDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; iterpluginDefinition iterplugin.cxx:10; ; #include ""iterplugin.cxx""; ; iterplugin *plugin = nullptr;; ; void runplugin(); {; ; ; TString tutdir = gROOT->GetTutorialDir();; gROOT->ProcessLine("".x "" + tutdir + ""/geom/rootgeom.C"");; plugin = new iterplugin();; gGeoManager->GetGeomPainter()->SetIteratorPlugin(plugin);; }; ; void select(Int_t replica=1, Int_t color=kGreen); {; // Change current color. Replica range: 1-4; plugin->Select(replica, color);; gGeoManager->GetGeomPainter()->ModifiedPad();; }; Int_tint Int_tDefinition RtypesCore.h:45; kGreen@ kGreenDefinition Rtypes.h:66; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; gROOT#define gROOTDefinition TROOT.h:406; TGeoManager::GetGeomPainterTVirtualGeoPainter * GetGeomPainter()Make a default painter if none present. Returns pointer to it.Definition TGeoManager.cxx:2916; TStringBasic string class.Definition TString.h:139; TVirtualGeoPainter::ModifiedPadvirtual void ModifiedPad(Bool_t update=kFALSE) const =0; TVirtualGeoPainter::SetIteratorPluginvirtual void SetIteratorPlugin(TGeoIteratorPlugin *plugin)=0; iterplugin::Selectvoid Select(Int_t replica, Int_t color)Definition iterplugin.cxx:16; iterplugin.cxx; AuthorAndrei Gheata ; Definition in file runplugin.C. tutorialsgeomrunplugin.C. ROOT master - Refe",MatchSource.WIKI,doc/master/runplugin_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/runplugin_8C.html
Usability,simpl,simple,". ROOT: tutorials/geom/runplugin.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. runplugin.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Creates and runs a simple iterator plugin connected to TGeoPainter iterator. ; It demonstrates the possibility to dynamically change the color of drawn volumes according some arbitrary criteria WITHOUT changing the color of the same volume drawn on branches that do not match the criteria.; To run:; root[0] .L iterplugin.cxx+; root[1] .x runplugin.C; root[2] select(2,kMagenta);; root[3] select(3,kBlue); ...; kMagenta@ kMagentaDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; iterpluginDefinition iterplugin.cxx:10; ; #include ""iterplugin.cxx""; ; iterplugin *plugin = nullptr;; ; void runplugin(); {; ; ; TString tutdir = gROOT->GetTutorialDir();; gROOT->ProcessLine("".x "" + tutdir + ""/geom/rootgeom.C"");; plugin = new iterplugin();; gGeoManager->GetGeomPainter()->SetIteratorPlugin(plugin);; }; ; void select(Int_t replica=1, Int_t color=kGreen); {; // Change current color. Replica range: 1-4; plugin->Select(replica, color);; gGeoManager->GetGeomPainter()->ModifiedPad();; }; Int_tint Int_tDefinition RtypesCore.h:45; kGreen@ kGreenDefinition Rtypes.h:66; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; gROOT#define gROOTDefinition TROOT.h:406; TGeoManager::GetGeomPainterTVirtualGeoPainter * GetGeomPainter()Make a default painter if none present. Returns pointer to it.Definition TGeoManager.cxx:2916; TStringBasic string class.Definition TString.h:139; TVirtualGeoPainter::ModifiedPadvirtual void ModifiedPad(Bool_t update=kFALSE) const =0; TVirtualGeoPainter::SetIteratorPluginvirtual void SetIteratorPlugin(TGeoIteratorPlugin *plugin)=0; iterplugin::Selectvoid Select(Int_t replica, Int_t color)Definition iterplugin.cxx:16; iterplugin.cxx; AuthorAndrei Gheata ; Definition in file runplugin.C. tutorialsgeomrunplugin.C. ROOT master - Refe",MatchSource.WIKI,doc/master/runplugin_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/runplugin_8C.html
Modifiability,variab,variable,"; chain.SetCacheSize(20*1024*1024);; chain.Add(""$H1/dstarmb.root"");; chain.Add(""$H1/dstarp1a.root"");; chain.Add(""$H1/dstarp1b.root"");; chain.Add(""$H1/dstarp2.root"");; ; TString selectionMacro = gSystem->GetDirName(__FILE__) + ""/h1analysis.C"";; ; if (type == 0); chain.Process(selectionMacro);; else if (type == 1) {; // use AClic ( add a + at the end; selectionMacro += ""+"";; chain.Process(selectionMacro);; }; else if (type == 2) {; chain.Process(selectionMacro,""fillList"");; chain.Process(selectionMacro,""useList"");; }; }; ; ; ; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TChainA chain is a collection of files containing TTree objects.Definition TChain.h:33; TStringBasic string class.Definition TString.h:139; TSystem::Setenvvirtual void Setenv(const char *name, const char *value)Set environment variable.Definition TSystem.cxx:1649; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; Author; Definition in file run_h1analysis.C. tutorialstreerun_h1analysis.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/run__h1analysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/run__h1analysis_8C.html
Availability,error,error,"ECK(off) SmallVectorBase {; 139public:; 140 // This limits the maximum size of an RVec<char> to ~4GB but we don't expect this to ever be a problem,; 141 // and we prefer the smaller Size_T to reduce the size of each RVec object.; 142 using Size_T = int32_t;; 143 ; 144protected:; 145 void *fBeginX;; 146 /// Always >= 0.; 147 // Type is signed only for consistency with fCapacity.; 148 Size_T fSize = 0;; 149 /// Always >= -1. fCapacity == -1 indicates the RVec is in ""memory adoption"" mode.; 150 Size_T fCapacity;; 151 ; 152 /// The maximum value of the Size_T used.; 153 static constexpr size_t SizeTypeMax() { return std::numeric_limits<Size_T>::max(); }; 154 ; 155 SmallVectorBase() = delete;; 156 SmallVectorBase(void *FirstEl, size_t TotalCapacity) : fBeginX(FirstEl), fCapacity(TotalCapacity) {}; 157 ; 158 /// This is an implementation of the grow() method which only works; 159 /// on POD-like data types and is out of line to reduce code duplication.; 160 /// This function will report a fatal error if it cannot increase capacity.; 161 void grow_pod(void *FirstEl, size_t MinSize, size_t TSize);; 162 ; 163 /// Report that MinSize doesn't fit into this vector's size type. Throws; 164 /// std::length_error or calls report_fatal_error.; 165 static void report_size_overflow(size_t MinSize);; 166 /// Report that this vector is already at maximum capacity. Throws; 167 /// std::length_error or calls report_fatal_error.; 168 static void report_at_maximum_capacity();; 169 ; 170 /// If false, the RVec is in ""memory adoption"" mode, i.e. it is acting as a view on a memory buffer it does not own.; 171 bool Owns() const { return fCapacity != -1; }; 172 ; 173public:; 174 size_t size() const { return fSize; }; 175 size_t capacity() const noexcept { return Owns() ? fCapacity : fSize; }; 176 ; 177 R__RVEC_NODISCARD bool empty() const { return !fSize; }; 178 ; 179 /// Set the array size to \p N, which the current array must have enough; 180 /// capacity for.; 181 ///; 182 /// This does not c",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
Deployability,update,update,"fit into this vector's size type. Throws; 164 /// std::length_error or calls report_fatal_error.; 165 static void report_size_overflow(size_t MinSize);; 166 /// Report that this vector is already at maximum capacity. Throws; 167 /// std::length_error or calls report_fatal_error.; 168 static void report_at_maximum_capacity();; 169 ; 170 /// If false, the RVec is in ""memory adoption"" mode, i.e. it is acting as a view on a memory buffer it does not own.; 171 bool Owns() const { return fCapacity != -1; }; 172 ; 173public:; 174 size_t size() const { return fSize; }; 175 size_t capacity() const noexcept { return Owns() ? fCapacity : fSize; }; 176 ; 177 R__RVEC_NODISCARD bool empty() const { return !fSize; }; 178 ; 179 /// Set the array size to \p N, which the current array must have enough; 180 /// capacity for.; 181 ///; 182 /// This does not construct or destroy any elements in the vector.; 183 ///; 184 /// Clients can use this in conjunction with capacity() to write past the end; 185 /// of the buffer when they know that more elements are available, and only; 186 /// update the size later. This avoids the cost of value initializing elements; 187 /// which will only be overwritten.; 188 void set_size(size_t N); 189 {; 190 if (N > capacity()) {; 191 throw std::runtime_error(""Setting size to a value greater than capacity."");; 192 }; 193 fSize = N;; 194 }; 195};; 196 ; 197/// Used to figure out the offset of the first element of an RVec; 198template <class T>; 199struct SmallVectorAlignmentAndSize {; 200 alignas(SmallVectorBase) char Base[sizeof(SmallVectorBase)];; 201 alignas(T) char FirstEl[sizeof(T)];; 202};; 203 ; 204/// This is the part of SmallVectorTemplateBase which does not depend on whether the type T is a POD.; 205template <typename T>; 206class R__CLING_PTRCHECK(off) SmallVectorTemplateCommon : public SmallVectorBase {; 207 using Base = SmallVectorBase;; 208 ; 209 /// Find the address of the first element. For this pointer math to be valid; 210 /// with small-si",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
Energy Efficiency,adapt,adapted,". ROOT: math/vecops/inc/ROOT/RVec.hxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. RVec.hxx. Go to the documentation of this file. 1// Author: Enrico Guiraud, Enric Tejedor, Danilo Piparo CERN 04/2021; 2// Implementation adapted from from llvm::SmallVector.; 3// See /math/vecops/ARCHITECTURE.md for more information.; 4 ; 5/*************************************************************************; 6 * Copyright (C) 1995-2021, Rene Brun and Fons Rademakers. *; 7 * All rights reserved. *; 8 * *; 9 * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 *************************************************************************/; 12 ; 13#ifndef ROOT_RVEC; 14#define ROOT_RVEC; 15 ; 16#if __cplusplus > 201402L; 17#define R__RVEC_NODISCARD [[nodiscard]]; 18#else; 19#define R__RVEC_NODISCARD; 20#endif; 21 ; 22#ifdef _WIN32; 23 #ifndef M_PI; 24 #ifndef _USE_MATH_DEFINES; 25 #define _USE_MATH_DEFINES; 26 #endif; 27 #include <math.h>; 28 #undef _USE_MATH_DEFINES; 29 #endif; 30 #define _VECOPS_USE_EXTERN_TEMPLATES false; 31#else; 32 #define _VECOPS_USE_EXTERN_TEMPLATES true; 33#endif; 34 ; 35#include <Rtypes.h> // R__CLING_PTRCHECK; 36#include <TError.h> // R__ASSERT; 37 ; 38#include <algorithm>; 39#include <cmath>; 40#include <cstring>; 41#include <limits> // for numeric_limits; 42#include <memory> // uninitialized_value_construct; 43#include <new>; 44#include <numeric> // for inner_product; 45#include <sstream>; 46#include <stdexcept>; 47#include <string>; 48#include <tuple>; 49#include <type_traits>; 50#include <utility>; 51#include <vector>; 52 ; 53#ifdef R__HAS_VDT; 54#include <vdt/vdtMath.h>; 55#endif; 56 ; 57 ; 58namespace ROOT {; 59 ; 60namespace VecOps {; 61template<typename T>; 62class RVec;; 63}; 64 ; 65namespace Internal {; 66namespace VecOps {; 67 ; 68template<typename T>; 69using RVec = ROOT::VecOps::RVec<T>;; 70 ; 71// clang-format off; 72template <typena",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
Integrability,depend,depend,"() const { return fSize; }; 175 size_t capacity() const noexcept { return Owns() ? fCapacity : fSize; }; 176 ; 177 R__RVEC_NODISCARD bool empty() const { return !fSize; }; 178 ; 179 /// Set the array size to \p N, which the current array must have enough; 180 /// capacity for.; 181 ///; 182 /// This does not construct or destroy any elements in the vector.; 183 ///; 184 /// Clients can use this in conjunction with capacity() to write past the end; 185 /// of the buffer when they know that more elements are available, and only; 186 /// update the size later. This avoids the cost of value initializing elements; 187 /// which will only be overwritten.; 188 void set_size(size_t N); 189 {; 190 if (N > capacity()) {; 191 throw std::runtime_error(""Setting size to a value greater than capacity."");; 192 }; 193 fSize = N;; 194 }; 195};; 196 ; 197/// Used to figure out the offset of the first element of an RVec; 198template <class T>; 199struct SmallVectorAlignmentAndSize {; 200 alignas(SmallVectorBase) char Base[sizeof(SmallVectorBase)];; 201 alignas(T) char FirstEl[sizeof(T)];; 202};; 203 ; 204/// This is the part of SmallVectorTemplateBase which does not depend on whether the type T is a POD.; 205template <typename T>; 206class R__CLING_PTRCHECK(off) SmallVectorTemplateCommon : public SmallVectorBase {; 207 using Base = SmallVectorBase;; 208 ; 209 /// Find the address of the first element. For this pointer math to be valid; 210 /// with small-size of 0 for T with lots of alignment, it's important that; 211 /// SmallVectorStorage is properly-aligned even for small-size of 0.; 212 void *getFirstEl() const; 213 {; 214 return const_cast<void *>(reinterpret_cast<const void *>(reinterpret_cast<const char *>(this) +; 215 offsetof(SmallVectorAlignmentAndSize<T>, FirstEl)));; 216 }; 217 // Space after 'FirstEl' is clobbered, do not add any instance vars after it.; 218 ; 219protected:; 220 SmallVectorTemplateCommon(size_t Size) : Base(getFirstEl(), Size) {}; 221 ; 222 void grow_pod(s",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
Modifiability,adapt,adapted,". ROOT: math/vecops/inc/ROOT/RVec.hxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. RVec.hxx. Go to the documentation of this file. 1// Author: Enrico Guiraud, Enric Tejedor, Danilo Piparo CERN 04/2021; 2// Implementation adapted from from llvm::SmallVector.; 3// See /math/vecops/ARCHITECTURE.md for more information.; 4 ; 5/*************************************************************************; 6 * Copyright (C) 1995-2021, Rene Brun and Fons Rademakers. *; 7 * All rights reserved. *; 8 * *; 9 * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 *************************************************************************/; 12 ; 13#ifndef ROOT_RVEC; 14#define ROOT_RVEC; 15 ; 16#if __cplusplus > 201402L; 17#define R__RVEC_NODISCARD [[nodiscard]]; 18#else; 19#define R__RVEC_NODISCARD; 20#endif; 21 ; 22#ifdef _WIN32; 23 #ifndef M_PI; 24 #ifndef _USE_MATH_DEFINES; 25 #define _USE_MATH_DEFINES; 26 #endif; 27 #include <math.h>; 28 #undef _USE_MATH_DEFINES; 29 #endif; 30 #define _VECOPS_USE_EXTERN_TEMPLATES false; 31#else; 32 #define _VECOPS_USE_EXTERN_TEMPLATES true; 33#endif; 34 ; 35#include <Rtypes.h> // R__CLING_PTRCHECK; 36#include <TError.h> // R__ASSERT; 37 ; 38#include <algorithm>; 39#include <cmath>; 40#include <cstring>; 41#include <limits> // for numeric_limits; 42#include <memory> // uninitialized_value_construct; 43#include <new>; 44#include <numeric> // for inner_product; 45#include <sstream>; 46#include <stdexcept>; 47#include <string>; 48#include <tuple>; 49#include <type_traits>; 50#include <utility>; 51#include <vector>; 52 ; 53#ifdef R__HAS_VDT; 54#include <vdt/vdtMath.h>; 55#endif; 56 ; 57 ; 58namespace ROOT {; 59 ; 60namespace VecOps {; 61template<typename T>; 62class RVec;; 63}; 64 ; 65namespace Internal {; 66namespace VecOps {; 67 ; 68template<typename T>; 69using RVec = ROOT::VecOps::RVec<T>;; 70 ; 71// clang-format off; 72template <typena",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
Performance,optimiz,optimizes,"range [I, E) onto the uninitialized memory; 438 /// starting with ""Dest"", constructing elements into it as needed.; 439 template <typename It1, typename It2>; 440 static void uninitialized_move(It1 I, It1 E, It2 Dest); 441 {; 442 // Just do a copy.; 443 uninitialized_copy(I, E, Dest);; 444 }; 445 ; 446 /// Copy the range [I, E) onto the uninitialized memory; 447 /// starting with ""Dest"", constructing elements into it as needed.; 448 template <typename It1, typename It2>; 449 static void uninitialized_copy(It1 I, It1 E, It2 Dest); 450 {; 451 // Arbitrary iterator types; just use the basic implementation.; 452 std::uninitialized_copy(I, E, Dest);; 453 }; 454 ; 455 /// Copy the range [I, E) onto the uninitialized memory; 456 /// starting with ""Dest"", constructing elements into it as needed.; 457 template <typename T1, typename T2>; 458 static void uninitialized_copy(; 459 T1 *I, T1 *E, T2 *Dest,; 460 typename std::enable_if<std::is_same<typename std::remove_const<T1>::type, T2>::value>::type * = nullptr); 461 {; 462 // Use memcpy for PODs iterated by pointers (which includes SmallVector; 463 // iterators): std::uninitialized_copy optimizes to memmove, but we can; 464 // use memcpy here. Note that I and E are iterators and thus might be; 465 // invalid for memcpy if they are equal.; 466 if (I != E); 467 memcpy(reinterpret_cast<void *>(Dest), I, (E - I) * sizeof(T));; 468 }; 469 ; 470 /// Double the size of the allocated memory, guaranteeing space for at; 471 /// least one more element or MinSize if specified.; 472 void grow(size_t MinSize = 0); 473 {; 474 this->grow_pod(MinSize, sizeof(T));; 475 }; 476 ; 477public:; 478 using iterator = typename SuperClass::iterator;; 479 using const_iterator = typename SuperClass::const_iterator;; 480 using reference = typename SuperClass::reference;; 481 using size_type = typename SuperClass::size_type;; 482 ; 483 void push_back(const T &Elt); 484 {; 485 if (R__unlikely(this->size() >= this->capacity())); 486 this->grow();; 487 memcpy",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
Safety,avoid,avoids,");; 166 /// Report that this vector is already at maximum capacity. Throws; 167 /// std::length_error or calls report_fatal_error.; 168 static void report_at_maximum_capacity();; 169 ; 170 /// If false, the RVec is in ""memory adoption"" mode, i.e. it is acting as a view on a memory buffer it does not own.; 171 bool Owns() const { return fCapacity != -1; }; 172 ; 173public:; 174 size_t size() const { return fSize; }; 175 size_t capacity() const noexcept { return Owns() ? fCapacity : fSize; }; 176 ; 177 R__RVEC_NODISCARD bool empty() const { return !fSize; }; 178 ; 179 /// Set the array size to \p N, which the current array must have enough; 180 /// capacity for.; 181 ///; 182 /// This does not construct or destroy any elements in the vector.; 183 ///; 184 /// Clients can use this in conjunction with capacity() to write past the end; 185 /// of the buffer when they know that more elements are available, and only; 186 /// update the size later. This avoids the cost of value initializing elements; 187 /// which will only be overwritten.; 188 void set_size(size_t N); 189 {; 190 if (N > capacity()) {; 191 throw std::runtime_error(""Setting size to a value greater than capacity."");; 192 }; 193 fSize = N;; 194 }; 195};; 196 ; 197/// Used to figure out the offset of the first element of an RVec; 198template <class T>; 199struct SmallVectorAlignmentAndSize {; 200 alignas(SmallVectorBase) char Base[sizeof(SmallVectorBase)];; 201 alignas(T) char FirstEl[sizeof(T)];; 202};; 203 ; 204/// This is the part of SmallVectorTemplateBase which does not depend on whether the type T is a POD.; 205template <typename T>; 206class R__CLING_PTRCHECK(off) SmallVectorTemplateCommon : public SmallVectorBase {; 207 using Base = SmallVectorBase;; 208 ; 209 /// Find the address of the first element. For this pointer math to be valid; 210 /// with small-size of 0 for T with lots of alignment, it's important that; 211 /// SmallVectorStorage is properly-aligned even for small-size of 0.; 212 void *getFir",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
Security,expose,expose,"8 ; 219protected:; 220 SmallVectorTemplateCommon(size_t Size) : Base(getFirstEl(), Size) {}; 221 ; 222 void grow_pod(size_t MinSize, size_t TSize) { Base::grow_pod(getFirstEl(), MinSize, TSize); }; 223 ; 224 /// Return true if this is a smallvector which has not had dynamic; 225 /// memory allocated for it.; 226 bool isSmall() const { return this->fBeginX == getFirstEl(); }; 227 ; 228 /// Put this vector in a state of being small.; 229 void resetToSmall(); 230 {; 231 this->fBeginX = getFirstEl();; 232 // from the original LLVM implementation:; 233 // FIXME: Setting fCapacity to 0 is suspect.; 234 this->fSize = this->fCapacity = 0;; 235 }; 236 ; 237public:; 238 // note that fSize is a _signed_ integer, but we expose it as an unsigned integer for consistency with STL containers; 239 // as well as backward-compatibility; 240 using size_type = size_t;; 241 using difference_type = ptrdiff_t;; 242 using value_type = T;; 243 using iterator = T *;; 244 using const_iterator = const T *;; 245 ; 246 using const_reverse_iterator = std::reverse_iterator<const_iterator>;; 247 using reverse_iterator = std::reverse_iterator<iterator>;; 248 ; 249 using reference = T &;; 250 using const_reference = const T &;; 251 using pointer = T *;; 252 using const_pointer = const T *;; 253 ; 254 using Base::capacity;; 255 using Base::empty;; 256 using Base::size;; 257 ; 258 // forward iterator creation methods.; 259 iterator begin() noexcept { return (iterator)this->fBeginX; }; 260 const_iterator begin() const noexcept { return (const_iterator)this->fBeginX; }; 261 const_iterator cbegin() const noexcept { return (const_iterator)this->fBeginX; }; 262 iterator end() noexcept { return begin() + size(); }; 263 const_iterator end() const noexcept { return begin() + size(); }; 264 const_iterator cend() const noexcept { return begin() + size(); }; 265 ; 266 // reverse iterator creation methods.; 267 reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }; 268 const_reverse_iterator rbegin(",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
Testability,log,logical,"VecF (`float`); 1340- RVecI (`int`); 1341- RVecL (`long`); 1342- RVecLL (`long long`); 1343- RVecU (`unsigned`); 1344- RVecUL (`unsigned long`); 1345- RVecULL (`unsigned long long`); 1346 ; 1347\note RVec does not attempt to be exception safe. Exceptions thrown by element constructors during insertions, swaps or; 1348other operations will be propagated potentially leaving the RVec object in an invalid state.; 1349 ; 1350\note RVec methods (e.g. `at` or `size`) follow the STL naming convention instead of the ROOT naming convention in order; 1351to make RVec a drop-in replacement for `std::vector`.; 1352 ; 1353\htmlonly; 1354<a href=""https://doi.org/10.5281/zenodo.1253756""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.1253756.svg"" alt=""DOI""></a>; 1355\endhtmlonly; 1356 ; 1357## Table of Contents; 1358- [Example](\ref example); 1359- [Arithmetic operations, logical operations and mathematical functions](\ref operationsandfunctions); 1360- [Owning and adopting memory](\ref owningandadoptingmemory); 1361- [Sorting and manipulation of indices](\ref sorting); 1362- [Usage in combination with RDataFrame](\ref usagetdataframe); 1363- [Reference for the RVec class](\ref RVecdoxyref); 1364- [Reference for RVec helper functions](https://root.cern/doc/master/namespaceROOT_1_1VecOps.html); 1365 ; 1366\anchor example; 1367## Example; 1368Suppose to have an event featuring a collection of muons with a certain pseudorapidity,; 1369momentum and charge, e.g.:; 1370~~~{.cpp}; 1371std::vector<short> mu_charge {1, 1, -1, -1, -1, 1, 1, -1};; 1372std::vector<float> mu_pt {56, 45, 32, 24, 12, 8, 7, 6.2};; 1373std::vector<float> mu_eta {3.1, -.2, -1.1, 1, 4.1, 1.6, 2.4, -.5};; 1374~~~; 1375Suppose you want to extract the transverse momenta of the muons satisfying certain; 1376criteria, for example consider only negatively charged muons with a pseudorapidity; 1377smaller or equal to 2 and with a transverse momentum greater than 10 GeV.; 1378Such a selection would require, among the ot",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
Usability,clear,clear,"72 explicit RVecImpl(unsigned N) : ROOT::Internal::VecOps::SmallVectorTemplateBase<T>(N) {}; 573 ; 574public:; 575 RVecImpl(const RVecImpl &) = delete;; 576 ; 577 ~RVecImpl(); 578 {; 579 // Subclass has already destructed this vector's elements.; 580 // If this wasn't grown from the inline copy, deallocate the old space.; 581 if (!this->isSmall() && this->Owns()); 582 free(this->begin());; 583 }; 584 ; 585 // also give up adopted memory if applicable; 586 void clear(); 587 {; 588 if (this->Owns()) {; 589 this->destroy_range(this->begin(), this->end());; 590 this->fSize = 0;; 591 } else {; 592 this->resetToSmall();; 593 }; 594 }; 595 ; 596 void resize(size_type N); 597 {; 598 if (N < this->size()) {; 599 if (this->Owns()); 600 this->destroy_range(this->begin() + N, this->end());; 601 this->set_size(N);; 602 } else if (N > this->size()) {; 603 if (this->capacity() < N); 604 this->grow(N);; 605 for (auto I = this->end(), E = this->begin() + N; I != E; ++I); 606 new (&*I) T();; 607 this->set_size(N);; 608 }; 609 }; 610 ; 611 void resize(size_type N, const T &NV); 612 {; 613 if (N < this->size()) {; 614 if (this->Owns()); 615 this->destroy_range(this->begin() + N, this->end());; 616 this->set_size(N);; 617 } else if (N > this->size()) {; 618 if (this->capacity() < N); 619 this->grow(N);; 620 std::uninitialized_fill(this->end(), this->begin() + N, NV);; 621 this->set_size(N);; 622 }; 623 }; 624 ; 625 void reserve(size_type N); 626 {; 627 if (this->capacity() < N); 628 this->grow(N);; 629 }; 630 ; 631 void pop_back_n(size_type NumItems); 632 {; 633 if (this->size() < NumItems) {; 634 throw std::runtime_error(""Popping back more elements than those available."");; 635 }; 636 if (this->Owns()); 637 this->destroy_range(this->end() - NumItems, this->end());; 638 this->set_size(this->size() - NumItems);; 639 }; 640 ; 641 R__RVEC_NODISCARD T pop_back_val(); 642 {; 643 T Result = ::std::move(this->back());; 644 this->pop_back();; 645 return Result;; 646 }; 647 ; 648 void swap(RVecI",MatchSource.WIKI,doc/master/RVec_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html
Deployability,update,updated,". ROOT: core/foundation/inc/RVersion.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Macros ; RVersion.h File Reference. #include ""ROOT/RVersion.hxx"". Include dependency graph for RVersion.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Macros; #define ROOT_RELEASE_TIME   ""00:00:00"" /* not updated anymore */;  . Macro Definition Documentation. ◆ ROOT_RELEASE_TIME. #define ROOT_RELEASE_TIME   ""00:00:00"" /* not updated anymore */. Definition at line 6 of file RVersion.h. corefoundationincRVersion.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/RVersion_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVersion_8h.html
Integrability,depend,dependency,". ROOT: core/foundation/inc/RVersion.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Macros ; RVersion.h File Reference. #include ""ROOT/RVersion.hxx"". Include dependency graph for RVersion.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Macros; #define ROOT_RELEASE_TIME   ""00:00:00"" /* not updated anymore */;  . Macro Definition Documentation. ◆ ROOT_RELEASE_TIME. #define ROOT_RELEASE_TIME   ""00:00:00"" /* not updated anymore */. Definition at line 6 of file RVersion.h. corefoundationincRVersion.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/RVersion_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RVersion_8h.html
Deployability,configurat,configuration," created QWebEngineView can be found with the command:; 355///; 356/// auto view = qparent->findChild<QWebEngineView*>(""RootWebView"");; 357 ; 358std::string RWebDisplayArgs::GetQt5EmbedQualifier(const void *qparent, const std::string &urlopt, unsigned qtversion); 359{; 360 std::string where = (qtversion >= 0x60000) ? ""qt6"" : ""qt5"";; 361 if (qparent) {; 362 where.append("":"");; 363 where.append(std::to_string((uintptr_t) qparent));; 364 }; 365 if (!urlopt.empty()) {; 366 where.append(""?"");; 367 where.append(urlopt);; 368 }; 369 return where;; 370}; RConfig.hxx; RLogger.hxx; RWebDisplayArgs.hxx; RWebWindow.hxx; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; heightOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t heightDefinition TGWin32VirtualXProxy.cxx:164; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; ROOT::RWebDisplayArgsHolds different arguments for starting browser with RWebDisplayHandle::Display() method.Definition RWebDisplayArgs.hxx:33; ROOT::RWebDisplayArgs::GetBrowserNamestd::string GetBrowserName() constReturns configured browser name.Definition RWebDisplayArgs.cxx:252; ROOT::RWebDisplayArgs::~RWebDisplayArgsvirtual ~RWebDisplayArgs()Destructor.; ROOT::RWebDisplayArgs::GetBrowserKindEBrowserKind GetBrowserKind() constreturns configured browser kind, see EBrowserKind for supported valuesDefinition RWebDisplayArgs.hxx:99; ROOT::RWebDisplayArgs::SetUrlOptRWebDisplayArgs & SetUrlOpt(const std::string &opt)set window url optionsDefinition RWebDisplayArgs.hxx:149; ROOT::RWebDisplayArgs::SetPosAsStrbool SetPosAsStr(const std::string &str)Set position of web browser window as string like ""100,100"".Definition RWebDisplayArgs.cxx:120; ROOT::RWebDisplayArgs::fExecstd::string fExec! string to run browser, used with kCus",MatchSource.WIKI,doc/master/RWebDisplayArgs_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebDisplayArgs_8cxx_source.html
Modifiability,config,configured," * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 *************************************************************************/; 12 ; 13#include <ROOT/RWebDisplayArgs.hxx>; 14 ; 15#include <ROOT/RConfig.hxx>; 16#include <ROOT/RLogger.hxx>; 17#include <ROOT/RWebWindow.hxx>; 18 ; 19#include ""TROOT.h""; 20#include <string>; 21 ; 22using namespace ROOT;; 23 ; 24ROOT::Experimental::RLogChannel &ROOT::WebGUILog(); 25{; 26 static ROOT::Experimental::RLogChannel sLog(""ROOT.WebGUI"");; 27 return sLog;; 28}; 29 ; 30 ; 31/** \class ROOT::RWebDisplayArgs; 32\ingroup webdisplay; 33 ; 34Holds different arguments for starting browser with RWebDisplayHandle::Display() method; 35 ; 36*/; 37 ; 38///////////////////////////////////////////////////////////////////////////////////////////; 39/// Default constructor.; 40/// Browser kind configured from gROOT->GetWebDisplay(); 41 ; 42RWebDisplayArgs::RWebDisplayArgs(); 43{; 44 SetBrowserKind("""");; 45}; 46 ; 47///////////////////////////////////////////////////////////////////////////////////////////; 48/// Constructor.; 49/// Browser kind specified as std::string.; 50/// See \ref SetBrowserKind method for description of allowed parameters; 51 ; 52RWebDisplayArgs::RWebDisplayArgs(const std::string &browser); 53{; 54 SetBrowserKind(browser);; 55}; 56 ; 57///////////////////////////////////////////////////////////////////////////////////////////; 58/// Constructor.; 59/// Browser kind specified as `const char *`.; 60/// See \ref SetBrowserKind method for description of allowed parameters; 61 ; 62RWebDisplayArgs::RWebDisplayArgs(const char *browser); 63{; 64 SetBrowserKind(browser);; 65}; 66 ; 67///////////////////////////////////////////////////////////////////////////////////////////; 68/// Constructor.; 69/// Let specify window width and height; 70 ; 71RWebDisplayArgs::RWebDisplayArgs(int width, int height, int x, int y, const std::string &browser); 72{; 73 SetSize(width, he",MatchSource.WIKI,doc/master/RWebDisplayArgs_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebDisplayArgs_8cxx_source.html
Testability,log,log," created QWebEngineView can be found with the command:; 355///; 356/// auto view = qparent->findChild<QWebEngineView*>(""RootWebView"");; 357 ; 358std::string RWebDisplayArgs::GetQt5EmbedQualifier(const void *qparent, const std::string &urlopt, unsigned qtversion); 359{; 360 std::string where = (qtversion >= 0x60000) ? ""qt6"" : ""qt5"";; 361 if (qparent) {; 362 where.append("":"");; 363 where.append(std::to_string((uintptr_t) qparent));; 364 }; 365 if (!urlopt.empty()) {; 366 where.append(""?"");; 367 where.append(urlopt);; 368 }; 369 return where;; 370}; RConfig.hxx; RLogger.hxx; RWebDisplayArgs.hxx; RWebWindow.hxx; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; heightOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t heightDefinition TGWin32VirtualXProxy.cxx:164; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; ROOT::RWebDisplayArgsHolds different arguments for starting browser with RWebDisplayHandle::Display() method.Definition RWebDisplayArgs.hxx:33; ROOT::RWebDisplayArgs::GetBrowserNamestd::string GetBrowserName() constReturns configured browser name.Definition RWebDisplayArgs.cxx:252; ROOT::RWebDisplayArgs::~RWebDisplayArgsvirtual ~RWebDisplayArgs()Destructor.; ROOT::RWebDisplayArgs::GetBrowserKindEBrowserKind GetBrowserKind() constreturns configured browser kind, see EBrowserKind for supported valuesDefinition RWebDisplayArgs.hxx:99; ROOT::RWebDisplayArgs::SetUrlOptRWebDisplayArgs & SetUrlOpt(const std::string &opt)set window url optionsDefinition RWebDisplayArgs.hxx:149; ROOT::RWebDisplayArgs::SetPosAsStrbool SetPosAsStr(const std::string &str)Set position of web browser window as string like ""100,100"".Definition RWebDisplayArgs.cxx:120; ROOT::RWebDisplayArgs::fExecstd::string fExec! string to run browser, used with kCus",MatchSource.WIKI,doc/master/RWebDisplayArgs_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebDisplayArgs_8cxx_source.html
Usability,clear,clear,"rowser; 147/// firefox - use Mozilla Firefox web browser; 148/// edge - use Microsoft Edge web browser (Windows only); 149/// native - either chrome/edge or firefox, only these browsers support batch (headless) mode; 150/// default - default system web-browser, no batch mode; 151/// cef - Chromium Embeded Framework, local display, local communication; 152/// qt5 - Qt5 QWebEngine, local display, local communication; 153/// qt6 - Qt6 QWebEngineCore, local display, local communication; 154/// local - either cef or qt5 or qt6; 155/// off - disable web display; 156/// on - first try ""local"", then ""native"", then ""default"" (default option); 157/// `<prog>` - any program name which will be started to open widget URL, like ""/usr/bin/opera""; 158 ; 159RWebDisplayArgs &RWebDisplayArgs::SetBrowserKind(const std::string &_kind); 160{; 161 std::string kind = _kind;; 162 ; 163 auto pos = kind.find(""?"");; 164 if (pos == 0) {; 165 SetUrlOpt(kind.substr(1));; 166 kind.clear();; 167 } else if (pos != std::string::npos) {; 168 SetUrlOpt(kind.substr(pos+1));; 169 kind.resize(pos);; 170 }; 171 ; 172 pos = kind.find(""size:"");; 173 if (pos != std::string::npos) {; 174 auto epos = kind.find_first_of("" ;"", pos+5);; 175 if (epos == std::string::npos) epos = kind.length();; 176 SetSizeAsStr(kind.substr(pos+5, epos-pos-5));; 177 kind.erase(pos, epos-pos);; 178 }; 179 ; 180 pos = kind.find(""pos:"");; 181 if (pos != std::string::npos) {; 182 auto epos = kind.find_first_of("" ;"", pos+4);; 183 if (epos == std::string::npos) epos = kind.length();; 184 SetPosAsStr(kind.substr(pos+4, epos-pos-4));; 185 kind.erase(pos, epos-pos);; 186 }; 187 ; 188 pos = kind.rfind(""headless"");; 189 if ((pos != std::string::npos) && (pos == kind.length() - 8)) {; 190 SetHeadless(true);; 191 kind.resize(pos);; 192 if ((pos > 0) && (kind[pos-1] == ';')) kind.resize(pos-1);; 193 }; 194 ; 195 // very special handling of qt5/qt6 which can specify pointer as a string; 196 if ((kind.find(""qt5:"") == 0) || (kind.find(""qt6:"") == 0)) ",MatchSource.WIKI,doc/master/RWebDisplayArgs_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebDisplayArgs_8cxx_source.html
Availability,avail,available,"WebWindow &win, bool remote = false, std::string *produced_key = nullptr);; 76 ; 77 bool CreateServer(bool with_http = false);; 78 ; 79 bool InformListener(const std::string &msg);; 80 ; 81 static std::string GenerateKey(int keylen = 32);; 82 ; 83public:; 84 RWebWindowsManager();; 85 ; 86 ~RWebWindowsManager();; 87 ; 88 /// Returns THttpServer instance; 89 THttpServer *GetServer() const { return fServer.get(); }; 90 ; 91 /// Returns http address of the server, empty string when not available; 92 std::string GetServerAddr() const { return fAddr; }; 93 ; 94 /// Assign show callback which can catch window showing, used by RBrowser; 95 void SetShowCallback(WebWindowShowCallback_t func) { fShowCallback = func; }; 96 ; 97 /// Assign show callback which can catch window showing, used by RBrowser; 98 void SetDeleteCallback(WebWindowDeleteCallback_t func) { fDeleteCallback = func; }; 99 ; 100 static std::shared_ptr<RWebWindowsManager> &Instance();; 101 ; 102 std::shared_ptr<RWebWindow> CreateWindow();; 103 ; 104 void Terminate();; 105 ; 106 static bool IsMainThrd();; 107 static void AssignMainThrd();; 108 ; 109 static void SetLoopbackMode(bool on = true);; 110 static bool IsLoopbackMode();; 111 ; 112 static void SetUseSessionKey(bool on = true);; 113 static void SetUseConnectionKey(bool on = true);; 114 ; 115 static void AddServerLocation(const std::string &server_prefix, const std::string &files_path);; 116 static std::map<std::string, std::string> GetServerLocations();; 117 static void ClearServerLocations();; 118};; 119 ; 120} // namespace ROOT; 121 ; 122#endif; RWebWindow.hxx; onOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void onDefinition TGWin32VirtualXProxy.cxx:106; winOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttribute",MatchSource.WIKI,doc/master/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html
Deployability,configurat,configuration,"ssEventsbool fExternalProcessEvents! indicate that there are external process events engineDefinition RWebWindowsManager.hxx:54; ROOT::RWebWindowsManager::fMutexstd::recursive_mutex fMutex! main mutex, used for window creationsDefinition RWebWindowsManager.hxx:49; ROOT::RWebWindowsManager::SetDeleteCallbackvoid SetDeleteCallback(WebWindowDeleteCallback_t func)Assign show callback which can catch window showing, used by RBrowser.Definition RWebWindowsManager.hxx:98; ROOT::RWebWindowsManager::RWebWindowsManagerRWebWindowsManager()window manager constructor Required here for correct usage of unique_ptr<THttpServer>Definition RWebWindowsManager.cxx:273; ROOT::RWebWindowsManager::WaitForint WaitFor(RWebWindow &win, WebWindowWaitFunc_t check, bool timed=false, double tm=-1)Waits until provided check function or lambdas returns non-zero value Regularly calls WebWindow::Sync...Definition RWebWindowsManager.cxx:901; ROOT::RWebWindowsManager::ClearServerLocationsstatic void ClearServerLocations()Clear all server locations Does not change configuration of already running HTTP server.Definition RWebWindowsManager.cxx:239; ROOT::RWebWindowsManager::fShowCallbackWebWindowShowCallback_t fShowCallback! function called for each RWebWindow::Show callDefinition RWebWindowsManager.hxx:56; ROOT::RWebWindowsManager::fDeleteCallbackWebWindowDeleteCallback_t fDeleteCallback! function called when RWebWindow is destroyedDefinition RWebWindowsManager.hxx:57; ROOT::RWebWindowsManager::ShowWindowunsigned ShowWindow(RWebWindow &win, const RWebDisplayArgs &args)Show window in specified location, see Show() method for more details.Definition RWebWindowsManager.cxx:778; ROOT::RWebWindowsManager::fAddrstd::string fAddr! HTTP address of the serverDefinition RWebWindowsManager.hxx:46; ROOT::RWebWindowsManager::Terminatevoid Terminate()Terminate http server and ROOT application.Definition RWebWindowsManager.cxx:937; ROOT::RWebWindowsManager::fIdCntunsigned fIdCnt! counter for identifiersDefinition RWebW",MatchSource.WIKI,doc/master/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html
Integrability,message,message,"nderThreadsbool fUseSenderThreads! use extra threads for sending data from RWebWindow to clientsDefinition RWebWindowsManager.hxx:52; ROOT::RWebWindowsManager::fServerstd::unique_ptr< THttpServer > fServer! central communication with the all used displaysDefinition RWebWindowsManager.hxx:45; ROOT::RWebWindowsManager::SetLoopbackModestatic void SetLoopbackMode(bool on=true)Set loopback mode for THttpServer used for web widgets By default is on.Definition RWebWindowsManager.cxx:129; ROOT::RWebWindowsManager::IsMainThrdstatic bool IsMainThrd()Returns true when called from main process Main process recognized at the moment when library is load...Definition RWebWindowsManager.cxx:105; ROOT::RWebWindowsManager::Instancestatic std::shared_ptr< RWebWindowsManager > & Instance()Returns default window manager Used to display all standard ROOT elements like TCanvas or TFitPanel.Definition RWebWindowsManager.cxx:79; ROOT::RWebWindowsManager::InformListenerbool InformListener(const std::string &msg)If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket.Definition RWebWindowsManager.cxx:299; ROOT::RWebWindowsManager::fLaunchTmoutfloat fLaunchTmout! timeout in seconds to start browser process, default 30sDefinition RWebWindowsManager.hxx:53; ROOT::RWebWindowsManager::GetServerLocationsstatic std::map< std::string, std::string > GetServerLocations()Returns server locations as <std::string, std::string> Key is location name (with slash at the end) a...Definition RWebWindowsManager.cxx:209; ROOT::RWebWindowsManager::GetUrlstd::string GetUrl(RWebWindow &win, bool remote=false, std::string *produced_key=nullptr)Provide URL address to access specified window from inside or from remote.Definition RWebWindowsManager.cxx:686; ROOT::RWebWindowsManager::Unregistervoid Unregister(RWebWindow &win)Release all references to specified window Called from RWebWindow destructor.Definition RWebWindowsManager.cxx:674; ROOT::RWebWindowsManager::IsLoopbackModestatic boo",MatchSource.WIKI,doc/master/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html
Modifiability,config,configure,"ance to create and show web-based windows like Canvas or FitPanel.Definition RWebWindowsManager.hxx:40; ROOT::RWebWindowsManager::AddServerLocationstatic void AddServerLocation(const std::string &server_prefix, const std::string &files_path)Configure server location which can be used for loading of custom scripts or files When THttpServer i...Definition RWebWindowsManager.cxx:178; ROOT::RWebWindowsManager::GenerateKeystatic std::string GenerateKey(int keylen=32)Static method to generate cryptographic key Parameter keylen defines length of cryptographic key in b...Definition RWebWindowsManager.cxx:250; ROOT::RWebWindowsManager::fUseSessionKeybool fUseSessionKey! is session key has to be used for data signingDefinition RWebWindowsManager.hxx:48; ROOT::RWebWindowsManager::fAssgnExecstd::unique_ptr< TExec > fAssgnExec! special exec to assign thread id via ProcessEventsDefinition RWebWindowsManager.hxx:55; ROOT::RWebWindowsManager::CreateServerbool CreateServer(bool with_http=false)Creates http server, if required - with real http engine (civetweb) One could configure concrete HTTP...Definition RWebWindowsManager.cxx:430; ROOT::RWebWindowsManager::GetLaunchTmoutfloat GetLaunchTmout() constReturns timeout for launching new browser process.Definition RWebWindowsManager.hxx:66; ROOT::RWebWindowsManager::SetUseConnectionKeystatic void SetUseConnectionKey(bool on=true)Enable or disable usage of connection key (default on) If enabled, each connection (and reconnection)...Definition RWebWindowsManager.cxx:168; ROOT::RWebWindowsManager::fExternalProcessEventsbool fExternalProcessEvents! indicate that there are external process events engineDefinition RWebWindowsManager.hxx:54; ROOT::RWebWindowsManager::fMutexstd::recursive_mutex fMutex! main mutex, used for window creationsDefinition RWebWindowsManager.hxx:49; ROOT::RWebWindowsManager::SetDeleteCallbackvoid SetDeleteCallback(WebWindowDeleteCallback_t func)Assign show callback which can catch window showing, used by RBrowser.Defin",MatchSource.WIKI,doc/master/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html
Performance,load,loading,"or GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void onDefinition TGWin32VirtualXProxy.cxx:106; winOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t winDefinition TGWin32VirtualXProxy.cxx:186; THttpEngine.h; ROOT::RWebDisplayArgsHolds different arguments for starting browser with RWebDisplayHandle::Display() method.Definition RWebDisplayArgs.hxx:33; ROOT::RWebWindowRepresents web window, which can be shown in web browser or any other supported environment.Definition RWebWindow.hxx:54; ROOT::RWebWindowsManagerCentral instance to create and show web-based windows like Canvas or FitPanel.Definition RWebWindowsManager.hxx:40; ROOT::RWebWindowsManager::AddServerLocationstatic void AddServerLocation(const std::string &server_prefix, const std::string &files_path)Configure server location which can be used for loading of custom scripts or files When THttpServer i...Definition RWebWindowsManager.cxx:178; ROOT::RWebWindowsManager::GenerateKeystatic std::string GenerateKey(int keylen=32)Static method to generate cryptographic key Parameter keylen defines length of cryptographic key in b...Definition RWebWindowsManager.cxx:250; ROOT::RWebWindowsManager::fUseSessionKeybool fUseSessionKey! is session key has to be used for data signingDefinition RWebWindowsManager.hxx:48; ROOT::RWebWindowsManager::fAssgnExecstd::unique_ptr< TExec > fAssgnExec! special exec to assign thread id via ProcessEventsDefinition RWebWindowsManager.hxx:55; ROOT::RWebWindowsManager::CreateServerbool CreateServer(bool with_http=false)Creates http server, if required - with real http engine (civetweb) One could configure concrete HTTP...Definition RWebWindowsManager.cxx:430; ROOT::RWebWindowsManager::GetLaunchTmoutfloat GetLaunchTmout() constReturns timeout f",MatchSource.WIKI,doc/master/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html
Safety,timeout,timeout,"pThrd{false}; ///<! use special thread for THttpServer; 52 bool fUseSenderThreads{false}; ///<! use extra threads for sending data from RWebWindow to clients; 53 float fLaunchTmout{30.}; ///<! timeout in seconds to start browser process, default 30s; 54 bool fExternalProcessEvents{false}; ///<! indicate that there are external process events engine; 55 std::unique_ptr<TExec> fAssgnExec; ///<! special exec to assign thread id via ProcessEvents; 56 WebWindowShowCallback_t fShowCallback; ///<! function called for each RWebWindow::Show call; 57 WebWindowDeleteCallback_t fDeleteCallback; ///<! function called when RWebWindow is destroyed; 58 ; 59 /// Returns true if http server use special thread for requests processing (default off); 60 bool IsUseHttpThread() const { return fUseHttpThrd; }; 61 ; 62 /// Returns true if extra threads to send data via websockets will be used (default off); 63 bool IsUseSenderThreads() const { return fUseSenderThreads; }; 64 ; 65 /// Returns timeout for launching new browser process; 66 float GetLaunchTmout() const { return fLaunchTmout; }; 67 ; 68 void Unregister(RWebWindow &win);; 69 ; 70 /// Show window in specified location, see Show() method for more details; 71 unsigned ShowWindow(RWebWindow &win, const RWebDisplayArgs &args);; 72 ; 73 int WaitFor(RWebWindow &win, WebWindowWaitFunc_t check, bool timed = false, double tm = -1);; 74 ; 75 std::string GetUrl(RWebWindow &win, bool remote = false, std::string *produced_key = nullptr);; 76 ; 77 bool CreateServer(bool with_http = false);; 78 ; 79 bool InformListener(const std::string &msg);; 80 ; 81 static std::string GenerateKey(int keylen = 32);; 82 ; 83public:; 84 RWebWindowsManager();; 85 ; 86 ~RWebWindowsManager();; 87 ; 88 /// Returns THttpServer instance; 89 THttpServer *GetServer() const { return fServer.get(); }; 90 ; 91 /// Returns http address of the server, empty string when not available; 92 std::string GetServerAddr() const { return fAddr; }; 93 ; 94 /// Assign show callback whic",MatchSource.WIKI,doc/master/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html
Security,access,access,"t when library is load...Definition RWebWindowsManager.cxx:105; ROOT::RWebWindowsManager::Instancestatic std::shared_ptr< RWebWindowsManager > & Instance()Returns default window manager Used to display all standard ROOT elements like TCanvas or TFitPanel.Definition RWebWindowsManager.cxx:79; ROOT::RWebWindowsManager::InformListenerbool InformListener(const std::string &msg)If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket.Definition RWebWindowsManager.cxx:299; ROOT::RWebWindowsManager::fLaunchTmoutfloat fLaunchTmout! timeout in seconds to start browser process, default 30sDefinition RWebWindowsManager.hxx:53; ROOT::RWebWindowsManager::GetServerLocationsstatic std::map< std::string, std::string > GetServerLocations()Returns server locations as <std::string, std::string> Key is location name (with slash at the end) a...Definition RWebWindowsManager.cxx:209; ROOT::RWebWindowsManager::GetUrlstd::string GetUrl(RWebWindow &win, bool remote=false, std::string *produced_key=nullptr)Provide URL address to access specified window from inside or from remote.Definition RWebWindowsManager.cxx:686; ROOT::RWebWindowsManager::Unregistervoid Unregister(RWebWindow &win)Release all references to specified window Called from RWebWindow destructor.Definition RWebWindowsManager.cxx:674; ROOT::RWebWindowsManager::IsLoopbackModestatic bool IsLoopbackMode()Returns true if loopback mode used by THttpServer for web widgets.Definition RWebWindowsManager.cxx:147; ROOT::RWebWindowsManager::CreateWindowstd::shared_ptr< RWebWindow > CreateWindow()Creates new window To show window, RWebWindow::Show() have to be called.Definition RWebWindowsManager.cxx:619; TExecTExec is a utility class that can be used to execute a C++ command when some event happens in a pad.Definition TExec.h:26; THttpServerOnline http server for arbitrary ROOT application.Definition THttpServer.h:31; THttpWSHandlerClass for user-side handling of websocket with THttpServer.Definition THttpWS",MatchSource.WIKI,doc/master/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html
Integrability,protocol,protocol,"ect event; 163 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 164 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 165 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 166 std::thread fWindowThrd; ///<! special thread for that window; 167 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 168 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 169 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 170 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 171 float fOperationTmout{50.}; ///<! timeout in seconds to perform synchronous operation, default 50s; 172 std::string fClientVersion; ///<! configured client version, used as prefix in scripts URL; 173 std::string fProtocolFileName; ///<! local file where communication protocol will be written; 174 int fProtocolCnt{-1}; ///<! counter for protocol recording; 175 unsigned fProtocolConnId{0}; ///<! connection id, which is used for writing protocol; 176 std::string fProtocolPrefix; ///<! prefix for created files names; 177 std::string fProtocol; ///<! protocol; 178 std::string fUserArgs; ///<! arbitrary JSON code, which is accessible via conn.getUserArgs() method; 179 std::shared_ptr<void> fClearOnClose; ///<! entry which is cleared when last connection is closed; 180 ; 181 std::shared_ptr<RWebWindowWSHandler> CreateWSHandler(std::shared_ptr<RWebWindowsManager> mgr, unsigned id, double tmout);; 182 ; 183 bool ProcessWS(THttpCallArg &arg);; 184 ; 185 void CompleteWSSend(unsigned wsid);; 186 ; 187 ConnectionsList_t GetWindowConnections(unsigned connid = 0, bool only_active = false) const;; 188 ; 189 /// Find connection with specified websocket id; 190 std::shared_ptr<WebConn> FindConnection(unsigned wsid);; 191 ; 192 std::shared_ptr<WebConn> RemoveConnection(unsigned wsid);; 193 ; 194 bool _CanTrustIn(std::shared_ptr<WebC",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
Modifiability,config,configured,"ect event; 163 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 164 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 165 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 166 std::thread fWindowThrd; ///<! special thread for that window; 167 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 168 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 169 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 170 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 171 float fOperationTmout{50.}; ///<! timeout in seconds to perform synchronous operation, default 50s; 172 std::string fClientVersion; ///<! configured client version, used as prefix in scripts URL; 173 std::string fProtocolFileName; ///<! local file where communication protocol will be written; 174 int fProtocolCnt{-1}; ///<! counter for protocol recording; 175 unsigned fProtocolConnId{0}; ///<! connection id, which is used for writing protocol; 176 std::string fProtocolPrefix; ///<! prefix for created files names; 177 std::string fProtocol; ///<! protocol; 178 std::string fUserArgs; ///<! arbitrary JSON code, which is accessible via conn.getUserArgs() method; 179 std::shared_ptr<void> fClearOnClose; ///<! entry which is cleared when last connection is closed; 180 ; 181 std::shared_ptr<RWebWindowWSHandler> CreateWSHandler(std::shared_ptr<RWebWindowsManager> mgr, unsigned id, double tmout);; 182 ; 183 bool ProcessWS(THttpCallArg &arg);; 184 ; 185 void CompleteWSSend(unsigned wsid);; 186 ; 187 ConnectionsList_t GetWindowConnections(unsigned connid = 0, bool only_active = false) const;; 188 ; 189 /// Find connection with specified websocket id; 190 std::shared_ptr<WebConn> FindConnection(unsigned wsid);; 191 ; 192 std::shared_ptr<WebConn> RemoveConnection(unsigned wsid);; 193 ; 194 bool _CanTrustIn(std::shared_ptr<WebC",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
Performance,queue,queue,"hxx""; 19 ; 20#include <memory>; 21#include <vector>; 22#include <string>; 23#include <queue>; 24#include <map>; 25#include <functional>; 26#include <mutex>; 27#include <thread>; 28#include <chrono>; 29 ; 30class THttpCallArg;; 31class THttpServer;; 32 ; 33namespace ROOT {; 34 ; 35/// function signature for connect/disconnect call-backs; 36/// argument is connection id; 37using WebWindowConnectCallback_t = std::function<void(unsigned)>;; 38 ; 39/// function signature for call-backs from the window clients; 40/// first argument is connection id, second is received data; 41using WebWindowDataCallback_t = std::function<void(unsigned, const std::string &)>;; 42 ; 43/// function signature for waiting call-backs; 44/// Such callback used when calling thread need to waits for some special data,; 45/// but wants to run application event loop; 46/// As argument, spent time in second will be provided; 47/// Waiting will be performed until function returns non-zero value; 48using WebWindowWaitFunc_t = std::function<int(double)>;; 49 ; 50class RFileDialog;; 51class RWebWindowsManager;; 52c",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
Safety,timeout,timeout,"ect event; 163 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 164 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 165 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 166 std::thread fWindowThrd; ///<! special thread for that window; 167 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 168 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 169 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 170 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 171 float fOperationTmout{50.}; ///<! timeout in seconds to perform synchronous operation, default 50s; 172 std::string fClientVersion; ///<! configured client version, used as prefix in scripts URL; 173 std::string fProtocolFileName; ///<! local file where communication protocol will be written; 174 int fProtocolCnt{-1}; ///<! counter for protocol recording; 175 unsigned fProtocolConnId{0}; ///<! connection id, which is used for writing protocol; 176 std::string fProtocolPrefix; ///<! prefix for created files names; 177 std::string fProtocol; ///<! protocol; 178 std::string fUserArgs; ///<! arbitrary JSON code, which is accessible via conn.getUserArgs() method; 179 std::shared_ptr<void> fClearOnClose; ///<! entry which is cleared when last connection is closed; 180 ; 181 std::shared_ptr<RWebWindowWSHandler> CreateWSHandler(std::shared_ptr<RWebWindowsManager> mgr, unsigned id, double tmout);; 182 ; 183 bool ProcessWS(THttpCallArg &arg);; 184 ; 185 void CompleteWSSend(unsigned wsid);; 186 ; 187 ConnectionsList_t GetWindowConnections(unsigned connid = 0, bool only_active = false) const;; 188 ; 189 /// Find connection with specified websocket id; 190 std::shared_ptr<WebConn> FindConnection(unsigned wsid);; 191 ; 192 std::shared_ptr<WebConn> RemoveConnection(unsigned wsid);; 193 ; 194 bool _CanTrustIn(std::shared_ptr<WebC",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
Security,authenticat,authentication,"Data(data) {}; 135 };; 136 ; 137 using ConnectionsList_t = std::vector<std::shared_ptr<WebConn>>;; 138 ; 139 std::shared_ptr<RWebWindowsManager> fMgr; ///<! display manager; 140 std::shared_ptr<RWebWindow> fMaster; ///<! master window where this window is embedded; 141 std::vector<MasterConn> fMasterConns; ///<! master connections; 142 std::string fDefaultPage; ///<! HTML page (or file name) returned when window URL is opened; 143 std::string fPanelName; ///<! panel name which should be shown in the window; 144 unsigned fId{0}; ///<! unique identifier; 145 bool fUseServerThreads{false}; ///<! indicates that server thread is using, no special window thread; 146 bool fUseProcessEvents{false}; ///<! all window functionality will run through process events; 147 bool fProcessMT{false}; ///<! if window event processing performed in dedicated thread; 148 bool fSendMT{false}; ///<! true is special threads should be used for sending data; 149 bool fRequireAuthKey{true}; ///<! defines if authentication key always required when connect to the widget; 150 std::shared_ptr<RWebWindowWSHandler> fWSHandler; ///<! specialize websocket handler for all incoming connections; 151 unsigned fConnCnt{0}; ///<! counter of new connections to assign ids; 152 ConnectionsList_t fPendingConn; ///<! list of pending connection with pre-assigned keys; 153 ConnectionsList_t fConn; ///<! list of all accepted connections; 154 mutable std::mutex fConnMutex; ///<! mutex used to protect connection list; 155 unsigned fConnLimit{1}; ///<! number of allowed active connections; 156 std::string fConnToken; ///<! value of ""token"" URL parameter which should be provided for connecting window; 157 bool fNativeOnlyConn{false}; ///<! only native connection are allowed, created by Show() method; 158 bool fUseCurrentDir{false}; ///<! if window can access local files via currentdir/ path of http server; 159 unsigned fMaxQueueLength{10}; ///<! maximal number of queue entries; 160 WebWindowConnectCallback_t fConnCallback",MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
Usability,clear,cleared,,MatchSource.WIKI,doc/master/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html
Safety,avoid,avoid,". ROOT: tutorials/graphics/saveall.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. saveall.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Creates many canvases and save as images or pdf. ; This macro creates 100 canvases and store them in different images files using TCanvas::SaveAll() method. Demonstrated how different output format can be used in batch mode.; ; void saveall(); {; gROOT->SetBatch(kTRUE); // enforce batch mode to avoid appearance of multiple canvas windows; ; std::vector<TPad *> pads;; ; for(int n = 0; n < 100; ++n) {; auto c = new TCanvas(TString::Format(""canvas%d"", n), ""Canvas with histogram"");; ; auto h1 = new TH1I(TString::Format(""hist%d"", n), ""Histogram with random data"", 100, -5., 5);; h1->SetDirectory(nullptr);; h1->FillRandom(""gaus"", 10000);; ; h1->Draw();; ; pads.push_back(c);; }; ; TCanvas::SaveAll(pads, ""image%03d.png""); // create 100 PNG images; ; TCanvas::SaveAll(pads, ""image.svg""); // create 100 SVG images, %d pattern will be automatically append; ; TCanvas::SaveAll(pads, ""images.root""); // create single ROOT file with all canvases; ; TCanvas::SaveAll(); // save all existing canvases in allcanvases.pdf file; }; c#define c(i)Definition RSha256.hxx:101; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; gROOT#define gROOTDefinition TROOT.h:406; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::SaveAllstatic Bool_t SaveAll(const std::vector< TPad * > &={}, const char *filename="""", Option_t *option="""")Save provided pads/canvases into the image file(s) Filename can include printf argument for image num...Definition TCanvas.cxx:2654; TH1I1-D histogram with an int per channel (see TH1 documentation)Definition TH1.h:540; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::FillRandomvirtual void FillRandom(const char *fnam",MatchSource.WIKI,doc/master/saveall_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/saveall_8C.html
Performance,perform,performance,". ROOT: tutorials/graphics/save_batch.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. save_batch.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This macro demonstrates batch image mode of web canvas When enabled - several images converted into JSON before all together provided to headless browser to produce image files. ; Let significantly increase performance. Important - disable batch mode for flushing remaining images; ; void save_batch(); {; // 37 canvases will be collected together for conversion; TWebCanvas::BatchImageMode(37);; ; auto c = new TCanvas(""canvas"", ""Canvas with histogram"");; ; auto h1 = new TH1I(""hist"", ""Histogram with random data"", 100, -5., 5);; h1->SetDirectory(nullptr);; h1->FillRandom(""gaus"", 10000);; h1->Draw();; ; for(int n = 0; n < 100; ++n) {; h1->FillRandom(""gaus"", 10000);; c->SaveAs(TString::Format(""batch_image_%03d.png"", n));; }; ; // Important - disabling batch mode also flush remaining images; TWebCanvas::BatchImageMode(0);; }; c#define c(i)Definition RSha256.hxx:101; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1I1-D histogram with an int per channel (see TH1 documentation)Definition TH1.h:540; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TWebCanvas::BatchImageModestatic void BatchImageMode(UInt_t n=100)Configure batch image mode for web graphics.Definitio",MatchSource.WIKI,doc/master/save__batch_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/save__batch_8C.html
Integrability,depend,dependency,". ROOT: core/dictgen/src/Scanner.cxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions |; Variables ; Scanner.cxx File Reference. #include ""Scanner.h""; #include ""clang/AST/ASTConsumer.h""; #include ""clang/Basic/SourceLocation.h""; #include ""clang/Basic/SourceManager.h""; #include ""llvm/ADT/SmallSet.h""; #include ""clang/Sema/Sema.h""; #include ""clang/Frontend/CompilerInstance.h""; #include ""cling/Interpreter/Interpreter.h""; #include ""llvm/Support/Path.h""; #include ""TClassEdit.h""; #include <iostream>; #include <sstream>; #include ""llvm/ADT/StringExtras.h""; #include ""SelectionRules.h"". Include dependency graph for Scanner.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Functions; std::string AddSpace (const std::string &txt);  ; long APIntToLong (const llvm::APInt &num);  ; size_t APIntToSize (const llvm::APInt &num);  ; std::string APIntToStr (const llvm::APInt &num);  ; std::string IntToStd (int num);  ; std::string IntToStr (int num);  ; std::string Message (const std::string &msg, const std::string &location);  ; void * ToDeclProp (clang::Decl *item);  . Variables; cling::Interpreter * gInterp;  . Function Documentation. ◆ AddSpace(). std::string AddSpace ; (; const std::string & ; txt). inline . Definition at line 266 of file Scanner.cxx. ◆ APIntToLong(). long APIntToLong ; (; const llvm::APInt & ; num). inline . Definition at line 147 of file Scanner.cxx. ◆ APIntToSize(). size_t APIntToSize ; (; const llvm::APInt & ; num). inline . Definition at line 140 of file Scanner.cxx. ◆ APIntToStr(). std::string APIntToStr ; (; const llvm::APInt & ; num). inline . Definition at line 154 of file Scanner.cxx. ◆ IntToStd(). std::string IntToStd ; (; int ; num). inline . Definition at line 170 of file Scanner.cxx. ◆ IntToStr(). std::string IntToStr ; (; int ; num). inline . Definition at line 161 of file Scanner.cxx. ◆ Message(). std::string Message ; (; const std::string & ; msg, . co",MatchSource.WIKI,doc/master/Scanner_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx.html
Integrability,message,message,"std::string IntToStd(int num); 171{; 172 std::ostringstream stream;; 173 stream << num;; 174 return stream.str();; 175}; 176 ; 177////////////////////////////////////////////////////////////////////////////////; 178 ; 179inline std::string Message(const std::string &msg, const std::string &location); 180{; 181 std::string loc = location;; 182 ; 183 if (loc == """"); 184 return msg;; 185 else; 186 return loc + "" "" + msg;; 187}; 188 ; 189////////////////////////////////////////////////////////////////////////////////; 190 ; 191void RScanner::ShowInfo(const std::string &msg, const std::string &location) const; 192{; 193 const std::string message = Message(msg, location);; 194 std::cout << message << std::endl;; 195}; 196 ; 197////////////////////////////////////////////////////////////////////////////////; 198 ; 199void RScanner::ShowWarning(const std::string &msg, const std::string &location) const; 200{; 201 const std::string message = Message(msg, location);; 202 std::cout << message << std::endl;; 203}; 204 ; 205////////////////////////////////////////////////////////////////////////////////; 206 ; 207void RScanner::ShowError(const std::string &msg, const std::string &location) const; 208{; 209 const std::string message = Message(msg, location);; 210 std::cout << message << std::endl;; 211}; 212 ; 213////////////////////////////////////////////////////////////////////////////////; 214 ; 215void RScanner::ShowTemplateInfo(const std::string &msg, const std::string &location) const; 216{; 217 std::string loc = location;; 218 if (loc == """"); 219 loc = GetLocation (fLastDecl);; 220 ShowWarning(msg, loc);; 221}; 222 ; 223////////////////////////////////////////////////////////////////////////////////; 224 ; 225std::string RScanner::GetSrcLocation(clang::SourceLocation L) const; 226{; 227 std::string location = """";; 228 llvm::raw_string_ostream stream(location);; 229 L.print(stream, *fSourceManager);; 230 return stream.str();; 231}; 232 ; 233/////////////////////////////////",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
Performance,cache,cache,"e ROOT;; 59using namespace clang;; 60 ; 61extern cling::Interpreter *gInterp;; 62 ; 63const char* RScanner::fgClangDeclKey = ""ClangDecl""; // property key used for connection with Clang objects; 64const char* RScanner::fgClangFuncKey = ""ClangFunc""; // property key for demangled names; 65 ; 66int RScanner::fgAnonymousClassCounter = 0;; 67int RScanner::fgBadClassCounter = 0;; 68int RScanner::fgAnonymousEnumCounter = 0;; 69 ; 70std::map <clang::Decl*, std::string> RScanner::fgAnonymousClassMap;; 71std::map <clang::Decl*, std::string> RScanner::fgAnonymousEnumMap;; 72 ; 73////////////////////////////////////////////////////////////////////////////////; 74/// Regular constructor setting up the scanner to search for entities; 75/// matching the 'rules'.; 76 ; 77RScanner::RScanner (SelectionRules &rules,; 78 EScanType stype,; 79 const cling::Interpreter &interpret,; 80 ROOT::TMetaUtils::TNormalizedCtxt &normCtxt,; 81 unsigned int verbose /* = 0 */) :; 82 fVerboseLevel(verbose),; 83 fSourceManager(nullptr),; 84 fInterpreter(interpret),; 85 fRecordDeclCallback(nullptr),; 86 fNormCtxt(normCtxt),; 87 fSelectionRules(rules),; 88 fScanType(stype),; 89 fFirstPass(true); 90{; 91 // Build the cache for all selection rules; 92 fSelectionRules.FillCache();; 93 ; 94 for (int i = 0; i <= fgDeclLast; i ++); 95 fDeclTable [i] = false;; 96 ; 97 for (int i = 0; i <= fgTypeLast; i ++); 98 fTypeTable [i] = false;; 99 ; 100 fLastDecl = nullptr;; 101}; 102 ; 103////////////////////////////////////////////////////////////////////////////////; 104 ; 105RScanner::~RScanner (); 106{; 107}; 108 ; 109////////////////////////////////////////////////////////////////////////////////; 110/// Whether we can actually visit this declaration, i.e. if it is reachable; 111/// via name lookup.; 112///; 113/// RScanner shouldn't touch decls for which this method returns false as we; 114/// call Sema methods on those declarations. Those will fail in strange way as; 115/// they assume those decls are already visibl",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
Safety,detect,detected,"E = F->param_end(); I != E; ++I) {; 1027 clang::ParmVarDecl* P = *I;; 1028 ; 1029 if (prototype != """"); 1030 prototype += "","";; 1031 ; 1032 //std::string type = P->getType().getAsString();; 1033 std::string type = P->getType().getAsString();; 1034 if (type.at(type.length()-1) == '*') {; 1035 type.at(type.length()-2) = '*';; 1036 type.erase(type.length()-1);; 1037 }; 1038 prototype += type;; 1039 }; 1040 ; 1041 prototype = ""("" + prototype + "")"";; 1042 return true;; 1043 }; 1044 else {; 1045 ShowWarning(""can't convert Decl to FunctionDecl"","""");; 1046 return false;; 1047 }; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051 ; 1052void RScanner::Scan(const clang::ASTContext &C); 1053{; 1054 fSourceManager = &C.getSourceManager();; 1055 ; 1056// if (fVerboseLevel >= 3) fSelectionRules.PrintSelectionRules();; 1057 ; 1058 if (fVerboseLevel > 0 && fSelectionRules.GetHasFileNameRule()) {; 1059 std::cout<<""File name detected""<<std::endl;; 1060 }; 1061 ; 1062 if (fScanType == EScanType::kTwoPasses); 1063 TraverseDecl(C.getTranslationUnitDecl());; 1064 ; 1065 fFirstPass=false;; 1066 fselectedRecordDecls.clear();; 1067 fSelectedEnums.clear();; 1068 fSelectedTypedefs.clear();; 1069 fSelectedVariables.clear();; 1070 fSelectedFunctions.clear();; 1071 TraverseDecl(C.getTranslationUnitDecl());; 1072 ; 1073 // The RecursiveASTVisitor uses range-based for; we must not modify the AST; 1074 // during iteration / visitation. Instead, buffer the lookups that could; 1075 // potentially create new template specializations, and handle them here:; 1076 AddDelayedAnnotatedRecordDecls();; 1077}; 1078 ; 1079 ; 1080////////////////////////////////////////////////////////////////////////////////; 1081/// Set the callback to the RecordDecl and return the previous one.; 1082 ; 1083RScanner::DeclCallback RScanner::SetRecordDeclCallback(RScanner::DeclCallback callback); 1084{; 1085 DeclCallback old = fRecordDeclCallback;; 1086 fRecordDeclCallback = ",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
Security,access,access,"leName = llvm::sys::path::filename(selected->GetSelFileName()).str();; 751 auto lineno = selected->GetLineNumber();; 752 auto rulesAreCompatible = SelectionRulesUtils::areEqual<ClassSelectionRule>(selected, previouslyMatchingRule, true /*moduloNameOrPattern*/);; 753 if (!rulesAreCompatible){; 754 std::stringstream message;; 755 if (lineno > 1) message << ""Selection file "" << cleanFileName << "", lines ""; 756 << lineno << "" and "" << previouslineno << "". "";; 757 message << ""Attempt to select a class ""<< normName << "" with two rules which have incompatible attributes. ""; 758 << ""The attributes such as transiency might not be correctly propagated to the typesystem of ROOT.\n"";; 759 selected->Print(message);; 760 message << ""Conflicting rule already matched:\n"";; 761 previouslyMatchingRule->Print(message);; 762 ROOT::TMetaUtils::Warning(nullptr,""%s\n"", message.str().c_str());; 763 }; 764 }; 765 }; 766 ; 767 fDeclSelRuleMap[recordDecl->getCanonicalDecl()] = selected;; 768 ; 769 if (!rcrdDeclNotAlreadySelected || fFirstPass); 770 return true;; 771 ; 772 // Before adding the decl to the selected ones, check its access.; 773 // We do not yet support I/O of private or protected classes.; 774 // See ROOT-7450.; 775 // Additionally, private declarations lead to uncompilable code, so just ignore (ROOT-9112).; 776 if (recordDecl->getAccess() == AS_private || recordDecl->getAccess() == AS_protected) {; 777 // Don't warn about types selected by ""everything in that file"".; 778 auto isFileSelection = selected->HasAttributeFileName() &&; 779 selected->HasAttributePattern() &&; 780 ""*"" == selected->GetAttributePattern();; 781 if (!isFileSelection) {; 782 std::string normName;; 783 TMetaUtils::GetNormalizedName(normName,; 784 recordDecl->getASTContext().getTypeDeclType(recordDecl),; 785 fInterpreter,; 786 fNormCtxt);; 787 auto msg = ""Class or struct %s was selected but its dictionary cannot be generated: ""; 788 ""this is a private or protected class and this is not supported. No direct "";",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
Testability,test,test," 448 if (P->getInit()) {; 449 std::string init_value = ExprToStr(P->getDefaultArg());; 450 result += ""="" + init_value;; 451 }; 452 }; 453 ; 454 return result;; 455}; 456 ; 457////////////////////////////////////////////////////////////////////////////////; 458 ; 459std::string RScanner::FuncParameterList(clang::FunctionDecl* D) const; 460{; 461 std::string result = """";; 462 ; 463 for (clang::FunctionDecl::param_iterator I = D->param_begin(), E = D->param_end(); I != E; ++I) {; 464 clang::ParmVarDecl* P = *I;; 465 ; 466 if (result != """"); 467 result += "","";; 468 ; 469 std::string type = P->getType().getAsString();; 470 result += type;; 471 }; 472 ; 473 return ""("" + result + "")"";; 474}; 475 ; 476////////////////////////////////////////////////////////////////////////////////; 477/// This method visits a namespace node; 478 ; 479bool RScanner::VisitNamespaceDecl(clang::NamespaceDecl* N); 480{; 481 // We don't need to visit this while creating the big PCM; 482 if (fScanType == EScanType::kOnePCM); 483 return true;; 484 ; 485 if (!shouldVisitDecl(N)); 486 return true;; 487 ; 488 // in case it is implicit we don't create a builder; 489 // [Note: Can N be nullptr?, is so 'ShouldVisitDecl' should test or we should test sooner]; 490 if((N && N->isImplicit()) || !N){; 491 return true;; 492 }; 493 ; 494 bool ret = true;; 495 ; 496 const ClassSelectionRule *selected = fSelectionRules.IsDeclSelected(N);; 497 if (selected) {; 498 ; 499 clang::DeclContext* primary_ctxt = N->getPrimaryContext();; 500 clang::NamespaceDecl* primary = llvm::dyn_cast<clang::NamespaceDecl>(primary_ctxt);; 501 ; 502 RPredicateIsSameNamespace pred(primary);; 503 if ( find_if(fSelectedNamespaces.begin(),fSelectedNamespaces.end(),pred) == fSelectedNamespaces.end() ) {; 504 // The namespace is not already registered.; 505 ; 506 if (fVerboseLevel > 0) {; 507 std::string qual_name;; 508 GetDeclQualName(N,qual_name);; 509 // std::cout<<""\tSelected namespace -> "" << qual_name << "" ptr "" << (void*)N << "" decl ctxt",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
Usability,clear,clear,"sString();; 1033 std::string type = P->getType().getAsString();; 1034 if (type.at(type.length()-1) == '*') {; 1035 type.at(type.length()-2) = '*';; 1036 type.erase(type.length()-1);; 1037 }; 1038 prototype += type;; 1039 }; 1040 ; 1041 prototype = ""("" + prototype + "")"";; 1042 return true;; 1043 }; 1044 else {; 1045 ShowWarning(""can't convert Decl to FunctionDecl"","""");; 1046 return false;; 1047 }; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051 ; 1052void RScanner::Scan(const clang::ASTContext &C); 1053{; 1054 fSourceManager = &C.getSourceManager();; 1055 ; 1056// if (fVerboseLevel >= 3) fSelectionRules.PrintSelectionRules();; 1057 ; 1058 if (fVerboseLevel > 0 && fSelectionRules.GetHasFileNameRule()) {; 1059 std::cout<<""File name detected""<<std::endl;; 1060 }; 1061 ; 1062 if (fScanType == EScanType::kTwoPasses); 1063 TraverseDecl(C.getTranslationUnitDecl());; 1064 ; 1065 fFirstPass=false;; 1066 fselectedRecordDecls.clear();; 1067 fSelectedEnums.clear();; 1068 fSelectedTypedefs.clear();; 1069 fSelectedVariables.clear();; 1070 fSelectedFunctions.clear();; 1071 TraverseDecl(C.getTranslationUnitDecl());; 1072 ; 1073 // The RecursiveASTVisitor uses range-based for; we must not modify the AST; 1074 // during iteration / visitation. Instead, buffer the lookups that could; 1075 // potentially create new template specializations, and handle them here:; 1076 AddDelayedAnnotatedRecordDecls();; 1077}; 1078 ; 1079 ; 1080////////////////////////////////////////////////////////////////////////////////; 1081/// Set the callback to the RecordDecl and return the previous one.; 1082 ; 1083RScanner::DeclCallback RScanner::SetRecordDeclCallback(RScanner::DeclCallback callback); 1084{; 1085 DeclCallback old = fRecordDeclCallback;; 1086 fRecordDeclCallback = callback;; 1087 return old;; 1088}; IntToStrstd::string IntToStr(int num)Definition Scanner.cxx:161; APIntToLonglong APIntToLong(const llvm::APInt &num)Definition Scanner.cxx:147",MatchSource.WIKI,doc/master/Scanner_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html
Modifiability,variab,variables,"catter.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. scatter.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw a scatter plot. . ; void scatter(); {; auto canvas = new TCanvas();; canvas->SetRightMargin(0.14);; gStyle->SetPalette(kBird, 0, 0.6); // define a transparent palette; ; const int n = 175;; double x[n];; double y[n];; double c[n];; double s[n];; ; // Define four random data set; auto r = new TRandom();; for (int i=0; i<n; i++) {; x[i] = 100*r->Rndm(i);; y[i] = 200*r->Rndm(i);; c[i] = 300*r->Rndm(i);; s[i] = 400*r->Rndm(i);; }; ; auto scatter = new TScatter(n, x, y, c, s);; scatter->SetMarkerStyle(20);; scatter->SetTitle(""Scatter plot title;X title;Y title;Z title"");; scatter->GetXaxis()->SetRangeUser(20.,90.);; scatter->GetYaxis()->SetRangeUser(55.,90.);; scatter->GetZaxis()->SetRangeUser(10.,200.);; scatter->Draw(""A"");; }; c#define c(i)Definition RSha256.hxx:101; kBird@ kBirdDefinition TColor.h:118; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TScatterA TScatter is able to draw four variables scatter plot on a single plot.Definition TScatter.h:32; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; AuthorOlivier Couet ; Definition in file scatter.C. tutorialsgraphsscatter.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/scatter_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/scatter_8C.html
Energy Efficiency,energy,energy,". ROOT: tutorials/graphics/schroedinger_hydrogen.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. schroedinger_hydrogen.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Plot the Amplitude of a Hydrogen Atom. ; Visualize the Amplitude of a Hydrogen Atom in the n = 2, l = 0, m = 0 state. Demonstrates how TH2F can be used in Quantum Mechanics.; The formula for Hydrogen in this energy state is \( \psi_{200} = \frac{1}{4\sqrt{2\pi}a_0 ^{\frac{3}{2}}}(2-\frac{\sqrt{x^2+y^2}}{a_0})e^{-\frac{\sqrt{x^2+y^2}}{2a_0}} \). ; #include <cmath>; ; double WaveFunction(double x, double y) {; double r = sqrt(x *x + y*y);; ; double w = (1/pow((4*sqrt(2*TMath::Pi())* 1), 1.5)) * (2 - (r / 1)*pow(TMath::E(), (-1 * r)/2)); // Wavefunction formula for psi 2,0,0; ; return w*w; // Amplitude; ; }; ; void schroedinger_hydrogen() {; TH2F *h2D = new TH2F(""Hydrogen Atom"",; ""Hydrogen in n = 2, l = 0, m = 0 state; Position in x direction; Position in y direction"",; 200, -10, 10, 200, -10, 10);; ; for (float i = -10; i < 10; i += 0.01) {; for (float j = -10; j < 10; j += 0.01) {; h2D->Fill(i, j, WaveFunction(i, j));; }; }; ; gStyle->SetPalette(kCividis);; gStyle->SetOptStat(0);; ; TCanvas *c1 = new TCanvas(""c1"", ""Schroedinger's Hydrogen Atom"", 750, 1500);; c1->Divide(1, 2);; ; auto c1_1 = c1->cd(1);; c1_1->SetRightMargin(0.14);; h2D->GetXaxis()->SetLabelSize(0.03);; h2D->GetYaxis()->SetLabelSize(0.03);; h2D->GetZaxis()->SetLabelSize(0.03);; h2D->SetContour(50);; h2D->Draw(""colz"");; ; TLatex *l = new TLatex(-10, -12.43, ""The Electron is more likely to be found in the yellow areas and less likely to be found in the blue areas."");; l->SetTextFont(42);; l->SetTextSize(0.02);; l->Draw();; ; auto c1_2 = c1->cd(2);; c1_2->SetTheta(42.);; ; TH2D *h2Dc = (TH2D*)h2D->Clone();; h2Dc->SetTitle(""3D view of probability amplitude;;"");; h2Dc->Draw(""surf2"");; }; kCividis@ kCividisDefinition TColor.h:136; wwinID wDefinition TGWin32VirtualGLProxy.cx",MatchSource.WIKI,doc/master/schroedinger__hydrogen_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/schroedinger__hydrogen_8C.html
Testability,log,log,"ize of axis labels.Definition TAttAxis.cxx:203; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::SetTitlevoid SetTitle(const char *title) overrideChange/set the title.Definition TH1.cxx:6718; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::SetContourvirtual void SetContour(Int_t nlevels, const Double_t *levels=nullptr)Set the number and values of contour levels.Definition TH1.cxx:8483; TH1::CloneTObject * Clone(const char *newname="""") const overrideMake a complete copy of the underlying object.Definition TH1.cxx:2752; TH2D2-D histogram with a double per channel (see TH1 documentation)Definition TH2.h:357; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH2::FillInt_t Fill(Double_t) overrideInvalid Fill method.Definition TH2.cxx:393; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; TMath::Econstexpr Double_t E()Base of natural log: .Definition TMath.h:93; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; lTLine lDefinition textangle.C:4; AuthorAdvait Dhingra ; Definition in file schroedinger_hydrogen.C. tutorialsgraphicsschroedinger_hydrogen.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/schroedinger__hydrogen_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/schroedinger__hydrogen_8C.html
Integrability,depend,dependency,". ROOT: net/http/civetweb/sha1.inl File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Macros |; Functions ; sha1.inl File Reference. #include <stdint.h>; #include <string.h>. Include dependency graph for sha1.inl:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; union  CHAR64LONG16;  ; struct  SHA_CTX;  . Macros; #define blk(block, i);  ; #define R0(v, w, x, y, z, i);  ; #define R1(v, w, x, y, z, i);  ; #define R2(v, w, x, y, z, i);  ; #define R3(v, w, x, y, z, i);  ; #define R4(v, w, x, y, z, i);  ; #define rol(value, bits)   (((value) << (bits)) | ((value) >> (32 - (bits))));  ; #define SHA1_DIGEST_SIZE   20;  . Functions; static uint32_t blk0 (CHAR64LONG16 *block, int i);  ; SHA_API void SHA1_Final (unsigned char *digest, SHA_CTX *context);  ; SHA_API void SHA1_Init (SHA_CTX *context);  ; static void SHA1_Transform (uint32_t state[5], const uint8_t buffer[64]);  ; SHA_API void SHA1_Update (SHA_CTX *context, const uint8_t *data, const uint32_t len);  . Macro Definition Documentation. ◆ blk. #define blk; (;  ; block, .  ; i . ). Value: ((block)->l[(i)&15] = \; rol((block)->l[((i) + 13) & 15] ^ (block)->l[((i) + 8) & 15] \; ^ (block)->l[((i) + 2) & 15] ^ (block)->l[(i)&15], \; 1)); lTLine lDefinition textangle.C:4. Definition at line 124 of file sha1.inl. ◆ R0. #define R0; (;  ; v, .  ; w, .  ; x, .  ; y, .  ; z, .  ; i . ). Value: z += ((w & (x ^ y)) ^ y) + blk0(block, i) + 0x5A827999 + rol(v, 5); \; w = rol(w, 30);; blk0#define blk0(i)Definition RSha256.hxx:93; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; v@ vDefinition rootcling_impl.cxx:3699; rol#define rol(value, bits)Definition sha1.inl:100. Definition at line 131 of file sha1.inl. ◆ R1. #define R1; (;  ; v, .  ; w, .  ; x, .  ; y, .  ; z, .  ; i . ). Value: z += ((w & (x ^ y)) ^ y) + blk(block, i) + 0x5A827999 + rol(v, 5); \; w ",MatchSource.WIKI,doc/master/sha1_8inl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/sha1_8inl.html
Availability,error,error,"; 488 Return true if inversion is successful.; 489 The method used is based on direct inversion using the Cramer rule for; 490 matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; 491 Note that this method is faster but can suffer from much larger numerical accuracy; 492 when the condition of the matrix is large; 493 */; 494 bool InvertFast();; 495 ; 496 /**; 497 Invert a square Matrix and returns a new matrix. In case the inversion fails; 498 the current matrix is returned.; 499 \param ifail . ifail will be set to 0 when inversion is successful.; 500 See ROOT::Math::SMatrix::InvertFast for the inversion algorithm; 501 */; 502 SMatrix<T,D1,D2,R> InverseFast(int & ifail ) const;; 503 ; 504 /**; 505 Inversion of a symmetric positive defined Matrix using Choleski decomposition.; 506 ( this method changes the current matrix).; 507 Return true if inversion is successful.; 508 The method used is based on Choleski decomposition; 509 A compile error is given if the matrix is not of type symmetric and a run-time failure if the; 510 matrix is not positive defined.; 511 For solving a linear system, it is possible to use also the function; 512 ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion; 513 */; 514 bool InvertChol();; 515 ; 516 /**; 517 Invert of a symmetric positive defined Matrix using Choleski decomposition.; 518 A compile error is given if the matrix is not of type symmetric and a run-time failure if the; 519 matrix is not positive defined.; 520 In case the inversion fails the current matrix is returned.; 521 \param ifail . ifail will be set to 0 when inversion is successful.; 522 See ROOT::Math::SMatrix::InvertChol for the inversion algorithm; 523 */; 524 SMatrix<T,D1,D2,R> InverseChol(int & ifail ) const;; 525 ; 526 /**; 527 determinant of square Matrix via Dfact.; 528 Return true when the calculation is successful.; 529 \param det will contain the calculated determinant value; 530 \b Note: this will ",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
Deployability,configurat,configurations," source code; 12//; 13// created: 20. Mar 2001; 14//; 15// author: Thorsten Glebe; 16// HERA-B Collaboration; 17// Max-Planck-Institut fuer Kernphysik; 18// Saupfercheckweg 1; 19// 69117 Heidelberg; 20// Germany; 21// E-mail: T.Glebe@mpi-hd.mpg.de; 22//; 23// Description: A fixed size two dimensional Matrix class; 24//; 25// changes:; 26// 20 Mar 2001 (TG) creation; 27// 21 Mar 2001 (TG) added operators +=, -=, *=, /=; 28// 26 Mar 2001 (TG) place_in_row(), place_in_col() added; 29// 02 Apr 2001 (TG) non-const Array() added; 30// 03 Apr 2001 (TG) invert() added; 31// 07 Apr 2001 (TG) CTOR from SVertex (dyadic product) added; 32// 09 Apr 2001 (TG) CTOR from array added; 33// 11 Apr 2001 (TG) rows(), cols(), size() replaced by rows, cols, size; 34// 25 Mai 2001 (TG) row(), col() added; 35// 04 Sep 2001 (TG) moved inlined functions to .icc file; 36// 11 Jan 2002 (TG) added operator==(), operator!=(); 37// 14 Jan 2002 (TG) added more operator==(), operator!=(), operator>(), operator<(); 38//; 39***************************************************************************/; 40// for platform specific configurations; 41 ; 42#include ""Math/MConfig.h""; 43 ; 44#include <iosfwd>; 45 ; 46 ; 47/**; 48\defgroup SMatrixSVector Matrix and Vector classes; 49\ingroup SMatrixGroup; 50 ; 51Classes representing Matrices and Vectors of arbitrary type and dimension.; 52For a detailed description and usage examples see:; 53 ; 54 - \ref SVectorDoc; 55 - \ref SMatrixDoc; 56 - \ref MatVecFunctions; 57 ; 58*/; 59 ; 60 ; 61#include ""Math/Expression.h""; 62#include ""Math/MatrixRepresentationsStatic.h""; 63 ; 64 ; 65namespace ROOT {; 66 ; 67namespace Math {; 68 ; 69 ; 70template <class T, unsigned int D> class SVector;; 71 ; 72struct SMatrixIdentity { };; 73struct SMatrixNoInit { };; 74 ; 75//__________________________________________________________________________; 76/**; 77 SMatrix: a generic fixed size D1 x D2 Matrix class.; 78 The class is template on the scalar type, on the matrix sizes:; 79 D1",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
Integrability,interface,interface,"NoInit { };; 74 ; 75//__________________________________________________________________________; 76/**; 77 SMatrix: a generic fixed size D1 x D2 Matrix class.; 78 The class is template on the scalar type, on the matrix sizes:; 79 D1 = number of rows and D2 = number of columns; 80 amd on the representation storage type.; 81 By default the representation is MatRepStd<T,D1,D2> (standard D1xD2 of type T),; 82 but it can be of type MatRepSym<T,D> for symmetric matrices DxD, where the storage is only; 83 D*(D+1)/2.; 84 ; 85 See \ref SMatrixDoc.; 86 ; 87 Original author is Thorsten Glebe; 88 HERA-B Collaboration, MPI Heidelberg (Germany); 89 ; 90 @ingroup SMatrixSVector; 91 ; 92 @authors T. Glebe, L. Moneta and J. Palacios; 93*/; 94//==============================================================================; 95// SMatrix: column-wise storage; 96//==============================================================================; 97template <class T,; 98 unsigned int D1,; 99 unsigned int D2 = D1,; 100 class R=MatRepStd<T, D1, D2> >; 101class SMatrix {; 102public:; 103 /** @name --- Typedefs --- */; 104 ; 105 /** contained scalar type */; 106 typedef T value_type;; 107 ; 108 /** storage representation type */; 109 typedef R rep_type;; 110 ; 111 /** STL iterator interface. */; 112 typedef T* iterator;; 113 ; 114 /** STL const_iterator interface. */; 115 typedef const T* const_iterator;; 116 ; 117 ; 118 ; 119 /** @name --- Constructors and Assignment --- */; 120 ; 121 /**; 122 Default constructor:; 123 */; 124 SMatrix();; 125 ///; 126 /**; 127 construct from without initialization; 128 */; 129 inline SMatrix( SMatrixNoInit ){}; 130 ; 131 /**; 132 construct from an identity matrix; 133 */; 134 SMatrix( SMatrixIdentity );; 135 /**; 136 copy constructor (from a matrix of the same representation; 137 */; 138 SMatrix(const SMatrix<T,D1,D2,R>& rhs);; 139 /**; 140 construct from a matrix with different representation.; 141 Works only from symmetric to general and not viceversa.; 142 ",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
Modifiability,config,configurations," source code; 12//; 13// created: 20. Mar 2001; 14//; 15// author: Thorsten Glebe; 16// HERA-B Collaboration; 17// Max-Planck-Institut fuer Kernphysik; 18// Saupfercheckweg 1; 19// 69117 Heidelberg; 20// Germany; 21// E-mail: T.Glebe@mpi-hd.mpg.de; 22//; 23// Description: A fixed size two dimensional Matrix class; 24//; 25// changes:; 26// 20 Mar 2001 (TG) creation; 27// 21 Mar 2001 (TG) added operators +=, -=, *=, /=; 28// 26 Mar 2001 (TG) place_in_row(), place_in_col() added; 29// 02 Apr 2001 (TG) non-const Array() added; 30// 03 Apr 2001 (TG) invert() added; 31// 07 Apr 2001 (TG) CTOR from SVertex (dyadic product) added; 32// 09 Apr 2001 (TG) CTOR from array added; 33// 11 Apr 2001 (TG) rows(), cols(), size() replaced by rows, cols, size; 34// 25 Mai 2001 (TG) row(), col() added; 35// 04 Sep 2001 (TG) moved inlined functions to .icc file; 36// 11 Jan 2002 (TG) added operator==(), operator!=(); 37// 14 Jan 2002 (TG) added more operator==(), operator!=(), operator>(), operator<(); 38//; 39***************************************************************************/; 40// for platform specific configurations; 41 ; 42#include ""Math/MConfig.h""; 43 ; 44#include <iosfwd>; 45 ; 46 ; 47/**; 48\defgroup SMatrixSVector Matrix and Vector classes; 49\ingroup SMatrixGroup; 50 ; 51Classes representing Matrices and Vectors of arbitrary type and dimension.; 52For a detailed description and usage examples see:; 53 ; 54 - \ref SVectorDoc; 55 - \ref SMatrixDoc; 56 - \ref MatVecFunctions; 57 ; 58*/; 59 ; 60 ; 61#include ""Math/Expression.h""; 62#include ""Math/MatrixRepresentationsStatic.h""; 63 ; 64 ; 65namespace ROOT {; 66 ; 67namespace Math {; 68 ; 69 ; 70template <class T, unsigned int D> class SVector;; 71 ; 72struct SMatrixIdentity { };; 73struct SMatrixNoInit { };; 74 ; 75//__________________________________________________________________________; 76/**; 77 SMatrix: a generic fixed size D1 x D2 Matrix class.; 78 The class is template on the scalar type, on the matrix sizes:; 79 D1",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
Performance,perform,performing,"t can suffer from much larger numerical accuracy; 492 when the condition of the matrix is large; 493 */; 494 bool InvertFast();; 495 ; 496 /**; 497 Invert a square Matrix and returns a new matrix. In case the inversion fails; 498 the current matrix is returned.; 499 \param ifail . ifail will be set to 0 when inversion is successful.; 500 See ROOT::Math::SMatrix::InvertFast for the inversion algorithm; 501 */; 502 SMatrix<T,D1,D2,R> InverseFast(int & ifail ) const;; 503 ; 504 /**; 505 Inversion of a symmetric positive defined Matrix using Choleski decomposition.; 506 ( this method changes the current matrix).; 507 Return true if inversion is successful.; 508 The method used is based on Choleski decomposition; 509 A compile error is given if the matrix is not of type symmetric and a run-time failure if the; 510 matrix is not positive defined.; 511 For solving a linear system, it is possible to use also the function; 512 ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion; 513 */; 514 bool InvertChol();; 515 ; 516 /**; 517 Invert of a symmetric positive defined Matrix using Choleski decomposition.; 518 A compile error is given if the matrix is not of type symmetric and a run-time failure if the; 519 matrix is not positive defined.; 520 In case the inversion fails the current matrix is returned.; 521 \param ifail . ifail will be set to 0 when inversion is successful.; 522 See ROOT::Math::SMatrix::InvertChol for the inversion algorithm; 523 */; 524 SMatrix<T,D1,D2,R> InverseChol(int & ifail ) const;; 525 ; 526 /**; 527 determinant of square Matrix via Dfact.; 528 Return true when the calculation is successful.; 529 \param det will contain the calculated determinant value; 530 \b Note: this will destroy the contents of the Matrix!; 531 */; 532 bool Det(T& det);; 533 ; 534 /**; 535 determinant of square Matrix via Dfact.; 536 Return true when the calculation is successful.; 537 \param det will contain the calculated determinant value; 5",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
Safety,avoid,avoid,"d SetDiagonal(const Vector & v);; 623 ; 624 /**; 625 return the trace of a matrix; 626 Sum of the diagonal elements; 627 */; 628 T Trace() const;; 629 ; 630 ; 631 /**; 632 return the upper Triangular block of the matrices (including the diagonal) as; 633 a vector of sizes N = D1 * (D1 + 1)/2.; 634 It works only for square matrices with D1==D2, otherwise it will produce a compile error; 635 */; 636#ifndef UNSUPPORTED_TEMPLATE_EXPRESSION; 637 SVector<T, D1 * (D2 +1)/2> UpperBlock() const;; 638#else; 639 template<class SubVector>; 640 SubVector UpperBlock() const;; 641#endif; 642 ; 643 /**; 644 return the lower Triangular block of the matrices (including the diagonal) as; 645 a vector of sizes N = D1 * (D1 + 1)/2.; 646 It works only for square matrices with D1==D2, otherwise it will produce a compile error; 647 */; 648#ifndef UNSUPPORTED_TEMPLATE_EXPRESSION; 649 SVector<T, D1 * (D2 +1)/2> LowerBlock() const;; 650#else; 651 template<class SubVector>; 652 SubVector LowerBlock() const;; 653#endif; 654 ; 655 ; 656 /** @name --- Other Functions --- */; 657 ; 658 /**; 659 Function to check if a matrix is sharing same memory location of the passed pointer; 660 This function is used by the expression templates to avoid the alias problem during; 661 expression evaluation. When the matrix is in use, for example in operations; 662 like A = B * A, a temporary object storing the intermediate result is automatically; 663 created when evaluating the expression.; 664 ; 665 */; 666 bool IsInUse(const T* p) const;; 667 ; 668 // submatrices; 669 ; 670 /// Print: used by operator<<(); 671 std::ostream& Print(std::ostream& os) const;; 672 ; 673 ; 674 ; 675 ; 676public:; 677 ; 678 /** @name --- Data Member --- */; 679 ; 680 /**; 681 Matrix Storage Object containing matrix data; 682 */; 683 R fRep;; 684 ; 685}; // end of class SMatrix; 686 ; 687 ; 688 ; 689 ; 690//==============================================================================; 691// operator<<; 692//==========================",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
Security,access,access,"ral but NOT vice-versa; 206 */; 207 template <class M>; 208 SMatrix<T,D1,D2,R>& operator=(const M& rhs);; 209 ; 210 SMatrix<T,D1,D2,R>& operator=(const SMatrix<T,D1,D2,R>& rhs);; 211 ; 212 /**; 213 Assign from a matrix expression; 214 */; 215 template <class A, class R2>; 216 SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs);; 217 ; 218 /**; 219 Assign from an identity matrix; 220 */; 221 SMatrix<T,D1,D2,R> & operator=(SMatrixIdentity );; 222 ; 223 /**; 224 Assign from a scalar value (only for size 1 matrices); 225 */; 226 SMatrix<T,D1,D2,R>& operator=(const T& rhs);; 227 ; 228 /** @name --- Matrix dimension --- */; 229 ; 230 /**; 231 Enumeration defining the matrix dimension,; 232 number of rows, columns and size = rows*columns); 233 */; 234 enum {; 235 /// return no. of matrix rows; 236 kRows = D1,; 237 /// return no. of matrix columns; 238 kCols = D2,; 239 /// return no of elements: rows*columns; 240 kSize = D1*D2; 241 };; 242 ; 243 /** @name --- Access functions --- */; 244 ; 245 /** access the parse tree with the index starting from zero and; 246 following the C convention for the order in accessing; 247 the matrix elements.; 248 Same convention for general and symmetric matrices.; 249 */; 250 T apply(unsigned int i) const;; 251 ; 252 /// return read-only pointer to internal array; 253 const T* Array() const;; 254 /// return pointer to internal array; 255 T* Array();; 256 ; 257 /** @name --- STL-like interface ---; 258 The iterators access the matrix element in the order how they are; 259 stored in memory. The C (row-major) convention is used, and in the; 260 case of symmetric matrices the iterator spans only the lower diagonal; 261 block. For example for a symmetric 3x3 matrices the order of the 6; 262 elements \f${a_0,...a_5}\f$ is:; 263 \f[; 264 M = \left( \begin{array}{ccc}; 265 a_0 & a_1 & a_3 \\; 266 a_1 & a_2 & a_4 \\; 267 a_3 & a_4 & a_5 \end{array} \right); 268 \f]; 269 */; 270 ; 271 /** STL iterator interface. */; 272 iterator begin();; 273",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
Testability,assert,assert,"tor<(const T& rhs) const;; 335 /// element wise comparison; 336 template <class R2>; 337 bool operator>(const SMatrix<T,D1,D2,R2>& rhs) const;; 338 /// element wise comparison; 339 template <class R2>; 340 bool operator<(const SMatrix<T,D1,D2,R2>& rhs) const;; 341 /// element wise comparison; 342 template <class A, class R2>; 343 bool operator>(const Expr<A,T,D1,D2,R2>& rhs) const;; 344 /// element wise comparison; 345 template <class A, class R2>; 346 bool operator<(const Expr<A,T,D1,D2,R2>& rhs) const;; 347 ; 348 /**; 349 read only access to matrix element, with indices starting from 0; 350 */; 351 const T& operator()(unsigned int i, unsigned int j) const;; 352 /**; 353 read/write access to matrix element with indices starting from 0; 354 */; 355 T& operator()(unsigned int i, unsigned int j);; 356 ; 357 /**; 358 read only access to matrix element, with indices starting from 0.; 359 Function will check index values and it will assert if they are wrong; 360 */; 361 const T& At(unsigned int i, unsigned int j) const;; 362 /**; 363 read/write access to matrix element with indices starting from 0.; 364 Function will check index values and it will assert if they are wrong; 365 */; 366 T& At(unsigned int i, unsigned int j);; 367 ; 368 ; 369 // helper class for implementing the m[i][j] operator; 370 ; 371 class SMatrixRow {; 372 public:; 373 SMatrixRow ( SMatrix<T,D1,D2,R> & rhs, unsigned int i ) :; 374 fMat(&rhs), fRow(i); 375 {}; 376 T & operator[](int j) { return (*fMat)(fRow,j); }; 377 private:; 378 SMatrix<T,D1,D2,R> * fMat;; 379 unsigned int fRow;; 380 };; 381 ; 382 class SMatrixRow_const {; 383 public:; 384 SMatrixRow_const ( const SMatrix<T,D1,D2,R> & rhs, unsigned int i ) :; 385 fMat(&rhs), fRow(i); 386 {}; 387 ; 388 const T & operator[](int j) const { return (*fMat)(fRow, j); }; 389 ; 390 private:; 391 const SMatrix<T,D1,D2,R> * fMat;; 392 unsigned int fRow;; 393 };; 394 ; 395 /**; 396 read only access to matrix element, with indices starting from 0 : m[i][j]; 397",MatchSource.WIKI,doc/master/SMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html
Availability,down,down,"++;; }; i++; k=0;; }; ; ; ; ; // 2 ___||____||_____||____||____||____||____||; ; ; k=0; i=0;; ; while (i<5){; while(k<19){; sprintf(nBlocks,""ab%d"",N++);; mBlock = geom->MakeBox(nBlocks,Iron, 5,5,20);; mBlock->SetLineColor(50);; top->AddNodeOverlap(mBlock,1,new TGeoCombiTrans(-300+(k*33.3),78,525, new TGeoRotation(""r1"",0,0,0)));; k++;; }; i++; k=0;; }; ; ; ; ; k=0; i=0;; ; while (i<5){; while(k<19){; sprintf(nBlocks,""ab%d"",N++);; mBlock = geom->MakeBox(nBlocks,Iron, 5,5,20);; mBlock->SetLineColor(50);; top->AddNodeOverlap(mBlock,1,new TGeoCombiTrans(-300+(k*33.3),-78,525, new TGeoRotation(""r1"",0,0,0)));; k++;; }; i++; k=0;; }; ; ; ; k=0; i=0;; ; while (i<5){; while(k<5){; sprintf(nBlocks,""ab%d"",N++);; mBlock = geom->MakeBox(nBlocks,Iron, 5,5,20);; mBlock->SetLineColor(50);; top->AddNodeOverlap(mBlock,1,new TGeoCombiTrans(-300,-78+(k*33),525, new TGeoRotation(""r1"",0,0,0)));; k++;; }; i++; k=0;; }; ; ; ; ; ; k=0; i=0;; ; while (i<5){; while(k<5){; sprintf(nBlocks,""ab%d"",N++);; mBlock = geom->MakeBox(nBlocks,Iron, 5,5,20);; mBlock->SetLineColor(50);; top->AddNodeOverlap(mBlock,1,new TGeoCombiTrans(300,-78+(k*33),525, new TGeoRotation(""r1"",0,0,0)));; k++;; }; i++; k=0;; }; ; ; ; ; // ||// ||// ||// ||//; ; //down; ; k=0; i=0;; ; while (i<5){; while(k<19){; sprintf(nBlocks,""ab%d"",N++);; mBlock = geom->MakeBox(nBlocks,Iron, 5,5,20);; mBlock->SetLineColor(50);; top->AddNodeOverlap(mBlock,1,new TGeoCombiTrans(-300+(k*33.3),90,522, new TGeoRotation(""r1"",0,-45,0)));; k++;; }; i++; k=0;; }; ; ; ; ; k=0; i=0;; ; while (i<5){; while(k<19){; sprintf(nBlocks,""ab%d"",N++);; mBlock = geom->MakeBox(nBlocks,Iron, 5,5,20);; mBlock->SetLineColor(50);; top->AddNodeOverlap(mBlock,1,new TGeoCombiTrans(-300+(k*33.3),-90,522, new TGeoRotation(""r1"",0,45,0)));; k++;; }; i++; k=0;; }; ; ; k=0; i=0;; ; while (i<5){; while(k<5){; sprintf(nBlocks,""ab%d"",N++);; mBlock = geom->MakeBox(nBlocks,Iron, 5,5,20);; mBlock->SetLineColor(50);; top->AddNodeOverlap(mBlock,1,new TGeoCombiTrans(-318,-78+(k*33.3),52",MatchSource.WIKI,doc/master/south__gate_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/south__gate_8C.html
Availability,error,error,"/mathcore:$Id$; 2// Author: David Gonzalez Maline Wed Aug 28 15:33:03 2009; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for class BinData; 12 ; 13#include <iostream>; 14#include <iterator>; 15#include <algorithm>; 16 ; 17#include <vector>; 18#include <list>; 19 ; 20#include <stdexcept>; 21 ; 22#include <cmath>; 23#include <limits>; 24 ; 25#include ""Fit/BinData.h""; 26#include ""Fit/SparseData.h""; 27 ; 28using std::cout, std::endl, std::vector, std::list, std::ostream, std::ostream_iterator;; 29 ; 30namespace ROOT {; 31 ; 32 namespace Fit {; 33 ; 34 //This class is a helper. It represents a bin in N; 35 //dimensions. The change in the name is to avoid name collision.; 36 class Box; 37 {; 38 public:; 39 // Creates a Box with limits specified by the vectors and; 40 // content=value and error=error; 41 Box(const vector<double>& min, const vector<double>& max,; 42 const double value = 0.0, const double error = 1.0):; 43 fMin(min), fMax(max), fVal(value), fError(error); 44 { }; 45 ; 46 // Compares to Boxes to see if they are equal in all its; 47 // variables. This is to be used by the std::find algorithm; 48 bool operator==(const Box& b); 49 { return (fMin == b.fMin) && (fMax == b.fMax); 50 && (fVal == b.fVal) && (fError == b.fError); }; 51 ; 52 // Get the list of minimum coordinates; 53 const vector<double>& GetMin() const { return fMin; }; 54 // Get the list of maximum coordinates; 55 const vector<double>& GetMax() const { return fMax; }; 56 // Get the value of the Box; 57 double GetVal() const { return fVal; }; 58 // Get the error of the Box; 59 double GetError() const { return fError; }; 60 ; 61 // Add an amount to the content of the Box; 62 void AddVal(const double value) { fVal += value; }; 63 ; 64 friend class BoxContainer;; 65 friend ostream& operator <",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
Deployability,update,updated,"ox>();; 212 fList->PushBack(originalBox);; 213 }; 214 ; 215 SparseData::SparseData(const SparseData & rhs) :; 216 FitData(rhs); 217 {; 218 fList = std::make_unique<ProxyListBox>(*rhs.fList);; 219 }; 220 SparseData & SparseData::operator=(const SparseData & rhs); 221 {; 222 FitData::operator=( rhs );; 223 fList = std::make_unique<ProxyListBox>(*rhs.fList);; 224 return *this;; 225 }; 226 ; 227 SparseData::~SparseData() {}; 228 ; 229 unsigned int SparseData::NPoints() const; 230 {; 231 // Returns the number of points stored, including the 0 ones.; 232 return fList->GetList().size();; 233 }; 234 ; 235 unsigned int SparseData::NDim() const; 236 {; 237 // Returns the number of dimension of the SparseData object.; 238 return fList->Begin()->GetMin().size();; 239 }; 240 ; 241 void SparseData::Add(std::vector<double>& min, std::vector<double>& max,; 242 const double content, const double error); 243 {; 244 // Add a box to the stored ones. For that, it will look for; 245 // the box that contains the new data and either replace it; 246 // or updated it.; 247 ; 248 // Little box is the new Bin to be added; 249 Box littleBox(min, max);; 250 list<Box>::iterator it;; 251 // So we look for the Bin already in the list that contains; 252 // littleBox; 253 it = std::find_if(fList->Begin(), fList->End(), BoxContainer(littleBox));; 254 if ( it != fList->End() ); 255// cout << ""Found: "" << *it << endl;; 256 ;; 257 else {; 258 cout << ""SparseData::Add -> FAILED! box not found! "" << endl;; 259 cout << littleBox << endl;; 260 return; // Does not add the box, as it is part of the; 261 // underflow/overflow bin; 262 }; 263 // If it happens to have a value, then we add the value,; 264 if ( it->GetVal() ); 265 it->AddVal( content );; 266 else; 267 {; 268 // otherwise, we divide the container!; 269 DivideBox(it->GetMin(), it->GetMax(),; 270 littleBox.GetMin(), littleBox.GetMax(),; 271 it->GetMin().size(), it->GetMin().size() - 1,; 272 fList->GetList(), content, error );; 273 // and remove it from",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
Modifiability,variab,variables,"-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for class BinData; 12 ; 13#include <iostream>; 14#include <iterator>; 15#include <algorithm>; 16 ; 17#include <vector>; 18#include <list>; 19 ; 20#include <stdexcept>; 21 ; 22#include <cmath>; 23#include <limits>; 24 ; 25#include ""Fit/BinData.h""; 26#include ""Fit/SparseData.h""; 27 ; 28using std::cout, std::endl, std::vector, std::list, std::ostream, std::ostream_iterator;; 29 ; 30namespace ROOT {; 31 ; 32 namespace Fit {; 33 ; 34 //This class is a helper. It represents a bin in N; 35 //dimensions. The change in the name is to avoid name collision.; 36 class Box; 37 {; 38 public:; 39 // Creates a Box with limits specified by the vectors and; 40 // content=value and error=error; 41 Box(const vector<double>& min, const vector<double>& max,; 42 const double value = 0.0, const double error = 1.0):; 43 fMin(min), fMax(max), fVal(value), fError(error); 44 { }; 45 ; 46 // Compares to Boxes to see if they are equal in all its; 47 // variables. This is to be used by the std::find algorithm; 48 bool operator==(const Box& b); 49 { return (fMin == b.fMin) && (fMax == b.fMax); 50 && (fVal == b.fVal) && (fError == b.fError); }; 51 ; 52 // Get the list of minimum coordinates; 53 const vector<double>& GetMin() const { return fMin; }; 54 // Get the list of maximum coordinates; 55 const vector<double>& GetMax() const { return fMax; }; 56 // Get the value of the Box; 57 double GetVal() const { return fVal; }; 58 // Get the error of the Box; 59 double GetError() const { return fError; }; 60 ; 61 // Add an amount to the content of the Box; 62 void AddVal(const double value) { fVal += value; }; 63 ; 64 friend class BoxContainer;; 65 friend ostream& operator <<(ostream& os, const Box& b);; 66 ; 67 private:; 68 vector<double> fMin;; 69 vector<double> fMax;; 70 double fVal;; 71 double fError;; 72 };; 73 ; 74 // This class is just a helper to be used in std::for_each t",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
Safety,avoid,avoid," master. Reference Guide ; .  . Loading...; Searching...; No Matches. SparseData.cxx. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Author: David Gonzalez Maline Wed Aug 28 15:33:03 2009; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for class BinData; 12 ; 13#include <iostream>; 14#include <iterator>; 15#include <algorithm>; 16 ; 17#include <vector>; 18#include <list>; 19 ; 20#include <stdexcept>; 21 ; 22#include <cmath>; 23#include <limits>; 24 ; 25#include ""Fit/BinData.h""; 26#include ""Fit/SparseData.h""; 27 ; 28using std::cout, std::endl, std::vector, std::list, std::ostream, std::ostream_iterator;; 29 ; 30namespace ROOT {; 31 ; 32 namespace Fit {; 33 ; 34 //This class is a helper. It represents a bin in N; 35 //dimensions. The change in the name is to avoid name collision.; 36 class Box; 37 {; 38 public:; 39 // Creates a Box with limits specified by the vectors and; 40 // content=value and error=error; 41 Box(const vector<double>& min, const vector<double>& max,; 42 const double value = 0.0, const double error = 1.0):; 43 fMin(min), fMax(max), fVal(value), fError(error); 44 { }; 45 ; 46 // Compares to Boxes to see if they are equal in all its; 47 // variables. This is to be used by the std::find algorithm; 48 bool operator==(const Box& b); 49 { return (fMin == b.fMin) && (fMax == b.fMax); 50 && (fVal == b.fVal) && (fError == b.fError); }; 51 ; 52 // Get the list of minimum coordinates; 53 const vector<double>& GetMin() const { return fMin; }; 54 // Get the list of maximum coordinates; 55 const vector<double>& GetMax() const { return fMax; }; 56 // Get the value of the Box; 57 double GetVal() const { return fVal; }; 58 // Get the error of the Box; 59 double GetError() const { return fError; }; 60 ; 61 // Add an amount to the cont",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
Usability,simpl,simplify," in the name is to avoid name collision.; 36 class Box; 37 {; 38 public:; 39 // Creates a Box with limits specified by the vectors and; 40 // content=value and error=error; 41 Box(const vector<double>& min, const vector<double>& max,; 42 const double value = 0.0, const double error = 1.0):; 43 fMin(min), fMax(max), fVal(value), fError(error); 44 { }; 45 ; 46 // Compares to Boxes to see if they are equal in all its; 47 // variables. This is to be used by the std::find algorithm; 48 bool operator==(const Box& b); 49 { return (fMin == b.fMin) && (fMax == b.fMax); 50 && (fVal == b.fVal) && (fError == b.fError); }; 51 ; 52 // Get the list of minimum coordinates; 53 const vector<double>& GetMin() const { return fMin; }; 54 // Get the list of maximum coordinates; 55 const vector<double>& GetMax() const { return fMax; }; 56 // Get the value of the Box; 57 double GetVal() const { return fVal; }; 58 // Get the error of the Box; 59 double GetError() const { return fError; }; 60 ; 61 // Add an amount to the content of the Box; 62 void AddVal(const double value) { fVal += value; }; 63 ; 64 friend class BoxContainer;; 65 friend ostream& operator <<(ostream& os, const Box& b);; 66 ; 67 private:; 68 vector<double> fMin;; 69 vector<double> fMax;; 70 double fVal;; 71 double fError;; 72 };; 73 ; 74 // This class is just a helper to be used in std::for_each to; 75 // simplify the code later. It's just a definition of a method; 76 // that will discern whether a Box is included into another one; 77 class BoxContainer; 78 {; 79 private:; 80 const Box& fBox;; 81 public:; 82 //Constructs the BoxContainer object with a Box that is meant; 83 //to include another one that will be provided later; 84 BoxContainer(const Box& b): fBox(b) {}; 85 ; 86 bool operator() (const Box& b1); 87 { return operator()(fBox, b1); }; 88 ; 89 // Looks if b2 is included in b1; 90 bool operator() (const Box& b1, const Box& b2); 91 {; 92 bool isIn = true;; 93 vector<double>::const_iterator boxit = b2.fMin.begin();; 9",MatchSource.WIKI,doc/master/SparseData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html
Availability,error,errors,"tMarkerSizevirtual void SetMarkerSize(Size_t msize=1)Set the marker size.Definition TAttMarker.h:45; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet current canvas & pad.Definition TCanvas.cxx:719; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::SetTitlevoid SetTitle(const char *title) overrideChange/set the title.Definition TH1.cxx:6718; TH1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Definition TH1.h:404; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::Dividevirtual Bool_t Divide(TF1 *f1, Double_t c1=1)Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:2840; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH2::FillInt_t Fill(Double_t) overrideInvalid Fill method.Definition TH2.cxx:393; TH3F3-D histogram with a float per channel (see TH1 documentation)Definition TH3.h:317; THnSparseEfficient multidimensional histogram.Definition THnSparse.h:37; THnMultidimensional histogram.Definition THn.h:30; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TPad::Dividevoid Divide(Int_t nx=1, Int_t ny=1, Float_t xmargin=0.01, Float_t ymargin=0.01, Int_t color=0) overrideAutomatic pad generation by division.Definition TPad.cxx:1249; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Defi",MatchSource.WIKI,doc/master/sparsehist_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/sparsehist_8C.html
Energy Efficiency,allocate,allocate,"Stop();; ++rep[h];; } while ((!h && w.RealTime() < 0.1); || (h && rep[0] > 0 && rep[1] < rep[0]));; ; fTime[h][0] = (1.* fNum * rep[h]) / w.RealTime() / 1E6;; fTime[h][1] = (1.* fNum * rep[h]) / w.CpuTime() / 1E6;; ; if (h == 1 && (fTime[h][0] > 1E20 || fTime[h][1] > 1E20)) {; do {; // some more cycles:; w.Start(kFALSE);; Fill((EHist) h);; Check((EHist) h);; w.Stop();; ++rep[h];; } while (w.RealTime() < 0.1);; ; fTime[h][0] = (1.* fNum * rep[h]) / w.RealTime() / 1E6;; fTime[h][1] = (1.* fNum * rep[h]) / w.CpuTime() / 1E6;; }; ; if (fTime[h][0] > 1E20) fTime[h][0] = 1E20;; if (fTime[h][1] > 1E20) fTime[h][1] = 1E20;; }; catch (std::exception&) {; fTime[h][0] = fTime[h][1] = -1.;; check[h] = -1.; // can never be < 1 without exception; rep[h] = -1;; }; }; if (check[0] != check[1]); if (check[0] != -1.); printf(""ERROR: mismatch of histogram (%g) and sparse histogram (%g) for dim=%d, bins=%d!\n"",; check[0], check[1], fDim, fBins);; // else; // printf(""ERROR: cannot allocate histogram for dim=%d, bins=%d - out of memory!\n"",; // fDim, fBins);; return (check[0] == check[1]);; }; ; void TTimeHists::NextValues(); {; for (Int_t d = 0; d < fDim; ++d); fValue[d] = gRandom->Gaus() / 4.;; }; ; void TTimeHists::SetupValues(); {; // define fValue; if (!fValue) fValue = new Double_t[fDim];; gRandom->SetSeed(42);; }; ; void TTimeHists::Fill(EHist hist); {; for (Long_t n = 0; n < fNum; ++n) {; NextValues();; if (fgDebug > 1) {; printf(""%ld: fill %s"", n, hist == kHist? (fDim < 4 ? ""hist"" : ""arr"") : ""sparse"");; for (Int_t d = 0; d < fDim; ++d); printf(""[%g]"", fValue[d]);; printf(""\n"");; }; if (hist == kHist) {; switch (fDim) {; case 1: fHist->Fill(fValue[0]); break;; case 2: ((TH2F*)fHist)->Fill(fValue[0], fValue[1]); break;; case 3: ((TH3F*)fHist)->Fill(fValue[0], fValue[1], fValue[2]); break;; default: fHn->Fill(fValue); break;; }; } else {; fSparse->Fill(fValue);; }; }; }; ; void TTimeHists::SetupHist(EHist hist); {; if (hist == kHist) {; switch (fDim) {; case 1: fHist = new TH1F(""h1",MatchSource.WIKI,doc/master/sparsehist_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/sparsehist_8C.html
Integrability,depend,depends,". ROOT: tutorials/hist/sparsehist.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. sparsehist.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Evaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension. ; The script calculates the bandwidth for filling and retrieving bin contents (in million entries per second) for these two histogramming techniques, where ""seconds"" is CPU and real time.; The first line of the plots contains the bandwidth based on the CPU time (THnSpase, TH1/2/3/nF*, ratio), the second line shows the plots for real time, and the third line shows the fraction of filled bins and memory used by THnSparse vs. TH1/2/3/nF.; The timing depends on the distribution and the amount of entries in the histograms; here, a Gaussian distribution (center is contained in the histograms) is used to fill each histogram with 1000 entries. The filling and reading is repeated until enough statistics have been collected.; tutorials/tree/drawsparse.C shows an example for visualizing a THnSparse. It creates a TTree which is then drawn using TParallelCoord.; This macro should be run in compiled mode due to the many nested loops that force CLING to disable its optimization. If run interpreted one would not benchmark THnSparse but CLING.; Run as: root[0] .L $ROOTSYS/tutorials/hist/sparsehist.C+; root[1] sparsehist(); ; #include ""TH1.h""; #include ""TH2.h""; #include ""TH3.h""; #include ""THn.h""; #include ""THnSparse.h""; #include ""TStopwatch.h""; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""TFile.h""; #include ""TStyle.h""; #include ""TSystem.h""; ; #ifndef INT_MAX; #define INT_MAX std::numeric_limits<int>::max(); #endif; ; class TTimeHists {; public:; enum EHist { kHist, kSparse, kNumHist };; enum ETime { kReal, kCPU, kNumTime };; TTimeHists(Int_t dim, Int_t bins, Long_t num):; fValue(nullptr), fDim(dim), fBins(bins), fNum(num),; fSparse(nullptr), fHist(nullpt",MatchSource.WIKI,doc/master/sparsehist_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/sparsehist_8C.html
Performance,perform,performance,". ROOT: tutorials/hist/sparsehist.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. sparsehist.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Evaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension. ; The script calculates the bandwidth for filling and retrieving bin contents (in million entries per second) for these two histogramming techniques, where ""seconds"" is CPU and real time.; The first line of the plots contains the bandwidth based on the CPU time (THnSpase, TH1/2/3/nF*, ratio), the second line shows the plots for real time, and the third line shows the fraction of filled bins and memory used by THnSparse vs. TH1/2/3/nF.; The timing depends on the distribution and the amount of entries in the histograms; here, a Gaussian distribution (center is contained in the histograms) is used to fill each histogram with 1000 entries. The filling and reading is repeated until enough statistics have been collected.; tutorials/tree/drawsparse.C shows an example for visualizing a THnSparse. It creates a TTree which is then drawn using TParallelCoord.; This macro should be run in compiled mode due to the many nested loops that force CLING to disable its optimization. If run interpreted one would not benchmark THnSparse but CLING.; Run as: root[0] .L $ROOTSYS/tutorials/hist/sparsehist.C+; root[1] sparsehist(); ; #include ""TH1.h""; #include ""TH2.h""; #include ""TH3.h""; #include ""THn.h""; #include ""THnSparse.h""; #include ""TStopwatch.h""; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""TFile.h""; #include ""TStyle.h""; #include ""TSystem.h""; ; #ifndef INT_MAX; #define INT_MAX std::numeric_limits<int>::max(); #endif; ; class TTimeHists {; public:; enum EHist { kHist, kSparse, kNumHist };; enum ETime { kReal, kCPU, kNumTime };; TTimeHists(Int_t dim, Int_t bins, Long_t num):; fValue(nullptr), fDim(dim), fBins(bins), fNum(num),; fSparse(nullptr), fHist(nullpt",MatchSource.WIKI,doc/master/sparsehist_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/sparsehist_8C.html
Testability,benchmark,benchmark,"pt calculates the bandwidth for filling and retrieving bin contents (in million entries per second) for these two histogramming techniques, where ""seconds"" is CPU and real time.; The first line of the plots contains the bandwidth based on the CPU time (THnSpase, TH1/2/3/nF*, ratio), the second line shows the plots for real time, and the third line shows the fraction of filled bins and memory used by THnSparse vs. TH1/2/3/nF.; The timing depends on the distribution and the amount of entries in the histograms; here, a Gaussian distribution (center is contained in the histograms) is used to fill each histogram with 1000 entries. The filling and reading is repeated until enough statistics have been collected.; tutorials/tree/drawsparse.C shows an example for visualizing a THnSparse. It creates a TTree which is then drawn using TParallelCoord.; This macro should be run in compiled mode due to the many nested loops that force CLING to disable its optimization. If run interpreted one would not benchmark THnSparse but CLING.; Run as: root[0] .L $ROOTSYS/tutorials/hist/sparsehist.C+; root[1] sparsehist(); ; #include ""TH1.h""; #include ""TH2.h""; #include ""TH3.h""; #include ""THn.h""; #include ""THnSparse.h""; #include ""TStopwatch.h""; #include ""TRandom.h""; #include ""TCanvas.h""; #include ""TFile.h""; #include ""TStyle.h""; #include ""TSystem.h""; ; #ifndef INT_MAX; #define INT_MAX std::numeric_limits<int>::max(); #endif; ; class TTimeHists {; public:; enum EHist { kHist, kSparse, kNumHist };; enum ETime { kReal, kCPU, kNumTime };; TTimeHists(Int_t dim, Int_t bins, Long_t num):; fValue(nullptr), fDim(dim), fBins(bins), fNum(num),; fSparse(nullptr), fHist(nullptr), fHn(nullptr) {}; ~TTimeHists();; bool Run();; Double_t GetTime(EHist hist, ETime time) const {; if (time == kReal) return fTime[hist][0];; return fTime[hist][1]; }; static void SetDebug(Int_t lvl) { fgDebug = lvl; }; THnSparse* GetSparse() const { return fSparse; }; ; protected:; void Fill(EHist hist);; Double_t Check(EHist hist);;",MatchSource.WIKI,doc/master/sparsehist_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/sparsehist_8C.html
Availability,error,error,"--------------------------------------------------------------------------*/; 435/* implementation of the incomplete beta function */; 436/**; 437 * DESCRIPTION:; 438 *; 439 * Returns incomplete beta integral of the arguments, evaluated; 440 * from zero to x. The function is defined as; 441 *; 442 * x; 443 * - -; 444 * | (a+b) | | a-1 b-1; 445 * ----------- | t (1-t) dt.; 446 * - - | |; 447 * | (a) | (b) -; 448 * 0; 449 *; 450 * The domain of definition is 0 <= x <= 1. In this; 451 * implementation a and b are restricted to positive values.; 452 * The integral from x to 1 may be obtained by the symmetry; 453 * relation; 454 *; 455 * 1 - incbet( a, b, x ) = incbet( b, a, 1-x ).; 456 *; 457 * The integral is evaluated by a continued fraction expansion; 458 * or, when b*x is small, by a power series.; 459 *; 460 * ACCURACY:; 461 *; 462 * Tested at uniformly distributed random points (a,b,x) with a and b; 463 * in ""domain"" and x between 0 and 1.; 464 * Relative error; 465 * arithmetic domain # trials peak rms; 466 * IEEE 0,5 10000 6.9e-15 4.5e-16; 467 * IEEE 0,85 250000 2.2e-13 1.7e-14; 468 * IEEE 0,1000 30000 5.3e-12 6.3e-13; 469 * IEEE 0,10000 250000 9.3e-11 7.1e-12; 470 * IEEE 0,100000 10000 8.7e-10 4.8e-11; 471 * Outputs smaller than the IEEE gradual underflow threshold; 472 * were excluded from these statistics.; 473 *; 474 * ERROR MESSAGES:; 475 * message condition value returned; 476 * incbet domain x<0, x>1 0.0; 477 * incbet underflow 0.0; 478 *; 479 * Cephes Math Library, Release 2.8: June, 2000; 480 * Copyright 1984, 1995, 2000 by Stephen L. Moshier; 481 */; 482 ; 483 ; 484double incbet( double aa, double bb, double xx ); 485{; 486 double a, b, t, x, xc, w, y;; 487 int flag;; 488 ; 489 if( aa <= 0.0 || bb <= 0.0 ); 490 return( 0.0 );; 491 ; 492 // LM: changed: for X > 1 return 1.; 493 if (xx <= 0.0) return( 0.0 );; 494 if ( xx >= 1.0) return( 1.0 );; 495 ; 496 flag = 0;; 497 ; 498/* - to test if that way is better for large b/ (comment out from Cephes version)",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
Energy Efficiency,power,power,".; Searching...; No Matches. SpecFuncCephes.cxx. Go to the documentation of this file. 1//; 2//; 3// gamma and related functions from Cephes library; 4// see: http://www.netlib.org/cephes; 5//; 6// Copyright 1985, 1987, 2000 by Stephen L. Moshier; 7//; 8//; 9 ; 10#include ""SpecFuncCephes.h""; 11#include ""Math/Math.h""; 12 ; 13 ; 14#include <cmath>; 15 ; 16#include <limits>; 17 ; 18 ; 19 ; 20namespace ROOT {; 21namespace Math {; 22 ; 23namespace Cephes {; 24 ; 25 ; 26static double kBig = 4.503599627370496e15;; 27static double kBiginv = 2.22044604925031308085e-16;; 28 ; 29/* log( sqrt( 2*pi ) ) */; 30static double LS2PI = 0.91893853320467274178;; 31 ; 32 ; 33// incomplete gamma function (complement integral); 34// igamc(a,x) = 1 - igam(a,x); 35//; 36// inf.; 37// -; 38// 1 | | -t a-1; 39// = ----- | e t dt.; 40// - | |; 41// | (a) -; 42// x; 43//; 44//; 45 ; 46// In this implementation both arguments must be positive.; 47// The integral is evaluated by either a power series or; 48// continued fraction expansion, depending on the relative; 49// values of a and x.; 50 ; 51double igamc( double a, double x ); 52{; 53 ; 54 double ans, ax, c, yc, r, t, y, z;; 55 double pk, pkm1, pkm2, qk, qkm1, qkm2;; 56 ; 57 // LM: for negative values returns 0.0; 58 // This is correct if a is a negative integer since Gamma(-n) = +/- inf; 59 if (a <= 0) return 0.0;; 60 ; 61 if (x <= 0) return 1.0;; 62 ; 63 if( (x < 1.0) || (x < a) ); 64 return( 1.0 - igam(a,x) );; 65 ; 66 ax = a * std::log(x) - x - lgam(a);; 67 if( ax < -kMAXLOG ); 68 return( 0.0 );; 69 ; 70 ax = std::exp(ax);; 71 ; 72/* continued fraction */; 73 y = 1.0 - a;; 74 z = x + y + 1.0;; 75 c = 0.0;; 76 pkm2 = 1.0;; 77 qkm2 = x;; 78 pkm1 = x + 1.0;; 79 qkm1 = z * x;; 80 ans = pkm1/qkm1;; 81 ; 82 do; 83 {; 84 c += 1.0;; 85 y += 1.0;; 86 z += 2.0;; 87 yc = y * c;; 88 pk = pkm1 * z - pkm2 * yc;; 89 qk = qkm1 * z - qkm2 * yc;; 90 if(qk); 91 {; 92 r = pk/qk;; 93 t = std::abs( (ans - r)/r );; 94 ans = r;; 95 }; 96 else; 97 t = 1.0;; 98 pk",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
Integrability,depend,depending,".; Searching...; No Matches. SpecFuncCephes.cxx. Go to the documentation of this file. 1//; 2//; 3// gamma and related functions from Cephes library; 4// see: http://www.netlib.org/cephes; 5//; 6// Copyright 1985, 1987, 2000 by Stephen L. Moshier; 7//; 8//; 9 ; 10#include ""SpecFuncCephes.h""; 11#include ""Math/Math.h""; 12 ; 13 ; 14#include <cmath>; 15 ; 16#include <limits>; 17 ; 18 ; 19 ; 20namespace ROOT {; 21namespace Math {; 22 ; 23namespace Cephes {; 24 ; 25 ; 26static double kBig = 4.503599627370496e15;; 27static double kBiginv = 2.22044604925031308085e-16;; 28 ; 29/* log( sqrt( 2*pi ) ) */; 30static double LS2PI = 0.91893853320467274178;; 31 ; 32 ; 33// incomplete gamma function (complement integral); 34// igamc(a,x) = 1 - igam(a,x); 35//; 36// inf.; 37// -; 38// 1 | | -t a-1; 39// = ----- | e t dt.; 40// - | |; 41// | (a) -; 42// x; 43//; 44//; 45 ; 46// In this implementation both arguments must be positive.; 47// The integral is evaluated by either a power series or; 48// continued fraction expansion, depending on the relative; 49// values of a and x.; 50 ; 51double igamc( double a, double x ); 52{; 53 ; 54 double ans, ax, c, yc, r, t, y, z;; 55 double pk, pkm1, pkm2, qk, qkm1, qkm2;; 56 ; 57 // LM: for negative values returns 0.0; 58 // This is correct if a is a negative integer since Gamma(-n) = +/- inf; 59 if (a <= 0) return 0.0;; 60 ; 61 if (x <= 0) return 1.0;; 62 ; 63 if( (x < 1.0) || (x < a) ); 64 return( 1.0 - igam(a,x) );; 65 ; 66 ax = a * std::log(x) - x - lgam(a);; 67 if( ax < -kMAXLOG ); 68 return( 0.0 );; 69 ; 70 ax = std::exp(ax);; 71 ; 72/* continued fraction */; 73 y = 1.0 - a;; 74 z = x + y + 1.0;; 75 c = 0.0;; 76 pkm2 = 1.0;; 77 qkm2 = x;; 78 pkm1 = x + 1.0;; 79 qkm1 = z * x;; 80 ans = pkm1/qkm1;; 81 ; 82 do; 83 {; 84 c += 1.0;; 85 y += 1.0;; 86 z += 2.0;; 87 yc = y * c;; 88 pk = pkm1 * z - pkm2 * yc;; 89 qk = qkm1 * z - qkm2 * yc;; 90 if(qk); 91 {; 92 r = pk/qk;; 93 t = std::abs( (ans - r)/r );; 94 ans = r;; 95 }; 96 else; 97 t = 1.0;; 98 pk",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
Testability,log,log,". ROOT: math/mathcore/src/SpecFuncCephes.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. SpecFuncCephes.cxx. Go to the documentation of this file. 1//; 2//; 3// gamma and related functions from Cephes library; 4// see: http://www.netlib.org/cephes; 5//; 6// Copyright 1985, 1987, 2000 by Stephen L. Moshier; 7//; 8//; 9 ; 10#include ""SpecFuncCephes.h""; 11#include ""Math/Math.h""; 12 ; 13 ; 14#include <cmath>; 15 ; 16#include <limits>; 17 ; 18 ; 19 ; 20namespace ROOT {; 21namespace Math {; 22 ; 23namespace Cephes {; 24 ; 25 ; 26static double kBig = 4.503599627370496e15;; 27static double kBiginv = 2.22044604925031308085e-16;; 28 ; 29/* log( sqrt( 2*pi ) ) */; 30static double LS2PI = 0.91893853320467274178;; 31 ; 32 ; 33// incomplete gamma function (complement integral); 34// igamc(a,x) = 1 - igam(a,x); 35//; 36// inf.; 37// -; 38// 1 | | -t a-1; 39// = ----- | e t dt.; 40// - | |; 41// | (a) -; 42// x; 43//; 44//; 45 ; 46// In this implementation both arguments must be positive.; 47// The integral is evaluated by either a power series or; 48// continued fraction expansion, depending on the relative; 49// values of a and x.; 50 ; 51double igamc( double a, double x ); 52{; 53 ; 54 double ans, ax, c, yc, r, t, y, z;; 55 double pk, pkm1, pkm2, qk, qkm1, qkm2;; 56 ; 57 // LM: for negative values returns 0.0; 58 // This is correct if a is a negative integer since Gamma(-n) = +/- inf; 59 if (a <= 0) return 0.0;; 60 ; 61 if (x <= 0) return 1.0;; 62 ; 63 if( (x < 1.0) || (x < a) ); 64 return( 1.0 - igam(a,x) );; 65 ; 66 ax = a * std::log(x) - x - lgam(a);; 67 if( ax < -kMAXLOG ); 68 return( 0.0 );; 69 ; 70 ax = std::exp(ax);; 71 ; 72/* continued fraction */; 73 y = 1.0 - a;; 74 z = x + y + 1.0;; 75 c = 0.0;; 76 pkm2 = 1.0;; 77 qkm2 = x;; 78 pkm1 = x + 1.0;; 79 qkm1 = z * x;; 80 ans = pkm1/qkm1;; 81 ; 82 do; 83 {; 84 c += 1.0;; 85 y += 1.0;; 86 z += 2.0;; 87 yc = y * c;; 88 pk = pkm1 * z - pkm2 * yc;; 89 qk = qkm1 * z - qkm2 * yc;; 9",MatchSource.WIKI,doc/master/SpecFuncCephes_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html
Availability,error,error,"ter. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Macros ; SpecFuncMathCore.cxx File Reference. #include ""SpecFuncCephes.h""; #include <cmath>; #include <limits>. Include dependency graph for SpecFuncMathCore.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Math;  . Macros; #define PI   3.14159265358979323846264338328 /* pi */;  ; #define USE_CEPHES;  . Functions; Special Functions from MathCore; double ROOT::Math::beta (double x, double y);  Calculates the beta function. ;  ; double ROOT::Math::cosint (double x);  Calculates the real part of the cosine integral Re(Ci). ;  ; double ROOT::Math::erf (double x);  Error function encountered in integrating the normal distribution. ;  ; double ROOT::Math::erfc (double x);  Complementary error function. ;  ; double ROOT::Math::inc_beta (double x, double a, double b);  Calculates the normalized (regularized) incomplete beta function. ;  ; double ROOT::Math::inc_gamma (double a, double x);  Calculates the normalized (regularized) lower incomplete gamma function (lower integral) ;  ; double ROOT::Math::inc_gamma_c (double a, double x);  Calculates the normalized (regularized) upper incomplete gamma function (upper integral) ;  ; double ROOT::Math::lgamma (double x);  Calculates the logarithm of the gamma function. ;  ; double ROOT::Math::sinint (double x);  Calculates the sine integral. ;  ; double ROOT::Math::tgamma (double x);  The gamma function is defined to be the extension of the factorial to real numbers. ;  . Macro Definition Documentation. ◆ PI. #define PI   3.14159265358979323846264338328 /* pi */. Definition at line 23 of file SpecFuncMathCore.cxx. ◆ USE_CEPHES. #define USE_CEPHES. Definition at line 27 of file SpecFuncMathCore.cxx. mathmat",MatchSource.WIKI,doc/master/SpecFuncMathCore_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncMathCore_8cxx.html
Deployability,integrat,integrating,". ROOT: math/mathcore/src/SpecFuncMathCore.cxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Macros ; SpecFuncMathCore.cxx File Reference. #include ""SpecFuncCephes.h""; #include <cmath>; #include <limits>. Include dependency graph for SpecFuncMathCore.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Math;  . Macros; #define PI   3.14159265358979323846264338328 /* pi */;  ; #define USE_CEPHES;  . Functions; Special Functions from MathCore; double ROOT::Math::beta (double x, double y);  Calculates the beta function. ;  ; double ROOT::Math::cosint (double x);  Calculates the real part of the cosine integral Re(Ci). ;  ; double ROOT::Math::erf (double x);  Error function encountered in integrating the normal distribution. ;  ; double ROOT::Math::erfc (double x);  Complementary error function. ;  ; double ROOT::Math::inc_beta (double x, double a, double b);  Calculates the normalized (regularized) incomplete beta function. ;  ; double ROOT::Math::inc_gamma (double a, double x);  Calculates the normalized (regularized) lower incomplete gamma function (lower integral) ;  ; double ROOT::Math::inc_gamma_c (double a, double x);  Calculates the normalized (regularized) upper incomplete gamma function (upper integral) ;  ; double ROOT::Math::lgamma (double x);  Calculates the logarithm of the gamma function. ;  ; double ROOT::Math::sinint (double x);  Calculates the sine integral. ;  ; double ROOT::Math::tgamma (double x);  The gamma function is defined to be the extension of the factorial to real numbers. ;  . Macro Definition Documentation. ◆ PI. #define PI   3.14159265358979323846264338328 /* pi */. Definition at line 23 of file SpecFuncMathCore.cxx. ◆ USE_CEPHES. #d",MatchSource.WIKI,doc/master/SpecFuncMathCore_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncMathCore_8cxx.html
Integrability,depend,dependency,". ROOT: math/mathcore/src/SpecFuncMathCore.cxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Macros ; SpecFuncMathCore.cxx File Reference. #include ""SpecFuncCephes.h""; #include <cmath>; #include <limits>. Include dependency graph for SpecFuncMathCore.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Math;  . Macros; #define PI   3.14159265358979323846264338328 /* pi */;  ; #define USE_CEPHES;  . Functions; Special Functions from MathCore; double ROOT::Math::beta (double x, double y);  Calculates the beta function. ;  ; double ROOT::Math::cosint (double x);  Calculates the real part of the cosine integral Re(Ci). ;  ; double ROOT::Math::erf (double x);  Error function encountered in integrating the normal distribution. ;  ; double ROOT::Math::erfc (double x);  Complementary error function. ;  ; double ROOT::Math::inc_beta (double x, double a, double b);  Calculates the normalized (regularized) incomplete beta function. ;  ; double ROOT::Math::inc_gamma (double a, double x);  Calculates the normalized (regularized) lower incomplete gamma function (lower integral) ;  ; double ROOT::Math::inc_gamma_c (double a, double x);  Calculates the normalized (regularized) upper incomplete gamma function (upper integral) ;  ; double ROOT::Math::lgamma (double x);  Calculates the logarithm of the gamma function. ;  ; double ROOT::Math::sinint (double x);  Calculates the sine integral. ;  ; double ROOT::Math::tgamma (double x);  The gamma function is defined to be the extension of the factorial to real numbers. ;  . Macro Definition Documentation. ◆ PI. #define PI   3.14159265358979323846264338328 /* pi */. Definition at line 23 of file SpecFuncMathCore.cxx. ◆ USE_CEPHES. #d",MatchSource.WIKI,doc/master/SpecFuncMathCore_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncMathCore_8cxx.html
Testability,log,logarithm," ""SpecFuncCephes.h""; #include <cmath>; #include <limits>. Include dependency graph for SpecFuncMathCore.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Math;  . Macros; #define PI   3.14159265358979323846264338328 /* pi */;  ; #define USE_CEPHES;  . Functions; Special Functions from MathCore; double ROOT::Math::beta (double x, double y);  Calculates the beta function. ;  ; double ROOT::Math::cosint (double x);  Calculates the real part of the cosine integral Re(Ci). ;  ; double ROOT::Math::erf (double x);  Error function encountered in integrating the normal distribution. ;  ; double ROOT::Math::erfc (double x);  Complementary error function. ;  ; double ROOT::Math::inc_beta (double x, double a, double b);  Calculates the normalized (regularized) incomplete beta function. ;  ; double ROOT::Math::inc_gamma (double a, double x);  Calculates the normalized (regularized) lower incomplete gamma function (lower integral) ;  ; double ROOT::Math::inc_gamma_c (double a, double x);  Calculates the normalized (regularized) upper incomplete gamma function (upper integral) ;  ; double ROOT::Math::lgamma (double x);  Calculates the logarithm of the gamma function. ;  ; double ROOT::Math::sinint (double x);  Calculates the sine integral. ;  ; double ROOT::Math::tgamma (double x);  The gamma function is defined to be the extension of the factorial to real numbers. ;  . Macro Definition Documentation. ◆ PI. #define PI   3.14159265358979323846264338328 /* pi */. Definition at line 23 of file SpecFuncMathCore.cxx. ◆ USE_CEPHES. #define USE_CEPHES. Definition at line 27 of file SpecFuncMathCore.cxx. mathmathcoresrcSpecFuncMathCore.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/SpecFuncMathCore_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncMathCore_8cxx.html
Availability,error,error,"as Zsenei & Lorenzo Moneta 06/2005; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11#if defined(__sun) || defined(__sgi) || defined(_WIN32) || defined(_AIX); 12#define NOT_HAVE_TGAMMA; 13#endif; 14 ; 15 ; 16#include ""SpecFuncCephes.h""; 17 ; 18 ; 19#include <cmath>; 20#include <limits>; 21 ; 22#ifndef PI; 23#define PI 3.14159265358979323846264338328 /* pi */; 24#endif; 25 ; 26// use cephes for functions which are also in C99; 27#define USE_CEPHES; 28 ; 29// platforms not implemening C99; 30// #if defined(__sun) || defined(__sgi) || defined(_WIN32) || defined(_AIX); 31// #define USE_CEPHES; 32// #endif; 33 ; 34 ; 35namespace ROOT {; 36namespace Math {; 37 ; 38 ; 39 ; 40 ; 41 ; 42// (26.x.21.2) complementary error function; 43 ; 44double erfc(double x) {; 45 ; 46 ; 47#ifdef USE_CEPHES; 48 // use cephes implementation; 49 return ROOT::Math::Cephes::erfc(x);; 50#else; 51 return ::erfc(x);; 52#endif; 53 ; 54}; 55 ; 56 ; 57// (26.x.21.1) error function; 58 ; 59double erf(double x) {; 60 ; 61 ; 62#ifdef USE_CEPHES; 63 return ROOT::Math::Cephes::erf(x);; 64#else; 65 return ::erf(x);; 66#endif; 67 ; 68 ; 69}; 70 ; 71 ; 72 ; 73 ; 74double lgamma(double z) {; 75 ; 76#ifdef USE_CEPHES; 77 return ROOT::Math::Cephes::lgam(z);; 78#else; 79 return ::lgamma(z);; 80#endif; 81 ; 82}; 83 ; 84 ; 85 ; 86 ; 87// (26.x.18) gamma function; 88 ; 89double tgamma(double x) {; 90 ; 91#ifdef USE_CEPHES; 92 return ROOT::Math::Cephes::gamma(x);; 93#else; 94 return ::tgamma(x);; 95#endif; 96 ; 97}; 98 ; 99double inc_gamma( double a, double x) {; 100 return ROOT::Math::Cephes::igam(a,x);; 101}; 102 ; 103double inc_gamma_c( double a, double x) {; 104 return ROOT::Math::Cephes::igamc(a,x);; 105}; 106 ; 107 ; 108// [5.2.1.3] beta function; 109// (26.x.19); 110 ; 111double beta(double x, double y) {; 112 return std::exp(lgamm",MatchSource.WIKI,doc/master/SpecFuncMathCore_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncMathCore_8cxx_source.html
Deployability,integrat,integrating,"double inc_beta(double x, double a, double b)Calculates the normalized (regularized) incomplete beta function.Definition SpecFuncMathCore.cxx:115; ROOT::Math::erfcdouble erfc(double x)Complementary error function.Definition SpecFuncMathCore.cxx:44; ROOT::Math::sinintdouble sinint(double x)Calculates the sine integral.Definition SpecFuncMathCore.cxx:122; ROOT::Math::tgammadouble tgamma(double x)The gamma function is defined to be the extension of the factorial to real numbers.Definition SpecFuncMathCore.cxx:89; ROOT::Math::lgammadouble lgamma(double x)Calculates the logarithm of the gamma function.Definition SpecFuncMathCore.cxx:74; ROOT::Math::cosintdouble cosint(double x)Calculates the real part of the cosine integral Re(Ci).Definition SpecFuncMathCore.cxx:212; ROOT::Math::inc_gammadouble inc_gamma(double a, double x)Calculates the normalized (regularized) lower incomplete gamma function (lower integral)Definition SpecFuncMathCore.cxx:99; ROOT::Math::erfdouble erf(double x)Error function encountered in integrating the normal distribution.Definition SpecFuncMathCore.cxx:59; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; MathNamespace for new Math classes and functions.; ROOT::Math::Cephes::erfcdouble erfc(double a)Definition SpecFuncCephes.cxx:874; ROOT::Math::Cephes::erfdouble erf(double x)Definition SpecFuncCephes.cxx:926; ROOT::Math::Cephes::incbetdouble incbet(double aa, double bb, double xx)DESCRIPTION:Definition SpecFuncCephes.cxx:484; ROOT::Math::Cephes::igamdouble igam(double a, double x)Definition SpecFuncCephes.cxx:127; ROOT::Math::Cephes::lgamdouble lgam(double x)Definition SpecFuncCephes.cxx:197; ROOT::Math::Cephes::igamcdouble igamc(double a, double x)incomplete complementary gamma function igamc(a, x) = 1 - igam(a, x)Definition SpecFuncCephes.cxx:51; ROOT::Math::Cephes::gammadouble gamma(double x)Definition SpecFuncCephes.cxx:339; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forwar",MatchSource.WIKI,doc/master/SpecFuncMathCore_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncMathCore_8cxx_source.html
Integrability,integrat,integrating,"double inc_beta(double x, double a, double b)Calculates the normalized (regularized) incomplete beta function.Definition SpecFuncMathCore.cxx:115; ROOT::Math::erfcdouble erfc(double x)Complementary error function.Definition SpecFuncMathCore.cxx:44; ROOT::Math::sinintdouble sinint(double x)Calculates the sine integral.Definition SpecFuncMathCore.cxx:122; ROOT::Math::tgammadouble tgamma(double x)The gamma function is defined to be the extension of the factorial to real numbers.Definition SpecFuncMathCore.cxx:89; ROOT::Math::lgammadouble lgamma(double x)Calculates the logarithm of the gamma function.Definition SpecFuncMathCore.cxx:74; ROOT::Math::cosintdouble cosint(double x)Calculates the real part of the cosine integral Re(Ci).Definition SpecFuncMathCore.cxx:212; ROOT::Math::inc_gammadouble inc_gamma(double a, double x)Calculates the normalized (regularized) lower incomplete gamma function (lower integral)Definition SpecFuncMathCore.cxx:99; ROOT::Math::erfdouble erf(double x)Error function encountered in integrating the normal distribution.Definition SpecFuncMathCore.cxx:59; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; MathNamespace for new Math classes and functions.; ROOT::Math::Cephes::erfcdouble erfc(double a)Definition SpecFuncCephes.cxx:874; ROOT::Math::Cephes::erfdouble erf(double x)Definition SpecFuncCephes.cxx:926; ROOT::Math::Cephes::incbetdouble incbet(double aa, double bb, double xx)DESCRIPTION:Definition SpecFuncCephes.cxx:484; ROOT::Math::Cephes::igamdouble igam(double a, double x)Definition SpecFuncCephes.cxx:127; ROOT::Math::Cephes::lgamdouble lgam(double x)Definition SpecFuncCephes.cxx:197; ROOT::Math::Cephes::igamcdouble igamc(double a, double x)incomplete complementary gamma function igamc(a, x) = 1 - igam(a, x)Definition SpecFuncCephes.cxx:51; ROOT::Math::Cephes::gammadouble gamma(double x)Definition SpecFuncCephes.cxx:339; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forwar",MatchSource.WIKI,doc/master/SpecFuncMathCore_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncMathCore_8cxx_source.html
Testability,log,log,"; 248 +0.00000313199197601, -0.00000042110196496,; 249 +0.00000006907244830, -0.00000001318321290,; 250 +0.00000000283697433, -0.00000000067329234,; 251 +0.00000000017339687, -0.00000000004786939,; 252 +0.00000000001403235, -0.00000000000433496,; 253 +0.00000000000140273, -0.00000000000047306,; 254 +0.00000000000016558, -0.00000000000005994,; 255 +0.00000000000002237, -0.00000000000000859,; 256 +0.00000000000000338, -0.00000000000000136,; 257 +0.00000000000000056, -0.00000000000000024,; 258 +0.00000000000000010};; 259 ; 260 double h = 0;; 261 if(x == 0) {; 262 h = - std::numeric_limits<double>::infinity();; 263 } else if (std::abs(x) <= 8) {; 264 h = r32*x*x-1;; 265 double alfa = h+h;; 266 double b0 = 0;; 267 double b1 = 0;; 268 double b2 = 0;; 269 for (int i = 15; i >= 0; --i) {; 270 b0 = c[i]+alfa*b1-b2;; 271 b2 = b1;; 272 b1 = b0;; 273 }; 274 h = ce+std::log(std::abs(x))-b0+h*b2;; 275 } else {; 276 double r = 1/x;; 277 h = 128*r*r-1;; 278 double alfa = h+h;; 279 double b0 = 0;; 280 double b1 = 0;; 281 double b2 = 0;; 282 for (int i = 28; i >= 0; --i) {; 283 b0 = p[i]+alfa*b1-b2;; 284 b2 = b1;; 285 b1 = b0;; 286 }; 287 double pp = b0-h*b2;; 288 b1 = 0;; 289 b2 = 0;; 290 for (int i = 24; i >= 0; --i) {; 291 b0 = q[i]+alfa*b1-b2;; 292 b2 = b1;; 293 b1 = b0;; 294 }; 295 h = r*((b0-h*b2)*std::sin(x)-r*pp*std::cos(x));; 296 }; 297 return h;; 298}; 299 ; 300 ; 301 ; 302 ; 303} // namespace Math; 304} // namespace ROOT; 305 ; 306 ; 307 ; 308 ; 309 ; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; SpecFuncCephes.h; PI#define PIDefinition SpecFuncMathCore.cxx:23; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefin",MatchSource.WIKI,doc/master/SpecFuncMathCore_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SpecFuncMathCore_8cxx_source.html
Modifiability,variab,variables,". ROOT: tutorials/tree/spider.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. spider.C File ReferenceTutorials » Tree tutorials. Detailed Description; TSpider example. ; ; #include ""TFile.h""; #include ""TCanvas.h""; #include ""TNtuple.h""; #include ""TSpider.h""; ; void spider() {; TCanvas *c1 = new TCanvas(""c1"",""TSpider example"",200,10,700,700);; TFile *f = new TFile(""hsimple.root"");; if (!f || f->IsZombie()) {; printf(""Please run <ROOT location>/tutorials/hsimple.C before."");; return;; }; TNtuple* ntuple = (TNtuple*)f->Get(""ntuple"");; TString varexp = ""px:py:pz:random:sin(px):log(px/py):log(pz)"";; TString selection = ""px>0 && py>0 && pz>0"";; TString options = ""average"";; TSpider *spider = new TSpider(ntuple,varexp.Data(),selection.Data(),options.Data());; spider->Draw();; c1->ToggleEditor();; c1->Selected(c1,spider,1);; }; f#define f(i)Definition RSha256.hxx:104; TCanvas.h; TFile.h; TNtuple.h; TSpider.h; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TSpiderSpider class.Definition TSpider.h:40; TSpider::Drawvoid Draw(Option_t *options="""") overrideDraw the spider.Definition TSpider.cxx:454; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; c1return c1Definition legend1.C:41; AuthorBastien Dallapiazza ; Definition in file spider.C. tutorialstreespider.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/spider_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/spider_8C.html
Testability,log,log,". ROOT: tutorials/tree/spider.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. spider.C File ReferenceTutorials » Tree tutorials. Detailed Description; TSpider example. ; ; #include ""TFile.h""; #include ""TCanvas.h""; #include ""TNtuple.h""; #include ""TSpider.h""; ; void spider() {; TCanvas *c1 = new TCanvas(""c1"",""TSpider example"",200,10,700,700);; TFile *f = new TFile(""hsimple.root"");; if (!f || f->IsZombie()) {; printf(""Please run <ROOT location>/tutorials/hsimple.C before."");; return;; }; TNtuple* ntuple = (TNtuple*)f->Get(""ntuple"");; TString varexp = ""px:py:pz:random:sin(px):log(px/py):log(pz)"";; TString selection = ""px>0 && py>0 && pz>0"";; TString options = ""average"";; TSpider *spider = new TSpider(ntuple,varexp.Data(),selection.Data(),options.Data());; spider->Draw();; c1->ToggleEditor();; c1->Selected(c1,spider,1);; }; f#define f(i)Definition RSha256.hxx:104; TCanvas.h; TFile.h; TNtuple.h; TSpider.h; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TSpiderSpider class.Definition TSpider.h:40; TSpider::Drawvoid Draw(Option_t *options="""") overrideDraw the spider.Definition TSpider.cxx:454; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; c1return c1Definition legend1.C:41; AuthorBastien Dallapiazza ; Definition in file spider.C. tutorialstreespider.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/spider_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/spider_8C.html
Usability,simpl,simple,". ROOT: tutorials/tree/spider.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. spider.C File ReferenceTutorials » Tree tutorials. Detailed Description; TSpider example. ; ; #include ""TFile.h""; #include ""TCanvas.h""; #include ""TNtuple.h""; #include ""TSpider.h""; ; void spider() {; TCanvas *c1 = new TCanvas(""c1"",""TSpider example"",200,10,700,700);; TFile *f = new TFile(""hsimple.root"");; if (!f || f->IsZombie()) {; printf(""Please run <ROOT location>/tutorials/hsimple.C before."");; return;; }; TNtuple* ntuple = (TNtuple*)f->Get(""ntuple"");; TString varexp = ""px:py:pz:random:sin(px):log(px/py):log(pz)"";; TString selection = ""px>0 && py>0 && pz>0"";; TString options = ""average"";; TSpider *spider = new TSpider(ntuple,varexp.Data(),selection.Data(),options.Data());; spider->Draw();; c1->ToggleEditor();; c1->Selected(c1,spider,1);; }; f#define f(i)Definition RSha256.hxx:104; TCanvas.h; TFile.h; TNtuple.h; TSpider.h; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TSpiderSpider class.Definition TSpider.h:40; TSpider::Drawvoid Draw(Option_t *options="""") overrideDraw the spider.Definition TSpider.cxx:454; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; c1return c1Definition legend1.C:41; AuthorBastien Dallapiazza ; Definition in file spider.C. tutorialstreespider.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/spider_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/spider_8C.html
Energy Efficiency,power,power,". ROOT: tutorials/graphs/splines_test.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. splines_test.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Examples of use of the spline classes. . ; void splines_test(Int_t np=23, Double_t a=-0.5, Double_t b=31); {; // array of points; Double_t *xx=0, *yy=0;; TSpline3 *spline3=0;; TSpline5 *spline5=0;; TLine *line5, *line3;; TText *text5, *text3, *textn;; char text[20];; const Double_t power=0.75;; ; // Define the original function; TF1 *f=new TF1(""f"",""sin(x)*sin(x/10)"",; a-0.05*(b-a),b+0.05*(b-a));; // Draw function; f->Draw(""lc"");; ; // Create text and legend; Double_t xx1, yy1, xx2, yy2, dx, dy;; gPad->Update();; gPad->GetRangeAxis(xx1,yy1,xx2,yy2);; dx = xx2-xx1;; dy = yy2-yy1;; line5=new TLine(xx1+dx*0.3,yy1+dy*1.02,; xx1+dx*0.38,yy1+dy*1.02);; line5->SetLineColor(kRed);; line5->SetLineWidth(2);; text5 = new TText(xx1+dx*0.4,; yy1+dy*1.03,""quintic spline"");; text5->SetTextAlign(12);; text5->SetTextSize(0.04);; line3=new TLine(xx1+dx*0.67,yy1+dy*1.02,; xx1+dx*0.75,yy1+dy*1.02);; line3->SetLineColor(kGreen);; line3->SetLineWidth(2);; text3 = new TText(xx1+dx*0.77,; yy1+dy*1.03,""third spline"");; text3->SetTextAlign(12);; text3->SetTextSize(0.04);; textn = new TText(xx1+dx*0.8,yy1+dy*0.91,"" "");; textn->SetTextAlign(12);; textn->SetTextSize(0.04);; textn->Draw();; ; // Draw legenda; line5->Draw();; text5->Draw();; line3->Draw();; text3->Draw();; ; for(Int_t nnp=2; nnp<=np; ++nnp) {; ; // Calculate the knots; if(xx) delete[] xx;; xx = new Double_t[nnp];; if(yy) delete[] yy;; yy = new Double_t[nnp];; for (Int_t i=0; i<nnp; ++i) {; xx[i]=a+(b-a)*TMath::Power(i/Double_t (nnp-1),power);; yy[i]=f->Eval(xx[i]);; }; ; // Evaluate fifth spline coefficients; Double_t eps=(b-a)*1.e-5;; if(spline5) delete spline5;; spline5 = new TSpline5(""Test"",xx,f,nnp,""b1e1b2e2"",; f->Derivative(a),f->Derivative(b),; (f->Derivative(a+eps)-f->Derivative(a))/eps,; (f->Derivative(b)-f->D",MatchSource.WIKI,doc/master/splines__test_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/splines__test_8C.html
Usability,simpl,simple,"tion TGWin32VirtualXProxy.cxx:68; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; gPad#define gPadDefinition TVirtualPad.h:308; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TAttMarker::SetMarkerSizevirtual void SetMarkerSize(Size_t msize=1)Set the marker size.Definition TAttMarker.h:45; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TF11-Dim function classDefinition TF1.h:233; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TSpline3Class to create third splines to interpolate knots Arbitrary conditions can be introduced for first a...Definition TSpline.h:182; TSpline5Class to create quintic natural splines to interpolate knots Arbitrary conditions can be introduced f...Definition TSpline.h:238; TSpline::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TSpline.cxx:101; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; TTextBase class for several text objects.Definition TText.h:22; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; AuthorFederico Carminati ;",MatchSource.WIKI,doc/master/splines__test_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/splines__test_8C.html
Security,access,access,". ROOT: tutorials/pyroot/staff.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; staff.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; example of macro to read data from an ascii file and create a root file with a Tree. ; NOTE: comparing the results of this macro with those of staff.C, you'll notice that the resultant file is a couple of bytes smaller, because the code below strips all white-spaces, whereas the .C version does not.; ; import re, array, os; import ROOT; from ROOT import TFile, TTree, gROOT, addressof; ; ## A C/C++ structure is required, to allow memory based access; gROOT.ProcessLine(; ""struct staff_t {\; Int_t Category;\; UInt_t Flag;\; Int_t Age;\; Int_t Service;\; Int_t Children;\; Int_t Grade;\; Int_t Step;\; Int_t Hrweek;\; Int_t Cost;\; Char_t Division[4];\; Char_t Nation[3];\; };"" );; ; ## Function to read in data from ASCII file and fill the ROOT tree; def staff():; ; staff = ROOT.staff_t(); ; # The input file cern.dat is a copy of the CERN staff data base; # from 1988; ; f = TFile( 'staff.root', 'RECREATE' ); tree = TTree( 'T', 'staff data from ascii file' ); tree.Branch( 'staff', staff, 'Category/I:Flag:Age:Service:Children:Grade:Step:Hrweek:Cost' ); tree.Branch( 'Divisions', addressof( staff, 'Division' ), 'Division/C' ); tree.Branch( 'Nation', addressof( staff, 'Nation' ), 'Nation/C' ); ; # note that the branches Division and Nation cannot be on the first branch; fname = os.path.join(str(ROOT.gROOT.GetTutorialDir()), 'tree', 'cernstaff.dat'); for line in open(fname).readlines():; t = list(filter( lambda x: x, re.split( '\s+', line ) ) ); staff.Category = int(t[0]) # assign as integers; staff.Flag = int(t[1]); staff.Age = int(t[2]); staff.Service = int(t[3]); staff.Children = int(t[4]); staff.Grade = int(t[5]); staff.Step = int(t[6]); staff.Hrweek = int(t[7]); staff.Cost = int(t[8]); staff.Division = t[9] # assign as strings; staff.Nation = t[10]; ; tree.Fil",MatchSource.WIKI,doc/master/staff_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/staff_8py.html
Safety,avoid,avoid,"; .  . Loading...; Searching...; No Matches. statsEditing.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Edit statistics box. ; This example shows:; how to remove a stat element from the stat box; how to add a new one. ; TCanvas *statsEditing() {; // Create and plot a test histogram with stats; TCanvas *se = new TCanvas;; TH1F *h = new TH1F(""h"",""test"",100,-3,3);; h->FillRandom(""gaus"",3000);; gStyle->SetOptStat();; h->Draw();; se->Update();; ; // Retrieve the stat box; TPaveStats *ps = (TPaveStats*)se->GetPrimitive(""stats"");; ps->SetName(""mystats"");; TList *listOfLines = ps->GetListOfLines();; ; // Remove the RMS line; TText *tconst = ps->GetLineWith(""RMS"");; listOfLines->Remove(tconst);; ; // Add a new line in the stat box.; // Note that ""="" is a control character; TLatex *myt = new TLatex(0,0,""Test = 10"");; myt ->SetTextFont(42);; myt ->SetTextSize(0.04);; myt ->SetTextColor(kRed);; listOfLines->Add(myt);; ; // the following line is needed to avoid that the automatic redrawing of stats; h->SetStats(0);; ; se->Modified();; return se;; }; h#define h(i)Definition RSha256.hxx:106; kRed@ kRedDefinition Rtypes.h:66; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::Updatevoid Update() overrideUpdate canvas pad buffers.Definition TCanvas.cxx:2489; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object f",MatchSource.WIKI,doc/master/statsEditing_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/statsEditing_8C.html
Testability,test,test,". ROOT: tutorials/hist/statsEditing.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. statsEditing.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Edit statistics box. ; This example shows:; how to remove a stat element from the stat box; how to add a new one. ; TCanvas *statsEditing() {; // Create and plot a test histogram with stats; TCanvas *se = new TCanvas;; TH1F *h = new TH1F(""h"",""test"",100,-3,3);; h->FillRandom(""gaus"",3000);; gStyle->SetOptStat();; h->Draw();; se->Update();; ; // Retrieve the stat box; TPaveStats *ps = (TPaveStats*)se->GetPrimitive(""stats"");; ps->SetName(""mystats"");; TList *listOfLines = ps->GetListOfLines();; ; // Remove the RMS line; TText *tconst = ps->GetLineWith(""RMS"");; listOfLines->Remove(tconst);; ; // Add a new line in the stat box.; // Note that ""="" is a control character; TLatex *myt = new TLatex(0,0,""Test = 10"");; myt ->SetTextFont(42);; myt ->SetTextSize(0.04);; myt ->SetTextColor(kRed);; listOfLines->Add(myt);; ; // the following line is needed to avoid that the automatic redrawing of stats; h->SetStats(0);; ; se->Modified();; return se;; }; h#define h(i)Definition RSha256.hxx:106; kRed@ kRedDefinition Rtypes.h:66; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::Updatevoid Update() overrideUpdate canvas pad buffers.Definition TCanvas.cxx:2489; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideD",MatchSource.WIKI,doc/master/statsEditing_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/statsEditing_8C.html
Integrability,depend,dependency,". ROOT: core/clingutils/src/stlLoader.cc File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions |; Variables ; stlLoader.cc File Reference. #include ""G__ci.h""; #include ""Api.h""; #include ""FastAllocString.h"". Include dependency graph for stlLoader.cc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Functions; static int stlLoader ();  . Variables; static int sltLoad = stlLoader();  ; static const char * what = WHAT;  . Function Documentation. ◆ stlLoader(). static int stlLoader ; (; ). static . Definition at line 7 of file stlLoader.cc. Variable Documentation. ◆ sltLoad. int sltLoad = stlLoader(). static . Definition at line 29 of file stlLoader.cc. ◆ what. const char* what = WHAT. static . Definition at line 5 of file stlLoader.cc. coreclingutilssrcstlLoader.cc. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:13 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/stlLoader_8cc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/stlLoader_8cc.html
Availability,failure,failure," the result; 60 exp = 1;; 61 } else if (bytes > 0) {; 62 exp = std::min( (int) (std::log(bytes) / std::log(unit)),; 63 (int) (sizeof(suffix) / sizeof(suffix[0]) - 1));; 64 }; 65 *coeff = bytes / std::pow(unit, exp);; 66 *units = suffix[exp][!si];; 67}; 68 ; 69enum class EFromHumanReadableSize {; 70 kSuccess,; 71 kParseFail,; 72 kOverflow; 73};; 74 ; 75///////////////////////////////////////////////////////////////////////////////; 76/// Convert strings like the following into byte counts; 77/// 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB; 78/// with some amount of forgiveness baked into the parsing.; 79/// For this routine we use the official SI unit where the [i] is reserved; 80/// for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes.; 81/// \param str the string to be parsed; 82/// \param value will be updated with the result if and only if the parse is successful and does not overflow for the type of value.; 83/// \return return a EFromHumanReadableSize enum value indicating the success or failure of the parse.; 84///; 85template <typename T>; 86EFromHumanReadableSize FromHumanReadableSize(std::string_view str, T &value); 87{; 88 try {; 89 size_t cur, size = str.size();; 90 // Parse leading numeric factor; 91 const double coeff = stod(std::string(str.data(), str.size()), &cur);; 92 ; 93 // Skip any intermediate white space; 94 while (cur<size && isspace(str[cur])) ++cur;; 95 ; 96 // Read off first character which should be an SI prefix; 97 int exp = 0, unit = 1000;; 98 ; 99 auto result = [coeff,&exp,&unit,&value]() {; 100 double v = exp ? coeff * std::pow(unit, exp / 3) : coeff;; 101 if (v < (double) std::numeric_limits<T>::max()) {; 102 value = (T)v;; 103 return EFromHumanReadableSize::kSuccess;; 104 } else {; 105 return EFromHumanReadableSize::kOverflow;; 106 }; 107 };; 108 if (cur==size) return result();; 109 ; 110 switch (toupper(str[cur])) {; 111 case 'B': exp = 0; break;; 112 case 'K': exp = 3; break;; 113 case 'M': exp = 6; break;; ",MatchSource.WIKI,doc/master/StringConv_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/StringConv_8hxx_source.html
Deployability,update,updated,"nt) (std::log(bytes) / std::log(unit); 58 // in the case of bytes==unit ends up surprisingly to be zero; 59 // rather than one, so 'hard code' the result; 60 exp = 1;; 61 } else if (bytes > 0) {; 62 exp = std::min( (int) (std::log(bytes) / std::log(unit)),; 63 (int) (sizeof(suffix) / sizeof(suffix[0]) - 1));; 64 }; 65 *coeff = bytes / std::pow(unit, exp);; 66 *units = suffix[exp][!si];; 67}; 68 ; 69enum class EFromHumanReadableSize {; 70 kSuccess,; 71 kParseFail,; 72 kOverflow; 73};; 74 ; 75///////////////////////////////////////////////////////////////////////////////; 76/// Convert strings like the following into byte counts; 77/// 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB; 78/// with some amount of forgiveness baked into the parsing.; 79/// For this routine we use the official SI unit where the [i] is reserved; 80/// for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes.; 81/// \param str the string to be parsed; 82/// \param value will be updated with the result if and only if the parse is successful and does not overflow for the type of value.; 83/// \return return a EFromHumanReadableSize enum value indicating the success or failure of the parse.; 84///; 85template <typename T>; 86EFromHumanReadableSize FromHumanReadableSize(std::string_view str, T &value); 87{; 88 try {; 89 size_t cur, size = str.size();; 90 // Parse leading numeric factor; 91 const double coeff = stod(std::string(str.data(), str.size()), &cur);; 92 ; 93 // Skip any intermediate white space; 94 while (cur<size && isspace(str[cur])) ++cur;; 95 ; 96 // Read off first character which should be an SI prefix; 97 int exp = 0, unit = 1000;; 98 ; 99 auto result = [coeff,&exp,&unit,&value]() {; 100 double v = exp ? coeff * std::pow(unit, exp / 3) : coeff;; 101 if (v < (double) std::numeric_limits<T>::max()) {; 102 value = (T)v;; 103 return EFromHumanReadableSize::kSuccess;; 104 } else {; 105 return EFromHumanReadableSize::kOverflow;; 106 }; 107 };; 108 if (cur==size) return re",MatchSource.WIKI,doc/master/StringConv_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/StringConv_8hxx_source.html
Energy Efficiency,power,power,"B"" },; 51 { ""ZB"", ""ZiB"" },; 52 { ""YB"", ""YiB"" } };; 53 value_type unit = si ? 1000 : 1024;; 54 int exp = 0;; 55 if (bytes == unit) {; 56 // On some 32bit platforms, the result of; 57 // (int) (std::log(bytes) / std::log(unit); 58 // in the case of bytes==unit ends up surprisingly to be zero; 59 // rather than one, so 'hard code' the result; 60 exp = 1;; 61 } else if (bytes > 0) {; 62 exp = std::min( (int) (std::log(bytes) / std::log(unit)),; 63 (int) (sizeof(suffix) / sizeof(suffix[0]) - 1));; 64 }; 65 *coeff = bytes / std::pow(unit, exp);; 66 *units = suffix[exp][!si];; 67}; 68 ; 69enum class EFromHumanReadableSize {; 70 kSuccess,; 71 kParseFail,; 72 kOverflow; 73};; 74 ; 75///////////////////////////////////////////////////////////////////////////////; 76/// Convert strings like the following into byte counts; 77/// 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB; 78/// with some amount of forgiveness baked into the parsing.; 79/// For this routine we use the official SI unit where the [i] is reserved; 80/// for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes.; 81/// \param str the string to be parsed; 82/// \param value will be updated with the result if and only if the parse is successful and does not overflow for the type of value.; 83/// \return return a EFromHumanReadableSize enum value indicating the success or failure of the parse.; 84///; 85template <typename T>; 86EFromHumanReadableSize FromHumanReadableSize(std::string_view str, T &value); 87{; 88 try {; 89 size_t cur, size = str.size();; 90 // Parse leading numeric factor; 91 const double coeff = stod(std::string(str.data(), str.size()), &cur);; 92 ; 93 // Skip any intermediate white space; 94 while (cur<size && isspace(str[cur])) ++cur;; 95 ; 96 // Read off first character which should be an SI prefix; 97 int exp = 0, unit = 1000;; 98 ; 99 auto result = [coeff,&exp,&unit,&value]() {; 100 double v = exp ? coeff * std::pow(unit, exp / 3) : coeff;; 101 if (v < (double) std::numeric_lim",MatchSource.WIKI,doc/master/StringConv_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/StringConv_8hxx_source.html
Integrability,rout,routine,"B"" },; 51 { ""ZB"", ""ZiB"" },; 52 { ""YB"", ""YiB"" } };; 53 value_type unit = si ? 1000 : 1024;; 54 int exp = 0;; 55 if (bytes == unit) {; 56 // On some 32bit platforms, the result of; 57 // (int) (std::log(bytes) / std::log(unit); 58 // in the case of bytes==unit ends up surprisingly to be zero; 59 // rather than one, so 'hard code' the result; 60 exp = 1;; 61 } else if (bytes > 0) {; 62 exp = std::min( (int) (std::log(bytes) / std::log(unit)),; 63 (int) (sizeof(suffix) / sizeof(suffix[0]) - 1));; 64 }; 65 *coeff = bytes / std::pow(unit, exp);; 66 *units = suffix[exp][!si];; 67}; 68 ; 69enum class EFromHumanReadableSize {; 70 kSuccess,; 71 kParseFail,; 72 kOverflow; 73};; 74 ; 75///////////////////////////////////////////////////////////////////////////////; 76/// Convert strings like the following into byte counts; 77/// 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB; 78/// with some amount of forgiveness baked into the parsing.; 79/// For this routine we use the official SI unit where the [i] is reserved; 80/// for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes.; 81/// \param str the string to be parsed; 82/// \param value will be updated with the result if and only if the parse is successful and does not overflow for the type of value.; 83/// \return return a EFromHumanReadableSize enum value indicating the success or failure of the parse.; 84///; 85template <typename T>; 86EFromHumanReadableSize FromHumanReadableSize(std::string_view str, T &value); 87{; 88 try {; 89 size_t cur, size = str.size();; 90 // Parse leading numeric factor; 91 const double coeff = stod(std::string(str.data(), str.size()), &cur);; 92 ; 93 // Skip any intermediate white space; 94 while (cur<size && isspace(str[cur])) ++cur;; 95 ; 96 // Read off first character which should be an SI prefix; 97 int exp = 0, unit = 1000;; 98 ; 99 auto result = [coeff,&exp,&unit,&value]() {; 100 double v = exp ? coeff * std::pow(unit, exp / 3) : coeff;; 101 if (v < (double) std::numeric_lim",MatchSource.WIKI,doc/master/StringConv_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/StringConv_8hxx_source.html
Testability,log,log,"/info-stuff/bytecalc.html for example.; 30 ; 31///////////////////////////////////////////////////////////////////////////////; 32/// Return the size expressed in 'human readable' format.; 33/// \param bytes the size in bytes to be converted; 34/// \param si whether to use the SI units or not.; 35/// \param coeff return the size expressed in the new unit.; 36/// \param units return a pointer to the string representation of the new unit; 37template <typename value_type>; 38void ToHumanReadableSize(value_type bytes,; 39 Bool_t si,; 40 Double_t *coeff,; 41 const char **units); 42{; 43 // Static lookup table of byte-based SI units; 44 static const char *const suffix[][2] =; 45 { { ""B"", ""B"" },; 46 { ""KB"", ""KiB"" },; 47 { ""MB"", ""MiB"" },; 48 { ""GB"", ""GiB"" },; 49 { ""TB"", ""TiB"" },; 50 { ""EB"", ""EiB"" },; 51 { ""ZB"", ""ZiB"" },; 52 { ""YB"", ""YiB"" } };; 53 value_type unit = si ? 1000 : 1024;; 54 int exp = 0;; 55 if (bytes == unit) {; 56 // On some 32bit platforms, the result of; 57 // (int) (std::log(bytes) / std::log(unit); 58 // in the case of bytes==unit ends up surprisingly to be zero; 59 // rather than one, so 'hard code' the result; 60 exp = 1;; 61 } else if (bytes > 0) {; 62 exp = std::min( (int) (std::log(bytes) / std::log(unit)),; 63 (int) (sizeof(suffix) / sizeof(suffix[0]) - 1));; 64 }; 65 *coeff = bytes / std::pow(unit, exp);; 66 *units = suffix[exp][!si];; 67}; 68 ; 69enum class EFromHumanReadableSize {; 70 kSuccess,; 71 kParseFail,; 72 kOverflow; 73};; 74 ; 75///////////////////////////////////////////////////////////////////////////////; 76/// Convert strings like the following into byte counts; 77/// 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB; 78/// with some amount of forgiveness baked into the parsing.; 79/// For this routine we use the official SI unit where the [i] is reserved; 80/// for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes.; 81/// \param str the string to be parsed; 82/// \param value will be updated with the result if and onl",MatchSource.WIKI,doc/master/StringConv_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/StringConv_8hxx_source.html
Availability,mask,mask,". ROOT: ColorStruct_t Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; ColorStruct_t Struct Reference. . Definition at line 310 of file GuiTypes.h. Public Attributes; UShort_t fBlue;  blue component (0..65535) ;  ; UShort_t fGreen;  green component (0..65535) ;  ; UShort_t fMask;  mask telling which color components are valid ;  ; ULong_t fPixel;  color pixel value (index in color table) ;  ; UShort_t fRed;  red component (0..65535) ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fBlue. UShort_t ColorStruct_t::fBlue. blue component (0..65535) ; Definition at line 314 of file GuiTypes.h. ◆ fGreen. UShort_t ColorStruct_t::fGreen. green component (0..65535) ; Definition at line 313 of file GuiTypes.h. ◆ fMask. UShort_t ColorStruct_t::fMask. mask telling which color components are valid ; Definition at line 315 of file GuiTypes.h. ◆ fPixel. ULong_t ColorStruct_t::fPixel. color pixel value (index in color table) ; Definition at line 311 of file GuiTypes.h. ◆ fRed. UShort_t ColorStruct_t::fRed. red component (0..65535) ; Definition at line 312 of file GuiTypes.h. Collaboration diagram for ColorStruct_t:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; core/gui/inc/GuiTypes.h. ColorStruct_t. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:35 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structColorStruct__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structColorStruct__t.html
Energy Efficiency,green,green,". ROOT: ColorStruct_t Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; ColorStruct_t Struct Reference. . Definition at line 310 of file GuiTypes.h. Public Attributes; UShort_t fBlue;  blue component (0..65535) ;  ; UShort_t fGreen;  green component (0..65535) ;  ; UShort_t fMask;  mask telling which color components are valid ;  ; ULong_t fPixel;  color pixel value (index in color table) ;  ; UShort_t fRed;  red component (0..65535) ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fBlue. UShort_t ColorStruct_t::fBlue. blue component (0..65535) ; Definition at line 314 of file GuiTypes.h. ◆ fGreen. UShort_t ColorStruct_t::fGreen. green component (0..65535) ; Definition at line 313 of file GuiTypes.h. ◆ fMask. UShort_t ColorStruct_t::fMask. mask telling which color components are valid ; Definition at line 315 of file GuiTypes.h. ◆ fPixel. ULong_t ColorStruct_t::fPixel. color pixel value (index in color table) ; Definition at line 311 of file GuiTypes.h. ◆ fRed. UShort_t ColorStruct_t::fRed. red component (0..65535) ; Definition at line 312 of file GuiTypes.h. Collaboration diagram for ColorStruct_t:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; core/gui/inc/GuiTypes.h. ColorStruct_t. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:35 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structColorStruct__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structColorStruct__t.html
Availability,mask,mask,". ROOT: Event_t Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; Event_t Struct Reference. ; Event structure. ; Definition at line 174 of file GuiTypes.h. Public Attributes; UInt_t fCode;  key or button code ;  ; Int_t fCount;  if non-zero, at least this many more exposes ;  ; Int_t fFormat;  Next fields only used by kClientMessageEvent. ;  ; Handle_t fHandle;  general resource handle (used for atoms or windows) ;  ; UInt_t fHeight;  width and height of exposed area ;  ; Bool_t fSendEvent;  true if event came from SendEvent ;  ; UInt_t fState;  key or button mask ;  ; Time_t fTime;  time event event occurred in ms ;  ; EGEventType fType;  of event (see EGEventType) ;  ; Longptr_t fUser [5];  5 longs can be used by client message events NOTE: only [0], [1] and [2] may be used. ;  ; UInt_t fWidth;  ; Window_t fWindow;  window reported event is relative to ;  ; Int_t fX;  ; Int_t fXRoot;  ; Int_t fY;  pointer x, y coordinates in event window ;  ; Int_t fYRoot;  coordinates relative to root ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fCode. UInt_t Event_t::fCode. key or button code ; Definition at line 180 of file GuiTypes.h. ◆ fCount. Int_t Event_t::fCount. if non-zero, at least this many more exposes ; Definition at line 183 of file GuiTypes.h. ◆ fFormat. Int_t Event_t::fFormat. Next fields only used by kClientMessageEvent. ; Definition at line 186 of file GuiTypes.h. ◆ fHandle. Handle_t Event_t::fHandle. general resource handle (used for atoms or windows) ; Definition at line 185 of file GuiTypes.h. ◆ fHeight. UInt_t Event_t::fHeight. width and height of exposed area ; Definition at line 182 of file GuiTypes.h. ◆ fSendEvent. Bool_t Event_t::fSendEvent. true if event came from SendEvent ; Definition at line 184 of file GuiTypes.h. ◆ fState. UInt_t Event_t::fState. key or button mask ; Definition at line 181 of file GuiTypes.h. ◆ fTime. Time_t",MatchSource.WIKI,doc/master/structEvent__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structEvent__t.html
Integrability,message,message,". ROOT: Event_t Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; Event_t Struct Reference. ; Event structure. ; Definition at line 174 of file GuiTypes.h. Public Attributes; UInt_t fCode;  key or button code ;  ; Int_t fCount;  if non-zero, at least this many more exposes ;  ; Int_t fFormat;  Next fields only used by kClientMessageEvent. ;  ; Handle_t fHandle;  general resource handle (used for atoms or windows) ;  ; UInt_t fHeight;  width and height of exposed area ;  ; Bool_t fSendEvent;  true if event came from SendEvent ;  ; UInt_t fState;  key or button mask ;  ; Time_t fTime;  time event event occurred in ms ;  ; EGEventType fType;  of event (see EGEventType) ;  ; Longptr_t fUser [5];  5 longs can be used by client message events NOTE: only [0], [1] and [2] may be used. ;  ; UInt_t fWidth;  ; Window_t fWindow;  window reported event is relative to ;  ; Int_t fX;  ; Int_t fXRoot;  ; Int_t fY;  pointer x, y coordinates in event window ;  ; Int_t fYRoot;  coordinates relative to root ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fCode. UInt_t Event_t::fCode. key or button code ; Definition at line 180 of file GuiTypes.h. ◆ fCount. Int_t Event_t::fCount. if non-zero, at least this many more exposes ; Definition at line 183 of file GuiTypes.h. ◆ fFormat. Int_t Event_t::fFormat. Next fields only used by kClientMessageEvent. ; Definition at line 186 of file GuiTypes.h. ◆ fHandle. Handle_t Event_t::fHandle. general resource handle (used for atoms or windows) ; Definition at line 185 of file GuiTypes.h. ◆ fHeight. UInt_t Event_t::fHeight. width and height of exposed area ; Definition at line 182 of file GuiTypes.h. ◆ fSendEvent. Bool_t Event_t::fSendEvent. true if event came from SendEvent ; Definition at line 184 of file GuiTypes.h. ◆ fState. UInt_t Event_t::fState. key or button mask ; Definition at line 181 of file GuiTypes.h. ◆ fTime. Time_t",MatchSource.WIKI,doc/master/structEvent__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structEvent__t.html
Security,expose,exposes,". ROOT: Event_t Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; Event_t Struct Reference. ; Event structure. ; Definition at line 174 of file GuiTypes.h. Public Attributes; UInt_t fCode;  key or button code ;  ; Int_t fCount;  if non-zero, at least this many more exposes ;  ; Int_t fFormat;  Next fields only used by kClientMessageEvent. ;  ; Handle_t fHandle;  general resource handle (used for atoms or windows) ;  ; UInt_t fHeight;  width and height of exposed area ;  ; Bool_t fSendEvent;  true if event came from SendEvent ;  ; UInt_t fState;  key or button mask ;  ; Time_t fTime;  time event event occurred in ms ;  ; EGEventType fType;  of event (see EGEventType) ;  ; Longptr_t fUser [5];  5 longs can be used by client message events NOTE: only [0], [1] and [2] may be used. ;  ; UInt_t fWidth;  ; Window_t fWindow;  window reported event is relative to ;  ; Int_t fX;  ; Int_t fXRoot;  ; Int_t fY;  pointer x, y coordinates in event window ;  ; Int_t fYRoot;  coordinates relative to root ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fCode. UInt_t Event_t::fCode. key or button code ; Definition at line 180 of file GuiTypes.h. ◆ fCount. Int_t Event_t::fCount. if non-zero, at least this many more exposes ; Definition at line 183 of file GuiTypes.h. ◆ fFormat. Int_t Event_t::fFormat. Next fields only used by kClientMessageEvent. ; Definition at line 186 of file GuiTypes.h. ◆ fHandle. Handle_t Event_t::fHandle. general resource handle (used for atoms or windows) ; Definition at line 185 of file GuiTypes.h. ◆ fHeight. UInt_t Event_t::fHeight. width and height of exposed area ; Definition at line 182 of file GuiTypes.h. ◆ fSendEvent. Bool_t Event_t::fSendEvent. true if event came from SendEvent ; Definition at line 184 of file GuiTypes.h. ◆ fState. UInt_t Event_t::fState. key or button mask ; Definition at line 181 of file GuiTypes.h. ◆ fTime. Time_t",MatchSource.WIKI,doc/master/structEvent__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structEvent__t.html
Availability,mask,mask,". master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; GCValues_t Struct Reference. ; Graphics context structure. ; Definition at line 224 of file GuiTypes.h. Public Member Functions;  GCValues_t ();  . Public Attributes; Int_t fArcMode;  kArcChord, kArcPieSlice ;  ; ULong_t fBackground;  background pixel ;  ; Int_t fCapStyle;  kCapNotLast, kCapButt, kCapRound, kCapProjecting ;  ; Pixmap_t fClipMask;  bitmap clipping; other calls for rects ;  ; Int_t fClipXOrigin;  origin for clipping ;  ; Int_t fClipYOrigin;  ; Char_t fDashes [8];  dash pattern list (dash length per byte) ;  ; Int_t fDashLen;  number of dashes in fDashes ;  ; Int_t fDashOffset;  patterned/dashed line information ;  ; Int_t fFillRule;  kEvenOddRule, kWindingRule ;  ; Int_t fFillStyle;  kFillSolid, kFillTiled, kFillStippled, kFillOpaeueStippled ;  ; FontH_t fFont;  default text font for text operations ;  ; ULong_t fForeground;  foreground pixel ;  ; EGraphicsFunction fFunction;  logical operation ;  ; Bool_t fGraphicsExposures;  boolean, should exposures be generated ;  ; Int_t fJoinStyle;  kJoinMiter, kJoinRound, kJoinBevel ;  ; Int_t fLineStyle;  kLineSolid, kLineOnOffDash, kLineDoubleDash ;  ; Int_t fLineWidth;  line width ;  ; Mask_t fMask;  bit mask specifying which fields are valid ;  ; ULong_t fPlaneMask;  plane mask ;  ; Pixmap_t fStipple;  stipple 1 plane pixmap for stippling ;  ; Int_t fSubwindowMode;  kClipByChildren, kIncludeInferiors ;  ; Pixmap_t fTile;  tile pixmap for tiling operations ;  ; Int_t fTsXOrigin;  offset for tile or stipple operations ;  ; Int_t fTsYOrigin;  . #include <GuiTypes.h>; Constructor & Destructor Documentation. ◆ GCValues_t(). GCValues_t::GCValues_t ; (; ). inline . Definition at line 253 of file GuiTypes.h. Member Data Documentation. ◆ fArcMode. Int_t GCValues_t::fArcMode. kArcChord, kArcPieSlice ; Definition at line 237 of file GuiTypes.h. ◆ fBackgroun",MatchSource.WIKI,doc/master/structGCValues__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structGCValues__t.html
Testability,log,logical,". master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; GCValues_t Struct Reference. ; Graphics context structure. ; Definition at line 224 of file GuiTypes.h. Public Member Functions;  GCValues_t ();  . Public Attributes; Int_t fArcMode;  kArcChord, kArcPieSlice ;  ; ULong_t fBackground;  background pixel ;  ; Int_t fCapStyle;  kCapNotLast, kCapButt, kCapRound, kCapProjecting ;  ; Pixmap_t fClipMask;  bitmap clipping; other calls for rects ;  ; Int_t fClipXOrigin;  origin for clipping ;  ; Int_t fClipYOrigin;  ; Char_t fDashes [8];  dash pattern list (dash length per byte) ;  ; Int_t fDashLen;  number of dashes in fDashes ;  ; Int_t fDashOffset;  patterned/dashed line information ;  ; Int_t fFillRule;  kEvenOddRule, kWindingRule ;  ; Int_t fFillStyle;  kFillSolid, kFillTiled, kFillStippled, kFillOpaeueStippled ;  ; FontH_t fFont;  default text font for text operations ;  ; ULong_t fForeground;  foreground pixel ;  ; EGraphicsFunction fFunction;  logical operation ;  ; Bool_t fGraphicsExposures;  boolean, should exposures be generated ;  ; Int_t fJoinStyle;  kJoinMiter, kJoinRound, kJoinBevel ;  ; Int_t fLineStyle;  kLineSolid, kLineOnOffDash, kLineDoubleDash ;  ; Int_t fLineWidth;  line width ;  ; Mask_t fMask;  bit mask specifying which fields are valid ;  ; ULong_t fPlaneMask;  plane mask ;  ; Pixmap_t fStipple;  stipple 1 plane pixmap for stippling ;  ; Int_t fSubwindowMode;  kClipByChildren, kIncludeInferiors ;  ; Pixmap_t fTile;  tile pixmap for tiling operations ;  ; Int_t fTsXOrigin;  offset for tile or stipple operations ;  ; Int_t fTsYOrigin;  . #include <GuiTypes.h>; Constructor & Destructor Documentation. ◆ GCValues_t(). GCValues_t::GCValues_t ; (; ). inline . Definition at line 253 of file GuiTypes.h. Member Data Documentation. ◆ fArcMode. Int_t GCValues_t::fArcMode. kArcChord, kArcPieSlice ; Definition at line 237 of file GuiTypes.h. ◆ fBackgroun",MatchSource.WIKI,doc/master/structGCValues__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structGCValues__t.html
Availability,mask,mask,. ROOT: PictureAttributes_t Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; PictureAttributes_t Struct Reference. . Definition at line 323 of file GuiTypes.h. Public Attributes; UInt_t fCloseness;  allowable RGB deviation ;  ; Colormap_t fColormap;  colormap to use ;  ; Int_t fDepth;  depth of window ;  ; UInt_t fHeight;  height of picture ;  ; Mask_t fMask;  mask specifying which attributes are defined ;  ; UInt_t fNpixels;  number of used color pixels ;  ; ULong_t * fPixels;  list of used color pixels (if set use delete[]) ;  ; UInt_t fWidth;  width of picture ;  ; UInt_t fXHotspot;  picture x hotspot coordinate ;  ; UInt_t fYHotspot;  picture y hotspot coordinate ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fCloseness. UInt_t PictureAttributes_t::fCloseness. allowable RGB deviation ; Definition at line 332 of file GuiTypes.h. ◆ fColormap. Colormap_t PictureAttributes_t::fColormap. colormap to use ; Definition at line 324 of file GuiTypes.h. ◆ fDepth. Int_t PictureAttributes_t::fDepth. depth of window ; Definition at line 325 of file GuiTypes.h. ◆ fHeight. UInt_t PictureAttributes_t::fHeight. height of picture ; Definition at line 327 of file GuiTypes.h. ◆ fMask. Mask_t PictureAttributes_t::fMask. mask specifying which attributes are defined ; Definition at line 333 of file GuiTypes.h. ◆ fNpixels. UInt_t PictureAttributes_t::fNpixels. number of used color pixels ; Definition at line 331 of file GuiTypes.h. ◆ fPixels. ULong_t* PictureAttributes_t::fPixels. list of used color pixels (if set use delete[]) ; Definition at line 330 of file GuiTypes.h. ◆ fWidth. UInt_t PictureAttributes_t::fWidth. width of picture ; Definition at line 326 of file GuiTypes.h. ◆ fXHotspot. UInt_t PictureAttributes_t::fXHotspot. picture x hotspot coordinate ; Definition at line 328 of file GuiTypes.h. ◆ fYHotspot. UInt_t PictureAttributes_t::fYHotspot. picture y h,MatchSource.WIKI,doc/master/structPictureAttributes__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structPictureAttributes__t.html
Performance,cache,cache,". ROOT: RooAbsArg::ProxyListCache Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; RooAbsArg::ProxyListCache Struct Reference. . Definition at line 660 of file RooAbsArg.h. Public Attributes; std::vector< RooAbsProxy * > cache;  ; bool isDirty = true;  . #include <RooAbsArg.h>; Member Data Documentation. ◆ cache. std::vector<RooAbsProxy*> RooAbsArg::ProxyListCache::cache. Definition at line 661 of file RooAbsArg.h. ◆ isDirty. bool RooAbsArg::ProxyListCache::isDirty = true. Definition at line 662 of file RooAbsArg.h. Collaboration diagram for RooAbsArg::ProxyListCache:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; roofit/roofitcore/inc/RooAbsArg.h. RooAbsArgProxyListCache. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:38 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structRooAbsArg_1_1ProxyListCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooAbsArg_1_1ProxyListCache.html
Availability,error,errorFR,". ROOT: RooAbsReal::PlotOpt Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; RooAbsReal::PlotOpt Struct Reference. . Definition at line 463 of file RooAbsReal.h. Public Attributes; const char * addToCurveName = nullptr;  ; double addToWgtOther = 1.0;  ; double addToWgtSelf = 1.0;  ; bool binProjData = false;  ; bool curveInvisible = false;  ; const char * curveName = nullptr;  ; const char * curveNameSuffix = """";  ; bool doeeval = false;  ; Option_t * drawOptions = ""L"";  ; double eeval = 0.0;  ; const RooFitResult * errorFR = nullptr;  ; RooFit::MPSplit interleave = RooFit::Interleave;  ; const char * normRangeName = nullptr;  ; Int_t numCPU = 1;  ; Int_t numee = 10;  ; bool postRangeFracScale = false;  ; double precision = 1e-3;  ; bool progress = false;  ; const RooAbsData * projData = nullptr;  ; const RooArgSet * projDataSet = nullptr;  ; const char * projectionRangeName = nullptr;  ; const RooArgSet * projSet = nullptr;  ; double rangeHi = 0.0;  ; double rangeLo = 0.0;  ; double scaleFactor = 1.0;  ; bool shiftToZero = false;  ; ScaleType stype = Relative;  ; RooCurve::WingMode wmode = RooCurve::Extended;  . #include <RooAbsReal.h>; Member Data Documentation. ◆ addToCurveName. const char* RooAbsReal::PlotOpt::addToCurveName = nullptr. Definition at line 481 of file RooAbsReal.h. ◆ addToWgtOther. double RooAbsReal::PlotOpt::addToWgtOther = 1.0. Definition at line 483 of file RooAbsReal.h. ◆ addToWgtSelf. double RooAbsReal::PlotOpt::addToWgtSelf = 1.0. Definition at line 482 of file RooAbsReal.h. ◆ binProjData. bool RooAbsReal::PlotOpt::binProjData = false. Definition at line 468 of file RooAbsReal.h. ◆ curveInvisible. bool RooAbsReal::PlotOpt::curveInvisible = false. Definition at line 479 of file RooAbsReal.h. ◆ curveName. const char* RooAbsReal::PlotOpt::curveName = nullptr. Definition at line 480 of file RooAbsReal.h. ◆ curveNameSuffix. const cha",MatchSource.WIKI,doc/master/structRooAbsReal_1_1PlotOpt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooAbsReal_1_1PlotOpt.html
Modifiability,enhance,enhance,. ROOT: RooFit::UniqueId< Class > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Static Public Attributes |; Private Member Functions |; Private Attributes |; Static Private Attributes |; List of all members ; RooFit::UniqueId< Class > Struct Template Reference. ; template<class Class>; struct RooFit::UniqueId< Class >A UniqueId can be added as a class member to enhance any class with a unique identifier for each instantiated object. ; Example: class MyClass {; ; public:; /// Return unique ID by reference.; /// Please always use the name `uniqueId` for the getter.; UniqueId<MyClass> const& uniqueId() const { return _uniqueId; }; ; private:; const UniqueId<MyClass> _uniqueId; //! should be non-persistent; ; };; RooFit::UniqueIdA UniqueId can be added as a class member to enhance any class with a unique identifier for each inst...Definition UniqueId.h:39. Definition at line 39 of file UniqueId.h. Public Types; using Value_t = unsigned long;  . Public Member Functions;  UniqueId ();  Create a new UniqueId with the next value from the static counter. ;  ;  UniqueId (const UniqueId &)=delete;  ;  UniqueId (UniqueId &&)=delete;  ;  operator Value_t () const;  ; bool operator< (UniqueId const &other) const;  ; UniqueId & operator= (const UniqueId &)=delete;  ; UniqueId & operator= (UniqueId &&)=delete;  ; bool operator== (UniqueId const &other) const;  ; constexpr Value_t value () const;  Return numerical value of ID. ;  . Static Public Member Functions; static UniqueId const & nullid ();  Get an ID that is less than the ID of any object (similar to nullptr). ;  . Static Public Attributes; static constexpr Value_t nullval = 0UL;  The value of the nullid. ;  . Private Member Functions;  UniqueId (Value_t val);  . Private Attributes; Value_t _val;  Numerical value of the ID. ;  . Static Private Attributes; static std:,MatchSource.WIKI,doc/master/structRooFit_1_1UniqueId.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooFit_1_1UniqueId.html
Availability,error,error,"object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Return",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
Integrability,message,message,"object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Return",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
Modifiability,inherit,inherited,". ROOT: RooHelpers::WrapIntoTObject< T > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; RooHelpers::WrapIntoTObject< T > Struct Template Reference. ; template<typename T>; struct RooHelpers::WrapIntoTObject< T >Wrap an object into a TObject. Sometimes needed to avoid reinterpret_cast or enable RTTI. ; Definition at line 57 of file RooHelpers.h. Public Member Functions;  WrapIntoTObject (T &obj);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
Safety,avoid,avoid,". ROOT: RooHelpers::WrapIntoTObject< T > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; RooHelpers::WrapIntoTObject< T > Struct Template Reference. ; template<typename T>; struct RooHelpers::WrapIntoTObject< T >Wrap an object into a TObject. Sometimes needed to avoid reinterpret_cast or enable RTTI. ; Definition at line 57 of file RooHelpers.h. Public Member Functions;  WrapIntoTObject (T &obj);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
Security,hash,hash," Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; virtual TClass * IsA () const;  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other obje",MatchSource.WIKI,doc/master/structRooHelpers_1_1WrapIntoTObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structRooHelpers_1_1WrapIntoTObject.html
Modifiability,inherit,inherited,". ROOT: ROOT::Detail::TCollectionProxyInfo::Environ< T > Class Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Public Attributes |; List of all members ; ROOT::Detail::TCollectionProxyInfo::Environ< T > Class Template Reference. ; template<typename T>; class ROOT::Detail::TCollectionProxyInfo::Environ< T >Small helper to save proxy environment in the event of recursive calls. ; AuthorM.Frank ; Version1.0 ; Date10/10/2004 ; Definition at line 244 of file TCollectionProxyInfo.h. Public Types; typedef T Iter_t;  . Public Member Functions;  Environ ();  ; T & iter ();  ;  Public Member Functions inherited from ROOT::Detail::TCollectionProxyInfo::EnvironBase;  EnvironBase ();  ; virtual ~EnvironBase ();  . Static Public Member Functions; static void * Create ();  . Public Attributes; Iter_t fIterator;  ;  Public Attributes inherited from ROOT::Detail::TCollectionProxyInfo::EnvironBase; union { ;  ;    Bool_t   fLastValueVecBool ;  ;    Bool_t   fUseTemp ;  ; };  ;  ; size_t fIdx;  ; void * fObject;  ; int fRefCount;  ; size_t fSize;  ; size_t fSpace;  ; void * fStart;  ; void * fTemp;  . #include <TCollectionProxyInfo.h>. Inheritance diagram for ROOT::Detail::TCollectionProxyInfo::Environ< T >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ Iter_t. template<typename T > . typedef T ROOT::Detail::TCollectionProxyInfo::Environ< T >::Iter_t. Definition at line 246 of file TCollectionProxyInfo.h. Constructor & Destructor Documentation. ◆ Environ(). template<typename T > . ROOT::Detail::TCollectionProxyInfo::Environ< T >::Environ ; (; ). inline . Definition at line 245 of file TCollectionProxyInfo.h. Member Function Documentation. ◆ Create(). template<typename T > . static void * ROOT::Detail::TCollectionProxyInfo::Environ< T >::Create ; (; ). in",MatchSource.WIKI,doc/master/structROOT_1_1Detail_1_1TCollectionProxyInfo_1_1Environ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Detail_1_1TCollectionProxyInfo_1_1Environ.html
Modifiability,inherit,inherited,". ROOT: ROOT::Experimental::RNTupleImporter::RCStringTransformation Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; List of all members ; ROOT::Experimental::RNTupleImporter::RCStringTransformation Struct Reference. ; Transform a NULL terminated C string branch into an std::string field. ; Definition at line 196 of file RNTupleImporter.hxx. Public Member Functions;  RCStringTransformation (std::size_t b, std::size_t f);  ;  ~RCStringTransformation () override=default;  ; RResult< void > Transform (const RImportBranch &branch, RImportField &field) final;  ;  Public Member Functions inherited from ROOT::Experimental::RNTupleImporter::RImportTransformation;  RImportTransformation (std::size_t branchIdx, std::size_t fieldIdx);  ; virtual ~RImportTransformation ()=default;  . Additional Inherited Members;  Public Attributes inherited from ROOT::Experimental::RNTupleImporter::RImportTransformation; std::size_t fImportBranchIdx = 0;  ; std::size_t fImportFieldIdx = 0;  . Inheritance diagram for ROOT::Experimental::RNTupleImporter::RCStringTransformation:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RCStringTransformation(). ROOT::Experimental::RNTupleImporter::RCStringTransformation::RCStringTransformation ; (; std::size_t ; b, . std::size_t ; f . ). inline . Definition at line 197 of file RNTupleImporter.hxx. ◆ ~RCStringTransformation(). ROOT::Experimental::RNTupleImporter::RCStringTransformation::~RCStringTransformation ; (; ). overridedefault . Member Function Documentation. ◆ Transform(). ROOT::Experimental::RResult< void > ROOT::Experimental::RNTupleImporter::RCStringTransformation::Transform ; (; const RImportBranch & ; branch, . RImportField & ; field . ). finalvirtual . Implements ROOT::Experimental::RNTupleImporter::RImportTransformation.; Definition at line 73 of file RNTu",MatchSource.WIKI,doc/master/structROOT_1_1Experimental_1_1RNTupleImporter_1_1RCStringTransformation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Experimental_1_1RNTupleImporter_1_1RCStringTransformation.html
Performance,perform,perform,". ROOT: ROOT::Experimental::RNTupleImporter::RImportTransformation Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::Experimental::RNTupleImporter::RImportTransformation Struct Referenceabstract. ; Base class to perform data transformations from TTree branches to RNTuple fields if necessary. ; Definition at line 146 of file RNTupleImporter.hxx. Public Member Functions;  RImportTransformation (std::size_t branchIdx, std::size_t fieldIdx);  ; virtual ~RImportTransformation ()=default;  ; virtual RResult< void > Transform (const RImportBranch &branch, RImportField &field)=0;  . Public Attributes; std::size_t fImportBranchIdx = 0;  ; std::size_t fImportFieldIdx = 0;  . Inheritance diagram for ROOT::Experimental::RNTupleImporter::RImportTransformation:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RImportTransformation(). ROOT::Experimental::RNTupleImporter::RImportTransformation::RImportTransformation ; (; std::size_t ; branchIdx, . std::size_t ; fieldIdx . ). inline . Definition at line 150 of file RNTupleImporter.hxx. ◆ ~RImportTransformation(). virtual ROOT::Experimental::RNTupleImporter::RImportTransformation::~RImportTransformation ; (; ). virtualdefault . Member Function Documentation. ◆ Transform(). virtual RResult< void > ROOT::Experimental::RNTupleImporter::RImportTransformation::Transform ; (; const RImportBranch & ; branch, . RImportField & ; field . ). pure virtual . Implemented in ROOT::Experimental::RNTupleImporter::RCStringTransformation. Member Data Documentation. ◆ fImportBranchIdx. std::size_t ROOT::Experimental::RNTupleImporter::RImportTransformation::fImportBranchIdx = 0. Definition at line 147 of file RNTupleImporter.hxx. ◆ fImportFieldIdx. std::size_t ROOT::Experimental::RNTupleImporter::RImportTransformation::fI",MatchSource.WIKI,doc/master/structROOT_1_1Experimental_1_1RNTupleImporter_1_1RImportTransformation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Experimental_1_1RNTupleImporter_1_1RImportTransformation.html
Modifiability,inherit,inherited,". ROOT: Member List. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ROOT::Fit::DataOptions Member List. This is the complete list of members for ROOT::Fit::DataOptions, including all inherited members. DataOptions()ROOT::Fit::DataOptionsinline; fAsymErrorsROOT::Fit::DataOptions; fBinVolumeROOT::Fit::DataOptions; fCoordErrorsROOT::Fit::DataOptions; fErrors1ROOT::Fit::DataOptions; fExpErrorsROOT::Fit::DataOptions; fIntegralROOT::Fit::DataOptions; fNormBinVolumeROOT::Fit::DataOptions; fUseEmptyROOT::Fit::DataOptions; fUseRangeROOT::Fit::DataOptions. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:15 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1Fit_1_1DataOptions-members.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions-members.html
Availability,error,errors,". ROOT: ROOT::Fit::DataOptions Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::Fit::DataOptions Struct ReferenceMath » MathCore » Fitting and Parameter Estimation » Fit Data Classes. ; DataOptions : simple structure holding the options on how the data are filled. ; Definition at line 28 of file DataOptions.h. Public Member Functions;  DataOptions ();  Default constructor: use the default options. ;  . Public Attributes; bool fAsymErrors;  use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ;  ; bool fBinVolume;  normalize data by the bin volume (it is used in the Poisson likelihood fits) ;  ; bool fCoordErrors;  use errors on the x coordinates when available (default is true) ;  ; bool fErrors1;  use all errors equal to 1, i.e. fit without errors (default is false) ;  ; bool fExpErrors;  use expected errors from the function and not from the data ;  ; bool fIntegral;  use integral of bin content instead of bin center (default is false) ;  ; bool fNormBinVolume;  normalize data by a normalized the bin volume (bin volume divided by a reference value) ;  ; bool fUseEmpty;  use empty bins (default is false) with a fixed error of 1 ;  ; bool fUseRange;  use the function range when creating the fit data (default is false) ;  . #include <Fit/DataOptions.h>; Constructor & Destructor Documentation. ◆ DataOptions(). ROOT::Fit::DataOptions::DataOptions ; (; ). inline . Default constructor: use the default options. ; Definition at line 34 of file DataOptions.h. Member Data Documentation. ◆ fAsymErrors. bool ROOT::Fit::DataOptions::fAsymErrors. use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ; Definition at line 55 of file DataOptions.h. ◆ fBinVolume. bool ROOT::Fit::DataOptions::fBinVolume. n",MatchSource.WIKI,doc/master/structROOT_1_1Fit_1_1DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html
Usability,simpl,simple,". ROOT: ROOT::Fit::DataOptions Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::Fit::DataOptions Struct ReferenceMath » MathCore » Fitting and Parameter Estimation » Fit Data Classes. ; DataOptions : simple structure holding the options on how the data are filled. ; Definition at line 28 of file DataOptions.h. Public Member Functions;  DataOptions ();  Default constructor: use the default options. ;  . Public Attributes; bool fAsymErrors;  use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ;  ; bool fBinVolume;  normalize data by the bin volume (it is used in the Poisson likelihood fits) ;  ; bool fCoordErrors;  use errors on the x coordinates when available (default is true) ;  ; bool fErrors1;  use all errors equal to 1, i.e. fit without errors (default is false) ;  ; bool fExpErrors;  use expected errors from the function and not from the data ;  ; bool fIntegral;  use integral of bin content instead of bin center (default is false) ;  ; bool fNormBinVolume;  normalize data by a normalized the bin volume (bin volume divided by a reference value) ;  ; bool fUseEmpty;  use empty bins (default is false) with a fixed error of 1 ;  ; bool fUseRange;  use the function range when creating the fit data (default is false) ;  . #include <Fit/DataOptions.h>; Constructor & Destructor Documentation. ◆ DataOptions(). ROOT::Fit::DataOptions::DataOptions ; (; ). inline . Default constructor: use the default options. ; Definition at line 34 of file DataOptions.h. Member Data Documentation. ◆ fAsymErrors. bool ROOT::Fit::DataOptions::fAsymErrors. use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true) ; Definition at line 55 of file DataOptions.h. ◆ fBinVolume. bool ROOT::Fit::DataOptions::fBinVolume. n",MatchSource.WIKI,doc/master/structROOT_1_1Fit_1_1DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Fit_1_1DataOptions.html
Energy Efficiency,allocate,allocate,. ROOT: ROOT::Internal::VecOps::RVecInlineStorageSize< T > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Attributes |; Static Private Attributes |; List of all members ; ROOT::Internal::VecOps::RVecInlineStorageSize< T > Struct Template Reference. ; template<typename T>; struct ROOT::Internal::VecOps::RVecInlineStorageSize< T >The size of the inline storage of an RVec. ; Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline) unless the size of the buffer with 8 elements would be over a certain maximum size. ; Definition at line 512 of file RVec.hxx. Static Public Attributes; static constexpr unsigned value;  . Static Private Attributes; static constexpr std::size_t cacheLineSize = 64;  ; static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);  ; static constexpr unsigned maxInlineByteSize = 1024;  . #include <ROOT/RVec.hxx>; Member Data Documentation. ◆ cacheLineSize. template<typename T > . constexpr std::size_t ROOT::Internal::VecOps::RVecInlineStorageSize< T >::cacheLineSize = 64. staticconstexprprivate . Definition at line 518 of file RVec.hxx. ◆ elementsPerCacheLine. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T). staticconstexprprivate . Definition at line 520 of file RVec.hxx. ◆ maxInlineByteSize. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::maxInlineByteSize = 1024. staticconstexprprivate . Definition at line 521 of file RVec.hxx. ◆ value. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::value. staticconstexpr . Initial value:=; elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8); ROOT::Internal::VecOps::RVecInlineStorag,MatchSource.WIKI,doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html
Performance,cache,cacheline,. ROOT: ROOT::Internal::VecOps::RVecInlineStorageSize< T > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Attributes |; Static Private Attributes |; List of all members ; ROOT::Internal::VecOps::RVecInlineStorageSize< T > Struct Template Reference. ; template<typename T>; struct ROOT::Internal::VecOps::RVecInlineStorageSize< T >The size of the inline storage of an RVec. ; Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline) unless the size of the buffer with 8 elements would be over a certain maximum size. ; Definition at line 512 of file RVec.hxx. Static Public Attributes; static constexpr unsigned value;  . Static Private Attributes; static constexpr std::size_t cacheLineSize = 64;  ; static constexpr unsigned elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T);  ; static constexpr unsigned maxInlineByteSize = 1024;  . #include <ROOT/RVec.hxx>; Member Data Documentation. ◆ cacheLineSize. template<typename T > . constexpr std::size_t ROOT::Internal::VecOps::RVecInlineStorageSize< T >::cacheLineSize = 64. staticconstexprprivate . Definition at line 518 of file RVec.hxx. ◆ elementsPerCacheLine. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::elementsPerCacheLine = (cacheLineSize - sizeof(SmallVectorBase)) / sizeof(T). staticconstexprprivate . Definition at line 520 of file RVec.hxx. ◆ maxInlineByteSize. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::maxInlineByteSize = 1024. staticconstexprprivate . Definition at line 521 of file RVec.hxx. ◆ value. template<typename T > . constexpr unsigned ROOT::Internal::VecOps::RVecInlineStorageSize< T >::value. staticconstexpr . Initial value:=; elementsPerCacheLine >= 8 ? elementsPerCacheLine : (sizeof(T) * 8 > maxInlineByteSize ? 0 : 8); ROOT::Internal::VecOps::RVecInlineStorag,MatchSource.WIKI,doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Internal_1_1VecOps_1_1RVecInlineStorageSize.html
Availability,error,error,". ROOT: ROOT::Math::Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > > Struct Template Reference. ; template<class T, unsigned int D1, unsigned int D2, class A>; struct ROOT::Math::Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >Dummy Structure which flags an error to avoid assignment from expression based on a general matrix to a symmetric matrix. ; Definition at line 131 of file HelperOps.h. Static Public Member Functions; static void Evaluate (SMatrix< T, D1, D2, MatRepSym< T, D1 > > &, const Expr< A, T, D1, D2, MatRepStd< T, D1, D2 > > &);  . #include <Math/HelperOps.h>; Member Function Documentation. ◆ Evaluate(). template<class T , unsigned int D1, unsigned int D2, class A > . static void ROOT::Math::Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >::Evaluate ; (; SMatrix< T, D1, D2, MatRepSym< T, D1 > > & ; , . const Expr< A, T, D1, D2, MatRepStd< T, D1, D2 > > & ;  . ). inlinestatic . Definition at line 133 of file HelperOps.h. The documentation for this struct was generated from the following file:; math/smatrix/inc/Math/HelperOps.h. ROOTMathAssign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:19 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1Assign_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_00_062d5e865199fb0af80bca6cc0f9059e9.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1Assign_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_00_062d5e865199fb0af80bca6cc0f9059e9.html
Safety,avoid,avoid,". ROOT: ROOT::Math::Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > > Struct Template Reference. ; template<class T, unsigned int D1, unsigned int D2, class A>; struct ROOT::Math::Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >Dummy Structure which flags an error to avoid assignment from expression based on a general matrix to a symmetric matrix. ; Definition at line 131 of file HelperOps.h. Static Public Member Functions; static void Evaluate (SMatrix< T, D1, D2, MatRepSym< T, D1 > > &, const Expr< A, T, D1, D2, MatRepStd< T, D1, D2 > > &);  . #include <Math/HelperOps.h>; Member Function Documentation. ◆ Evaluate(). template<class T , unsigned int D1, unsigned int D2, class A > . static void ROOT::Math::Assign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >::Evaluate ; (; SMatrix< T, D1, D2, MatRepSym< T, D1 > > & ; , . const Expr< A, T, D1, D2, MatRepStd< T, D1, D2 > > & ;  . ). inlinestatic . Definition at line 133 of file HelperOps.h. The documentation for this struct was generated from the following file:; math/smatrix/inc/Math/HelperOps.h. ROOTMathAssign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:19 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1Assign_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_00_062d5e865199fb0af80bca6cc0f9059e9.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1Assign_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_00_062d5e865199fb0af80bca6cc0f9059e9.html
Modifiability,inherit,inherited,". ROOT: ROOT::Math::CDFWrapper Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::Math::CDFWrapper Struct Reference. . Definition at line 40 of file GoFTest.cxx. Public Member Functions;  CDFWrapper (const IGenFunction &cdf, Double_t xmin=0, Double_t xmax=-1);  ;  ~CDFWrapper () override;  ; IGenFunction * Clone () const override;  Clone a function. ;  ; Double_t DoEval (Double_t x) const override;  implementation of the evaluation function. Must be implemented by derived classes ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionOneDim; virtual ~IBaseFunctionOneDim ()=default;  ; virtual bool HasGradient () const;  ; double operator() (const double *x) const;  Evaluate the function at a point x[]. ;  ; double operator() (double x) const;  Evaluate the function at a point x. ;  . Public Attributes; const IGenFunction * fCDF;  ; Double_t fNorm;  ; Double_t fXmax;  ; Double_t fXmin;  . Additional Inherited Members;  Public Types inherited from ROOT::Math::IBaseFunctionOneDim; typedef IBaseFunctionOneDim BaseFunc;  . Inheritance diagram for ROOT::Math::CDFWrapper:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ~CDFWrapper(). ROOT::Math::CDFWrapper::~CDFWrapper ; (; ). inlineoverride . Definition at line 48 of file GoFTest.cxx. ◆ CDFWrapper(). ROOT::Math::CDFWrapper::CDFWrapper ; (; const IGenFunction & ; cdf, . Double_t ; xmin = 0, . Double_t ; xmax = -1 . ). inline . Definition at line 50 of file GoFTest.cxx. Member Function Documentation. ◆ Clone(). IGenFunction * ROOT::Math::CDFWrapper::Clone ; (; ); const. inlineoverridevirtual . Clone a function. ; Each derived class will implement their version of the private DoClone method. ; Implements ROOT::Math::IBaseFunctionOneDim.; Definition at line 71 of file GoFTest.cx",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1CDFWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1CDFWrapper.html
Availability,error,error,". ROOT: ROOT::Math::GeneralLinearFunctionDerivation< T > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::GeneralLinearFunctionDerivation< T > Struct Template Reference. ; template<class T>; struct ROOT::Math::GeneralLinearFunctionDerivation< T >Auxiliar class to bypass the (provisional) lack of vectorization in TFormula::EvalPar. ; WrappedMultiTF1Templ::DoParameterDerivation calls TFormula::EvalPar in the case of a general linear function built with TFormula using ++; as EvalPar is not vectorized, in order to generalize DoParameterDerivative with a general type T, we use this auxiliar class to branch the code in compile time with the double specialization (that can call EvalPar) and the general implementation (that throws an error in the case of general linear function). ; Definition at line 203 of file WrappedMultiTF1.h. Static Public Member Functions; static T DoParameterDerivative (const WrappedMultiTF1Templ< T > *, const T *, unsigned int);  . #include <Math/WrappedMultiTF1.h>; Member Function Documentation. ◆ DoParameterDerivative(). template<class T > . static T ROOT::Math::GeneralLinearFunctionDerivation< T >::DoParameterDerivative ; (; const WrappedMultiTF1Templ< T > * ; , . const T * ; , . unsigned int ;  . ). inlinestatic . Definition at line 204 of file WrappedMultiTF1.h. The documentation for this struct was generated from the following file:; hist/hist/inc/Math/WrappedMultiTF1.h. ROOTMathGeneralLinearFunctionDerivation. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1GeneralLinearFunctionDerivation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1GeneralLinearFunctionDerivation.html
Integrability,wrap,wrappedFunc,". ROOT: ROOT::Math::GeneralLinearFunctionDerivation< double > Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::GeneralLinearFunctionDerivation< double > Struct Reference. . Definition at line 214 of file WrappedMultiTF1.h. Static Public Member Functions; static double DoParameterDerivative (const WrappedMultiTF1Templ< double > *wrappedFunc, const double *x, unsigned int ipar);  . #include <Math/WrappedMultiTF1.h>; Member Function Documentation. ◆ DoParameterDerivative(). static double ROOT::Math::GeneralLinearFunctionDerivation< double >::DoParameterDerivative ; (; const WrappedMultiTF1Templ< double > * ; wrappedFunc, . const double * ; x, . unsigned int ; ipar . ). inlinestatic . Definition at line 216 of file WrappedMultiTF1.h. The documentation for this struct was generated from the following file:; hist/hist/inc/Math/WrappedMultiTF1.h. ROOTMathGeneralLinearFunctionDerivation< double >. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1GeneralLinearFunctionDerivation_3_01double_01_4.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1GeneralLinearFunctionDerivation_3_01double_01_4.html
Energy Efficiency,adapt,adapting,". ROOT: ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc > Struct Template ReferenceMath » MathCore | Math » MathMore » Numerical Algorithms » Multi-dimensional Minimization. ; template<class UserFunc>; struct ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MultiMin algorithms. ; The templated C++ function class must implement:; double operator( const double * x) and if the derivatives are required: void Gradient( const double * x, double * g); This class defines static methods with will be used to fill the gsl_multimin_function and gsl_multimin_function_fdf structs used by GSL. See for examples the GSL online manual ; Definition at line 66 of file GSLMultiMinFunctionAdapter.h. Static Public Member Functions; static void Df (const gsl_vector *x, void *p, gsl_vector *g);  ; static double F (const gsl_vector *x, void *p);  ; static void Fdf (const gsl_vector *x, void *p, double *f, gsl_vector *g);  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/math/mathmore/src/GSLMultiMinFunctionAdapter.h>; Member Function Documentation. ◆ Df(). template<class UserFunc > . static void ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >::Df ; (; const gsl_vector * ; x, . void * ; p, . gsl_vector * ; g . ). inlinestatic . Definition at line 76 of file GSLMultiMinFunctionAdapter.h. ◆ F(). template<class UserFunc > . static double ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >::F ; (; const gsl_vector * ; x, . void * ; p . ). inlinestatic . Definition at line 68 of file GSLMultiMinFunctionAdapter.h. ◆ Fdf(). template<class UserFunc > . static void ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >::Fdf ; (; const gsl_ve",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1GSLMultiMinFunctionAdapter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1GSLMultiMinFunctionAdapter.html
Modifiability,adapt,adapting,". ROOT: ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc > Struct Template ReferenceMath » MathCore | Math » MathMore » Numerical Algorithms » Multi-dimensional Minimization. ; template<class UserFunc>; struct ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MultiMin algorithms. ; The templated C++ function class must implement:; double operator( const double * x) and if the derivatives are required: void Gradient( const double * x, double * g); This class defines static methods with will be used to fill the gsl_multimin_function and gsl_multimin_function_fdf structs used by GSL. See for examples the GSL online manual ; Definition at line 66 of file GSLMultiMinFunctionAdapter.h. Static Public Member Functions; static void Df (const gsl_vector *x, void *p, gsl_vector *g);  ; static double F (const gsl_vector *x, void *p);  ; static void Fdf (const gsl_vector *x, void *p, double *f, gsl_vector *g);  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/math/mathmore/src/GSLMultiMinFunctionAdapter.h>; Member Function Documentation. ◆ Df(). template<class UserFunc > . static void ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >::Df ; (; const gsl_vector * ; x, . void * ; p, . gsl_vector * ; g . ). inlinestatic . Definition at line 76 of file GSLMultiMinFunctionAdapter.h. ◆ F(). template<class UserFunc > . static double ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >::F ; (; const gsl_vector * ; x, . void * ; p . ). inlinestatic . Definition at line 68 of file GSLMultiMinFunctionAdapter.h. ◆ Fdf(). template<class UserFunc > . static void ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >::Fdf ; (; const gsl_ve",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1GSLMultiMinFunctionAdapter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1GSLMultiMinFunctionAdapter.html
Energy Efficiency,allocate,allocated,". ROOT: ROOT::Math::GSLRngROOTWrapper< Engine > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; Public Attributes |; List of all members ; ROOT::Math::GSLRngROOTWrapper< Engine > Struct Template Reference. ; template<class Engine>; struct ROOT::Math::GSLRngROOTWrapper< Engine >class for wrapping ROOT Engines in gsl_rng types which can be used as extra GSL random number generators For this we need to implement functions which will be called by gsl_rng. ; The functions (Seed, Rndm, IntRndm) are passed in the gsl_rng_type and used to build a gsl_rng object. When gsl_rng is alloacated, only the memory state is allocated using calloc(1,size), which gives a memory block of the given bytes and it initializes to zero. Therefore no constructor of GSLRngROOTWrapper can be called and also we cannot call non-static member function of the class. The underlined ROOT engine is then built and deleted using the functions CreateEngine() and FreeEngine(), called by the specific GSLRandomEngine class that instantiates for the the generator (e.g. GSLRngMixMax) ; Definition at line 39 of file GSLRngROOTWrapper.h. Static Public Member Functions; static void CreateEngine (gsl_rng *r);  ; static void FreeEngine (gsl_rng *r);  ; static unsigned long IntRndm (void *p);  ; static unsigned long Max ();  ; static unsigned long Min ();  ; static std::string Name ();  ; static double Rndm (void *p);  ; static void Seed (void *p, unsigned long seed);  ; static size_t Size ();  . Public Attributes; Engine * fEngine = nullptr;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/math/mathmore/src/GSLRngROOTWrapper.h>; Member Function Documentation. ◆ CreateEngine(). template<class Engine > . static void ROOT::Math::GSLRngROOTWrapper< Engine >::CreateEngine ; (; gsl_rng * ; r). inlinestatic . Definition at line 46 of file GSLRngROOTWrapper.h. ◆ FreeEngi",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1GSLRngROOTWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1GSLRngROOTWrapper.html
Integrability,wrap,wrapping,". ROOT: ROOT::Math::GSLRngROOTWrapper< Engine > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; Public Attributes |; List of all members ; ROOT::Math::GSLRngROOTWrapper< Engine > Struct Template Reference. ; template<class Engine>; struct ROOT::Math::GSLRngROOTWrapper< Engine >class for wrapping ROOT Engines in gsl_rng types which can be used as extra GSL random number generators For this we need to implement functions which will be called by gsl_rng. ; The functions (Seed, Rndm, IntRndm) are passed in the gsl_rng_type and used to build a gsl_rng object. When gsl_rng is alloacated, only the memory state is allocated using calloc(1,size), which gives a memory block of the given bytes and it initializes to zero. Therefore no constructor of GSLRngROOTWrapper can be called and also we cannot call non-static member function of the class. The underlined ROOT engine is then built and deleted using the functions CreateEngine() and FreeEngine(), called by the specific GSLRandomEngine class that instantiates for the the generator (e.g. GSLRngMixMax) ; Definition at line 39 of file GSLRngROOTWrapper.h. Static Public Member Functions; static void CreateEngine (gsl_rng *r);  ; static void FreeEngine (gsl_rng *r);  ; static unsigned long IntRndm (void *p);  ; static unsigned long Max ();  ; static unsigned long Min ();  ; static std::string Name ();  ; static double Rndm (void *p);  ; static void Seed (void *p, unsigned long seed);  ; static size_t Size ();  . Public Attributes; Engine * fEngine = nullptr;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/math/mathmore/src/GSLRngROOTWrapper.h>; Member Function Documentation. ◆ CreateEngine(). template<class Engine > . static void ROOT::Math::GSLRngROOTWrapper< Engine >::CreateEngine ; (; gsl_rng * ; r). inlinestatic . Definition at line 46 of file GSLRngROOTWrapper.h. ◆ FreeEngi",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1GSLRngROOTWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1GSLRngROOTWrapper.html
Performance,perform,performing,". ROOT: ROOT::Math::MinusEquals< T, D1, D2, A, R1, R2 > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::MinusEquals< T, D1, D2, A, R1, R2 > Struct Template Reference. ; template<class T, unsigned int D1, unsigned int D2, class A, class R1, class R2>; struct ROOT::Math::MinusEquals< T, D1, D2, A, R1, R2 >Evaluate the expression performing a -= operation Need to check whether creating a temporary object with the expression result (like in op: A -= A * B ) ; Definition at line 279 of file HelperOps.h. Static Public Member Functions; static void Evaluate (SMatrix< T, D1, D2, R1 > &lhs, const Expr< A, T, D1, D2, R2 > &rhs);  . #include <Math/HelperOps.h>; Member Function Documentation. ◆ Evaluate(). template<class T , unsigned int D1, unsigned int D2, class A , class R1 , class R2 > . static void ROOT::Math::MinusEquals< T, D1, D2, A, R1, R2 >::Evaluate ; (; SMatrix< T, D1, D2, R1 > & ; lhs, . const Expr< A, T, D1, D2, R2 > & ; rhs . ). inlinestatic . Definition at line 281 of file HelperOps.h. The documentation for this struct was generated from the following file:; math/smatrix/inc/Math/HelperOps.h. ROOTMathMinusEquals. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1MinusEquals.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1MinusEquals.html
Performance,perform,performing,". ROOT: ROOT::Math::MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > > Struct Template Reference. ; template<class T, unsigned int D1, unsigned int D2, class A>; struct ROOT::Math::MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >Specialization for symmetric matrices. ; Evaluate the expression performing a -= operation for symmetric matrices Need to have a separate functions to avoid to modify two times the off-diagonal elements (i.e applying two times the expression) Need to check whether creating a temporary object with the expression result (like in op: A -= A + B ) ; Definition at line 315 of file HelperOps.h. Static Public Member Functions; static void Evaluate (SMatrix< T, D1, D2, MatRepSym< T, D1 > > &lhs, const Expr< A, T, D1, D2, MatRepSym< T, D1 > > &rhs);  . #include <Math/HelperOps.h>; Member Function Documentation. ◆ Evaluate(). template<class T , unsigned int D1, unsigned int D2, class A > . static void ROOT::Math::MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >::Evaluate ; (; SMatrix< T, D1, D2, MatRepSym< T, D1 > > & ; lhs, . const Expr< A, T, D1, D2, MatRepSym< T, D1 > > & ; rhs . ). inlinestatic . Definition at line 317 of file HelperOps.h. The documentation for this struct was generated from the following file:; math/smatrix/inc/Math/HelperOps.h. ROOTMathMinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1MinusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_430c9cf3013fba6ff738c698e3426727e.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1MinusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_430c9cf3013fba6ff738c698e3426727e.html
Safety,avoid,avoid,". ROOT: ROOT::Math::MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > > Struct Template Reference. ; template<class T, unsigned int D1, unsigned int D2, class A>; struct ROOT::Math::MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >Specialization for symmetric matrices. ; Evaluate the expression performing a -= operation for symmetric matrices Need to have a separate functions to avoid to modify two times the off-diagonal elements (i.e applying two times the expression) Need to check whether creating a temporary object with the expression result (like in op: A -= A + B ) ; Definition at line 315 of file HelperOps.h. Static Public Member Functions; static void Evaluate (SMatrix< T, D1, D2, MatRepSym< T, D1 > > &lhs, const Expr< A, T, D1, D2, MatRepSym< T, D1 > > &rhs);  . #include <Math/HelperOps.h>; Member Function Documentation. ◆ Evaluate(). template<class T , unsigned int D1, unsigned int D2, class A > . static void ROOT::Math::MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >::Evaluate ; (; SMatrix< T, D1, D2, MatRepSym< T, D1 > > & ; lhs, . const Expr< A, T, D1, D2, MatRepSym< T, D1 > > & ; rhs . ). inlinestatic . Definition at line 317 of file HelperOps.h. The documentation for this struct was generated from the following file:; math/smatrix/inc/Math/HelperOps.h. ROOTMathMinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1MinusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_430c9cf3013fba6ff738c698e3426727e.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1MinusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_430c9cf3013fba6ff738c698e3426727e.html
Deployability,integrat,integration,". ROOT: ROOT::Math::MiserParameters Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::Math::MiserParameters Struct ReferenceMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration » Numerical Monte Carlo Integration Classes. ; Structure collecting parameters for MISER multidimensional integration. ; Definition at line 77 of file MCParameters.h. Public Member Functions;  MiserParameters (const ROOT::Math::IOptions &opt, size_t dim=10);  ;  MiserParameters (size_t dim=10);  ; std::unique_ptr< ROOT::Math::IOptions > MakeIOptions () const;  convert to options (return object is managed by the user) ;  ; MiserParameters & operator= (const ROOT::Math::IOptions &opt);  ; void SetDefaultValues (size_t dim=10);  default MISER parameters (copied from gsl/monte/vegas.c) ;  . Public Attributes; double alpha;  ; double dither;  ; double estimate_frac;  ; size_t min_calls;  ; size_t min_calls_per_bisection;  . #include <Math/MCParameters.h>; Constructor & Destructor Documentation. ◆ MiserParameters() [1/2]. ROOT::Math::MiserParameters::MiserParameters ; (; size_t ; dim = 10). inline . Definition at line 86 of file MCParameters.h. ◆ MiserParameters() [2/2]. ROOT::Math::MiserParameters::MiserParameters ; (; const ROOT::Math::IOptions & ; opt, . size_t ; dim = 10 . ). Definition at line 98 of file MCParameters.cxx. Member Function Documentation. ◆ MakeIOptions(). std::unique_ptr< ROOT::Math::IOptions > ROOT::Math::MiserParameters::MakeIOptions ; (; ); const. convert to options (return object is managed by the user) ; Definition at line 122 of file MCParameters.cxx. ◆ operator=(). MiserParameters & ROOT::Math::MiserParameters::operator= ; (; const ROOT::Math::IOptions & ; opt). Definition at line 103 of file MCParameters.cxx. ◆ SetDefaultValues(). void ROOT::Math::MiserParameters::SetDefaultValues ; (; size_t ; dim ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1MiserParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1MiserParameters.html
Integrability,integrat,integration,". ROOT: ROOT::Math::MiserParameters Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::Math::MiserParameters Struct ReferenceMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration » Numerical Monte Carlo Integration Classes. ; Structure collecting parameters for MISER multidimensional integration. ; Definition at line 77 of file MCParameters.h. Public Member Functions;  MiserParameters (const ROOT::Math::IOptions &opt, size_t dim=10);  ;  MiserParameters (size_t dim=10);  ; std::unique_ptr< ROOT::Math::IOptions > MakeIOptions () const;  convert to options (return object is managed by the user) ;  ; MiserParameters & operator= (const ROOT::Math::IOptions &opt);  ; void SetDefaultValues (size_t dim=10);  default MISER parameters (copied from gsl/monte/vegas.c) ;  . Public Attributes; double alpha;  ; double dither;  ; double estimate_frac;  ; size_t min_calls;  ; size_t min_calls_per_bisection;  . #include <Math/MCParameters.h>; Constructor & Destructor Documentation. ◆ MiserParameters() [1/2]. ROOT::Math::MiserParameters::MiserParameters ; (; size_t ; dim = 10). inline . Definition at line 86 of file MCParameters.h. ◆ MiserParameters() [2/2]. ROOT::Math::MiserParameters::MiserParameters ; (; const ROOT::Math::IOptions & ; opt, . size_t ; dim = 10 . ). Definition at line 98 of file MCParameters.cxx. Member Function Documentation. ◆ MakeIOptions(). std::unique_ptr< ROOT::Math::IOptions > ROOT::Math::MiserParameters::MakeIOptions ; (; ); const. convert to options (return object is managed by the user) ; Definition at line 122 of file MCParameters.cxx. ◆ operator=(). MiserParameters & ROOT::Math::MiserParameters::operator= ; (; const ROOT::Math::IOptions & ; opt). Definition at line 103 of file MCParameters.cxx. ◆ SetDefaultValues(). void ROOT::Math::MiserParameters::SetDefaultValues ; (; size_t ; dim ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1MiserParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1MiserParameters.html
Performance,perform,performing,". ROOT: ROOT::Math::PlusEquals< T, D1, D2, A, R1, R2 > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::PlusEquals< T, D1, D2, A, R1, R2 > Struct Template Reference. ; template<class T, unsigned int D1, unsigned int D2, class A, class R1, class R2>; struct ROOT::Math::PlusEquals< T, D1, D2, A, R1, R2 >Evaluate the expression performing a += operation Need to check whether creating a temporary object with the expression result (like in op: A += A * B ) ; Definition at line 195 of file HelperOps.h. Static Public Member Functions; static void Evaluate (SMatrix< T, D1, D2, R1 > &lhs, const Expr< A, T, D1, D2, R2 > &rhs);  . #include <Math/HelperOps.h>; Member Function Documentation. ◆ Evaluate(). template<class T , unsigned int D1, unsigned int D2, class A , class R1 , class R2 > . static void ROOT::Math::PlusEquals< T, D1, D2, A, R1, R2 >::Evaluate ; (; SMatrix< T, D1, D2, R1 > & ; lhs, . const Expr< A, T, D1, D2, R2 > & ; rhs . ). inlinestatic . Definition at line 197 of file HelperOps.h. The documentation for this struct was generated from the following file:; math/smatrix/inc/Math/HelperOps.h. ROOTMathPlusEquals. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:23 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1PlusEquals.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1PlusEquals.html
Performance,perform,performing,". ROOT: ROOT::Math::PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > > Struct Template Reference. ; template<class T, unsigned int D1, unsigned int D2, class A>; struct ROOT::Math::PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >Specialization for symmetric matrices Evaluate the expression performing a += operation for symmetric matrices Need to have a separate functions to avoid to modify two times the off-diagonal elements (i.e applying two times the expression) Need to check whether creating a temporary object with the expression result (like in op: A += A * B ) ; Definition at line 232 of file HelperOps.h. Static Public Member Functions; static void Evaluate (SMatrix< T, D1, D2, MatRepSym< T, D1 > > &lhs, const Expr< A, T, D1, D2, MatRepSym< T, D1 > > &rhs);  . #include <Math/HelperOps.h>; Member Function Documentation. ◆ Evaluate(). template<class T , unsigned int D1, unsigned int D2, class A > . static void ROOT::Math::PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >::Evaluate ; (; SMatrix< T, D1, D2, MatRepSym< T, D1 > > & ; lhs, . const Expr< A, T, D1, D2, MatRepSym< T, D1 > > & ; rhs . ). inlinestatic . Definition at line 234 of file HelperOps.h. The documentation for this struct was generated from the following file:; math/smatrix/inc/Math/HelperOps.h. ROOTMathPlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:23 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1PlusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_ab389af18e6c21fe987654dcf40e7fea.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1PlusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_ab389af18e6c21fe987654dcf40e7fea.html
Safety,avoid,avoid,". ROOT: ROOT::Math::PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Member Functions |; List of all members ; ROOT::Math::PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > > Struct Template Reference. ; template<class T, unsigned int D1, unsigned int D2, class A>; struct ROOT::Math::PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >Specialization for symmetric matrices Evaluate the expression performing a += operation for symmetric matrices Need to have a separate functions to avoid to modify two times the off-diagonal elements (i.e applying two times the expression) Need to check whether creating a temporary object with the expression result (like in op: A += A * B ) ; Definition at line 232 of file HelperOps.h. Static Public Member Functions; static void Evaluate (SMatrix< T, D1, D2, MatRepSym< T, D1 > > &lhs, const Expr< A, T, D1, D2, MatRepSym< T, D1 > > &rhs);  . #include <Math/HelperOps.h>; Member Function Documentation. ◆ Evaluate(). template<class T , unsigned int D1, unsigned int D2, class A > . static void ROOT::Math::PlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >::Evaluate ; (; SMatrix< T, D1, D2, MatRepSym< T, D1 > > & ; lhs, . const Expr< A, T, D1, D2, MatRepSym< T, D1 > > & ; rhs . ). inlinestatic . Definition at line 234 of file HelperOps.h. The documentation for this struct was generated from the following file:; math/smatrix/inc/Math/HelperOps.h. ROOTMathPlusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:23 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1PlusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_ab389af18e6c21fe987654dcf40e7fea.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1PlusEquals_3_01T_00_01D1_00_01D2_00_01A_00_01MatRepSym_3_01T_00_01D1_01_4_ab389af18e6c21fe987654dcf40e7fea.html
Deployability,integrat,integration,. ROOT: ROOT::Math::VegasParameters Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::Math::VegasParameters Struct ReferenceMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration » Numerical Monte Carlo Integration Classes. ; Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. ; Definition at line 46 of file MCParameters.h. Public Member Functions;  VegasParameters ();  ;  VegasParameters (const ROOT::Math::IOptions &opt);  ; std::unique_ptr< ROOT::Math::IOptions > MakeIOptions () const;  Convert to options. ;  ; VegasParameters & operator= (const ROOT::Math::IOptions &opt);  ; void SetDefaultValues ();  default VEGAS parameters (copied from gsl/monte/vegas.c) ;  . Public Attributes; double alpha;  ; size_t iterations;  ; int mode;  ; int stage;  ; int verbose;  . #include <Math/MCParameters.h>; Constructor & Destructor Documentation. ◆ VegasParameters() [1/2]. ROOT::Math::VegasParameters::VegasParameters ; (; ). inline . Definition at line 54 of file MCParameters.h. ◆ VegasParameters() [2/2]. ROOT::Math::VegasParameters::VegasParameters ; (; const ROOT::Math::IOptions & ; opt). Definition at line 48 of file MCParameters.cxx. Member Function Documentation. ◆ MakeIOptions(). std::unique_ptr< ROOT::Math::IOptions > ROOT::Math::VegasParameters::MakeIOptions ; (; ); const. Convert to options. ; Definition at line 72 of file MCParameters.cxx. ◆ operator=(). VegasParameters & ROOT::Math::VegasParameters::operator= ; (; const ROOT::Math::IOptions & ; opt). Definition at line 53 of file MCParameters.cxx. ◆ SetDefaultValues(). void ROOT::Math::VegasParameters::SetDefaultValues ; (; ). default VEGAS parameters (copied from gsl/monte/vegas.c) ; Definition at line 39 of file MCParameters.cxx. Membe,MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1VegasParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1VegasParameters.html
Integrability,integrat,integration,. ROOT: ROOT::Math::VegasParameters Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::Math::VegasParameters Struct ReferenceMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration » Numerical Monte Carlo Integration Classes. ; Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. ; Definition at line 46 of file MCParameters.h. Public Member Functions;  VegasParameters ();  ;  VegasParameters (const ROOT::Math::IOptions &opt);  ; std::unique_ptr< ROOT::Math::IOptions > MakeIOptions () const;  Convert to options. ;  ; VegasParameters & operator= (const ROOT::Math::IOptions &opt);  ; void SetDefaultValues ();  default VEGAS parameters (copied from gsl/monte/vegas.c) ;  . Public Attributes; double alpha;  ; size_t iterations;  ; int mode;  ; int stage;  ; int verbose;  . #include <Math/MCParameters.h>; Constructor & Destructor Documentation. ◆ VegasParameters() [1/2]. ROOT::Math::VegasParameters::VegasParameters ; (; ). inline . Definition at line 54 of file MCParameters.h. ◆ VegasParameters() [2/2]. ROOT::Math::VegasParameters::VegasParameters ; (; const ROOT::Math::IOptions & ; opt). Definition at line 48 of file MCParameters.cxx. Member Function Documentation. ◆ MakeIOptions(). std::unique_ptr< ROOT::Math::IOptions > ROOT::Math::VegasParameters::MakeIOptions ; (; ); const. Convert to options. ; Definition at line 72 of file MCParameters.cxx. ◆ operator=(). VegasParameters & ROOT::Math::VegasParameters::operator= ; (; const ROOT::Math::IOptions & ; opt). Definition at line 53 of file MCParameters.cxx. ◆ SetDefaultValues(). void ROOT::Math::VegasParameters::SetDefaultValues ; (; ). default VEGAS parameters (copied from gsl/monte/vegas.c) ; Definition at line 39 of file MCParameters.cxx. Membe,MatchSource.WIKI,doc/master/structROOT_1_1Math_1_1VegasParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1Math_1_1VegasParameters.html
Availability,avail,available,". ROOT: ROOT::RCompressionSetting Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Static Public Member Functions |; List of all members ; ROOT::RCompressionSetting Struct Reference. ; The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. ; Both are defined in Bits.h. The default is to use the global setting and the default of the global setting is to use the ZLIB compression algorithm.; The LZMA algorithm (from the XZ package) is also available. The LZMA compression usually results in greater compression factors, but takes more CPU time and memory when compressing. LZMA memory usage is particularly high for compression levels 8 and 9.; Finally, the LZ4 package results in worse compression ratios than ZLIB but achieves much faster decompression rates. The current algorithms support level 1 to 9. The higher the level the greater the compression and more CPU time and memory resources used during compression. Level 0 means no compression.; Recommendation for the compression algorithm's levels:; ZLIB is recommended to be used with compression level 1 [101]; LZMA is recommended to be used with compression level 7-8 (higher is better, since in the case of LZMA we don't care about compression/decompression speed) [207 - 208]; LZ4 is recommended to be used with compression level 4 [404]; ZSTD is recommended to be used with compression level 5 [505] . Definition at line 46 of file Compression.h. Classes; struct  EAlgorithm;  ; struct  EDefaults;  ; struct  ELevel;  . Static Public Member Functions; static EAlgorithm::EValues AlgorithmFromCompressionSettings (int compSettings);  ; static std::string AlgorithmToString (EAlgorithm::EValues algorithm);  . #include <Compression.h>; Member Function Documentation. ◆ AlgorithmFromCompressionSettings(). static EAlgorithm::EValues ROOT::RCompressionSetting::AlgorithmFromCompressi",MatchSource.WIKI,doc/master/structROOT_1_1RCompressionSetting.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1RCompressionSetting.html
Integrability,depend,depend,". ROOT: ROOT::RCompressionSetting Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Static Public Member Functions |; List of all members ; ROOT::RCompressionSetting Struct Reference. ; The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. ; Both are defined in Bits.h. The default is to use the global setting and the default of the global setting is to use the ZLIB compression algorithm.; The LZMA algorithm (from the XZ package) is also available. The LZMA compression usually results in greater compression factors, but takes more CPU time and memory when compressing. LZMA memory usage is particularly high for compression levels 8 and 9.; Finally, the LZ4 package results in worse compression ratios than ZLIB but achieves much faster decompression rates. The current algorithms support level 1 to 9. The higher the level the greater the compression and more CPU time and memory resources used during compression. Level 0 means no compression.; Recommendation for the compression algorithm's levels:; ZLIB is recommended to be used with compression level 1 [101]; LZMA is recommended to be used with compression level 7-8 (higher is better, since in the case of LZMA we don't care about compression/decompression speed) [207 - 208]; LZ4 is recommended to be used with compression level 4 [404]; ZSTD is recommended to be used with compression level 5 [505] . Definition at line 46 of file Compression.h. Classes; struct  EAlgorithm;  ; struct  EDefaults;  ; struct  ELevel;  . Static Public Member Functions; static EAlgorithm::EValues AlgorithmFromCompressionSettings (int compSettings);  ; static std::string AlgorithmToString (EAlgorithm::EValues algorithm);  . #include <Compression.h>; Member Function Documentation. ◆ AlgorithmFromCompressionSettings(). static EAlgorithm::EValues ROOT::RCompressionSetting::AlgorithmFromCompressi",MatchSource.WIKI,doc/master/structROOT_1_1RCompressionSetting.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1RCompressionSetting.html
Modifiability,variab,variable,". ROOT: ROOT::RCompressionSetting Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Static Public Member Functions |; List of all members ; ROOT::RCompressionSetting Struct Reference. ; The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. ; Both are defined in Bits.h. The default is to use the global setting and the default of the global setting is to use the ZLIB compression algorithm.; The LZMA algorithm (from the XZ package) is also available. The LZMA compression usually results in greater compression factors, but takes more CPU time and memory when compressing. LZMA memory usage is particularly high for compression levels 8 and 9.; Finally, the LZ4 package results in worse compression ratios than ZLIB but achieves much faster decompression rates. The current algorithms support level 1 to 9. The higher the level the greater the compression and more CPU time and memory resources used during compression. Level 0 means no compression.; Recommendation for the compression algorithm's levels:; ZLIB is recommended to be used with compression level 1 [101]; LZMA is recommended to be used with compression level 7-8 (higher is better, since in the case of LZMA we don't care about compression/decompression speed) [207 - 208]; LZ4 is recommended to be used with compression level 4 [404]; ZSTD is recommended to be used with compression level 5 [505] . Definition at line 46 of file Compression.h. Classes; struct  EAlgorithm;  ; struct  EDefaults;  ; struct  ELevel;  . Static Public Member Functions; static EAlgorithm::EValues AlgorithmFromCompressionSettings (int compSettings);  ; static std::string AlgorithmToString (EAlgorithm::EValues algorithm);  . #include <Compression.h>; Member Function Documentation. ◆ AlgorithmFromCompressionSettings(). static EAlgorithm::EValues ROOT::RCompressionSetting::AlgorithmFromCompressi",MatchSource.WIKI,doc/master/structROOT_1_1RCompressionSetting.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1RCompressionSetting.html
Modifiability,inherit,inherited,". ROOT: Member List. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. ROOT::RCompressionSetting::EAlgorithm Member List. This is the complete list of members for ROOT::RCompressionSetting::EAlgorithm, including all inherited members. EValues enum nameROOT::RCompressionSetting::EAlgorithm; kInherit enum valueROOT::RCompressionSetting::EAlgorithm; kLZ4 enum valueROOT::RCompressionSetting::EAlgorithm; kLZMA enum valueROOT::RCompressionSetting::EAlgorithm; kOldCompressionAlgo enum valueROOT::RCompressionSetting::EAlgorithm; kUndefined enum valueROOT::RCompressionSetting::EAlgorithm; kUseGlobal enum valueROOT::RCompressionSetting::EAlgorithm; kZLIB enum valueROOT::RCompressionSetting::EAlgorithm; kZSTD enum valueROOT::RCompressionSetting::EAlgorithm. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:58 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1RCompressionSetting_1_1EAlgorithm-members.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1RCompressionSetting_1_1EAlgorithm-members.html
Modifiability,inherit,inherited,". ROOT: ROOT::RCompressionSetting::EAlgorithm Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; List of all members ; ROOT::RCompressionSetting::EAlgorithm Struct Reference. . Definition at line 86 of file Compression.h. Public Types; enum  EValues { ;   kInherit = -1; , kUseGlobal = 0; , kZLIB; , kLZMA; , ;   kOldCompressionAlgo; , kLZ4; , kZSTD; , kUndefined. };  Note: this is only temporarily a struct and will become a enum class hence the name convention used. More...;  . #include <Compression.h>; Member Enumeration Documentation. ◆ EValues. enum ROOT::RCompressionSetting::EAlgorithm::EValues. Note: this is only temporarily a struct and will become a enum class hence the name convention used. . EnumeratorkInherit Some objects use this value to denote that the compression algorithm should be inherited from the parent object (e.g., TBranch should get the algorithm from the TTree) . kUseGlobal Use the global compression algorithm. . kZLIB Use ZLIB compression. . kLZMA Use LZMA compression. . kOldCompressionAlgo Use the old compression algorithm. . kLZ4 Use LZ4 compression. . kZSTD Use ZSTD compression. . kUndefined Undefined compression algorithm (must be kept the last of the list in case a new algorithm is added). . Definition at line 88 of file Compression.h. The documentation for this struct was generated from the following file:; core/zip/inc/Compression.h. ROOTRCompressionSettingEAlgorithm. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:58 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1RCompressionSetting_1_1EAlgorithm.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1RCompressionSetting_1_1EAlgorithm.html
Modifiability,inherit,inherited,". ROOT: ROOT::RCompressionSetting::ELevel Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; List of all members ; ROOT::RCompressionSetting::ELevel Struct Reference. . Definition at line 63 of file Compression.h. Public Types; enum  EValues { ;   kInherit = -1; , kUncompressed = 0; , kUseMin = 1; , kDefaultZLIB = 1; , ;   kDefaultLZ4 = 4; , kDefaultZSTD = 5; , kDefaultOld = 6; , kDefaultLZMA = 7. };  Note: this is only temporarily a struct and will become a enum class hence the name convention used. More...;  . #include <Compression.h>; Member Enumeration Documentation. ◆ EValues. enum ROOT::RCompressionSetting::ELevel::EValues. Note: this is only temporarily a struct and will become a enum class hence the name convention used. . EnumeratorkInherit Some objects use this value to denote that the compression algorithm should be inherited from the parent object. . kUncompressed Compression level reserved for ""uncompressed state"". . kUseMin Compression level reserved when we are not sure what to use (1 is for the fastest compression) . kDefaultZLIB Compression level reserved for ZLIB compression algorithm (fastest compression) . kDefaultLZ4 Compression level reserved for LZ4 compression algorithm (trade-off between file ratio/decompression speed) . kDefaultZSTD Compression level reserved for ZSTD compression algorithm (trade-off between file ratio/decompression speed) . kDefaultOld Compression level reserved for old ROOT compression algorithm. . kDefaultLZMA Compression level reserved for LZMA compression algorithm (slowest compression with smallest files) . Definition at line 65 of file Compression.h. The documentation for this struct was generated from the following file:; core/zip/inc/Compression.h. ROOTRCompressionSettingELevel. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:58 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1RCompressionSetting_1_1ELevel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1RCompressionSetting_1_1ELevel.html
Integrability,interface,interfaces,". ROOT: ROOT::TNumSlots Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; Friends |; List of all members ; ROOT::TNumSlots Class Reference. ; Defines the number of threads in some of ROOT's interfaces. ; Definition at line 42 of file TThreadedObject.hxx. Public Attributes; unsigned int fVal;  . Friends; bool operator!= (TNumSlots lhs, TNumSlots rhs);  ; bool operator== (TNumSlots lhs, TNumSlots rhs);  . #include <ROOT/TThreadedObject.hxx>; Friends And Related Symbol Documentation. ◆ operator!=. bool operator!= ; (; TNumSlots ; lhs, . TNumSlots ; rhs . ). friend . Definition at line 45 of file TThreadedObject.hxx. ◆ operator==. bool operator== ; (; TNumSlots ; lhs, . TNumSlots ; rhs . ). friend . Definition at line 44 of file TThreadedObject.hxx. Member Data Documentation. ◆ fVal. unsigned int ROOT::TNumSlots::fVal. Definition at line 43 of file TThreadedObject.hxx. Collaboration diagram for ROOT::TNumSlots:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this class was generated from the following file:; core/thread/inc/ROOT/TThreadedObject.hxx. ROOTTNumSlots. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:00 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1TNumSlots.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1TNumSlots.html
Performance,perform,performed,". ROOT: ROOT::TypeTraits::TypeList< Types > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Static Public Attributes |; List of all members ; ROOT::TypeTraits::TypeList< Types > Struct Template Reference. ; template<typename... Types>; struct ROOT::TypeTraits::TypeList< Types >Lightweight storage for a collection of types. ; Differently from std::tuple, no instantiation of objects of stored types is performed ; Definition at line 25 of file TypeTraits.hxx. Static Public Attributes; static constexpr std::size_t list_size = sizeof...(Types);  . #include <ROOT/TypeTraits.hxx>; Member Data Documentation. ◆ list_size. template<typename... Types> . constexpr std::size_t ROOT::TypeTraits::TypeList< Types >::list_size = sizeof...(Types). staticconstexpr . Definition at line 26 of file TypeTraits.hxx. Collaboration diagram for ROOT::TypeTraits::TypeList< Types >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; core/foundation/inc/ROOT/TypeTraits.hxx. ROOTTypeTraitsTypeList. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:28 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structROOT_1_1TypeTraits_1_1TypeList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1TypeTraits_1_1TypeList.html
Availability,error,error,"ject. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t ",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
Integrability,message,message,"ject. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t ",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
Modifiability,inherit,inherited,". ROOT: ROOT::v5::TF1Data Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Public Attributes |; List of all members ; ROOT::v5::TF1Data Struct Reference. . Definition at line 37 of file TF1Data.h. Public Member Functions;  TF1Data ();  F1 default constructor. ;  ;  ~TF1Data () override;  TF1 default destructor. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void Streamer (TBuffer &b, Int_t version, UInt_t start, UInt_t count, const TClass *onfile_class=nullptr);  specialized streamer function being able to read old TF1 versions as TF1Data in memory ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from ROOT::v5::TFormula;  TFormula ();  Formula default constructor. ;  ;  TFormula (const char *name, const char *formula);  Normal Formula constructor. ;  ;  TFormula (const TFormula &formula);  Default constructor. ;  ;  ~TFormula () override;  Formula default destructor. ;  ; virtual void Analyze (const char *schain, Int_t &err, Int_t offset=0);  Analyze a sub-expression in one formula. ;  ; virtual Bool_t AnalyzeFunction (TString &chaine, Int_t &err, Int_t offset=0);  Check if the chain as function call. ;  ; void Clear (Option_t *option="""") override;  Resets the objects. ;  ; virtual Int_t Compile (const char *expression="""");  Compile expression already stored in fTitle. ;  ; void Copy (TObject &formula) const override;  Copy this formula. ;  ; virtual char * DefinedString (Int_t code);  Return address of string corresponding to special code. ;  ; virtual Double_t DefinedValue (Int_t code);  Return value corresponding to special code. ;  ; virtual Int_t DefinedVariable (TString &variable, Int_t &action);  Check if expression is in the list of defined variables. ;  ; virtual Double_t Eval (Double_t x, Double_t y=0, Double_t z=",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
Performance,optimiz,optimization,"const;  ; Int_t GetActionParam (Int_t code) const;  ; Int_t GetActionParamOptimized (Int_t code) const;  ; Int_t * GetOper () const;  ; Int_t * GetOperOptimized () const;  ; virtual Bool_t IsString (Int_t oper) const;  Return true if the expression at the index 'oper' has to be treated as a string. ;  ; void MakePrimitive (const char *expr, Int_t pos);  MakePrimitive find TFormulaPrimitive replacement for some operands. ;  ; Int_t PreCompile ();  pointer to optimal function ;  ; void SetAction (Int_t code, Int_t value, Int_t param=0);  ; void SetActionOptimized (Int_t code, Int_t value, Int_t param=0);  ; virtual Bool_t StringToNumber (Int_t code);  Try to 'demote' a string into an array bytes. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from ROOT::v5::TFormula; TBits fAlreadyFound;  ; Double_t * fConst;  ; TString * fExpr;  ; TString * fExprOptimized;  Number of operators after optimization. ;  ; TObjArray fFunctions;  ; TObjArray fLinearParts;  ; TString * fNames;  ; Int_t fNconst;  ; Int_t fNdim;  ; Int_t fNoper;  ; Int_t fNOperOptimized;  cache for information ;  ; Int_t fNpar;  ; Int_t fNstring;  ; Int_t fNumber;  ; Int_t fNval;  ; TOperOffset * fOperOffset;  [fNOperOptimized] List of operators. (See documentation for changes made at version 7) ;  ; Int_t * fOperOptimized;  [fNOperOptimized] List of expressions ;  ; TFuncG fOptimal;  [fNPar] predefined function ;  ; Double_t * fParams;  ; TFormulaPrimitive ** fPredefined;  [fNOperOptimized] Offsets of operrands ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth;  Line width. ;  ;  Protected Attributes inherited from TAttFill; Color_t fF",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
Security,hash,hash,"as TF1Old in memory ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Update ();  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,doc/master/structROOT_1_1v5_1_1TF1Data.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html
Availability,mask,mask,". ROOT: SetWindowAttributes_t Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; SetWindowAttributes_t Struct Reference. ; Attributes that can be used when creating or changing a window. ; Definition at line 93 of file GuiTypes.h. Public Attributes; ULong_t fBackgroundPixel;  background pixel ;  ; Pixmap_t fBackgroundPixmap;  background or kNone or kParentRelative ;  ; ULong_t fBackingPixel;  value to use in restoring planes ;  ; ULong_t fBackingPlanes;  planes to be preserved if possible ;  ; Int_t fBackingStore;  kNotUseful, kWhenMapped, kAlways ;  ; Int_t fBitGravity;  one of bit gravity values ;  ; ULong_t fBorderPixel;  border pixel value ;  ; Pixmap_t fBorderPixmap;  border of the window ;  ; UInt_t fBorderWidth;  border width in pixels ;  ; Colormap_t fColormap;  color map to be associated with window ;  ; Cursor_t fCursor;  cursor to be displayed (or kNone) ;  ; Long_t fDoNotPropagateMask;  set of events that should not propagate ;  ; Long_t fEventMask;  set of events that should be saved ;  ; Mask_t fMask;  bit mask specifying which fields are valid ;  ; Bool_t fOverrideRedirect;  boolean value for override-redirect ;  ; Bool_t fSaveUnder;  should bits under be saved (popups)? ;  ; Int_t fWinGravity;  one of the window gravity values ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fBackgroundPixel. ULong_t SetWindowAttributes_t::fBackgroundPixel. background pixel ; Definition at line 95 of file GuiTypes.h. ◆ fBackgroundPixmap. Pixmap_t SetWindowAttributes_t::fBackgroundPixmap. background or kNone or kParentRelative ; Definition at line 94 of file GuiTypes.h. ◆ fBackingPixel. ULong_t SetWindowAttributes_t::fBackingPixel. value to use in restoring planes ; Definition at line 103 of file GuiTypes.h. ◆ fBackingPlanes. ULong_t SetWindowAttributes_t::fBackingPlanes. planes to be preserved if possible ; Definition at line 102 of file GuiTypes.h",MatchSource.WIKI,doc/master/structSetWindowAttributes__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structSetWindowAttributes__t.html
Modifiability,inherit,inherited,". ROOT: TF1::TF1FunctorPointerImpl< T > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; TF1::TF1FunctorPointerImpl< T > Struct Template Reference. ; template<class T>; struct TF1::TF1FunctorPointerImpl< T >; Definition at line 313 of file TF1.h. Public Member Functions;  TF1FunctorPointerImpl (const ROOT::Math::ParamFunctorTempl< T > &func);  ;  TF1FunctorPointerImpl (const std::function< T(const T *f, const Double_t *param)> &func);  ;  ~TF1FunctorPointerImpl () override;  ; TF1FunctorPointer * Clone () const override;  ;  Public Member Functions inherited from TF1::TF1FunctorPointer; virtual ~TF1FunctorPointer ();  . Public Attributes; ROOT::Math::ParamFunctorTempl< T > fImpl;  . #include <TF1.h>. Inheritance diagram for TF1::TF1FunctorPointerImpl< T >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TF1FunctorPointerImpl() [1/2]. template<class T > . TF1::TF1FunctorPointerImpl< T >::TF1FunctorPointerImpl ; (; const ROOT::Math::ParamFunctorTempl< T > & ; func). inline . Definition at line 314 of file TF1.h. ◆ TF1FunctorPointerImpl() [2/2]. template<class T > . TF1::TF1FunctorPointerImpl< T >::TF1FunctorPointerImpl ; (; const std::function< T(const T *f, const Double_t *param)> & ; func). inline . Definition at line 315 of file TF1.h. ◆ ~TF1FunctorPointerImpl(). template<class T > . TF1::TF1FunctorPointerImpl< T >::~TF1FunctorPointerImpl ; (; ). inlineoverride . Definition at line 316 of file TF1.h. Member Function Documentation. ◆ Clone(). template<class T > . TF1FunctorPointer * TF1::TF1FunctorPointerImpl< T >::Clone ; (; ); const. inlineoverridevirtual . Implements TF1::TF1FunctorPointer.; Definition at line 317 of file TF1.h. Member Data Documentation. ◆ fImpl. template<class T > . ROOT::Math::ParamFunctorTempl<T> TF1::TF1",MatchSource.WIKI,doc/master/structTF1_1_1TF1FunctorPointerImpl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTF1_1_1TF1FunctorPointerImpl.html
Performance,cache,cache,". ROOT: TGenCollectionProxy::Value Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; TGenCollectionProxy::Value Class Reference. ; Small helper to describe the Value_type or the key_type of an STL container. ; AuthorM.Frank ; Version1.0 ; Date10/10/2004 ; Definition at line 60 of file TGenCollectionProxy.h. Public Member Functions;  Value (const std::string &info, Bool_t silent, size_t hint_pair_offset=0, size_t hint_pair_size=0);  Constructor. ;  ; void DeleteItem (void *ptr);  ; Bool_t IsValid ();  Return true if the Value has been properly initialized. ;  . Public Attributes; UInt_t fCase;  type of data of Value_type ;  ; ROOT::NewFunc_t fCtor;  Method cache for containee constructor. ;  ; ROOT::DelFunc_t fDelete;  Method cache for containee delete. ;  ; ROOT::DesFunc_t fDtor;  Method cache for containee destructor. ;  ; EDataType fKind;  kind of ROOT-fundamental type ;  ; UInt_t fProperties;  Additional properties of the value type (kNeedDelete) ;  ; size_t fSize;  fSize of the contained object ;  ; TClassRef fType;  TClass reference of Value_type in collection. ;  . #include <TGenCollectionProxy.h>; Constructor & Destructor Documentation. ◆ Value(). TGenCollectionProxy::Value::Value ; (; const std::string & ; info, . Bool_t ; silent, . size_t ; hint_pair_offset = 0, . size_t ; hint_pair_size = 0 . ). Constructor. ; Definition at line 316 of file TGenCollectionProxy.cxx. Member Function Documentation. ◆ DeleteItem(). void TGenCollectionProxy::Value::DeleteItem ; (; void * ; ptr). Definition at line 518 of file TGenCollectionProxy.cxx. ◆ IsValid(). Bool_t TGenCollectionProxy::Value::IsValid ; (; ). Return true if the Value has been properly initialized. ; Definition at line 511 of file TGenCollectionProxy.cxx. Member Data Documentation. ◆ fCase. UInt_t TGenCollectionProxy::Value::fCase. type of data of Value_type ; Definition",MatchSource.WIKI,doc/master/structTGenCollectionProxy_1_1Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTGenCollectionProxy_1_1Value.html
Modifiability,inherit,inherited,". ROOT: TMVA::DNN::TDNNGenDescriptors< Layer_t > Struct Template Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Attributes |; List of all members ; TMVA::DNN::TDNNGenDescriptors< Layer_t > Struct Template Reference. ; template<typename Layer_t>; struct TMVA::DNN::TDNNGenDescriptors< Layer_t >; Definition at line 37 of file ContextHandles.h. Public Types; using HelperDescriptor_t = typename Layer_t::HelperDescriptor_t;  . Public Attributes; HelperDescriptor_t HelperDescriptor;  . Additional Inherited Members;  Public Member Functions inherited from TMVA::DNN::TDescriptors; virtual ~TDescriptors ();  . #include <TMVA/DNN/CNN/ContextHandles.h>. Inheritance diagram for TMVA::DNN::TDNNGenDescriptors< Layer_t >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ HelperDescriptor_t. template<typename Layer_t > . using TMVA::DNN::TDNNGenDescriptors< Layer_t >::HelperDescriptor_t = typename Layer_t::HelperDescriptor_t. Definition at line 38 of file ContextHandles.h. Member Data Documentation. ◆ HelperDescriptor. template<typename Layer_t > . HelperDescriptor_t TMVA::DNN::TDNNGenDescriptors< Layer_t >::HelperDescriptor. Definition at line 40 of file ContextHandles.h. Collaboration diagram for TMVA::DNN::TDNNGenDescriptors< Layer_t >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; tmva/tmva/inc/TMVA/DNN/CNN/ContextHandles.h. TMVADNNTDNNGenDescriptors. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:46 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structTMVA_1_1DNN_1_1TDNNGenDescriptors.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTMVA_1_1DNN_1_1TDNNGenDescriptors.html
Performance,optimiz,optimizer,". ROOT: TMVA::TTrainingSettings Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; TMVA::TTrainingSettings Struct Reference. ; All of the options that can be specified in the training string. ; Definition at line 72 of file MethodDL.h. Public Attributes; size_t batchSize;  ; size_t convergenceSteps;  ; std::vector< Double_t > dropoutProbabilities;  ; Double_t learningRate;  ; size_t maxEpochs;  ; Double_t momentum;  ; bool multithreading;  ; DNN::EOptimizer optimizer;  ; TString optimizerName;  ; std::map< TString, double > optimizerParams;  ; DNN::ERegularization regularization;  ; size_t testInterval;  ; Double_t weightDecay;  . #include <TMVA/MethodDL.h>; Member Data Documentation. ◆ batchSize. size_t TMVA::TTrainingSettings::batchSize. Definition at line 73 of file MethodDL.h. ◆ convergenceSteps. size_t TMVA::TTrainingSettings::convergenceSteps. Definition at line 75 of file MethodDL.h. ◆ dropoutProbabilities. std::vector<Double_t> TMVA::TTrainingSettings::dropoutProbabilities. Definition at line 83 of file MethodDL.h. ◆ learningRate. Double_t TMVA::TTrainingSettings::learningRate. Definition at line 80 of file MethodDL.h. ◆ maxEpochs. size_t TMVA::TTrainingSettings::maxEpochs. Definition at line 76 of file MethodDL.h. ◆ momentum. Double_t TMVA::TTrainingSettings::momentum. Definition at line 81 of file MethodDL.h. ◆ multithreading. bool TMVA::TTrainingSettings::multithreading. Definition at line 85 of file MethodDL.h. ◆ optimizer. DNN::EOptimizer TMVA::TTrainingSettings::optimizer. Definition at line 78 of file MethodDL.h. ◆ optimizerName. TString TMVA::TTrainingSettings::optimizerName. Definition at line 79 of file MethodDL.h. ◆ optimizerParams. std::map<TString,double> TMVA::TTrainingSettings::optimizerParams. Definition at line 84 of file MethodDL.h. ◆ regularization. DNN::ERegularization TMVA::TTrainingSettings::regularization. Definition at line",MatchSource.WIKI,doc/master/structTMVA_1_1TTrainingSettings.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html
Testability,test,testInterval,". ROOT: TMVA::TTrainingSettings Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; TMVA::TTrainingSettings Struct Reference. ; All of the options that can be specified in the training string. ; Definition at line 72 of file MethodDL.h. Public Attributes; size_t batchSize;  ; size_t convergenceSteps;  ; std::vector< Double_t > dropoutProbabilities;  ; Double_t learningRate;  ; size_t maxEpochs;  ; Double_t momentum;  ; bool multithreading;  ; DNN::EOptimizer optimizer;  ; TString optimizerName;  ; std::map< TString, double > optimizerParams;  ; DNN::ERegularization regularization;  ; size_t testInterval;  ; Double_t weightDecay;  . #include <TMVA/MethodDL.h>; Member Data Documentation. ◆ batchSize. size_t TMVA::TTrainingSettings::batchSize. Definition at line 73 of file MethodDL.h. ◆ convergenceSteps. size_t TMVA::TTrainingSettings::convergenceSteps. Definition at line 75 of file MethodDL.h. ◆ dropoutProbabilities. std::vector<Double_t> TMVA::TTrainingSettings::dropoutProbabilities. Definition at line 83 of file MethodDL.h. ◆ learningRate. Double_t TMVA::TTrainingSettings::learningRate. Definition at line 80 of file MethodDL.h. ◆ maxEpochs. size_t TMVA::TTrainingSettings::maxEpochs. Definition at line 76 of file MethodDL.h. ◆ momentum. Double_t TMVA::TTrainingSettings::momentum. Definition at line 81 of file MethodDL.h. ◆ multithreading. bool TMVA::TTrainingSettings::multithreading. Definition at line 85 of file MethodDL.h. ◆ optimizer. DNN::EOptimizer TMVA::TTrainingSettings::optimizer. Definition at line 78 of file MethodDL.h. ◆ optimizerName. TString TMVA::TTrainingSettings::optimizerName. Definition at line 79 of file MethodDL.h. ◆ optimizerParams. std::map<TString,double> TMVA::TTrainingSettings::optimizerParams. Definition at line 84 of file MethodDL.h. ◆ regularization. DNN::ERegularization TMVA::TTrainingSettings::regularization. Definition at line",MatchSource.WIKI,doc/master/structTMVA_1_1TTrainingSettings.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html
Usability,learn,learningRate,". ROOT: TMVA::TTrainingSettings Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; TMVA::TTrainingSettings Struct Reference. ; All of the options that can be specified in the training string. ; Definition at line 72 of file MethodDL.h. Public Attributes; size_t batchSize;  ; size_t convergenceSteps;  ; std::vector< Double_t > dropoutProbabilities;  ; Double_t learningRate;  ; size_t maxEpochs;  ; Double_t momentum;  ; bool multithreading;  ; DNN::EOptimizer optimizer;  ; TString optimizerName;  ; std::map< TString, double > optimizerParams;  ; DNN::ERegularization regularization;  ; size_t testInterval;  ; Double_t weightDecay;  . #include <TMVA/MethodDL.h>; Member Data Documentation. ◆ batchSize. size_t TMVA::TTrainingSettings::batchSize. Definition at line 73 of file MethodDL.h. ◆ convergenceSteps. size_t TMVA::TTrainingSettings::convergenceSteps. Definition at line 75 of file MethodDL.h. ◆ dropoutProbabilities. std::vector<Double_t> TMVA::TTrainingSettings::dropoutProbabilities. Definition at line 83 of file MethodDL.h. ◆ learningRate. Double_t TMVA::TTrainingSettings::learningRate. Definition at line 80 of file MethodDL.h. ◆ maxEpochs. size_t TMVA::TTrainingSettings::maxEpochs. Definition at line 76 of file MethodDL.h. ◆ momentum. Double_t TMVA::TTrainingSettings::momentum. Definition at line 81 of file MethodDL.h. ◆ multithreading. bool TMVA::TTrainingSettings::multithreading. Definition at line 85 of file MethodDL.h. ◆ optimizer. DNN::EOptimizer TMVA::TTrainingSettings::optimizer. Definition at line 78 of file MethodDL.h. ◆ optimizerName. TString TMVA::TTrainingSettings::optimizerName. Definition at line 79 of file MethodDL.h. ◆ optimizerParams. std::map<TString,double> TMVA::TTrainingSettings::optimizerParams. Definition at line 84 of file MethodDL.h. ◆ regularization. DNN::ERegularization TMVA::TTrainingSettings::regularization. Definition at line",MatchSource.WIKI,doc/master/structTMVA_1_1TTrainingSettings.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTMVA_1_1TTrainingSettings.html
Performance,cache,cache,". ROOT: TTreePerfStats::BasketInfo Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; TTreePerfStats::BasketInfo Struct Reference. . Definition at line 41 of file TTreePerfStats.h. Public Attributes; UInt_t fLoaded = {0};  Number of times the basket was put in the primary TTreeCache. ;  ; UInt_t fLoadedMiss = {0};  Number of times the basket was put in the secondary cache. ;  ; UInt_t fMissed = {0};  Number of times the basket was read directly from the file. ;  ; UInt_t fUsed = {0};  Number of times the basket was requested from the disk. ;  . #include <TTreePerfStats.h>; Member Data Documentation. ◆ fLoaded. UInt_t TTreePerfStats::BasketInfo::fLoaded = {0}. Number of times the basket was put in the primary TTreeCache. ; Definition at line 43 of file TTreePerfStats.h. ◆ fLoadedMiss. UInt_t TTreePerfStats::BasketInfo::fLoadedMiss = {0}. Number of times the basket was put in the secondary cache. ; Definition at line 44 of file TTreePerfStats.h. ◆ fMissed. UInt_t TTreePerfStats::BasketInfo::fMissed = {0}. Number of times the basket was read directly from the file. ; Definition at line 45 of file TTreePerfStats.h. ◆ fUsed. UInt_t TTreePerfStats::BasketInfo::fUsed = {0}. Number of times the basket was requested from the disk. ; Definition at line 42 of file TTreePerfStats.h. Collaboration diagram for TTreePerfStats::BasketInfo:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; tree/treeplayer/inc/TTreePerfStats.h. TTreePerfStatsBasketInfo. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:40 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/structTTreePerfStats_1_1BasketInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structTTreePerfStats_1_1BasketInfo.html
Availability,mask,mask,". ROOT: WindowAttributes_t Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; WindowAttributes_t Struct Reference. ; Window attributes that can be inquired. ; Definition at line 114 of file GuiTypes.h. Public Attributes; Long_t fAllEventMasks;  set of events all people have interest in ;  ; ULong_t fBackingPixel;  value to be used when restoring planes ;  ; ULong_t fBackingPlanes;  planes to be preserved if possible ;  ; Int_t fBackingStore;  kNotUseful, kWhenMapped, kAlways ;  ; Int_t fBitGravity;  one of bit gravity values ;  ; Int_t fBorderWidth;  border width of window ;  ; Int_t fClass;  kInputOutput, kInputOnly ;  ; Colormap_t fColormap;  color map to be associated with window ;  ; Int_t fDepth;  depth of window ;  ; Long_t fDoNotPropagateMask;  set of events that should not propagate ;  ; Int_t fHeight;  width and height of window ;  ; Bool_t fMapInstalled;  boolean, is color map currently installed ;  ; Int_t fMapState;  kIsUnmapped, kIsUnviewable, kIsViewable ;  ; Bool_t fOverrideRedirect;  boolean value for override-redirect ;  ; Window_t fRoot;  root of screen containing window ;  ; Bool_t fSaveUnder;  boolean, should bits under be saved? ;  ; void * fScreen;  back pointer to correct screen ;  ; void * fVisual;  the associated visual structure ;  ; Int_t fWidth;  ; Int_t fWinGravity;  one of the window gravity values ;  ; Int_t fX;  ; Int_t fY;  location of window ;  ; Long_t fYourEventMask;  my event mask ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fAllEventMasks. Long_t WindowAttributes_t::fAllEventMasks. set of events all people have interest in ; Definition at line 131 of file GuiTypes.h. ◆ fBackingPixel. ULong_t WindowAttributes_t::fBackingPixel. value to be used when restoring planes ; Definition at line 126 of file GuiTypes.h. ◆ fBackingPlanes. ULong_t WindowAttributes_t::fBackingPlanes. planes to be preserved if possible ; ",MatchSource.WIKI,doc/master/structWindowAttributes__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structWindowAttributes__t.html
Deployability,install,installed,". ROOT: WindowAttributes_t Struct Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; WindowAttributes_t Struct Reference. ; Window attributes that can be inquired. ; Definition at line 114 of file GuiTypes.h. Public Attributes; Long_t fAllEventMasks;  set of events all people have interest in ;  ; ULong_t fBackingPixel;  value to be used when restoring planes ;  ; ULong_t fBackingPlanes;  planes to be preserved if possible ;  ; Int_t fBackingStore;  kNotUseful, kWhenMapped, kAlways ;  ; Int_t fBitGravity;  one of bit gravity values ;  ; Int_t fBorderWidth;  border width of window ;  ; Int_t fClass;  kInputOutput, kInputOnly ;  ; Colormap_t fColormap;  color map to be associated with window ;  ; Int_t fDepth;  depth of window ;  ; Long_t fDoNotPropagateMask;  set of events that should not propagate ;  ; Int_t fHeight;  width and height of window ;  ; Bool_t fMapInstalled;  boolean, is color map currently installed ;  ; Int_t fMapState;  kIsUnmapped, kIsUnviewable, kIsViewable ;  ; Bool_t fOverrideRedirect;  boolean value for override-redirect ;  ; Window_t fRoot;  root of screen containing window ;  ; Bool_t fSaveUnder;  boolean, should bits under be saved? ;  ; void * fScreen;  back pointer to correct screen ;  ; void * fVisual;  the associated visual structure ;  ; Int_t fWidth;  ; Int_t fWinGravity;  one of the window gravity values ;  ; Int_t fX;  ; Int_t fY;  location of window ;  ; Long_t fYourEventMask;  my event mask ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fAllEventMasks. Long_t WindowAttributes_t::fAllEventMasks. set of events all people have interest in ; Definition at line 131 of file GuiTypes.h. ◆ fBackingPixel. ULong_t WindowAttributes_t::fBackingPixel. value to be used when restoring planes ; Definition at line 126 of file GuiTypes.h. ◆ fBackingPlanes. ULong_t WindowAttributes_t::fBackingPlanes. planes to be preserved if possible ; ",MatchSource.WIKI,doc/master/structWindowAttributes__t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/structWindowAttributes__t.html
Availability,error,error,". ROOT: math/smatrix/inc/Math/SVector.icc Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. SVector.icc. Go to the documentation of this file. 1// @(#)root/smatrix:$Id$; 2// Authors: T. Glebe, L. Moneta 2005; 3 ; 4#ifndef ROOT_Math_SVector_icc; 5#define ROOT_Math_SVector_icc; 6// ********************************************************************; 7//; 8// source:; 9//; 10// type: source code; 11//; 12// created: 21. Mar 2001; 13//; 14// author: Thorsten Glebe; 15// HERA-B Collaboration; 16// Max-Planck-Institut fuer Kernphysik; 17// Saupfercheckweg 1; 18// 69117 Heidelberg; 19// Germany; 20// E-mail: T.Glebe@mpi-hd.mpg.de; 21//; 22// Description: A fixed size Vector class; 23//; 24// changes:; 25// 21 Mar 2001 (TG) creation; 26// 26 Mar 2001 (TG) added place_at(); 27// 06 Apr 2001 (TG) CTORS added; 28// 07 Apr 2001 (TG) CTORS added; 29// 22 Aug 2001 (TG) CTOR(T*,len) added; 30// 14 Jan 2002 (TG) added operator==(), operator!=(), operator>(), operator<(); 31//; 32// ********************************************************************; 33 ; 34#ifndef ROOT_Math_SVector; 35#error ""Do not use SVector.icc directly. #include \""Math/SVector.h\"" instead.""; 36#endif // ROOT_Math_SVector; 37 ; 38#include <iostream>; 39#include <assert.h>; 40#include <algorithm>; 41 ; 42#include ""Math/StaticCheck.h""; 43 ; 44namespace ROOT {; 45 ; 46namespace Math {; 47 ; 48 ; 49//==============================================================================; 50// Constructors; 51//==============================================================================; 52template <class T, unsigned int D>; 53SVector<T,D>::SVector() {; 54 for(unsigned int i=0; i<D; ++i); 55 fArray[i] = 0;; 56}; 57 ; 58template <class T, unsigned int D>; 59template <class A>; 60SVector<T,D>::SVector(const VecExpr<A,T,D>& rhs) {; 61 operator=(rhs);; 62}; 63 ; 64template <class T, unsigned int D>; 65SVector<T,D>::SVector(const SVector<T,D>& rhs) {; 66 for(unsigned int i=0; i<D; ++",MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
Integrability,interface,interfaces,,MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
Security,access,access,"Iterator>; 571void SVector<T,D>::SetElements(InputIterator ibegin, unsigned int size) {; 572 // size <= vector size; 573 assert( size <= D);; 574 std::copy(ibegin, ibegin+size, fArray);; 575}; 576 ; 577 ; 578//==============================================================================; 579// Operators; 580//==============================================================================; 581template <class T, unsigned int D>; 582inline const T& SVector<T,D>::operator[](unsigned int i) const { return fArray[i]; }; 583 ; 584template <class T, unsigned int D>; 585inline const T& SVector<T,D>::operator()(unsigned int i) const { return fArray[i]; }; 586 ; 587template <class T, unsigned int D>; 588inline T& SVector<T,D>::operator[](unsigned int i) { return fArray[i]; }; 589 ; 590template <class T, unsigned int D>; 591inline T& SVector<T,D>::operator()(unsigned int i) { return fArray[i]; }; 592//==============================================================================; 593// Element access with At(); 594//==============================================================================; 595template <class T, unsigned int D>; 596inline const T& SVector<T,D>::At(unsigned int i) const {; 597 assert(i < D);; 598 return fArray[i];; 599}; 600 ; 601template <class T, unsigned int D>; 602inline T& SVector<T,D>::At(unsigned int i) {; 603 assert(i < D);; 604 return fArray[i];; 605}; 606 ; 607//==============================================================================; 608// SubVector; 609//==============================================================================; 610template <class T, unsigned int D>; 611template <class SubVector>; 612SubVector SVector<T,D>::Sub(unsigned int row) const {; 613 ; 614 STATIC_CHECK( SubVector::kSize <= D,SVector_dimension_too_small);; 615 ; 616 assert(row + SubVector::kSize <= D);; 617 ; 618 SubVector tmp;; 619 // need to use std::copy ??; 620 for(unsigned int i=0; i < SubVector::kSize; ++i) {; 621 tmp[i] = fArray[i+row];; 622 }; 623 return t",MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
Testability,assert,assert,"05; 3 ; 4#ifndef ROOT_Math_SVector_icc; 5#define ROOT_Math_SVector_icc; 6// ********************************************************************; 7//; 8// source:; 9//; 10// type: source code; 11//; 12// created: 21. Mar 2001; 13//; 14// author: Thorsten Glebe; 15// HERA-B Collaboration; 16// Max-Planck-Institut fuer Kernphysik; 17// Saupfercheckweg 1; 18// 69117 Heidelberg; 19// Germany; 20// E-mail: T.Glebe@mpi-hd.mpg.de; 21//; 22// Description: A fixed size Vector class; 23//; 24// changes:; 25// 21 Mar 2001 (TG) creation; 26// 26 Mar 2001 (TG) added place_at(); 27// 06 Apr 2001 (TG) CTORS added; 28// 07 Apr 2001 (TG) CTORS added; 29// 22 Aug 2001 (TG) CTOR(T*,len) added; 30// 14 Jan 2002 (TG) added operator==(), operator!=(), operator>(), operator<(); 31//; 32// ********************************************************************; 33 ; 34#ifndef ROOT_Math_SVector; 35#error ""Do not use SVector.icc directly. #include \""Math/SVector.h\"" instead.""; 36#endif // ROOT_Math_SVector; 37 ; 38#include <iostream>; 39#include <assert.h>; 40#include <algorithm>; 41 ; 42#include ""Math/StaticCheck.h""; 43 ; 44namespace ROOT {; 45 ; 46namespace Math {; 47 ; 48 ; 49//==============================================================================; 50// Constructors; 51//==============================================================================; 52template <class T, unsigned int D>; 53SVector<T,D>::SVector() {; 54 for(unsigned int i=0; i<D; ++i); 55 fArray[i] = 0;; 56}; 57 ; 58template <class T, unsigned int D>; 59template <class A>; 60SVector<T,D>::SVector(const VecExpr<A,T,D>& rhs) {; 61 operator=(rhs);; 62}; 63 ; 64template <class T, unsigned int D>; 65SVector<T,D>::SVector(const SVector<T,D>& rhs) {; 66 for(unsigned int i=0; i<D; ++i); 67 fArray[i] = rhs.fArray[i];; 68}; 69 ; 70 ; 71 ; 72//==============================================================================; 73// New Constructors from STL interfaces; 74//===============================================================",MatchSource.WIKI,doc/master/SVector_8icc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/SVector_8icc_source.html
Availability,avail,available,"clude ""TApplication.h""; 24#include ""TException.h""; 25#include ""TGuiFactory.h""; 26#include ""TVirtualX.h""; 27#include ""TROOT.h""; 28#include ""TSystem.h""; 29#include ""TString.h""; 30#include ""TError.h""; 31#include ""TObjArray.h""; 32#include ""TObjString.h""; 33#include ""TTimer.h""; 34#include ""TInterpreter.h""; 35#include ""TStyle.h""; 36#include ""TVirtualPad.h""; 37#include ""TEnv.h""; 38#include ""TColor.h""; 39#include ""TPluginManager.h""; 40#include ""TClassTable.h""; 41#include ""TBrowser.h""; 42#include ""TUrl.h""; 43#include ""TVirtualMutex.h""; 44#include ""TClassEdit.h""; 45#include ""TMethod.h""; 46#include ""TDataMember.h""; 47#include ""TApplicationCommandLineOptionsHelp.h""; 48#include ""TPRegexp.h""; 49#include <cstdlib>; 50#include <iostream>; 51#include <fstream>; 52 ; 53TApplication *gApplication = nullptr;; 54Bool_t TApplication::fgGraphNeeded = kFALSE;; 55Bool_t TApplication::fgGraphInit = kFALSE;; 56TList *TApplication::fgApplications = nullptr; // List of available applications; 57 ; 58////////////////////////////////////////////////////////////////////////////////; 59 ; 60class TIdleTimer : public TTimer {; 61public:; 62 TIdleTimer(Long_t ms) : TTimer(ms, kTRUE) {}; 63 Bool_t Notify() override;; 64};; 65 ; 66////////////////////////////////////////////////////////////////////////////////; 67/// Notify handler.; 68 ; 69Bool_t TIdleTimer::Notify(); 70{; 71 gApplication->HandleIdleTimer();; 72 Reset();; 73 return kFALSE;; 74}; 75 ; 76 ; 77ClassImp(TApplication);; 78 ; 79static void CallEndOfProcessCleanups(); 80{; 81 // Insure that the files, canvases and sockets are closed.; 82 ; 83 // If we get here, the tear down has started. We have no way to know what; 84 // has or has not yet been done. In particular on Ubuntu, this was called; 85 // after the function static in TSystem.cxx has been destructed. So we; 86 // set gROOT in its end-of-life mode which prevents executing code, like; 87 // autoloading libraries (!) that is pointless ...; 88 if (gROOT) {; 89 gROOT->SetBit(kInvalidObjec",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
Deployability,patch,patches,"b should have opened in your browser."");; 658}; 659 ; 660namespace {; 661enum EUrl { kURLforClass, kURLforNameSpace, kURLforStruct };; 662////////////////////////////////////////////////////////////////////////////////; 663/// The function generates a URL address for class or namespace (scopeName).; 664/// This is the URL to the online reference guide, generated by Doxygen.; 665/// With the enumeration ""EUrl"" we pick which case we need - the one for; 666/// class (kURLforClass) or the one for namespace (kURLforNameSpace).; 667///; 668/// \param[in] scopeName the name of the class or the namespace; 669/// \param[in] scopeType the enumerator for class or namespace; 670 ; 671static TString UrlGenerator(TString scopeName, EUrl scopeType); 672{; 673 // We start the URL with a static part, the same for all scopes and members.; 674 TString url = ""https://root.cern/doc/"";; 675 // Then we check the ROOT version used.; 676 TPRegexp re4(R""(.*/(v\d)-(\d\d)-00-patches)"");; 677 const char *branchName = gROOT->GetGitBranch();; 678 TObjArray *objarr = re4.MatchS(branchName);; 679 TString version;; 680 // We extract the correct version name for the URL.; 681 if (objarr && objarr->GetEntries() == 3) {; 682 // We have a valid version of ROOT and we will extract the correct name for the URL.; 683 version = ((TObjString *)objarr->At(1))->GetString() + ((TObjString *)objarr->At(2))->GetString();; 684 } else {; 685 // If it's not a supported version, we will go to ""master"" branch.; 686 version = ""master"";; 687 }; 688 delete objarr;; 689 url.Append(version);; 690 url.Append(""/"");; 691 // We will replace all ""::"" with ""_1_1"" and all ""_"" with ""__"" in the; 692 // classes definitions, due to Doxygen syntax requirements.; 693 scopeName.ReplaceAll(""_"", ""__"");; 694 scopeName.ReplaceAll(""::"", ""_1_1"");; 695 // We build the URL for the correct scope type and name.; 696 if (scopeType == kURLforClass) {; 697 url.Append(""class"");; 698 } else if (scopeType == kURLforStruct) {; 699 url.Append(""struct"");;",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
Energy Efficiency,allocate,allocated,"/ttf/lib.; 256 const char *ttpath = gEnv->GetValue(""Root.TTFontPath"",; 257 TROOT::GetTTFFontDir());; 258 char *ttfont = gSystem->Which(ttpath, ""arialbd.ttf"", kReadPermission);; 259 // Check for use of DFSG - fonts; 260 if (!ttfont); 261 ttfont = gSystem->Which(ttpath, ""FreeSansBold.ttf"", kReadPermission);; 262 ; 263 #if !defined(R__WIN32); 264 if (!gROOT->IsBatch() && !strcmp(gVirtualX->GetName(), ""X11"") &&; 265 ttfont && gEnv->GetValue(""Root.UseTTFonts"", 1)) {; 266 if (gClassTable->GetDict(""TGX11TTF"")) {; 267 // in principle we should not have linked anything against libGX11TTF; 268 // but with ACLiC this can happen, initialize TGX11TTF by hand; 269 // (normally this is done by the static library initializer); 270 ProcessLine(""TGX11TTF::Activate();"");; 271 } else {; 272 TPluginHandler *h;; 273 if ((h = gROOT->GetPluginManager()->FindHandler(""TVirtualX"", ""x11ttf""))); 274 if (h->LoadPlugin() == -1); 275 Info(""InitializeGraphics"", ""no TTF support"");; 276 }; 277 }; 278 #endif; 279 delete [] ttfont;; 280 }; 281 ; 282 if (!only_web || !fAppImp) {; 283 // Create WM dependent application environment; 284 if (fAppImp); 285 delete fAppImp;; 286 fAppImp = gGuiFactory->CreateApplicationImp(gROOT->GetName(), &fArgc, fArgv);; 287 if (!fAppImp) {; 288 MakeBatch();; 289 fAppImp = gGuiFactory->CreateApplicationImp(gROOT->GetName(), &fArgc, fArgv);; 290 }; 291 }; 292 ; 293 // Create the canvas colors early so they are allocated before; 294 // any color table expensive bitmaps get allocated in GUI routines (like; 295 // creation of XPM bitmaps).; 296 TColor::InitializeColors();; 297 ; 298 // Hook for further initializing the WM dependent application environment; 299 Init();; 300 ; 301 // Set default screen factor (if not disabled in rc file); 302 if (!only_web && gEnv->GetValue(""Canvas.UseScreenFactor"", 1)) {; 303 Int_t x, y;; 304 UInt_t w, h;; 305 if (gVirtualX) {; 306 gVirtualX->GetGeometry(-1, x, y, w, h);; 307 if (h > 0); 308 gStyle->SetScreenFactor(0.001 * h);; 309 }; 310 }; 311",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
Integrability,interface,interfaces,". ROOT: core/base/src/TApplication.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TApplication.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Fons Rademakers 22/12/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TApplication; 13\ingroup Base; 14 ; 15This class creates the ROOT Application Environment that interfaces; 16to the windowing system eventloop and eventhandlers.; 17This class must be instantiated exactly once in any given; 18application. Normally the specific application class inherits from; 19TApplication (see TRint).; 20*/; 21 ; 22#include ""RConfigure.h""; 23#include ""TApplication.h""; 24#include ""TException.h""; 25#include ""TGuiFactory.h""; 26#include ""TVirtualX.h""; 27#include ""TROOT.h""; 28#include ""TSystem.h""; 29#include ""TString.h""; 30#include ""TError.h""; 31#include ""TObjArray.h""; 32#include ""TObjString.h""; 33#include ""TTimer.h""; 34#include ""TInterpreter.h""; 35#include ""TStyle.h""; 36#include ""TVirtualPad.h""; 37#include ""TEnv.h""; 38#include ""TColor.h""; 39#include ""TPluginManager.h""; 40#include ""TClassTable.h""; 41#include ""TBrowser.h""; 42#include ""TUrl.h""; 43#include ""TVirtualMutex.h""; 44#include ""TClassEdit.h""; 45#include ""TMethod.h""; 46#include ""TDataMember.h""; 47#include ""TApplicationCommandLineOptionsHelp.h""; 48#include ""TPRegexp.h""; 49#include <cstdlib>; 50#include <iostream>; 51#include <fstream>; 52 ; 53TApplication *gApplication = nullptr;; 54Bool_t TApplication::fgGraphNeeded = kFALSE;; 55Bool_t TApplication::fgGraphInit = kFALSE;; 56TList *TApplication::fgApplications = nullptr; // List of available applications; 57 ; 58////",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
Modifiability,inherit,inherits,". ROOT: core/base/src/TApplication.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TApplication.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Fons Rademakers 22/12/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TApplication; 13\ingroup Base; 14 ; 15This class creates the ROOT Application Environment that interfaces; 16to the windowing system eventloop and eventhandlers.; 17This class must be instantiated exactly once in any given; 18application. Normally the specific application class inherits from; 19TApplication (see TRint).; 20*/; 21 ; 22#include ""RConfigure.h""; 23#include ""TApplication.h""; 24#include ""TException.h""; 25#include ""TGuiFactory.h""; 26#include ""TVirtualX.h""; 27#include ""TROOT.h""; 28#include ""TSystem.h""; 29#include ""TString.h""; 30#include ""TError.h""; 31#include ""TObjArray.h""; 32#include ""TObjString.h""; 33#include ""TTimer.h""; 34#include ""TInterpreter.h""; 35#include ""TStyle.h""; 36#include ""TVirtualPad.h""; 37#include ""TEnv.h""; 38#include ""TColor.h""; 39#include ""TPluginManager.h""; 40#include ""TClassTable.h""; 41#include ""TBrowser.h""; 42#include ""TUrl.h""; 43#include ""TVirtualMutex.h""; 44#include ""TClassEdit.h""; 45#include ""TMethod.h""; 46#include ""TDataMember.h""; 47#include ""TApplicationCommandLineOptionsHelp.h""; 48#include ""TPRegexp.h""; 49#include <cstdlib>; 50#include <iostream>; 51#include <fstream>; 52 ; 53TApplication *gApplication = nullptr;; 54Bool_t TApplication::fgGraphNeeded = kFALSE;; 55Bool_t TApplication::fgGraphInit = kFALSE;; 56TList *TApplication::fgApplications = nullptr; // List of available applications; 57 ; 58////",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
Performance,load,loaded,"ing closed after the; 220 // end of 'main' (or more exactly before the library start being; 221 // unloaded).; 222 if (fgApplications == nullptr || fgApplications->FirstLink() == nullptr ) {; 223 TROOT::ShutDown();; 224 }; 225 ; 226 // Now that all the canvases and files have been closed we can; 227 // delete the implementation.; 228 SafeDelete(fAppImp);; 229}; 230 ; 231////////////////////////////////////////////////////////////////////////////////; 232/// Static method. This method should be called from static library; 233/// initializers if the library needs the low level graphics system.; 234 ; 235void TApplication::NeedGraphicsLibs(); 236{; 237 fgGraphNeeded = kTRUE;; 238}; 239 ; 240////////////////////////////////////////////////////////////////////////////////; 241/// Initialize the graphics environment.; 242/// If @param only_web is specified, only web-related part of graphics is loaded; 243 ; 244void TApplication::InitializeGraphics(Bool_t only_web); 245{; 246 if (fgGraphInit || !fgGraphNeeded); 247 return;; 248 ; 249 if (!only_web) {; 250 // Load the graphics related libraries; 251 LoadGraphicsLibs();; 252 ; 253 // Try to load TrueType font renderer. Only try to load if not in batch; 254 // mode and Root.UseTTFonts is true and Root.TTFontPath exists. Abort silently; 255 // if libttf or libGX11TTF are not found in $ROOTSYS/lib or $ROOTSYS/ttf/lib.; 256 const char *ttpath = gEnv->GetValue(""Root.TTFontPath"",; 257 TROOT::GetTTFFontDir());; 258 char *ttfont = gSystem->Which(ttpath, ""arialbd.ttf"", kReadPermission);; 259 // Check for use of DFSG - fonts; 260 if (!ttfont); 261 ttfont = gSystem->Which(ttpath, ""FreeSansBold.ttf"", kReadPermission);; 262 ; 263 #if !defined(R__WIN32); 264 if (!gROOT->IsBatch() && !strcmp(gVirtualX->GetName(), ""X11"") &&; 265 ttfont && gEnv->GetValue(""Root.UseTTFonts"", 1)) {; 266 if (gClassTable->GetDict(""TGX11TTF"")) {; 267 // in principle we should not have linked anything against libGX11TTF; 268 // but with ACLiC this can happen, initi",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
Safety,risk,risk,"Application has been created; 183 gSystem->NotifyApplicationCreated();; 184 ; 185 fAppImp = gGuiFactory->CreateApplicationImp(appClassName, argc, argv);; 186 ResetBit(kProcessRemotely);; 187 ; 188 // Initialize the graphics environment; 189 if (gClassTable->GetDict(""TPad"")) {; 190 fgGraphNeeded = kTRUE;; 191 InitializeGraphics(gROOT->IsWebDisplay());; 192 }; 193 ; 194 // Save current interpreter context; 195 gInterpreter->SaveContext();; 196 gInterpreter->SaveGlobalsContext();; 197 ; 198 // to allow user to interact with TCanvas's under WIN32; 199 gROOT->SetLineHasBeenProcessed();; 200 ; 201 //Needs to be done last; 202 gApplication = this;; 203 gROOT->SetApplication(this);; 204 ; 205}; 206 ; 207////////////////////////////////////////////////////////////////////////////////; 208/// TApplication dtor.; 209 ; 210TApplication::~TApplication(); 211{; 212 for (int i = 0; i < fArgc; i++); 213 if (fArgv[i]) delete [] fArgv[i];; 214 delete [] fArgv;; 215 ; 216 if (fgApplications); 217 fgApplications->Remove(this);; 218 ; 219 // Reduce the risk of the files or sockets being closed after the; 220 // end of 'main' (or more exactly before the library start being; 221 // unloaded).; 222 if (fgApplications == nullptr || fgApplications->FirstLink() == nullptr ) {; 223 TROOT::ShutDown();; 224 }; 225 ; 226 // Now that all the canvases and files have been closed we can; 227 // delete the implementation.; 228 SafeDelete(fAppImp);; 229}; 230 ; 231////////////////////////////////////////////////////////////////////////////////; 232/// Static method. This method should be called from static library; 233/// initializers if the library needs the low level graphics system.; 234 ; 235void TApplication::NeedGraphicsLibs(); 236{; 237 fgGraphNeeded = kTRUE;; 238}; 239 ; 240////////////////////////////////////////////////////////////////////////////////; 241/// Initialize the graphics environment.; 242/// If @param only_web is specified, only web-related part of graphics is loaded; 243 ; 244voi",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
Security,access,accessed,,MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
Usability,guid,guide,"browser on Windows.; 640 TString cWindows(""start \""\"" "");; 641 cWindows.Append(url);; 642 gSystem->Exec(cWindows);; 643#else; 644 // Command for opening a browser in Linux.; 645 TString cLinux(""xdg-open "");; 646 // For Linux we check if the DISPLAY is set.; 647 if (gSystem->Getenv(""DISPLAY"")) {; 648 // If the DISPLAY is set it will open the browser.; 649 cLinux.Append(url);; 650 gSystem->Exec(cLinux);; 651 } else {; 652 // Else the user will have a warning and the URL in the terminal.; 653 Warning(""OpenInBrowser"", ""The $DISPLAY is not set! Please open (e.g. Ctrl-click) %s\n"", url.Data());; 654 return;; 655 }; 656#endif; 657 Info(""OpenInBrowser"", ""A new tab should have opened in your browser."");; 658}; 659 ; 660namespace {; 661enum EUrl { kURLforClass, kURLforNameSpace, kURLforStruct };; 662////////////////////////////////////////////////////////////////////////////////; 663/// The function generates a URL address for class or namespace (scopeName).; 664/// This is the URL to the online reference guide, generated by Doxygen.; 665/// With the enumeration ""EUrl"" we pick which case we need - the one for; 666/// class (kURLforClass) or the one for namespace (kURLforNameSpace).; 667///; 668/// \param[in] scopeName the name of the class or the namespace; 669/// \param[in] scopeType the enumerator for class or namespace; 670 ; 671static TString UrlGenerator(TString scopeName, EUrl scopeType); 672{; 673 // We start the URL with a static part, the same for all scopes and members.; 674 TString url = ""https://root.cern/doc/"";; 675 // Then we check the ROOT version used.; 676 TPRegexp re4(R""(.*/(v\d)-(\d\d)-00-patches)"");; 677 const char *branchName = gROOT->GetGitBranch();; 678 TObjArray *objarr = re4.MatchS(branchName);; 679 TString version;; 680 // We extract the correct version name for the URL.; 681 if (objarr && objarr->GetEntries() == 3) {; 682 // We have a valid version of ROOT and we will extract the correct name for the URL.; 683 version = ((TObjString *)objarr->At(1))-",MatchSource.WIKI,doc/master/TApplication_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html
Availability,avail,available,"rn from Run(); 63 Bool_t fNoLog; //Do not process logon and logoff macros; 64 Bool_t fNoLogo; //Do not show splash screen and welcome message; 65 Bool_t fQuit; //Exit after having processed input files; 66 TObjArray *fFiles; //Array of input files or C++ expression (TObjString's) specified via argv; 67 TString fWorkDir; //Working directory specified via argv; 68 TString fIdleCommand; //Command to execute while application is idle; 69 TTimer *fIdleTimer; //Idle timer; 70 TSignalHandler *fSigHandler; //Interrupt handler; 71 EExitOnException fExitOnException; //Exit on exception option; 72 ; 73 static Bool_t fgGraphNeeded; // True if graphics libs need to be initialized; 74 static Bool_t fgGraphInit; // True if graphics libs initialized; 75 ; 76 TApplication(const TApplication&) = delete;; 77 TApplication& operator=(const TApplication&) = delete;; 78 ; 79protected:; 80 TApplication *fAppRemote; //Current remote application, if defined; 81 ; 82 static TList *fgApplications; //List of available applications; 83 ; 84 TApplication();; 85 ; 86 virtual Longptr_t ProcessRemote(const char *line, Int_t *error = nullptr);; 87 virtual void Forum(const char *line);; 88 virtual void GitHub(const char *line);; 89 virtual void Help(const char *line);; 90 virtual void LoadGraphicsLibs();; 91 virtual void MakeBatch();; 92 void SetSignalHandler(TSignalHandler *sh) { fSigHandler = sh; }; 93 ; 94 static Int_t ParseRemoteLine(const char *ln,; 95 TString &hostdir, TString &user,; 96 Int_t &dbg, TString &script);; 97 static TApplication *Open(const char *url, Int_t debug, const char *script);; 98 static void Close(TApplication *app);; 99 ; 100public:; 101 TApplication(const char *appClassName, Int_t *argc, char **argv,; 102 void *options = nullptr, Int_t numOptions = 0);; 103 virtual ~TApplication();; 104 ; 105 void InitializeGraphics(Bool_t only_web = kFALSE);; 106 virtual void GetOptions(Int_t *argc, char **argv);; 107 TSignalHandler *GetSignalHandler() const { return fSigHandler; }; 108 v",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
Deployability,install,installation,"on::operator=TApplication & operator=(const TApplication &)=delete; TApplication::NeedGraphicsLibsstatic void NeedGraphicsLibs()Static method.Definition TApplication.cxx:235; TApplication::ParseRemoteLinestatic Int_t ParseRemoteLine(const char *ln, TString &hostdir, TString &user, Int_t &dbg, TString &script)Parse the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1419; TApplication::fIdleTimerTTimer * fIdleTimerDefinition TApplication.h:69; TApplication::IsCmdThreadvirtual Bool_t IsCmdThread()Definition TApplication.h:135; TApplication::lsvoid ls(Option_t *option="""") const overrideShow available sessions.Definition TApplication.cxx:2087; TApplication::Raisevirtual void Raise()Definition TApplication.h:133; TApplication::fArgcInt_t fArgcDefinition TApplication.h:58; TApplication::fNoLogBool_t fNoLogDefinition TApplication.h:63; TApplication::fNoLogoBool_t fNoLogoDefinition TApplication.h:64; TApplication::GetSetupTString GetSetup()It gets the ROOT installation setup as TString.Definition TApplication.cxx:967; TApplication::HandleIdleTimervirtual void HandleIdleTimer()Handle idle timeout.Definition TApplication.cxx:577; TApplication::WorkingDirectoryconst char * WorkingDirectory() constDefinition TApplication.h:147; TApplication::QuitOptBool_t QuitOpt() constDefinition TApplication.h:145; TApplication::fSigHandlerTSignalHandler * fSigHandlerDefinition TApplication.h:70; TApplication::ArgcInt_t Argc() constDefinition TApplication.h:140; TApplication::ProcessRemotevirtual Longptr_t ProcessRemote(const char *line, Int_t *error=nullptr)Process the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1485; TApplication::fAppRemoteTApplication * fAppRemoteDefinition TApplication.h:80; TApplication::Showvirtual void Show()Definition TApplication.h:129; TApplication::SetSignalHandlervoid SetSignalHandler(TSignalHandler *sh)Definition TApplication.h:92; TApplication::fArgvch",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
Integrability,interface,interfaces,". ROOT: core/base/inc/TApplication.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TApplication.h. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Fons Rademakers 22/12/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TApplication; 13#define ROOT_TApplication; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TApplication //; 19// //; 20// This class creates the ROOT Application Environment that interfaces //; 21// to the windowing system eventloop and eventhandlers. //; 22// This class must be instantiated exactly once in any given //; 23// application. Normally the specific application class inherits from //; 24// TApplication (see TRint). //; 25// //; 26//////////////////////////////////////////////////////////////////////////; 27 ; 28#include ""TObject.h""; 29 ; 30#include ""TQObject.h""; 31 ; 32#include ""TApplicationImp.h""; 33 ; 34class TObjArray;; 35class TTimer;; 36class TSignalHandler;; 37 ; 38 ; 39class TApplication : public TObject, public TQObject {; 40 ; 41public:; 42 // TApplication specific bits; 43 enum EStatusBits {; 44 kProcessRemotely = BIT(15), // TRUE if this line has to be processed remotely; 45 kDefaultApplication = BIT(16) // TRUE if created via CreateApplication(); 46 };; 47 // TApplication specific bits for fFiles; 48 enum EFileBits {; 49 kExpression = BIT(14) // If the arguments is an expression rather than a file.; 50 };; 51 enum EExitOnException {; 52 kDontExit,; 53 kExit,; 54 kAbort; 55 };; 56 ; 57private:; 58 Int_t fArgc; //Number of com mand line arguments; 59 char **fArgv",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
Modifiability,inherit,inherits,"uide ; .  . Loading...; Searching...; No Matches. TApplication.h. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Fons Rademakers 22/12/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TApplication; 13#define ROOT_TApplication; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TApplication //; 19// //; 20// This class creates the ROOT Application Environment that interfaces //; 21// to the windowing system eventloop and eventhandlers. //; 22// This class must be instantiated exactly once in any given //; 23// application. Normally the specific application class inherits from //; 24// TApplication (see TRint). //; 25// //; 26//////////////////////////////////////////////////////////////////////////; 27 ; 28#include ""TObject.h""; 29 ; 30#include ""TQObject.h""; 31 ; 32#include ""TApplicationImp.h""; 33 ; 34class TObjArray;; 35class TTimer;; 36class TSignalHandler;; 37 ; 38 ; 39class TApplication : public TObject, public TQObject {; 40 ; 41public:; 42 // TApplication specific bits; 43 enum EStatusBits {; 44 kProcessRemotely = BIT(15), // TRUE if this line has to be processed remotely; 45 kDefaultApplication = BIT(16) // TRUE if created via CreateApplication(); 46 };; 47 // TApplication specific bits for fFiles; 48 enum EFileBits {; 49 kExpression = BIT(14) // If the arguments is an expression rather than a file.; 50 };; 51 enum EExitOnException {; 52 kDontExit,; 53 kExit,; 54 kAbort; 55 };; 56 ; 57private:; 58 Int_t fArgc; //Number of com mand line arguments; 59 char **fArgv; //Command line arguments; 60 TApplicationImp *fAppImp; //!Window system specifi",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
Performance,load,loads,"plication.cxx:1395; TApplication::OpenGitHubIssuevoid OpenGitHubIssue(const TString &type)It opens a GitHub issue in a web browser with prefilled ROOT version.Definition TApplication.cxx:1034; TApplication::Hidevirtual void Hide()Definition TApplication.h:130; TApplication::fReturnFromRunBool_t fReturnFromRunDefinition TApplication.h:62; TApplication::Initvirtual void Init()Definition TApplication.h:117; TApplication::fIdleCommandTString fIdleCommandDefinition TApplication.h:68; TApplication::Argvchar ** Argv() constDefinition TApplication.h:141; TApplication::fgGraphNeededstatic Bool_t fgGraphNeededDefinition TApplication.h:73; TApplication::Terminatevirtual void Terminate(Int_t status=0)Terminate the application by call TSystem::Exit() unless application has been told to return from Run...Definition TApplication.cxx:1927; TApplication::GetAppRemoteTApplication * GetAppRemote() constDefinition TApplication.h:150; TApplication::OpenInBrowservoid OpenInBrowser(const TString &url)The function generates and executes a command that loads the Doxygen URL in a browser.Definition TApplication.cxx:629; TApplication::ApplicationNamevirtual const char * ApplicationName() constDefinition TApplication.h:128; TApplication::Forumvirtual void Forum(const char *line)The function ("".forum <type>"") submits a new post on the ROOT forum via web browser.Definition TApplication.cxx:1165; TApplication::SetReturnFromRunvoid SetReturnFromRun(Bool_t ret)Definition TApplication.h:154; TApplication::fQuitBool_t fQuitDefinition TApplication.h:65; TApplication::TabCompletionHookvirtual Int_t TabCompletionHook(char *buf, int *pLoc, std::ostream &out)What to do when tab is pressed.Definition TApplication.cxx:1917; TApplication::fExitOnExceptionEExitOnException fExitOnExceptionDefinition TApplication.h:71; TApplication::GetApplicationImpvirtual TApplicationImp * GetApplicationImp()Definition TApplication.h:136; TApplication::fFilesTObjArray * fFilesDefinition TApplication.h:66; TApplication::GetIdl",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
Safety,timeout,timeout,"raphicsLibs()Static method.Definition TApplication.cxx:235; TApplication::ParseRemoteLinestatic Int_t ParseRemoteLine(const char *ln, TString &hostdir, TString &user, Int_t &dbg, TString &script)Parse the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1419; TApplication::fIdleTimerTTimer * fIdleTimerDefinition TApplication.h:69; TApplication::IsCmdThreadvirtual Bool_t IsCmdThread()Definition TApplication.h:135; TApplication::lsvoid ls(Option_t *option="""") const overrideShow available sessions.Definition TApplication.cxx:2087; TApplication::Raisevirtual void Raise()Definition TApplication.h:133; TApplication::fArgcInt_t fArgcDefinition TApplication.h:58; TApplication::fNoLogBool_t fNoLogDefinition TApplication.h:63; TApplication::fNoLogoBool_t fNoLogoDefinition TApplication.h:64; TApplication::GetSetupTString GetSetup()It gets the ROOT installation setup as TString.Definition TApplication.cxx:967; TApplication::HandleIdleTimervirtual void HandleIdleTimer()Handle idle timeout.Definition TApplication.cxx:577; TApplication::WorkingDirectoryconst char * WorkingDirectory() constDefinition TApplication.h:147; TApplication::QuitOptBool_t QuitOpt() constDefinition TApplication.h:145; TApplication::fSigHandlerTSignalHandler * fSigHandlerDefinition TApplication.h:70; TApplication::ArgcInt_t Argc() constDefinition TApplication.h:140; TApplication::ProcessRemotevirtual Longptr_t ProcessRemote(const char *line, Int_t *error=nullptr)Process the content of a line starting with "".R"" (already stripped-off) The format is.Definition TApplication.cxx:1485; TApplication::fAppRemoteTApplication * fAppRemoteDefinition TApplication.h:80; TApplication::Showvirtual void Show()Definition TApplication.h:129; TApplication::SetSignalHandlervoid SetSignalHandler(TSignalHandler *sh)Definition TApplication.h:92; TApplication::fArgvchar ** fArgvDefinition TApplication.h:59; TListA doubly linked list.Definition TList.h:38; TObjArrayAn array of TOb",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
Testability,log,logon,"; 50 };; 51 enum EExitOnException {; 52 kDontExit,; 53 kExit,; 54 kAbort; 55 };; 56 ; 57private:; 58 Int_t fArgc; //Number of com mand line arguments; 59 char **fArgv",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
Usability,guid,guide,"tion TApplication.cxx:1949; TApplication::ProcessLinevirtual Longptr_t ProcessLine(const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr)Process a single command line, either a C++ statement or an interpreter command starting with a ""....Definition TApplication.cxx:1565; TApplication::fgApplicationsstatic TList * fgApplicationsDefinition TApplication.h:82; TApplication::Closestatic void Close(TApplication *app)Static function used to close a remote application.Definition TApplication.cxx:2070; TApplication::HandleTermInputvirtual Bool_t HandleTermInput()Definition TApplication.h:116; TApplication::IsRunningBool_t IsRunning() constDefinition TApplication.h:152; TApplication::SetEchoModevirtual void SetEchoMode(Bool_t mode)Set console echo mode:Definition TApplication.cxx:1968; TApplication::InputFilesTObjArray * InputFiles() constDefinition TApplication.h:146; TApplication::Helpvirtual void Help(const char *line)The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxy...Definition TApplication.cxx:1208; TApplication::LineProcessedvirtual void LineProcessed(const char *line)Emit signal when a line has been processed.Definition TApplication.cxx:1941; TApplication::ClearInputFilesvoid ClearInputFiles()Clear list containing macro files passed as program arguments.Definition TApplication.cxx:318; TApplication::fAppImpTApplicationImp * fAppImpDefinition TApplication.h:60; TApplication::TApplicationTApplication(const TApplication &)=delete; TApplication::EExitOnExceptionEExitOnExceptionDefinition TApplication.h:51; TApplication::kDontExit@ kDontExitDefinition TApplication.h:52; TApplication::kAbort@ kAbortDefinition TApplication.h:54; TApplication::kExit@ kExitDefinition TApplication.h:53; TApplication::ExecuteFilestatic Longptr_t ExecuteFile(const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE)Execute a file containing a C++ macro (static method).Definition TApplication.cxx:1729; TApplication::GetSignalHandlerTSignalH",MatchSource.WIKI,doc/master/TApplication_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html
Usability,simpl,simple,"nge current fill area attributes if necessary.Definition TAttFill.cxx:216; TAttFill::SaveFillAttributesvirtual void SaveFillAttributes(std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1001)Save fill attributes as C++ statement(s) on output stream out.Definition TAttFill.cxx:239; TAttLine::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TAttLine::SetLineStylevirtual void SetLineStyle(Style_t lstyle)Set the line style.Definition TAttLine.h:42; TAttLine::Modifyvirtual void Modify()Change current line attributes if necessary.Definition TAttLine.cxx:247; TAttLine::Copyvoid Copy(TAttLine &attline) constCopy this line attributes to a new TAttLine.Definition TAttLine.cxx:177; TAttLine::SaveLineAttributesvirtual void SaveLineAttributes(std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1, Int_t widdef=1)Save line attributes as C++ statement(s) on output stream out.Definition TAttLine.cxx:275; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::fY1Double_t fY1Y of 1st point.Definition TLine.h:26; TLine::fX1Double_t fX1X of 1st point.Definition TLine.h:25; TLine::kLineNDC@ kLineNDCUse NDC coordinates.Definition TLine.h:33; TLine::Copyvoid Copy(TObject &line) const overrideCopy this line to line.Definition TLine.cxx:76; TLine::fX2Double_t fX2X of 2nd point.Definition TLine.h:27; TLine::fY2Double_t fY2Y of 2nd point.Definition TLine.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObj",MatchSource.WIKI,doc/master/TArrow_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TArrow_8cxx_source.html
Usability,simpl,simple,"ault constructor.Definition TArrow.cxx:47; TArrow::fAngleFloat_t fAngleArrow opening angle (degrees)Definition TArrow.h:31; TArrow::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TArrow.cxx:365; TArrow::SetOptionvirtual void SetOption(Option_t *option="">"")Definition TArrow.h:62; TArrow::fgDefaultOptionstatic TString fgDefaultOptionDefault Arrow shapes.Definition TArrow.h:37; TArrow::fOptionTString fOptionArrow shapes.Definition TArrow.h:33; TArrow::PaintArrowNDCvirtual void PaintArrowNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2, Float_t arrowsize=0.05, Option_t *option="">"")Draw this arrow with new coordinates in NDC.Definition TArrow.cxx:352; TArrow::PaintArrowvirtual void PaintArrow(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Float_t arrowsize=0.05, Option_t *option="">"")Draw this arrow with new coordinates.Definition TArrow.cxx:175; TArrow::~TArrow~TArrow() overrideArrow default destructor.Definition TArrow.cxx:91; TArrow::GetArrowSizeFloat_t GetArrowSize() constDefinition TArrow.h:52; TArrow::SetAnglevirtual void SetAngle(Float_t angle=60)Definition TArrow.h:60; TArrow::GetDefaultArrowSizestatic Float_t GetDefaultArrowSize()Get default arrow size.Definition TArrow.cxx:431; TArrow::Copyvoid Copy(TObject &arrow) const overrideCopy this arrow to arrow.Definition TArrow.cxx:108; TAttFillFill Area Attributes class.Definition TAttFill.h:19; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TObjectMother of all ROOT objects.Definition TObject.h:41; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; double; arrowDefinition RArrowDS.hxx:17; v2@ v2Definition rootcling_impl.cxx:3702; v1@ v1Definition rootcling_impl.cxx:3701; Drawth1 Draw(). graf2dgrafincTArrow.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:18 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TArrow_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TArrow_8h_source.html
Performance,optimiz,optimized,"//////////////////////////////////////////////////////////////////////; 187/// Set distance between the axis and the labels.; 188/// The distance is expressed in per cent of the pad width.; 189/// A negative value allow to draw the label on the other side of the axis.; 190 ; 191void TAttAxis::SetLabelOffset(Float_t offset); 192{; 193 fLabelOffset = offset;; 194 if (gPad) gPad->Modified();; 195}; 196 ; 197 ; 198////////////////////////////////////////////////////////////////////////////////; 199/// Set size of axis labels.; 200/// The size is expressed in per cent of the pad size, unless the font precision; 201/// is 3 and in that case the size is expressed in pixels.; 202 ; 203void TAttAxis::SetLabelSize(Float_t size); 204{; 205 fLabelSize = size;; 206 if (gPad) gPad->Modified();; 207}; 208 ; 209////////////////////////////////////////////////////////////////////////////////; 210/// Set the number of divisions for this axis.; 211///; 212/// - if optim = kTRUE (default), the number of divisions will be; 213/// optimized around the specified value.; 214/// - if optim = kFALSE, or n < 0, the axis will be forced to use; 215/// exactly n divisions.; 216///~~~ {.cpp}; 217/// n = n1 + 100*n2 + 10000*n3; 218///~~~; 219/// Where n1 is the number of primary divisions,; 220/// n2 is the number of second order divisions and; 221/// n3 is the number of third order divisions.; 222///; 223/// If the number of divisions is ""optimized"" (see above) n1, n2, n3 are; 224/// maximum values.; 225///; 226/// Examples:; 227///; 228/// - ndiv = 0: no tick marks.; 229/// - ndiv = 2: 2 divisions, one tick mark in the middle of the axis.; 230/// - ndiv = 510: 10 primary divisions, 5 secondary divisions.; 231/// - ndiv = -10: exactly 10 primary divisions.; 232 ; 233void TAttAxis::SetNdivisions(Int_t n, Bool_t optim); 234{; 235 Int_t ndiv = (n%1000000);; 236 Bool_t isOptimized = optim && (ndiv>0);; 237 Int_t current_maxDigits = abs(fNdivisions)/1000000;; 238 fNdivisions = abs(ndiv) + current_maxD",MatchSource.WIKI,doc/master/TAttAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttAxis_8cxx_source.html
Availability,avail,available,"ributes are:; 34 ; 35 - [Fill Area color](\ref ATTFILL1); 36 - [Fill Area style](\ref ATTFILL2); 37 ; 38\anchor ATTFILL1; 39## Fill Area color; 40The fill area color is a color index (integer) pointing in the ROOT; 41color table.; 42The fill area color of any class inheriting from `TAttFill` can; 43be changed using the method `SetFillColor` and retrieved using the; 44method `GetFillColor`.; 45The following table shows the first 50 default colors.; 46 ; 47Begin_Macro; 48{; 49 TCanvas *c = new TCanvas(""c"",""Fill Area colors"",0,0,500,200);; 50 c->DrawColorTable();; 51 return c;; 52}; 53End_Macro; 54 ; 55### Color transparency; 56`SetFillColorAlpha()`, allows to set a transparent color.; 57In the following example the fill color of the histogram `histo`; 58is set to blue with an opacity of 35% (i.e. a transparency of 65%).; 59(The color `kBlue` itself is internally stored as fully opaque.); 60 ; 61~~~ {.cpp}; 62histo->SetFillColorAlpha(kBlue, 0.35);; 63~~~; 64 ; 65The transparency is available on all platforms when the flag; 66`OpenGL.CanvasPreferGL` is set to `1` in `$ROOTSYS/etc/system.rootrc`, or on Mac; 67with the Cocoa backend.; 68On the file output it is visible with PDF, PNG, Gif, JPEG, SVG, TeX... but not PostScript.; 69 ; 70Alternatively, you can call at the top of your script `gSytle->SetCanvasPreferGL();`.; 71Or if you prefer to activate GL for a single canvas `c`, then use `c->SetSupportGL(true);`.; 72 ; 73### The ROOT Color Wheel.; 74The wheel contains the recommended 216 colors to be used in web applications.; 75The colors in the Color Wheel are created by TColor::CreateColorWheel.; 76 ; 77Using this color set for your text, background or graphics will give your; 78application a consistent appearance across different platforms and browsers.; 79 ; 80Colors are grouped by hue, the aspect most important in human perception; 81Touching color chips have the same hue, but with different brightness and vividness.; 82 ; 83Colors of slightly different hues _clash_. ",MatchSource.WIKI,doc/master/TAttFill_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttFill_8cxx_source.html
Modifiability,inherit,inheritance,". ROOT: core/base/src/TAttFill.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TAttFill.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Rene Brun 12/12/94; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include <iostream>; 13#include ""TAttFill.h""; 14#include ""TVirtualPad.h""; 15#include ""TStyle.h""; 16#include ""TVirtualX.h""; 17#include ""TVirtualPadEditor.h""; 18#include ""TColor.h""; 19 ; 20ClassImp(TAttFill);; 21 ; 22/** \class TAttFill; 23\ingroup Base; 24\ingroup GraphicsAtt; 25 ; 26Fill Area Attributes class.; 27 ; 28This class is used (in general by secondary inheritance); 29by many other classes (graphics, histograms). It holds all the fill area; 30attributes.; 31 ; 32## Fill Area attributes; 33Fill Area attributes are:; 34 ; 35 - [Fill Area color](\ref ATTFILL1); 36 - [Fill Area style](\ref ATTFILL2); 37 ; 38\anchor ATTFILL1; 39## Fill Area color; 40The fill area color is a color index (integer) pointing in the ROOT; 41color table.; 42The fill area color of any class inheriting from `TAttFill` can; 43be changed using the method `SetFillColor` and retrieved using the; 44method `GetFillColor`.; 45The following table shows the first 50 default colors.; 46 ; 47Begin_Macro; 48{; 49 TCanvas *c = new TCanvas(""c"",""Fill Area colors"",0,0,500,200);; 50 c->DrawColorTable();; 51 return c;; 52}; 53End_Macro; 54 ; 55### Color transparency; 56`SetFillColorAlpha()`, allows to set a transparent color.; 57In the following example the fill color of the histogram `histo`; 58is set to blue with an opacity of 35% (i.e. a transparency of 65%).; 59(The color `kBlue` itself is int",MatchSource.WIKI,doc/master/TAttFill_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttFill_8cxx_source.html
Availability,avail,available," are:; 35 ; 36 - [Line Color](\ref ATTLINE1); 37 - [Line Width](\ref ATTLINE2); 38 - [Line Style](\ref ATTLINE3); 39 ; 40\anchor ATTLINE1; 41## Line Color; 42The line color is a color index (integer) pointing in the ROOT; 43color table.; 44The line color of any class inheriting from `TAttLine` can; 45be changed using the method `SetLineColor` and retrieved using the; 46method `GetLineColor`.; 47The following table shows the first 50 default colors.; 48 ; 49Begin_Macro; 50{; 51 TCanvas *c = new TCanvas(""c"",""Fill Area colors"",0,0,500,200);; 52 c->DrawColorTable();; 53 return c;; 54}; 55End_Macro; 56 ; 57### Color transparency; 58`SetLineColorAlpha()`, allows to set a transparent color.; 59In the following example the line color of the histogram `histo`; 60is set to blue with an opacity of 35% (i.e. a transparency of 65%).; 61(The color `kBlue` itself is internally stored as fully opaque.); 62 ; 63~~~ {.cpp}; 64histo->SetLineColorAlpha(kBlue, 0.35);; 65~~~; 66 ; 67The transparency is available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1`; 68in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output; 69it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.; 70 ; 71Alternatively, you can call at the top of your script `gSytle->SetCanvasPreferGL();`.; 72Or if you prefer to activate GL for a single canvas `c`, then use `c->SetSupportGL(true);`.; 73 ; 74\anchor ATTLINE2; 75## Line Width; 76The line width is expressed in pixel units.; 77The line width of any class inheriting from `TAttLine` can; 78be changed using the method `SetLineWidth` and retrieved using the; 79method `GetLineWidth`.; 80The following picture shows the line widths from 1 to 10 pixels.; 81 ; 82Begin_Macro; 83{; 84 TCanvas *Lw = new TCanvas(""Lw"",""test"",500,200);; 85 TText t;; 86 t.SetTextAlign(32);; 87 t.SetTextSize(0.08);; 88 Int_t i=1;; 89 for (float s=0.1; s<1.0 ; s+=0.092) {; 90 TLine *lh = new TLine(0.15,s,.85,s);; 91 lh->SetLineWidth",MatchSource.WIKI,doc/master/TAttLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttLine_8cxx_source.html
Modifiability,inherit,inheritance,"AttLine.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TAttLine.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Rene Brun 28/11/94; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TAttLine.h""; 13#include ""TVirtualPad.h""; 14#include ""TStyle.h""; 15#include ""TVirtualX.h""; 16#include ""TVirtualPadEditor.h""; 17#include ""TColor.h""; 18#include <cmath>; 19#include <iostream>; 20 ; 21ClassImp(TAttLine);; 22using std::sqrt;; 23 ; 24/** \class TAttLine; 25\ingroup Base; 26\ingroup GraphicsAtt; 27 ; 28Line Attributes class.; 29 ; 30This class is used (in general by secondary inheritance); 31by many other classes (graphics, histograms). It holds all the line attributes.; 32 ; 33## Line attributes; 34Line attributes are:; 35 ; 36 - [Line Color](\ref ATTLINE1); 37 - [Line Width](\ref ATTLINE2); 38 - [Line Style](\ref ATTLINE3); 39 ; 40\anchor ATTLINE1; 41## Line Color; 42The line color is a color index (integer) pointing in the ROOT; 43color table.; 44The line color of any class inheriting from `TAttLine` can; 45be changed using the method `SetLineColor` and retrieved using the; 46method `GetLineColor`.; 47The following table shows the first 50 default colors.; 48 ; 49Begin_Macro; 50{; 51 TCanvas *c = new TCanvas(""c"",""Fill Area colors"",0,0,500,200);; 52 c->DrawColorTable();; 53 return c;; 54}; 55End_Macro; 56 ; 57### Color transparency; 58`SetLineColorAlpha()`, allows to set a transparent color.; 59In the following example the line color of the histogram `histo`; 60is set to blue with an opacity of 35% (i.e. a transparency of 65%).; 61(The color `kBlue` itself is",MatchSource.WIKI,doc/master/TAttLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttLine_8cxx_source.html
Security,access,accessed,"500,200);; 85 TText t;; 86 t.SetTextAlign(32);; 87 t.SetTextSize(0.08);; 88 Int_t i=1;; 89 for (float s=0.1; s<1.0 ; s+=0.092) {; 90 TLine *lh = new TLine(0.15,s,.85,s);; 91 lh->SetLineWidth(i);; 92 t.DrawText(0.1,s,Form(""%d"",i++));; 93 lh->Draw();; 94 }; 95}; 96End_Macro; 97 ; 98\anchor ATTLINE3; 99## Line Style; 100Line styles are identified via integer numbers. The line style of any class; 101inheriting from `TAttLine` can be changed using the method; 102`SetLineStyle` and retrieved using the method `GetLineStyle`.; 103 ; 104The first 10 line styles are predefined as shown on the following picture:; 105 ; 106Begin_Macro; 107{; 108 TCanvas *Ls = new TCanvas(""Ls"",""test"",500,200);; 109 TText t;; 110 t.SetTextAlign(32);; 111 t.SetTextSize(0.08);; 112 Int_t i=1;; 113 for (float s=0.1; s<1.0 ; s+=0.092) {; 114 TLine *lh = new TLine(0.15,s,.85,s);; 115 lh->SetLineStyle(i);; 116 lh->SetLineWidth(3);; 117 t.DrawText(0.1,s,Form(""%d"",i++));; 118 lh->Draw();; 119 }; 120}; 121End_Macro; 122 ; 123Some line styles can be accessed via the following enum:; 124 ; 125~~~ {.cpp}; 126 kSolid = 1; 127 kDashed = 2; 128 kDotted = 3; 129 kDashDotted = 4; 130~~~; 131 ; 132Additional line styles can be defined using `TStyle::SetLineStyleString`.; 133For example the line style number 11 can be defined as follow:; 134~~~ {.cpp}; 135 gStyle->SetLineStyleString(11,""400 200"");; 136~~~; 137Existing line styles (1 to 10) can be redefined using the same method.; 138 */; 139 ; 140////////////////////////////////////////////////////////////////////////////////; 141/// AttLine default constructor.; 142 ; 143TAttLine::TAttLine(); 144{; 145 if (!gStyle) {fLineColor=1; fLineWidth=1; fLineStyle=1; return;}; 146 fLineColor = gStyle->GetLineColor();; 147 fLineWidth = gStyle->GetLineWidth();; 148 fLineStyle = gStyle->GetLineStyle();; 149}; 150 ; 151////////////////////////////////////////////////////////////////////////////////; 152/// AttLine normal constructor.; 153/// Line attributes are taking from the ",MatchSource.WIKI,doc/master/TAttLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttLine_8cxx_source.html
Testability,test,test,"ity of 35% (i.e. a transparency of 65%).; 61(The color `kBlue` itself is internally stored as fully opaque.); 62 ; 63~~~ {.cpp}; 64histo->SetLineColorAlpha(kBlue, 0.35);; 65~~~; 66 ; 67The transparency is available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1`; 68in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output; 69it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.; 70 ; 71Alternatively, you can call at the top of your script `gSytle->SetCanvasPreferGL();`.; 72Or if you prefer to activate GL for a single canvas `c`, then use `c->SetSupportGL(true);`.; 73 ; 74\anchor ATTLINE2; 75## Line Width; 76The line width is expressed in pixel units.; 77The line width of any class inheriting from `TAttLine` can; 78be changed using the method `SetLineWidth` and retrieved using the; 79method `GetLineWidth`.; 80The following picture shows the line widths from 1 to 10 pixels.; 81 ; 82Begin_Macro; 83{; 84 TCanvas *Lw = new TCanvas(""Lw"",""test"",500,200);; 85 TText t;; 86 t.SetTextAlign(32);; 87 t.SetTextSize(0.08);; 88 Int_t i=1;; 89 for (float s=0.1; s<1.0 ; s+=0.092) {; 90 TLine *lh = new TLine(0.15,s,.85,s);; 91 lh->SetLineWidth(i);; 92 t.DrawText(0.1,s,Form(""%d"",i++));; 93 lh->Draw();; 94 }; 95}; 96End_Macro; 97 ; 98\anchor ATTLINE3; 99## Line Style; 100Line styles are identified via integer numbers. The line style of any class; 101inheriting from `TAttLine` can be changed using the method; 102`SetLineStyle` and retrieved using the method `GetLineStyle`.; 103 ; 104The first 10 line styles are predefined as shown on the following picture:; 105 ; 106Begin_Macro; 107{; 108 TCanvas *Ls = new TCanvas(""Ls"",""test"",500,200);; 109 TText t;; 110 t.SetTextAlign(32);; 111 t.SetTextSize(0.08);; 112 Int_t i=1;; 113 for (float s=0.1; s<1.0 ; s+=0.092) {; 114 TLine *lh = new TLine(0.15,s,.85,s);; 115 lh->SetLineStyle(i);; 116 lh->SetLineWidth(3);; 117 t.DrawText(0.1,s,Form(""%d"",i++));; 118 lh->Draw();; 119 }; 120}; 121",MatchSource.WIKI,doc/master/TAttLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttLine_8cxx_source.html
Integrability,depend,dependency,". ROOT: core/base/inc/TAttLine.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; TAttLine.h File Reference. #include ""Rtypes.h"". Include dependency graph for TAttLine.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TAttLine;  Line Attributes class. More...;  . Enumerations; enum  ELineStyle { kSolid = 1; , kDashed; , kDotted; , kDashDotted; };  . Enumeration Type Documentation. ◆ ELineStyle. enum ELineStyle. EnumeratorkSolid ; kDashed ; kDotted ; kDashDotted . Definition at line 48 of file TAttLine.h. corebaseincTAttLine.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:12 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TAttLine_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttLine_8h.html
Availability,avail,available,"ef ATTMARKER2); 38 - [Marker line width](\ref ATTMARKER21); 39 - [Marker size](\ref M3); 40 ; 41\anchor ATTMARKER1; 42## Marker color; 43The marker color is a color index (integer) pointing in the ROOT color; 44table.; 45The marker color of any class inheriting from `TAttMarker` can; 46be changed using the method `SetMarkerColor` and retrieved using the; 47method `GetMarkerColor`.; 48The following table shows the first 50 default colors.; 49 ; 50Begin_Macro; 51{; 52 TCanvas *c = new TCanvas(""c"",""Fill Area colors"",0,0,500,200);; 53 c->DrawColorTable();; 54 return c;; 55}; 56End_Macro; 57 ; 58### Color transparency; 59 ; 60`SetMarkerColorAlpha()`, allows to set a transparent color.; 61In the following example the marker color of the histogram `histo`; 62is set to blue with an opacity of 35% (i.e. a transparency of 65%).; 63(The color `kBlue` itself is internally stored as fully opaque.); 64 ; 65~~~ {.cpp}; 66histo->SetMarkerColorAlpha(kBlue, 0.35);; 67~~~; 68 ; 69The transparency is available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1`; 70in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output; 71it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.; 72 ; 73Alternatively, you can call at the top of your script `gSytle->SetCanvasPreferGL();`.; 74Or if you prefer to activate GL for a single canvas `c`, then use `c->SetSupportGL(true);`.; 75 ; 76\anchor ATTMARKER2; 77## Marker style; 78 ; 79The Marker style defines the markers' shape.; 80The marker style of any class inheriting from `TAttMarker` can; 81be changed using the method `SetMarkerStyle` and retrieved using the; 82method `GetMarkerStyle`.; 83 ; 84The following list gives the currently supported markers (screen; 85and PostScript) style. Each marker style is identified by an integer number; 86(first column) corresponding to a marker shape (second column) and can be also; 87accessed via a global name (third column).; 88 ; 89~~~ {.cpp}; 90 Mark",MatchSource.WIKI,doc/master/TAttMarker_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttMarker_8cxx_source.html
Modifiability,inherit,inheritance,"src/TAttMarker.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TAttMarker.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Rene Brun 12/05/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include <iostream>; 13#include ""Strlen.h""; 14#include ""TAttMarker.h""; 15#include ""TVirtualPad.h""; 16#include ""TStyle.h""; 17#include ""TVirtualX.h""; 18#include ""TVirtualPadEditor.h""; 19#include ""TColor.h""; 20 ; 21ClassImp(TAttMarker);; 22 ; 23/** \class TAttMarker; 24\ingroup Base; 25\ingroup GraphicsAtt; 26 ; 27Marker Attributes class.; 28 ; 29This class is used (in general by secondary inheritance); 30by many other classes (graphics, histograms). It holds all the markers; 31attributes.; 32 ; 33## Marker attributes; 34The marker attributes are:; 35 ; 36 - [Marker color](\ref ATTMARKER1); 37 - [Marker style](\ref ATTMARKER2); 38 - [Marker line width](\ref ATTMARKER21); 39 - [Marker size](\ref M3); 40 ; 41\anchor ATTMARKER1; 42## Marker color; 43The marker color is a color index (integer) pointing in the ROOT color; 44table.; 45The marker color of any class inheriting from `TAttMarker` can; 46be changed using the method `SetMarkerColor` and retrieved using the; 47method `GetMarkerColor`.; 48The following table shows the first 50 default colors.; 49 ; 50Begin_Macro; 51{; 52 TCanvas *c = new TCanvas(""c"",""Fill Area colors"",0,0,500,200);; 53 c->DrawColorTable();; 54 return c;; 55}; 56End_Macro; 57 ; 58### Color transparency; 59 ; 60`SetMarkerColorAlpha()`, allows to set a transparent color.; 61In the following example the marker color of the histogram `histo`; 62is set to blue ",MatchSource.WIKI,doc/master/TAttMarker_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttMarker_8cxx_source.html
Performance,scalab,scalable,"reen; 85and PostScript) style. Each marker style is identified by an integer number; 86(first column) corresponding to a marker shape (second column) and can be also; 87accessed via a global name (third column).; 88 ; 89~~~ {.cpp}; 90 Marker number Marker shape Marker name; 91 1 dot kDot; 92 2 + kPlus; 93 3 * kStar; 94 4 o kCircle; 95 5 x kMultiply; 96 6 small dot kFullDotSmall; 97 7 medium dot kFullDotMedium; 98 8 large scalable dot kFullDotLarge; 99 9 -->19 large scalable dot; 100 20 full circle kFullCircle; 101 21 full square kFullSquare; 102 22 full triangle up kFullTriangleUp; 103 23 full triangle down kFullTriangleDown; 104 24 open circle kOpenCircle; 105 25 open square kOpenSquare; 106 26 open triangle up kOpenTriangleUp; 107 27 open diamond kOpenDiamond; 108 28 open cross kOpenCross; 109 29 full star kFullStar; 110 30 open star kOpenStar; 111 31 *; 112 32 open triangle down kOpenTriangleDown; 113 33 full diamond kFullDiamond; 114 34 full cross kFullCross; 115 35 open diamond cross kOpenDiamondCross; 116 36 open square diagonal kOpenSquareDiagonal; 117 37 open three triangle kOpenThreeTriangles; 118 38 octagon with cross kOctagonCross; 119 39 full three triangles kFullThreeTriangles; 120 40 open four triangleX kOpenFourTrianglesX; 121 41 full four triangleX kFullFourTrianglesX; 122 42 open double diamond kOpenDoubleDiamond; 123 43 full double diamond kFullDoubleDiamond; 124 44 open four triangle+ kOpenFourTrianglesPlus; 125 45 full four triangle+ kFullFourTrianglesPlus; 126 46 open cross X kOpenCrossX; 127 47 full cross X kFullCrossX; 128 48 four squares X kFourSquaresX; 129 49 four squares+ kFourSquaresPlus; 130~~~; 131 ; 132Begin_Macro; 133{; 134 TCanvas *c = new TCanvas(""c"",""Marker types"",0,0,500,200);; 135 TMarker marker;; 136 marker.DisplayMarkerTypes();; 137}; 138End_Macro; 139 ; 140\warning Non-symmetric symbols should be used carefully. See markerwarning.C; 141 ; 142\anchor ATTMARKER21; 143### Marker line width; 144 ; 145The line width of a marker is n",MatchSource.WIKI,doc/master/TAttMarker_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttMarker_8cxx_source.html
Integrability,depend,dependency,". ROOT: core/base/inc/TAttMarker.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; TAttMarker.h File Reference. #include ""Rtypes.h"". Include dependency graph for TAttMarker.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TAttMarker;  Marker Attributes class. More...;  . Enumerations; enum  EMarkerStyle { ;   kDot =1; , kPlus; , kStar; , kCircle =4; , ;   kMultiply =5; , kFullDotSmall =6; , kFullDotMedium =7; , kFullDotLarge =8; , ;   kFullCircle =20; , kFullSquare =21; , kFullTriangleUp =22; , kFullTriangleDown =23; , ;   kOpenCircle =24; , kOpenSquare =25; , kOpenTriangleUp =26; , kOpenDiamond =27; , ;   kOpenCross =28; , kFullStar =29; , kOpenStar =30; , kOpenTriangleDown =32; , ;   kFullDiamond =33; , kFullCross =34; , kOpenDiamondCross =35; , kOpenSquareDiagonal =36; , ;   kOpenThreeTriangles =37; , kOctagonCross =38; , kFullThreeTriangles =39; , kOpenFourTrianglesX =40; , ;   kFullFourTrianglesX =41; , kOpenDoubleDiamond =42; , kFullDoubleDiamond =43; , kOpenFourTrianglesPlus =44; , ;   kFullFourTrianglesPlus =45; , kOpenCrossX =46; , kFullCrossX =47; , kFourSquaresX =48; , ;   kFourSquaresPlus =49. };  . Enumeration Type Documentation. ◆ EMarkerStyle. enum EMarkerStyle. EnumeratorkDot ; kPlus ; kStar ; kCircle ; kMultiply ; kFullDotSmall ; kFullDotMedium ; kFullDotLarge ; kFullCircle ; kFullSquare ; kFullTriangleUp ; kFullTriangleDown ; kOpenCircle ; kOpenSquare ; kOpenTriangleUp ; kOpenDiamond ; kOpenCross ; kFullStar ; kOpenStar ; kOpenTriangleDown ; kFullDiamond ; kFullCross ; kOpenDiamondCross ; kOpenSquareDiagonal ; kOpenThreeTriangles ; kOctagonCross ; kFullThreeTriangles ; kOpenFourTrianglesX ; kFullFourTrianglesX ; kOpenDoubleDiamond ; kFullDoubleDiamond ; kOpenFourTria",MatchSource.WIKI,doc/master/TAttMarker_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttMarker_8h.html
Availability,avail,available,"ported fonts](\ref ATTTEXT53); 45 ; 46\anchor ATTTEXT1; 47## Text Alignment; 48 ; 49The text alignment is an integer number (`align`) allowing to control; 50the horizontal and vertical position of the text string with respect; 51to the text position.; 52The text alignment of any class inheriting from `TAttText` can; 53be changed using the method `SetTextAlign` and retrieved using the; 54method `GetTextAlign`.; 55 ; 56~~~ {.cpp}; 57 align = 10*HorizontalAlign + VerticalAlign; 58~~~; 59 ; 60For horizontal alignment the following convention applies:; 61 ; 62~~~ {.cpp}; 63 1=left adjusted, 2=centered, 3=right adjusted; 64~~~; 65 ; 66For vertical alignment the following convention applies:; 67 ; 68~~~ {.cpp}; 69 1=bottom adjusted, 2=centered, 3=top adjusted; 70~~~; 71 ; 72For example:; 73 ; 74~~~ {.cpp}; 75 align = 11 = left adjusted and bottom adjusted; 76 align = 32 = right adjusted and vertically centered; 77~~~; 78 ; 79Begin_Macro(source); 80textalign.C; 81End_Macro; 82 ; 83Mnemonic constants are available:; 84 ; 85~~~ {.cpp}; 86kHAlignLeft = 10, kHAlignCenter = 20, kHAlignRight = 30,; 87kVAlignBottom = 1, kVAlignCenter = 2, kVAlignTop = 3; 88~~~; 89 ; 90They allow to write:; 91 ; 92~~~ {.cpp}; 93object->SetTextAlign(kHAlignLeft+kVAlignTop);; 94~~~; 95 ; 96\anchor ATTTEXT2; 97## Text Angle; 98 ; 99Text angle in degrees.; 100The text angle of any class inheriting from `TAttText` can; 101be changed using the method `SetTextAngle` and retrieved using the; 102method `GetTextAngle`.; 103The following picture shows the text angle:; 104 ; 105Begin_Macro(source); 106textangle.C; 107End_Macro; 108 ; 109\anchor ATTTEXT3; 110## Text Color; 111 ; 112The text color is a color index (integer) pointing in the ROOT; 113color table.; 114The text color of any class inheriting from `TAttText` can; 115be changed using the method `SetTextColor` and retrieved using the; 116method `GetTextColor`.; 117The following table shows the first 50 default colors.; 118 ; 119Begin_Macro; 120{; 121 TCa",MatchSource.WIKI,doc/master/TAttText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttText_8cxx_source.html
Integrability,depend,depend," available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1`; 138in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output; 139it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.; 140 ; 141Alternatively, you can call at the top of your script `gSytle->SetCanvasPreferGL();`.; 142Or if you prefer to activate GL for a single canvas `c`, then use `c->SetSupportGL(true);`.; 143 ; 144\anchor ATTTEXT4; 145## Text Size; 146 ; 147If the text precision (see next paragraph) is smaller than 3, the text; 148size (`textsize`) is a fraction of the current pad size. Therefore the; 149same `textsize` value can generate text outputs with different absolute; 150sizes in two different pads.; 151The text size in pixels (`charheight`) is computed the following way:; 152 ; 153~~~ {.cpp}; 154 pad_width = gPad->XtoPixel(gPad->GetX2());; 155 pad_height = gPad->YtoPixel(gPad->GetY1());; 156 if (pad_width < pad_height) charheight = textsize*pad_width;; 157 else charheight = textsize*pad_height;; 158~~~; 159 ; 160If the text precision is equal to 3, the text size doesn't depend on the pad's; 161dimensions. A given `textsize` value always generates the same absolute; 162size. The text size (`charheight`) is given in pixels:; 163 ; 164~~~ {.cpp}; 165 charheight = textsize;; 166~~~; 167 ; 168Note that to scale fonts to the same size as the old True Type package a; 169scale factor of `0.93376068` is apply to the text size before drawing.; 170 ; 171The text size of any class inheriting from `TAttText` can; 172be changed using the method `SetTextSize` and retrieved using the; 173method `GetTextSize`.; 174 ; 175\anchor ATTTEXT5; 176## Text Font and Precision; 177 ; 178The text font code is combination of the font number and the precision.; 179~~~ {.cpp}; 180 Text font code = 10*fontnumber + precision; 181~~~; 182Font numbers must be between 1 and 14.; 183 ; 184The precision can be:; 185 ; 186 - `precision = 0` fast hardware fonts (ste",MatchSource.WIKI,doc/master/TAttText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttText_8cxx_source.html
Modifiability,inherit,inheritance,"OOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TAttText.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Rene Brun 12/12/94; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include <iostream>; 13#include ""Strlen.h""; 14#include ""TROOT.h""; 15#include ""TAttText.h""; 16#include ""TVirtualPad.h""; 17#include ""TStyle.h""; 18#include ""TVirtualX.h""; 19#include ""TError.h""; 20#include ""TVirtualPadEditor.h""; 21#include ""TColor.h""; 22 ; 23ClassImp(TAttText);; 24 ; 25/** \class TAttText; 26\ingroup Base; 27\ingroup GraphicsAtt; 28 ; 29Text Attributes class.; 30 ; 31This class is used (in general by secondary inheritance); 32by many other classes (graphics, histograms). It holds all the text attributes.; 33 ; 34## Text attributes; 35Text attributes are:; 36 ; 37 - [Text Alignment](\ref ATTTEXT1); 38 - [Text Angle](\ref ATTTEXT2); 39 - [Text Color](\ref ATTTEXT3); 40 - [Text Size](\ref ATTTEXT4); 41 - [Text Font and Precision](\ref ATTTEXT5); 42 - [Font quality and speed](\ref ATTTEXT51); 43 - [How to use True Type Fonts](\ref ATTTEXT52); 44 - [List of the currently supported fonts](\ref ATTTEXT53); 45 ; 46\anchor ATTTEXT1; 47## Text Alignment; 48 ; 49The text alignment is an integer number (`align`) allowing to control; 50the horizontal and vertical position of the text string with respect; 51to the text position.; 52The text alignment of any class inheriting from `TAttText` can; 53be changed using the method `SetTextAlign` and retrieved using the; 54method `GetTextAlign`.; 55 ; 56~~~ {.cpp}; 57 align = 10*HorizontalAlign + VerticalAlign; 58~~~; 59 ; 60For horizontal alignment the following con",MatchSource.WIKI,doc/master/TAttText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttText_8cxx_source.html
Performance,scalab,scalable," ; 160If the text precision is equal to 3, the text size doesn't depend on the pad's; 161dimensions. A given `textsize` value always generates the same absolute; 162size. The text size (`charheight`) is given in pixels:; 163 ; 164~~~ {.cpp}; 165 charheight = textsize;; 166~~~; 167 ; 168Note that to scale fonts to the same size as the old True Type package a; 169scale factor of `0.93376068` is apply to the text size before drawing.; 170 ; 171The text size of any class inheriting from `TAttText` can; 172be changed using the method `SetTextSize` and retrieved using the; 173method `GetTextSize`.; 174 ; 175\anchor ATTTEXT5; 176## Text Font and Precision; 177 ; 178The text font code is combination of the font number and the precision.; 179~~~ {.cpp}; 180 Text font code = 10*fontnumber + precision; 181~~~; 182Font numbers must be between 1 and 14.; 183 ; 184The precision can be:; 185 ; 186 - `precision = 0` fast hardware fonts (steps in the size); 187 - `precision = 1` scalable and rotatable hardware fonts (see below); 188 - `precision = 2` scalable and rotatable hardware fonts; 189 - `precision = 3` scalable and rotatable hardware fonts. Text size; 190 is given in pixels.; 191 ; 192The text font and precision of any class inheriting from `TAttText` can; 193be changed using the method `SetTextFont` and retrieved using the; 194method `GetTextFont`.; 195 ; 196\anchor ATTTEXT51; 197### Font quality and speed; 198 ; 199When precision 0 is used, only the original non-scaled X11 system fonts are; 200used. The fonts have a minimum (4) and maximum (37) size in pixels. These; 201fonts are fast and are of good quality. Their size varies with large steps; 202and they cannot be rotated.; 203Precision 1 and 2 fonts have a different behaviour depending if the; 204True Type Fonts (TTF) are used or not. If TTF are used, you always get very good; 205quality scalable and rotatable fonts.; 206These days TTF fonts are rendered fast enough and can be used in all cases.; 207 ; 208\anchor ATTTEXT",MatchSource.WIKI,doc/master/TAttText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttText_8cxx_source.html
Integrability,depend,dependency,". ROOT: core/base/inc/TAttText.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; TAttText.h File Reference. #include ""Rtypes.h"". Include dependency graph for TAttText.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TAttText;  Text Attributes class. More...;  . Enumerations; enum  ETextAlign { ;   kHAlignLeft =10; , kHAlignCenter =20; , kHAlignRight =30; , kVAlignBottom =1; , ;   kVAlignCenter =2; , kVAlignTop =3. };  . Enumeration Type Documentation. ◆ ETextAlign. enum ETextAlign. EnumeratorkHAlignLeft ; kHAlignCenter ; kHAlignRight ; kVAlignBottom ; kVAlignCenter ; kVAlignTop . Definition at line 53 of file TAttText.h. corebaseincTAttText.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:12 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TAttText_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAttText_8h.html
Availability,down,down,"fTimeFormat.Index(""%F"")+2;; 617 if (idF<2) {; 618 Warning(""GetGMTimeOffset"",""Time format is not set!"");; 619 return 0;; 620 }; 621 TString stime=fTimeFormat(idF,19);; 622 if (stime.Length() != 19) {; 623 Warning(""GetGMTimeOffset"",""Bad time format!"");; 624 return 0;; 625 }; 626 ; 627 TDatime datime(stime.Data());; 628 return datime.Convert(kTRUE); // Convert to unix gmt time; 629}; 630 ; 631////////////////////////////////////////////////////////////////////////////////; 632/// Return the ticks option (see SetTicks); 633 ; 634const char *TAxis::GetTicks() const; 635{; 636 if (TestBit(kTickPlus) && TestBit(kTickMinus)) return ""+-"";; 637 if (TestBit(kTickMinus)) return ""-"";; 638 if (TestBit(kTickPlus)) return ""+"";; 639 return """";; 640}; 641 ; 642////////////////////////////////////////////////////////////////////////////////; 643/// This helper function checks if there is a bin without a label; 644/// if all bins have labels, the axis can / will become alphanumeric; 645 ; 646Bool_t TAxis::HasBinWithoutLabel() const; 647{; 648 return fLabels->GetSize() != fNbins;; 649}; 650 ; 651////////////////////////////////////////////////////////////////////////////////; 652/// Set option(s) to draw axis with labels; 653/// option can be:; 654/// - ""a"" sort by alphabetic order; 655/// - "">"" sort by decreasing values; 656/// - ""<"" sort by increasing values; 657/// - ""h"" draw labels horizontal; 658/// - ""v"" draw labels vertical; 659/// - ""u"" draw labels up (end of label right adjusted); 660/// - ""d"" draw labels down (start of label left adjusted); 661 ; 662void TAxis::LabelsOption(Option_t *option); 663{; 664 if (!fLabels) {; 665 Warning(""Sort"",""Cannot sort. No labels"");; 666 return;; 667 }; 668 TH1 *h = (TH1*)GetParent();; 669 if (!h) {; 670 Error(""Sort"",""Axis has no parent"");; 671 return;; 672 }; 673 ; 674 h->LabelsOption(option,GetName());; 675}; 676 ; 677////////////////////////////////////////////////////////////////////////////////; 678/// Copy axis attributes to this; 679 ; 680",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
Deployability,release,released,"tUniqueID(label->GetUniqueID());; 244 }; 245 }; 246 if (axis.fModLabs) {; 247 axis.fModLabs->Delete();; 248 delete axis.fModLabs;; 249 axis.fModLabs = nullptr;; 250 }; 251 if (fModLabs) {; 252 axis.fModLabs = new TList();; 253 TIter next(fModLabs);; 254 while(auto modlabel = (TAxisModLab *)next()) {; 255 TAxisModLab *copyModLabel = new TAxisModLab(*modlabel);; 256 axis.fModLabs->Add(copyModLabel);; 257 copyModLabel->SetUniqueID(modlabel->GetUniqueID());; 258 }; 259 }; 260}; 261 ; 262////////////////////////////////////////////////////////////////////////////////; 263/// Compute distance from point px,py to an axis; 264 ; 265Int_t TAxis::DistancetoPrimitive(Int_t, Int_t); 266{; 267 return 9999;; 268}; 269 ; 270////////////////////////////////////////////////////////////////////////////////; 271/// Execute action corresponding to one event; 272///; 273/// This member function is called when an axis is clicked with the locator.; 274/// The axis range is set between the position where the mouse is pressed; 275/// and the position where it is released.; 276/// If the mouse position is outside the current axis range when it is released; 277/// the axis is unzoomed with the corresponding proportions.; 278/// Note that the mouse does not need to be in the pad or even canvas; 279/// when it is released.; 280 ; 281void TAxis::ExecuteEvent(Int_t event, Int_t px, Int_t py); 282{; 283 if (!gPad) return;; 284 gPad->ExecuteEventAxis(event,px,py,this);; 285}; 286 ; 287////////////////////////////////////////////////////////////////////////////////; 288/// Find bin number corresponding to abscissa x. NOTE: this method does not work with alphanumeric bins !!!; 289///; 290/// If x is underflow or overflow, attempt to extend the axis if TAxis::kCanExtend is true.; 291/// Otherwise, return 0 or fNbins+1.; 292 ; 293Int_t TAxis::FindBin(Double_t x); 294{; 295 Int_t bin;; 296 // NOTE: This should not be allowed for Alphanumeric histograms,; 297 // but it is heavily used (legacy) in the TTre",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
Integrability,depend,depending,"0;; 302 if (fParent == nullptr) return bin;; 303 if (!CanExtend() || IsAlphanumeric() ) return bin;; 304 ((TH1*)fParent)->ExtendAxis(x,this);; 305 return FindFixBin(x);; 306 } else if ( !(x < fXmax)) { //*-* overflow (note the way to catch NaN); 307 bin = fNbins+1;; 308 if (fParent == nullptr) return bin;; 309 if (!CanExtend() || IsAlphanumeric() ) return bin;; 310 ((TH1*)fParent)->ExtendAxis(x,this);; 311 return FindFixBin(x);; 312 } else {; 313 if (!fXbins.fN) { //*-* fix bins; 314 bin = 1 + int (fNbins*(x-fXmin)/(fXmax-fXmin) );; 315 } else { //*-* variable bin sizes; 316 //for (bin =1; x >= fXbins.fArray[bin]; bin++);; 317 bin = 1 + TMath::BinarySearch(fXbins.fN,fXbins.fArray,x);; 318 }; 319 }; 320 return bin;; 321}; 322 ; 323////////////////////////////////////////////////////////////////////////////////; 324/// Find bin number with label.; 325/// If the List of labels does not exist create it and make the axis alphanumeric; 326/// If one wants just to add a single label- just call TAxis::SetBinLabel; 327/// If label is not in the list of labels do the following depending on the; 328/// bit TAxis::kCanExtend; of the axis.; 329/// - if the bit is set add the new label and if the number of labels exceeds; 330/// the number of bins, double the number of bins via TH1::LabelsInflate; 331/// - if the bit is not set and the histogram has labels in each bin; 332/// set the bit automatically and consider the histogram as alphanumeric; 333/// if histogram has only some bins with labels then the histogram is not; 334/// consider alphanumeric and return -1; 335///; 336/// -1 is returned only when the Axis has no parent histogram; 337 ; 338Int_t TAxis::FindBin(const char *label); 339{; 340 //create list of labels if it does not exist yet; 341 if (!fLabels) {; 342 if (!fParent) return -1;; 343 fLabels = new THashList(fNbins,3);; 344 // we set the axis alphanumeric; 345 // when list of labels does not exist; 346 // do we want to do this also when histogram is not empty ?????;",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
Modifiability,variab,variable,"ntributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TAxis.h""; 13#include ""TVirtualPad.h""; 14#include ""TStyle.h""; 15#include ""TError.h""; 16#include ""THashList.h""; 17#include ""TList.h""; 18#include ""TAxisModLab.h""; 19#include ""TH1.h""; 20#include ""TObjString.h""; 21#include ""TDatime.h""; 22#include ""TTimeStamp.h""; 23#include ""TBuffer.h""; 24#include ""TMath.h""; 25#include ""THLimitsFinder.h""; 26#include ""strlcpy.h""; 27#include ""snprintf.h""; 28 ; 29#include <iostream>; 30#include <ctime>; 31#include <cassert>; 32 ; 33ClassImp(TAxis);; 34 ; 35////////////////////////////////////////////////////////////////////////////////; 36/** \class TAxis; 37 \ingroup Histograms; 38 \brief Class to manage histogram axis; 39 ; 40This class manages histogram axis. It is referenced by TH1 and TGraph.; 41To make a graphical representation of an histogram axis, this class; 42references the TGaxis class. TAxis supports axis with fixed or variable bin sizes.; 43Labels may be associated to individual bins.; 44See examples of various axis representations drawn by class TGaxis.; 45*///////////////////////////////////////////////////////////////////////////////; 46 ; 47////////////////////////////////////////////////////////////////////////////////; 48/// Default constructor.; 49 ; 50TAxis::TAxis(); 51{; 52 fNbins = 1;; 53 fXmin = 0;; 54 fXmax = 1;; 55 fFirst = 0;; 56 fLast = 0;; 57 fParent = nullptr;; 58 fLabels = nullptr;; 59 fModLabs = nullptr;; 60 fBits2 = 0;; 61 fTimeDisplay = false;; 62}; 63 ; 64////////////////////////////////////////////////////////////////////////////////; 65/// Axis constructor for axis with fix bin size; 66 ; 67TAxis::TAxis(Int_t nbins,Double_t xlow,Double_t xup); 68{; 69 fParent = nullptr;; 70 fLabels = nullptr;; 71 fModLabs = nullptr;; 72 Set(nbins,xlow,xup);; 73}; 74 ; 75////////////////////////////////////////////////////////////////////////////////; 76/// Axis constructor for variabl",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
Performance,optimiz,optimization,"(center + bin - 1) = GetBinCenter(bin);; 557}; 558 ; 559////////////////////////////////////////////////////////////////////////////////; 560/// Return an array with the low edge of all bins; 561 ; 562void TAxis::GetLowEdge(Double_t *edge) const; 563{; 564 for (Int_t bin = 1; bin <= fNbins; bin++); 565 *(edge + bin - 1) = GetBinLowEdge(bin);; 566}; 567 ; 568////////////////////////////////////////////////////////////////////////////////; 569/// Return the number of axis labels.; 570///; 571/// It is sometimes useful to know the number of labels on an axis. For instance; 572/// when changing the labels with TAxis::ChangeLabel. The number of labels is equal; 573/// to `the_number_of_divisions + 1`. By default the number of divisions is; 574/// optimised to show a coherent labeling of the main tick marks. After optimisation the; 575/// real number of divisions will be smaller or equal to number of divisions requested.; 576/// In order to turn off the labeling optimization, it is enough to give a negative; 577/// number of divisions to TAttAxis::SetNdivisions. The absolute value of this number will be use as; 578/// the exact number of divisions. This method takes the two cases (optimised or not) into; 579/// account.; 580 ; 581Int_t TAxis::GetNlabels() const; 582{; 583 if (fNdivisions > 0) {; 584 Int_t divxo = 0;; 585 Double_t x1o = 0.;; 586 Double_t x2o = 0.;; 587 Double_t bwx = 0.;; 588 THLimitsFinder::Optimize(fXmin, fXmax,fNdivisions%100,x1o,x2o,divxo,bwx,"""");; 589 return divxo+1;; 590 } else {; 591 Int_t divx = -fNdivisions;; 592 return divx%100+1;; 593 }; 594}; 595 ; 596////////////////////////////////////////////////////////////////////////////////; 597/// Return *only* the time format from the string fTimeFormat; 598 ; 599const char *TAxis::GetTimeFormatOnly() const; 600{; 601 static TString timeformat;; 602 Int_t idF = fTimeFormat.Index(""%F"");; 603 if (idF>=0) {; 604 timeformat = fTimeFormat(0,idF);; 605 } else {; 606 timeformat = fTimeFormat;; 607 }; 608 retu",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
Security,hash,hash,"virtual Double_t GetMaximum(Double_t maxval=FLT_MAX) constReturn maximum value smaller than maxval of bins in the range, unless the value has been overridden b...Definition TH1.cxx:8545; TH1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Definition TH1.h:404; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::kNstat@ kNstatSize of statistics data (up to TProfile3D)Definition TH1.h:184; TH1::GetMinimumvirtual Double_t GetMinimum(Double_t minval=-FLT_MAX) constReturn minimum value larger than minval of bins in the range, unless the value has been overridden by...Definition TH1.cxx:8635; THLimitsFinder::Optimizestatic void Optimize(Double_t A1, Double_t A2, Int_t nold, Double_t &BinLow, Double_t &BinHigh, Int_t &nbins, Double_t &BWID, Option_t *option="""")Static function to compute reasonable axis limits.Definition THLimitsFinder.cxx:184; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition THashList.cxx:207; THashList::Rehashvoid Rehash(Int_t newCapacity)Rehash the hashlist.Definition THashList.cxx:368; THashList::FindObjectTObject * FindObject(const char *name) const overrideFind object using its name.Definition THashList.cxx:262; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::Copyvoid Copy(TObject &named) const overrideCopy this to obj.Definition TNamed.cxx:94; TNamed::SetTitlevirtual void SetTitle(const ch",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
Testability,assert,assert,");; 360 if (obj) return (Int_t)obj->GetUniqueID();; 361 ; 362 // if labels is not in the list and we have already labels; 363 if (!IsAlphanumeric()) {; 364 // if bins without labels exist or if the axis cannot be set to alphanumeric; 365 if (HasBinWithoutLabel() || !CanBeAlphanumeric() ) {; 366 Info(""FindBin"",""Label %s is not in the list and the axis is not alphanumeric - ignore it"",label);; 367 return -1;; 368 }; 369 else {; 370 Info(""FindBin"",""Label %s not in the list. It will be added to the histogram"",label);; 371 SetCanExtend(kTRUE);; 372 SetAlphanumeric(kTRUE);; 373 }; 374 }; 375 ; 376 //Not yet in the list. Can we extend the axis ?; 377 assert ( CanExtend() && IsAlphanumeric() );; 378 // {; 379 // if (gDebug>0); 380 // Info(""FindBin"",""Label %s is not in the list and the axis cannot be extended - the entry will be added in the underflow bin"",label);; 381 // return 0;; 382 // }; 383 ; 384 Int_t n = fLabels->GetEntries();; 385 ; 386 //may be we have to resize the histogram (doubling number of channels); 387 if (n >= fNbins) ((TH1*)fParent)->LabelsInflate(GetName());; 388 ; 389 //add new label to the list: assign bin number; 390 obj = new TObjString(label);; 391 fLabels->Add(obj);; 392 obj->SetUniqueID(n+1);; 393 return n+1;; 394}; 395 ; 396////////////////////////////////////////////////////////////////////////////////; 397/// Find bin number with label.; 398/// If the List of labels does not exist or the label does not exist just return -1 .; 399/// Do not attempt to modify the axis. This is different than FindBin; 400 ; 401Int_t TAxis::FindFixBin(const char *label) const; 402{; 403 //create list of labels if it does not exist yet; 404 if (!fLabels) return -1;; 405 ; 406 // search for label in the existing list and return it if it exists; 407 TObjString *obj = (TObjString*)fLabels->FindObject(label);; 408 if (obj) return (Int_t)obj->GetUniqueID();; 409 return -1;; 410}; 411 ; 412 ; 413//////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
Usability,clear,clear,"Axis::Set"", ""bins must be in increasing order"");; 816 fXmin = fXbins.fArray[0];; 817 fXmax = fXbins.fArray[fNbins];; 818 if (!fParent) SetDefaults();; 819}; 820 ; 821////////////////////////////////////////////////////////////////////////////////; 822/// Initialize axis with variable bins; 823 ; 824void TAxis::Set(Int_t nbins, const Double_t *xbins); 825{; 826 Int_t bin;; 827 fNbins = nbins;; 828 fXbins.Set(fNbins+1);; 829 for (bin=0; bin<= fNbins; bin++); 830 fXbins.fArray[bin] = xbins[bin];; 831 for (bin=1; bin<= fNbins; bin++); 832 if (fXbins.fArray[bin] < fXbins.fArray[bin-1]); 833 Error(""TAxis::Set"", ""bins must be in increasing order"");; 834 fXmin = fXbins.fArray[0];; 835 fXmax = fXbins.fArray[fNbins];; 836 if (!fParent) SetDefaults();; 837}; 838 ; 839////////////////////////////////////////////////////////////////////////////////; 840/// Set axis alphanumeric; 841 ; 842void TAxis::SetAlphanumeric(Bool_t alphanumeric); 843{; 844 if (alphanumeric) fBits2 |= kAlphanumeric;; 845 else fBits2 &= ~kAlphanumeric;; 846 ; 847 // clear underflow and overflow (in an alphanumeric situation they do not make sense); 848 // NOTE: using AddBinContent instead of SetBinContent in order to not change; 849 // the number of entries; 850 //((TH1 *)fParent)->ClearUnderflowAndOverflow();; 851 // L.M. 26.1.15 Keep underflow and overflows (see ROOT-7034); 852 if (gDebug && fParent) {; 853 TH1 * h = dynamic_cast<TH1*>( fParent);; 854 if (!h) return;; 855 double s[TH1::kNstat];; 856 h->GetStats(s);; 857 if (s[0] != 0. && gDebug > 0); 858 Info(""SetAlphanumeric"",""Cannot switch axis %s of histogram %s to alphanumeric: it has non-zero content"",GetName(),h->GetName());; 859 }; 860}; 861 ; 862 ; 863////////////////////////////////////////////////////////////////////////////////; 864/// Set axis default values (from TStyle); 865 ; 866void TAxis::SetDefaults(); 867{; 868 fFirst = 0;; 869 fLast = 0;; 870 fBits2 = 0;; 871 char name[2];; 872 strlcpy(name,GetName(),2);; 873 name[1] = 0;; 874 TAttAxis:",MatchSource.WIKI,doc/master/TAxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html
Integrability,depend,dependency,". ROOT: hist/hist/inc/TAxis.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TAxis.h File Reference. #include ""TNamed.h""; #include ""TAttAxis.h""; #include ""TArrayD.h"". Include dependency graph for TAxis.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TAxis;  Class to manage histogram axis. More...;  . histhistincTAxis.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TAxis_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8h.html
Modifiability,extend,extended,"$ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TAxis; 13#define ROOT_TAxis; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TAxis //; 19// //; 20// Axis class. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TNamed.h""; 25#include ""TAttAxis.h""; 26#include ""TArrayD.h""; 27 ; 28class THashList;; 29class TAxisModLab;; 30 ; 31class TAxis : public TNamed, public TAttAxis {; 32 ; 33private:; 34 Int_t fNbins; ///< Number of bins; 35 Double_t fXmin; ///< Low edge of first bin; 36 Double_t fXmax; ///< Upper edge of last bin; 37 TArrayD fXbins; ///< Bin edges array in X; 38 Int_t fFirst; ///< First bin to display; 39 Int_t fLast; ///< Last bin to display; 40 UShort_t fBits2; ///< Second bit status word; 41 Bool_t fTimeDisplay; ///< On/off displaying time values instead of numerics; 42 TString fTimeFormat; ///< Date&time format, ex: 09/12/99 12:34:00; 43 TObject *fParent; ///<! Object owning this axis; 44 THashList *fLabels; ///< List of labels; 45 TList *fModLabs; ///< List of modified labels; 46 ; 47 /// TAxis extra status bits (stored in fBits2); 48 enum {; 49 kAlphanumeric = BIT(0), ///< Axis is alphanumeric; 50 kCanExtend = BIT(1), ///< Axis can be extended; 51 kNotAlpha = BIT(2) ///< Axis is forced to be not alphanumeric; 52 };; 53 ; 54 Bool_t HasBinWithoutLabel() const;; 55 ; 56 ; 57 TAxisModLab *FindModLab(Int_t num, Double_t v = 0., Double_t eps = 0.) const;; 58 ; 59public:; 60 /// TAxis status bits; 61 enum EStatusBits {; 62 kDecimals = BIT(7),; 63 kTickPlus = BIT(9),; 64 kTickMinus = BIT(10),; 65 kAxisRange = BIT(11),; 66 kCenterTitle = BIT(12),; 67 kCenterLabels = BIT(14), ///< Bit 13 is used by TObject; 68 kRotateTitle = BIT(15),; 69 kPalette = BIT(16),; 70 kNoExponent = BIT(17),; 71 kLabelsHori = BIT(18),; 72 kLabelsVert = BIT(19),; 73 kLabelsDown = BIT(20),; 74 kLabelsUp = B",MatchSource.WIKI,doc/master/TAxis_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8h_source.html
Security,hash,hash," TAxis.cxx:1157; TAxis::CanBeAlphanumericBool_t CanBeAlphanumeric()Definition TAxis.h:87; TAxis::fTimeFormatTString fTimeFormatDate&time format, ex: 09/12/99 12:34:00.Definition TAxis.h:42; TAxis::GetParentvirtual TObject * GetParent() constDefinition TAxis.h:128; TAxis::SetRangevirtual void SetRange(Int_t first=0, Int_t last=0)Set the viewing range for the axis using bin numbers.Definition TAxis.cxx:1052; TAxis::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width.Definition TAxis.cxx:540; TAxis::GetBinUpEdgevirtual Double_t GetBinUpEdge(Int_t bin) constReturn up edge of bin.Definition TAxis.cxx:528; TAxis::GetFirstInt_t GetFirst() constReturn first bin on the axis i.e.Definition TAxis.cxx:458; TAxis::GetTicksvirtual const char * GetTicks() constReturn the ticks option (see SetTicks)Definition TAxis.cxx:634; TAxis::fBits2UShort_t fBits2Second bit status word.Definition TAxis.h:40; TAxis::fFirstInt_t fFirstFirst bin to display.Definition TAxis.h:38; TAxis::GetLabelsTHashList * GetLabels() constDefinition TAxis.h:121; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; TListA doubly linked list.Definition TList.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::fTitleTString fTitleDefinition TNamed.h:33; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; bool; double; int; xDouble_t x[n]Definition legend1.C:17; v@ vDefinition rootcling_impl.cxx:3699. histhistincTAxis.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TAxis_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8h_source.html
Testability,log,log,"is right adjusted; 193 ; 194inline void TAxis::CenterTitle(Bool_t center); 195{; 196 SetBit(kCenterTitle, center);; 197}; 198 ; 199////////////////////////////////////////////////////////////////////////////////; 200/// Rotate title by 180 degrees. By default the title is drawn right adjusted.; 201/// If rotate is TRUE, the title is left adjusted at the end of the axis and rotated by 180 degrees; 202 ; 203inline void TAxis::RotateTitle(Bool_t rotate); 204{; 205 SetBit(kRotateTitle, rotate);; 206}; 207 ; 208////////////////////////////////////////////////////////////////////////////////; 209/// Sets the decimals flag; 210/// By default, blank characters are stripped, and then the label is correctly aligned.; 211/// If the dot is the last character of the string, it is also stripped, unless this option is specified.; 212 ; 213inline void TAxis::SetDecimals(Bool_t dot) {; 214 SetBit(kDecimals, dot);; 215}; 216 ; 217////////////////////////////////////////////////////////////////////////////////; 218/// Set the kMoreLogLabels bit flag; 219/// When this option is selected more labels are drawn when in log scale and there is a small number; 220/// of decades (<3).; 221/// The flag (in fBits) is passed to the drawing function TGaxis::PaintAxis; 222 ; 223inline void TAxis::SetMoreLogLabels(Bool_t more); 224{; 225 SetBit(kMoreLogLabels, more);; 226}; 227 ; 228////////////////////////////////////////////////////////////////////////////////; 229/// Set the NoExponent flag; 230/// By default, an exponent of the form 10^N is used when the label value are either all very small or very large.; 231/// The flag (in fBits) is passed to the drawing function TGaxis::PaintAxis; 232 ; 233inline void TAxis::SetNoExponent(Bool_t noExponent); 234{; 235 SetBit(kNoExponent, noExponent);; 236}; 237 ; 238 ; 239#endif; Bool_tbool Bool_tDefinition RtypesCore.h:63; UShort_tunsigned short UShort_tDefinition RtypesCore.h:40; Int_tint Int_tDefinition RtypesCore.h:45; UInt_tunsigned int UInt_tDefinitio",MatchSource.WIKI,doc/master/TAxis_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TAxis_8h_source.html
Integrability,interface,interface,"g_t Property() const overrideGet property description word. For meaning of bits see EProperty.Definition TBaseClass.cxx:134; TBaseClass::~TBaseClassvirtual ~TBaseClass()TBaseClass dtor deletes adopted CINT BaseClassInfo object.Definition TBaseClass.cxx:46; TBaseClass::TBaseClassTBaseClass(const TBaseClass &)=delete; TBaseClass::fClassPtrTClassRef fClassPtrpointer to CINT base class infoDefinition TBaseClass.h:50; TBaseClass::fDeltaAtomicInt_t fDeltapointer to parent classDefinition TBaseClass.h:52; TBaseClass::fClassTClass * fClassDefinition TBaseClass.h:51; TBaseClass::fSTLTypeInt_t fSTLTypeDefinition TBaseClass.h:54; TBaseClass::fPropertyAtomicInt_t fPropertyDefinition TBaseClass.h:53; TBaseClass::SetClassvoid SetClass(TClass *cl)Definition TBaseClass.h:67; TBaseClass::fInfoBaseClassInfo_t * fInfoDefinition TBaseClass.h:49; TBaseClass::GetClassPointerTClass * GetClassPointer(Bool_t load=kTRUE)Get pointer to the base class TClass.Definition TBaseClass.cxx:63; TBaseClass::AtomicInt_tstd::atomic< Int_t > AtomicInt_tDefinition TBaseClass.h:35; TBaseClass::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Definition TBaseClass.h:64; TBaseClass::GetTitleconst char * GetTitle() const overrideGet base class description (comment).Definition TBaseClass.cxx:92; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; bool; int; ROOT::ESTLTypeESTLTypeDefinition ESTLType.h:28. coremetaincTBaseClass.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TBaseClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBaseClass_8h_source.html
Performance,cache,cache,"//////////////; 17// //; 18// TBaseClass //; 19// //; 20// Description of a base class. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24 ; 25#include ""TDictionary.h""; 26#include ""TClassRef.h""; 27 ; 28#include <atomic>; 29 ; 30class TBrowser;; 31class TClass;; 32 ; 33class TBaseClass : public TDictionary {; 34#ifndef __CLING__; 35 using AtomicInt_t = std::atomic<Int_t>;; 36 static_assert(sizeof(std::atomic<Int_t>) == sizeof(Int_t),; 37 ""We requiqre atomic<int> and <int> to have the same size but they are not"");; 38#else; 39 // std::atomic is not yet supported in the I/O, so; 40 // we hide them from Cling; 41 using AtomicInt_t = Int_t;; 42#endif; 43 ; 44private:; 45 TBaseClass(const TBaseClass &) = delete;; 46 TBaseClass&operator=(const TBaseClass &) = delete;; 47 ; 48private:; 49 BaseClassInfo_t *fInfo; //!pointer to CINT base class info; 50 TClassRef fClassPtr; // pointer to the base class TClass; 51 TClass *fClass; //!pointer to parent class; 52 AtomicInt_t fDelta; // BaseClassInfo_t offset (INT_MAX if unset); 53 mutable AtomicInt_t fProperty; // BaseClassInfo_t's properties; 54 Int_t fSTLType; // cache of IsSTLContainer(); 55 ; 56public:; 57 TBaseClass(BaseClassInfo_t *info = nullptr, TClass *cl = nullptr);; 58 virtual ~TBaseClass();; 59 ; 60 void Browse(TBrowser *b) override;; 61 const char *GetTitle() const override;; 62 TClass *GetClassPointer(Bool_t load=kTRUE);; 63 Int_t GetDelta();; 64 Bool_t IsFolder() const override {return kTRUE;}; 65 ROOT::ESTLType IsSTLContainer();; 66 Long_t Property() const override;; 67 void SetClass(TClass* cl) { fClass = cl; }; 68 ; 69 ClassDefOverride(TBaseClass,2) //Description of a base class; 70};; 71 ; 72#endif; b#define b(i)Definition RSha256.hxx:100; Int_tint Int_tDefinition RtypesCore.h:45; Long_tlong Long_tDefinition RtypesCore.h:54; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TClassRef.h; ",MatchSource.WIKI,doc/master/TBaseClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBaseClass_8h_source.html
Deployability,release,released,"A) {; 563 fX1 = gPad->AbsPixeltoX(pxold);; 564 fY1 = gPad->AbsPixeltoY(pyt);; 565 fX2 = gPad->AbsPixeltoX(pxt);; 566 fY2 = gPad->AbsPixeltoY(pyold);; 567 }; 568 if (pB) {; 569 fX1 = gPad->AbsPixeltoX(pxl);; 570 fY1 = gPad->AbsPixeltoY(pyt);; 571 fX2 = gPad->AbsPixeltoX(pxold);; 572 fY2 = gPad->AbsPixeltoY(pyold);; 573 }; 574 if (pC) {; 575 fX1 = gPad->AbsPixeltoX(pxl);; 576 fY1 = gPad->AbsPixeltoY(pyold);; 577 fX2 = gPad->AbsPixeltoX(pxold);; 578 fY2 = gPad->AbsPixeltoY(pyl);; 579 }; 580 if (pD) {; 581 fX1 = gPad->AbsPixeltoX(pxold);; 582 fY1 = gPad->AbsPixeltoY(pyold);; 583 fX2 = gPad->AbsPixeltoX(pxt);; 584 fY2 = gPad->AbsPixeltoY(pyl);; 585 }; 586 if (pTop || pBot || pL || pR || pINSIDE) {; 587 fX1 = gPad->AbsPixeltoX(px1);; 588 fY1 = gPad->AbsPixeltoY(py1);; 589 fX2 = gPad->AbsPixeltoX(px2);; 590 fY2 = gPad->AbsPixeltoY(py2);; 591 }; 592 ; 593 if (isBox) {; 594 if (gPad->GetLogx()) {; 595 fX1 = TMath::Power(10,fX1);; 596 fX2 = TMath::Power(10,fX2);; 597 }; 598 if (gPad->GetLogy()) {; 599 fY1 = TMath::Power(10,fY1);; 600 fY2 = TMath::Power(10,fY2);; 601 }; 602 }; 603 if (pINSIDE) {; 604 // if it was not a pad that was moved then it must have been; 605 // a box or something like that so we have to redraw the pad; 606 if (parent == gPad) gPad->Modified(kTRUE);; 607 }; 608 }; 609 ; 610 if (pA || pB || pC || pD || pTop || pL || pR || pBot) gPad->Modified(kTRUE);; 611 ; 612 if (!opaque) {; 613 gVirtualX->SetLineColor(-1);; 614 gVirtualX->SetLineWidth(-1);; 615 }; 616 ; 617 break;; 618 ; 619 case kButton1Locate:; 620 ; 621 ExecuteEvent(kButton1Down, px, py);; 622 ; 623 while (true) {; 624 px = py = 0;; 625 event = gVirtualX->RequestLocator(1, 1, px, py);; 626 ; 627 ExecuteEvent(kButton1Motion, px, py);; 628 ; 629 if (event != -1) { // button is released; 630 ExecuteEvent(kButton1Up, px, py);; 631 return;; 632 }; 633 }; 634 }; 635}; 636 ; 637////////////////////////////////////////////////////////////////////////////////; 638/// Hide tool tip depending on the event type.",MatchSource.WIKI,doc/master/TBox_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBox_8cxx_source.html
Energy Efficiency,power,power,"Point.h:47; TPoint::GetXSCoord_t GetX() constDefinition TPoint.h:46; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::YtoAbsPixelvirtual Int_t YtoAbsPixel(Double_t y) const =0; TVirtualPad::GetX2virtual Double_t GetX2() const =0; TVirtualPad::XtoAbsPixelvirtual Int_t XtoAbsPixel(Double_t x) const =0; TVirtualPad::GetY1virtual Double_t GetY1() const =0; TVirtualPad::GetY2virtual Double_t GetY2() const =0; TVirtualPad::GetBorderSizevirtual Short_t GetBorderSize() const =0; TVirtualPad::GetX1virtual Double_t GetX1() const =0; TVirtualX::kHollow@ kHollowDefinition TVirtualX.h:50; bool; double; int; unsigned int; boxvoid box(Int_t pat, Double_t x1, Double_t y1, Double_t x2, Double_t y2)Definition fillpatterns.C:1; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; Rectangle_tRectangle structure (maps to the X11 XRectangle structure)Definition GuiTypes.h:361. graf2dgrafsrcTBox.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:18 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TBox_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBox_8cxx_source.html
Integrability,depend,depending,"A) {; 563 fX1 = gPad->AbsPixeltoX(pxold);; 564 fY1 = gPad->AbsPixeltoY(pyt);; 565 fX2 = gPad->AbsPixeltoX(pxt);; 566 fY2 = gPad->AbsPixeltoY(pyold);; 567 }; 568 if (pB) {; 569 fX1 = gPad->AbsPixeltoX(pxl);; 570 fY1 = gPad->AbsPixeltoY(pyt);; 571 fX2 = gPad->AbsPixeltoX(pxold);; 572 fY2 = gPad->AbsPixeltoY(pyold);; 573 }; 574 if (pC) {; 575 fX1 = gPad->AbsPixeltoX(pxl);; 576 fY1 = gPad->AbsPixeltoY(pyold);; 577 fX2 = gPad->AbsPixeltoX(pxold);; 578 fY2 = gPad->AbsPixeltoY(pyl);; 579 }; 580 if (pD) {; 581 fX1 = gPad->AbsPixeltoX(pxold);; 582 fY1 = gPad->AbsPixeltoY(pyold);; 583 fX2 = gPad->AbsPixeltoX(pxt);; 584 fY2 = gPad->AbsPixeltoY(pyl);; 585 }; 586 if (pTop || pBot || pL || pR || pINSIDE) {; 587 fX1 = gPad->AbsPixeltoX(px1);; 588 fY1 = gPad->AbsPixeltoY(py1);; 589 fX2 = gPad->AbsPixeltoX(px2);; 590 fY2 = gPad->AbsPixeltoY(py2);; 591 }; 592 ; 593 if (isBox) {; 594 if (gPad->GetLogx()) {; 595 fX1 = TMath::Power(10,fX1);; 596 fX2 = TMath::Power(10,fX2);; 597 }; 598 if (gPad->GetLogy()) {; 599 fY1 = TMath::Power(10,fY1);; 600 fY2 = TMath::Power(10,fY2);; 601 }; 602 }; 603 if (pINSIDE) {; 604 // if it was not a pad that was moved then it must have been; 605 // a box or something like that so we have to redraw the pad; 606 if (parent == gPad) gPad->Modified(kTRUE);; 607 }; 608 }; 609 ; 610 if (pA || pB || pC || pD || pTop || pL || pR || pBot) gPad->Modified(kTRUE);; 611 ; 612 if (!opaque) {; 613 gVirtualX->SetLineColor(-1);; 614 gVirtualX->SetLineWidth(-1);; 615 }; 616 ; 617 break;; 618 ; 619 case kButton1Locate:; 620 ; 621 ExecuteEvent(kButton1Down, px, py);; 622 ; 623 while (true) {; 624 px = py = 0;; 625 event = gVirtualX->RequestLocator(1, 1, px, py);; 626 ; 627 ExecuteEvent(kButton1Motion, px, py);; 628 ; 629 if (event != -1) { // button is released; 630 ExecuteEvent(kButton1Up, px, py);; 631 return;; 632 }; 633 }; 634 }; 635}; 636 ; 637////////////////////////////////////////////////////////////////////////////////; 638/// Hide tool tip depending on the event type.",MatchSource.WIKI,doc/master/TBox_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBox_8cxx_source.html
Modifiability,inherit,inherits,"sBuffervirtual Int_t WriteClassBuffer(const TClass *cl, void *pointer)=0; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::operator=TObject & operator=(const TObject &rhs)TObject assignment operator.Definition TObject.h:296; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Copyvirtual void Copy(TObject &object) constCopy this to obj.Definition TObject.cxx:146; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TPointDefinition TPoint.h:31; TPoint::GetYSCoord_t GetY() constDefinition TPoint.h:47; TPoint::GetXSCoord_t GetX() constDefinition TPoint.h:46; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::YtoAbsPixelvirtual Int_t YtoAbsPixel(Double_t y) const =0; TVirtualPad::GetX2vi",MatchSource.WIKI,doc/master/TBox_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBox_8cxx_source.html
Testability,log,logarithm,"Point.h:47; TPoint::GetXSCoord_t GetX() constDefinition TPoint.h:46; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::YtoAbsPixelvirtual Int_t YtoAbsPixel(Double_t y) const =0; TVirtualPad::GetX2virtual Double_t GetX2() const =0; TVirtualPad::XtoAbsPixelvirtual Int_t XtoAbsPixel(Double_t x) const =0; TVirtualPad::GetY1virtual Double_t GetY1() const =0; TVirtualPad::GetY2virtual Double_t GetY2() const =0; TVirtualPad::GetBorderSizevirtual Short_t GetBorderSize() const =0; TVirtualPad::GetX1virtual Double_t GetX1() const =0; TVirtualX::kHollow@ kHollowDefinition TVirtualX.h:50; bool; double; int; unsigned int; boxvoid box(Int_t pat, Double_t x1, Double_t y1, Double_t x2, Double_t y2)Definition fillpatterns.C:1; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; Rectangle_tRectangle structure (maps to the X11 XRectangle structure)Definition GuiTypes.h:361. graf2dgrafsrcTBox.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:18 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TBox_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBox_8cxx_source.html
Integrability,depend,depending,"t tool tip text associated with this box.Definition TBox.cxx:732; TBox::SetY2virtual void SetY2(Double_t y2)Definition TBox.h:65; TBox::PaintBoxvirtual void PaintBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Option_t *option="""")Draw this box with new coordinates.Definition TBox.cxx:678; TBox::SetBBoxX1void SetBBoxX1(const Int_t x) overrideSet left hand side of BoundingBox to a value (resize in x direction on left)Definition TBox.cxx:880; TBox::~TBox~TBox() overrideBox destructor.Definition TBox.cxx:69; TBox::operator=TBox & operator=(const TBox &)Assignment operator.Definition TBox.cxx:93; TBox::SetBBoxY2void SetBBoxY2(const Int_t y) overrideSet bottom of BoundingBox to a value (resize in y direction on bottom)Definition TBox.cxx:912; TBox::SetBBoxY1void SetBBoxY1(const Int_t y) overrideSet top of BoundingBox to a value (resize in y direction on top)Definition TBox.cxx:901; TBox::fX1Double_t fX1X of 1st point.Definition TBox.h:28; TBox::HideToolTipvirtual void HideToolTip(Int_t event)Hide tool tip depending on the event type.Definition TBox.cxx:642; TBox::SetBBoxCenterYvoid SetBBoxCenterY(const Int_t y) overrideSet Y coordinate of the center of the Box.Definition TBox.cxx:861; TBox::GetX2Double_t GetX2() constDefinition TBox.h:52; TBox::lsvoid ls(Option_t *option="""") const overrideList this box with its attributes.Definition TBox.cxx:661; TBox::GetY1Double_t GetY1() constDefinition TBox.h:53; TBox::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TBox.cxx:232; TBox::SetX1virtual void SetX1(Double_t x1)Definition TBox.h:62; TBox::Paintvoid Paint(Option_t *option="""") overridePaint this box with its current attributes.Definition TBox.cxx:670; TBox::GetY2Double_t GetY2() constDefinition TBox.h:54; TBox::IsInsidevirtual Int_t IsInside(Double_t x, Double_t y) constFunction which returns 1 if point x,y lies inside the box, 0 otherwise.Definition TBox.cxx:651; TBox::GetBBoxCenterTPoint GetB",MatchSource.WIKI,doc/master/TBox_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBox_8h_source.html
Testability,test,test,"h""; 19 ; 20class TPoint;; 21 ; 22class TBox : public TObject, public TAttLine, public TAttFill, public TAttBBox2D {; 23 ; 24private:; 25 TObject *fTip{nullptr}; ///<! tool tip associated with box; 26 ; 27protected:; 28 Double_t fX1; ///< X of 1st point; 29 Double_t fY1; ///< Y of 1st point; 30 Double_t fX2; ///< X of 2nd point; 31 Double_t fY2; ///< Y of 2nd point; 32 Bool_t fResizing; ///<! True if box is being resized; 33 ; 34public:; 35 // Private bits, clients can only test but not change them; 36 enum {; 37 kCannotMove = BIT(12) //if set the box cannot be moved/resized; 38 };; 39 TBox();; 40 TBox(Double_t x1, Double_t y1,Double_t x2, Double_t y2);; 41 TBox(const TBox &box);; 42 TBox& operator=(const TBox&);; 43 ~TBox() override;; 44 ; 45 void Copy(TObject &box) const override;; 46 Int_t DistancetoPrimitive(Int_t px, Int_t py) override;; 47 void Draw(Option_t *option="""") override;; 48 virtual TBox *DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2);; 49 void ExecuteEvent(Int_t event, Int_t px, Int_t py) override;; 50 Bool_t IsBeingResized() const { return fResizing; }; 51 Double_t GetX1() const { return fX1; }; 52 Double_t GetX2() const { return fX2; }; 53 Double_t GetY1() const { return fY1; }; 54 Double_t GetY2() c",MatchSource.WIKI,doc/master/TBox_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBox_8h_source.html
Availability,down,downwards,"ement->CannotSplit()) {; 432 fSplitLevel = 0;; 433 } else if (element->IsA() == TStreamerBase::Class()) {; 434 // -- We are a base class element.; 435 // Note: This does not include an STL container class which is; 436 // being used as a base class because the streamer element; 437 // in that case is not the base streamer element it is the; 438 // STL streamer element.; 439 fType = 1;; 440 TClass* clOfElement = element->GetClassPointer();; 441 Int_t nbranches = fBranches.GetEntriesFast();; 442 // Note: The following code results in base class branches; 443 // having two different cases for what their parent; 444 // class will be, this is very annoying. It is also; 445 // very annoying that the naming conventions for the; 446 // sub-branch names are different as well.; 447 if (!strcmp(name, clOfElement->GetName())) {; 448 // -- If the branch's name is the same as the base class name,; 449 // which happens when we are a child branch of a top-level; 450 // branch whose name does not end in a dot and also has no; 451 // internal dots, elide the branch name, and keep the branch; 452 // hierarchy rooted at the ultimate parent, this keeps the base; 453 // class part of the branch name from propagating downwards.; 454 // FIXME: We are eliding the base class here, creating a break in the branch hierarchy.; 455 // Note: We can use parent class (cltop) != branch class (elemClass) to detection elision.; 456 Unroll("""", fBranchClass.GetClass(), clOfElement, pointer, basketsize, splitlevel+splitSTLP, 0);; 457 SetReadLeavesPtr();; 458 SetFillLeavesPtr();; 459 return;; 460 }; 461 // If the branch's name is not the same as the base class name,; 462 // keep the branch name as a prefix (i.e., continue the branch; 463 // hierarchy), but start a new class hierarchy at the base class.; 464 //; 465 // Note: If the parent branch was created by the branch constructor; 466 // which takes a folder as a parameter, then this case will; 467 // be used, because the branch name will be the same as t",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
Deployability,update,updated,"reamer info for the branch class.; 1023 ; 1024TStreamerInfo* TBranchElement::GetInfo() const; 1025{; 1026 return GetInfoImp();; 1027}; 1028 ; 1029////////////////////////////////////////////////////////////////////////////////; 1030/// Browse the branch content.; 1031 ; 1032void TBranchElement::Browse(TBrowser* b); 1033{; 1034 Int_t nbranches = fBranches.GetEntriesFast();; 1035 if (nbranches > 0) {; 1036 TList persistentBranches;; 1037 TBranch* branch=nullptr;; 1038 TIter iB(&fBranches);; 1039 while((branch=(TBranch*)iB())) {; 1040 if (branch->IsFolder()) persistentBranches.Add(branch);; 1041 else {; 1042 // only show branches corresponding to persistent members; 1043 TClass* cl=nullptr;; 1044 if (strlen(GetClonesName())); 1045 // this works both for top level branches and for sub-branches,; 1046 // as GetClonesName() is properly updated for sub-branches; 1047 cl=fClonesClass;; 1048 else {; 1049 cl=TClass::GetClass(GetClassName());; 1050 ; 1051 // check if we're in a sub-branch of this class; 1052 // we can only find out asking the streamer given our ID; 1053 TStreamerElement *element=nullptr;; 1054 TClass* clsub=nullptr;; 1055 if (fID>=0 && GetInfoImp(); 1056 && GetInfoImp()->IsCompiled(); 1057 && ((element=GetInfoImp()->GetElement(fID))); 1058 && ((clsub=element->GetClassPointer()))); 1059 cl=clsub;; 1060 }; 1061 if (cl) {; 1062 TString strMember=branch->GetName();; 1063 Size_t mempos=strMember.Last('.');; 1064 if (mempos!=kNPOS); 1065 strMember.Remove(0, (Int_t)mempos+1);; 1066 mempos=strMember.First('[');; 1067 if (mempos!=kNPOS); 1068 strMember.Remove((Int_t)mempos);; 1069 TDataMember* m=cl->GetDataMember(strMember);; 1070 if (!m || m->IsPersistent()) persistentBranches.Add(branch);; 1071 } else persistentBranches.Add(branch);; 1072 } // branch if not a folder; 1073 }; 1074 persistentBranches.Browse(b);; 1075 // add all public const methods without params; 1076 if (GetBrowsables() && GetBrowsables()->GetSize()); 1077 GetBrowsables()->Browse(b);; 1078 } else {; 1",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
Energy Efficiency,allocate,allocated,")->Add(leaf);; 944 // ===> create sub branches for each data member of an STL container value class; 945 TClass* valueClass = cont->GetValueClass();; 946 if (!valueClass) {; 947 return;; 948 }; 949 fClonesName = valueClass->GetName();; 950 fClonesClass = valueClass;; 951 TString branchname( name );; 952 branchname += ""_"";; 953 SetTitle(branchname);; 954 leaf->SetName(branchname);; 955 leaf->SetTitle(branchname);; 956 Unroll(name, valueClass, valueClass, nullptr, basketsize, splitlevel, 41);; 957 BuildTitle(name);; 958 SetReadLeavesPtr();; 959 SetFillLeavesPtr();; 960 return;; 961 }; 962 ; 963 TLeaf *leaf = new TLeafElement(this, GetTitle(), fID, fStreamerType);; 964 leaf->SetTitle(GetTitle());; 965 fNleaves = 1;; 966 fLeaves.Add(leaf);; 967 fTree->GetListOfLeaves()->Add(leaf);; 968 SetReadLeavesPtr();; 969 SetFillLeavesPtr();; 970}; 971 ; 972////////////////////////////////////////////////////////////////////////////////; 973/// Destructor.; 974 ; 975TBranchElement::~TBranchElement(); 976{; 977 // Release any allocated I/O buffers.; 978 if (fOnfileObject && TestBit(kOwnOnfileObj)) {; 979 delete fOnfileObject;; 980 fOnfileObject = nullptr;; 981 }; 982 ResetAddress();; 983 ; 984 delete[] fBranchOffset;; 985 fBranchOffset = nullptr;; 986 ; 987 fInfo = nullptr;; 988 fBranchCount2 = nullptr;; 989 fBranchCount = nullptr;; 990 ; 991 if (fType == 4 || fType == 0) {; 992 // Only the top level TBranchElement containing an STL container,; 993 // owns the collectionproxy.; 994 delete fCollProxy;; 995 }; 996 fCollProxy = nullptr;; 997 ; 998 delete fReadActionSequence;; 999 delete fFillActionSequence;; 1000 delete fIterators;; 1001 delete fWriteIterators;; 1002 delete fPtrIterators;; 1003}; 1004 ; 1005//; 1006// This function is located here to allow inlining by the optimizer.; 1007//; 1008////////////////////////////////////////////////////////////////////////////////; 1009/// Get streamer info for the branch class.; 1010 ; 1011inline TStreamerInfo* TBranchElement::GetInfoImp() c",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
Integrability,message,message,"bject).; 1319 ; 1320void TBranchElement::FillLeavesMakeClass(TBuffer& b); 1321{; 1322 ValidateAddress();; 1323 ; 1324 //; 1325 // Silently do nothing if we have no user i/o buffer.; 1326 //; 1327 ; 1328 if (!fObject) {; 1329 return;; 1330 }; 1331 ; 1332 // -- TClonesArray top-level branch. Write out number of entries, sub-branch writes the entries themselves.; 1333 if(fType == 3) {; 1334 // fClonesClass can not be zero since we are of type 3, see TBranchElement::Init; 1335 TVirtualStreamerInfo* si = fClonesClass->GetStreamerInfo();; 1336 if (!si) {; 1337 Error(""FillLeaves"", ""Cannot get streamer info for branch '%s' class '%s'"", GetName(), fClonesClass->GetName());; 1338 return;; 1339 }; 1340 b.ForceWriteInfo(si,false);; 1341 Int_t* nptr = (Int_t*) fAddress;; 1342 b << *nptr;; 1343 } else if (fType == 31) {; 1344 // -- TClonesArray sub-branch. Write out the entries in the TClonesArray.; 1345 // -- A MakeClass() tree, we must use fAddress instead of fObject.; 1346 if (!fAddress) {; 1347 // FIXME: Enable this message.; 1348 //Error(""FillLeaves"", ""Branch address not set for branch '%s'!"", GetName());; 1349 return;; 1350 }; 1351 Int_t atype = fStreamerType;; 1352 if (atype > 54) {; 1353 // Note: We are not supporting kObjectp, kAny, kObjectp,; 1354 // kObjectP, kTString, kTObject, kTNamed, kAnyp,; 1355 // kAnyP, kSTLp, kSTL, kSTLstring, kStreamer,; 1356 // kStreamLoop here, nor pointers to varying length; 1357 // arrays of them either.; 1358 // Nor do we support pointers to varying length; 1359 // arrays of kBits, kLong64, kULong64, nor kBool.; 1360 return;; 1361 }; 1362 Int_t* nn = (Int_t*) fBranchCount->GetAddress();; 1363 if (!nn) {; 1364 Error(""FillLeaves"", ""The branch counter address was zero!"");; 1365 return;; 1366 }; 1367 Int_t n = *nn;; 1368 if (atype > 40) {; 1369 // Note: We are not supporting pointer to varying length array.; 1370 Error(""FillLeaves"", ""Clonesa: %s, n=%d, sorry not supported yet"", GetName(), n);; 1371 return;; 1372 }; 1373 if (atype > 20) {; 137",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
Modifiability,inherit,inherits,"ass()) {; 364 bool hasCustomStreamer = false;; 365 bool canSelfReference = CanSelfReference(fBranchClass);; 366 if (fBranchClass.GetClass()->IsTObject()) {; 367 if (canSelfReference) SetBit(kBranchObject);; 368 hasCustomStreamer = (!fBranchClass.GetClass()->GetCollectionProxy() && fBranchClass.GetClass()->HasCustomStreamerMember());; 369 } else {; 370 if (canSelfReference) SetBit(kBranchAny);; 371 hasCustomStreamer = !fBranchClass.GetClass()->GetCollectionProxy() && (fBranchClass.GetClass()->GetStreamer() != nullptr || fBranchClass.GetClass()->HasCustomStreamerMember());; 372 }; 373 if (hasCustomStreamer) {; 374 fType = -1;; 375 }; 376 }; 377 } else {; 378 // -- We are a sub-branch of a split object.; 379 TStreamerElement* element = sinfo->GetElement(id);; 380 if ((fStreamerType == TVirtualStreamerInfo::kObject) || (fStreamerType == TVirtualStreamerInfo::kBase) || (fStreamerType == TVirtualStreamerInfo::kTNamed) || (fStreamerType == TVirtualStreamerInfo::kTObject) || (fStreamerType == TVirtualStreamerInfo::kObjectp) || (fStreamerType == TVirtualStreamerInfo::kObjectP)) {; 381 // -- If we are an object data member which inherits from TObject,; 382 // flag it so that later during i/o we will register the object; 383 // with the buffer so that pointers are handled correctly.; 384 if (CanSelfReference(fBranchClass)) {; 385 if (fBranchClass.GetClass()->IsTObject()) {; 386 SetBit(kBranchObject);; 387 } else {; 388 SetBit(kBranchAny);; 389 }; 390 }; 391 }; 392 if (element->IsA() == TStreamerBasicPointer::Class()) {; 393 // -- Fixup title with counter if we are a varying length array data member.; 394 TStreamerBasicPointer *bp = (TStreamerBasicPointer *)element;; 395 TString countname;; 396 countname = bname;; 397 Ssiz_t dot = countname.Last('.');; 398 if (dot>=0) {; 399 countname.Remove(dot+1);; 400 } else {; 401 countname = """";; 402 }; 403 countname += bp->GetCountName();; 404 brOfCounter = (TBranchElement *)fTree->GetBranch(countname);; 405 countname.Form(""%s[%s]"",name.Da",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
Performance,optimiz,optimizer,"etTitle(), fID, fStreamerType);; 964 leaf->SetTitle(GetTitle());; 965 fNleaves = 1;; 966 fLeaves.Add(leaf);; 967 fTree->GetListOfLeaves()->Add(leaf);; 968 SetReadLeavesPtr();; 969 SetFillLeavesPtr();; 970}; 971 ; 972////////////////////////////////////////////////////////////////////////////////; 973/// Destructor.; 974 ; 975TBranchElement::~TBranchElement(); 976{; 977 // Release any allocated I/O buffers.; 978 if (fOnfileObject && TestBit(kOwnOnfileObj)) {; 979 delete fOnfileObject;; 980 fOnfileObject = nullptr;; 981 }; 982 ResetAddress();; 983 ; 984 delete[] fBranchOffset;; 985 fBranchOffset = nullptr;; 986 ; 987 fInfo = nullptr;; 988 fBranchCount2 = nullptr;; 989 fBranchCount = nullptr;; 990 ; 991 if (fType == 4 || fType == 0) {; 992 // Only the top level TBranchElement containing an STL container,; 993 // owns the collectionproxy.; 994 delete fCollProxy;; 995 }; 996 fCollProxy = nullptr;; 997 ; 998 delete fReadActionSequence;; 999 delete fFillActionSequence;; 1000 delete fIterators;; 1001 delete fWriteIterators;; 1002 delete fPtrIterators;; 1003}; 1004 ; 1005//; 1006// This function is located here to allow inlining by the optimizer.; 1007//; 1008////////////////////////////////////////////////////////////////////////////////; 1009/// Get streamer info for the branch class.; 1010 ; 1011inline TStreamerInfo* TBranchElement::GetInfoImp() const; 1012{; 1013 // Note: we need to find a way to reduce the complexity of; 1014 // this often executed condition.; 1015 if (!fInfo || (fInfo && (!fInit || !fInfo->IsCompiled()))) {; 1016 const_cast<TBranchElement*>(this)->InitInfo();; 1017 }; 1018 return fInfo;; 1019}; 1020 ; 1021////////////////////////////////////////////////////////////////////////////////; 1022/// Get streamer info for the branch class.; 1023 ; 1024TStreamerInfo* TBranchElement::GetInfo() const; 1025{; 1026 return GetInfoImp();; 1027}; 1028 ; 1029////////////////////////////////////////////////////////////////////////////////; 1030/// Browse the branch cont",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
Safety,detect,detection,"ement.; 439 fType = 1;; 440 TClass* clOfElement = element->GetClassPointer();; 441 Int_t nbranches = fBranches.GetEntriesFast();; 442 // Note: The following code results in base class branches; 443 // having two different cases for what their parent; 444 // class will be, this is very annoying. It is also; 445 // very annoying that the naming conventions for the; 446 // sub-branch names are different as well.; 447 if (!strcmp(name, clOfElement->GetName())) {; 448 // -- If the branch's name is the same as the base class name,; 449 // which happens when we are a child branch of a top-level; 450 // branch whose name does not end in a dot and also has no; 451 // internal dots, elide the branch name, and keep the branch; 452 // hierarchy rooted at the ultimate parent, this keeps the base; 453 // class part of the branch name from propagating downwards.; 454 // FIXME: We are eliding the base class here, creating a break in the branch hierarchy.; 455 // Note: We can use parent class (cltop) != branch class (elemClass) to detection elision.; 456 Unroll("""", fBranchClass.GetClass(), clOfElement, pointer, basketsize, splitlevel+splitSTLP, 0);; 457 SetReadLeavesPtr();; 458 SetFillLeavesPtr();; 459 return;; 460 }; 461 // If the branch's name is not the same as the base class name,; 462 // keep the branch name as a prefix (i.e., continue the branch; 463 // hierarchy), but start a new class hierarchy at the base class.; 464 //; 465 // Note: If the parent branch was created by the branch constructor; 466 // which takes a folder as a parameter, then this case will; 467 // be used, because the branch name will be the same as the; 468 // parent branch name.; 469 // Note: This means that the sub-branches of a base class branch; 470 // created by TTree::Bronch() have the base class name as; 471 // as part of the branch name, while those created by; 472 // Unroll() do not, ouch!!!; 473 //; 474 Unroll(name, clOfElement, clOfElement, pointer, basketsize, splitlevel+splitSTLP, 0);; 475 if (",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
Security,access,access,";; 558 } else if (((fSTLtype >= ROOT::kSTLvector) && (fSTLtype < ROOT::kSTLend)) || ((fSTLtype > -ROOT::kSTLend) && (fSTLtype <= -ROOT::kSTLvector))) {; 559 // -- We are an STL container element.; 560 TClass* contCl = elementClass;; 561 fCollProxy = contCl->GetCollectionProxy()->Generate();; 562 TClass* valueClass = GetCollectionProxy()->GetValueClass();; 563 // Check to see if we can split the container.; 564 bool cansplit = true;; 565 if (!valueClass) {; 566 cansplit = false;; 567 } else if ((valueClass == TString::Class()) || (valueClass == TClass::GetClass(""string""))) {; 568 cansplit = false;; 569 } else if (GetCollectionProxy()->HasPointers() && !splitSTLP ) {; 570 cansplit = false;; 571 } else if (!valueClass->CanSplit() && !(GetCollectionProxy()->HasPointers() && splitSTLP)) {; 572 cansplit = false;; 573 } else if (valueClass->GetCollectionProxy()) {; 574 // -- A collection was stored in a collection, we choose not to split it.; 575 // Note: Splitting it would require extending TTreeFormula; 576 // to understand how to access it.; 577 cansplit = false;; 578 }; 579 if (cansplit) {; 580 // -- Do the splitting work if we are allowed to.; 581 fType = 4;; 582 // Create a leaf for the master branch (the counter).; 583 TLeaf *leaf = new TLeafElement(this, name, fID, fStreamerType);; 584 fNleaves = 1;; 585 fLeaves.Add(leaf);; 586 fTree->GetListOfLeaves()->Add(leaf);; 587 // Check that the contained objects class name is part of the element title.; 588 // This name is mandatory when reading the tree later on and; 589 // the parent class with the pointer to the STL container is not available.; 590 fClonesName = valueClass->GetName();; 591 fClonesClass = valueClass;; 592 TString aname;; 593 aname.Form("" (%s)"", valueClass->GetName());; 594 TString atitle = element->GetTitle();; 595 if (!atitle.Contains(aname)) {; 596 atitle += aname;; 597 element->SetTitle(atitle.Data());; 598 }; 599 TString branchname (name);; 600 if (branchname.EndsWith(""."")); 601 branchname.Remove(bra",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
Testability,test,test,"he function returns the number of bytes committed to the; 1223/// individual branches. If a write error occurs, the number of; 1224/// bytes returned is -1. If no data are written, because, e.g.,; 1225/// the branch is disabled, the number of bytes returned is 0.; 1226///; 1227/// Note: We not not use any member functions from TLeafElement!; 1228 ; 1229Int_t TBranchElement::FillImpl(ROOT::Internal::TBranchIMTHelper *imtHelper); 1230{; 1231 Int_t nbytes = 0;; 1232 Int_t nwrite = 0;; 1233 Int_t nerror = 0;; 1234 Int_t nbranches = fBranches.GetEntriesFast();; 1235 ; 1236 ValidateAddress();; 1237 ; 1238 //; 1239 // If we are a top-level branch, update addresses.; 1240 //; 1241 ; 1242 if (fID < 0) {; 1243 if (!fObject) {; 1244 Error(""Fill"", ""attempt to fill branch %s while address is not set"", GetName());; 1245 return 0;; 1246 }; 1247 }; 1248 ; 1249 //; 1250 // If the tree has a TRefTable, set the current branch if; 1251 // branch is not a basic type.; 1252 //; 1253 ; 1254 // FIXME: This test probably needs to be extended past 10.; 1255 if ((fType >= -1) && (fType < 10)) {; 1256 TBranchRef* bref = fTree->GetBranchRef();; 1257 if (bref) {; 1258 fBranchID = bref->SetParent(this, fBranchID);; 1259 }; 1260 }; 1261 ; 1262 if (!nbranches) {; 1263 // No sub-branches.; 1264 if (!TestBit(kDoNotProcess)) {; 1265 nwrite = TBranch::FillImpl(imtHelper);; 1266 if (nwrite < 0) {; 1267 Error(""Fill"", ""Failed filling branch:%s, nbytes=%d"", GetName(), nwrite);; 1268 ++nerror;; 1269 } else {; 1270 nbytes += nwrite;; 1271 }; 1272 }; 1273 } else {; 1274 // We have sub-branches.; 1275 if (fType == 3 || fType == 4) {; 1276 // TClonesArray or STL container counter; 1277 nwrite = TBranch::FillImpl(imtHelper);; 1278 if (nwrite < 0) {; 1279 Error(""Fill"", ""Failed filling branch:%s, nbytes=%d"", GetName(), nwrite);; 1280 ++nerror;; 1281 } else {; 1282 nbytes += nwrite;; 1283 }; 1284 } else {; 1285 ++fEntries;; 1286 }; 1287 for (Int_t i = 0; i < nbranches; ++i) {; 1288 TBranchElement* branch = (TBranchE",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
Usability,clear,clear,"2344 }; 2345 }; 2346 subbranch->fOnfileObject = fOnfileObject;; 2347 lastbranch = subbranch;; 2348 }; 2349 }; 2350 if (toplevel) {; 2351 SetBit(kOwnOnfileObj);; 2352 if (lastbranch != this); 2353 lastbranch->ResetBit(kOwnOnfileObj);; 2354 } else {; 2355 lastbranch->SetBit(kOwnOnfileObj);; 2356 }; 2357 };; 2358 if (GetID() > -1) {; 2359 // We are *not* a top-level branch.; 2360 std::string s(GetName());; 2361 size_t pos = s.rfind('.');; 2362 if (pos != std::string::npos) {; 2363 s = s.substr(pos+1);; 2364 }; 2365 while ((pos = s.rfind('[')) != std::string::npos) {; 2366 s = s.substr(0, pos);; 2367 }; 2368 int offset = 0;; 2369 TStreamerElement* elt = fInfo->GetStreamerElement(s.c_str(), offset);; 2370 if (elt && offset!=TStreamerInfo::kMissing) {; 2371 size_t ndata = fInfo->GetNelement();; 2372 fNewIDs.clear();; 2373 for (size_t i = 0; i < ndata; ++i) {; 2374 if (fInfo->GetElement(i) == elt) {; 2375 if (elt->TestBit (TStreamerElement::kCache); 2376 && (i+1) < ndata; 2377 && s == fInfo->GetElement(i)->GetName()); 2378 {; 2379 // If the TStreamerElement we found is storing the information in the; 2380 // cache and is a repeater, we need to use the real one (the next one).; 2381 // (At least until the cache/repeat mechanism is properly handle by; 2382 // ReadLeaves).; 2383 // fID = i+1;; 2384 fID = i;; 2385 if (fType != 2) {; 2386 if (elt->TestBit(TStreamerElement::kRepeat)) {; 2387 fNewIDs.push_back(fID+1);; 2388 fNewIDs.back().fElement = fInfo->GetElement(i+1);; 2389 fNewIDs.back().fInfo = fInfo;; 2390 } else if (fInfo->GetElement(i+1)->TestBit(TStreamerElement::kWrite)) {; 2391 fNewIDs.push_back(fID+1);; 2392 fNewIDs.back().fElement = fInfo->GetElement(i+1);; 2393 fNewIDs.back().fInfo = fInfo;; 2394 }; 2395 }; 2396 } else {; 2397 fID = i;; 2398 }; 2399 if (elt->TestBit (TStreamerElement::kCache)) {; 2400 SetBit(TBranchElement::kCache);; 2401 }; 2402 break;; 2403 }; 2404 }; 2405 for (size_t i = fID+1+(fNewIDs.size()); i < ndata; ++i) {; 2406 TStreamerElement *nextel =",MatchSource.WIKI,doc/master/TBranchElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html
Availability,error,error,"T type system.Definition TClass.h:81; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TFileMergeInfoDefinition TFileMergeInfo.h:42; TFolder<div class=""legacybox""><h2>Legacy Code</h2> TFolder is a legacy interface: there will be no bug fixes...Definition TFolder.h:30; TLeafElementA TLeaf for the general case when using the branches created via a TStreamerInfo (i....Definition TLeafElement.h:32; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TStreamerInfoActions::TActionSequence::SequenceGetter_tSequencePtr(*)(TStreamerInfo *info, TVirtualCollectionProxy *collectionProxy, TClass *originalClass) SequenceGetter_tDefinition TStreamerInfoActions.h:185; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TTreeClonerClass implementing or helping the various TTree cloning method.Definition TTreeCloner.h:31; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetMakeClassInt_t GetMakeClass() constDefinition TTree.h:535; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; TVirtualCollection",MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
Deployability,release,release,"id SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TStreamerInfoActions::TActionSequence::SequenceGetter_tSequencePtr(*)(TStreamerInfo *info, TVirtualCollectionProxy *collectionProxy, TClass *originalClass) SequenceGetter_tDefinition TStreamerInfoActions.h:185; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TTreeClonerClass implementing or helping the various TTree cloning method.Definition TTreeCloner.h:31; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetMakeClassInt_t GetMakeClass() constDefinition TTree.h:535; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; TVirtualCollectionIteratorsSmall helper class to generically acquire and release iterators.Definition TVirtualCollectionIterators.h:26; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionPtrIteratorsDefinition TVirtualCollectionIterators.h:195; double; int; unsigned int; TStreamerInfoActions::TIDsstd::vector< TIDNode > TIDsDefinition TStreamerInfoActions.h:138; ROOT::RCompressionSetting::EAlgorithm::kInherit@ kInheritSome objects use this value to denote that the compression algorithm should be inherited from the par...Definition Compression.h:91. treetreeincTBranchElement.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:04 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
Energy Efficiency,allocate,allocated,"Element::Printvoid Print(Option_t *option="""") const overridePrint TBranch parameters.Definition TBranchElement.cxx:3836; TBranchElement::GetIDInt_t GetID() constDefinition TBranchElement.h:195; TBranchElement::GetBranchOffsetInt_t * GetBranchOffset() constDefinition TBranchElement.h:184; TBranchElement::GetClassNameconst char * GetClassName() const overrideReturn the name of the user class whose content is stored in this branch, if any.Definition TBranchElement.h:186; TBranchElement::GetInfoTStreamerInfo * GetInfo() constGet streamer info for the branch class.Definition TBranchElement.cxx:1024; TBranchElement::ReadLeavesCollectionvoid ReadLeavesCollection(TBuffer &b)Read leaves into i/o buffers for this branch.Definition TBranchElement.cxx:4267; TBranchElement::SetupAddressesvoid SetupAddresses() overrideIf the branch address is not set, we set all addresses starting with the top level parent branch.Definition TBranchElement.cxx:5892; TBranchElement::ResetAddressvoid ResetAddress() overrideSet branch address to zero and free all allocated memory.Definition TBranchElement.cxx:4780; TBranchElement::SetTypevirtual void SetType(Int_t btype)Definition TBranchElement.h:234; TBranchElement::FillLeavesMembervoid FillLeavesMember(TBuffer &b)Write leaves into i/o buffers for this branch.Definition TBranchElement.cxx:1734; TBranchElement::SetBranchCountvoid SetBranchCount(TBranchElement *bre)Set the branch counter for this branch.Definition TBranchElement.cxx:5529; TBranchElement::SwitchContainerstatic void SwitchContainer(TObjArray *)Modify the container type of the branches.Definition TBranchElement.cxx:85; TBranchElement::SetReadActionSequencevoid SetReadActionSequence()Set the sequence of actions needed to read the data out of the buffer.Definition TBranchElement.cxx:5663; TBranchElement::IsMissingCollectionbool IsMissingCollection() constDetect a collection written using a zero pointer in old versions of root.Definition TBranchElement.cxx:3776; TBranchElement::FillImplInt_",MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
Integrability,interface,interface,"ranch {; 40 ; 41// Friends; 42 friend class TTreeCloner;; 43 friend class TLeafElement;; 44 ; 45/// Types; 46protected:; 47 enum EStatusBits {; 48 kBranchFolder = BIT(14),; 49 kDeleteObject = BIT(16), ///< We are the owner of fObject.; 50 kCache = BIT(18), ///< Need to pushd/pop fOnfileObject.; 51 kOwnOnfileObj = BIT(19), ///< We are the owner of fOnfileObject.; 52 kAddressSet = BIT(20), ///< The addressing set have been called for this branch; 53 kMakeClass = BIT(21), ///< This branch has been switched to using the MakeClass Mode; 54 kDecomposedObj = BIT(21) ///< More explicit alias for kMakeClass.; 55 };; 56 ; 57 ; 58// Data Members; 59protected:; 60 TString fClassName; ///< Class name of referenced object; 61 TString fParentName; ///< Name of parent class; 62 TString fClonesName; ///< Name of class in TClonesArray (if any); 63 TVirtualCollectionProxy *fCollProxy; ///<! collection interface (if any); 64 UInt_t fCheckSum; ///< CheckSum of class; 65 Version_t fClassVersion; ///< Version number of class; 66 Int_t fID; ///< element serial number in fInfo; 67 Int_t fType; ///< Branch type; 68 ///<; 69 ///< Note on fType values:; 70 ///< * -1 unsplit object with custom streamer at time of writing; 71 ///< * 0 unsplit object with default streamer at time of writing; 72 ///< OR simple data member of split object (fID==-1 for the former); 73 ///< * 1 base class of a split object.; 74 ///< * 2 class typed data member of a split object; 75 ///< * 3 branch count of a split TClonesArray; 76 ///< * 31 data member of the content of a split TClonesArray; 77 ///< * 4 branch count of a split STL Collection.; 78 ///< * 41 data member of the content of a split STL collection; 79 Int_t fStreamerType; ///< branch streamer type; 80 Int_t fMaximum; ///< Maximum entries for a TClonesArray or variable array; 81 Int_t fSTLtype; ///<! STL container type; 82 Int_t fNdata; ///<! Number of data in this branch; 83 TBranchElement *fBranchCount; ///< pointer to primary branchcount branch; 84 TBranc",MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
Modifiability,variab,variable, of class; 65 Version_t fClassVersion; ///< Version number of class; 66 Int_t fID; ///< element serial number in fInfo; 67 Int_t fType; ///< Branch type; 68 ///<; 69 ///< Note on fType values:; 70 ///< * -1 unsplit object with custom streamer at time of writing; 71 ///< * 0 unsplit object with default streamer at time of writing; 72 ///< OR simple data member of split object (fID==-1 for the former); 73 ///< * 1 base class of a split object.; 74 ///< * 2 class typed data member of a split object; 75 ///< * 3 branch count of a split TClonesArray; 76 ///< * 31 data member of the content of a split TClonesArray; 77 ///< * 4 branch count of a split STL Collection.; 78 ///< * 41 data member of the content of a split STL collection; 79 Int_t fStreamerType; ///< branch streamer type; 80 Int_t fMaximum; ///< Maximum entries for a TClonesArray or variable array; 81 Int_t fSTLtype; ///<! STL container type; 82 Int_t fNdata; ///<! Number of data in this branch; 83 TBranchElement *fBranchCount; ///< pointer to primary branchcount branch; 84 TBranchElement *fBranchCount2; ///< pointer to secondary branchcount branch; 85 TStreamerInfo *fInfo; ///<! Pointer to StreamerInfo; 86 char *fObject; ///<! Pointer to object at *fAddress; 87 TVirtualArray *fOnfileObject; ///<! Place holder for the onfile representation of data members.; 88 bool fInit : 1; ///<! Initialization flag for branch assignment; 89 bool fInInitInfo : 1;///<! True during the 2nd part of InitInfo (cut recursion).; 90 bool fInitOffsets: 1;///<! Initialization flag to not endlessly recalculate offsets; 91 TClassRef fTargetClass; ///<! Reference to the target in-memory class; 92 TClassRef fCurrentClass; ///<! Reference to current (transient) class definition; 93 TClassRef fParentClass; ///<! Reference to class definition in fParentName; 94 TClassRef fBranchClass; ///<! Reference to class definition in fClassName; 95 TClassRef fClonesClass; ///<! Reference to class definition in fClonesName; 96 Int_t *fBranchOffset; ///<!,MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
Performance,load,loaded,6; TBranchElement::fIDInt_t fIDelement serial number in fInfoDefinition TBranchElement.h:66; TBranchElement::GetAddresschar * GetAddress() const overrideGet the branch address.Definition TBranchElement.cxx:1923; TBranchElement::FillLeavesMemberCountervoid FillLeavesMemberCounter(TBuffer &b)Write leaves into i/o buffers for this branch.Definition TBranchElement.cxx:1697; TBranchElement::SetBranchCount2void SetBranchCount2(TBranchElement *bre)Definition TBranchElement.h:124; TBranchElement::FillLeavesCollectionSplitPtrMembervoid FillLeavesCollectionSplitPtrMember(TBuffer &b)Write leaves into i/o buffers for this branch.Definition TBranchElement.cxx:1499; TBranchElement::SetAddressvoid SetAddress(void *addobj) overridePoint this branch at an object.Definition TBranchElement.cxx:4962; TBranchElement::GetInfoImpTStreamerInfo * GetInfoImp() constGet streamer info for the branch class.Definition TBranchElement.cxx:1011; TBranchElement::SetTargetClassvirtual void SetTargetClass(const char *name)Set the name of the class of the in-memory object into which the data will loaded.Definition TBranchElement.cxx:5855; TBranchElement::ResetDeleteObjectvirtual void ResetDeleteObject()Release ownership of any allocated objects.Definition TBranchElement.cxx:4814; TBranchElement::GetParentNamevirtual const char * GetParentName() constDefinition TBranchElement.h:200; TBranchElement::ValidateAddressvoid ValidateAddress() constDefinition TBranchElement.h:264; TBranchElement::GetOnfileObjectTVirtualArray * GetOnfileObject() constDefinition TBranchElement.h:199; TBranchElement::fWriteIteratorsTVirtualCollectionIterators * fWriteIterators! holds the read (non-staging) iterators when the branch is of fType==4 and associative containers.Definition TBranchElement.h:102; TBranchElement::PrintValuevoid PrintValue(Int_t i) constPrints values of leaves.Definition TBranchElement.cxx:3928; TBranchElement::fOnfileObjectTVirtualArray * fOnfileObject! Place holder for the onfile representation of data mem,MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
Security,access,access,"id SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TStreamerInfoActions::TActionSequence::SequenceGetter_tSequencePtr(*)(TStreamerInfo *info, TVirtualCollectionProxy *collectionProxy, TClass *originalClass) SequenceGetter_tDefinition TStreamerInfoActions.h:185; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TTreeClonerClass implementing or helping the various TTree cloning method.Definition TTreeCloner.h:31; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetMakeClassInt_t GetMakeClass() constDefinition TTree.h:535; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; TVirtualCollectionIteratorsSmall helper class to generically acquire and release iterators.Definition TVirtualCollectionIterators.h:26; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionPtrIteratorsDefinition TVirtualCollectionIterators.h:195; double; int; unsigned int; TStreamerInfoActions::TIDsstd::vector< TIDNode > TIDsDefinition TStreamerInfoActions.h:138; ROOT::RCompressionSetting::EAlgorithm::kInherit@ kInheritSome objects use this value to denote that the compression algorithm should be inherited from the par...Definition Compression.h:91. treetreeincTBranchElement.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:04 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
Usability,simpl,simple,"ranch {; 40 ; 41// Friends; 42 friend class TTreeCloner;; 43 friend class TLeafElement;; 44 ; 45/// Types; 46protected:; 47 enum EStatusBits {; 48 kBranchFolder = BIT(14),; 49 kDeleteObject = BIT(16), ///< We are the owner of fObject.; 50 kCache = BIT(18), ///< Need to pushd/pop fOnfileObject.; 51 kOwnOnfileObj = BIT(19), ///< We are the owner of fOnfileObject.; 52 kAddressSet = BIT(20), ///< The addressing set have been called for this branch; 53 kMakeClass = BIT(21), ///< This branch has been switched to using the MakeClass Mode; 54 kDecomposedObj = BIT(21) ///< More explicit alias for kMakeClass.; 55 };; 56 ; 57 ; 58// Data Members; 59protected:; 60 TString fClassName; ///< Class name of referenced object; 61 TString fParentName; ///< Name of parent class; 62 TString fClonesName; ///< Name of class in TClonesArray (if any); 63 TVirtualCollectionProxy *fCollProxy; ///<! collection interface (if any); 64 UInt_t fCheckSum; ///< CheckSum of class; 65 Version_t fClassVersion; ///< Version number of class; 66 Int_t fID; ///< element serial number in fInfo; 67 Int_t fType; ///< Branch type; 68 ///<; 69 ///< Note on fType values:; 70 ///< * -1 unsplit object with custom streamer at time of writing; 71 ///< * 0 unsplit object with default streamer at time of writing; 72 ///< OR simple data member of split object (fID==-1 for the former); 73 ///< * 1 base class of a split object.; 74 ///< * 2 class typed data member of a split object; 75 ///< * 3 branch count of a split TClonesArray; 76 ///< * 31 data member of the content of a split TClonesArray; 77 ///< * 4 branch count of a split STL Collection.; 78 ///< * 41 data member of the content of a split STL collection; 79 Int_t fStreamerType; ///< branch streamer type; 80 Int_t fMaximum; ///< Maximum entries for a TClonesArray or variable array; 81 Int_t fSTLtype; ///<! STL container type; 82 Int_t fNdata; ///<! Number of data in this branch; 83 TBranchElement *fBranchCount; ///< pointer to primary branchcount branch; 84 TBranc",MatchSource.WIKI,doc/master/TBranchElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html
Availability,avail,available,"ype);; 384 } else if (*leaftype == 'f') {; 385 leaf = new TLeafF16(this, leafname, leaftype);; 386 } else if (*leaftype == 'L') {; 387 leaf = new TLeafL(this, leafname, leaftype);; 388 } else if (*leaftype == 'l') {; 389 leaf = new TLeafL(this, leafname, leaftype);; 390 leaf->SetUnsigned();; 391 } else if (*leaftype == 'D') {; 392 leaf = new TLeafD(this, leafname, leaftype);; 393 } else if (*leaftype == 'd') {; 394 leaf = new TLeafD32(this, leafname, leaftype);; 395 } else if (*leaftype == 'G') {; 396 leaf = new TLeafG(this, leafname, leaftype);; 397 } else if (*leaftype == 'g') {; 398 leaf = new TLeafG(this, leafname, leaftype);; 399 leaf->SetUnsigned();; 400 }; 401 if (!leaf) {; 402 Error(""TLeaf"", ""Illegal data type for %s/%s"", name, leaflist);; 403 delete[] leaftype;; 404 delete [] leafname;; 405 MakeZombie();; 406 return;; 407 }; 408 if (leaf->IsZombie()) {; 409 delete leaf;; 410 leaf = nullptr;; 411 auto msg = ""Illegal leaf: %s/%s. If this is a variable size C array it's possible that the branch holding the size is not available."";; 412 Error(""TBranch"", msg, name, leaflist);; 413 delete [] leafname;; 414 delete[] leaftype;; 415 MakeZombie();; 416 return;; 417 }; 418 leaf->SetBranch(this);; 419 leaf->SetAddress((char*) (fAddress + offset));; 420 leaf->SetOffset(offset);; 421 if (leaf->GetLeafCount()) {; 422 // -- Leaf is a varying length array, we need an offset array.; 423 fEntryOffsetLen = 1000;; 424 }; 425 if (leaf->InheritsFrom(TLeafC::Class())) {; 426 // -- Leaf is a character string, we need an offset array.; 427 fEntryOffsetLen = 1000;; 428 }; 429 ++fNleaves;; 430 fLeaves.Add(leaf);; 431 fTree->GetListOfLeaves()->Add(leaf);; 432 if (*pos == 0) {; 433 // -- We reached the end of the leaf specification.; 434 break;; 435 }; 436 nameBegin = pos + 1;; 437 offset += leaf->GetLenType() * leaf->GetLen();; 438 }; 439 }; 440 delete[] leafname;; 441 leafname = nullptr;; 442 delete[] leaftype;; 443 leaftype = nullptr;; 444 ; 445}; 446 ; 447///////////////////////////",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
Deployability,update,update,"7 if (ondisk) {; 608 fTotBytes += basket->GetObjlen() + basket->GetKeylen() ;; 609 fZipBytes += basket->GetNbytes();; 610 fTree->AddTotBytes(basket->GetObjlen() + basket->GetKeylen());; 611 fTree->AddZipBytes(basket->GetNbytes());; 612 }; 613}; 614 ; 615////////////////////////////////////////////////////////////////////////////////; 616/// Add the start entry of the write basket (not yet created); 617 ; 618void TBranch::AddLastBasket(Long64_t startEntry); 619{; 620 if (fWriteBasket >= fMaxBaskets) {; 621 ExpandBasketArrays();; 622 }; 623 Int_t where = fWriteBasket;; 624 ; 625 if (where && startEntry < fBasketEntry[where-1]) {; 626 // Need to find the right location and move the possible baskets; 627 ; 628 Fatal(""AddBasket"",""The last basket must have the highest entry number (%s/%lld/%d)."",GetName(),startEntry,fWriteBasket);; 629 ; 630 }; 631 // The first basket (should) always start at zero. If we are asked to update; 632 // it, this likely to be from merging 'empty' branches (base class node and the likes); 633 if (where) {; 634 fBasketEntry[where] = startEntry;; 635 fBaskets.AddAtAndExpand(nullptr,fWriteBasket);; 636 }; 637}; 638 ; 639////////////////////////////////////////////////////////////////////////////////; 640/// Loop on all leaves of this branch to back fill Basket buffer.; 641///; 642/// Use this routine instead of TBranch::Fill when filling a branch individually; 643/// to catch up with the number of entries already in the TTree.; 644///; 645/// First it calls TBranch::Fill and then if the number of entries of the branch; 646/// reach one of TTree cluster's boundary, the basket is flushed.; 647///; 648/// The function returns the number of bytes committed to the memory basket.; 649/// If a write error occurs, the number of bytes returned is -1.; 650/// If no data are written, because e.g. the branch is disabled,; 651/// the number of bytes returned is 0.; 652///; 653/// To insure that the baskets of each cluster are located close by in the; 654/// fil",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
Integrability,depend,dependent,"ariable type must be 1 character. (Characters; 142/// after the first are legal and will be appended to the visible; 143/// name of the leaf, but have no effect.) If no type is given, the; 144/// type of the variable is assumed to be the same as the previous; 145/// variable. If the first variable does not have a type, it is; 146/// assumed of type F by default. The list of currently supported; 147/// types is given below:; 148/// - `C` : a character string terminated by the 0 character; 149/// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 150/// - `b` : an 8 bit unsigned integer (`UChar_t`); 151/// - `S` : a 16 bit signed integer (`Short_t`); 152/// - `s` : a 16 bit unsigned integer (`UShort_t`); 153/// - `I` : a 32 bit signed integer (`Int_t`); 154/// - `i` : a 32 bit unsigned integer (`UInt_t`); 155/// - `F` : a 32 bit floating point (`Float_t`); 156/// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 157/// - `D` : a 64 bit floating point (`Double_t`); 158/// - `d` : a 24 bit truncated floating point (`Double32_t`); 159/// - `L` : a 64 bit signed integer (`Long64_t`); 160/// - `l` : a 64 bit unsigned integer (`ULong64_t`); 161/// - `G` : a long signed integer (`Long_t`, which `sizeof` is platform dependent), stored as a 64 bit integer but usually held in memory as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; 162/// - `g` : a long unsigned integer (`ULong_t`, which `sizeof` is platform dependent), stored as a 64 bit unsigned integer but held in memory usually as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; 163/// - `O` : [the letter `o`, not a zero] a boolean (`bool`); 164///; 165/// Arrays of values are supported with the following syntax:; 166/// - If leaf name has the form var[nelem], where nelem is alphanumeric, then; 167///",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
Modifiability,variab,variable,"); 107, fFirstEntry(0); 108, fTotBytes(0); 109, fZipBytes(0); 110, fBranches(); 111, fLeaves(); 112, fBaskets(fMaxBaskets); 113, fBasketBytes(nullptr); 114, fBasketEntry(nullptr); 115, fBasketSeek(nullptr); 116, fTree(nullptr); 117, fMother(nullptr); 118, fParent(nullptr); 119, fAddress(nullptr); 120, fDirectory(nullptr); 121, fFileName(""""); 122, fEntryBuffer(nullptr); 123, fTransientBuffer(nullptr); 124, fBrowsables(nullptr); 125, fBulk(*this); 126, fSkipZip(false); 127, fReadLeaves(&TBranch::ReadLeavesImpl); 128, fFillLeaves(&TBranch::FillLeavesImpl); 129{; 130 SetBit(TBranch::kDoNotUseBufferMap);; 131}; 132 ; 133////////////////////////////////////////////////////////////////////////////////; 134/// Create a Branch as a child of a Tree; 135///; 136/// * address is the address of the first item of a structure; 137/// or the address of a pointer to an object (see example in TTree.cxx).; 138/// * leaflist is the concatenation of all the variable names and types; 139/// separated by a colon character :; 140/// The variable name and the variable type are separated by a; 141/// slash (/). The variable type must be 1 character. (Characters; 142/// after the first are legal and will be appended to the visible; 143/// name of the leaf, but have no effect.) If no type is given, the; 144/// type of the variable is assumed to be the same as the previous; 145/// variable. If the first variable does not have a type, it is; 146/// assumed of type F by default. The list of currently supported; 147/// types is given below:; 148/// - `C` : a character string terminated by the 0 character; 149/// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 150/// - `b` : an 8 bit unsigned integer (`UChar_t`); 151/// - `S` : a 16 bit signed integer (`Short_t`); 152/// - `s` : a 16 bit unsigned integer (`UShort_t`); 153/// - `I` : a 32 bit signed integer (`Int_t`); 154/// - `i` : a 32 bit unsigned integer (`UInt_t`); 155/// - `F` : a 32 bit floating point (`Fl",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
Performance,cache,cache," }; 1245 // if cluster pre-fetching or retaining is on, do not re-use existing baskets; 1246 // unless a new cluster is used.; 1247 if (fTree->GetMaxVirtualSize() < 0 || fTree->GetClusterPrefetch()); 1248 basket = GetFreshCluster(user_buffer);; 1249 else; 1250 basket = GetFreshBasket(basketnumber, user_buffer);; 1251 ; 1252 // fSkipZip is old stuff still maintained for CDF; 1253 if (fSkipZip) basket->SetBit(TBufferFile::kNotDecompressed);; 1254 if (fBasketBytes[basketnumber] == 0) {; 1255 fBasketBytes[basketnumber] = basket->ReadBasketBytes(fBasketSeek[basketnumber],file);; 1256 }; 1257 //add branch to cache (if any); 1258 {; 1259 R__LOCKGUARD_IMT(gROOTMutex); // Lock for parallel TTree I/O; 1260 TFileCacheRead *pf = fTree->GetReadCache(file);; 1261 if (pf){; 1262 if (pf->IsLearning()) pf->LearnBranch(this, false);; 1263 if (fSkipZip) pf->SetSkipZip();; 1264 }; 1265 }; 1266 ; 1267 //now read basket; 1268 Int_t badread = basket->ReadBasketBuffers(fBasketSeek[basketnumber],fBasketBytes[basketnumber],file);; 1269 if (R__unlikely(badread || basket->GetSeekKey() != fBasketSeek[basketnumber] || basket->IsZombie())) {; 1270 nerrors++;; 1271 if (nerrors > 10) return nullptr;; 1272 if (nerrors == 10) {; 1273 printf("" file probably overwritten: stopping reporting error messages\n"");; 1274 if (fBasketSeek[basketnumber] > 2000000000) {; 1275 printf(""===>File is more than 2 Gigabytes\n"");; 1276 return nullptr;; 1277 }; 1278 if (fBasketSeek[basketnumber] > 1000000000) {; 1279 printf(""===>Your file is may be bigger than the maximum file size allowed on your system\n"");; 1280 printf("" Check your AFS maximum file size limit for example\n"");; 1281 return nullptr;; 1282 }; 1283 }; 1284 Error(""GetBasket"",""File: %s at byte:%lld, branch:%s, entry:%lld, badread=%d, nerrors=%d, basketnumber=%d"",file->GetName(),basket->GetSeekKey(),GetName(),fReadEntry,badread,nerrors.load(),basketnumber);; 1285 return nullptr;; 1286 }; 1287 ; 1288 ++fNBaskets;; 1289 ; 1290 fCacheInfo.SetUsed(basketnumber);;",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
Safety,avoid,avoid,"//////////////////////////////////////////////////////////////////////; 752/// Loop on all branch baskets. Drop all baskets from memory except readbasket.; 753/// If the option contains ""all"", drop all baskets including; 754/// read- and write-baskets (unless they are not stored individually on disk).; 755/// The option ""all"" also lead to DropBaskets being called on the sub-branches.; 756 ; 757void TBranch::DropBaskets(Option_t* options); 758{; 759 bool all = false;; 760 if (options && options[0]) {; 761 TString opt = options;; 762 opt.ToLower();; 763 if (opt.Contains(""all"")) all = true;; 764 }; 765 ; 766 TBasket *basket;; 767 Int_t nbaskets = fBaskets.GetEntriesFast();; 768 ; 769 if ( (fNBaskets>1) || all ) {; 770 //slow case; 771 for (Int_t i=0;i<nbaskets;i++) {; 772 basket = (TBasket*)fBaskets.UncheckedAt(i);; 773 if (!basket) continue;; 774 if ((i == fReadBasket || i == fWriteBasket) && !all) continue;; 775 // if the basket is not yet on file but already has event in it; 776 // we must continue to avoid dropping the basket (and thus losing data); 777 if (fBasketBytes[i]==0 && basket->GetNevBuf() > 0) continue;; 778 basket->DropBuffers();; 779 --fNBaskets;; 780 fBaskets.RemoveAt(i);; 781 if (basket == fCurrentBasket) {; 782 fCurrentBasket = nullptr;; 783 fFirstBasketEntry = -1;; 784 fNextBasketEntry = -1;; 785 }; 786 delete basket;; 787 }; 788 ; 789 // process subbranches; 790 if (all) {; 791 TObjArray *lb = GetListOfBranches();; 792 Int_t nb = lb->GetEntriesFast();; 793 for (Int_t j = 0; j < nb; j++) {; 794 TBranch* branch = (TBranch*) lb->UncheckedAt(j);; 795 if (!branch) continue;; 796 branch->DropBaskets(""all"");; 797 }; 798 }; 799 } else {; 800 //fast case; 801 if (nbaskets > 0) {; 802 Int_t i = fBaskets.GetLast();; 803 basket = (TBasket*)fBaskets.UncheckedAt(i);; 804 if (basket && fBasketBytes[i]!=0) {; 805 basket->DropBuffers();; 806 if (basket == fCurrentBasket) {; 807 fCurrentBasket = nullptr;; 808 fFirstBasketEntry = -1;; 809 fNextBasketEntry = -1;; 810 ",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
Security,access,access,"/// it is used as a 2 dimensional array of fixed size.; 175/// - In case of the truncated floating point types (Float16_t and Double32_t) you can; 176/// furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after; 177/// the type character. See `TStreamerElement::GetRange()` for further information.; 178/// - Any of other form is not supported.; 179///; 180/// Note that the TTree will assume that all the item are contiguous in memory.; 181/// On some platform, this is not always true of the member of a struct or a class,; 182/// due to padding and alignment. Sorting your data member in order of decreasing; 183/// sizeof usually leads to their being contiguous in memory.; 184///; 185/// * bufsize is the buffer size in bytes for this branch; 186/// The default value is 32000 bytes and should be ok for most cases.; 187/// You can specify a larger value (e.g. 256000) if your Tree is not split; 188/// and each entry is large (Megabytes); 189/// A small value for bufsize is optimum if you intend to access; 190/// the entries in the Tree randomly and your Tree is in split mode.; 191///; 192/// See an example of a Branch definition in the TTree constructor.; 193///; 194/// Note that in case the data type is an object, this branch can contain; 195/// only this object.; 196///; 197/// Note that this function is invoked by TTree::Branch; 198 ; 199TBranch::TBranch(TTree *tree, const char *name, void *address, const char *leaflist, Int_t basketsize, Int_t compress); 200 : TNamed(name, leaflist); 201, TAttFill(0, 1001); 202, fCompress(compress); 203, fBasketSize((basketsize < 100) ? 100 : basketsize); 204, fEntryOffsetLen(0); 205, fWriteBasket(0); 206, fEntryNumber(0); 207, fExtraBasket(nullptr); 208, fIOFeatures(tree ? tree->GetIOFeatures().GetFeatures() : 0); 209, fOffset(0); 210, fMaxBaskets(10); 211, fNBaskets(0); 212, fSplitLevel(0); 213, fNleaves(0); 214, fReadBasket(0); 215, fReadEntry(-1); 216, fFirstBasketEntry(-1); 217, fNextBasketEntry(-1); 218, ",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
Testability,test,test,"e of a TChain, the entry number in the current Tree must be found; 1692/// before calling this function. For example:; 1693///; 1694///~~~ {.cpp}; 1695/// TChain* chain = ...;; 1696/// Long64_t localEntry = chain->LoadTree(entry);; 1697/// branch->GetEntry(localEntry);; 1698///~~~; 1699///; 1700/// The function returns the number of bytes read from the input buffer.; 1701/// If entry does not exist, the function returns 0.; 1702/// If an I/O error occurs, the function returns -1.; 1703///; 1704/// See IMPORTANT REMARKS in TTree::GetEntry.; 1705 ; 1706Int_t TBranch::GetEntry(Long64_t entry, Int_t getall); 1707{; 1708 // Remember which entry we are reading.; 1709 fReadEntry = entry;; 1710 ; 1711 if (R__unlikely(TestBit(kDoNotProcess) && !getall)) { return 0; }; 1712 ; 1713 TBasket *basket; // will be initialized in the if/then clauses.; 1714 Long64_t first;; 1715 ; 1716 Int_t result = GetBasketAndFirst(basket, first, nullptr);; 1717 if (R__unlikely(result < 0)) { return result + 1; }; 1718 ; 1719 basket->PrepareBasket(entry);; 1720 TBuffer* buf = basket->GetBufferRef();; 1721 ; 1722 // This test necessary to read very old Root files (NvE).; 1723 if (R__unlikely(!buf)) {; 1724 TFile* file = GetFile(0);; 1725 if (!file) return -1;; 1726 basket->ReadBasketBuffers(fBasketSeek[fReadBasket], fBasketBytes[fReadBasket], file);; 1727 buf = basket->GetBufferRef();; 1728 }; 1729 ; 1730 // Set entry offset in buffer.; 1731 if (!TestBit(kDoNotUseBufferMap)) {; 1732 buf->ResetMap();; 1733 }; 1734 if (R__unlikely(!buf->IsReading())) {; 1735 basket->SetReadMode();; 1736 }; 1737 ; 1738 Int_t* entryOffset = basket->GetEntryOffset();; 1739 Int_t bufbegin = 0;; 1740 if (entryOffset) {; 1741 bufbegin = entryOffset[entry-first];; 1742 buf->SetBufferOffset(bufbegin);; 1743 Int_t* displacement = basket->GetDisplacement();; 1744 if (R__unlikely(displacement)) {; 1745 buf->SetBufferDisplacement(displacement[entry-first]);; 1746 }; 1747 } else {; 1748 bufbegin = basket->GetKeylen() + ((entry-fi",MatchSource.WIKI,doc/master/TBranch_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html
Deployability,update,updateSubBranches,"Print(Option_t *option="""") const override;; 263 void PrintCacheInfo() const;; 264 virtual void ReadBasket(TBuffer &b);; 265 virtual void Refresh(TBranch *b);; 266 virtual void Reset(Option_t *option="""");; 267 virtual void ResetAfterMerge(TFileMergeInfo *);; 268 virtual void ResetAddress();; 269 virtual void ResetReadEntry() {fReadEntry = -1;}; 270 virtual void SetAddress(void *add);; 271 virtual void SetObject(void *objadd);; 272 virtual void SetAutoDelete(bool autodel=true);; 273 virtual void SetBasketSize(Int_t buffsize);; 274 virtual void SetBufferAddress(TBuffer *entryBuffer);; 275 void SetCompressionAlgorithm(Int_t algorithm = ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);; 276 void SetCompressionLevel(Int_t level = ROOT::RCompressionSetting::ELevel::kUseMin);; 277 void SetCompressionSettings(Int_t settings = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);; 278 virtual void SetEntries(Long64_t entries);; 279 virtual void SetEntryOffsetLen(Int_t len, bool updateSubBranches = false);; 280 virtual void SetFirstEntry(Long64_t entry);; 281 virtual void SetFile(TFile *file = nullptr);; 282 virtual void SetFile(const char *filename);; 283 void SetIOFeatures(TIOFeatures &features) {fIOFeatures = features;}; 284 virtual bool SetMakeClass(bool decomposeObj = true);; 285 virtual void SetOffset(Int_t offset=0) {fOffset=offset;}; 286 virtual void SetStatus(bool status=true);; 287 virtual void SetTree(TTree *tree) { fTree = tree; }; 288 virtual void SetupAddresses();; 289 bool SupportsBulkRead() const;; 290 virtual void UpdateAddress() {}; 291 virtual void UpdateFile();; 292 ; 293 static void ResetCount();; 294 ; 295 ClassDefOverride(TBranch, 13); // Branch descriptor; 296};; 297 ; 298//______________________________________________________________________________; 299inline Int_t TBranch::GetCompressionAlgorithm() const; 300{; 301 return (fCompress < 0) ? -1 : fCompress / 100;; 302}; 303 ; 304//_______________________________________________________________",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
Integrability,interface,interfaces,"space Internal {; 48class TBulkBranchRead;; 49}; 50}; 51namespace Internal {; 52class TBranchIMTHelper; ///< A helper class for managing IMT work during TTree:Fill operations.; 53}; 54}; 55 ; 56const Int_t kDoNotProcess = BIT(10); // Active bit for branches; 57const Int_t kIsClone = BIT(11); // to indicate a TBranchClones; 58const Int_t kBranchObject = BIT(12); // branch is a TObject*; 59const Int_t kBranchAny = BIT(17); // branch is an object*; 60const Int_t kMapObject = kBranchObject | kBranchAny;; 61 ; 62namespace ROOT {; 63namespace Experimental {; 64namespace Internal {; 65 ; 66///\class TBulkBranchRead; 67/// Helper class for reading many branch entries at once to optimize throughput.; 68class TBulkBranchRead {; 69 ; 70 friend class ::TBranch;; 71 ; 72public:; 73 /// See TBranch::GetBulkEntries(Long64_t evt, TBuffer &user_buf);; 74 Int_t GetBulkEntries(Long64_t evt, TBuffer &user_buf);; 75 /// See TBranch::GetEntriesSerialized(Long64_t evt, TBuffer &user_buf);; 76 Int_t GetEntriesSerialized(Long64_t evt, TBuffer &user_buf);; 77 /// See TBranch::GetEntriesSerialized(Long64_t evt, TBuffer &user_buf, TBuffer *count_buf);; 78 Int_t GetEntriesSerialized(Long64_t evt, TBuffer &user_buf, TBuffer *count_buf);; 79 /// Return true if the branch can be read through the bulk interfaces.; 80 bool SupportsBulkRead() const;; 81 ; 82private:; 83 TBulkBranchRead(TBranch &parent); 84 : fParent(parent); 85 {}; 86 ; 87 TBranch &fParent;; 88};; 89}; 90}; 91}; 92 ; 93class TBranch : public TNamed, public TAttFill {; 94 using TIOFeatures = ROOT::TIOFeatures;; 95 ; 96protected:; 97 friend class TTreeCache;; 98 friend class TTreeCloner;; 99 friend class TTree;; 100 friend class TBranchElement;; 101 friend class ROOT::Experimental::Internal::TBulkBranchRead;; 102 ; 103 /// TBranch status bits; 104 enum EStatusBits {; 105 kDoNotProcess = ::kDoNotProcess, ///< Active bit for branches; 106 kIsClone = ::kIsClone, ///< To indicate a TBranchClones; 107 kBranchObject = ::kBranchObject, ///< B",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
Modifiability,variab,variable,"n this branch; 136 Long64_t fTotBytes; ///< Total number of bytes in all leaves before compression; 137 Long64_t fZipBytes; ///< Total number of bytes in all leaves after compression; 138 TObjArray fBranches; ///< -> List of Branches of this branch; 139 TObjArray fLeaves; ///< -> List of leaves of this branch; 140 TObjArray fBaskets; ///< -> List of baskets of this branch; 141 Int_t *fBasketBytes; ///<[fMaxBaskets] Length of baskets on file; 142 Long64_t *fBasketEntry; ///<[fMaxBaskets] Table of first entry in each basket; 143 Long64_t *fBasketSeek; ///<[fMaxBaskets] Addresses of baskets on file; 144 TTree *fTree; ///<! Pointer to Tree header; 145 TBranch *fMother; ///<! Pointer to top-level parent branch in the tree.; 146 TBranch *fParent; ///<! Pointer to parent branch.; 147 char *fAddress; ///<! Address of 1st leaf (variable or object); 148 TDirectory *fDirectory; ///<! Pointer to directory where this branch buffers are stored; 149 TString fFileName; ///< Name of file where buffers are stored ("""" if in same file as Tree header); 150 TBuffer *fEntryBuffer; ///<! Buffer used to directly pass the content without streaming; 151 TBuffer *fTransientBuffer; ///<! Pointer to the current transient buffer.; 152 TList *fBrowsables; ///<! List of TVirtualBranchBrowsables used for Browse(); 153 BulkObj fBulk; ///<! Helper for performing bulk IO; 154 ; 155 bool fSkipZip; ///<! After being read, the buffer will not be unzipped.; 156 ; 157 using CacheInfo_t = ROOT::Internal::TBranchCacheInfo;; 158 CacheInfo_t fCacheInfo; ///<! Hold info about which basket are in the cache and if they have been retrieved from the cache.; 159 ; 160 typedef void (TBranch::*ReadLeaves_t)(TBuffer &b);; 161 ReadLeaves_t fReadLeaves; ///<! Pointer to the ReadLeaves implementation to use.; 162 typedef void (TBranch::*FillLeaves_t)(TBuffer &b);; 163 FillLeaves_t fFillLeaves; ///<! Pointer to the FillLeaves implementation to use.; 164 void ReadLeavesImpl(TBuffer &b);; 165 void ReadLeaves0Impl(TBuffer &b);",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
Performance,optimiz,optimize,"ranch description) //; 24//////////////////////////////////////////////////////////////////////////; 25 ; 26#include ""TNamed.h""; 27#include ""TAttFill.h""; 28#include ""TObjArray.h""; 29#include ""TBranchCacheInfo.h""; 30#include ""TDataType.h""; 31#include ""Compression.h""; 32#include ""ROOT/TIOFeatures.hxx""; 33 ; 34class TTree;; 35class TBasket;; 36class TBranchElement;; 37class TLeaf;; 38class TBrowser;; 39class TDirectory;; 40class TFile;; 41class TClonesArray;; 42class TTreeCloner;; 43class TTreeCache;; 44 ; 45namespace ROOT {; 46namespace Experimental {; 47namespace Internal {; 48class TBulkBranchRead;; 49}; 50}; 51namespace Internal {; 52class TBranchIMTHelper; ///< A helper class for managing IMT work during TTree:Fill operations.; 53}; 54}; 55 ; 56const Int_t kDoNotProcess = BIT(10); // Active bit for branches; 57const Int_t kIsClone = BIT(11); // to indicate a TBranchClones; 58const Int_t kBranchObject = BIT(12); // branch is a TObject*; 59const Int_t kBranchAny = BIT(17); // branch is an object*; 60const Int_t kMapObject = kBranchObject | kBranchAny;; 61 ; 62namespace ROOT {; 63namespace Experimental {; 64namespace Internal {; 65 ; 66///\class TBulkBranchRead; 67/// Helper class for reading many branch entries at once to optimize throughput.; 68class TBulkBranchRead {; 69 ; 70 friend class ::TBranch;; 71 ; 72public:; 73 /// See TBranch::GetBulkEntries(Long64_t evt, TBuffer &user_buf);; 74 Int_t GetBulkEntries(Long64_t evt, TBuffer &user_buf);; 75 /// See TBranch::GetEntriesSerialized(Long64_t evt, TBuffer &user_buf);; 76 Int_t GetEntriesSerialized(Long64_t evt, TBuffer &user_buf);; 77 /// See TBranch::GetEntriesSerialized(Long64_t evt, TBuffer &user_buf, TBuffer *count_buf);; 78 Int_t GetEntriesSerialized(Long64_t evt, TBuffer &user_buf, TBuffer *count_buf);; 79 /// Return true if the branch can be read through the bulk interfaces.; 80 bool SupportsBulkRead() const;; 81 ; 82private:; 83 TBulkBranchRead(TBranch &parent); 84 : fParent(parent); 85 {}; 86 ; 87 TBranch ",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
Safety,avoid,avoid,"nch.cxx:2763; TBranch::UpdateAddressvirtual void UpdateAddress()Definition TBranch.h:290; TBranch::GetOffsetInt_t GetOffset() constDefinition TBranch.h:235; TBranch::SetEntryOffsetLenvirtual void SetEntryOffsetLen(Int_t len, bool updateSubBranches=false)Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and...Definition TBranch.cxx:2821; TBranch::FindLeafvirtual TLeaf * FindLeaf(const char *name)Find the leaf corresponding to the name 'searchname'.Definition TBranch.cxx:1081; TBranch::fBulkBulkObj fBulk! Helper for performing bulk IODefinition TBranch.h:153; TBranch::GetReadEntryLong64_t GetReadEntry() constDefinition TBranch.h:237; TBranch::fCacheInfoCacheInfo_t fCacheInfo! Hold info about which basket are in the cache and if they have been retrieved from the cache.Definition TBranch.h:158; TBranch::GetListOfBasketsTObjArray * GetListOfBaskets()Definition TBranch.h:245; TBranch::SetBufferAddressvirtual void SetBufferAddress(TBuffer *entryBuffer)Set address of this branch directly from a TBuffer to avoid streaming.Definition TBranch.cxx:2745; TBranch::GetEntriesLong64_t GetEntries() constDefinition TBranch.h:251; TBranch::fNleavesInt_t fNleaves! Number of leavesDefinition TBranch.h:128; TBranch::fSplitLevelInt_t fSplitLevelBranch split level.Definition TBranch.h:127; TBranch::WriteBasketImplInt_t WriteBasketImpl(TBasket *basket, Int_t where, ROOT::Internal::TBranchIMTHelper *)Write the current basket to disk and return the number of bytes written to the file.Definition TBranch.cxx:3202; TBranch::UpdateFilevirtual void UpdateFile()Refresh the value of fDirectory (i.e.Definition TBranch.cxx:3304; TBranch::SetSkipZipvoid SetSkipZip(bool skip=true)Definition TBranch.h:170; TBranch::GetReadBasketInt_t GetReadBasket() constDefinition TBranch.h:236; TBranch::fBasketBytesInt_t * fBasketBytes[fMaxBaskets] Length of baskets on fileDefinition TBranch.h:141; TBranch::fNextBasketEntryLong64_t fNextBasketEntry! Next entry that will re",MatchSource.WIKI,doc/master/TBranch_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html
Availability,error,error,"s).Definition TClass.h:517; TContextMenuThis class provides an interface to context sensitive popup menus.Definition TContextMenu.h:44; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TGuiFactory::CreateBrowserImpvirtual TBrowserImp * CreateBrowserImp(TBrowser *b, const char *title, UInt_t width, UInt_t height, Option_t *opt="""")Create a batch version of TBrowserImp.Definition TGuiFactory.cxx:92; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Classstatic TClass * Class(); TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TStringBasic string class.Definition TString.h:139; TStyle::GetScreenFactorFloat_t GetScreenFactor() constDefinition TStyle.h:256; TSystem::AddTimervirtual void AddTimer(TTimer *t)Add timer to list of system timers.Definition TSystem.cxx:471; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::Resetvoid Reset()Reset the timer.Definition TTimer.cxx:159; bool; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17. coreguisrcTBrowser.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TBrowser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBrowser_8cxx_source.html
Integrability,wrap,wrap,"4/00**; 25 ; 26TBrowser invokes by default the Web-based %ROOT file browser [RBrowser](ROOT::RBrowser); 27To change this behaviour, and invoke the standard TBrowser, one should put; 28the following directive in the `.rootrc` file:; 29```; 30Browser.Name: TRootBrowser; 31```; 32*/; 33 ; 34#include ""TBrowser.h""; 35#include ""TGuiFactory.h""; 36#include ""TROOT.h""; 37#include ""TEnv.h""; 38#include ""TSystem.h""; 39#include ""TStyle.h""; 40#include ""TTimer.h""; 41#include ""TContextMenu.h""; 42#include ""TInterpreter.h""; 43#include ""TVirtualMutex.h""; 44#include ""TClass.h""; 45#include ""TApplication.h""; 46 ; 47/** \class TBrowserTimer; 48Called whenever timer times out.; 49*/; 50 ; 51class TBrowserTimer : public TTimer {; 52 ; 53protected:; 54 TBrowser *fBrowser{nullptr};; 55 Bool_t fActivate{kFALSE};; 56 ; 57public:; 58 TBrowserTimer(TBrowser *b, Long_t ms = 1000) : TTimer(ms, kTRUE), fBrowser(b), fActivate(kFALSE) {}; 59 Bool_t Notify() override; 60 {; 61 if (fBrowser) {; 62 if (fBrowser->GetRefreshFlag()) {; 63 fBrowser->SetRefreshFlag(kFALSE);; 64 fActivate = kTRUE;; 65 } else if (fActivate) {; 66 fActivate = kFALSE;; 67 fBrowser->Refresh();; 68 }; 69 }; 70 Reset();; 71 ; 72 return kFALSE;; 73 }; 74};; 75 ; 76/** \class TBrowserObject; 77This class is designed to wrap a Foreign object in order to inject it into the Browse sub-system.; 78*/; 79 ; 80class TBrowserObject : public TNamed {; 81 ; 82public:; 83 TBrowserObject(void *obj, TClass *cl, const char *brname); 84 : TNamed(brname, cl ? cl->GetName() : """"), fObj(obj), fClass(cl); 85 {; 86 if (!cl); 87 Fatal(""Constructor"", ""Class parameter should not be null"");; 88 SetBit(kCanDelete);; 89 }; 90 ; 91 ~TBrowserObject() {}; 92 ; 93 void Browse(TBrowser *b) override { fClass->Browse(fObj, b); }; 94 Bool_t IsFolder() const override { return fClass->IsFolder(fObj); }; 95 TClass *IsA() const override { return fClass; }; 96 ; 97private:; 98 void *fObj; ///<! pointer to the foreign object; 99 TClass *fClass; ///<! pointer to class of the f",MatchSource.WIKI,doc/master/TBrowser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBrowser_8cxx_source.html
Modifiability,inherit,inherits,"ion is specified in the $HOME/.root....Definition TBrowser.cxx:399; TBrowser::AddCheckBoxvoid AddCheckBox(TObject *obj, Bool_t check=kFALSE)Add checkbox for this item.Definition TBrowser.cxx:336; TBrowser::Addvoid Add(TObject *obj, const char *name=nullptr, Int_t check=-1)Add object with name to browser.Definition TBrowser.cxx:303; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Browsevoid Browse(TBrowser *b) overrideThis method is called by a browser to get the class information.Definition TClass.cxx:2077; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TClass::IsCallingNewstatic ENewType IsCallingNew()Static method returning the defConstructor flag passed to TClass::New().Definition TClass.cxx:5969; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Definition TClass.h:517; TContextMenuThis class provides an interface to context sensitive popup menus.Definition TContextMenu.h:44; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TGuiFactory::CreateBrowserImpvirtual TBrowserImp * CreateBrowserImp(TBrowser *b, const char *title, UInt_t width, UInt_t height, Option_t *opt="""")Create a batch version of TBrowserImp.Definition TGuiFactory.cxx:92; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(co",MatchSource.WIKI,doc/master/TBrowser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBrowser_8cxx_source.html
Performance,load,loaded,"owser *b, Long_t ms = 1000) : TTimer(ms, kTRUE), fBrowser(b), fActivate(kFALSE) {}; 59 Bool_t Notify() override; 60 {; 61 if (fBrowser) {; 62 if (fBrowser->GetRefreshFlag()) {; 63 fBrowser->SetRefreshFlag(kFALSE);; 64 fActivate = kTRUE;; 65 } else if (fActivate) {; 66 fActivate = kFALSE;; 67 fBrowser->Refresh();; 68 }; 69 }; 70 Reset();; 71 ; 72 return kFALSE;; 73 }; 74};; 75 ; 76/** \class TBrowserObject; 77This class is designed to wrap a Foreign object in order to inject it into the Browse sub-system.; 78*/; 79 ; 80class TBrowserObject : public TNamed {; 81 ; 82public:; 83 TBrowserObject(void *obj, TClass *cl, const char *brname); 84 : TNamed(brname, cl ? cl->GetName() : """"), fObj(obj), fClass(cl); 85 {; 86 if (!cl); 87 Fatal(""Constructor"", ""Class parameter should not be null"");; 88 SetBit(kCanDelete);; 89 }; 90 ; 91 ~TBrowserObject() {}; 92 ; 93 void Browse(TBrowser *b) override { fClass->Browse(fObj, b); }; 94 Bool_t IsFolder() const override { return fClass->IsFolder(fObj); }; 95 TClass *IsA() const override { return fClass; }; 96 ; 97private:; 98 void *fObj; ///<! pointer to the foreign object; 99 TClass *fClass; ///<! pointer to class of the foreign object; 100};; 101 ; 102ClassImp(TBrowser);; 103 ; 104////////////////////////////////////////////////////////////////////////////////; 105// Make sure the application environment exists and the GUI libs are loaded; 106 ; 107Bool_t TBrowser::InitGraphics(); 108{; 109 // Make sure the application environment exists. It is need for graphics; 110 // (colors are initialized in the TApplication ctor).; 111 if (!gApplication); 112 TApplication::CreateApplication();; 113 // make sure that the Gpad and GUI libs are loaded; 114 TApplication::NeedGraphicsLibs();; 115 ; 116 TString hname = gEnv->GetValue(""Browser.Name"", ""TRootBrowserLite"");; 117 ; 118 Bool_t isweb = gROOT->IsWebDisplay() || (hname == ""ROOT::RWebBrowserImp"");; 119 ; 120 if (gApplication); 121 gApplication->InitializeGraphics(isweb);; 122 ; 123 if (!gROOT->IsB",MatchSource.WIKI,doc/master/TBrowser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBrowser_8cxx_source.html
Security,inject,inject,"4/00**; 25 ; 26TBrowser invokes by default the Web-based %ROOT file browser [RBrowser](ROOT::RBrowser); 27To change this behaviour, and invoke the standard TBrowser, one should put; 28the following directive in the `.rootrc` file:; 29```; 30Browser.Name: TRootBrowser; 31```; 32*/; 33 ; 34#include ""TBrowser.h""; 35#include ""TGuiFactory.h""; 36#include ""TROOT.h""; 37#include ""TEnv.h""; 38#include ""TSystem.h""; 39#include ""TStyle.h""; 40#include ""TTimer.h""; 41#include ""TContextMenu.h""; 42#include ""TInterpreter.h""; 43#include ""TVirtualMutex.h""; 44#include ""TClass.h""; 45#include ""TApplication.h""; 46 ; 47/** \class TBrowserTimer; 48Called whenever timer times out.; 49*/; 50 ; 51class TBrowserTimer : public TTimer {; 52 ; 53protected:; 54 TBrowser *fBrowser{nullptr};; 55 Bool_t fActivate{kFALSE};; 56 ; 57public:; 58 TBrowserTimer(TBrowser *b, Long_t ms = 1000) : TTimer(ms, kTRUE), fBrowser(b), fActivate(kFALSE) {}; 59 Bool_t Notify() override; 60 {; 61 if (fBrowser) {; 62 if (fBrowser->GetRefreshFlag()) {; 63 fBrowser->SetRefreshFlag(kFALSE);; 64 fActivate = kTRUE;; 65 } else if (fActivate) {; 66 fActivate = kFALSE;; 67 fBrowser->Refresh();; 68 }; 69 }; 70 Reset();; 71 ; 72 return kFALSE;; 73 }; 74};; 75 ; 76/** \class TBrowserObject; 77This class is designed to wrap a Foreign object in order to inject it into the Browse sub-system.; 78*/; 79 ; 80class TBrowserObject : public TNamed {; 81 ; 82public:; 83 TBrowserObject(void *obj, TClass *cl, const char *brname); 84 : TNamed(brname, cl ? cl->GetName() : """"), fObj(obj), fClass(cl); 85 {; 86 if (!cl); 87 Fatal(""Constructor"", ""Class parameter should not be null"");; 88 SetBit(kCanDelete);; 89 }; 90 ; 91 ~TBrowserObject() {}; 92 ; 93 void Browse(TBrowser *b) override { fClass->Browse(fObj, b); }; 94 Bool_t IsFolder() const override { return fClass->IsFolder(fObj); }; 95 TClass *IsA() const override { return fClass; }; 96 ; 97private:; 98 void *fObj; ///<! pointer to the foreign object; 99 TClass *fClass; ///<! pointer to class of the f",MatchSource.WIKI,doc/master/TBrowser_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBrowser_8cxx_source.html
Integrability,protocol,protocol,"mbedding(name); }; 120 ; 121 ClassDefOverride(TBrowser,0) //ROOT Object Browser; 122};; 123 ; 124#endif; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Longptr_tlong Longptr_tDefinition RtypesCore.h:75; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Option_tconst char Option_tDefinition RtypesCore.h:66; BIT#define BIT(n)Definition Rtypes.h:90; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TBrowserImp.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; heightOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t heightDefinition TGWin32VirtualXProxy.cxx:164; namechar name[80]Definition TGX11.cxx:110; TNamed.h; TBrowserImpABC describing GUI independent browser implementation protocol.Definition TBrowserImp.h:29; TBrowserImp::Iconifyvirtual void Iconify()Definition TBrowserImp.h:52; TBrowserImp::GetDrawOptionvirtual Option_t * GetDrawOption() constDefinition TBrowserImp.h:57; TBrowserImp::StartEmbeddingvirtual void StartEmbedding(Int_t, Int_t)Definition TBrowserImp.h:62; TBrowserImp::SetStatusTextvirtual void SetStatusText(const char *, Int_t)Definition TBrowserImp.h:61; TBrowserImp::BrowseObjvirtual void BrowseObj(TObject *)Definition TBrowserImp.h:48; TBrowserImp::ExecPluginvirtual Longptr_t ExecPlugin(const char *, const char *, const char *, Int_t, Int_t)Definition TBrowserImp.h:60; TBrowserImp::SetDrawOptionvirtual void SetDrawOption(Option_t *="""")Definition TBrowserImp.h:56; TBrowserImp::IsWebvirtual Bool_t IsWeb() constDefinition TBrowserImp.h:58; TBrowserImp::Showvirtual void Show()Definition TBrowserImp.h:55; TBrowserImp::StopEmbeddingvirtual void StopEmbedding(const char *)Definition TBrowserImp.h:63; TBrowserTimerCall",MatchSource.WIKI,doc/master/TBrowser_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBrowser_8h_source.html
Availability,error,error,"); 74{; 75 if (bufsiz < 0); 76 Fatal(""TBuffer"",""Request to create a buffer with a negative size, likely due to an integer overflow: 0x%x for a max of 0x%x."", bufsiz, kMaxBufferSize);; 77 if (bufsiz < kMinimalSize) bufsiz = kMinimalSize;; 78 fBufSize = bufsiz;; 79 fMode = mode;; 80 fVersion = 0;; 81 fParent = nullptr;; 82 ; 83 SetBit(kIsOwner);; 84 ; 85 fBuffer = new char[fBufSize+kExtraSpace];; 86 ; 87 fBufCur = fBuffer;; 88 fBufMax = fBuffer + fBufSize;; 89 ; 90 SetReAllocFunc( nullptr );; 91}; 92 ; 93////////////////////////////////////////////////////////////////////////////////; 94/// Create an I/O buffer object. Mode should be either TBuffer::kRead or; 95/// TBuffer::kWrite. By default the I/O buffer has a size of; 96/// TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; 97/// to TBuffer via the buf argument. By default this buffer will be adopted; 98/// unless adopt is false.; 99///; 100/// If the new buffer is _not_ adopted and no memory allocation routine; 101/// is provided, a Fatal error will be issued if the Buffer attempts to; 102/// expand.; 103 ; 104TBuffer::TBuffer(EMode mode, Int_t bufsiz, void *buf, Bool_t adopt, ReAllocCharFun_t reallocfunc); 105{; 106 if (bufsiz < 0); 107 Fatal(""TBuffer"",""Request to create a buffer with a negative size, likely due to an integer overflow: 0x%x for a max of 0x%x."", bufsiz, kMaxBufferSize);; 108 fBufSize = bufsiz;; 109 fMode = mode;; 110 fVersion = 0;; 111 fParent = nullptr;; 112 ; 113 SetBit(kIsOwner);; 114 ; 115 if (buf) {; 116 fBuffer = (char *)buf;; 117 if ( (fMode&kWrite)!=0 ) {; 118 fBufSize -= kExtraSpace;; 119 }; 120 if (!adopt) ResetBit(kIsOwner);; 121 } else {; 122 if (fBufSize < kMinimalSize) {; 123 fBufSize = kMinimalSize;; 124 }; 125 fBuffer = new char[(Long64_t)fBufSize+kExtraSpace];; 126 }; 127 fBufCur = fBuffer;; 128 fBufMax = fBuffer + fBufSize;; 129 ; 130 SetReAllocFunc( reallocfunc );; 131 ; 132 if (buf && ( (fMode&kWrite)!=0 ) && fBufSize < 0) {; 133 Expand( kMinimalSize );; 134 ",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
Deployability,release,release,"///////////////////////////////////; 275/// Return the reallocation method currently used.; 276 ; 277ReAllocCharFun_t TBuffer::GetReAllocFunc() const; 278{; 279 return fReAllocFunc;; 280}; 281 ; 282////////////////////////////////////////////////////////////////////////////////; 283/// Set which memory reallocation method to use. If reallocafunc is null,; 284/// reset it to the default value (TStorage::ReAlloc); 285 ; 286void TBuffer::SetReAllocFunc(ReAllocCharFun_t reallocfunc ); 287{; 288 if (reallocfunc) {; 289 fReAllocFunc = reallocfunc;; 290 } else {; 291 if (TestBit(kIsOwner)) {; 292 fReAllocFunc = TStorage::ReAllocChar;; 293 } else {; 294 fReAllocFunc = R__NoReAllocChar;; 295 }; 296 }; 297}; 298 ; 299////////////////////////////////////////////////////////////////////////////////; 300/// Set buffer in read mode.; 301 ; 302void TBuffer::SetReadMode(); 303{; 304 if ( (fMode&kWrite)!=0 ) {; 305 // We had reserved space for the free block count,; 306 // release it,; 307 fBufSize += kExtraSpace;; 308 }; 309 fMode = kRead;; 310}; 311 ; 312////////////////////////////////////////////////////////////////////////////////; 313/// Set buffer in write mode.; 314 ; 315void TBuffer::SetWriteMode(); 316{; 317 if ( (fMode&kWrite)==0 ) {; 318 // We had not yet reserved space for the free block count,; 319 // reserve it now.; 320 fBufSize -= kExtraSpace;; 321 }; 322 fMode = kWrite;; 323}; 324 ; 325////////////////////////////////////////////////////////////////////////////////; 326/// Forward to TROOT::GetClass().; 327 ; 328TClass *TBuffer::GetClass(const std::type_info &typeinfo); 329{; 330 return TClass::GetClass(typeinfo);; 331}; 332 ; 333////////////////////////////////////////////////////////////////////////////////; 334/// Forward to TROOT::GetClass().; 335 ; 336TClass *TBuffer::GetClass(const char *className); 337{; 338 return TClass::GetClass(className);; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342/// Return the ",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
Integrability,rout,routine,"); 74{; 75 if (bufsiz < 0); 76 Fatal(""TBuffer"",""Request to create a buffer with a negative size, likely due to an integer overflow: 0x%x for a max of 0x%x."", bufsiz, kMaxBufferSize);; 77 if (bufsiz < kMinimalSize) bufsiz = kMinimalSize;; 78 fBufSize = bufsiz;; 79 fMode = mode;; 80 fVersion = 0;; 81 fParent = nullptr;; 82 ; 83 SetBit(kIsOwner);; 84 ; 85 fBuffer = new char[fBufSize+kExtraSpace];; 86 ; 87 fBufCur = fBuffer;; 88 fBufMax = fBuffer + fBufSize;; 89 ; 90 SetReAllocFunc( nullptr );; 91}; 92 ; 93////////////////////////////////////////////////////////////////////////////////; 94/// Create an I/O buffer object. Mode should be either TBuffer::kRead or; 95/// TBuffer::kWrite. By default the I/O buffer has a size of; 96/// TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; 97/// to TBuffer via the buf argument. By default this buffer will be adopted; 98/// unless adopt is false.; 99///; 100/// If the new buffer is _not_ adopted and no memory allocation routine; 101/// is provided, a Fatal error will be issued if the Buffer attempts to; 102/// expand.; 103 ; 104TBuffer::TBuffer(EMode mode, Int_t bufsiz, void *buf, Bool_t adopt, ReAllocCharFun_t reallocfunc); 105{; 106 if (bufsiz < 0); 107 Fatal(""TBuffer"",""Request to create a buffer with a negative size, likely due to an integer overflow: 0x%x for a max of 0x%x."", bufsiz, kMaxBufferSize);; 108 fBufSize = bufsiz;; 109 fMode = mode;; 110 fVersion = 0;; 111 fParent = nullptr;; 112 ; 113 SetBit(kIsOwner);; 114 ; 115 if (buf) {; 116 fBuffer = (char *)buf;; 117 if ( (fMode&kWrite)!=0 ) {; 118 fBufSize -= kExtraSpace;; 119 }; 120 if (!adopt) ResetBit(kIsOwner);; 121 } else {; 122 if (fBufSize < kMinimalSize) {; 123 fBufSize = kMinimalSize;; 124 }; 125 fBuffer = new char[(Long64_t)fBufSize+kExtraSpace];; 126 }; 127 fBufCur = fBuffer;; 128 fBufMax = fBuffer + fBufSize;; 129 ; 130 SetReAllocFunc( reallocfunc );; 131 ; 132 if (buf && ( (fMode&kWrite)!=0 ) && fBufSize < 0) {; 133 Expand( kMinimalSize );; 134 ",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
Modifiability,extend,extending,"y GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; TProcessID.h; ReAllocCharFun_tchar *(* ReAllocCharFun_t)(char *, size_t, size_t)Definition TStorage.h:30; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuffer::TBufferTBuffer()Definition TBuffer.h:59; TBuffer::SetWriteModevoid SetWriteMode()Set buffer in write mode.Definition TBuffer.cxx:315; TBuffer::ByteSwapBufferBool_t ByteSwapBuffer(Long64_t n, EDataType type)Byte-swap N primitive-elements in the buffer.Definition TBuffer.cxx:392; TBuffer::fCacheStackCacheList_t fCacheStackRealloc function to be used when extending the buffer.Definition TBuffer.h:56; TBuffer::ReadProcessIDvirtual TProcessID * ReadProcessID(UShort_t pidf)=0Return the current Process-ID.Definition TBuffer.cxx:344; TBuffer::WriteProcessIDvirtual UShort_t WriteProcessID(TProcessID *pid)=0Always return 0 (current processID).Definition TBuffer.cxx:353; TBuffer::fBufSizeInt_t fBufSizeDefinition TBuffer.h:50; TBuffer::SetParentvoid SetParent(TObject *parent)Set parent owning this buffer.Definition TBuffer.cxx:270; TBuffer::GetParentTObject * GetParent() constReturn pointer to parent of this buffer.Definition TBuffer.cxx:262; TBuffer::GetCurrentchar * GetCurrent() constDefinition TBuffer.h:97; TBuffer::Expandvoid Expand(Int_t newsize, Bool_t copy=kTRUE)Expand (or shrink) the I/O buffer to newsize bytes.Definition TBuffer.cxx:223; TBuffer::kIsOwner@ kIsOwnerDefinition TBuffer.h:75; TBuffer::SetBuffervoid SetBuffer(void *buf, UInt_t bufsiz=0, Bool_t adopt=kTRUE, ReAllocCharFun_t reallocfunc=nullptr)",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
Performance,cache,cache,/////////////; 326/// Forward to TROOT::GetClass().; 327 ; 328TClass *TBuffer::GetClass(const std::type_info &typeinfo); 329{; 330 return TClass::GetClass(typeinfo);; 331}; 332 ; 333////////////////////////////////////////////////////////////////////////////////; 334/// Forward to TROOT::GetClass().; 335 ; 336TClass *TBuffer::GetClass(const char *className); 337{; 338 return TClass::GetClass(className);; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342/// Return the current Process-ID.; 343 ; 344TProcessID *TBuffer::ReadProcessID(UShort_t pidf); 345{; 346 if (!pidf) return TProcessID::GetPID(); //may happen when cloning an object; 347 return nullptr;; 348}; 349 ; 350////////////////////////////////////////////////////////////////////////////////; 351/// Always return 0 (current processID).; 352 ; 353UShort_t TBuffer::WriteProcessID(TProcessID *); 354{; 355 return 0;; 356}; 357 ; 358////////////////////////////////////////////////////////////////////////////////; 359/// Push a new data cache area onto the list of area to be used for; 360/// temporarily store 'missing' data members.; 361 ; 362void TBuffer::PushDataCache(TVirtualArray *obj); 363{; 364 fCacheStack.push_back(obj);; 365}; 366 ; 367////////////////////////////////////////////////////////////////////////////////; 368/// Return the 'current' data cache area from the list of area to be used for; 369/// temporarily store 'missing' data members.; 370 ; 371TVirtualArray *TBuffer::PeekDataCache() const; 372{; 373 if (fCacheStack.empty()) return nullptr;; 374 return fCacheStack.back();; 375}; 376 ; 377////////////////////////////////////////////////////////////////////////////////; 378/// Pop and Return the 'current' data cache area from the list of area to be used for; 379/// temporarily store 'missing' data members.; 380 ; 381TVirtualArray *TBuffer::PopDataCache(); 382{; 383 TVirtualArray *val = PeekDataCache();; 384 fCacheStack.pop_back();; 385 return val;; 386,MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
Safety,avoid,avoid,"oading...; Searching...; No Matches. TBuffer.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id: 6da0b5b613bbcfaa3a5cd4074e7b2be2448dfb31 $; 2// Author: Fons Rademakers 04/05/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TBuffer; 13\ingroup Base; 14 ; 15Buffer base class used for serializing objects.; 16*/; 17 ; 18#include ""TBuffer.h""; 19#include ""TClass.h""; 20#include ""TProcessID.h""; 21 ; 22constexpr Int_t kExtraSpace = 8; // extra space at end of buffer (used for free block count); 23constexpr Int_t kMaxBufferSize = 0x7FFFFFFE; // largest possible size.; 24 ; 25 ; 26ClassImp(TBuffer);; 27 ; 28/// Default streamer implementation used by ClassDefInline to avoid; 29/// requirement to include TBuffer.h; 30void ROOT::Internal::DefaultStreamer(TBuffer &R__b, const TClass *cl, void *objpointer); 31{; 32 if (R__b.IsReading()); 33 R__b.ReadClassBuffer(cl, objpointer);; 34 else; 35 R__b.WriteClassBuffer(cl, objpointer);; 36}; 37 ; 38////////////////////////////////////////////////////////////////////////////////; 39/// The user has provided memory than we don't own, thus we can not extent it; 40/// either.; 41 ; 42static char *R__NoReAllocChar(char *, size_t, size_t); 43{; 44 return nullptr;; 45}; 46 ; 47////////////////////////////////////////////////////////////////////////////////; 48/// Create an I/O buffer object. Mode should be either TBuffer::kRead or; 49/// TBuffer::kWrite. By default the I/O buffer has a size of; 50/// TBuffer::kInitialSize (1024) bytes.; 51 ; 52TBuffer::TBuffer(EMode mode); 53{; 54 fBufSize = kInitialSize;; 55 fMode = mode;; 56 fVersion = 0;; 57 fParent = nullptr;; 58 ; 59 SetBit(kIsOwner)",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
Security,access,access," mode.Definition TBuffer.cxx:302; TBuffer::WriteClassBuffervirtual Int_t WriteClassBuffer(const TClass *cl, void *pointer)=0; TBuffer::fVersionInt_t fVersionDefinition TBuffer.h:49; TBuffer::LengthInt_t Length() constDefinition TBuffer.h:100; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TProcessIDA TProcessID identifies a ROOT job in a unique way in time and space.Definition TProcessID.h:74; TProcessID::GetPIDstatic TProcessID * GetPID()static: returns pointer to current TProcessIDDefinition TProcessID.cxx:343; TStorage::ReAllocCharstatic char * ReAllocChar(char *vp, size_t size, size_t oldsize)Reallocate (i.e.Definition TStorage.cxx:228; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; bool; double; int; unsigned int; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::DefaultStreamervoid DefaultStreamer(TBuffer &R__b, const TClass *cl, void *objpointer)Default streamer implementation used by ClassDefInline to avoid requirement to include TBuffer....Definition TBuffer.cxx:30; lTLine lDefinition textangle.C:4. corebasesrcTBuffer.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:05 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TBuffer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html
Modifiability,extend,extending,"terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TBuffer; 13#define ROOT_TBuffer; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TBuffer //; 19// //; 20// Buffer base class used for serializing objects. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TDataType.h""; 25#include ""TObject.h""; 26#include ""TClass.h""; 27#include ""Bytes.h""; 28 ; 29#include <vector>; 30#include <string>; 31 ; 32class TVirtualStreamerInfo;; 33class TStreamerElement;; 34class TString;; 35class TProcessID;; 36class TClonesArray;; 37class TRefTable;; 38class TVirtualArray;; 39namespace TStreamerInfoActions {; 40 class TActionSequence;; 41}; 42 ; 43class TBuffer : public TObject {; 44 ; 45protected:; 46 typedef std::vector<TVirtualArray*> CacheList_t;; 47 ; 48 Bool_t fMode; //Read or write mode; 49 Int_t fVersion; //Buffer format version; 50 Int_t fBufSize; //Size of buffer; 51 char *fBuffer; //Buffer used to store objects; 52 char *fBufCur; //Current position in buffer; 53 char *fBufMax; //End of buffer; 54 TObject *fParent; //Pointer to parent object owning this buffer; 55 ReAllocCharFun_t fReAllocFunc; //! Realloc function to be used when extending the buffer.; 56 CacheList_t fCacheStack; //Stack of pointers to the cache where to temporarily store the value of 'missing' data members; 57 ; 58 // Default ctor; 59 TBuffer() : TObject(), fMode(0), fVersion(0), fBufSize(0), fBuffer(nullptr),; 60 fBufCur(nullptr), fBufMax(nullptr), fParent(nullptr), fReAllocFunc(nullptr), fCacheStack(0, (TVirtualArray*)nullptr) {}; 61 ; 62 // TBuffer objects cannot be copied or assigned; 63 TBuffer(const TBuffer &) = delete;; 64 void operator=(const TBuffer &) = delete;; 65 ; 66 Int_t Read(const char *name) override { return TObject::Read(name); }; 67 Int_t Writ",MatchSource.WIKI,doc/master/TBuffer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html
Performance,cache,cache,; 56 CacheList_t fCacheStack; //Stack of pointers to the cache where to temporarily store the value of 'missing' data members;,MatchSource.WIKI,doc/master/TBuffer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html
Security,access,access,"rray(const ULong_t *l, Int_t n)=0; TBuffer::ReadClassEmulatedvirtual Int_t ReadClassEmulated(const TClass *cl, void *object, const TClass *onfile_class=nullptr)=0; TBuffer::Bufferchar * Buffer() constDefinition TBuffer.h:96; TBuffer::ReadArrayvirtual Int_t ReadArray(Char_t *&c)=0; TBuffer::StreamObjectvirtual void StreamObject(void *obj, const std::type_info &typeinfo, const TClass *onFileClass=nullptr)=0; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TMemberStreamerDefinition TMemberStreamer.h:26; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::Readvirtual Int_t Read(const char *name)Read contents of object with specified name from the current directory.Definition TObject.cxx:654; TProcessIDA TProcessID identifies a ROOT job in a unique way in time and space.Definition TProcessID.h:74; TRefTableA TRefTable maintains the association between a referenced object and the parent object supporting th...Definition TRefTable.h:35; TStreamerElementDefinition TStreamerElement.h:32; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TStringBasic string class.Definition TString.h:139; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; TVirtualStreamerInfoAbstract Interface class describing Streamer information for one class.Definition TVirtualStreamerInfo.h:44; bool; double; int; unsigned int; nconst Int_t nDefinition legend1.C:16; TStreamerInfoActionsDefinition TBuffer.h:39; lTLine lDefinition textangle.C:4. corebaseincTBuffer.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:03 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TBuffer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html
Usability,usab,usable,"TBuffer &buf, ULong64_t l){ buf.WriteULong64(l);return buf; }; 372inline TBuffer &operator<<(TBuffer &buf, Float_t f) { buf.WriteFloat(f); return buf; }; 373inline TBuffer &operator<<(TBuffer &buf, Double_t d) { buf.WriteDouble(d); return buf; }; 374inline TBuffer &operator<<(TBuffer &buf, const Char_t *c) { buf.WriteCharP(c); return buf; }; 375inline TBuffer &operator<<(TBuffer &buf, const TString &s) { buf.WriteTString(s);return buf; }; 376 ; 377#if defined(R__SOLARIS) && defined(R__GNU); 378#include <typeinfo>; 379#endif; 380 ; 381template <class Tmpl> TBuffer &operator>>(TBuffer &buf, Tmpl *&obj); 382{; 383 // Read TObject derived classes from a TBuffer. Need to provide; 384 // custom version for non-TObject derived classes.; 385 ; 386 // This operator has to be a templated and/or automatically; 387 // generated if we want to be able to check the type of the; 388 // incoming object. I.e. a operator>>(TBuffer &buf, TObject *&); 389 // would not be sufficient to pass the information 'which class do we want'; 390 // since the pointer could be zero (so typeid(*obj) is not usable).; 391 ; 392 auto cl = TClass::GetClass<Tmpl>();; 393 obj = (Tmpl *) ( (void*) buf.ReadObjectAny(cl) );; 394 return buf;; 395}; 396 ; 397template <class Tmpl> TBuffer &operator<<(TBuffer &buf, const Tmpl *obj); 398{; 399 auto cl = (obj) ? TClass::GetClass<Tmpl>() : nullptr;; 400 buf.WriteObjectAny(obj, cl);; 401 return buf;; 402}; 403 ; 404template <class T>; 405inline Int_t TBuffer::WriteObject(const T *objptr, Bool_t cacheReuse); 406{; 407 auto cl = (objptr) ? TClass::GetClass<T>() : nullptr;; 408 return WriteObjectAny(objptr, cl, cacheReuse);; 409}; 410 ; 411#endif // ROOT_TBuffer; Bytes.h; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; Bool_tbool Bool_tDefinition RtypesCore.h:63; UShort_tunsign",MatchSource.WIKI,doc/master/TBuffer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TBuffer_8h_source.html
Availability,avail,available," display; 91manager. A ROOT session may have several canvases open at any given time.; 92 ; 93A Canvas may be subdivided into independent graphical areas: the __Pads__.; 94A canvas has a default pad which has the name of the canvas itself.; 95An example of a Canvas layout is sketched in the picture below.; 96 ; 97\image html gpad_canvas.png; 98 ; 99This canvas contains two pads named P1 and P2. Both Canvas, P1 and P2 can be; 100moved, grown, shrunk using the normal rules of the Display manager.; 101 ; 102Once objects have been drawn in a canvas, they can be edited/moved by pointing; 103directly to them. The cursor shape is changed to suggest the type of action that; 104one can do on this object. Clicking with the right mouse button on an object; 105pops-up a contextmenu with a complete list of actions possible on this object.; 106 ; 107A graphical editor may be started from the canvas ""View"" menu under the menu; 108entry ""Toolbar"".; 109 ; 110An interactive HELP is available by clicking on the HELP button at the top right; 111of the canvas. It gives a short explanation about the canvas' menus.; 112 ; 113A canvas may be automatically divided into pads via `TPad::Divide`.; 114 ; 115At creation time, no matter if in interactive or batch mode, the constructor; 116defines the size of the canvas window (including the size of the window; 117manager's decoration). To define precisely the graphics area size of a canvas in; 118the interactive mode, the following four lines of code should be used:; 119~~~ {.cpp}; 120 {; 121 Double_t w = 600;; 122 Double_t h = 600;; 123 auto c = new TCanvas(""c"", ""c"", w, h);; 124 c->SetWindowSize(w + (w - c->GetWw()), h + (h - c->GetWh()));; 125 }; 126~~~; 127and in the batch mode simply do:; 128~~~ {.cpp}; 129 c->SetCanvasSize(w,h);; 130~~~; 131 ; 132If the canvas size exceeds the window size, scroll bars will be added to the canvas; 133This allows to display very large canvases (even bigger than the screen size). The; 134Following example shows",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
Deployability,update,update,"/////////; 1143/// Flush canvas buffers.; 1144 ; 1145void TCanvas::Flush(); 1146{; 1147 if ((fCanvasID == -1) || IsWeb()) return;; 1148 ; 1149 TContext ctxt(this, kTRUE);; 1150 if (!IsBatch()) {; 1151 if (!UseGL() || fGLDevice == -1) {; 1152 gVirtualX->SelectWindow(fCanvasID);; 1153 gPad = ctxt.GetSaved(); //don't do cd() because than also the pixmap is changed; 1154 CopyPixmaps();; 1155 gVirtualX->UpdateWindow(1);; 1156 } else {; 1157 TVirtualPS *tvps = gVirtualPS;; 1158 gVirtualPS = nullptr;; 1159 gGLManager->MakeCurrent(fGLDevice);; 1160 fPainter->InitPainter();; 1161 Paint();; 1162 if (ctxt.GetSaved() && ctxt.GetSaved()->GetCanvas() == this) {; 1163 ctxt.GetSaved()->cd();; 1164 ctxt.GetSaved()->HighLight(ctxt.GetSaved()->GetHighLightColor());; 1165 //cd();; 1166 }; 1167 fPainter->LockPainter();; 1168 gGLManager->Flush(fGLDevice);; 1169 gVirtualPS = tvps;; 1170 }; 1171 }; 1172}; 1173 ; 1174////////////////////////////////////////////////////////////////////////////////; 1175/// Force canvas update; 1176 ; 1177void TCanvas::ForceUpdate(); 1178{; 1179 if (fCanvasImp) fCanvasImp->ForceUpdate();; 1180}; 1181 ; 1182////////////////////////////////////////////////////////////////////////////////; 1183/// Force a copy of current style for all objects in canvas.; 1184 ; 1185void TCanvas::UseCurrentStyle(); 1186{; 1187 if (!gROOT->IsLineProcessing() && !gVirtualX->IsCmdThread()) {; 1188 gInterpreter->Execute(this, IsA(), ""UseCurrentStyle"", """");; 1189 return;; 1190 }; 1191 ; 1192 R__LOCKGUARD(gROOTMutex);; 1193 ; 1194 TPad::UseCurrentStyle();; 1195 ; 1196 if (gStyle->IsReading()) {; 1197 SetFillColor(gStyle->GetCanvasColor());; 1198 fBorderSize = gStyle->GetCanvasBorderSize();; 1199 fBorderMode = gStyle->GetCanvasBorderMode();; 1200 } else {; 1201 gStyle->SetCanvasColor(GetFillColor());; 1202 gStyle->SetCanvasBorderSize(fBorderSize);; 1203 gStyle->SetCanvasBorderMode(fBorderMode);; 1204 }; 1205}; 1206 ; 1207//////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
Energy Efficiency,allocate,allocated,"p->SetWindowSize(ww, wh);; 2182}; 2183 ; 2184////////////////////////////////////////////////////////////////////////////////; 2185/// Set the canvas scale in centimeters.; 2186///; 2187/// This information is used by PostScript to set the page size.; 2188///; 2189/// \param[in] xsize size of the canvas in centimeters along X; 2190/// \param[in] ysize size of the canvas in centimeters along Y; 2191///; 2192/// if xsize and ysize are not equal to 0, then the scale factors will; 2193/// be computed to keep the ratio ysize/xsize independently of the canvas; 2194/// size (parts of the physical canvas will be unused).; 2195///; 2196/// if xsize = 0 and ysize is not zero, then xsize will be computed; 2197/// to fit to the current canvas scale. If the canvas is resized,; 2198/// a new value for xsize will be recomputed. In this case the aspect; 2199/// ratio is not preserved.; 2200///; 2201/// if both xsize = 0 and ysize = 0, then the scaling is automatic.; 2202/// the largest dimension will be allocated a size of 20 centimeters.; 2203 ; 2204void TCanvas::Size(Float_t xsize, Float_t ysize); 2205{; 2206 fXsizeUser = xsize;; 2207 fYsizeUser = ysize;; 2208 ; 2209 Resize();; 2210}; 2211 ; 2212////////////////////////////////////////////////////////////////////////////////; 2213/// Show canvas; 2214 ; 2215void TCanvas::Show(); 2216{; 2217 if (fCanvasImp); 2218 fCanvasImp->Show();; 2219}; 2220 ; 2221////////////////////////////////////////////////////////////////////////////////; 2222/// Stream a class object.; 2223 ; 2224void TCanvas::Streamer(TBuffer &b); 2225{; 2226 UInt_t R__s, R__c;; 2227 if (b.IsReading()) {; 2228 Version_t v = b.ReadVersion(&R__s, &R__c);; 2229 gPad = this;; 2230 fCanvas = this;; 2231 if (v>7) b.ClassBegin(TCanvas::IsA());; 2232 if (v>7) b.ClassMember(""TPad"");; 2233 TPad::Streamer(b);; 2234 gPad = this;; 2235 //restore the colors; 2236 auto colors = dynamic_cast<TObjArray *>(fPrimitives->FindObject(""ListOfColors""));; 2237 if (colors) {; 2238 auto root_colo",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
Integrability,depend,depending,"return;; 1030 }; 1031 }; 1032 // default; 1033 fCanvasImp->SetStatusText(selected->GetObjectInfo(px,py),3);; 1034}; 1035 ; 1036////////////////////////////////////////////////////////////////////////////////; 1037/// Get editor bar.; 1038 ; 1039void TCanvas::EditorBar(); 1040{; 1041 TVirtualPadEditor::GetPadEditor();; 1042}; 1043 ; 1044////////////////////////////////////////////////////////////////////////////////; 1045/// Embedded a canvas into a TRootEmbeddedCanvas. This method is only called; 1046/// via TRootEmbeddedCanvas::AdoptCanvas.; 1047 ; 1048void TCanvas::EmbedInto(Int_t winid, Int_t ww, Int_t wh); 1049{; 1050 // If fCanvasImp already exists, no need to go further.; 1051 if(fCanvasImp) return;; 1052 ; 1053 fCanvasID = winid;; 1054 fWindowTopX = 0;; 1055 fWindowTopY = 0;; 1056 fWindowWidth = ww;; 1057 fWindowHeight = wh;; 1058 fCw = ww;; 1059 fCh = wh;; 1060 fBatch = kFALSE;; 1061 fUpdating = kFALSE;; 1062 ; 1063 fCanvasImp = gBatchGuiFactory->CreateCanvasImp(this, GetName(), fCw, fCh);; 1064 if (!fCanvasImp) return;; 1065 Build();; 1066 Resize();; 1067}; 1068 ; 1069////////////////////////////////////////////////////////////////////////////////; 1070/// Generate kMouseEnter and kMouseLeave events depending on the previously; 1071/// selected object and the currently selected object. Does nothing if the; 1072/// selected object does not change.; 1073 ; 1074void TCanvas::EnterLeave(TPad *prevSelPad, TObject *prevSelObj); 1075{; 1076 if (prevSelObj == fSelected) return;; 1077 ; 1078 TContext ctxt(kFALSE);; 1079 Int_t sevent = fEvent;; 1080 ; 1081 if (prevSelObj) {; 1082 gPad = prevSelPad;; 1083 prevSelObj->ExecuteEvent(kMouseLeave, fEventX, fEventY);; 1084 fEvent = kMouseLeave;; 1085 RunAutoExec();; 1086 ProcessedEvent(kMouseLeave, fEventX, fEventY, prevSelObj); // emit signal; 1087 }; 1088 ; 1089 gPad = fSelectedPad;; 1090 ; 1091 if (fSelected) {; 1092 fSelected->ExecuteEvent(kMouseEnter, fEventX, fEventY);; 1093 fEvent = kMouseEnter;; 1094 RunAutoExec();;",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
Modifiability,variab,variable,""" ""<<GetName()<<""->ToggleToolTips();""<<std::endl;; 1798 }; 1799 if (GetShowToolBar()) {; 1800 out<<"" ""<<GetName()<<""->ToggleToolBar();""<<std::endl;; 1801 }; 1802 if (GetHighLightColor() != 5) {; 1803 if (TColor::SaveColor(out, GetHighLightColor())); 1804 out<<"" ""<<GetName()<<""->SetHighLightColor(ci);"" << std::endl;; 1805 else; 1806 out<<"" ""<<GetName()<<""->SetHighLightColor(""<<GetHighLightColor()<<"");""<<std::endl;; 1807 }; 1808 ; 1809 // Now recursively scan all pads of this canvas; 1810 cd();; 1811 TPad::SavePrimitive(out,option);; 1812}; 1813 ; 1814////////////////////////////////////////////////////////////////////////////////; 1815/// Save primitives in this canvas as a C++ macro file.; 1816/// This function loops on all the canvas primitives and for each primitive; 1817/// calls the object SavePrimitive function.; 1818/// When outputting floating point numbers, the default precision is 7 digits.; 1819/// The precision can be changed (via system.rootrc) by changing the value; 1820/// of the environment variable ""Canvas.SavePrecision""; 1821 ; 1822void TCanvas::SaveSource(const char *filename, Option_t * /*option*/); 1823{; 1824 // Reset the ClassSaved status of all classes; 1825 gROOT->ResetClassSaved();; 1826 ; 1827 char quote = '""';; 1828 TString cname0 = GetName();; 1829 Bool_t invalid = kFALSE;; 1830 ; 1831 TString cname = cname0.Strip(TString::kBoth);; 1832 if (cname.IsNull()) {; 1833 invalid = kTRUE;; 1834 cname = ""c1"";; 1835 }; 1836 ; 1837 // if filename is given, open this file, otherwise create a file; 1838 // with a name equal to the canvasname.C; 1839 TString fname;; 1840 if (filename && *filename) {; 1841 fname = filename;; 1842 } else {; 1843 fname = cname + "".C"";; 1844 }; 1845 ; 1846 std::ofstream out;; 1847 out.open(fname.Data(), std::ios::out);; 1848 if (!out.good()) {; 1849 Error(""SaveSource"", ""Cannot open file: %s"", fname.Data());; 1850 return;; 1851 }; 1852 ; 1853 //set precision; 1854 Int_t precision = gEnv->GetValue(""Canvas.SavePrecision"",7);; ",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
Performance,response time,response time,"anvas Name="" <<GetName()<<"" Title=""<<GetTitle()<<"" Option=""<<option<<std::endl;; 1508 TROOT::IncreaseDirLevel();; 1509 TPad::ls(option);; 1510 TROOT::DecreaseDirLevel();; 1511}; 1512 ; 1513////////////////////////////////////////////////////////////////////////////////; 1514/// Static function to build a default canvas.; 1515 ; 1516TCanvas *TCanvas::MakeDefCanvas(); 1517{; 1518 auto cdef = GetNewCanvasName();; 1519 ; 1520 auto c = new TCanvas(cdef.Data(), cdef.Data(), 1);; 1521 ; 1522 ::Info(""TCanvas::MakeDefCanvas"","" created default TCanvas with name %s"", cdef.Data());; 1523 return c;; 1524}; 1525 ; 1526////////////////////////////////////////////////////////////////////////////////; 1527/// Set option to move objects/pads in a canvas.; 1528///; 1529/// - set = 1 (default) graphics objects are moved in opaque mode; 1530/// - set = 0 only the outline of objects is drawn when moving them; 1531///; 1532/// The option opaque produces the best effect. It requires however a; 1533/// a reasonably fast workstation or response time.; 1534 ; 1535void TCanvas::MoveOpaque(Int_t set); 1536{; 1537 SetBit(kMoveOpaque,set);; 1538}; 1539 ; 1540////////////////////////////////////////////////////////////////////////////////; 1541/// Paint canvas.; 1542 ; 1543void TCanvas::Paint(Option_t *option); 1544{; 1545 if (fCanvas); 1546 TPad::Paint(option);; 1547}; 1548 ; 1549////////////////////////////////////////////////////////////////////////////////; 1550/// Prepare for pick, call TPad::Pick() and when selected object; 1551/// is different from previous then emit Picked() signal.; 1552 ; 1553TPad *TCanvas::Pick(Int_t px, Int_t py, TObject *prevSelObj); 1554{; 1555 TObjLink *pickobj = nullptr;; 1556 ; 1557 fSelected = nullptr;; 1558 fSelectedOpt = """";; 1559 fSelectedPad = nullptr;; 1560 ; 1561 TPad *pad = Pick(px, py, pickobj);; 1562 if (!pad) return nullptr;; 1563 ; 1564 if (!pickobj) {; 1565 fSelected = pad;; 1566 fSelectedOpt = """";; 1567 } else {; 1568 if (!fSelected) { // can be set v",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
Safety,avoid,avoid,"vas, i.e. a canvas that is in a TGCanvas widget; 218/// which is placed in a TGFrame. This ctor is only called via the; 219/// TRootEmbeddedCanvas class.; 220///; 221/// If ""name"" starts with ""gl"" the canvas is ready to receive GL output.; 222 ; 223TCanvas::TCanvas(const char *name, Int_t ww, Int_t wh, Int_t winid) : TPad(), fDoubleBuffer(0); 224{; 225 fCanvasImp = nullptr;; 226 fPainter = nullptr;; 227 Init();; 228 ; 229 fCanvasID = winid;; 230 fWindowTopX = 0;; 231 fWindowTopY = 0;; 232 fWindowWidth = ww;; 233 fWindowHeight = wh;; 234 fCw = ww + 4;; 235 fCh = wh +28;; 236 fBatch = kFALSE;; 237 fUpdating = kFALSE;; 238 ; 239 //This is a very special ctor. A window exists already!; 240 //Can create painter now.; 241 fUseGL = gStyle->GetCanvasPreferGL();; 242 ; 243 if (fUseGL) {; 244 fGLDevice = gGLManager->CreateGLContext(winid);; 245 if (fGLDevice == -1); 246 fUseGL = kFALSE;; 247 }; 248 ; 249 fCanvasImp = gBatchGuiFactory->CreateCanvasImp(this, name, fCw, fCh);; 250 if (!fCanvasImp) return;; 251 ; 252 CreatePainter();; 253 fName = GetNewCanvasName(name); // avoid Modified() signal from SetName; 254 Build();; 255}; 256 ; 257////////////////////////////////////////////////////////////////////////////////; 258/// Create a new canvas with a predefined size form.; 259/// If form < 0 the menubar is not shown.; 260///; 261/// - form = 1 700x500 at 10,10 (set by TStyle::SetCanvasDefH,W,X,Y); 262/// - form = 2 500x500 at 20,20; 263/// - form = 3 500x500 at 30,30; 264/// - form = 4 500x500 at 40,40; 265/// - form = 5 500x500 at 50,50; 266///; 267/// If ""name"" starts with ""gl"" the canvas is ready to receive GL output.; 268 ; 269TCanvas::TCanvas(const char *name, const char *title, Int_t form) : TPad(), fDoubleBuffer(0); 270{; 271 fPainter = nullptr;; 272 fUseGL = gStyle->GetCanvasPreferGL();; 273 ; 274 Constructor(name, title, form);; 275}; 276 ; 277////////////////////////////////////////////////////////////////////////////////; 278/// Create a new canvas with a predefined ",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
Testability,assert,assert,"nvas = this;; 2231 if (v>7) b.ClassBegin(TCanvas::IsA());; 2232 if (v>7) b.ClassMember(""TPad"");; 2233 TPad::Streamer(b);; 2234 gPad = this;; 2235 //restore the colors; 2236 auto colors = dynamic_cast<TObjArray *>(fPrimitives->FindObject(""ListOfColors""));; 2237 if (colors) {; 2238 auto root_colors = dynamic_cast<TObjArray *>(gROOT->GetListOfColors());; 2239 ; 2240 TIter next(colors);; 2241 while (auto colold = static_cast<TColor *>(next())) {; 2242 Int_t cn = colold->GetNumber();; 2243 TColor *colcur = gROOT->GetColor(cn);; 2244 if (colcur && (colcur->IsA() == TColor::Class()) && (colold->IsA() == TColor::Class())) {; 2245 colcur->SetName(colold->GetName());; 2246 colcur->SetRGB(colold->GetRed(), colold->GetGreen(), colold->GetBlue());; 2247 colcur->SetAlpha(colold->GetAlpha());; 2248 } else {; 2249 if (colcur) {; 2250 if (root_colors) root_colors->Remove(colcur);; 2251 delete colcur;; 2252 }; 2253 colors->Remove(colold);; 2254 if (root_colors) {; 2255 if (colcur) {; 2256 root_colors->AddAtAndExpand(colold, cn);; 2257 }; 2258 else {; 2259 // Copy to current session; 2260 // do not use copy constructor which does not update highest color index; 2261 [[maybe_unused]] TColor* const colnew = new TColor(cn, colold->GetRed(), colold->GetGreen(), colold->GetBlue(), colold->GetName(), colold->GetAlpha());; 2262 delete colold;; 2263 // No need to delete colnew, as the constructor adds it to global list of colors; 2264 assert(root_colors->At(cn) == colnew);; 2265 }; 2266 }; 2267 }; 2268 }; 2269 //restore the palette if needed; 2270 auto palette = dynamic_cast<TObjArray *>(fPrimitives->FindObject(""CurrentColorPalette""));; 2271 if (palette) {; 2272 TIter nextcol(palette);; 2273 Int_t number = palette->GetEntries();; 2274 TArrayI palcolors(number);; 2275 Int_t i = 0;; 2276 while (auto col = static_cast<TColor *>(nextcol())); 2277 palcolors[i++] = col->GetNumber();; 2278 gStyle->SetPalette(number, palcolors.GetArray());; 2279 fPrimitives->Remove(palette);; 2280 delete palette;; 228",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
Usability,simpl,simply,"ed to suggest the type of action that; 104one can do on this object. Clicking with the right mouse button on an object; 105pops-up a contextmenu with a complete list of actions possible on this object.; 106 ; 107A graphical editor may be started from the canvas ""View"" menu under the menu; 108entry ""Toolbar"".; 109 ; 110An interactive HELP is available by clicking on the HELP button at the top right; 111of the canvas. It gives a short explanation about the canvas' menus.; 112 ; 113A canvas may be automatically divided into pads via `TPad::Divide`.; 114 ; 115At creation time, no matter if in interactive or batch mode, the constructor; 116defines the size of the canvas window (including the size of the window; 117manager's decoration). To define precisely the graphics area size of a canvas in; 118the interactive mode, the following four lines of code should be used:; 119~~~ {.cpp}; 120 {; 121 Double_t w = 600;; 122 Double_t h = 600;; 123 auto c = new TCanvas(""c"", ""c"", w, h);; 124 c->SetWindowSize(w + (w - c->GetWw()), h + (h - c->GetWh()));; 125 }; 126~~~; 127and in the batch mode simply do:; 128~~~ {.cpp}; 129 c->SetCanvasSize(w,h);; 130~~~; 131 ; 132If the canvas size exceeds the window size, scroll bars will be added to the canvas; 133This allows to display very large canvases (even bigger than the screen size). The; 134Following example shows how to proceed.; 135~~~ {.cpp}; 136 {; 137 auto c = new TCanvas(""c"",""c"");; 138 c->SetCanvasSize(1500, 1500);; 139 c->SetWindowSize(500, 500);; 140 }; 141~~~; 142*/; 143 ; 144////////////////////////////////////////////////////////////////////////////////; 145/// Canvas default constructor.; 146 ; 147TCanvas::TCanvas(Bool_t build) : TPad(), fDoubleBuffer(0); 148{; 149 fPainter = nullptr;; 150 fWindowTopX = 0;; 151 fWindowTopY = 0;; 152 fWindowWidth = 0;; 153 fWindowHeight = 0;; 154 fCw = 0;; 155 fCh = 0;; 156 fXsizeUser = 0;; 157 fYsizeUser = 0;; 158 fXsizeReal = kDefaultCanvasSize;; 159 fYsizeReal = kDefaultCanvasSize;; 160 fHi",MatchSource.WIKI,doc/master/TCanvas_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html
Integrability,depend,dependency,". ROOT: graf2d/gpad/inc/TCanvas.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TCanvas.h File Reference. #include ""TPad.h""; #include ""TAttCanvas.h"". Include dependency graph for TCanvas.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TCanvas;  The Canvas class. More...;  . graf2dgpadincTCanvas.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:16 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TCanvas_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8h.html
Deployability,update,update,"selected objectDefinition TCanvas.h:55; TCanvas::fUpdatingBool_t fUpdating! True when Updating the canvasDefinition TCanvas.h:60; TCanvas::SaveSourcevoid SaveSource(const char *filename="""", Option_t *option="""")Save primitives in this canvas as a C++ macro file.Definition TCanvas.cxx:1822; TCanvas::SetCanvasImpvoid SetCanvasImp(TCanvasImp *i)Definition TCanvas.h:205; TCanvas::fHighLightColorColor_t fHighLightColorHighlight color of active pad.Definition TCanvas.h:37; TCanvas::GetXsizeUserSize_t GetXsizeUser() constDefinition TCanvas.h:153; TCanvas::Sizevirtual void Size(Float_t xsizeuser=0, Float_t ysizeuser=0)Set the canvas scale in centimeters.Definition TCanvas.cxx:2201; TCanvas::ProcessedEventvirtual void ProcessedEvent(Int_t event, Int_t x, Int_t y, TObject *selected)Emit ProcessedEvent() signal.Definition TCanvas.cxx:1653; TCanvas::HandleInputvirtual void HandleInput(EEventType button, Int_t x, Int_t y)Handle Input Events.Definition TCanvas.cxx:1234; TCanvas::UpdateAsyncvoid UpdateAsync() overrideAsynchronous pad update.Definition TCanvas.cxx:2545; TCanvas::GetSelectedTObject * GetSelected() const overrideDefinition TCanvas.h:141; TCanvas::GetXsizeRealSize_t GetXsizeReal() constDefinition TCanvas.h:155; TCanvas::GetEventXInt_t GetEventX() const overrideDefinition TCanvas.h:136; TCanvas::IsUpdatedBool_t IsUpdated() constDefinition TCanvas.h:173; TCanvas::fXsizeUserSize_t fXsizeUserUser specified size of canvas along X in CM.Definition TCanvas.h:33; TCanvas::fEventYInt_t fEventY! Last Y mouse position in canvasDefinition TCanvas.h:47; TCanvas::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet current canvas & pad.Definition TCanvas.cxx:719; TCanvas::fWindowHeightUInt_t fWindowHeightHeight of window (including menubar, borders, etc.)Definition TCanvas.h:42; TCanvas::GetWindowTopYInt_t GetWindowTopY()Returns current top y position of window on screen.Definition TCanvas.cxx:1221; TCanvas::SetPadSavevoid SetPadSave(TPad *pad)Definition TCanvas.h:216; TCanvas::GetSh",MatchSource.WIKI,doc/master/TCanvas_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8h_source.html
Integrability,depend,depending,"(UInt_t ww, UInt_t wh)Set canvas window size.Definition TCanvas.cxx:2173; TCanvas::IsDrawnBool_t IsDrawn() constDefinition TCanvas.h:172; TCanvas::SetFolderstatic void SetFolder(Bool_t isfolder=kTRUE)If isfolder=kTRUE, the canvas can be browsed like a folder by default a canvas is not browsable.Definition TCanvas.cxx:2038; TCanvas::Browsevoid Browse(TBrowser *b) overrideBrowse.Definition TCanvas.cxx:685; TCanvas::GetWindowHeightUInt_t GetWindowHeight() constDefinition TCanvas.h:162; TCanvas::GetClickSelectedTObject * GetClickSelected() constDefinition TCanvas.h:142; TCanvas::ResetUpdatedvoid ResetUpdated()Definition TCanvas.h:193; TCanvas::EditorBarvirtual void EditorBar()Get editor bar.Definition TCanvas.cxx:1039; TCanvas::MakeDefCanvasstatic TCanvas * MakeDefCanvas()Static function to build a default canvas.Definition TCanvas.cxx:1516; TCanvas::ClearPadSavevoid ClearPadSave()Definition TCanvas.h:140; TCanvas::EnterLeavevoid EnterLeave(TPad *prevSelPad, TObject *prevSelObj)Generate kMouseEnter and kMouseLeave events depending on the previously selected object and the curre...Definition TCanvas.cxx:1074; TCanvas::GetClickSelectedPadTVirtualPad * GetClickSelectedPad() constDefinition TCanvas.h:147; TCanvas::fYsizeRealSize_t fYsizeRealCurrent size of canvas along Y in CM.Definition TCanvas.h:36; TCanvas::Constructorvoid Constructor()Canvas default constructor.Definition TCanvas.cxx:191; TCanvas::SetClickSelectedPadvoid SetClickSelectedPad(TPad *pad)Definition TCanvas.h:211; TCanvas::ToggleAutoExecvirtual void ToggleAutoExec()Toggle pad auto execution of list of TExecs.Definition TCanvas.cxx:2422; TCanvas::TCanvasTCanvas(const TCanvas &canvas)=delete; TCanvas::fWindowTopXInt_t fWindowTopXTop X position of window (in pixels)Definition TCanvas.h:39; TCanvas::SetSelectedPadvoid SetSelectedPad(TPad *pad)Definition TCanvas.h:210; TCanvas::SetHighLightColorvoid SetHighLightColor(Color_t col)Definition TCanvas.h:207; TCanvas::ToggleToolTipsvirtual void ToggleToolTips()Toggle ",MatchSource.WIKI,doc/master/TCanvas_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8h_source.html
Modifiability,config,configurable,"ggle batch mode.Definition TCanvas.cxx:1957; TCanvas::Deletevoid Delete(Option_t *="""") overrideDelete this object.Definition TCanvas.h:120; TCanvas::UseGLBool_t UseGL() constDefinition TCanvas.h:228; TCanvas::ResizeOpaquevoid ResizeOpaque(Int_t set=1)Set option to resize objects/pads in a canvas.Definition TCanvas.cxx:1759; TCanvas::ToggleToolBarvirtual void ToggleToolBar()Toggle toolbar.Definition TCanvas.cxx:2442; TCanvas::SetRetainedvoid SetRetained(Bool_t retained=kTRUE)Definition TCanvas.h:218; TCanvas::OpaqueResizingBool_t OpaqueResizing() const overrideDefinition TCanvas.h:181; TCanvas::DrawClonePadvirtual TObject * DrawClonePad()Draw a clone of this canvas into the current pad In an interactive session, select the destination/cu...Definition TCanvas.cxx:924; TCanvas::ResetDrawnvoid ResetDrawn()Definition TCanvas.h:192; TContextMenuThis class provides an interface to context sensitive popup menus.Definition TContextMenu.h:44; TControlBarA Control Bar is a fully user configurable tool which provides fast access to frequently used operati...Definition TControlBar.h:26; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TObjLinkWrapper around a TObject so it can be stored in a TList.Definition TList.h:123; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::MayNotUsevoid MayNotUse(const char *method) constUse this method to signal that a method (defined in a base class) may not be called in a derived clas...Definition TObject.cxx:1046; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPad::Pickvirtual TPad * Pick(Int_t px, Int_t py, TObjLink *&pickobj)Search for an object at pixel position px,py.Definition TPad.cxx:4657; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TThread<div class=""legacybo",MatchSource.WIKI,doc/master/TCanvas_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8h_source.html
Security,access,access,"ggle batch mode.Definition TCanvas.cxx:1957; TCanvas::Deletevoid Delete(Option_t *="""") overrideDelete this object.Definition TCanvas.h:120; TCanvas::UseGLBool_t UseGL() constDefinition TCanvas.h:228; TCanvas::ResizeOpaquevoid ResizeOpaque(Int_t set=1)Set option to resize objects/pads in a canvas.Definition TCanvas.cxx:1759; TCanvas::ToggleToolBarvirtual void ToggleToolBar()Toggle toolbar.Definition TCanvas.cxx:2442; TCanvas::SetRetainedvoid SetRetained(Bool_t retained=kTRUE)Definition TCanvas.h:218; TCanvas::OpaqueResizingBool_t OpaqueResizing() const overrideDefinition TCanvas.h:181; TCanvas::DrawClonePadvirtual TObject * DrawClonePad()Draw a clone of this canvas into the current pad In an interactive session, select the destination/cu...Definition TCanvas.cxx:924; TCanvas::ResetDrawnvoid ResetDrawn()Definition TCanvas.h:192; TContextMenuThis class provides an interface to context sensitive popup menus.Definition TContextMenu.h:44; TControlBarA Control Bar is a fully user configurable tool which provides fast access to frequently used operati...Definition TControlBar.h:26; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TObjLinkWrapper around a TObject so it can be stored in a TList.Definition TList.h:123; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::MayNotUsevoid MayNotUse(const char *method) constUse this method to signal that a method (defined in a base class) may not be called in a derived clas...Definition TObject.cxx:1046; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPad::Pickvirtual TPad * Pick(Int_t px, Int_t py, TObjLink *&pickobj)Search for an object at pixel position px,py.Definition TPad.cxx:4657; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TThread<div class=""legacybo",MatchSource.WIKI,doc/master/TCanvas_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8h_source.html
Testability,assert,assert,"Force a copy of current style for all objects in canvas.Definition TCanvas.cxx:1185; TCanvas::Iconifyvoid Iconify()Iconify canvas.Definition TCanvas.cxx:1479; TCanvas::GetWindowTopXInt_t GetWindowTopX()Returns current top x position of window on screen.Definition TCanvas.cxx:1210; TCanvas::ToggleEventStatusvirtual void ToggleEventStatus()Toggle event statusbar.Definition TCanvas.cxx:2431; TCanvas::Destructorvoid Destructor()Actual canvas destructor.Definition TCanvas.cxx:695; TCanvas::GetCanvasParvirtual void GetCanvasPar(Int_t &wtopx, Int_t &wtopy, UInt_t &ww, UInt_t &wh)Definition TCanvas.h:165; TCanvas::GetCanvasImpTCanvasImp * GetCanvasImp() const overrideDefinition TCanvas.h:158; TCanvas::IsRetainedBool_t IsRetained() const overrideDefinition TCanvas.h:176; TCanvas::fUpdatedBool_t fUpdated! Set to True when Update method was calledDefinition TCanvas.h:64; TCanvas::SetSupportGLvoid SetSupportGL(Bool_t support)Definition TCanvas.h:229; TCanvas::DeleteCanvasPaintervoid DeleteCanvasPainter()assert on IsBatch() == false?Definition TCanvas.cxx:2626; TCanvas::fPadSaveTPad * fPadSave! Pointer to saved pad in HandleInputDefinition TCanvas.h:56; TCanvas::SupportAlphastatic Bool_t SupportAlpha()Static function returning ""true"" if transparency is supported.Definition TCanvas.cxx:2476; TCanvas::fBatchBool_t fBatch! True when in batchmodeDefinition TCanvas.h:59; TCanvas::fUseGLBool_t fUseGL! True when rendering is with GLDefinition TCanvas.h:62; TCanvas::GetEventYInt_t GetEventY() const overrideDefinition TCanvas.h:137; TCanvas::fEventXInt_t fEventX! Last X mouse position in canvasDefinition TCanvas.h:46; TCanvas::IsBatchBool_t IsBatch() const overrideDefinition TCanvas.h:171; TCanvas::DrawCloneTObject * DrawClone(Option_t *option="""") const overrideDraw a clone of this canvas A new canvas is created that is a clone of this canvas.Definition TCanvas.cxx:907; TCanvas::fXsizeRealSize_t fXsizeRealCurrent size of canvas along X in CM.Definition TCanvas.h:35; TCanvas::HasMenuBarBoo",MatchSource.WIKI,doc/master/TCanvas_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8h_source.html
Usability,simpl,simplification,"ed.Definition TCanvas.cxx:2476; TCanvas::fBatchBool_t fBatch! True when in batchmodeDefinition TCanvas.h:59; TCanvas::fUseGLBool_t fUseGL! True when rendering is with GLDefinition TCanvas.h:62; TCanvas::GetEventYInt_t GetEventY() const overrideDefinition TCanvas.h:137; TCanvas::fEventXInt_t fEventX! Last X mouse position in canvasDefinition TCanvas.h:46; TCanvas::IsBatchBool_t IsBatch() const overrideDefinition TCanvas.h:171; TCanvas::DrawCloneTObject * DrawClone(Option_t *option="""") const overrideDraw a clone of this canvas A new canvas is created that is a clone of this canvas.Definition TCanvas.cxx:907; TCanvas::fXsizeRealSize_t fXsizeRealCurrent size of canvas along X in CM.Definition TCanvas.h:35; TCanvas::HasMenuBarBool_t HasMenuBar() constDefinition TCanvas.h:168; TCanvas::GetCanvasPainterTVirtualPadPainter * GetCanvasPainter()Access and (probably) creation of pad painter.Definition TCanvas.cxx:2616; TCanvas::HighlightConnectvirtual void HighlightConnect(const char *slot)This is ""simplification"" for function TCanvas::Connect with Highlighted signal for specific slot.Definition TCanvas.cxx:1631; TCanvas::PickTPad * Pick(Int_t px, Int_t py, TObjLink *&pickobj) overrideSearch for an object at pixel position px,py.Definition TCanvas.h:183; TCanvas::Closevoid Close(Option_t *option="""") overrideClose canvas.Definition TCanvas.cxx:788; TCanvas::SetFixedAspectRatiovoid SetFixedAspectRatio(Bool_t fixed=kTRUE) overrideFix canvas aspect ratio to current value if fixed is true.Definition TCanvas.cxx:2016; TCanvas::Resizevirtual void Resize(Option_t *option="""")Recompute canvas parameters following a X11 Resize.Definition TCanvas.cxx:1668; TCanvas::GetHighLightColorColor_t GetHighLightColor() const overrideDefinition TCanvas.h:138; TCanvas::GetShowToolBarBool_t GetShowToolBar() constDefinition TCanvas.h:149; TCanvas::DrawEventStatusvoid DrawEventStatus(Int_t event, Int_t x, Int_t y, TObject *selected)Report name and title of primitive below the cursor.Definition TCanvas.cxx",MatchSource.WIKI,doc/master/TCanvas_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCanvas_8h_source.html
Deployability,update,updated,; 46 char *fPackets; ///<! Packet descriptor string; 47 TBranch **fBranchPtr; //,MatchSource.WIKI,doc/master/TChainElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TChainElement_8h_source.html
Performance,load,loading,; 46 char *fPackets; ///<! Packet descriptor string; 47 TBranch **fBranchPtr; //,MatchSource.WIKI,doc/master/TChainElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TChainElement_8h_source.html
Availability,repair,repairable,"ed, its friend; 675/// elements are also deleted.; 676///; 677/// The number of entries in the friend must be equal or greater to the number; 678/// of entries of the original chain. If the friend has fewer entries a warning; 679/// is given and the resulting histogram will have missing entries.; 680/// For additional information see TTree::AddFriend.; 681 ; 682TFriendElement* TChain::AddFriend(const char* chain, const char* dummy /* = """" */); 683{; 684 if (!fFriends) {; 685 fFriends = new TList();; 686 }; 687 TFriendElement* fe = new TFriendElement(this, chain, dummy);; 688 ; 689 R__ASSERT(fe); // There used to be a ""if (fe)"" test ... Keep this assert until we are sure that fe is never null; 690 ; 691 fFriends->Add(fe);; 692 ; 693 if (fProofChain); 694 // This updates the proxy chain when we will really use PROOF; 695 ResetBit(kProofUptodate);; 696 ; 697 // We need to invalidate the loading of the current tree because its list; 698 // of real friends is now obsolete. It is repairable only from LoadTree.; 699 InvalidateCurrentTree();; 700 ; 701 TTree* tree = fe->GetTree();; 702 if (!tree) {; 703 Warning(""AddFriend"", ""Unknown TChain %s"", chain);; 704 }; 705 return fe;; 706}; 707 ; 708////////////////////////////////////////////////////////////////////////////////; 709/// Add the whole chain or tree as a friend of this chain.; 710 ; 711TFriendElement* TChain::AddFriend(const char* chain, TFile* dummy); 712{; 713 if (!fFriends) fFriends = new TList();; 714 TFriendElement *fe = new TFriendElement(this,chain,dummy);; 715 ; 716 R__ASSERT(fe); // There used to be a ""if (fe)"" test ... Keep this assert until we are sure that fe is never null; 717 ; 718 fFriends->Add(fe);; 719 ; 720 if (fProofChain); 721 // This updates the proxy chain when we will really use PROOF; 722 ResetBit(kProofUptodate);; 723 ; 724 // We need to invalidate the loading of the current tree because its list; 725 // of real friend is now obsolete. It is repairable only from LoadTree; 726 InvalidateCurrentT",MatchSource.WIKI,doc/master/TChain_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html
Deployability,update,updates,"/////////////////////////////////////////////////////////////////////////; 216/// Add all files referenced by the passed chain to this chain.; 217/// The function returns the total number of files connected.; 218 ; 219Int_t TChain::Add(TChain* chain); 220{; 221 if (!chain) return 0;; 222 ; 223 // Check for enough space in fTreeOffset.; 224 if ((fNtrees + chain->GetNtrees()) >= fTreeOffsetLen) {; 225 fTreeOffsetLen += 2 * chain->GetNtrees();; 226 Long64_t* trees = new Long64_t[fTreeOffsetLen];; 227 for (Int_t i = 0; i <= fNtrees; i++) {; 228 trees[i] = fTreeOffset[i];; 229 }; 230 delete[] fTreeOffset;; 231 fTreeOffset = trees;; 232 }; 233 chain->GetEntries(); //to force the computation of nentries; 234 TIter next(chain->GetListOfFiles());; 235 Int_t nf = 0;; 236 TChainElement* element = nullptr;; 237 while ((element = (TChainElement*) next())) {; 238 Long64_t nentries = element->GetEntries();; 239 if (fTreeOffset[fNtrees] == TTree::kMaxEntries) {; 240 fTreeOffset[fNtrees+1] = TTree::kMaxEntries;; 241 } else {; 242 fTreeOffset[fNtrees+1] = fTreeOffset[fNtrees] + nentries;; 243 }; 244 fNtrees++;; 245 fEntries += nentries;; 246 TChainElement* newelement = new TChainElement(element->GetName(), element->GetTitle());; 247 newelement->SetPacketSize(element->GetPacketSize());; 248 newelement->SetNumberEntries(nentries);; 249 fFiles->Add(newelement);; 250 nf++;; 251 }; 252 if (fProofChain); 253 // This updates the proxy chain when we will really use PROOF; 254 ResetBit(kProofUptodate);; 255 ; 256 return nf;; 257}; 258 ; 259////////////////////////////////////////////////////////////////////////////////; 260/// \brief Add a new file to this chain.; 261///; 262/// \param[in] name The path to the file to be added. See below for details.; 263/// \param[in] nentries Number of entries in the file. This can be an estimate; 264/// or queried from the file. See below for details.; 265/// \returns There are different possible return values:; 266/// - If nentries>0 (including the defaul",MatchSource.WIKI,doc/master/TChain_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html
Energy Efficiency,efficient,efficient,"are the same as; 323/// in the format above.; 324///; 325/// <h4>Details of the nentries parameter</h4>; 326/// Depending on the value of the parameter, the number of entries in the file; 327/// is retrieved differently:; 328/// - If <tt>nentries <= 0</tt>, the file is connected and the tree header read; 329/// in memory to get the number of entries.; 330/// - If <tt>nentries > 0</tt>, the file is not connected, \p nentries is; 331/// assumed to be the number of entries in the file. In this case, no check is; 332/// made that the file exists and that the corresponding tree exists as well.; 333/// This second mode is interesting in case the number of entries in the file; 334/// is already stored in a run data base for example.; 335/// - If <tt>nentries == TTree::kMaxEntries</tt> (default), the file is not; 336/// connected. The number of entries in each file will be read only when the; 337/// file will need to be connected to read an entry. This option is the; 338/// default and very efficient if one processes the chain sequentially. Note; 339/// that in case TChain::GetEntry(entry) is called and entry refers to an; 340/// entry in the 3rd file, for example, this forces the tree headers in the; 341/// first and second file to be read to find the number of entries in these; 342/// files. Note that calling TChain::GetEntriesFast after having; 343/// created a chain with this default returns TTree::kMaxEntries ! Using; 344/// TChain::GetEntries instead will force all the tree headers in the chain to; 345/// be read to get the number of entries in each tree.; 346///; 347/// <h4>The %TChain data structure</h4>; 348/// Each element of the chain is a TChainElement object. It has a name equal to; 349/// the tree name of this chain (or the name of the specific tree in the added; 350/// file if it was explicitly tagged) and a title equal to the file name. So, to; 351/// loop over the files that have been added to this chain:; 352/// ~~~ {.cpp}; 353/// TObjArray *fileElements=ch",MatchSource.WIKI,doc/master/TChain_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html
Integrability,depend,depending,"oot/treename"");; 295/// // DO THIS INSTEAD; 296/// c.Add(""myfile.root?#treename"");; 297/// ~~~; 298/// - Wildcard treatment is triggered by any of the special characters:; 299/// <b>[]*?</b> which may be used in the file name or subdirectory name,; 300/// eg. specifying ""xxx*.root"" adds all files starting with xxx in the; 301/// current file system directory and ""*/*.root"" adds all the files in the; 302/// current subdirectories (but not in the subsubdirectories).; 303///; 304/// The second format accepted for \p name may have the form of a URL, e.g.:; 305///; 306/// ~~~ {.cpp}; 307/// root://machine/path/file_name[?[query][#tree_name]]; 308/// or root://machine/path/file_name; 309/// or root://machine/path/file_name.root[.oext]/tree_name; 310/// or root://machine/path/file_name.root[.oext]/tree_name?query; 311/// ~~~; 312///; 313/// Note the following:; 314/// - The optional ""query"" token is to be interpreted by the remote server.; 315/// - Wildcards may be supported in URLs, depending on the protocol plugin and; 316/// the remote server.; 317/// - \p http or \p https URLs can contain a query identifier without; 318/// \p tree_name, but generally URLs can not be written with them because of; 319/// ambiguity with the wildcard character. (Also see the documentation for; 320/// TChain::AddFile, which does not support wildcards but allows the URL name; 321/// to contain a query).; 322/// - The rules for tagging the name of the tree in the file are the same as; 323/// in the format above.; 324///; 325/// <h4>Details of the nentries parameter</h4>; 326/// Depending on the value of the parameter, the number of entries in the file; 327/// is retrieved differently:; 328/// - If <tt>nentries <= 0</tt>, the file is connected and the tree header read; 329/// in memory to get the number of entries.; 330/// - If <tt>nentries > 0</tt>, the file is not connected, \p nentries is; 331/// assumed to be the number of entries in the file. In this case, no check is; 332/// made that th",MatchSource.WIKI,doc/master/TChain_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html
Modifiability,variab,variable," 94 // Make sure we are informed if the TFile is deleted.; 95 R__LOCKGUARD(gROOTMutex);; 96 gROOT->GetListOfCleanups()->Add(this);; 97 }; 98}; 99 ; 100////////////////////////////////////////////////////////////////////////////////; 101/// Create a chain.; 102///; 103/// A TChain is a collection of TFile objects.; 104/// the first parameter ""name"" is the name of the TTree object; 105/// in the files added with Add.; 106/// Use TChain::Add to add a new element to this chain.; 107///; 108/// In case the Tree is in a subdirectory, do, eg:; 109/// ~~~ {.cpp}; 110/// TChain ch(""subdir/treename"");; 111/// ~~~; 112/// Example:; 113/// Suppose we have 3 files f1.root, f2.root and f3.root. Each file; 114/// contains a TTree object named ""T"".; 115/// ~~~ {.cpp}; 116/// TChain ch(""T""); creates a chain to process a Tree called ""T""; 117/// ch.Add(""f1.root"");; 118/// ch.Add(""f2.root"");; 119/// ch.Add(""f3.root"");; 120/// ch.Draw(""x"");; 121/// ~~~; 122/// The Draw function above will process the variable ""x"" in Tree ""T""; 123/// reading sequentially the 3 files in the chain ch.; 124///; 125/// The TChain data structure:; 126///; 127/// Each TChainElement has a name equal to the tree name of this TChain; 128/// and a title equal to the file name. So, to loop over the; 129/// TFiles that have been added to this chain:; 130/// ~~~ {.cpp}; 131/// TObjArray *fileElements=chain->GetListOfFiles();; 132/// TIter next(fileElements);; 133/// TChainElement *chEl=0;; 134/// while (( chEl=(TChainElement*)next() )) {; 135/// TFile f(chEl->GetTitle());; 136/// ... do something with f ...; 137/// }; 138/// ~~~; 139 ; 140TChain::TChain(const char *name, const char *title, Mode mode); 141 : TTree(name, title, /*splitlevel*/ 99, nullptr), fTreeOffsetLen(100), fNtrees(0), fTreeNumber(-1), fTreeOffset(nullptr),; 142 fCanDeleteRefs(false), fTree(nullptr), fFile(nullptr), fFiles(nullptr), fStatus(nullptr), fProofChain(nullptr),; 143 fGlobalRegistration(mode == kWithGlobalRegistration); 144{; 145 //; 146 /",MatchSource.WIKI,doc/master/TChain_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html
Performance,cache,cache,"fsetLen];; 149 fFiles = new TObjArray(fTreeOffsetLen);; 150 fStatus = new TList();; 151 fTreeOffset[0] = 0;; 152 fFile = nullptr;; 153 ; 154 // Reset PROOF-related bits; 155 ResetBit(kProofUptodate);; 156 ResetBit(kProofLite);; 157 ; 158 if (fGlobalRegistration) {; 159 R__LOCKGUARD(gROOTMutex);; 160 ; 161 // Add to the global lists; 162 gROOT->GetListOfSpecials()->Add(this);; 163 gROOT->GetListOfDataSets()->Add(this);; 164 ; 165 // Make sure we are informed if the TFile is deleted.; 166 gROOT->GetListOfCleanups()->Add(this);; 167 }; 168}; 169 ; 170////////////////////////////////////////////////////////////////////////////////; 171/// Destructor.; 172 ; 173TChain::~TChain(); 174{; 175 bool rootAlive = gROOT && !gROOT->TestBit(TObject::kInvalidObject);; 176 ; 177 if (rootAlive && fGlobalRegistration) {; 178 R__LOCKGUARD(gROOTMutex);; 179 gROOT->GetListOfCleanups()->Remove(this);; 180 }; 181 ; 182 SafeDelete(fProofChain);; 183 fStatus->Delete();; 184 delete fStatus;; 185 fStatus = nullptr;; 186 fFiles->Delete();; 187 delete fFiles;; 188 fFiles = nullptr;; 189 ; 190 //first delete cache if exists; 191 auto tc = fFile && fTree ? fTree->GetReadCache(fFile) : nullptr;; 192 if (tc) {; 193 delete tc;; 194 fFile->SetCacheRead(nullptr, fTree);; 195 }; 196 ; 197 delete fFile;; 198 fFile = nullptr;; 199 // Note: We do *not* own the tree.; 200 fTree = nullptr;; 201 delete[] fTreeOffset;; 202 fTreeOffset = nullptr;; 203 ; 204 // Remove from the global lists; 205 if (rootAlive && fGlobalRegistration) {; 206 R__LOCKGUARD(gROOTMutex);; 207 gROOT->GetListOfSpecials()->Remove(this);; 208 gROOT->GetListOfDataSets()->Remove(this);; 209 }; 210 ; 211 // This is the same as fFile, don't delete it a second time.; 212 fDirectory = nullptr;; 213}; 214 ; 215////////////////////////////////////////////////////////////////////////////////; 216/// Add all files referenced by the passed chain to this chain.; 217/// The function returns the total number of files connected.; 218 ; 219Int_t TChain::Ad",MatchSource.WIKI,doc/master/TChain_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html
Safety,recover,recover,"make)Set all the branches in this TTree to be in decomposed object mode (also known as MakeClass mode).Definition TTree.cxx:9177; TTree::GetDirectoryTDirectory * GetDirectory() constDefinition TTree.h:462; TTree::GetReadCacheTTreeCache * GetReadCache(TFile *file) constFind and return the TTreeCache registered with the file and which may contain branches for us.Definition TTree.cxx:6318; TTree::fEntriesLong64_t fEntriesNumber of entries.Definition TTree.h:84; TTree::fEntryListTEntryList * fEntryList! Pointer to event selection list (if one)Definition TTree.h:126; TTree::GetTreeIndexvirtual TVirtualIndex * GetTreeIndex() constDefinition TTree.h:558; TTree::fExternalFriendsTList * fExternalFriends! List of TFriendsElement pointing to us and need to be notified of LoadTree. Content not owned.Definition TTree.h:131; TTree::SetMaxVirtualSizevirtual void SetMaxVirtualSize(Long64_t size=0)Definition TTree.h:665; TTree::SetAutoSavevirtual void SetAutoSave(Long64_t autos=-300000000)In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSa...Definition TTree.cxx:8342; TTree::Processvirtual Long64_t Process(const char *filename, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Process this tree executing the TSelector code in the specified filename.Definition TTree.cxx:7450; TTree::ResetAfterMergevirtual void ResetAfterMerge(TFileMergeInfo *)Resets the state of this TTree after a merge (keep the customization but forget the data).Definition TTree.cxx:8034; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TTree::CloneTreevirtual TTree * CloneTree(Long64_t nentries=-1, Option_t *option="""")Create a clone of this tree and copy nentries.Definition TTree.cxx:3139; TTree::GetLeafvirtual TLeaf * GetLeaf(const char *branchname, const char *leafname)Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6195; TTree::Resetvir",MatchSource.WIKI,doc/master/TChain_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html
Security,hash,hashMarkTreeName,"ndex(dotr);; 381 while (dotrIdx != kNPOS) {; 382 lastDotrIdx = dotrIdx;; 383 dotrIdx = suffix.Index(dotr, dotrIdx + 1);; 384 }; 385 if (lastDotrIdx != kNPOS) {; 386 // Add the part up until '.root' to the basename for globbing; 387 basename.Append(suffix, lastDotrIdx + dotrl);; 388 // Remove the part up until '.root' from the suffix; 389 suffix.Replace(0, lastDotrIdx + dotrl, """");; 390 }; 391 ; 392 // case with one single file; 393 if (!basename.MaybeWildcard()) {; 394 return AddFile(name, nentries);; 395 }; 396 ; 397 // wildcarding used in name; 398 Int_t nf = 0;; 399 std::vector<std::string> expanded_glob;; 400 try {; 401 expanded_glob = ROOT::Internal::TreeUtils::ExpandGlob(std::string(basename));; 402 } catch (const std::runtime_error &) {; 403 // The 'ExpandGlob' function may throw in case the directory from the glob; 404 // cannot be opened. We return 0 to signify no files were added.; 405 return nf;; 406 }; 407 ; 408 const TString hashMarkTreeName{""#"" + treename};; 409 for (const auto &path : expanded_glob) {; 410 if (suffix == hashMarkTreeName) {; 411 // See https://github.com/root-project/root/issues/11483; 412 // In case the input parameter 'name' contains both a glob and the; 413 // '?#' token to identify the tree name, the call to; 414 // `ParseTreeFileName` will produce a 'suffix' string of the form; 415 // '#treename'. Passing this to the `AddFile` call produces a bogus; 416 // file name that TChain won't be able to open afterwards. Thus,; 417 // we do not pass the 'suffix' as part of the file name, instead we; 418 // directly pass 'treename' to `AddFile`.; 419 nf += AddFile(path.c_str(), nentries, treename);; 420 } else {; 421 nf += AddFile(TString::Format(""%s%s"", path.c_str(), suffix.Data()), nentries);; 422 }; 423 }; 424 ; 425 if (fProofChain); 426 // This updates the proxy chain when we will really use PROOF; 427 ResetBit(kProofUptodate);; 428 ; 429 return nf;; 430}; 431 ; 432//////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TChain_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html
Testability,test,test,"~; 666/// If the variable name is enough to uniquely identify the variable, you can; 667/// leave out the chain and/or branch name.; 668/// For example, this generates a 3-d scatter plot of variable ""var"" in the; 669/// TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2.; 670/// ~~~ {.cpp}; 671/// ch.Draw(""var:t1.v1:t2.v2"");; 672/// ~~~; 673/// When a TChain::Draw is executed, an automatic call to TTree::AddFriend; 674/// connects the trees in the chain. When a chain is deleted, its friend; 675/// elements are also deleted.; 676///; 677/// The number of entries in the friend must be equal or greater to the number; 678/// of entries of the original chain. If the friend has fewer entries a warning; 679/// is given and the resulting histogram will have missing entries.; 680/// For additional information see TTree::AddFriend.; 681 ; 682TFriendElement* TChain::AddFriend(const char* chain, const char* dummy /* = """" */); 683{; 684 if (!fFriends) {; 685 fFriends = new TList();; 686 }; 687 TFriendElement* fe = new TFriendElement(this, chain, dummy);; 688 ; 689 R__ASSERT(fe); // There used to be a ""if (fe)"" test ... Keep this assert until we are sure that fe is never null; 690 ; 691 fFriends->Add(fe);; 692 ; 693 if (fProofChain); 694 // This updates the proxy chain when we will really use PROOF; 695 ResetBit(kProofUptodate);; 696 ; 697 // We need to invalidate the loading of the current tree because its list; 698 // of real friends is now obsolete. It is repairable only from LoadTree.; 699 InvalidateCurrentTree();; 700 ; 701 TTree* tree = fe->GetTree();; 702 if (!tree) {; 703 Warning(""AddFriend"", ""Unknown TChain %s"", chain);; 704 }; 705 return fe;; 706}; 707 ; 708////////////////////////////////////////////////////////////////////////////////; 709/// Add the whole chain or tree as a friend of this chain.; 710 ; 711TFriendElement* TChain::AddFriend(const char* chain, TFile* dummy); 712{; 713 if (!fFriends) fFriends = new TList();; 714 TFriendElement *fe ",MatchSource.WIKI,doc/master/TChain_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html
Usability,simpl,simple," switched trees if requested; the user might need; 1606 // to properly account for the number of files/trees even if they; 1607 // have no entries.; 1608 if (fNotify) {; 1609 if(!fNotify->Notify()) return -6;; 1610 }; 1611 ; 1612 // Load the next TTree.; 1613 return LoadTree(entry);; 1614 } else {; 1615 treeReadEntry = fReadEntry = -2;; 1616 }; 1617 }; 1618 }; 1619 ; 1620 ; 1621 if (!fTree) {; 1622 // The Error message already issued. However if we reach here; 1623 // we need to make sure that we do not use fTree.; 1624 //; 1625 // Force a reload of the tree next time.; 1626 fTreeNumber = -1;; 1627 ; 1628 element->SetLoadResult(returnCode);; 1629 return returnCode;; 1630 }; 1631 // ----- End of modifications by MvL; 1632 ; 1633 // Copy the chain's clone list into the new tree's; 1634 // clone list so that branch addresses stay synchronized.; 1635 if (fClones) {; 1636 for (TObjLink* lnk = fClones->FirstLink(); lnk; lnk = lnk->Next()) {; 1637 TTree* clone = (TTree*) lnk->GetObject();; 1638 ((TChain*) fTree)->TTree::AddClone(clone);; 1639 }; 1640 }; 1641 ; 1642 // Since some of the friends of this chain might simple trees; 1643 // (i.e., not really chains at all), we need to execute this; 1644 // before calling LoadTree(entry) on the friends (so that; 1645 // they use the correct read entry number).; 1646 ; 1647 // Change the new current tree to the new entry.; 1648 Long64_t loadResult = fTree->LoadTree(treeReadEntry);; 1649 if (loadResult == treeReadEntry) {; 1650 element->SetLoadResult(0);; 1651 } else {; 1652 // This is likely to be an internal error, if treeReadEntry was not in range; 1653 // (or intentionally -2 for TChain::GetEntries) then something happened; 1654 // that is very odd/surprising.; 1655 element->SetLoadResult(-5);; 1656 }; 1657 ; 1658 ; 1659 // Change the chain friends to the new entry.; 1660 if (fFriends) {; 1661 // An alternative would move this code to each of the function; 1662 // calling LoadTree (and to overload a few more).; 1663 TIter next(f",MatchSource.WIKI,doc/master/TChain_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html
Integrability,depend,dependency,". ROOT: tree/tree/inc/TChain.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TChain.h File Reference. #include ""TTree.h"". Include dependency graph for TChain.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TChain;  A chain is a collection of files containing TTree objects. More...;  . treetreeincTChain.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:26 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TChain_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TChain_8h.html
Integrability,interface,interface,") overrideDefault Draw method for all objects.Definition TChain.h:90; TChain::GetLeafTLeaf * GetLeaf(const char *branchname, const char *leafname) overrideReturn a pointer to the leaf name in the current tree.Definition TChain.cxx:1078; TChain::EStatusBitsEStatusBitsDefinition TChain.h:60; TChain::kProofLite@ kProofLiteDefinition TChain.h:64; TChain::kAutoDelete@ kAutoDeleteDefinition TChain.h:62; TChain::kProofUptodate@ kProofUptodateDefinition TChain.h:63; TChain::kGlobalWeight@ kGlobalWeightDefinition TChain.h:61; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TCollectionCollection abstract base class.Definition TCollection.h:65; TCutA specialized string object used for TTree selections.Definition TCut.h:25; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TEntryListA List of entry numbers in a TTree or TChain.Definition TEntryList.h:26; TEventList<div class=""legacybox""><h2>Legacy Code</h2> TEventList is a legacy interface: there will be no bug fi...Definition TEventList.h:31; TFileMergeInfoDefinition TFileMergeInfo.h:42; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFriendElementA TFriendElement TF describes a TTree object TF in a file.Definition TFriendElement.h:33; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TListA doubly linked list.Definition TList.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::MayNotUsevoid MayNotUse(const char *method) constUse this method to signal that a method (defined in a base class) may not be called in a derived clas...Definition TObject.cxx:1046; TSelectorA TSelector object is used by the TTree::Draw, TTree::Scan, TTree::Process to navigate in a TTree and...Definition TSelector.h:31; TStringBasic string cla",MatchSource.WIKI,doc/master/TChain_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TChain_8h_source.html
Modifiability,variab,variables,"Rene Brun 03/02/97; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TChain; 13#define ROOT_TChain; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TChain //; 19// //; 20// A chain of TTrees. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TTree.h""; 25 ; 26class TFile;; 27class TBrowser;; 28class TCut;; 29class TEntryList;; 30class TEventList;; 31class TCollection;; 32 ; 33class TChain : public TTree {; 34 ; 35protected:; 36 Int_t fTreeOffsetLen; ///< Current size of fTreeOffset array; 37 Int_t fNtrees; ///< Number of trees; 38 Int_t fTreeNumber; ///<! Current Tree number in fTreeOffset table; 39 Long64_t *fTreeOffset; ///<[fTreeOffsetLen] Array of variables; 40 bool fCanDeleteRefs; ///<! If true, TProcessIDs are deleted when closing a file; 41 TTree *fTree; ///<! Pointer to current tree (Note: We do *not* own this tree.); 42 TFile *fFile; ///<! Pointer to current file (We own the file).; 43 TObjArray *fFiles; ///< -> List of file names containing the trees (TChainElement, owned); 44 TList *fStatus; ///< -> List of active/inactive branches (TChainElement, owned); 45 TChain *fProofChain; ///<! chain proxy when going to be processed by PROOF; 46 bool fGlobalRegistration; ///<! if true, bypass use of global lists; 47 ; 48private:; 49 TChain(const TChain&); // not implemented; 50 TChain& operator=(const TChain&); // not implemented; 51 void; 52 ParseTreeFilename(const char *name, TString &filename, TString &treename, TString &query, TString &suffix) const;; 53 ; 54protected:; 55 void InvalidateCurrentTree();; 56 void ",MatchSource.WIKI,doc/master/TChain_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TChain_8h_source.html
Performance,cache,cacheSize,"_t firstentry=0) override; // *MENU*; 145 virtual void SetAutoDelete(bool autodel=true);; 146 Int_t SetBranchAddress(const char *bname,void *add, TBranch **ptr = nullptr) override;; 147 Int_t SetBranchAddress(const char *bname,void *add, TBranch **ptr, TClass *realClass, EDataType datatype, bool isptr) override;; 148 Int_t SetBranchAddress(const char *bname,void *add, TClass *realClass, EDataType datatype, bool isptr) override;; 149 template <class T> Int_t SetBranchAddress(const char *bname, T **add, TBranch **ptr = nullptr) {; 150 return TTree::SetBranchAddress<T>(bname, add, ptr);; 151 }; 152#ifndef R__NO_CLASS_TEMPLATE_SPECIALIZATION; 153 // This can only be used when the template overload resolution can distinguish between; 154 // T* and T**; 155 template <class T> Int_t SetBranchAddress(const char *bname, T *add, TBranch **ptr = nullptr) {; 156 return TTree::SetBranchAddress<T>(bname, add, ptr);; 157 }; 158#endif; 159 ; 160 void SetBranchStatus(const char *bname, bool status = true, UInt_t *found = nullptr) override;; 161 Int_t SetCacheSize(Long64_t cacheSize = -1) override;; 162 void SetDirectory(TDirectory *dir) override;; 163 void SetEntryList(TEntryList *elist, Option_t *opt="""") override;; 164 virtual void SetEntryListFile(const char *filename="""", Option_t *opt="""");; 165 void SetEventList(TEventList *evlist) override;; 166 void SetMakeClass(Int_t make) override { TTree::SetMakeClass(make); if (fTree) fTree->SetMakeClass(make);}; 167 void SetName(const char *name) override;; 168 virtual void SetPacketSize(Int_t size = 100);; 169 virtual void SetProof(bool on = true, bool refresh = false, bool gettreeheader = false);; 170 void SetWeight(Double_t w=1, Option_t *option="""") override;; 171 virtual void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0);; 172 ; 173 ClassDefOverride(TChain,5) //A chain of TTrees; 174};; 175 ; 176#endif // ROOT_TChain; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Int_tint Int_tDefinition RtypesCore.",MatchSource.WIKI,doc/master/TChain_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TChain_8h_source.html
Integrability,depend,dependency,". ROOT: core/cont/src/TClassTable.cxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Macros |; Functions |; Variables ; TClassTable.cxx File Reference. #include ""TClassTable.h""; #include ""TClass.h""; #include ""TClassEdit.h""; #include ""TProtoClass.h""; #include ""TList.h""; #include ""TROOT.h""; #include ""TString.h""; #include ""TError.h""; #include ""TRegexp.h""; #include ""TObjString.h""; #include ""TMap.h""; #include ""TInterpreter.h""; #include <map>; #include <memory>; #include <typeinfo>; #include <cstdlib>; #include <string>; #include <mutex>. Include dependency graph for TClassTable.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TClassTable::NormalizeThenLock;  ; class  ROOT::TClassAlt;  ; class  ROOT::TClassRec;  ; class  ROOT::TForNamespace;  ; class  ROOT::TMapTypeToClassRec;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Macros; #define R__USE_STD_MAP;  . Functions; static int ClassComp (const void *a, const void *b);  ; static UInt_t ROOT::ClassTableHash (const char *name, UInt_t size);  ; static std::mutex & GetClassTableMutex ();  ; std::vector< std::unique_ptr< TClassRec > > & ROOT::GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & ROOT::GetDelayedAddClassAlternate ();  . Variables; TClassTable * gClassTable;  . Macro Definition Documentation. ◆ R__USE_STD_MAP. #define R__USE_STD_MAP. Definition at line 143 of file TClassTable.cxx. Function Documentation. ◆ ClassComp(). static int ClassComp ; (; const void * ; a, . const void * ; b . ). static . Definition at line 794 of file TClassTable.cxx. ◆ GetClassTableMutex(). static std::mutex & GetClassTableMutex ; (; ). static . Definition at line 60 of file TClassTable.cxx. Variable Documentation. ◆ gClassTable. TCl",MatchSource.WIKI,doc/master/TClassTable_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx.html
Availability,error,error,"inition RtypesCore.h:46; Short_tshort Short_tDefinition RtypesCore.h:39; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; DictFuncPtr_tTClass *(* DictFuncPtr_t)()Definition Rtypes.h:85; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TClassEdit.h; GetClassTableMutexstatic std::mutex & GetClassTableMutex()Definition TClassTable.cxx:60; gClassTableTClassTable * gClassTableDefinition TClassTable.cxx:47; ClassCompstatic int ClassComp(const void *a, const void *b)Definition TClassTable.cxx:794; TClassTable.h; gClassTableR__EXTERN TClassTable * gClassTableDefinition TClassTable.h:104; TClass.h; TError.h; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; idOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineCol",MatchSource.WIKI,doc/master/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html
Deployability,update,update," 406 if (!gClassTable); 407 new TClassTable;; 408 ; 409 std::unique_lock<std::mutex> lock(GetClassTableMutex());; 410 ; 411 // check if already in table, if so return; 412 TClassRec *r = FindElement(cname, kTRUE);; 413 if (r->fName && r->fInfo) {; 414 if ( strcmp(r->fInfo->name(), typeid(ROOT::TForNamespace).name()) ==0; 415 && strcmp(info.name(), typeid(ROOT::TForNamespace).name()) ==0 ) {; 416 // We have a namespace being reloaded.; 417 // This okay we just keep the old one.; 418 return;; 419 }; 420 if (!TClassEdit::IsStdClass(cname)) {; 421 lock.unlock(); // Warning might recursively call TClassTable during gROOT init; 422 // Warn only for class that are not STD classes; 423 ::Warning(""TClassTable::Add"", ""class %s already in TClassTable"", cname);; 424 }; 425 return;; 426 } else if (ROOT::Internal::gROOTLocal && gCling) {; 427 TClass *oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(cname);; 428 if (oldcl) { // && oldcl->GetClassInfo()) {; 429 // As a work-around to ROOT-6012, we need to register the class even if; 430 // it is not a template instance, because a forward declaration in the header; 431 // files loaded by the current dictionary wil also de-activate the update; 432 // class info mechanism!; 433 ; 434 // The TClass exist and already has a class info, so it must; 435 // correspond to a class template instantiation which the interpreter; 436 // was able to make with the library containing the TClass Init.; 437 // Because it is already known to the interpreter, the update class info; 438 // will not be triggered, we need to force it.; 439 gCling->RegisterTClassUpdate(oldcl, dict);; 440 }; 441 }; 442 ; 443 if (!r->fName); 444 r->fName = StrDup(cname);; 445 r->fId = id;; 446 r->fBits = pragmabits;; 447 r->fDict = dict;; 448 r->fInfo = &info;; 449 ; 450 fgIdMap->Add(info.name(),r);; 451 ; 452 fgSorted = kFALSE;; 453}; 454 ; 455////////////////////////////////////////////////////////////////////////////////; 456/// Add a class to the class table (this is",MatchSource.WIKI,doc/master/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html
Energy Efficiency,efficient,efficient,"tDefinition TClass.h:127; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TInterpreter::RegisterTClassUpdatevirtual void RegisterTClassUpdate(TClass *oldcl, DictFuncPtr_t dict)=0; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPairCl",MatchSource.WIKI,doc/master/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html
Integrability,wrap,wrapper,"/////////////////////////////////////////////////////////////////////////; 104 ; 105namespace ROOT {; 106 class TClassRec {; 107 public:; 108 TClassRec(TClassRec *next) :; 109 fName(nullptr), fId(0), fDict(nullptr), fInfo(nullptr), fProto(nullptr), fNext(next); 110 {}; 111 ; 112 ~TClassRec() {; 113 // TClassTable::fgIdMap->Remove(r->fInfo->name());; 114 delete [] fName;; 115 delete fProto;; 116 delete fNext;; 117 }; 118 ; 119 char *fName;; 120 Version_t fId;; 121 Int_t fBits;; 122 DictFuncPtr_t fDict;; 123 const std::type_info *fInfo;; 124 TProtoClass *fProto;; 125 TClassRec *fNext;; 126 };; 127 ; 128 class TClassAlt {; 129 public:; 130 TClassAlt(const char*alternate, const char *normName, TClassAlt *next) :; 131 fName(alternate), fNormName(normName), fNext(next); 132 {}; 133 ; 134 ~TClassAlt() {; 135 // Nothing more to delete.; 136 }; 137 ; 138 const char *fName; // Do not own; 139 const char *fNormName; // Do not own; 140 std::unique_ptr<TClassAlt> fNext;; 141 };; 142 ; 143#define R__USE_STD_MAP; 144 class TMapTypeToClassRec {; 145#if defined R__USE_STD_MAP; 146 // This wrapper class allow to avoid putting #include <map> in the; 147 // TROOT.h header file.; 148 public:; 149 typedef std::map<std::string, TClassRec*> IdMap_t;; 150 typedef IdMap_t::key_type key_type;; 151 typedef IdMap_t::const_iterator const_iterator;; 152 typedef IdMap_t::size_type size_type;; 153#ifdef R__WIN32; 154 // Window's std::map does NOT defined mapped_type; 155 typedef TClassRec* mapped_type;; 156#else; 157 typedef IdMap_t::mapped_type mapped_type;; 158#endif; 159 ; 160 private:; 161 IdMap_t fMap;; 162 ; 163 public:; 164 void Add(const key_type &key, mapped_type &obj) {; 165 fMap[key] = obj;; 166 }; 167 ; 168 mapped_type Find(const key_type &key) const {; 169 IdMap_t::const_iterator iter = fMap.find(key);; 170 mapped_type cl = nullptr;; 171 if (iter != fMap.end()) cl = iter->second;; 172 return cl;; 173 }; 174 ; 175 void Remove(const key_type &key) { fMap.erase(key); }; 176 ; 177 void Prin",MatchSource.WIKI,doc/master/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html
Performance,load,load," the table does not exist but the delayed list does, then; 306/// create the table and return true.; 307 ; 308inline Bool_t TClassTable::CheckClassTableInit(); 309{; 310 // This will be set at the lastest during TROOT construction, so before; 311 // any threading could happen.; 312 if (!gClassTable || !fgTable) {; 313 if (GetDelayedAddClass().size()) {; 314 new TClassTable;; 315 return kTRUE;; 316 }; 317 return kFALSE;; 318 }; 319 return kTRUE;; 320}; 321 ; 322////////////////////////////////////////////////////////////////////////////////; 323/// Print the class table. Before printing the table is sorted; 324/// alphabetically. Only classes specified in option are listed.; 325/// The default is to list all classes.; 326/// Standard wildcarding notation supported.; 327 ; 328void TClassTable::Print(Option_t *option) const; 329{; 330 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 331 ; 332 // This is the very rare case (i.e. called before any dictionary load); 333 // so we don't need to execute this outside of the critical section.; 334 if (fgTally == 0 || !fgTable); 335 return;; 336 ; 337 SortTable();; 338 ; 339 int n = 0, ninit = 0, nl = 0;; 340 ; 341 if (!option) option = """";; 342 int nch = strlen(option);; 343 TRegexp re(option, kTRUE);; 344 ; 345 Printf(""\nDefined classes"");; 346 Printf(""class version bits initialized"");; 347 Printf(""================================================================"");; 348 for (UInt_t i = 0; i < fgTally; i++) {; 349 TClassRec *r = fgSortedTable[i];; 350 if (!r) break;; 351 n++;; 352 TString s = r->fName;; 353 if (nch && strcmp(option,r->fName) && s.Index(re) == kNPOS) continue;; 354 nl++;; 355 if (TClass::GetClass(r->fName, kFALSE)) {; 356 ninit++;; 357 Printf(""%-35s %6d %7d Yes"", r->fName, r->fId, r->fBits);; 358 } else; 359 Printf(""%-35s %6d %7d No"", r->fName, r->fId, r->fBits);; 360 }; 361 Printf(""----------------------------------------------------------------"");; 362 Printf(""Listed Classes: %4d Total classes: %4d ini",MatchSource.WIKI,doc/master/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html
Safety,safe,safe,". ROOT: core/cont/src/TClassTable.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TClassTable.cxx. Go to the documentation of this file. 1// @(#)root/cont:$Id$; 2// Author: Fons Rademakers 11/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TClassTable; 13\ingroup Containers; 14This class registers for all classes their name, id and dictionary; 15function in a hash table. Classes are automatically added by the; 16ctor of a special init class when a global of this init class is; 17initialized when the program starts (see the ClassImp macro).; 18 ; 19All functions in TClassTable are thread-safe.; 20*/; 21 ; 22#include ""TClassTable.h""; 23 ; 24#include ""TClass.h""; 25#include ""TClassEdit.h""; 26#include ""TProtoClass.h""; 27#include ""TList.h""; 28#include ""TROOT.h""; 29#include ""TString.h""; 30#include ""TError.h""; 31#include ""TRegexp.h""; 32 ; 33#include ""TObjString.h""; 34#include ""TMap.h""; 35 ; 36#include ""TInterpreter.h""; 37 ; 38#include <map>; 39#include <memory>; 40#include <typeinfo>; 41#include <cstdlib>; 42#include <string>; 43#include <mutex>; 44 ; 45using namespace ROOT;; 46 ; 47TClassTable *gClassTable;; 48 ; 49TClassAlt **TClassTable::fgAlternate;; 50TClassRec **TClassTable::fgTable;; 51TClassRec **TClassTable::fgSortedTable;; 52UInt_t TClassTable::fgSize;; 53std::atomic<UInt_t> TClassTable::fgTally;; 54Bool_t TClassTable::fgSorted;; 55UInt_t TClassTable::fgCursor;; 56TClassTable::IdMap_t *TClassTable::fgIdMap;; 57 ; 58ClassImp(TClassTable);; 59 ; 60static std::mutex &GetClassTableMutex(); 61{; 62 static std::mutex sMutex;; 63 return sMutex;; 64}; 65 ; 66// RAII to first no",MatchSource.WIKI,doc/master/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html
Security,hash,hash,". ROOT: core/cont/src/TClassTable.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TClassTable.cxx. Go to the documentation of this file. 1// @(#)root/cont:$Id$; 2// Author: Fons Rademakers 11/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TClassTable; 13\ingroup Containers; 14This class registers for all classes their name, id and dictionary; 15function in a hash table. Classes are automatically added by the; 16ctor of a special init class when a global of this init class is; 17initialized when the program starts (see the ClassImp macro).; 18 ; 19All functions in TClassTable are thread-safe.; 20*/; 21 ; 22#include ""TClassTable.h""; 23 ; 24#include ""TClass.h""; 25#include ""TClassEdit.h""; 26#include ""TProtoClass.h""; 27#include ""TList.h""; 28#include ""TROOT.h""; 29#include ""TString.h""; 30#include ""TError.h""; 31#include ""TRegexp.h""; 32 ; 33#include ""TObjString.h""; 34#include ""TMap.h""; 35 ; 36#include ""TInterpreter.h""; 37 ; 38#include <map>; 39#include <memory>; 40#include <typeinfo>; 41#include <cstdlib>; 42#include <string>; 43#include <mutex>; 44 ; 45using namespace ROOT;; 46 ; 47TClassTable *gClassTable;; 48 ; 49TClassAlt **TClassTable::fgAlternate;; 50TClassRec **TClassTable::fgTable;; 51TClassRec **TClassTable::fgSortedTable;; 52UInt_t TClassTable::fgSize;; 53std::atomic<UInt_t> TClassTable::fgTally;; 54Bool_t TClassTable::fgSorted;; 55UInt_t TClassTable::fgCursor;; 56TClassTable::IdMap_t *TClassTable::fgIdMap;; 57 ; 58ClassImp(TClassTable);; 59 ; 60static std::mutex &GetClassTableMutex(); 61{; 62 static std::mutex sMutex;; 63 return sMutex;; 64}; 65 ; 66// RAII to first no",MatchSource.WIKI,doc/master/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html
Testability,assert,assert,"me) != 0) {; 521 fprintf(stderr,""Error in TClassTable::AddAlternate: ""; 522 ""Second registration of %s with a different normalized name (old: '%s', new: '%s')\n"",; 523 alternate, a->fNormName, normName);; 524 }; 525 return nullptr;; 526 }; 527 }; 528 ; 529 fgAlternate[slot] = new TClassAlt(alternate,normName,fgAlternate[slot]);; 530 return fgAlternate[slot];; 531}; 532 ; 533////////////////////////////////////////////////////////////////////////////////; 534///; 535void TClassTable::RemoveAlternate(ROOT::TClassAlt *alt); 536{; 537 if (!alt || !gClassTable); 538 return;; 539 ; 540 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 541 ; 542 UInt_t slot = ROOT::ClassTableHash(alt->fName, fgSize);; 543 ; 544 if (!fgAlternate[slot]); 545 return;; 546 ; 547 if (fgAlternate[slot] == alt); 548 fgAlternate[slot] = alt->fNext.release();; 549 else {; 550 for (TClassAlt *a = fgAlternate[slot]; a; a = a->fNext.get()) {; 551 if (a->fNext.get() == alt) {; 552 a->fNext.swap( alt->fNext );; 553 assert( alt == alt->fNext.get());; 554 alt->fNext.release();; 555 }; 556 }; 557 }; 558 delete alt;; 559}; 560 ; 561////////////////////////////////////////////////////////////////////////////////; 562 ; 563Bool_t TClassTable::Check(const char *cname, std::string &normname); 564{; 565 if (!CheckClassTableInit()); 566 return kFALSE;; 567 ; 568 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 569 ; 570 UInt_t slot = ROOT::ClassTableHash(cname, fgSize);; 571 ; 572 // Check if 'cname' is a known normalized name.; 573 for (TClassRec *r = fgTable[slot]; r; r = r->fNext); 574 if (strcmp(cname,r->fName)==0) return kTRUE;; 575 ; 576 // See if 'cname' is register in the list of alternate names; 577 for (const TClassAlt *a = fgAlternate[slot]; a; a = a->fNext.get()) {; 578 if (strcmp(cname,a->fName)==0) {; 579 normname = a->fNormName;; 580 return kTRUE;; 581 }; 582 }; 583 ; 584 return kFALSE;; 585}; 586 ; 587////////////////////////////////////////////////////////////////////////////////; 5",MatchSource.WIKI,doc/master/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html
Usability,clear,clear,"3 ; 254 std::vector<std::pair<const char *, const char *>> &GetDelayedAddClassAlternate(); 255 {; 256 static std::vector<std::pair<const char *, const char *>> delayedAddClassAlternate;; 257 return delayedAddClassAlternate;; 258 }; 259}; 260 ; 261////////////////////////////////////////////////////////////////////////////////; 262/// TClassTable is a singleton (i.e. only one can exist per application).; 263 ; 264TClassTable::TClassTable(); 265{; 266 if (gClassTable) return;; 267 ; 268 fgSize = 1009; //this is the result of (int)TMath::NextPrime(1000);; 269 fgTable = new TClassRec* [fgSize];; 270 fgAlternate = new TClassAlt* [fgSize];; 271 fgIdMap = new IdMap_t;; 272 memset(fgTable, 0, fgSize * sizeof(TClassRec*));; 273 memset(fgAlternate, 0, fgSize * sizeof(TClassAlt*));; 274 gClassTable = this;; 275 ; 276 for (auto &&r : GetDelayedAddClass()) {; 277 AddClass(r->fName, r->fId, *r->fInfo, r->fDict, r->fBits);; 278 };; 279 GetDelayedAddClass().clear();; 280 ; 281 for (auto &&r : GetDelayedAddClassAlternate()) {; 282 AddAlternate(r.first, r.second);; 283 }; 284 GetDelayedAddClassAlternate().clear();; 285}; 286 ; 287////////////////////////////////////////////////////////////////////////////////; 288/// TClassTable singleton is deleted in Terminate().; 289 ; 290TClassTable::~TClassTable(); 291{; 292 // Try to avoid spurious warning from memory leak checkers.; 293 if (gClassTable != this) return;; 294 ; 295 for (UInt_t i = 0; i < fgSize; i++) {; 296 delete fgTable[i]; // Will delete all the elements in the chain.; 297 }; 298 delete [] fgTable; fgTable = nullptr;; 299 delete [] fgSortedTable; fgSortedTable = nullptr;; 300 delete fgIdMap; fgIdMap = nullptr;; 301}; 302 ; 303////////////////////////////////////////////////////////////////////////////////; 304/// Return true fs the table exist.; 305/// If the table does not exist but the delayed list does, then; 306/// create the table and return true.; 307 ; 308inline Bool_t TClassTable::CheckClassTableInit(); 309{; 310 // Th",MatchSource.WIKI,doc/master/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html
Availability,avail,available,"lptr), fClassMenuList(nullptr),; 1176 fDeclFileName(""""), fImplFileName(""""), fDeclFileLine(0), fImplFileLine(0),; 1177 fInstanceCount(0), fOnHeap(0),; 1178 fCheckSum(0), fCollectionProxy(nullptr), fClassVersion(0), fClassInfo(nullptr),; 1179 fTypeInfo(nullptr), fShowMembers(nullptr),; 1180 fStreamer(nullptr), fIsA(nullptr), fGlobalIsA(nullptr), fIsAMethod(nullptr),; 1181 fMerge(nullptr), fResetAfterMerge(nullptr), fNew(nullptr), fNewArray(nullptr), fDelete(nullptr), fDeleteArray(nullptr),; 1182 fDestructor(nullptr), fDirAutoAdd(nullptr), fStreamerFunc(nullptr), fConvStreamerFunc(nullptr), fSizeof(-1),; 1183 fCanSplit(-1), fIsSyntheticPair(kFALSE), fHasCustomStreamerMember(kFALSE), fProperty(0), fClassProperty(0), fHasRootPcmInfo(kFALSE), fCanLoadClassInfo(kFALSE),; 1184 fIsOffsetStreamerSet(kFALSE), fVersionUsed(kFALSE), fRuntimeProperties(0), fOffsetStreamer(0), fStreamerType(TClass::kDefault),; 1185 fState(kNoInfo),; 1186 fCurrentInfo(nullptr), fLastReadInfo(nullptr), fRefProxy(nullptr),; 1187 fSchemaRules(nullptr), fStreamerImpl(&TClass::StreamerDefault); 1188{; 1189 R__LOCKGUARD(gInterpreterMutex);; 1190 ; 1191 if (!gROOT); 1192 ::Fatal(""TClass::TClass"", ""ROOT system not initialized"");; 1193 ; 1194 {; 1195 TMmallocDescTemp setreset;; 1196 fStreamerInfo = new TObjArray(1, -2);; 1197 }; 1198 fDeclFileLine = -2; // -2 for standalone TClass (checked in dtor); 1199 ; 1200 SetBit(kLoading);; 1201 if (!gInterpreter); 1202 ::Fatal(""TClass::TClass"", ""gInterpreter not initialized"");; 1203 ; 1204 gInterpreter->SetClassInfo(this); // sets fClassInfo pointer; 1205 if (!silent && !fClassInfo && !TClassEdit::IsArtificial(name)); 1206 ::Warning(""TClass::TClass"", ""no dictionary for class %s is available"", name);; 1207 ResetBit(kLoading);; 1208 ; 1209 if (fClassInfo) SetTitle(gCling->ClassInfo_Title(fClassInfo));; 1210 fConversionStreamerInfo = nullptr;; 1211}; 1212 ; 1213////////////////////////////////////////////////////////////////////////////////; 1214/// Internal constructor.",MatchSource.WIKI,doc/master/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html
Deployability,update,update,"char *ifil, Int_t dl, Int_t il,; 1439 ClassInfo_t *givenInfo,; 1440 Bool_t silent); 1441{; 1442 if (!gROOT); 1443 ::Fatal(""TClass::TClass"", ""ROOT system not initialized"");; 1444 if (!name || !name[0]) {; 1445 ::Error(""TClass::Init"", ""The name parameter is invalid (null or empty)"");; 1446 MakeZombie();; 1447 return;; 1448 }; 1449 // Always strip the default STL template arguments (from any template argument or the class name); 1450 if (TClassEdit::IsArtificial(name)); 1451 fName = name; // We can assume that the artificial class name is already normalized.; 1452 else; 1453 fName = TClassEdit::ShortType(name, TClassEdit::kDropStlDefault).c_str();; 1454 ; 1455 fClassVersion = cversion;; 1456 fDeclFileName = dfil ? dfil : """";; 1457 fImplFileName = ifil ? ifil : """";; 1458 fDeclFileLine = dl;; 1459 fImplFileLine = il;; 1460 fTypeInfo = typeinfo;; 1461 fIsA = isa;; 1462 if ( fIsA ) fIsA->SetClass(this);; 1463 // See also TCling::GenerateTClass() which will update fClassVersion after creation!; 1464 fStreamerInfo = new TObjArray(fClassVersion+2+10,-1); // +10 to read new data by old; 1465 fProperty = -1;; 1466 fClassProperty = 0;; 1467 const bool ispair = TClassEdit::IsStdPair(fName);; 1468 if (ispair); 1469 SetBit(kIsForeign);; 1470 ; 1471 ResetInstanceCount();; 1472 ; 1473 TClass *oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(fName.Data());; 1474 ; 1475 InsertTClassInRegistryRAII insertRAII(fState,fName,fNoInfoOrEmuOrFwdDeclNameRegistry);; 1476 ; 1477 if (oldcl && oldcl->TestBit(kLoading)) {; 1478 // Do not recreate a class while it is already being created!; 1479 ; 1480 // We can no longer reproduce this case, to check whether we are, we use; 1481 // this code:; 1482 // Fatal(""Init"",""A bad replacement for %s was requested\n"",name);; 1483 return;; 1484 }; 1485 ; 1486 TClass **persistentRef = nullptr;; 1487 if (oldcl) {; 1488 ; 1489 persistentRef = oldcl->fPersistentRef.exchange(nullptr);; 1490 ; 1491 // The code from here is also in ForceReload.; 1492 TClass::Remo",MatchSource.WIKI,doc/master/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html
Energy Efficiency,allocate,allocated,"b) {; 2082 if (!fRealData) BuildRealData();; 2083 ; 2084 b->Add(GetListOfDataMembers(), ""Data Members"");; 2085 b->Add(GetListOfRealData(), ""Real Data Members"");; 2086 b->Add(GetListOfMethods(), ""Methods"");; 2087 b->Add(GetListOfBases(), ""Base Classes"");; 2088 }; 2089}; 2090 ; 2091////////////////////////////////////////////////////////////////////////////////; 2092/// Build a full list of persistent data members.; 2093/// Scans the list of all data members in the class itself and also; 2094/// in all base classes. For each persistent data member, inserts a; 2095/// TRealData object in the list fRealData.; 2096///; 2097 ; 2098void TClass::BuildRealData(void* pointer, Bool_t isTransient); 2099{; 2100 ; 2101 R__LOCKGUARD(gInterpreterMutex);; 2102 ; 2103 // Only do this once.; 2104 if (fRealData) {; 2105 return;; 2106 }; 2107 ; 2108 if (fClassVersion == 0) {; 2109 isTransient = kTRUE;; 2110 }; 2111 ; 2112 // When called via TMapFile (e.g. Update()) make sure that the dictionary; 2113 // gets allocated on the heap and not in the mapped file.; 2114 TMmallocDescTemp setreset;; 2115 ; 2116 // Handle emulated classes and STL containers specially.; 2117 if (!HasInterpreterInfo() || TClassEdit::IsSTLCont(GetName(), 0) || TClassEdit::IsSTLBitset(GetName())) {; 2118 // We are an emulated class or an STL container.; 2119 fRealData = new TList;; 2120 BuildEmulatedRealData("""", 0, this, isTransient);; 2121 return;; 2122 }; 2123 ; 2124 // return early on string; 2125 static TClassRef clRefString(""std::string"");; 2126 if (clRefString == this) {; 2127 return;; 2128 }; 2129 ; 2130 // Complain about stl classes ending up here (unique_ptr etc) - except for; 2131 // pair where we will build .first, .second just fine; 2132 // and those for which the user explicitly requested a dictionary.; 2133 if (!isTransient && GetState() != kHasTClassInit; 2134 && TClassEdit::IsStdClass(GetName()); 2135 && !TClassEdit::IsStdPair(GetName())) {; 2136 Error(""BuildRealData"", ""Inspection for %s not supported",MatchSource.WIKI,doc/master/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html
Integrability,wrap,wrapper,"{; 339 // Register in the repository that an object has moved.; 340 ; 341 // Move not only the object itself but also any base classes or sub-objects.; 342 size_t objsize = what->Size();; 343 long delta = (char*)newadd - (char*)oldadd;; 344 R__LOCKGUARD2(fOVRMutex);; 345 RepoCont_t::iterator cur = fObjectVersionRepository.find(oldadd);; 346 for (; cur != fObjectVersionRepository.end();) {; 347 RepoCont_t::iterator tmp = cur++;; 348 if (oldadd <= tmp->first && tmp->first < ( ((char*)oldadd) + objsize) ) {; 349 // The location is within the object, let's move it.; 350 ; 351 fObjectVersionRepository.insert(RepoCont_t::value_type(((char*)tmp->first)+delta, tmp->second));; 352 fObjectVersionRepository.erase(tmp);; 353 ; 354 } else {; 355 // -- No address, version match, we've reached the end.; 356 break;; 357 }; 358 }; 359}; 360 ; 361//______________________________________________________________________________; 362//______________________________________________________________________________; 363namespace ROOT {; 364#define R__USE_STD_MAP; 365 class TMapTypeToTClass {; 366#if defined R__USE_STD_MAP; 367 // This wrapper class allow to avoid putting #include <map> in the; 368 // TROOT.h header file.; 369 public:; 370 typedef std::map<std::string,TClass*> IdMap_t;; 371 typedef IdMap_t::key_type key_type;; 372 typedef IdMap_t::const_iterator const_iterator;; 373 typedef IdMap_t::size_type size_type;; 374#ifdef R__WIN32; 375 // Window's std::map does NOT defined mapped_type; 376 typedef TClass* mapped_type;; 377#else; 378 typedef IdMap_t::mapped_type mapped_type;; 379#endif; 380 ; 381 private:; 382 IdMap_t fMap;; 383 ; 384 public:; 385 void Add(const key_type &key, mapped_type &obj); 386 {; 387 // Add the <key,obj> pair to the map.; 388 fMap[key] = obj;; 389 }; 390 mapped_type Find(const key_type &key) const; 391 {; 392 // Find the type corresponding to the key.; 393 IdMap_t::const_iterator iter = fMap.find(key);; 394 mapped_type cl = nullptr;; 395 if (iter != fMap.end()",MatchSource.WIKI,doc/master/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html
Modifiability,inherit,inherited,"SchemaRuleSet* TClass::GetSchemaRules() const; 2000{; 2001 return fSchemaRules;; 2002}; 2003 ; 2004////////////////////////////////////////////////////////////////////////////////; 2005/// Return the set of the schema rules if any.; 2006/// If create is true, create an empty set; 2007 ; 2008ROOT::Detail::TSchemaRuleSet* TClass::GetSchemaRules(Bool_t create); 2009{; 2010 if (create && fSchemaRules == nullptr) {; 2011 fSchemaRules = new ROOT::Detail::TSchemaRuleSet();; 2012 fSchemaRules->SetClass( this );; 2013 }; 2014 return fSchemaRules;; 2015}; 2016 ; 2017////////////////////////////////////////////////////////////////////////////////; 2018 ; 2019void TClass::AddImplFile(const char* filename, int line) {; 2020 // Currently reset the implementation file and line.; 2021 // In the close future, it will actually add this file and line; 2022 // to a ""list"" of implementation files.; 2023 ; 2024 fImplFileName = filename;; 2025 fImplFileLine = line;; 2026}; 2027 ; 2028////////////////////////////////////////////////////////////////////////////////; 2029/// Browse external object inherited from TObject.; 2030/// It passes through inheritance tree and calls TBrowser::Add; 2031/// in appropriate cases. Static function.; 2032 ; 2033Int_t TClass::AutoBrowse(TObject *obj, TBrowser *b); 2034{; 2035 if (!obj) return 0;; 2036 ; 2037 TAutoInspector insp(b);; 2038 obj->ShowMembers(insp);; 2039 return insp.fCount;; 2040}; 2041 ; 2042////////////////////////////////////////////////////////////////////////////////; 2043/// Browse objects of of the class described by this TClass object.; 2044 ; 2045Int_t TClass::Browse(void *obj, TBrowser *b) const; 2046{; 2047 if (!obj) return 0;; 2048 ; 2049 TClass *actual = GetActualClass(obj);; 2050 if (IsTObject()) {; 2051 // Call TObject::Browse.; 2052 ; 2053 if (!fIsOffsetStreamerSet) {; 2054 CalculateStreamerOffset();; 2055 }; 2056 TObject* realTObject = (TObject*)((size_t)obj + fOffsetStreamer);; 2057 realTObject->Browse(b);; 2058 return 1;; 2059",MatchSource.WIKI,doc/master/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html
Performance,perform,perform," Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TClass; 13TClass instances represent classes, structs and namespaces in the ROOT type system.; 14 ; 15TClass instances are created starting from different sources of information:; 161. TStreamerInfo instances saved in a ROOT file which is opened. This is called in jargon an *emulated TClass*.; 172. From TProtoClass instances saved in a ROOT pcm file created by the dictionary generator and the dictionary itself.; 183. From a lookup in the AST built by cling.; 19 ; 20If a TClass instance is built through the mechanisms 1. and 2., it does not contain information about methods of the; 21class/struct/namespace it represents. Conversely, if built through 3. or 1., it does not carry the information which is necessary; 22to ROOT to perform I/O of instances of the class/struct it represents.; 23The mechanisms 1., 2. and 3. are not mutually exclusive: it can happen that during the execution of the program, all; 24the three are triggered, modifying the state of the TClass instance.; 25 ; 26In order to retrieve a TClass instance from the type system, a query can be executed as follows through the static; 27TClass::GetClass method:; 28 ; 29~~~ {.cpp}; 30auto myClassTClass_0 = TClass::GetClass(""myClass"");; 31auto myClassTClass_1 = TClass::GetClass<myClass>();; 32auto myClassTClass_2 = TClass::GetClass(myClassTypeInfo);; 33~~~; 34 ; 35The name of classes is crucial for ROOT. A careful procedure of *name normalization* is carried out for; 36each and every class. A *normalized name* is a valid C++ class name.; 37In order to access the name of a class within the ROOT type system, the method TClass::GetName() can be used.; 38*/; 39 ; 40//*-*x7.5 macros/layout_class; 41 ; 42#include ""TClass.h""; 43 ; 44#include ""strlcpy.",MatchSource.WIKI,doc/master/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html
Safety,avoid,avoid,".h""; 125#include ""TRefArray.h""; 126 ; 127using std::multimap, std::make_pair, std::string;; 128 ; 129// Mutex to protect CINT and META operations; 130// (exported to be used for similar cases in related classes); 131 ; 132TVirtualMutex* gInterpreterMutex = nullptr;; 133 ; 134namespace {; 135 ; 136 static constexpr const char kUndeterminedClassInfoName[] = ""<NOT YET DETERMINED FROM fClassInfo>"";; 137 ; 138 class TMmallocDescTemp {; 139 private:; 140 void *fSave;; 141 public:; 142 TMmallocDescTemp(void *value = nullptr) :; 143 fSave(ROOT::Internal::gMmallocDesc) { ROOT::Internal::gMmallocDesc = value; }; 144 ~TMmallocDescTemp() { ROOT::Internal::gMmallocDesc = fSave; }; 145 };; 146 ; 147 // When a new class is created, we need to be able to find; 148 // if there are any existing classes that have the same name; 149 // after any typedefs are expanded. (This only really affects; 150 // template arguments.) To avoid having to search through all classes; 151 // in that case, we keep a hash table mapping from the fully; 152 // typedef-expanded names to the original class names.; 153 // An entry is made in the table only if they are actually different.; 154 //; 155 // In these objects, the TObjString base holds the typedef-expanded; 156 // name (the hash key), and fOrigName holds the original class name; 157 // (the value to which the key maps).; 158 //; 159 class TNameMapNode : public TObjString {; 160 public:; 161 TString fOrigName;; 162 ; 163 TNameMapNode(const char *typedf, const char *orig) :; 164 TObjString (typedf),; 165 fOrigName (orig); 166 {; 167 }; 168 };; 169 ; 170}; 171 ; 172std::atomic<Int_t> TClass::fgClassCount;; 173 ; 174static bool IsFromRootCling() {; 175 // rootcling also uses TCling for generating the dictionary ROOT files.; 176 const static bool foundSymbol = dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"");; 177 return foundSymbol;; 178}; 179 ; 180// Implementation of the TDeclNameRegistry; 181 ; 182////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html
Security,access,access,"ethods of the; 21class/struct/namespace it represents. Conversely, if built through 3. or 1., it does not carry the information which is necessary; 22to ROOT to perform I/O of instances of the class/struct it represents.; 23The mechanisms 1., 2. and 3. are not mutually exclusive: it can happen that during the execution of the program, all; 24the three are triggered, modifying the state of the TClass instance.; 25 ; 26In order to retrieve a TClass instance from the type system, a query can be executed as follows through the static; 27TClass::GetClass method:; 28 ; 29~~~ {.cpp}; 30auto myClassTClass_0 = TClass::GetClass(""myClass"");; 31auto myClassTClass_1 = TClass::GetClass<myClass>();; 32auto myClassTClass_2 = TClass::GetClass(myClassTypeInfo);; 33~~~; 34 ; 35The name of classes is crucial for ROOT. A careful procedure of *name normalization* is carried out for; 36each and every class. A *normalized name* is a valid C++ class name.; 37In order to access the name of a class within the ROOT type system, the method TClass::GetName() can be used.; 38*/; 39 ; 40//*-*x7.5 macros/layout_class; 41 ; 42#include ""TClass.h""; 43 ; 44#include ""strlcpy.h""; 45#include ""snprintf.h""; 46#include ""TBaseClass.h""; 47#include ""TBrowser.h""; 48#include ""TBuffer.h""; 49#include ""TClassGenerator.h""; 50#include ""TClassEdit.h""; 51#include ""TClassMenuItem.h""; 52#include ""TClassRef.h""; 53#include ""TClassTable.h""; 54#include ""TDataMember.h""; 55#include ""TDataType.h""; 56#include ""TDatime.h""; 57#include ""TEnum.h""; 58#include ""TError.h""; 59#include ""TExMap.h""; 60#include ""TFunctionTemplate.h""; 61#include ""THashList.h""; 62#include ""TInterpreter.h""; 63#include ""TMemberInspector.h""; 64#include ""TMethod.h""; 65#include ""TMethodArg.h""; 66#include ""TMethodCall.h""; 67#include ""TObjArray.h""; 68#include ""TObjString.h""; 69#include ""TProtoClass.h""; 70#include ""TROOT.h""; 71#include ""TRealData.h""; 72#include ""TCheckHashRecursiveRemoveConsistency.h"" // Private header; 73#include ""TStreamer.h""; 74#include ""TStreamerEl",MatchSource.WIKI,doc/master/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html
Testability,assert,assert,"ointer, i);; 749 line[kvalue+i] = 0;; 750 } else {; 751 line[kvalue] = 0;; 752 }; 753 } else {; 754 strncpy(&line[kvalue], membertype->AsString(p3pointer), TMath::Min(kline-1-kvalue,(int)strlen(membertype->AsString(p3pointer))));; 755 }; 756 } else if (!strcmp(memberFullTypeName, ""char*"") ||; 757 !strcmp(memberFullTypeName, ""const char*"")) {; 758 i = strlen(*ppointer);; 759 if (kvalue+i >= kline) i=kline-1-kvalue;; 760 Bool_t isPrintable = kTRUE;; 761 for (Int_t j = 0; j < i; j++) {; 762 if (!std::isprint((*ppointer)[j])) {; 763 isPrintable = kFALSE;; 764 break;; 765 }; 766 }; 767 if (isPrintable) {; 768 strncpy(line + kvalue, *ppointer, kline - kvalue);; 769 line[kvalue+i] = 0;; 770 } else {; 771 line[kvalue] = 0;; 772 }; 773 } else {; 774 if (!fNoAddr) {; 775 snprintf(&line[kvalue],kline-kvalue,""->%zx "", (size_t)p3pointer);; 776 }; 777 }; 778 } else if (membertype) {; 779 if (isdate) {; 780 cdatime = (UInt_t*)pointer;; 781 TDatime::GetDateTime(cdatime[0],cdate,ctime);; 782 snprintf(&line[kvalue],kline-kvalue,""%d/%d"",cdate,ctime);; 783 } else if (isbits) {; 784 snprintf(&line[kvalue],kline-kvalue,""0x%08x"", *(UInt_t*)pointer);; 785 } else {; 786 strncpy(&line[kvalue], membertype->AsString(pointer), TMath::Min(kline-1-kvalue,(int)strlen(membertype->AsString(pointer))));; 787 }; 788 } else {; 789 if (isStdString) {; 790 std::string *str = (std::string*)pointer;; 791 snprintf(&line[kvalue],kline-kvalue,""%s"",str->c_str());; 792 } else if (isTString) {; 793 TString *str = (TString*)pointer;; 794 snprintf(&line[kvalue],kline-kvalue,""%s"",str->Data());; 795 } else {; 796 if (!fNoAddr) {; 797 snprintf(&line[kvalue],kline-kvalue,""->%zx "", (size_t)pointer);; 798 }; 799 }; 800 }; 801 // Encode data member title; 802 if (isdate == kFALSE && strcmp(memberFullTypeName, ""char*"") && strcmp(memberFullTypeName, ""const char*"")) {; 803 i = strlen(&line[0]); line[i] = ' ';; 804 assert(250 > ktitle);; 805 strlcpy(&line[ktitle],memberTitle,250-ktitle+1); // strlcpy copy 'size-1' characters.",MatchSource.WIKI,doc/master/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html
Usability,simpl,simple,"n.; 3337 ; 3338 cl = GetIdMap()->Find(typeinfo.name());; 3339 ; 3340 if (cl) {; 3341 if (cl->IsLoaded()) return cl;; 3342 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3343 load = kTRUE;; 3344 } else {; 3345 // Note we might need support for typedefs and simple types!; 3346 ; 3347 // TDataType *objType = GetType(name, load);; 3348 //if (objType) {; 3349 // const char *typdfName = objType->GetTypeName();; 3350 // if (typdfName && strcmp(typdfName, name)) {; 3351 // cl = GetClass(typdfName, load);; 3352 // return cl;; 3353 // }; 3354 // }; 3355 }; 3356 ; 3357 if (!load) return nullptr;; 3358 ; 3359 DictFuncPtr_t dict = TClassTable::GetDict(typeinfo);; 3360 if (dict) {; 3361 cl = (dict)();; 3362 if (cl) cl->PostLoadCheck();; 3363 return cl;; 3364 }; 3365 if (cl) return cl;; 3366 ; 3367 TIter next(gROOT->GetListOfClassGenerators());; 3368 TClassGenerator *gen;; 3369 while( (gen = (TClassGenerator*) next()) ) {; 3370 cl = gen->GetClass(typeinfo,load);; 3371 if (cl) {; 3372 cl->PostLoadCheck();; 3373 return cl;; 3374 }; 3375 }; 3376 ; 3377 // try AutoLoading the typeinfo; 3378 int autoload_old = gCling->SetClassAutoLoading(1);; 3379 if (!autoload_old) {; 3380 // Re-disable, we just meant to test; 3381 gCling->SetClassAutoLoading(0);; 3382 }; 3383 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3384 // Disable autoload to avoid potential infinite recursion; 3385 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3386 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3387 if (cl) {; 3388 return cl;; 3389 }; 3390 }; 3391 ; 3392 if (hint_pair_offset) {; 3393 int err = 0;; 3394 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3395 if (!err) {; 3396 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3397 free(demangled_name);; 3398 if (cl); 3399 return cl;; 3400 }; 3401 }; 3402 ; 3403 // last attempt. Look in the interpreter list of all (compiled+",MatchSource.WIKI,doc/master/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html
Integrability,depend,dependency,". ROOT: core/meta/inc/TClass.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Typedefs |; Functions ; TClass.h File Reference. #include ""TDictionary.h""; #include ""TString.h""; #include ""TObjArray.h""; #include <cstddef>; #include <map>; #include <string>; #include <unordered_set>; #include <vector>; #include <atomic>. Include dependency graph for TClass.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TClass::InsertTClassInRegistryRAII;  ; struct  TClass::ObjectPtr;  ; class  TClass;  TClass instances represent classes, structs and namespaces in the ROOT type system. More...;  ; struct  ROOT::Internal::TClassGetClassHelper< T >;  ; class  TClass::TDeclNameRegistry;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Detail;  Special implementation of ROOT::RRangeCast for TCollection, including a check that the cast target type inherits from TObject and a new constructor that takes the TCollection by pointer. ;  ; namespace  ROOT::Internal;  . Typedefs; typedef ROOT::TMapDeclIdToTClass DeclIdMap_t;  ; typedef ROOT::TMapTypeToTClass IdMap_t;  . Functions; TClass * ROOT::CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; template<typename T > ; TClass * ROOT::GetClass (const T *);  ; template<typename T > ; TClass * ROOT::GetClass (const T **);  ; template<typename T > ; TClass * ROOT::GetClass (const T *const *);  ; template<typename T > ; TClass * ROOT::GetClass (T *);  ; template<typename T > ; TClass * ROOT::GetClass (T **);  ; template<typename T > ; TClass * ROOT::Internal::GetClassHelper (Bool_t load, Bool_t silent, std::false_type);  ;",MatchSource.WIKI,doc/master/TClass_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClass_8h.html
Modifiability,inherit,inherits," core/meta/inc/TClass.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Typedefs |; Functions ; TClass.h File Reference. #include ""TDictionary.h""; #include ""TString.h""; #include ""TObjArray.h""; #include <cstddef>; #include <map>; #include <string>; #include <unordered_set>; #include <vector>; #include <atomic>. Include dependency graph for TClass.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TClass::InsertTClassInRegistryRAII;  ; struct  TClass::ObjectPtr;  ; class  TClass;  TClass instances represent classes, structs and namespaces in the ROOT type system. More...;  ; struct  ROOT::Internal::TClassGetClassHelper< T >;  ; class  TClass::TDeclNameRegistry;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Detail;  Special implementation of ROOT::RRangeCast for TCollection, including a check that the cast target type inherits from TObject and a new constructor that takes the TCollection by pointer. ;  ; namespace  ROOT::Internal;  . Typedefs; typedef ROOT::TMapDeclIdToTClass DeclIdMap_t;  ; typedef ROOT::TMapTypeToTClass IdMap_t;  . Functions; TClass * ROOT::CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; template<typename T > ; TClass * ROOT::GetClass (const T *);  ; template<typename T > ; TClass * ROOT::GetClass (const T **);  ; template<typename T > ; TClass * ROOT::GetClass (const T *const *);  ; template<typename T > ; TClass * ROOT::GetClass (T *);  ; template<typename T > ; TClass * ROOT::GetClass (T **);  ; template<typename T > ; TClass * ROOT::Internal::GetClassHelper (Bool_t load, Bool_t silent, std::false_type);  ; templa",MatchSource.WIKI,doc/master/TClass_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClass_8h.html
Performance,load,load,"er is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TClass::InsertTClassInRegistryRAII;  ; struct  TClass::ObjectPtr;  ; class  TClass;  TClass instances represent classes, structs and namespaces in the ROOT type system. More...;  ; struct  ROOT::Internal::TClassGetClassHelper< T >;  ; class  TClass::TDeclNameRegistry;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Detail;  Special implementation of ROOT::RRangeCast for TCollection, including a check that the cast target type inherits from TObject and a new constructor that takes the TCollection by pointer. ;  ; namespace  ROOT::Internal;  . Typedefs; typedef ROOT::TMapDeclIdToTClass DeclIdMap_t;  ; typedef ROOT::TMapTypeToTClass IdMap_t;  . Functions; TClass * ROOT::CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; template<typename T > ; TClass * ROOT::GetClass (const T *);  ; template<typename T > ; TClass * ROOT::GetClass (const T **);  ; template<typename T > ; TClass * ROOT::GetClass (const T *const *);  ; template<typename T > ; TClass * ROOT::GetClass (T *);  ; template<typename T > ; TClass * ROOT::GetClass (T **);  ; template<typename T > ; TClass * ROOT::Internal::GetClassHelper (Bool_t load, Bool_t silent, std::false_type);  ; template<typename T > ; TClass * ROOT::Internal::GetClassHelper (Bool_t, Bool_t, std::true_type);  . Typedef Documentation. ◆ DeclIdMap_t. typedef ROOT::TMapDeclIdToTClass DeclIdMap_t. Definition at line 79 of file TClass.h. ◆ IdMap_t. typedef ROOT::TMapTypeToTClass IdMap_t. Definition at line 78 of file TClass.h. coremetaincTClass.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TClass_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClass_8h.html
Availability,avail,available,"_t> fCanSplit; //!Indicates whether this class can be split or not. Values are -1, 0, 1, 2; 246 ; 247 // Bit field; 248 /// Indicates whether this class represents a pair and was not created from a dictionary nor interpreter info but has; 249 /// compiler compatible offset and size (and all the info is in the StreamerInfo per se); 250 Bool_t fIsSyntheticPair : 1; //!; 251 ; 252 /// @brief The class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based) automatic streamer.; 253 Bool_t fHasCustomStreamerMember : 1; //!; 254 ; 255 mutable std::atomic<Long_t> fProperty; //!Property See TClass::Property() for details; 256 mutable Long_t fClassProperty; //!C++ Property of the class (is abstract, has virtual table, etc.); 257 ; 258 // fHasRootPcmInfo needs to be atomic as long as GetListOfBases needs to modify it.; 259 std::atomic<Bool_t> fHasRootPcmInfo; //!Whether info was loaded from a root pcm.; 260 mutable std::atomic<Bool_t> fCanLoadClassInfo; //!Indicates whether the ClassInfo is supposed to be available.; 261 mutable std::atomic<Bool_t> fIsOffsetStreamerSet; //!saved remember if fOffsetStreamer has been set.; 262 mutable std::atomic<Bool_t> fVersionUsed; //!Indicates whether GetClassVersion has been called; 263 ; 264 enum class ERuntimeProperties : UChar_t {; 265 kNotInitialized = 0,; 266 kSet = BIT(0),; 267 // kInconsistent when kSet & !kConsistent.; 268 kConsistentHash = BIT(1); 269 };; 270 friend bool operator&(UChar_t l, ERuntimeProperties r) {; 271 return l & static_cast<UChar_t>(r);; 272 }; 273 mutable std::atomic<UChar_t> fRuntimeProperties; //! Properties that can only be evaluated at run-time; 274 ; 275 mutable Longptr_t fOffsetStreamer; //!saved info to call Streamer; 276 Int_t fStreamerType; //!cached of the streaming method to use; 277 EState fState; //!Current 'state' of the class (Emulated,Interpreted,Loaded); 278 mutable std::atomic<TVirtualStreamerInfo*> fCurrentInfo; //!cached current streamer info.; 279 mutabl",MatchSource.WIKI,doc/master/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html
Deployability,update,updated,"mesSet;; 170 mutable std::atomic_flag fSpinLock; // MSVC doesn't support = ATOMIC_FLAG_INIT;; 171 };; 172 ; 173 class InsertTClassInRegistryRAII {; 174 // Trivial RAII used to insert names in the registry; 175 TClass::EState& fState;; 176 const char* fName;; 177 TDeclNameRegistry& fNoInfoOrEmuOrFwdDeclNameRegistry;; 178 public:; 179 InsertTClassInRegistryRAII(TClass::EState &state, const char *name, TDeclNameRegistry &emuRegistry);; 180 ~InsertTClassInRegistryRAII();; 181 };; 182 ; 183 // TClass objects can be created as a result of opening a TFile (in which; 184 // they are in emulated mode) or as a result of loading the dictionary for; 185 // the corresponding class. When a dictionary is loaded any pre-existing; 186 // emulated TClass is replaced by the one created/coming from the dictionary.; 187 // To have a reference that always point to the 'current' TClass object for; 188 // a given class, one should use a TClassRef.; 189 // TClassRef works by holding on to the fPersistentRef which is updated; 190 // atomically whenever a TClass is replaced. During the replacement the; 191 // value of fPersistentRef is set to zero, leading the TClassRef to call; 192 // TClass::GetClass which is also locked by the replacement. At the end; 193 // of the replacement, fPersistentRef points to the new TClass object.; 194 std::atomic<TClass**> fPersistentRef;//!Persistent address of pointer to this TClass object and its successors.; 195 ; 196 typedef std::atomic<std::map<std::string, TObjArray*>*> ConvSIMap_t;; 197 ; 198 mutable TObjArray *fStreamerInfo; //Array of TVirtualStreamerInfo; 199 mutable ConvSIMap_t fConversionStreamerInfo; //Array of the streamer infos derived from another class.; 200 TList *fRealData; //linked list for persistent members including base classes; 201 std::atomic<TList*> fBase; //linked list for base classes; 202 std::atomic<TListOfDataMembers*> fData; //linked list for data members; non-owning.; 203 std::atomic<TListOfDataMembers*> fUsingData;//linked lis",MatchSource.WIKI,doc/master/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html
Energy Efficiency,allocate,allocated,"5.34.18 (has no typedef at all); 115 kNoRangeCheck = 6, // Up to v5.34.18 and v5.99/06; 116 kNoBaseCheckSum = 7, // Up to v5.34.18 and v5.99/06; 117 kLatestCheckSum = 8; 118 };; 119 ; 120 // Describe the current state of the TClass itself.; 121 enum EState {; 122 kNoInfo, // The state has not yet been initialized, i.e. the TClass; 123 // was just created and/or there is no trace of it in the interpreter.; 124 kForwardDeclared, // The interpreted knows the entity is a class but that's it.; 125 kEmulated, // The information about the class only comes from a TStreamerInfo; 126 kInterpreted, // The class is described completely/only in the interpreter database.; 127 kHasTClassInit, // The class has a TClass proper bootstrap coming from a run; 128 // through rootcling/genreflex/TMetaUtils and the library; 129 // containing this dictionary has been loaded in memory.; 130 kLoaded = kHasTClassInit,; 131 kNamespaceForMeta // Very transient state necessary to bootstrap namespace entries; 132 // in ROOT Meta w/o interpreter information; 133 };; 134 ; 135 // ""Typed"" pointer that recalls how TClass::New allocated the object.; 136 // It is returned by TClass:NewObject and should be passed to TClass::DeleteArray or TClass::Destructor; 137 // to delete the object.; 138 // It is also used in TVirtualCollectionProxy for the same reasons.; 139 struct ObjectPtr; 140 {; 141 void *fPtr = nullptr;; 142 ; 143 TVirtualStreamerInfo *fAllocator = nullptr;; 144 ; 145 ObjectPtr(void *ptr = nullptr, TVirtualStreamerInfo *allocator = nullptr) : fPtr(ptr), fAllocator(allocator) {}; 146 ; 147 void *GetPtr() const { return fPtr; }; 148 ; 149 TVirtualStreamerInfo *GetAllocator() const { return fAllocator; }; 150 ; 151 operator bool() const { return fPtr != nullptr; }; 152 };; 153 ; 154private:; 155 ; 156 ; 157 ; 158 class TDeclNameRegistry {; 159 // A class which is used to collect decl names starting from normalised; 160 // names (typedef resolution is excluded here, just string manipulation; 161 // ",MatchSource.WIKI,doc/master/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html
Integrability,interface,interface,.; 200 TList *fRealData; //linked list for persistent members including base classes; 201 std::atomic<TList*> fBase; //linked list for base classes; 202 std::atomic<TListOfDataMembers*> fData; //linked list for data members; non-owning.; 203 std::atomic<TListOfDataMembers*> fUsingData;//linked list for data members pulled in through using decls.; 204 ; 205 std::atomic<TListOfEnums*> fEnums; //linked list for the enums; 206 TListOfFunctionTemplates *fFuncTemplate; //linked list for function templates [Not public until implemented as active list]; 207 std::atomic<TListOfFunctions*> fMethod; //linked list for methods; 208 ; 209 TViewPubDataMembers*fAllPubData; //all public data members (including from base classes); 210 TViewPubFunctions *fAllPubMethod; //all public methods (including from base classes); 211 mutable TList *fClassMenuList; //list of class menu items; 212 ; 213 const char *fDeclFileName; //name of class declaration file; 214 const char *fImplFileName; //name of class implementation file; 215 Short_t fDeclFileLine; //line of class declaration; 216 Short_t fImplFileLine; //line of class implementation; 217 UInt_t fInstanceCount; //number of instances of this class; 218 UInt_t fOnHeap; //number of instances on heap; 219 mutable std::atomic<UInt_t> fCheckSum; //checksum of data members and base classes; 220 TVirtualCollectionProxy *fCollectionProxy; //Collection interface; 221 Version_t fClassVersion; //Class version Identifier; 222 ClassInfo_t *fClassInfo; //pointer to CINT class info class; 223 TString fContextMenuTitle;//context menu title; 224 const std::type_info *fTypeInfo; //pointer to the C++ type information.; 225 ShowMembersFunc_t fShowMembers; //pointer to the class's ShowMembers function; 226 TClassStreamer *fStreamer; //pointer to streamer function; 227 TString fSharedLibs; //shared libraries containing class code; 228 ; 229 TVirtualIsAProxy *fIsA; //!pointer to the class's IsA proxy.; 230 IsAGlobalFunc_t fGlobalIsA; //pointer to a global IsA fu,MatchSource.WIKI,doc/master/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html
Modifiability,inherit,inheritance,"apInstanceCount() const { return fOnHeap; }; 468 void GetMenuItems(TList *listitems);; 469 TList *GetMenuList() const;; 470 TMethod *GetMethod(const char *method, const char *params, Bool_t objectIsConst = kFALSE);; 471 TMethod *GetMethodWithPrototype(const char *method, const char *proto, Bool_t objectIsConst = kFALSE,; 472 ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch);; 473 TMethod *GetMethodAny(const char *method);; 474 TMethod *GetMethodAllAny(const char *method);; 475 Int_t GetNdata();; 476 ROOT::MergeFunc_t GetMerge() const;; 477 ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const;; 478 ROOT::NewFunc_t GetNew() const;; 479 ROOT::NewArrFunc_t GetNewArray() const;; 480 Int_t GetNmethods();; 481 TClass *const*GetPersistentRef() const { return fPersistentRef; }; 482 TRealData *GetRealData(const char *name) const;; 483 TVirtualRefProxy *GetReferenceProxy() const { return fRefProxy; }; 484 const ROOT::Detail::TSchemaRuleSet *GetSchemaRules() const;; 485 ROOT::Detail::TSchemaRuleSet *GetSchemaRules(Bool_t create = kFALSE);; 486 const char *GetSharedLibs();; 487 ShowMembersFunc_t GetShowMembersWrapper() const { return fShowMembers; }; 488 EState GetState() const { return fState; }; 489 TClassStreamer *GetStreamer() const;; 490 ClassStreamerFunc_t GetStreamerFunc() const;; 491 ClassConvStreamerFunc_t GetConvStreamerFunc() const;; 492 const TObjArray *GetStreamerInfos() const { return fStreamerInfo; }; 493 TVirtualStreamerInfo *GetStreamerInfo(Int_t version=0, Bool_t isTransient = kFALSE) const;; 494 TVirtualStreamerInfo *GetStreamerInfoAbstractEmulated(Int_t version=0) const;; 495 TVirtualStreamerInfo *FindStreamerInfoAbstractEmulated(UInt_t checksum) const;; 496 const std::type_info *GetTypeInfo() const { return fTypeInfo; };; 497 ; 498 /// @brief Return 'true' if we can guarantee that if this class (or any class in; 499 /// this class inheritance hierarchy) overload TObject::Hash it also starts; 500 /// the RecursiveRemove process from its own destructor.",MatchSource.WIKI,doc/master/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html
Performance,load,loaded,"code should #include this directly.; 31// #include ""TObjString.h""; 32// #include ""ThreadLocalStorage.h""; 33// #include <set>; 34#endif; 35 ; 36#include <cstddef>; 37#include <map>; 38#include <string>; 39#include <unordered_set>; 40#include <vector>; 41#include <atomic>; 42 ; 43class TBaseClass;; 44class TBrowser;; 45class TDataMember;; 46class TCling;; 47class TMethod;; 48class TRealData;; 49class TBuffer;; 50class TVirtualStreamerInfo;; 51class TVirtualCollectionProxy;; 52class TMethodCall;; 53class TVirtualIsAProxy;; 54class TVirtualRefProxy;; 55class THashTable;; 56class TListOfFunctions;; 57class TListOfFunctionTemplates;; 58class TListOfDataMembers;; 59class TListOfEnums;; 60class TViewPubFunctions;; 61class TViewPubDataMembers;; 62class TFunctionTemplate;; 63class TProtoClass;; 64 ; 65namespace ROOT {; 66 class TGenericClassInfo;; 67 class TMapTypeToTClass;; 68 class TMapDeclIdToTClass;; 69 namespace Detail {; 70 class TSchemaRuleSet;; 71 class TCollectionProxyInfo;; 72 }; 73 namespace Internal {; 74 class TCheckHashRecursiveRemoveConsistency;; 75 }; 76}; 77 ; 78typedef ROOT::TMapTypeToTClass IdMap_t;; 79typedef ROOT::TMapDeclIdToTClass DeclIdMap_t;; 80 ; 81class TClass : public TDictionary {; 82 ; 83friend class TCling;; 84friend void ROOT::ResetClassVersion(TClass*, const char*, Short_t);; 85friend class ROOT::TGenericClassInfo;; 86friend class TProtoClass;; 87friend class ROOT::Internal::TCheckHashRecursiveRemoveConsistency;; 88friend class TStreamerInfo;; 89 ; 90public:; 91 // TClass status bits; 92 enum EStatusBits {; 93 kReservedLoading = BIT(7), // Internal status bits, set and reset only during initialization; 94 ; 95 /* had kClassSaved = BIT(12), */; 96 kHasLocalHashMember = BIT(14),; 97 kIgnoreTObjectStreamer = BIT(15),; 98 kUnloaded = BIT(16), // The library containing the dictionary for this class was; 99 // loaded and has been unloaded from memory.; 100 kIsTObject = BIT(17),; 101 kIsForeign = BIT(18),; 102 /* had kIsEmulation = BIT(19), // Depreca",MatchSource.WIKI,doc/master/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html
Security,checksum,checksum,.; 200 TList *fRealData; //linked list for persistent members including base classes; 201 std::atomic<TList*> fBase; //linked list for base classes; 202 std::atomic<TListOfDataMembers*> fData; //linked list for data members; non-owning.; 203 std::atomic<TListOfDataMembers*> fUsingData;//linked list for data members pulled in through using decls.; 204 ; 205 std::atomic<TListOfEnums*> fEnums; //linked list for the enums; 206 TListOfFunctionTemplates *fFuncTemplate; //linked list for function templates [Not public until implemented as active list]; 207 std::atomic<TListOfFunctions*> fMethod; //linked list for methods; 208 ; 209 TViewPubDataMembers*fAllPubData; //all public data members (including from base classes); 210 TViewPubFunctions *fAllPubMethod; //all public methods (including from base classes); 211 mutable TList *fClassMenuList; //list of class menu items; 212 ; 213 const char *fDeclFileName; //name of class declaration file; 214 const char *fImplFileName; //name of class implementation file; 215 Short_t fDeclFileLine; //line of class declaration; 216 Short_t fImplFileLine; //line of class implementation; 217 UInt_t fInstanceCount; //number of instances of this class; 218 UInt_t fOnHeap; //number of instances on heap; 219 mutable std::atomic<UInt_t> fCheckSum; //checksum of data members and base classes; 220 TVirtualCollectionProxy *fCollectionProxy; //Collection interface; 221 Version_t fClassVersion; //Class version Identifier; 222 ClassInfo_t *fClassInfo; //pointer to CINT class info class; 223 TString fContextMenuTitle;//context menu title; 224 const std::type_info *fTypeInfo; //pointer to the C++ type information.; 225 ShowMembersFunc_t fShowMembers; //pointer to the class's ShowMembers function; 226 TClassStreamer *fStreamer; //pointer to streamer function; 227 TString fSharedLibs; //shared libraries containing class code; 228 ; 229 TVirtualIsAProxy *fIsA; //!pointer to the class's IsA proxy.; 230 IsAGlobalFunc_t fGlobalIsA; //pointer to a global IsA fu,MatchSource.WIKI,doc/master/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html
Testability,test,testio,"92 Bool_t CanSplit() const;; 393 Bool_t CanIgnoreTObjectStreamer() { return TestBit(kIgnoreTObjectStreamer);}; 394 Long_t ClassProperty() const;; 395 TObject *Clone(const char *newname="""") const override;; 396 void CopyCollectionProxy(const TVirtualCollectionProxy&);; 397 void Draw(Option_t *option="""") override;; 398 void Dump() const override { TDictionary::Dump(); }; 399 void Dump(const void *obj, Bool_t noAddr = kFALSE) const;; 400 char *EscapeChars(const char *text) const;; 401 TVirtualStreamerInfo *FindStreamerInfo(UInt_t checksum, Bool_t isTransient = kFALSE) const;; 402 TVirtualStreamerInfo *GetConversionStreamerInfo( const char* onfile_classname, Int_t version ) const;; 403 TVirtualStreamerInfo *FindConversionStreamerInfo( const char* onfile_classname, UInt_t checksum ) const;; 404 TVirtualStreamerInfo *GetConversionStreamerInfo( const TClass* onfile_cl, Int_t version ) const;; 405 TVirtualStreamerInfo *FindConversionStreamerInfo( const TClass* onfile_cl, UInt_t checksum ) const;; 406 void ForceReload (TClass* oldcl);; 407 Bool_t HasDataMemberInfo() const { return fIsSyntheticPair || fHasRootPcmInfo || HasInterpreterInfo(); }; 408 Bool_t HasDefaultConstructor(Bool_t testio = kFALSE) const;; 409 Bool_t HasInterpreterInfoInMemory() const { return nullptr != fClassInfo; }; 410 Bool_t HasInterpreterInfo() const { return fCanLoadClassInfo || fClassInfo; }; 411 UInt_t GetCheckSum(ECheckSum code = kCurrentCheckSum) const;; 412 UInt_t GetCheckSum(Bool_t &isvalid) const;; 413 UInt_t GetCheckSum(ECheckSum code, Bool_t &isvalid) const;; 414 TVirtualCollectionProxy *GetCollectionProxy() const;; 415 TVirtualIsAProxy *GetIsAProxy() const;; 416 TMethod *GetClassMethod(const char *name, const char *params, Bool_t objectIsConst = kFALSE);; 417 TMethod *GetClassMethodWithPrototype(const char *name, const char *proto,; 418 Bool_t objectIsConst = kFALSE,; 419 ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch);; 420 Version_t GetClassVersion() const {; 421 if (!fVersionUsed.",MatchSource.WIKI,doc/master/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html
Usability,usab,usable,"alue of fStreamerType.Definition TClass.cxx:6282; TClass::GetSharedLibsconst char * GetSharedLibs()Get the list of shared libraries containing the code for class cls.Definition TClass.cxx:3690; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between an object of this class to its base class TObject.Definition TClass.cxx:2250; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition TClass.cxx:4040; TClass::ReplaceWithvoid ReplaceWith(TClass *newcl) constDefinition TClass.cxx:4209; TClass::RegisterAddressInRepositoryvoid RegisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:290; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6153; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7460; TClass::GetMenuItemsvoid GetMenuItems(TList *listitems)Returns list of methods accessible by context menu.Definition TClass.cxx:3941; TClass::SetNewvoid SetNew(ROOT::NewFunc_t newFunc)Install a new wrapper around 'new'.Definition TClass.cxx:7052; TClass::fIsAMethodstd::atomic< TMethodCall * > fIsAMethodDefinition TClass.h:231; TClass::ReadRulesstatic Int_t ReadRules()Read the class.rules files from the default location:.Definition TClass.cxx:1887; TClass::CanSplitBaseAllowBool_t CanSplitBaseAllow()Pointer to the function implementing streaming for this class.Definition TClass.cxx:2314; TClass::MoveAddressInRepositoryvoid MoveAddressInRepository(const char *where, void *oldadd, void *newadd, const TClass *what) constDefinition TClass.cxx:337; TClass::fStreamerImplstd::atomic< StreamerImpl_t > fStreamerImplDefinition TClass.h:287; TClass::SetContextMenuTitlevoid SetContextMenuTitle(c",MatchSource.WIKI,doc/master/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html
Integrability,depend,dependency,"ion.h""; #include ""cling/Interpreter/Value.h""; #include ""cling/Utils/AST.h""; #include ""clang/AST/ASTContext.h""; #include ""clang/AST/Decl.h""; #include ""clang/AST/DeclCXX.h""; #include ""clang/AST/GlobalDecl.h""; #include ""clang/AST/PrettyPrinter.h""; #include ""clang/AST/QualTypeNames.h""; #include ""clang/AST/RecordLayout.h""; #include ""clang/AST/Type.h""; #include ""clang/Frontend/CompilerInstance.h""; #include ""clang/Lex/Preprocessor.h""; #include ""clang/Sema/Sema.h""; #include ""clang/Sema/Lookup.h""; #include ""llvm/ADT/APInt.h""; #include ""llvm/ExecutionEngine/ExecutionEngine.h""; #include ""llvm/ExecutionEngine/GenericValue.h""; #include ""llvm/Support/Casting.h""; #include ""llvm/Support/raw_ostream.h""; #include ""llvm/IR/LLVMContext.h""; #include ""llvm/IR/DerivedTypes.h""; #include ""llvm/IR/Function.h""; #include ""llvm/IR/GlobalValue.h""; #include ""llvm/IR/Module.h""; #include ""llvm/IR/Type.h""; #include ""clang/Sema/SemaInternal.h""; #include <map>; #include <string>; #include <sstream>. Include dependency graph for TClingCallFunc.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Macros; #define X(type, name)    case BuiltinType::name: fArgVals[i] = cling::Value::Create(*fInterp, fArgVals[i].castAs<type>()); break;;  . Functions; static void EvaluateExpr (cling::Interpreter &interp, const Expr *E, cling::Value &V);  ; static void GetTypeAsString (QualType QT, string &type_name, ASTContext &C, PrintingPolicy Policy);  ; static void indent (ostringstream &buf, int indent_level);  ; static const string kIndentString ("" "");  . Variables; static map< const Decl *, void * > gCtorWrapperStore;  ; static map< const Decl *, void * > gDtorWrapperStore;  ; static unsigned long long gWrapperSerial = 0LL;  ; static map< const Decl *, void * > gWrapperStore;  . Macro Definition Documentation. ◆ X. #define X; (;  ; type, .  ; name . );     case BuiltinType::name: fArgVals[i] = cling::Value::Create(*fInterp, fArgVals[i].castAs<type>()); break;. Function Documentatio",MatchSource.WIKI,doc/master/TClingCallFunc_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TClingCallFunc_8cxx.html
Availability,error,error,"ename);  ; static bool R__InitStreamerInfoFactory ();  Helper to initialize TVirtualStreamerInfo's factor early. ;  ; static void RegisterCxxModules (cling::Interpreter &clingInterp);  ; static void RegisterPreIncludedHeaders (cling::Interpreter &clingInterp);  ; static bool requiresRootMap (const char *rootmapfile);  ; static Bool_t s_IsLibraryLoaded (const char *libname, cling::Interpreter *fInterpreter);  ; int TCling__AutoLoadCallback (const char *className);  ; int TCling__AutoParseCallback (const char *className);  ; int TCling__CompileMacro (const char *fileName, const char *options);  ; clang::NamespaceDecl * TCling__DEBUG__DCtoNamespace (clang::DeclContext *DC);  ; clang::RecordDecl * TCling__DEBUG__DCtoRecordDecl (clang::DeclContext *DC);  ; void TCling__DEBUG__decl_dump (void *D);  ; void TCling__DEBUG__dump (clang::Decl *D);  ; void TCling__DEBUG__dump (clang::DeclContext *DC);  ; void TCling__DEBUG__dump (clang::FunctionDecl *FD);  ; clang::DeclContext * TCling__DEBUG__getDeclContext (clang::Decl *D);  ; void TCling__DEBUG__printName (clang::Decl *D);  ; const char * TCling__GetClassSharedLibs (const char *className, bool skipCore);  ; void TCling__GetNormalizedContext (const ROOT::TMetaUtils::TNormalizedCtxt *&normCtxt);  ; TObject * TCling__GetObjectAddress (const char *Name, void *&LookupCtx);  ; const Decl * TCling__GetObjectDecl (TObject *obj);  ; void TCling__InvalidateGlobal (const clang::Decl *D);  ; int TCling__IsAutoLoadNamespaceCandidate (const clang::NamespaceDecl *nsDecl);  ; void TCling__LibraryLoadedRTTI (const void *dyLibHandle, const char *canonicalName);  ; bool TCling__LibraryLoadingFailed (const std::string &errmessage, const std::string &libStem, bool permanent, bool resolved);  Lookup libraries in LD_LIBRARY_PATH and DYLD_LIBRARY_PATH with mangled_name, which is extracted by error messages we get from callback from cling. ;  ; void TCling__LibraryUnloadedRTTI (const void *dyLibHandle, const char *canonicalName);  ; int TCling__Load",MatchSource.WIKI,doc/master/TCling_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx.html
Integrability,depend,dependency,"; #include ""cling/Utils/AST.h""; #include ""cling/Utils/ParserStateRAII.h""; #include ""cling/Utils/SourceNormalization.h""; #include ""cling/Interpreter/Exception.h""; #include ""llvm/IR/GlobalValue.h""; #include ""llvm/IR/Module.h""; #include ""llvm/Support/DynamicLibrary.h""; #include ""llvm/Support/raw_ostream.h""; #include ""llvm/Support/Path.h""; #include ""llvm/Support/Process.h""; #include ""llvm/Object/ELFObjectFile.h""; #include ""llvm/Object/ObjectFile.h""; #include ""llvm/Object/SymbolicFile.h""; #include ""llvm/Support/FileSystem.h""; #include <algorithm>; #include <iostream>; #include <cassert>; #include <map>; #include <set>; #include <stdexcept>; #include <stdint.h>; #include <fstream>; #include <sstream>; #include <string>; #include <tuple>; #include <typeinfo>; #include <unordered_map>; #include <unordered_set>; #include <utility>; #include <vector>; #include <functional>; #include <optional>; #include <cxxabi.h>; #include <sys/stat.h>; #include <limits.h>; #include <stdio.h>. Include dependency graph for TCling.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  AlternateTupleIntDoubleAsc;  ; struct  AlternateTupleIntDoubleDes;  . Macros; #define R__DLLEXPORT   __attribute__ ((visibility (""default"")));  . Enumerations; enum class  ETupleOrdering { kAscending; , kDescending; , kUnexpected; };  Check in what order the member of a tuple are layout. More...;  . Functions; static std::string AlternateTuple (const char *classname, const cling::LookupHelper &lh, Bool_t silent);  ; static void ConstructorName (std::string &name, const clang::Decl *decl, cling::Interpreter &interp, const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt);  ; TInterpreter * CreateInterpreter (void *interpLibHandle, const char *argv[]);  ; void DestroyInterpreter (TInterpreter *interp);  ; static cling::Interpreter::CompilationResult ExecAutoParse (const char *what, Bool_t header, cling::Interpreter *interpreter);  Parse the payload or header. ;  ; stat",MatchSource.WIKI,doc/master/TCling_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx.html
Performance,load,loadGlobalModuleIndex,"e. ;  ; static std::string GetClassSharedLibsForModule (const char *cls, cling::LookupHelper &LH, bool skipCore);  ; static std::string GetSharedLibImmediateDepsSlow (std::string lib, cling::Interpreter *interp, bool skipLoadedLibs=true);  This interface returns a list of dependent libraries in the form: lib libA.so libB.so libC.so. ;  ; static int HandleInterpreterException (cling::MetaProcessor *metaProcessor, const char *input_line, cling::Interpreter::CompilationResult &compRes, cling::Value *result);  Let cling process a command line. ;  ; static bool HasASTFileOnDisk (clang::Module *M, const clang::Preprocessor &PP, std::string *FullFileName=nullptr);  Checks if there is an ASTFile on disk for the given module M. ;  ; static bool hasParsedRootmapForLibrary (llvm::StringRef lib);  ; static bool hasPrecomputedLibraryDeps (llvm::StringRef lib);  ; static bool IsFromRootCling ();  ; static ETupleOrdering IsTupleAscending ();  ; static GlobalModuleIndex * loadGlobalModuleIndex (cling::Interpreter &interp);  ; static bool LoadModule (const std::string &ModuleName, cling::Interpreter &interp);  ; static void LoadModules (const std::vector< std::string > &modules, cling::Interpreter &interp);  Loads the C++ modules that we require to run any ROOT program. ;  ; static void PrintDlError (const char *dyLibName, const char *modulename);  ; static bool R__InitStreamerInfoFactory ();  Helper to initialize TVirtualStreamerInfo's factor early. ;  ; static void RegisterCxxModules (cling::Interpreter &clingInterp);  ; static void RegisterPreIncludedHeaders (cling::Interpreter &clingInterp);  ; static bool requiresRootMap (const char *rootmapfile);  ; static Bool_t s_IsLibraryLoaded (const char *libname, cling::Interpreter *fInterpreter);  ; int TCling__AutoLoadCallback (const char *className);  ; int TCling__AutoParseCallback (const char *className);  ; int TCling__CompileMacro (const char *fileName, const char *options);  ; clang::NamespaceDecl * TCling__DEBUG__DCtoNamespace (c",MatchSource.WIKI,doc/master/TCling_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx.html
Safety,avoid,avoid,"tion &T);  ; void TCling__UnlockCompilationDuringUserCodeExecution (void *);  Unlock the interpreter. ;  ; static void TCling__UpdateClassInfo (const NamedDecl *TD);  Update TClingClassInfo for a class (e.g. upon seeing a definition). ;  ; void TCling__UpdateListsOnCommitted (const cling::Transaction &T, cling::Interpreter *);  ; void TCling__UpdateListsOnUnloaded (const cling::Transaction &T);  ; int TCling_GenerateDictionary (const std::string &className, const std::vector< std::string > &headers, const std::vector< std::string > &fwdDecls, const std::vector< std::string > &unknown);  ; int TCling_GenerateDictionary (const std::vector< std::string > &classes, const std::vector< std::string > &headers, const std::vector< std::string > &fwdDecls, const std::vector< std::string > &unknown);  ; bool TClingLookupHelper__AutoParse (const char *cname);  Allow calling autoparsing from TMetaUtils. ;  ; bool TClingLookupHelper__ExistingTypeCheck (const std::string &tname, std::string &result);  Try hard to avoid looking up in the Cling database as this could enduce an unwanted autoparsing. ;  . Variables; const char * fantomline = ""TRint::EndOfLineAction();"";  ; static const std::unordered_set< std::string > gIgnoredPCMNames;  List of dicts that have the PCM information already in the PCH. ;  ; static bool HaveFullGlobalModuleIndex = false;  ; R__EXTERN int optind;  . Macro Definition Documentation. ◆ R__DLLEXPORT. #define R__DLLEXPORT   __attribute__ ((visibility (""default""))). Definition at line 151 of file TCling.cxx. Enumeration Type Documentation. ◆ ETupleOrdering. enum class ETupleOrdering. strong . Check in what order the member of a tuple are layout. . EnumeratorkAscending ; kDescending ; kUnexpected . Definition at line 3905 of file TCling.cxx. Function Documentation. ◆ AlternateTuple(). static std::string AlternateTuple ; (; const char * ; classname, . const cling::LookupHelper & ; lh, . Bool_t ; silent . ). static . Definition at line 3947 of file TCling.cxx. ◆ Co",MatchSource.WIKI,doc/master/TCling_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx.html
Availability,error,error,"eturn __FILE__; }; 315)ICF"";; 316}; 317R__EXTERN int optind;; 318 ; 319// The functions are used to bridge cling/clang/llvm compiled with no-rtti and; 320// ROOT (which uses rtti); 321 ; 322////////////////////////////////////////////////////////////////////////////////; 323/// Print a StackTrace!; 324 ; 325extern ""C""; 326void TCling__PrintStackTrace() {; 327 gSystem->StackTrace();; 328}; 329 ; 330////////////////////////////////////////////////////////////////////////////////; 331/// Load a library.; 332 ; 333extern ""C"" int TCling__LoadLibrary(const char *library); 334{; 335 return gSystem->Load(library, """", false);; 336}; 337 ; 338////////////////////////////////////////////////////////////////////////////////; 339/// Re-apply the lock count delta that TCling__ResetInterpreterMutex() caused.; 340 ; 341extern ""C"" void TCling__RestoreInterpreterMutex(void *delta); 342{; 343 ((TCling*)gCling)->ApplyToInterpreterMutex(delta);; 344}; 345 ; 346////////////////////////////////////////////////////////////////////////////////; 347/// Lookup libraries in LD_LIBRARY_PATH and DYLD_LIBRARY_PATH with mangled_name,; 348/// which is extracted by error messages we get from callback from cling. Return true; 349/// when the missing library was autoloaded.; 350 ; 351extern ""C"" bool TCling__LibraryLoadingFailed(const std::string& errmessage, const std::string& libStem, bool permanent, bool resolved); 352{; 353 return ((TCling*)gCling)->LibraryLoadingFailed(errmessage, libStem, permanent, resolved);; 354}; 355 ; 356////////////////////////////////////////////////////////////////////////////////; 357/// Reset the interpreter lock to the state it had before interpreter-related; 358/// calls happened.; 359 ; 360extern ""C"" void *TCling__ResetInterpreterMutex(); 361{; 362 return ((TCling*)gCling)->RewindInterpreterMutex();; 363}; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// Lock the interpreter.; 367 ; 368extern ""C"" void *TCling__LockCompi",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
Deployability,update,updateList,"///////////////////////////////////////////////////; 366/// Lock the interpreter.; 367 ; 368extern ""C"" void *TCling__LockCompilationDuringUserCodeExecution(); 369{; 370 if (gInterpreterMutex) {; 371 gInterpreterMutex->Lock();; 372 }; 373 return nullptr;; 374}; 375 ; 376////////////////////////////////////////////////////////////////////////////////; 377/// Unlock the interpreter.; 378 ; 379extern ""C"" void TCling__UnlockCompilationDuringUserCodeExecution(void* /*state*/); 380{; 381 if (gInterpreterMutex) {; 382 gInterpreterMutex->UnLock();; 383 }; 384}; 385 ; 386////////////////////////////////////////////////////////////////////////////////; 387/// Update TClingClassInfo for a class (e.g. upon seeing a definition).; 388 ; 389static void TCling__UpdateClassInfo(const NamedDecl* TD); 390{; 391 static Bool_t entered = kFALSE;; 392 static vector<const NamedDecl*> updateList;; 393 Bool_t topLevel;; 394 ; 395 if (entered) topLevel = kFALSE;; 396 else {; 397 entered = kTRUE;; 398 topLevel = kTRUE;; 399 }; 400 if (topLevel) {; 401 ((TCling*)gInterpreter)->UpdateClassInfoWithDecl(TD);; 402 } else {; 403 // If we are called indirectly from within another call to; 404 // TCling::UpdateClassInfo, we delay the update until the dictionary loading; 405 // is finished (i.e. when we return to the top level TCling::UpdateClassInfo).; 406 // This allows for the dictionary to be fully populated when we actually; 407 // update the TClass object. The updating of the TClass sometimes; 408 // (STL containers and when there is an emulated class) forces the building; 409 // of the TClass object's real data (which needs the dictionary info).; 410 updateList.push_back(TD);; 411 }; 412 if (topLevel) {; 413 while (!updateList.empty()) {; 414 ((TCling*)gInterpreter)->UpdateClassInfoWithDecl(updateList.back());; 415 updateList.pop_back();; 416 }; 417 entered = kFALSE;; 418 }; 419}; 420 ; 421void TCling::UpdateEnumConstants(TEnum* enumObj, TClass* cl) const {; 422 const clang::Decl* D = static_cast",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
Energy Efficiency,allocate,allocate,"_MACOSX; 3306 ; 3307#if defined (R__LINUX) || defined (R__FBSD); 3308 ; 3309////////////////////////////////////////////////////////////////////////////////; 3310/// Callback for dl_iterate_phdr(), see `man dl_iterate_phdr`.; 3311/// Collects opened libraries.; 3312 ; 3313static int callback_for_dl_iterate_phdr(struct dl_phdr_info *info, size_t size, void *data); 3314{; 3315 // This function is called through UpdateListOfLoadedSharedLibraries() which is locked.; 3316 static std::unordered_set<decltype(info->dlpi_addr)> sKnownLoadedLibBaseAddrs;; 3317 ; 3318 auto newLibs = static_cast<std::vector<std::string>*>(data);; 3319 if (!sKnownLoadedLibBaseAddrs.count(info->dlpi_addr)) {; 3320 // Skip \0, """", and kernel pseudo-libs linux-vdso.so.1 or linux-gate.so.1; 3321 if (info->dlpi_name && info->dlpi_name[0]; 3322#if defined(R__FBSD); 3323 //skip the executable (with null addr); 3324 && info->dlpi_addr; 3325 //has no path; 3326 && strncmp(info->dlpi_name, ""[vdso]"", 6); 3327 //the linker does not like to be mmapped; 3328 //causes a crash in cling::DynamicLibraryManager::loadLibrary()); 3329 //with error message ""mmap of entire address space failed: Cannot allocate memory""; 3330 && strncmp(info->dlpi_name, ""/libexec/ld-elf.so.1"", 20); 3331#endif; 3332 && strncmp(info->dlpi_name, ""linux-vdso.so"", 13); 3333 && strncmp(info->dlpi_name, ""linux-vdso32.so"", 15); 3334 && strncmp(info->dlpi_name, ""linux-vdso64.so"", 15); 3335 && strncmp(info->dlpi_name, ""linux-gate.so"", 13)); 3336 newLibs->emplace_back(info->dlpi_name);; 3337 sKnownLoadedLibBaseAddrs.insert(info->dlpi_addr);; 3338 }; 3339 // No matter what the doc says, return != 0 means ""stop the iteration"".; 3340 return 0;; 3341}; 3342 ; 3343#endif // R__LINUX || R__FBSD; 3344 ; 3345 ; 3346////////////////////////////////////////////////////////////////////////////////; 3347 ; 3348void TCling::UpdateListOfLoadedSharedLibraries(); 3349{; 3350#if defined(R__WIN32) || defined(__CYGWIN__); 3351 HMODULE hModules[1024];; 3352 void *hPro",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
Integrability,interface,interface,". ROOT: core/metacling/src/TCling.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TCling.cxx. Go to the documentation of this file. 1// @(#)root/meta:$Id$; 2// vim: sw=3 ts=3 expandtab foldmethod=indent; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TCling; 13 ; 14This class defines an interface to the cling C++ interpreter.; 15 ; 16Cling is a full ANSI compliant C++-11 interpreter based on; 17clang/LLVM technology.; 18*/; 19 ; 20#include ""TCling.h""; 21 ; 22#include ""ROOT/FoundationUtils.hxx""; 23 ; 24#include ""TClingBaseClassInfo.h""; 25#include ""TClingCallFunc.h""; 26#include ""TClingClassInfo.h""; 27#include ""TClingDataMemberInfo.h""; 28#include ""TClingMethodArgInfo.h""; 29#include ""TClingMethodInfo.h""; 30#include ""TClingRdictModuleFileExtension.h""; 31#include ""TClingTypedefInfo.h""; 32#include ""TClingTypeInfo.h""; 33#include ""TClingValue.h""; 34 ; 35#include ""TROOT.h""; 36#include ""TApplication.h""; 37#include ""TGlobal.h""; 38#include ""TDataType.h""; 39#include ""TClass.h""; 40#include ""TClassEdit.h""; 41#include ""TClassTable.h""; 42#include ""TClingCallbacks.h""; 43#include ""TClingDiagnostics.h""; 44#include ""TBaseClass.h""; 45#include ""TDataMember.h""; 46#include ""TMemberInspector.h""; 47#include ""TMethod.h""; 48#include ""TMethodArg.h""; 49#include ""TFunctionTemplate.h""; 50#include ""TObjArray.h""; 51#include ""TObjString.h""; 52#include ""TString.h""; 53#include ""THashList.h""; 54#include ""TVirtualPad.h""; 55#include ""TSystem.h""; 56#include ""TVirtualMutex.h""; 57#include ""TError.h""; 58#include ""TEnv.h""; 59#include ""TEnum.h""; 60#include ""TEnumConstant.h""; 61#include ""THashTable.h""; 62#include ""RConversion",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
Modifiability,plugin,plugin,"; 45#include ""TDataMember.h""; 46#include ""TMemberInspector.h""; 47#include ""TMethod.h""; 48#include ""TMethodArg.h""; 49#include ""TFunctionTemplate.h""; 50#include ""TObjArray.h""; 51#include ""TObjString.h""; 52#include ""TString.h""; 53#include ""THashList.h""; 54#include ""TVirtualPad.h""; 55#include ""TSystem.h""; 56#include ""TVirtualMutex.h""; 57#include ""TError.h""; 58#include ""TEnv.h""; 59#include ""TEnum.h""; 60#include ""TEnumConstant.h""; 61#include ""THashTable.h""; 62#include ""RConversionRuleParser.h""; 63#include ""RConfigure.h""; 64#include ""compiledata.h""; 65#include ""strlcpy.h""; 66#include ""snprintf.h""; 67#include ""TClingUtils.h""; 68#include ""TVirtualCollectionProxy.h""; 69#include ""TVirtualStreamerInfo.h""; 70#include ""TListOfDataMembers.h""; 71#include ""TListOfEnums.h""; 72#include ""TListOfEnumsWithLock.h""; 73#include ""TListOfFunctions.h""; 74#include ""TListOfFunctionTemplates.h""; 75#include ""TMemFile.h""; 76#include ""TProtoClass.h""; 77#include ""TStreamerInfo.h"" // This is here to avoid to use the plugin manager; 78#include ""ThreadLocalStorage.h""; 79#include ""TFile.h""; 80#include ""TKey.h""; 81#include ""ClingRAII.h""; 82 ; 83#include ""clang/AST/ASTContext.h""; 84#include ""clang/AST/Decl.h""; 85#include ""clang/AST/DeclarationName.h""; 86#include ""clang/AST/GlobalDecl.h""; 87#include ""clang/AST/RecordLayout.h""; 88#include ""clang/AST/DeclVisitor.h""; 89#include ""clang/AST/RecursiveASTVisitor.h""; 90#include ""clang/AST/Type.h""; 91#include ""clang/Basic/SourceLocation.h""; 92#include ""clang/Basic/Specifiers.h""; 93#include ""clang/Basic/TargetInfo.h""; 94#include ""clang/CodeGen/ModuleBuilder.h""; 95#include ""clang/Frontend/CompilerInstance.h""; 96#include ""clang/Frontend/FrontendDiagnostic.h""; 97#include ""clang/Lex/HeaderSearch.h""; 98#include ""clang/Lex/Preprocessor.h""; 99#include ""clang/Lex/PreprocessorOptions.h""; 100#include ""clang/Parse/Parser.h""; 101#include ""clang/Sema/Lookup.h""; 102#include ""clang/Sema/Sema.h""; 103#include ""clang/Serialization/ASTReader.h""; 104#include ""clang/Serialization/GlobalM",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
Performance,load,loader,"#include ""llvm/Support/raw_ostream.h""; 123#include ""llvm/Support/Path.h""; 124#include ""llvm/Support/Process.h""; 125#include ""llvm/Object/ELFObjectFile.h""; 126#include ""llvm/Object/ObjectFile.h""; 127#include ""llvm/Object/SymbolicFile.h""; 128#include ""llvm/Support/FileSystem.h""; 129 ; 130#include <algorithm>; 131#include <iostream>; 132#include <cassert>; 133#include <map>; 134#include <set>; 135#include <stdexcept>; 136#include <stdint.h>; 137#include <fstream>; 138#include <sstream>; 139#include <string>; 140#include <tuple>; 141#include <typeinfo>; 142#include <unordered_map>; 143#include <unordered_set>; 144#include <utility>; 145#include <vector>; 146#include <functional>; 147#include <optional>; 148 ; 149#ifndef R__WIN32; 150#include <cxxabi.h>; 151#define R__DLLEXPORT __attribute__ ((visibility (""default""))); 152#include <sys/stat.h>; 153#endif; 154#include <limits.h>; 155#include <stdio.h>; 156 ; 157#ifdef __APPLE__; 158#include <dlfcn.h>; 159#include <mach-o/dyld.h>; 160#include <mach-o/loader.h>; 161#endif // __APPLE__; 162 ; 163#ifdef R__UNIX; 164#include <dlfcn.h>; 165#endif; 166 ; 167#if defined(R__LINUX) || defined(R__FBSD); 168# ifndef _GNU_SOURCE; 169# define _GNU_SOURCE; 170# endif; 171# include <link.h> // dl_iterate_phdr(); 172#endif; 173 ; 174#if defined(__CYGWIN__); 175#include <sys/cygwin.h>; 176#define HMODULE void *; 177extern ""C"" {; 178 __declspec(dllimport) void * __stdcall GetCurrentProcess();; 179 __declspec(dllimport) bool __stdcall EnumProcessModules(void *, void **, unsigned long, unsigned long *);; 180 __declspec(dllimport) unsigned long __stdcall GetModuleFileNameExW(void *, void *, wchar_t *, unsigned long);; 181}; 182#endif; 183 ; 184// Fragment copied from LLVM's raw_ostream.cpp; 185#if defined(_MSC_VER); 186#ifndef STDIN_FILENO; 187# define STDIN_FILENO 0; 188#endif; 189#ifndef STDOUT_FILENO; 190# define STDOUT_FILENO 1; 191#endif; 192#ifndef STDERR_FILENO; 193# define STDERR_FILENO 2; 194#endif; 195#ifndef R__WIN32; 196//#if define",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
Safety,avoid,avoid,"; 45#include ""TDataMember.h""; 46#include ""TMemberInspector.h""; 47#include ""TMethod.h""; 48#include ""TMethodArg.h""; 49#include ""TFunctionTemplate.h""; 50#include ""TObjArray.h""; 51#include ""TObjString.h""; 52#include ""TString.h""; 53#include ""THashList.h""; 54#include ""TVirtualPad.h""; 55#include ""TSystem.h""; 56#include ""TVirtualMutex.h""; 57#include ""TError.h""; 58#include ""TEnv.h""; 59#include ""TEnum.h""; 60#include ""TEnumConstant.h""; 61#include ""THashTable.h""; 62#include ""RConversionRuleParser.h""; 63#include ""RConfigure.h""; 64#include ""compiledata.h""; 65#include ""strlcpy.h""; 66#include ""snprintf.h""; 67#include ""TClingUtils.h""; 68#include ""TVirtualCollectionProxy.h""; 69#include ""TVirtualStreamerInfo.h""; 70#include ""TListOfDataMembers.h""; 71#include ""TListOfEnums.h""; 72#include ""TListOfEnumsWithLock.h""; 73#include ""TListOfFunctions.h""; 74#include ""TListOfFunctionTemplates.h""; 75#include ""TMemFile.h""; 76#include ""TProtoClass.h""; 77#include ""TStreamerInfo.h"" // This is here to avoid to use the plugin manager; 78#include ""ThreadLocalStorage.h""; 79#include ""TFile.h""; 80#include ""TKey.h""; 81#include ""ClingRAII.h""; 82 ; 83#include ""clang/AST/ASTContext.h""; 84#include ""clang/AST/Decl.h""; 85#include ""clang/AST/DeclarationName.h""; 86#include ""clang/AST/GlobalDecl.h""; 87#include ""clang/AST/RecordLayout.h""; 88#include ""clang/AST/DeclVisitor.h""; 89#include ""clang/AST/RecursiveASTVisitor.h""; 90#include ""clang/AST/Type.h""; 91#include ""clang/Basic/SourceLocation.h""; 92#include ""clang/Basic/Specifiers.h""; 93#include ""clang/Basic/TargetInfo.h""; 94#include ""clang/CodeGen/ModuleBuilder.h""; 95#include ""clang/Frontend/CompilerInstance.h""; 96#include ""clang/Frontend/FrontendDiagnostic.h""; 97#include ""clang/Lex/HeaderSearch.h""; 98#include ""clang/Lex/Preprocessor.h""; 99#include ""clang/Lex/PreprocessorOptions.h""; 100#include ""clang/Parse/Parser.h""; 101#include ""clang/Sema/Lookup.h""; 102#include ""clang/Sema/Sema.h""; 103#include ""clang/Serialization/ASTReader.h""; 104#include ""clang/Serialization/GlobalM",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
Security,inject,injected," if (fCxxModulesEnabled) {; 1490 if (!fromRootCling) {; 1491 // We only set this flag, rest is done by the CIFactory.; 1492 interpArgs.push_back(""-fmodules"");; 1493 interpArgs.push_back(""-fno-implicit-module-maps"");; 1494 // We should never build modules during runtime, so let's enable the; 1495 // module build remarks from clang to make it easier to spot when we do; 1496 // this by accident.; 1497 interpArgs.push_back(""-Rmodule-build"");; 1498 }; 1499 // ROOT implements its AutoLoading upon module's link directives. We; 1500 // generate module A { header ""A.h"" link ""A.so"" export * } where ROOT's; 1501 // facilities use the link directive to dynamically load the relevant; 1502 // library. So, we need to suppress clang's default autolink behavior.; 1503 interpArgs.push_back(""-fno-autolink"");; 1504 }; 1505 ; 1506#ifdef R__FAST_MATH; 1507 // Same setting as in rootcling_impl.cxx.; 1508 interpArgs.push_back(""-ffast-math"");; 1509#endif; 1510 ; 1511 TString llvmResourceDir = TROOT::GetEtcDir() + ""/cling"";; 1512 // Add statically injected extra arguments, usually coming from rootcling.; 1513 for (const char** extraArgs = TROOT::GetExtraInterpreterArgs();; 1514 extraArgs && *extraArgs; ++extraArgs) {; 1515 if (!strcmp(*extraArgs, ""-resource-dir"")) {; 1516 // Take the next arg as the llvm resource directory.; 1517 llvmResourceDir = *(++extraArgs);; 1518 } else {; 1519 interpArgs.push_back(*extraArgs);; 1520 }; 1521 }; 1522 ; 1523 std::vector<std::string> _empty;; 1524 auto args = TROOT::AddExtraInterpreterArgs(_empty);; 1525 for (const auto &arg: args); 1526 interpArgs.emplace_back(arg.c_str());; 1527 ; 1528 // Add the Rdict module file extension.; 1529 cling::Interpreter::ModuleFileExtensions extensions;; 1530 EnvOpt = llvm::sys::Process::GetEnv(""ROOTDEBUG_RDICT"");; 1531 if (!EnvOpt.has_value()); 1532 extensions.push_back(std::make_shared<TClingRdictModuleFileExtension>());; 1533 ; 1534 fInterpreter = std::make_unique<cling::Interpreter>(interpArgs.size(),; 1535 &(interpArgs",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
Testability,test,testing," 220}; 221R__DLLEXPORT clang::RecordDecl* TCling__DEBUG__DCtoRecordDecl(clang::DeclContext* DC) {; 222 return llvm::dyn_cast<clang::RecordDecl>(DC);; 223}; 224R__DLLEXPORT void TCling__DEBUG__dump(clang::DeclContext* DC) {; 225 return DC->dumpDeclContext();; 226}; 227R__DLLEXPORT void TCling__DEBUG__dump(clang::Decl* D) {; 228 return D->dump();; 229}; 230R__DLLEXPORT void TCling__DEBUG__dump(clang::FunctionDecl* FD) {; 231 return FD->dump();; 232}; 233R__DLLEXPORT void TCling__DEBUG__decl_dump(void* D) {; 234 return ((clang::Decl*)D)->dump();; 235}; 236R__DLLEXPORT void TCling__DEBUG__printName(clang::Decl* D) {; 237 if (clang::NamedDecl* ND = llvm::dyn_cast<clang::NamedDecl>(D)) {; 238 std::string name;; 239 {; 240 llvm::raw_string_ostream OS(name);; 241 ND->getNameForDiagnostic(OS, D->getASTContext().getPrintingPolicy(),; 242 true /*Qualified*/);; 243 }; 244 printf(""%s\n"", name.c_str());; 245 }; 246}; 247//______________________________________________________________________________; 248// These functions are helpers for testing issues directly rather than; 249// relying on side effects.; 250// This is used for the test for ROOT-7462/ROOT-6070; 251R__DLLEXPORT bool TCling__TEST_isInvalidDecl(clang::Decl* D) {; 252 return D->isInvalidDecl();; 253}; 254R__DLLEXPORT bool TCling__TEST_isInvalidDecl(ClassInfo_t *input) {; 255 TClingClassInfo *info( (TClingClassInfo*) input);; 256 assert(info && info->IsValid());; 257 return info->GetDecl()->isInvalidDecl();; 258}; 259 ; 260using std::string, std::vector;; 261using namespace clang;; 262using namespace ROOT;; 263 ; 264namespace {; 265 static const std::string gInterpreterClassDef = R""ICF(; 266#undef ClassDef; 267#define ClassDef(name, id) \; 268_ClassDefInterp_(name,id,virtual,) \; 269static int DeclFileLine() { return __LINE__; }; 270#undef ClassDefNV; 271#define ClassDefNV(name, id) \; 272_ClassDefInterp_(name,id,,) \; 273static int DeclFileLine() { return __LINE__; }; 274#undef ClassDefOverride; 275#define ClassDefOv",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
Usability,clear,clear,"; 876 public:; 877 clangDiagSuppr(clang::DiagnosticsEngine& diag): fDiagEngine(diag){; 878 fOldDiagValue = fDiagEngine.getIgnoreAllWarnings();; 879 fDiagEngine.setIgnoreAllWarnings(true);; 880 }; 881 ; 882 ~clangDiagSuppr() {; 883 fDiagEngine.setIgnoreAllWarnings(fOldDiagValue);; 884 }; 885 private:; 886 clang::DiagnosticsEngine& fDiagEngine;; 887 bool fOldDiagValue;; 888 };; 889 ; 890}; 891 ; 892////////////////////////////////////////////////////////////////////////////////; 893/// Allow calling autoparsing from TMetaUtils; 894bool TClingLookupHelper__AutoParse(const char *cname); 895{; 896 return gCling->AutoParse(cname);; 897}; 898 ; 899////////////////////////////////////////////////////////////////////////////////; 900/// Try hard to avoid looking up in the Cling database as this could enduce; 901/// an unwanted autoparsing.; 902 ; 903bool TClingLookupHelper__ExistingTypeCheck(const std::string &tname,; 904 std::string &result); 905{; 906 result.clear();; 907 ; 908 unsigned long offset = 0;; 909 if (strncmp(tname.c_str(), ""const "", 6) == 0) {; 910 offset = 6;; 911 }; 912 unsigned long end = tname.length();; 913 while( end && (tname[end-1]=='&' || tname[end-1]=='*' || tname[end-1]==']') ) {; 914 if ( tname[end-1]==']' ) {; 915 --end;; 916 while ( end && tname[end-1]!='[' ) --end;; 917 }; 918 --end;; 919 }; 920 std::string innerbuf;; 921 const char *inner;; 922 if (end != tname.length()) {; 923 innerbuf = tname.substr(offset,end-offset);; 924 inner = innerbuf.c_str();; 925 } else {; 926 inner = tname.c_str()+offset;; 927 }; 928 ; 929 //if (strchr(tname.c_str(),'[')!=0) fprintf(stderr,""DEBUG: checking on %s vs %s %lu %lu\n"",tname.c_str(),inner,offset,end);; 930 if (gROOT->GetListOfClasses()->FindObject(inner); 931 || TClassTable::Check(inner,result) ) {; 932 // This is a known class.; 933 return true;; 934 }; 935 ; 936 THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );; 937 TDataType *type = (TDataType *)typeTable->THashTable::FindObject",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
Availability,error,error,"213 Int_t GetMore() const final;; 214 TClass *GenerateTClass(const char *classname, Bool_t emulation, Bool_t silent = kFALSE) final;; 215 TClass *GenerateTClass(ClassInfo_t *classinfo, Bool_t silent = kFALSE) final;; 216 Int_t GenerateDictionary(const char* classes, const char* includes = """", const char* options = nullptr) final;; 217 char* GetPrompt() final { return fPrompt; }; 218 const char* GetSharedLibs() final;; 219 const char* GetClassSharedLibs(const char* cls, bool skipCore = true) final;; 220 const char* GetSharedLibDeps(const char* lib, bool tryDyld = false) final;; 221 const char* GetIncludePath() final;; 222 virtual const char* GetSTLIncludePath() const final;; 223 TObjArray* GetRootMapFiles() const final { return fRootmapFiles; }; 224 unsigned long long GetInterpreterStateMarker() const final { return fTransactionCount;}; 225 virtual void Initialize() final;; 226 virtual void ShutDown() final;; 227 void InspectMembers(TMemberInspector&, const void* obj, const TClass* cl, Bool_t isTransient) final;; 228 Bool_t IsLoaded(const char* filename) const final;; 229 Bool_t IsLibraryLoaded(const char* libname) const final;; 230 Bool_t HasPCMForLibrary(const char *libname) const final;; 231 Int_t Load(const char* filenam, Bool_t system = kFALSE) final;; 232 void LoadMacro(const char* filename, EErrorCode* error = nullptr) final;; 233 Int_t LoadLibraryMap(const char* rootmapfile = nullptr) final;; 234 Int_t RescanLibraryMap() final;; 235 Int_t ReloadAllSharedLibraryMaps() final;; 236 Int_t UnloadAllSharedLibraryMaps() final;; 237 Int_t UnloadLibraryMap(const char* library) final;; 238 Longptr_t ProcessLine(const char* line, EErrorCode* error = nullptr) final;; 239 Longptr_t ProcessLineAsynch(const char* line, EErrorCode* error = nullptr);; 240 Longptr_t ProcessLineSynch(const char* line, EErrorCode* error = nullptr) final;; 241 void PrintIntro() final;; 242 bool RegisterPrebuiltModulePath(const std::string& FullPath,; 243 const std::string& ModuleMapName = ""module.",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
Deployability,update,update,"ng::fContentstd::string fContentDefinition TCling.h:619; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TCling::DeepAutoLoadImplstatic Int_t DeepAutoLoadImpl(const char *cls, std::unordered_set< std::string > &visited, bool nameIsNormalized)Definition TCling.cxx:6204; TCling::MethodArgInfo_DefaultValueconst char * MethodArgInfo_DefaultValue(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9296; TCling::ClassInfo_IsScopedEnumbool ClassInfo_IsScopedEnum(ClassInfo_t *info) const finalDefinition TCling.cxx:8302; TCling::TypeInfo_Nameconst char * TypeInfo_Name(TypeInfo_t *) const finalDefinition TCling.cxx:9388; TCling::MethodInfo_InterfaceMethodvoid * MethodInfo_InterfaceMethod(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9050; TCling::LoadEnumsvoid LoadEnums(TListOfEnums &cl) const finalCreate list of pointers to enums for TClass cl.Definition TCling.cxx:4395; TCling::UpdateListOfGlobalsvoid UpdateListOfGlobals() finalNo op: see TClingCallbacks (used to update the list of globals)Definition TCling.cxx:3885; TCling::TypedefInfo_IsValidbool TypedefInfo_IsValid(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9482; TCling::AutoLoadInt_t AutoLoad(const char *classname, Bool_t knowDictNotLoaded=kFALSE) finalLoad library containing the specified class.Definition TCling.cxx:6265; TCling::GetAutoLoadCallBackvoid * GetAutoLoadCallBack() const finalDefinition TCling.h:198; TCling::CallFunc_Initvoid CallFunc_Init(CallFunc_t *func) const finalDefinition TCling.cxx:7940; TCling::SetGetlinevoid SetGetline(const char *(*getlineFunc)(const char *prompt), void(*histaddFunc)(const char *line)) finalSet a getline function to call when input is needed.Definition TCling.cxx:3648; TCling::LibraryLoadingFailedbool LibraryLoadingFailed(const std::string &, const std::string &, bool, bool)Definition TCling.cxx:6568; TCling::GenericErrorvoid GenericError(const char *error) const finalLet the interpreter issue a generic error",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
Integrability,interface,interface,". ROOT: core/metacling/src/TCling.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TCling.h. Go to the documentation of this file. 1// @(#)root/meta:$Id$; 2// Author: Axel Naumann, 2011-10-19; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13#ifndef ROOT_TCling; 14#define ROOT_TCling; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TCling //; 19// //; 20// This class defines an interface to the cling C++ interpreter. //; 21// //; 22// Cling is a full ANSI compliant C++ interpreter based on //; 23// clang/LLVM technology. //; 24// //; 25//////////////////////////////////////////////////////////////////////////; 26 ; 27#include ""TInterpreter.h""; 28 ; 29#include <map>; 30#include <memory>; 31#include <set>; 32#include <tuple>; 33#include <unordered_map>; 34#include <unordered_set>; 35#include <vector>; 36#include <string>; 37#include <utility>; 38 ; 39#ifndef WIN32; 40#define TWin32SendClass char; 41#endif; 42 ; 43namespace llvm {; 44 class GlobalValue;; 45 class StringRef;; 46}; 47 ; 48namespace clang {; 49 class CXXRecordDecl;; 50 class Decl;; 51 class DeclContext;; 52 class EnumDecl;; 53 class FunctionDecl;; 54 class IdentifierIterator;; 55 class NamedDecl;; 56 class NamespaceDecl;; 57 class TagDecl;; 58 class Type;; 59 class QualType;; 60}; 61namespace cling {; 62 class Interpreter;; 63 class MetaProcessor;; 64 class Transaction;; 65 class Value;; 66}; 67 ; 68class TClingCallbacks;; 69class TEnv;; 70class TFile;; 71class THashTable;; 72class TInterpreterValue;; 73class TMethod;; 74class TObjArray;; 75class TListOfDataMembers;; 76class TLis",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
Modifiability,variab,variables,"#include <unordered_set>; 35#include <vector>; 36#include <string>; 37#include <utility>; 38 ; 39#ifndef WIN32; 40#define TWin32SendClass char; 41#endif; 42 ; 43namespace llvm {; 44 class GlobalValue;; 45 class StringRef;; 46}; 47 ; 48namespace clang {; 49 class CXXRecordDecl;; 50 class Decl;; 51 class DeclContext;; 52 class EnumDecl;; 53 class FunctionDecl;; 54 class IdentifierIterator;; 55 class NamedDecl;; 56 class NamespaceDecl;; 57 class TagDecl;; 58 class Type;; 59 class QualType;; 60}; 61namespace cling {; 62 class Interpreter;; 63 class MetaProcessor;; 64 class Transaction;; 65 class Value;; 66}; 67 ; 68class TClingCallbacks;; 69class TEnv;; 70class TFile;; 71class THashTable;; 72class TInterpreterValue;; 73class TMethod;; 74class TObjArray;; 75class TListOfDataMembers;; 76class TListOfFunctions;; 77class TListOfFunctionTemplates;; 78class TListOfEnums;; 79 ; 80namespace ROOT {; 81 namespace TMetaUtils {; 82 class TNormalizedCtxt;; 83 class TClingLookupHelper;; 84 }; 85}; 86 ; 87extern ""C"" {; 88 void TCling__UpdateListsOnCommitted(const cling::Transaction&,; 89 cling::Interpreter*);; 90 void TCling__UpdateListsOnUnloaded(const cling::Transaction&);; 91 void TCling__InvalidateGlobal(const clang::Decl*);; 92 void TCling__TransactionRollback(const cling::Transaction&);; 93 TObject* TCling__GetObjectAddress(const char *Name, void *&LookupCtx);; 94 const clang::Decl* TCling__GetObjectDecl(TObject *obj);; 95 void TCling__LibraryLoaded(const void* dyLibHandle,; 96 const char* canonicalName);; 97 void TCling__LibraryUnloaded(const void* dyLibHandle,; 98 const char* canonicalName);; 99 void TCling__RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent);; 100}; 101 ; 102class TCling final : public TInterpreter {; 103private: // Static Data Members; 104 ; 105 static void* fgSetOfSpecials; // set of TObjects used in CINT variables; 106 ; 107private: // Data Members; 108 ; 109 Int_t fExitCode; // Value passed to exit() in interpreter.",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
Performance,load,loaded,"t cling::Transaction&);; 93 TObject* TCling__GetObjectAddress(const char *Name, void *&LookupCtx);; 94 const clang::Decl* TCling__GetObjectDecl(TObject *obj);; 95 void TCling__LibraryLoaded(const void* dyLibHandle,; 96 const char* canonicalName);; 97 void TCling__LibraryUnloaded(const void* dyLibHandle,; 98 const char* canonicalName);; 99 void TCling__RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent);; 100}; 101 ; 102class TCling final : public TInterpreter {; 103private: // Static Data Members; 104 ; 105 static void* fgSetOfSpecials; // set of TObjects used in CINT variables; 106 ; 107private: // Data Members; 108 ; 109 Int_t fExitCode; // Value passed to exit() in interpreter.; 110 char fPrompt[64]; // Command line prompt string.; 111 //cling::DictPosition fDictPos; // dictionary context after initialization is complete.; 112 //cling::DictPosition fDictPosGlobals; // dictionary context after ResetGlobals().; 113 TString fSharedLibs; // Shared libraries loaded by G__loadfile().; 114 Int_t fGlobalsListSerial;// Last time we refreshed the ROOT list of globals.; 115 TString fIncludePath; // Interpreter include path.; 116 TString fRootmapLoadPath; // Dynamic load path for rootmap files.; 117 TEnv* fMapfile; // Association of classes to libraries.; 118 std::vector<std::string> fAutoLoadLibStorage; // A storage to return a const char* from GetClassSharedLibsForModule.; 119 std::map<size_t,std::vector<const char*>> fClassesHeadersMap; // Map of classes hashes and headers associated; 120 std::map<const cling::Transaction*,size_t> fTransactionHeadersMap; // Map which transaction contains which autoparse.; 121 std::set<size_t> fLookedUpClasses; // Set of classes for which headers were looked up already; 122 std::set<size_t> fPayloads; // Set of payloads; 123 std::set<const char*> fParsedPayloadsAddresses; // Set of payloads which were parsed; 124 std::hash<std::string> fStringHashFunction; // A simple hashing function; 125 std::unord",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
Safety,avoid,avoid,"ling::Transaction*,size_t> fTransactionHeadersMap; // Map which transaction contains which autoparse.; 121 std::set<size_t> fLookedUpClasses; // Set of classes for which headers were looked up already; 122 std::set<size_t> fPayloads; // Set of payloads; 123 std::set<const char*> fParsedPayloadsAddresses; // Set of payloads which were parsed; 124 std::hash<std::string> fStringHashFunction; // A simple hashing function; 125 std::unordered_set<const clang::NamespaceDecl*> fNSFromRootmaps; // Collection of namespaces fwd declared in the rootmaps; 126 TObjArray* fRootmapFiles; // Loaded rootmap files.; 127 Bool_t fLockProcessLine; // True if ProcessLine should lock gInterpreterMutex.; 128 Bool_t fCxxModulesEnabled;// True if C++ modules was enabled; 129 ; 130 std::unique_ptr<cling::Interpreter> fInterpreter; // The interpreter.; 131 std::unique_ptr<cling::MetaProcessor> fMetaProcessor; // The metaprocessor.; 132 ; 133 std::vector<cling::Value> *fTemporaries; // Stack of temporaries; 134 ROOT::TMetaUtils::TNormalizedCtxt *fNormalizedCtxt; // Which typedef to avoid stripping.; 135 ROOT::TMetaUtils::TClingLookupHelper *fLookupHelper; // lookup helper used by TClassEdit; 136 ; 137 void* fPrevLoadedDynLibInfo; // Internal info to mark the last loaded libray.; 138 std::vector<void*> fRegisterModuleDyLibs; // Stack of libraries currently running RegisterModule; 139 TClingCallbacks* fClingCallbacks; // cling::Interpreter owns it.; 140 struct CharPtrCmp_t {; 141 bool operator()(const char* a, const char *b) const {; 142 return strcmp(a, b) < 0;; 143 }; 144 };; 145 std::set<TClass*> fModTClasses;; 146 std::vector<std::pair<TClass*,DictFuncPtr_t> > fClassesToUpdate;; 147 void* fAutoLoadCallBack;; 148 ULong64_t fTransactionCount; // Cling counter for commited or unloaded transactions which changed the AST.; 149 std::vector<const char*> fCurExecutingMacros;; 150 ; 151 typedef void* SpecialObjectLookupCtx_t;; 152 typedef std::unordered_map<std::string, TObject*> SpecialObjectMap_t;; 1",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
Security,hash,hashes," ; 105 static void* fgSetOfSpecials; // set of TObjects used in CINT variables; 106 ; 107private: // Data Members; 108 ; 109 Int_t fExitCode; // Value passed to exit() in interpreter.; 110 char fPrompt[64]; // Command line prompt string.; 111 //cling::DictPosition fDictPos; // dictionary context after initialization is complete.; 112 //cling::DictPosition fDictPosGlobals; // dictionary context after ResetGlobals().; 113 TString fSharedLibs; // Shared libraries loaded by G__loadfile().; 114 Int_t fGlobalsListSerial;// Last time we refreshed the ROOT list of globals.; 115 TString fIncludePath; // Interpreter include path.; 116 TString fRootmapLoadPath; // Dynamic load path for rootmap files.; 117 TEnv* fMapfile; // Association of classes to libraries.; 118 std::vector<std::string> fAutoLoadLibStorage; // A storage to return a const char* from GetClassSharedLibsForModule.; 119 std::map<size_t,std::vector<const char*>> fClassesHeadersMap; // Map of classes hashes and headers associated; 120 std::map<const cling::Transaction*,size_t> fTransactionHeadersMap; // Map which transaction contains which autoparse.; 121 std::set<size_t> fLookedUpClasses; // Set of classes for which headers were looked up already; 122 std::set<size_t> fPayloads; // Set of payloads; 123 std::set<const char*> fParsedPayloadsAddresses; // Set of payloads which were parsed; 124 std::hash<std::string> fStringHashFunction; // A simple hashing function; 125 std::unordered_set<const clang::NamespaceDecl*> fNSFromRootmaps; // Collection of namespaces fwd declared in the rootmaps; 126 TObjArray* fRootmapFiles; // Loaded rootmap files.; 127 Bool_t fLockProcessLine; // True if ProcessLine should lock gInterpreterMutex.; 128 Bool_t fCxxModulesEnabled;// True if C++ modules was enabled; 129 ; 130 std::unique_ptr<cling::Interpreter> fInterpreter; // The interpreter.; 131 std::unique_ptr<cling::MetaProcessor> fMetaProcessor; // The metaprocessor.; 132 ; 133 std::vector<cling::Value> *fTemporaries; // Stack of te",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
Testability,test,testio,"erty(ClassInfo_t* info) const final;; 414 void ClassInfo_Delete(ClassInfo_t* info) const final;; 415 void ClassInfo_Delete(ClassInfo_t* info, void* arena) const final;; 416 void ClassInfo_DeleteArray(ClassInfo_t* info, void* arena, bool dtorOnly) const final;; 417 void ClassInfo_Destruct(ClassInfo_t* info, void* arena) const final;; 418 ClassInfo_t* ClassInfo_Factory(Bool_t all = kTRUE) const final;; 419 ClassInfo_t* ClassInfo_Factory(ClassInfo_t* cl) const final;; 420 ClassInfo_t* ClassInfo_Factory(const char* name) const final;; 421 ClassInfo_t* ClassInfo_Factory(DeclId_t declid) const final;; 422 Longptr_t ClassInfo_GetBaseOffset(ClassInfo_t* fromDerived, ClassInfo_t* toBase, void * address, bool isDerivedObject) const final;; 423 int ClassInfo_GetMethodNArg(ClassInfo_t* info, const char* method, const char* proto, Bool_t objectIsConst = false, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const final;; 424 bool ClassInfo_HasDefaultConstructor(ClassInfo_t* info, Bool_t testio = kFALSE) const final;; 425 bool ClassInfo_HasMethod(ClassInfo_t* info, const char* name) const final;; 426 void ClassInfo_Init(ClassInfo_t* info, const char* funcname) const final;; 427 void ClassInfo_Init(ClassInfo_t* info, int tagnum) const final;; 428 bool ClassInfo_IsBase(ClassInfo_t* info, const char* name) const final;; 429 bool ClassInfo_IsEnum(const char* name) const final;; 430 bool ClassInfo_IsScopedEnum(ClassInfo_t* info) const final;; 431 EDataType ClassInfo_GetUnderlyingType(ClassInfo_t* info) const final;; 432 bool ClassInfo_IsLoaded(ClassInfo_t* info) const final;; 433 bool ClassInfo_IsValid(ClassInfo_t* info) const final;; 434 bool ClassInfo_IsValidMethod(ClassInfo_t* info, const char* method, const char* proto, Longptr_t* offset, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) const final;; 435 bool ClassInfo_IsValidMethod(ClassInfo_t* info, const char* method, const char* proto, Bool_t objectIsConst, Longptr_t* offset, ROOT::EFunctionMatchMode /* mod",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
Usability,simpl,simple,"als; // dictionary context after ResetGlobals().; 113 TString fSharedLibs; // Shared libraries loaded by G__loadfile().; 114 Int_t fGlobalsListSerial;// Last time we refreshed the ROOT list of globals.; 115 TString fIncludePath; // Interpreter include path.; 116 TString fRootmapLoadPath; // Dynamic load path for rootmap files.; 117 TEnv* fMapfile; // Association of classes to libraries.; 118 std::vector<std::string> fAutoLoadLibStorage; // A storage to return a const char* from GetClassSharedLibsForModule.; 119 std::map<size_t,std::vector<const char*>> fClassesHeadersMap; // Map of classes hashes and headers associated; 120 std::map<const cling::Transaction*,size_t> fTransactionHeadersMap; // Map which transaction contains which autoparse.; 121 std::set<size_t> fLookedUpClasses; // Set of classes for which headers were looked up already; 122 std::set<size_t> fPayloads; // Set of payloads; 123 std::set<const char*> fParsedPayloadsAddresses; // Set of payloads which were parsed; 124 std::hash<std::string> fStringHashFunction; // A simple hashing function; 125 std::unordered_set<const clang::NamespaceDecl*> fNSFromRootmaps; // Collection of namespaces fwd declared in the rootmaps; 126 TObjArray* fRootmapFiles; // Loaded rootmap files.; 127 Bool_t fLockProcessLine; // True if ProcessLine should lock gInterpreterMutex.; 128 Bool_t fCxxModulesEnabled;// True if C++ modules was enabled; 129 ; 130 std::unique_ptr<cling::Interpreter> fInterpreter; // The interpreter.; 131 std::unique_ptr<cling::MetaProcessor> fMetaProcessor; // The metaprocessor.; 132 ; 133 std::vector<cling::Value> *fTemporaries; // Stack of temporaries; 134 ROOT::TMetaUtils::TNormalizedCtxt *fNormalizedCtxt; // Which typedef to avoid stripping.; 135 ROOT::TMetaUtils::TClingLookupHelper *fLookupHelper; // lookup helper used by TClassEdit; 136 ; 137 void* fPrevLoadedDynLibInfo; // Internal info to mark the last loaded libray.; 138 std::vector<void*> fRegisterModuleDyLibs; // Stack of libraries currently runn",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
Testability,test,tests,". ROOT: tutorials/tree/tcl.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tcl.C File ReferenceTutorials » Tree tutorials. Detailed Description; How to write a TClonesArray to a TTree ; The following tests can be run Interactive tests Root > .x tcl.C //no-split interpreted; Root > .x tcl.C(1) //split interpreted; Root > .x tcl.C++ //no-split compiled; Root > .x tcl.C++(1) //split compiled; Batch tests: same as above but with no graphics root -b -q tcl.C; root -b -q tcl.C++; root -b -q ""tcl.C(1)""; root -b -q ""tcl.C++(1)""; ; #include ""TFile.h""; #include ""TClonesArray.h""; #include ""TH2.h""; #include ""TLine.h""; #include ""TTree.h""; #include ""TBenchmark.h""; #include ""TRandom.h""; ; void tclwrite(Int_t split); {; // Generate a Tree with a TClonesArray; // The array can be split or not; TFile f(""tcl.root"",""recreate"");; f.SetCompressionLevel(1); //try level 2 also; TTree T(""T"",""test tcl"");; TClonesArray *arr = new TClonesArray(""TLine"");; TClonesArray &ar = *arr;; T.Branch(""tcl"",&arr,256000,split);; //By default a TClonesArray is created with its BypassStreamer bit set.; //However, because TLine has a custom Streamer, this bit was reset; //by TTree::Branch above. We set again this bit because the current; //version of TLine uses the automatic Streamer.; //BypassingStreamer saves space and time.; arr->BypassStreamer();; for (Int_t ev=0;ev<10000;ev++) {; ar.Clear();; Int_t nlines = Int_t(gRandom->Gaus(50,10));; if(nlines < 0) nlines = 1;; for (Int_t i=0;i<nlines;i++) {; Float_t x1 = gRandom->Rndm();; Float_t y1 = gRandom->Rndm();; Float_t x2 = gRandom->Rndm();; Float_t y2 = gRandom->Rndm();; new(ar[i]) TLine(x1,y1,x2,y2);; }; T.Fill();; }; T.Print();; T.Write();; }; ; void tclread(); {; // read file generated by tclwrite; // loop on all entries.; // histogram center of lines; TFile *f = new TFile(""tcl.root"");; TTree *T = (TTree*)f->Get(""T"");; TH2F *h2 = new TH2F(""h2"",""center of lines"",40,0,1,40,0,1);; ; TClonesArray *arr = new TCl",MatchSource.WIKI,doc/master/tcl_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tcl_8C.html
Usability,simpl,simple,"n THbookFile.cxx:91; TLine.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TTree.h; TBenchmark::Startvirtual void Start(const char *name)Starts Benchmark with the specified name.Definition TBenchmark.cxx:172; TBenchmark::Showvirtual void Show(const char *name)Stops Benchmark name and Prints results.Definition TBenchmark.cxx:155; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::BypassStreamervoid BypassStreamer(Bool_t bypass=kTRUE)When the kBypassStreamer bit is set, the automatically generated Streamer can call directly TClass::W...Definition TClonesArray.cxx:321; TClonesArray::Clearvoid Clear(Option_t *option="""") overrideClear the clones array.Definition TClonesArray.cxx:420; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::GetY1Double_t GetY1() constDefinition TLine.h:52; TLine::GetX2Double_t GetX2() constDefinition TLine.h:51; TLine::GetX1Double_t GetX1() constDefinition TLine.h:50; TLine::GetY2Double_t GetY2() constDefinition TLine.h:53; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Math::Chebyshev::Tdouble T(double x)Definition ChebyshevPol.h:34; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Pa",MatchSource.WIKI,doc/master/tcl_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tcl_8C.html
Availability,error,error,"ont_t;; 863 using typename InfoBase_t::Iter_t;; 864 using typename InfoBase_t::Value_t;; 865 using typename InfoBase_t::Env_t;; 866 using typename InfoBase_t::PEnv_t;; 867 using typename InfoBase_t::PCont_t;; 868 using typename InfoBase_t::PValue_t;; 869 ; 870 static void resize(void*,size_t) {; 871 }; 872 static void* feed(void *from, void *to, size_t size) {; 873 PCont_t c = PCont_t(to);; 874 PValue_t m = PValue_t(from);; 875 for (size_t i=0; i<size; ++i, ++m); 876 c->set(i,*m);; 877 return nullptr;; 878 }; 879 static int value_offset() {; 880 return 0;; 881 }; 882 };; 883 ; 884} // namespace Detail; 885 ; 886// For (reasonable) backward compatibility:; 887using namespace Detail;; 888} // namespace ROOT; 889 ; 890#endif; c#define c(i)Definition RSha256.hxx:101; e#define e(i)Definition RSha256.hxx:103; RtypesCore.h; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; TYPENAME#define TYPENAMEDefinition TCollectionProxyInfo.h:36; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; destOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t destDefinition TGWin32VirtualXProxy.cxx:164; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; ROOT::Detail::TCollectionProxyInfoDefinition TCollectionProxyInfo.h:57; ROOT::Detail::TCollectionProxyInfo::fCopyIteratorvoid *(* fCopyIterator)(void *dest, const void *source)Definition TCollectionProxyInfo.h:520; ROOT::Detail::TCollectionProxyInfo::fConstructFuncvoid *(* fConstructFunc)(void *,",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
Deployability,update,update,"_t c = PCont_t(coll);; 141 if (c->empty()) {; 142 *begin_arena = nullptr;; 143 *end_arena = nullptr;; 144 return;; 145 }; 146 *begin_arena = &(*c->begin());; 147#ifdef R__VISUAL_CPLUSPLUS; 148 *end_arena = &(*(c->end()-1)) + 1; // On windows we can not dererence the end iterator at all.; 149#else; 150 // coverity[past_the_end] Safe on other platforms; 151 *end_arena = &(*c->end());; 152#endif; 153 }; 154 static void* copy(void *dest, const void *source) {; 155 *(void**)dest = *(void**)(const_cast<void*>(source));; 156 return dest;; 157 }; 158 static void* next(void * /* iter_loc */, const void * /* end_loc */) {; 159 // Should not be used.; 160 // In the case of vector, so that the I/O can perform better,; 161 // the begin_arena and the end_arena are *not* set to the; 162 // address of any iterator rather they are set to the value of; 163 // the beginning (and end) address of the vector's data.; 164 // Hence this routine (which takes the value of fBegin) can; 165 // *not* update where its points to (which in the case of vector; 166 // would require update the value of fBegin).; 167 R__ASSERT(0 && ""Intentionally not implemented, do not use."");; 168 return nullptr;; 169 }; 170 static void destruct1(void * /* iter_ptr */) {; 171 // Nothing to do; 172 }; 173 static void destruct2(void * /* begin_ptr */, void * /* end_ptr */) {; 174 // Nothing to do; 175 }; 176 };; 177 ; 178 template <typename Cont_t> struct Iterators<Cont_t, /* large= */ true > {; 179 typedef Cont_t *PCont_t;; 180 typedef typename Cont_t::iterator iterator;; 181 ; 182 static void create(void *coll, void **begin_arena, void **end_arena, TVirtualCollectionProxy*) {; 183 PCont_t c = PCont_t(coll);; 184 *begin_arena = new iterator(c->begin());; 185 *end_arena = new iterator(c->end());; 186 }; 187 static void* copy(void * /*dest_arena*/, const void *source_ptr) {; 188 iterator *source = (iterator *)(source_ptr);; 189 void *iter = new iterator(*source);; 190 return iter;; 191 }; 192 static void* next(void *it",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
Energy Efficiency,allocate,allocated,"_t(0x1000))->second)) - ((char*)PValue_t(0x1000));; 494 }; 495 };; 496 ; 497 ; 498 public:; 499 const std::type_info &fInfo;; 500 size_t fIterSize;; 501 size_t fValueDiff;; 502 int fValueOffset;; 503 void* (*fSizeFunc)(void*);; 504 void (*fResizeFunc)(void*,size_t);; 505 void* (*fClearFunc)(void*);; 506 void* (*fFirstFunc)(void*);; 507 void* (*fNextFunc)(void*);; 508 void* (*fConstructFunc)(void*,size_t);; 509 void (*fDestructFunc)(void*,size_t);; 510 void* (*fFeedFunc)(void*,void*,size_t);; 511 void* (*fCollectFunc)(void*,void*);; 512 void* (*fCreateEnv)();; 513 ; 514 // Set of function of direct iteration of the collections.; 515 void (*fCreateIterators)(void *collection, void **begin_arena, void **end_arena, TVirtualCollectionProxy *proxy);; 516 // begin_arena and end_arena should contain the location of memory arena of size fgIteratorSize.; 517 // If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); 518 // Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena.; 519 ; 520 void* (*fCopyIterator)(void *dest, const void *source);; 521 // Copy the iterator source, into dest. dest should contain should contain the location of memory arena of size fgIteratorSize.; 522 // If the collection iterator are of that size or less, the iterator will be constructed in place in this location (new with placement); 523 // Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest.; 524 ; 525 void* (*fNext)(void *iter, const void *end);; 526 // iter and end should be pointer to respectively an iterator to be incremented and the result of colleciton.end(); 527 // 'Next' will increment the iterator 'iter' and return 0 if the iterator reached the end.; 528 // If the end is not reached, 'Next' will return the address of the content unless the collection contains point",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
Integrability,rout,routine,"_t c = PCont_t(coll);; 141 if (c->empty()) {; 142 *begin_arena = nullptr;; 143 *end_arena = nullptr;; 144 return;; 145 }; 146 *begin_arena = &(*c->begin());; 147#ifdef R__VISUAL_CPLUSPLUS; 148 *end_arena = &(*(c->end()-1)) + 1; // On windows we can not dererence the end iterator at all.; 149#else; 150 // coverity[past_the_end] Safe on other platforms; 151 *end_arena = &(*c->end());; 152#endif; 153 }; 154 static void* copy(void *dest, const void *source) {; 155 *(void**)dest = *(void**)(const_cast<void*>(source));; 156 return dest;; 157 }; 158 static void* next(void * /* iter_loc */, const void * /* end_loc */) {; 159 // Should not be used.; 160 // In the case of vector, so that the I/O can perform better,; 161 // the begin_arena and the end_arena are *not* set to the; 162 // address of any iterator rather they are set to the value of; 163 // the beginning (and end) address of the vector's data.; 164 // Hence this routine (which takes the value of fBegin) can; 165 // *not* update where its points to (which in the case of vector; 166 // would require update the value of fBegin).; 167 R__ASSERT(0 && ""Intentionally not implemented, do not use."");; 168 return nullptr;; 169 }; 170 static void destruct1(void * /* iter_ptr */) {; 171 // Nothing to do; 172 }; 173 static void destruct2(void * /* begin_ptr */, void * /* end_ptr */) {; 174 // Nothing to do; 175 }; 176 };; 177 ; 178 template <typename Cont_t> struct Iterators<Cont_t, /* large= */ true > {; 179 typedef Cont_t *PCont_t;; 180 typedef typename Cont_t::iterator iterator;; 181 ; 182 static void create(void *coll, void **begin_arena, void **end_arena, TVirtualCollectionProxy*) {; 183 PCont_t c = PCont_t(coll);; 184 *begin_arena = new iterator(c->begin());; 185 *end_arena = new iterator(c->end());; 186 }; 187 static void* copy(void * /*dest_arena*/, const void *source_ptr) {; 188 iterator *source = (iterator *)(source_ptr);; 189 void *iter = new iterator(*source);; 190 return iter;; 191 }; 192 static void* next(void *it",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
Performance,perform,perform,"ef std::vector<T> Cont_t;; 136 typedef Cont_t *PCont_t;; 137 typedef typename Cont_t::iterator iterator;; 138 ; 139 static void create(void *coll, void **begin_arena, void **end_arena, TVirtualCollectionProxy*) {; 140 PCont_t c = PCont_t(coll);; 141 if (c->empty()) {; 142 *begin_arena = nullptr;; 143 *end_arena = nullptr;; 144 return;; 145 }; 146 *begin_arena = &(*c->begin());; 147#ifdef R__VISUAL_CPLUSPLUS; 148 *end_arena = &(*(c->end()-1)) + 1; // On windows we can not dererence the end iterator at all.; 149#else; 150 // coverity[past_the_end] Safe on other platforms; 151 *end_arena = &(*c->end());; 152#endif; 153 }; 154 static void* copy(void *dest, const void *source) {; 155 *(void**)dest = *(void**)(const_cast<void*>(source));; 156 return dest;; 157 }; 158 static void* next(void * /* iter_loc */, const void * /* end_loc */) {; 159 // Should not be used.; 160 // In the case of vector, so that the I/O can perform better,; 161 // the begin_arena and the end_arena are *not* set to the; 162 // address of any iterator rather they are set to the value of; 163 // the beginning (and end) address of the vector's data.; 164 // Hence this routine (which takes the value of fBegin) can; 165 // *not* update where its points to (which in the case of vector; 166 // would require update the value of fBegin).; 167 R__ASSERT(0 && ""Intentionally not implemented, do not use."");; 168 return nullptr;; 169 }; 170 static void destruct1(void * /* iter_ptr */) {; 171 // Nothing to do; 172 }; 173 static void destruct2(void * /* begin_ptr */, void * /* end_ptr */) {; 174 // Nothing to do; 175 }; 176 };; 177 ; 178 template <typename Cont_t> struct Iterators<Cont_t, /* large= */ true > {; 179 typedef Cont_t *PCont_t;; 180 typedef typename Cont_t::iterator iterator;; 181 ; 182 static void create(void *coll, void **begin_arena, void **end_arena, TVirtualCollectionProxy*) {; 183 PCont_t c = PCont_t(coll);; 184 *begin_arena = new iterator(c->begin());; 185 *end_arena = new iterator(c->end());; 18",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
Safety,avoid,avoid,"t_t, value_ptr*> {; 81 static void* get(typename Cont_t::iterator &iter) {; 82 return (void*)(*iter);; 83 }; 84 };; 85 ; 86 /** @class ROOT::Detail::TCollectionProxyInfo::Iterators; 87 *; 88 * Small helper to implement the function to create,access and destroy; 89 * iterators.; 90 *; 91 **/; 92 ; 93 template <typename Cont_t, bool large = false>; 94 struct Iterators {; 95 typedef Cont_t *PCont_t;; 96 typedef typename Cont_t::iterator iterator;; 97 ; 98 static void create(void *coll, void **begin_arena, void **end_arena, TVirtualCollectionProxy*) {; 99 PCont_t c = PCont_t(coll);; 100 new (*begin_arena) iterator(c->begin());; 101 new (*end_arena) iterator(c->end());; 102 }; 103 static void* copy(void *dest_arena, const void *source_ptr) {; 104 iterator *source = (iterator *)(source_ptr);; 105 new (dest_arena) iterator(*source);; 106 return dest_arena;; 107 }; 108 static void* next(void *iter_loc, const void *end_loc) {; 109 iterator *end = (iterator *)(end_loc);; 110 iterator *iter = (iterator *)(iter_loc);; 111 if (*iter != *end) {; 112 void *result = IteratorValue<Cont_t, typename Cont_t::value_type>::get(*iter);; 113 ++(*iter);; 114 return result;; 115 }; 116 return nullptr;; 117 }; 118 static void destruct1(void *iter_ptr) {; 119 iterator *start = (iterator *)(iter_ptr);; 120 start->~iterator();; 121 }; 122 static void destruct2(void *begin_ptr, void *end_ptr) {; 123 iterator *start = (iterator *)(begin_ptr);; 124 iterator *end = (iterator *)(end_ptr);; 125 start->~iterator();; 126 end->~iterator();; 127 }; 128 };; 129 ; 130 // For Vector we take an extra short cut to avoid derefencing; 131 // the iterator all the time and redefine the 'address' of the; 132 // iterator as the iterator itself. This requires special handling; 133 // in the looper (see TStreamerInfoAction) but is much faster.; 134 template <typename T> struct Iterators<std::vector<T>, false> {; 135 typedef std::vector<T> Cont_t;; 136 typedef Cont_t *PCont_t;; 137 typedef typename Cont_t::iterator ite",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
Security,access,access,"alent; 50 // of 'template <int N> struct TCollectionProxyInfo::Type<std::bitset<N> >' which; 51 // is not effective in C++ (as of gcc 4.3.3).; 52};; 53}; 54 ; 55namespace Detail {; 56 ; 57 class TCollectionProxyInfo {; 58 // This class is a place holder for the information needed; 59 // to create the proper Collection Proxy.; 60 // This is similar to Reflex's CollFuncTable.; 61 ; 62 public:; 63 ; 64 // Same value as TVirtualCollectionProxy.; 65 static const UInt_t fgIteratorArenaSize = 16; // greater than sizeof(void*) + sizeof(UInt_t); 66 ; 67 /** @class ROOT::Detail::TCollectionProxyInfo::IteratorValue; 68 *; 69 * Small helper to encapsulate whether to return the value; 70 * pointed to by the iterator or its address.; 71 *; 72 **/; 73 ; 74 template <typename Cont_t, typename value> struct IteratorValue {; 75 static void* get(typename Cont_t::iterator &iter) {; 76 return (void*)&(*iter);; 77 }; 78 };; 79 ; 80 template <typename Cont_t, typename value_ptr> struct IteratorValue<Cont_t, value_ptr*> {; 81 static void* get(typename Cont_t::iterator &iter) {; 82 return (void*)(*iter);; 83 }; 84 };; 85 ; 86 /** @class ROOT::Detail::TCollectionProxyInfo::Iterators; 87 *; 88 * Small helper to implement the function to create,access and destroy; 89 * iterators.; 90 *; 91 **/; 92 ; 93 template <typename Cont_t, bool large = false>; 94 struct Iterators {; 95 typedef Cont_t *PCont_t;; 96 typedef typename Cont_t::iterator iterator;; 97 ; 98 static void create(void *coll, void **begin_arena, void **end_arena, TVirtualCollectionProxy*) {; 99 PCont_t c = PCont_t(coll);; 100 new (*begin_arena) iterator(c->begin());; 101 new (*end_arena) iterator(c->end());; 102 }; 103 static void* copy(void *dest_arena, const void *source_ptr) {; 104 iterator *source = (iterator *)(source_ptr);; 105 new (dest_arena) iterator(*source);; 106 return dest_arena;; 107 }; 108 static void* next(void *iter_loc, const void *end_loc) {; 109 iterator *end = (iterator *)(end_loc);; 110 iterator *iter = (iterato",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
Testability,test,test,"vector<bool> instead"");; 751 return {};; 752 }; 753 };; 754 ; 755 template <typename Bitset_t> struct TCollectionProxyInfo::Type<Internal::TStdBitsetHelper<Bitset_t> > : public TCollectionProxyInfo::Address<const Bool_t &>; 756 {; 757 typedef Bitset_t Cont_t;; 758 typedef std::pair<size_t,Bool_t> Iter_t;; 759 typedef Bool_t Value_t;; 760 typedef Environ<Iter_t> Env_t;; 761 typedef Env_t *PEnv_t;; 762 typedef Cont_t *PCont_t;; 763 typedef Value_t *PValue_t;; 764 ; 765 virtual ~Type() {}; 766 ; 767 static inline PCont_t object(void* ptr) {; 768 return PCont_t(PEnv_t(ptr)->fObject);; 769 }; 770 static void* size(void* env) {; 771 PEnv_t e = PEnv_t(env);; 772 e->fSize = PCont_t(e->fObject)->size();; 773 return &e->fSize;; 774 }; 775 static void* clear(void* env) {; 776 object(env)->reset();; 777 return nullptr;; 778 }; 779 static void* first(void* env) {; 780 PEnv_t e = PEnv_t(env);; 781 PCont_t c = PCont_t(e->fObject);; 782 e->fIterator.first = 0;; 783 e->fIterator.second = c->size() > 0 ? c->test(e->fIterator.first) : false ; // Iterator actually hold the value.; 784 e->fSize = c->size();; 785 return &(e->fIterator.second);; 786 }; 787 static void* next(void* env) {; 788 PEnv_t e = PEnv_t(env);; 789 PCont_t c = PCont_t(e->fObject);; 790 for (; e->fIdx > 0 && e->fIterator.first != c->size(); ++(e->fIterator.first), --e->fIdx){ }; 791 e->fIterator.second = (e->fIterator.first != c->size()) ? c->test(e->fIterator.first) : false;; 792 return &(e->fIterator.second);; 793 }; 794 static void* construct(void*,size_t) {; 795 // Nothing to construct.; 796 return nullptr;; 797 }; 798 static void* collect(void *coll, void *array) {; 799 PCont_t c = PCont_t(coll);; 800 PValue_t m = PValue_t(array); // 'start' is a buffer outside the container.; 801 for (size_t i=0; i != c->size(); ++i, ++m ); 802 *m = c->test(i);; 803 return nullptr;; 804 }; 805 static void destruct(void*,size_t) {; 806 // Nothing to destruct.; 807 }; 808 ; 809 //static const bool fgLargeIterator = sizeof(typename",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
Usability,clear,clear,"st<T,ALLOCATOR>& c) {return std::distance(c.begin(),c.end());}; 282 };; 283 ; 284 /** @class ROOT::Detail::TCollectionProxyInfo::Type; 285 *; 286 * Small helper to encapsulate basic data accesses for; 287 * all STL continers.; 288 *; 289 * @author M.Frank; 290 * @version 1.0; 291 * @date 10/10/2004; 292 */; 293 template <class T> struct Type; 294 : public Address<TYPENAME T::const_reference>; 295 {; 296 typedef T Cont_t;; 297 typedef typename T::iterator Iter_t;; 298 typedef typename T::value_type Value_t;; 299 typedef Environ<Iter_t> Env_t;; 300 typedef Env_t *PEnv_t;; 301 typedef Cont_t *PCont_t;; 302 typedef Value_t *PValue_t;; 303 ; 304 virtual ~Type() {}; 305 ; 306 static inline PCont_t object(void* ptr) {; 307 return PCont_t(PEnv_t(ptr)->fObject);; 308 }; 309 static void* size(void* env) {; 310 PEnv_t e = PEnv_t(env);; 311 e->fSize = SfinaeHelper::GetContainerSize(*PCont_t(e->fObject));; 312 return &e->fSize;; 313 }; 314 static void* clear(void* env) {; 315 object(env)->clear();; 316 return nullptr;; 317 }; 318 static void* first(void* env) {; 319 PEnv_t e = PEnv_t(env);; 320 PCont_t c = PCont_t(e->fObject);; 321#if 0; 322 // Assume iterators do not need destruction; 323 ::new(e->buff) Iter_t(c->begin());; 324#endif; 325 e->fIterator = c->begin();; 326 e->fSize = SfinaeHelper::GetContainerSize(*c);; 327 if ( 0 == e->fSize ) return e->fStart = nullptr;; 328 TYPENAME T::const_reference ref = *(e->iter());; 329 return e->fStart = Type<T>::address(ref);; 330 }; 331 static void* next(void* env) {; 332 PEnv_t e = PEnv_t(env);; 333 PCont_t c = PCont_t(e->fObject);; 334 for (; e->fIdx > 0 && e->iter() != c->end(); ++(e->iter()), --e->fIdx){ }; 335 // TODO: Need to find something for going backwards....; 336 if ( e->iter() == c->end() ) return nullptr;; 337 TYPENAME T::const_reference ref = *(e->iter());; 338 return Type<T>::address(ref);; 339 }; 340 static void* construct(void *what, size_t size) {; 341 PValue_t m = PValue_t(what);; 342 for (size_t i=0; i<size; ++i, +",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
Availability,error,error,";; 199 ; 200 while ((obj = next())); 201 Add(obj);; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Add all arguments to the collection. The list of objects must be; 206/// terminated by 0, e.g.: l.AddVector(o1, o2, o3, o4, 0);; 207 ; 208void TCollection::AddVector(TObject *va_(obj1), ...); 209{; 210 va_list ap;; 211 va_start(ap, va_(obj1));; 212 TObject *obj;; 213 ; 214 Add(va_(obj1));; 215 while ((obj = va_arg(ap, TObject *))); 216 Add(obj);; 217 va_end(ap);; 218}; 219 ; 220////////////////////////////////////////////////////////////////////////////////; 221/// Make sure all objects in this collection inherit from class cl.; 222 ; 223Bool_t TCollection::AssertClass(TClass *cl) const; 224{; 225 TObject *obj;; 226 TIter next(this);; 227 Bool_t error = kFALSE;; 228 ; 229 if (!cl) {; 230 Error(""AssertClass"", ""class == 0"");; 231 return kTRUE;; 232 }; 233 ; 234 for (int i = 0; (obj = next()); i++); 235 if (!obj->InheritsFrom(cl)) {; 236 Error(""AssertClass"", ""element %d is not an instance of class %s (%s)"",; 237 i, cl->GetName(), obj->ClassName());; 238 error = kTRUE;; 239 }; 240 return error;; 241}; 242 ; 243////////////////////////////////////////////////////////////////////////////////; 244/// Browse this collection (called by TBrowser).; 245/// If b=0, there is no Browse call TObject::Browse(0) instead.; 246/// This means TObject::Inspect() will be invoked indirectly; 247 ; 248void TCollection::Browse(TBrowser *b); 249{; 250 TIter next(this);; 251 TObject *obj;; 252 ; 253 if (b); 254 while ((obj = next())) b->Add(obj);; 255 else; 256 TObject::Browse(b);; 257}; 258 ; 259////////////////////////////////////////////////////////////////////////////////; 260/// Make a clone of an collection using the Streamer facility.; 261/// If newname is specified, this will be the name of the new collection.; 262 ; 263TObject *TCollection::Clone(const char *newname) const; 264{; 265 TCollection *new_collection = (TCollection*)TOb",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
Deployability,release,release,"*********************/; 11 ; 12/** \class TCollection; 13\ingroup Containers; 14Collection abstract base class. This class describes the base; 15protocol all collection classes have to implement. The ROOT; 16collection classes always store pointers to objects that inherit; 17from TObject. They never adopt the objects. Therefore, it is the; 18user's responsibility to take care of deleting the actual objects; 19once they are not needed anymore. In exceptional cases, when the; 20user is 100% sure nothing else is referencing the objects in the; 21collection, one can delete all objects and the collection at the; 22same time using the Delete() function.; 23 ; 24Collections can be iterated using an iterator object (see; 25TIterator). Depending on the concrete collection class there may be; 26some additional methods of iterating. See the respective classes.; 27 ; 28TCollection inherits from TObject since we want to be able to have; 29collections of collections.; 30 ; 31In a later release the collections may become templatized.; 32*/; 33 ; 34#include ""TCollection.h""; 35#include ""Varargs.h""; 36#include ""TBuffer.h""; 37#include ""TClass.h""; 38#include ""TROOT.h""; 39#include ""TBrowser.h""; 40#include ""TObjectTable.h""; 41#include ""TRegexp.h""; 42#include ""TPRegexp.h""; 43#include ""TVirtualMutex.h""; 44#include ""TError.h""; 45#include ""TSystem.h""; 46#include ""TObjArray.h""; 47#include <iostream>; 48#include <sstream>; 49 ; 50#include ""TSpinLockGuard.h""; 51 ; 52TVirtualMutex *gCollectionMutex = nullptr;; 53 ; 54TCollection *TCollection::fgCurrentCollection = nullptr;; 55TObjectTable *TCollection::fgGarbageCollection = nullptr;; 56Bool_t TCollection::fgEmptyingGarbage = kFALSE;; 57Int_t TCollection::fgGarbageStack = 0;; 58 ; 59ClassImp(TCollection);; 60ClassImp(TIter);; 61 ; 62#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 63 ; 64void TCollection::TErrorLock::ConflictReport(std::thread::id holder, const char *accesstype,; 65 const TCollection *collection, const char *function); 66{; 67 ; 68 auto l",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
Energy Efficiency,efficient,efficient,"d an object in this collection using its name. Requires a sequential; 309/// scan till the object has been found. Returns 0 if object with specified; 310/// name is not found.; 311 ; 312TObject *TCollection::FindObject(const char *name) const; 313{; 314 TIter next(this);; 315 TObject *obj;; 316 ; 317 while ((obj = next())); 318 if (!strcmp(name, obj->GetName())) return obj;; 319 return nullptr;; 320}; 321 ; 322////////////////////////////////////////////////////////////////////////////////; 323/// Find an object in this collection by name.; 324 ; 325TObject *TCollection::operator()(const char *name) const; 326{; 327 return FindObject(name);; 328}; 329 ; 330////////////////////////////////////////////////////////////////////////////////; 331/// Find an object in this collection using the object's IsEqual(); 332/// member function. Requires a sequential scan till the object has; 333/// been found. Returns 0 if object is not found.; 334/// Typically this function is overridden by a more efficient version; 335/// in concrete collection classes (e.g. THashTable).; 336 ; 337TObject *TCollection::FindObject(const TObject *obj) const; 338{; 339 TIter next(this);; 340 TObject *ob;; 341 ; 342 while ((ob = next())); 343 if (ob->IsEqual(obj)) return ob;; 344 return nullptr;; 345}; 346 ; 347////////////////////////////////////////////////////////////////////////////////; 348/// Return name of this collection.; 349/// if no name, return the collection class name.; 350 ; 351const char *TCollection::GetName() const; 352{; 353 if (fName.Length() > 0) return fName.Data();; 354 return ClassName();; 355}; 356 ; 357////////////////////////////////////////////////////////////////////////////////; 358/// Increase the collection's capacity by delta slots.; 359 ; 360Int_t TCollection::GrowBy(Int_t delta) const; 361{; 362 if (delta < 0) {; 363 Error(""GrowBy"", ""delta < 0"");; 364 delta = Capacity();; 365 }; 366 return Capacity() + TMath::Range(2, kMaxInt - Capacity(), delta);; 367}; 368 ; 369//",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
Integrability,depend,depending,"14 if (fgGarbageCollection && fgGarbageStack == 0 && fgEmptyingGarbage == kFALSE) {; 715 fgEmptyingGarbage = kTRUE;; 716 fgGarbageCollection->Delete();; 717 fgEmptyingGarbage = kFALSE;; 718 SafeDelete(fgGarbageCollection);; 719 }; 720}; 721 ; 722////////////////////////////////////////////////////////////////////////////////; 723/// Add to the list of things to be cleaned up.; 724 ; 725void TCollection::GarbageCollect(TObject *obj); 726{; 727 {; 728 R__LOCKGUARD2(gCollectionMutex);; 729 if (fgGarbageCollection) {; 730 if (!fgEmptyingGarbage) {; 731 fgGarbageCollection->Add(obj);; 732 return;; 733 }; 734 }; 735 }; 736 delete obj;; 737}; 738 ; 739////////////////////////////////////////////////////////////////////////////////; 740/// Set whether this collection is the owner (enable==true); 741/// of its content. If it is the owner of its contents,; 742/// these objects will be deleted whenever the collection itself; 743/// is deleted. The objects might also be deleted or destructed when Clear; 744/// is called (depending on the collection).; 745 ; 746void TCollection::SetOwner(Bool_t enable); 747{; 748 if (enable); 749 SetBit(kIsOwner);; 750 else; 751 ResetBit(kIsOwner);; 752}; 753 ; 754////////////////////////////////////////////////////////////////////////////////; 755/// Set this collection to use a RW lock upon access, making it thread safe.; 756/// Return the previous state.; 757///; 758/// Note: To test whether the usage is enabled do:; 759/// collection->TestBit(TCollection::kUseRWLock);; 760 ; 761bool TCollection::UseRWLock(Bool_t enable); 762{; 763 bool prev = TestBit(TCollection::kUseRWLock);; 764 if (enable) {; 765 SetBit(TCollection::kUseRWLock);; 766 } else {; 767 ResetBit(TCollection::kUseRWLock);; 768 }; 769 return prev;; 770}; 771 ; 772////////////////////////////////////////////////////////////////////////////////; 773/// Copy a TIter. This involves allocating a new TIterator of the right; 774/// sub class and assigning it with the original.; 775 ; 77",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
Modifiability,inherit,inherit,". ROOT: core/cont/src/TCollection.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TCollection.cxx. Go to the documentation of this file. 1// @(#)root/cont:$Id$; 2// Author: Fons Rademakers 13/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TCollection; 13\ingroup Containers; 14Collection abstract base class. This class describes the base; 15protocol all collection classes have to implement. The ROOT; 16collection classes always store pointers to objects that inherit; 17from TObject. They never adopt the objects. Therefore, it is the; 18user's responsibility to take care of deleting the actual objects; 19once they are not needed anymore. In exceptional cases, when the; 20user is 100% sure nothing else is referencing the objects in the; 21collection, one can delete all objects and the collection at the; 22same time using the Delete() function.; 23 ; 24Collections can be iterated using an iterator object (see; 25TIterator). Depending on the concrete collection class there may be; 26some additional methods of iterating. See the respective classes.; 27 ; 28TCollection inherits from TObject since we want to be able to have; 29collections of collections.; 30 ; 31In a later release the collections may become templatized.; 32*/; 33 ; 34#include ""TCollection.h""; 35#include ""Varargs.h""; 36#include ""TBuffer.h""; 37#include ""TClass.h""; 38#include ""TROOT.h""; 39#include ""TBrowser.h""; 40#include ""TObjectTable.h""; 41#include ""TRegexp.h""; 42#include ""TPRegexp.h""; 43#include ""TVirtualMutex.h""; 44#include ""TError.h""; 45#include ""TSystem.h""; 46#include ""TObjArray.h""; 47#include <iostream>; 48#",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
Performance,load,load,"5 // this id is now also in the holder variable; 116 if (holder == local) {; 117 // The holder was actually this thread, no problem there, we; 118 // allow re-entrancy.; 119 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" re-entered "" << fWriteCurrentRecurse << "" "" << collection; 120 // << "" lock:"" << this << std::endl;; 121 } else {; 122 ConflictReport(holder, ""WriteLock"", collection, function);; 123 }; 124 ++fWriteCurrentRecurse;; 125 }; 126}; 127 ; 128void TCollection::TErrorLock::Unlock(); 129{; 130 auto local = std::this_thread::get_id();; 131 auto none = std::thread::id();; 132 ; 133 --fWriteCurrentRecurse;; 134 if (fWriteCurrentRecurse == 0) {; 135 if (fWriteCurrent.compare_exchange_strong(local, none)) {; 136 // fWriteCurrent was local and is now none.; 137 ; 138 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" zero and cleaned : "" << std::dec << fWriteCurrentRecurse; 139 // << "" 0x"" << std::hex << fWriteCurrent.load() << "" lock:"" << this << std::endl;; 140 } else {; 141 // fWriteCurrent was not local, just live it as is.; 142 ; 143 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" zero but somebody else : "" << ""0x"" << std::hex <<; 144 // fWriteCurrent.load() << "" lock:"" << this << std::endl;; 145 }; 146 } else {; 147 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" still holding "" << ""0x"" << std::hex << fWriteCurrentRecurse; 148 // << "" lock:"" << this << std::endl;; 149 }; 150 ; 151 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" ended with : "" << std::dec << fWriteCurrentRecurse << "" 0x"" <<; 152 // std::hex << fWriteCurrent.load() << "" lock:"" << this << std::endl;; 153}; 154 ; 155void TCollection::TErrorLock::ReadLock(const TCollection *collection, const char *function); 156{; 157 auto local = std::this_thread::get_id();; 158 ; 159 {; 160 ROOT::Internal::TSpinLockGuard guard(fSpinLockFlag);; 161 fReadSet.insert(local); // this is not thread safe ...; 162 }; 163 ++fReadCurrentRecurse;; 164 ; 165 if (fWriteCurrentRecurse) {; 166 auto",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
Safety,safe,safe,"curse; 139 // << "" 0x"" << std::hex << fWriteCurrent.load() << "" lock:"" << this << std::endl;; 140 } else {; 141 // fWriteCurrent was not local, just live it as is.; 142 ; 143 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" zero but somebody else : "" << ""0x"" << std::hex <<; 144 // fWriteCurrent.load() << "" lock:"" << this << std::endl;; 145 }; 146 } else {; 147 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" still holding "" << ""0x"" << std::hex << fWriteCurrentRecurse; 148 // << "" lock:"" << this << std::endl;; 149 }; 150 ; 151 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" ended with : "" << std::dec << fWriteCurrentRecurse << "" 0x"" <<; 152 // std::hex << fWriteCurrent.load() << "" lock:"" << this << std::endl;; 153}; 154 ; 155void TCollection::TErrorLock::ReadLock(const TCollection *collection, const char *function); 156{; 157 auto local = std::this_thread::get_id();; 158 ; 159 {; 160 ROOT::Internal::TSpinLockGuard guard(fSpinLockFlag);; 161 fReadSet.insert(local); // this is not thread safe ...; 162 }; 163 ++fReadCurrentRecurse;; 164 ; 165 if (fWriteCurrentRecurse) {; 166 auto holder = fWriteCurrent.load();; 167 if (holder != local) ConflictReport(holder, ""ReadLock with WriteLock taken"", collection, function);; 168 }; 169}; 170 ; 171void TCollection::TErrorLock::ReadUnlock(); 172{; 173 auto local = std::this_thread::get_id();; 174 {; 175 ROOT::Internal::TSpinLockGuard guard(fSpinLockFlag);; 176 fReadSet.erase(local); // this is not thread safe ...; 177 }; 178 --fReadCurrentRecurse;; 179}; 180 ; 181#endif // R__CHECK_COLLECTION_MULTI_ACCESS; 182 ; 183////////////////////////////////////////////////////////////////////////////////; 184/// TNamed destructor.; 185 ; 186TCollection::~TCollection(); 187{; 188 // Required since we overload TObject::Hash.; 189 ROOT::CallRecursiveRemoveIfNeeded(*this);; 190}; 191 ; 192////////////////////////////////////////////////////////////////////////////////; 193/// Add all objects from collection col to this collection.;",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
Security,access,accesstype,"e; 29collections of collections.; 30 ; 31In a later release the collections may become templatized.; 32*/; 33 ; 34#include ""TCollection.h""; 35#include ""Varargs.h""; 36#include ""TBuffer.h""; 37#include ""TClass.h""; 38#include ""TROOT.h""; 39#include ""TBrowser.h""; 40#include ""TObjectTable.h""; 41#include ""TRegexp.h""; 42#include ""TPRegexp.h""; 43#include ""TVirtualMutex.h""; 44#include ""TError.h""; 45#include ""TSystem.h""; 46#include ""TObjArray.h""; 47#include <iostream>; 48#include <sstream>; 49 ; 50#include ""TSpinLockGuard.h""; 51 ; 52TVirtualMutex *gCollectionMutex = nullptr;; 53 ; 54TCollection *TCollection::fgCurrentCollection = nullptr;; 55TObjectTable *TCollection::fgGarbageCollection = nullptr;; 56Bool_t TCollection::fgEmptyingGarbage = kFALSE;; 57Int_t TCollection::fgGarbageStack = 0;; 58 ; 59ClassImp(TCollection);; 60ClassImp(TIter);; 61 ; 62#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 63 ; 64void TCollection::TErrorLock::ConflictReport(std::thread::id holder, const char *accesstype,; 65 const TCollection *collection, const char *function); 66{; 67 ; 68 auto local = std::this_thread::get_id();; 69 std::stringstream cur, loc;; 70 if (holder == std::thread::id()); 71 cur << ""None"";; 72 else; 73 cur << ""0x"" << std::hex << holder;; 74 loc << ""0x"" << std::hex << local;; 75 ; 76 // std::cerr << ""Error in "" << function << "": Access ("" << accesstype << "") to a collection ("" <<; 77 // collection->IsA()->GetName() << "":"" << collection <<; 78 // "") from multiple threads at a time. holder="" << ""0x"" << std::hex << holder << "" readers="" << fReadSet.size() <<; 79 // ""0x"" << std::hex << local << std::endl;; 80 ; 81 ::Error(function,; 82 ""Access (%s) to a collection (%s:%p) from multiple threads at a time. holder=%s readers=%lu intruder=%s"",; 83 accesstype, collection->IsA()->GetName(), collection, cur.str().c_str(), fReadSet.size(), loc.str().c_str());; 84 ; 85 std::set<std::thread::id> tmp;; 86 for (auto r : fReadSet) tmp.insert(r);; 87 for (auto r : tmp) {; 88 std::stringstream reader;; 89",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
Testability,test,test,"}; 738 ; 739////////////////////////////////////////////////////////////////////////////////; 740/// Set whether this collection is the owner (enable==true); 741/// of its content. If it is the owner of its contents,; 742/// these objects will be deleted whenever the collection itself; 743/// is deleted. The objects might also be deleted or destructed when Clear; 744/// is called (depending on the collection).; 745 ; 746void TCollection::SetOwner(Bool_t enable); 747{; 748 if (enable); 749 SetBit(kIsOwner);; 750 else; 751 ResetBit(kIsOwner);; 752}; 753 ; 754////////////////////////////////////////////////////////////////////////////////; 755/// Set this collection to use a RW lock upon access, making it thread safe.; 756/// Return the previous state.; 757///; 758/// Note: To test whether the usage is enabled do:; 759/// collection->TestBit(TCollection::kUseRWLock);; 760 ; 761bool TCollection::UseRWLock(Bool_t enable); 762{; 763 bool prev = TestBit(TCollection::kUseRWLock);; 764 if (enable) {; 765 SetBit(TCollection::kUseRWLock);; 766 } else {; 767 ResetBit(TCollection::kUseRWLock);; 768 }; 769 return prev;; 770}; 771 ; 772////////////////////////////////////////////////////////////////////////////////; 773/// Copy a TIter. This involves allocating a new TIterator of the right; 774/// sub class and assigning it with the original.; 775 ; 776TIter::TIter(const TIter &iter); 777{; 778 if (iter.fIterator) {; 779 fIterator = iter.GetCollection()->MakeIterator();; 780 fIterator->operator=(*iter.fIterator);; 781 } else; 782 fIterator = nullptr;; 783}; 784 ; 785////////////////////////////////////////////////////////////////////////////////; 786/// Assigning an TIter to another. This involves allocating a new TIterator; 787/// of the right sub class and assigning it with the original.; 788 ; 789TIter &TIter::operator=(const TIter &rhs); 790{; 791 if (this != &rhs) {; 792 if (rhs.fIterator) {; 793 delete fIterator;; 794 fIterator = rhs.GetCollection()->MakeIterator();; 795 fIt",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
Energy Efficiency,adapt,adapter," type inherits from TObject and a new constructor that takes the TCollection by pointer. ;  ; namespace  ROOT::Internal;  . Macros; #define R__COLL_COND_MUTEX(mutex)   this->IsUsingRWLock() ? mutex : nullptr;  ; #define R__COLLECTION_ITER_GUARD(collection);  ; #define R__COLLECTION_READ_GUARD();  ; #define R__COLLECTION_READ_LOCKGUARD(mutex)   ::ROOT::TReadLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_READ_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TReadLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_GUARD();  ; #define R__COLLECTION_WRITE_LOCKGUARD(mutex)   ::ROOT::TWriteLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TWriteLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__FOR_EACH(type, proc);  . Typedefs; template<typename T > ; using TRangeDynCast = ROOT::Detail::TRangeCast< T, true >;  TRangeDynCast is an adapter class that allows the typed iteration through a TCollection. ;  ; template<typename T > ; using ROOT::Detail::TRangeStaticCast = TRangeCast< T, false >;  TRangeStaticCast is an adapter class that allows the typed iteration through a TCollection. ;  . Functions; bool ROOT::Internal::ContaineeInheritsFrom (TClass *cl, TClass *base);  Return true if 'cl' inherits from 'base'. ;  ; const TCollection & ROOT::Internal::EmptyCollection ();  Return an empty collection for use with nullptr TRangeCast. ;  . Variables; R__EXTERN TVirtualMutex * gCollectionMutex;  ; const Bool_t kIterBackward = !kIterForward;  ; const Bool_t kIterForward = kTRUE;  . Macro Definition Documentation. ◆ R__COLL_COND_MUTEX. #define R__COLL_COND_MUTEX; (;  ; mutex);    this->IsUsingRWLock() ? mutex : nullptr. Definition at line 360 of file TCollection.h. ◆ R__COLLECTION_ITER_GUARD. #define R__COLLECTION_ITER_GUARD; (;  ; collection). Definition at line 129 of file TCollection.h. ◆ R__COLLE",MatchSource.WIKI,doc/master/TCollection_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h.html
Integrability,depend,dependency,". ROOT: core/cont/inc/TCollection.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Macros |; Typedefs |; Functions |; Variables ; TCollection.h File Reference. #include ""TObject.h""; #include ""TIterator.h""; #include ""TString.h""; #include ""TVirtualRWMutex.h""; #include ""ROOT/RRangeCast.hxx""; #include <cassert>. Include dependency graph for TCollection.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TCollection;  Collection abstract base class. More...;  ; class  TIter;  ; class  TIterCategory< T >;  ; class  ROOT::Detail::TRangeCast< T, isDynamic >;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Detail;  Special implementation of ROOT::RRangeCast for TCollection, including a check that the cast target type inherits from TObject and a new constructor that takes the TCollection by pointer. ;  ; namespace  ROOT::Internal;  . Macros; #define R__COLL_COND_MUTEX(mutex)   this->IsUsingRWLock() ? mutex : nullptr;  ; #define R__COLLECTION_ITER_GUARD(collection);  ; #define R__COLLECTION_READ_GUARD();  ; #define R__COLLECTION_READ_LOCKGUARD(mutex)   ::ROOT::TReadLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_READ_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TReadLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_GUARD();  ; #define R__COLLECTION_WRITE_LOCKGUARD(mutex)   ::ROOT::TWriteLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TWriteLockGuard _NAME2_(R__readguard,nam",MatchSource.WIKI,doc/master/TCollection_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h.html
Modifiability,inherit,inherits,"ence. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Macros |; Typedefs |; Functions |; Variables ; TCollection.h File Reference. #include ""TObject.h""; #include ""TIterator.h""; #include ""TString.h""; #include ""TVirtualRWMutex.h""; #include ""ROOT/RRangeCast.hxx""; #include <cassert>. Include dependency graph for TCollection.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TCollection;  Collection abstract base class. More...;  ; class  TIter;  ; class  TIterCategory< T >;  ; class  ROOT::Detail::TRangeCast< T, isDynamic >;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Detail;  Special implementation of ROOT::RRangeCast for TCollection, including a check that the cast target type inherits from TObject and a new constructor that takes the TCollection by pointer. ;  ; namespace  ROOT::Internal;  . Macros; #define R__COLL_COND_MUTEX(mutex)   this->IsUsingRWLock() ? mutex : nullptr;  ; #define R__COLLECTION_ITER_GUARD(collection);  ; #define R__COLLECTION_READ_GUARD();  ; #define R__COLLECTION_READ_LOCKGUARD(mutex)   ::ROOT::TReadLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_READ_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TReadLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_GUARD();  ; #define R__COLLECTION_WRITE_LOCKGUARD(mutex)   ::ROOT::TWriteLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TWriteLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__F",MatchSource.WIKI,doc/master/TCollection_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h.html
Security,access,accessible,",proc)())) \; _NAME3_(obj_,type,proc)->proc; _NAME3_#define _NAME3_(name1, name2, name3)Definition RConfig.hxx:444; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; TCollection::GetCurrentCollectionstatic TCollection * GetCurrentCollection()Return the globally accessible collection.Definition TCollection.cxx:680; TIterDefinition TCollection.h:235. Definition at line 373 of file TCollection.h. Typedef Documentation. ◆ TRangeDynCast. template<typename T > . using TRangeDynCast = ROOT::Detail::TRangeCast<T, true>. TRangeDynCast is an adapter class that allows the typed iteration through a TCollection. ; The typical use is: for(auto bcl : TRangeDynCast<TBaseClass>( *cl->GetListOfBases() )) {; if (!bcl) continue;; ... use bcl as a TBaseClass*; }; for(auto bcl : TRangeDynCast<TBaseClass>( cl->GetListOfBases() )) {; if (!bcl) continue;; ... use bcl as a TBaseClass*; }; a#define a(i)Definition RSha256.hxx:99; ROOT::Detail::TRangeCastDefinition TCollection.h:311; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; Template Parameters. TThe new type to convert to. . Definition at line 358 of file TCollection.h. Variable Documentation. ◆ gCollectionMutex. R__EXTE",MatchSource.WIKI,doc/master/TCollection_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h.html
Energy Efficiency,allocate,allocated,"TClass *cl) const;; 166 void Browse(TBrowser *b) override;; 167 Int_t Capacity() const { return fSize; }; 168 void Clear(Option_t *option="""") override = 0;; 169 TObject *Clone(const char *newname="""") const override;; 170 Int_t Compare(const TObject *obj) const override;; 171 Bool_t Contains(const char *name) const { return FindObject(name) != nullptr; }; 172 Bool_t Contains(const TObject *obj) const { return FindObject(obj) != nullptr; }; 173 void Delete(Option_t *option="""") override = 0;; 174 void Draw(Option_t *option="""") override;; 175 void Dump() const override;; 176 TObject *FindObject(const char *name) const override;; 177 TObject *operator()(const char *name) const;; 178 TObject *FindObject(const TObject *obj) const override;; 179 virtual Int_t GetEntries() const { return GetSize(); }; 180 const char *GetName() const override;; 181 virtual TObject **GetObjectRef(const TObject *obj) const = 0;; 182 /// Return the *capacity* of the collection, i.e. the current total amount of space that has been allocated so far.; 183 /// Same as `Capacity`. Use `GetEntries` to get the number of elements currently in the collection.; 184 virtual Int_t GetSize() const { return fSize; }; 185 virtual Int_t GrowBy(Int_t delta) const;; 186 ULong_t Hash() const override { return fName.Hash(); }; 187 Bool_t IsArgNull(const char *where, const TObject *obj) const;; 188 virtual Bool_t IsEmpty() const { return GetSize() <= 0; }; 189 Bool_t IsFolder() const override { return kTRUE; }; 190 Bool_t IsOwner() const { return TestBit(kIsOwner); }; 191 Bool_t IsSortable() const override { return kTRUE; }; 192 void ls(Option_t *option="""") const override;; 193 Bool_t Notify() override;; 194 virtual TIterator *MakeIterator(Bool_t dir = kIterForward) const = 0;; 195 virtual TIterator *MakeReverseIterator() const { return MakeIterator(kIterBackward); }; 196 void Paint(Option_t *option="""") override;; 197 void Print(Option_t *option="""") const override;; 198 virtual void Print(Option_t *option, Int_t rec",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
Integrability,wrap,wrapper,"t char *where, const TObject *obj) const;; 188 virtual Bool_t IsEmpty() const { return GetSize() <= 0; }; 189 Bool_t IsFolder() const override { return kTRUE; }; 190 Bool_t IsOwner() const { return TestBit(kIsOwner); }; 191 Bool_t IsSortable() const override { return kTRUE; }; 192 void ls(Option_t *option="""") const override;; 193 Bool_t Notify() override;; 194 virtual TIterator *MakeIterator(Bool_t dir = kIterForward) const = 0;; 195 virtual TIterator *MakeReverseIterator() const { return MakeIterator(kIterBackward); }; 196 void Paint(Option_t *option="""") override;; 197 void Print(Option_t *option="""") const override;; 198 virtual void Print(Option_t *option, Int_t recurse) const;; 199 virtual void Print(Option_t *option, const char* wildcard, Int_t recurse=1) const;; 200 virtual void Print(Option_t *option, TPRegexp& regexp, Int_t recurse=1) const;; 201 void RecursiveRemove(TObject *obj) override;; 202 virtual TObject *Remove(TObject *obj) = 0;; 203 virtual void RemoveAll(TCollection *col);; 204 void RemoveAll() { Clear(); }; 205 void SetCurrentCollection();; 206 void SetName(const char *name) { fName = name; }; 207 virtual void SetOwner(Bool_t enable = kTRUE);; 208 virtual bool UseRWLock(Bool_t enable = true);; 209 Int_t Write(const char *name = nullptr, Int_t option = 0, Int_t bufsize = 0) override;; 210 Int_t Write(const char *name = nullptr, Int_t option = 0, Int_t bufsize = 0) const override;; 211 ; 212 R__ALWAYS_INLINE Bool_t IsUsingRWLock() const { return TestBit(TCollection::kUseRWLock); }; 213 ; 214 static TCollection *GetCurrentCollection();; 215 static void StartGarbageCollection();; 216 static void GarbageCollect(TObject *obj);; 217 static void EmptyGarbageCollection();; 218 ; 219 TIter begin() const;; 220 TIter end() const;; 221 ; 222 ClassDefOverride(TCollection,3) //Collection abstract base class; 223};; 224 ; 225 ; 226//////////////////////////////////////////////////////////////////////////; 227// //; 228// TIter //; 229// //; 230// Iterator wrapper.",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
Modifiability,inherit,inherits,". ROOT: core/cont/inc/TCollection.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TCollection.h. Go to the documentation of this file. 1// @(#)root/cont:$Id$; 2// Author: Fons Rademakers 13/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TCollection; 13#define ROOT_TCollection; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TCollection //; 19// //; 20// Collection abstract base class. This class inherits from TObject //; 21// because we want to be able to have collections of collections. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TObject.h""; 26 ; 27#include ""TIterator.h""; 28 ; 29#include ""TString.h""; 30 ; 31#include ""TVirtualRWMutex.h""; 32 ; 33#include ""ROOT/RRangeCast.hxx""; 34 ; 35#include <cassert>; 36 ; 37class TClass;; 38class TObjectTable;; 39class TVirtualMutex;; 40class TIter;; 41 ; 42const Bool_t kIterForward = kTRUE;; 43const Bool_t kIterBackward = !kIterForward;; 44 ; 45R__EXTERN TVirtualMutex *gCollectionMutex;; 46 ; 47// #define R__CHECK_COLLECTION_MULTI_ACCESS; 48 ; 49// When R__CHECK_COLLECTION_MULTI_ACCESS is turned on (defined),; 50// the normal (not locked) ROOT TCollections are instrumented with a; 51// pseudo read-write lock which does not halt the execution but detects; 52// and report concurrent access to the same collections.; 53// Multiple readers are allowed.; 54// Multiple concurrent writer is reported as a Conflict; 55// Readers access while a write is running is reported as Conflict; 56// Re-entrant writing call by the same Wri",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
Performance,concurren,concurrent,"f contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TCollection; 13#define ROOT_TCollection; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TCollection //; 19// //; 20// Collection abstract base class. This class inherits from TObject //; 21// because we want to be able to have collections of collections. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TObject.h""; 26 ; 27#include ""TIterator.h""; 28 ; 29#include ""TString.h""; 30 ; 31#include ""TVirtualRWMutex.h""; 32 ; 33#include ""ROOT/RRangeCast.hxx""; 34 ; 35#include <cassert>; 36 ; 37class TClass;; 38class TObjectTable;; 39class TVirtualMutex;; 40class TIter;; 41 ; 42const Bool_t kIterForward = kTRUE;; 43const Bool_t kIterBackward = !kIterForward;; 44 ; 45R__EXTERN TVirtualMutex *gCollectionMutex;; 46 ; 47// #define R__CHECK_COLLECTION_MULTI_ACCESS; 48 ; 49// When R__CHECK_COLLECTION_MULTI_ACCESS is turned on (defined),; 50// the normal (not locked) ROOT TCollections are instrumented with a; 51// pseudo read-write lock which does not halt the execution but detects; 52// and report concurrent access to the same collections.; 53// Multiple readers are allowed.; 54// Multiple concurrent writer is reported as a Conflict; 55// Readers access while a write is running is reported as Conflict; 56// Re-entrant writing call by the same Writer thread are allowed.; 57// Entering a writing section by a single Reader thread is allowed.; 58 ; 59#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 60#include <atomic>; 61#include <thread>; 62#include <unordered_multiset>; 63#endif; 64 ; 65class TCollection : public TObject {; 66 ; 67#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 68public:; 69 class TErrorLock {; 70 // Warn when multiple thread try to acquire the same 'lock'; 71 std::atomic<std::thread::id> fWriteCurrent;; 72 std::atomic<size_t> fWri",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
Safety,detect,detects,"f contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TCollection; 13#define ROOT_TCollection; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TCollection //; 19// //; 20// Collection abstract base class. This class inherits from TObject //; 21// because we want to be able to have collections of collections. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TObject.h""; 26 ; 27#include ""TIterator.h""; 28 ; 29#include ""TString.h""; 30 ; 31#include ""TVirtualRWMutex.h""; 32 ; 33#include ""ROOT/RRangeCast.hxx""; 34 ; 35#include <cassert>; 36 ; 37class TClass;; 38class TObjectTable;; 39class TVirtualMutex;; 40class TIter;; 41 ; 42const Bool_t kIterForward = kTRUE;; 43const Bool_t kIterBackward = !kIterForward;; 44 ; 45R__EXTERN TVirtualMutex *gCollectionMutex;; 46 ; 47// #define R__CHECK_COLLECTION_MULTI_ACCESS; 48 ; 49// When R__CHECK_COLLECTION_MULTI_ACCESS is turned on (defined),; 50// the normal (not locked) ROOT TCollections are instrumented with a; 51// pseudo read-write lock which does not halt the execution but detects; 52// and report concurrent access to the same collections.; 53// Multiple readers are allowed.; 54// Multiple concurrent writer is reported as a Conflict; 55// Readers access while a write is running is reported as Conflict; 56// Re-entrant writing call by the same Writer thread are allowed.; 57// Entering a writing section by a single Reader thread is allowed.; 58 ; 59#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 60#include <atomic>; 61#include <thread>; 62#include <unordered_multiset>; 63#endif; 64 ; 65class TCollection : public TObject {; 66 ; 67#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 68public:; 69 class TErrorLock {; 70 // Warn when multiple thread try to acquire the same 'lock'; 71 std::atomic<std::thread::id> fWriteCurrent;; 72 std::atomic<size_t> fWri",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
Security,access,access,"f contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TCollection; 13#define ROOT_TCollection; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TCollection //; 19// //; 20// Collection abstract base class. This class inherits from TObject //; 21// because we want to be able to have collections of collections. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TObject.h""; 26 ; 27#include ""TIterator.h""; 28 ; 29#include ""TString.h""; 30 ; 31#include ""TVirtualRWMutex.h""; 32 ; 33#include ""ROOT/RRangeCast.hxx""; 34 ; 35#include <cassert>; 36 ; 37class TClass;; 38class TObjectTable;; 39class TVirtualMutex;; 40class TIter;; 41 ; 42const Bool_t kIterForward = kTRUE;; 43const Bool_t kIterBackward = !kIterForward;; 44 ; 45R__EXTERN TVirtualMutex *gCollectionMutex;; 46 ; 47// #define R__CHECK_COLLECTION_MULTI_ACCESS; 48 ; 49// When R__CHECK_COLLECTION_MULTI_ACCESS is turned on (defined),; 50// the normal (not locked) ROOT TCollections are instrumented with a; 51// pseudo read-write lock which does not halt the execution but detects; 52// and report concurrent access to the same collections.; 53// Multiple readers are allowed.; 54// Multiple concurrent writer is reported as a Conflict; 55// Readers access while a write is running is reported as Conflict; 56// Re-entrant writing call by the same Writer thread are allowed.; 57// Entering a writing section by a single Reader thread is allowed.; 58 ; 59#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 60#include <atomic>; 61#include <thread>; 62#include <unordered_multiset>; 63#endif; 64 ; 65class TCollection : public TObject {; 66 ; 67#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 68public:; 69 class TErrorLock {; 70 // Warn when multiple thread try to acquire the same 'lock'; 71 std::atomic<std::thread::id> fWriteCurrent;; 72 std::atomic<size_t> fWri",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
Testability,assert,assert,"inherits from TObject and a new constructor; 305/// that takes the TCollection by pointer.; 306/// \tparam T The new type to convert to.; 307/// \tparam isDynamic If `true`, `dynamic_cast` is used, otherwise `static_cast` is used.; 308namespace Detail {; 309 ; 310template <typename T, bool isDynamic>; 311class TRangeCast : public ROOT::RRangeCast<T*, isDynamic, TCollection const&> {; 312public:; 313 TRangeCast(TCollection const& col) : ROOT::RRangeCast<T*, isDynamic, TCollection const&>{col} {; 314 static_assert(std::is_base_of<TObject, T>::value, ""Containee type must inherit from TObject"");; 315 }; 316 TRangeCast(TCollection const* col) : TRangeCast{col != nullptr ? *col : ROOT::Internal::EmptyCollection()} {}; 317};; 318 ; 319/// @brief TRangeStaticCast is an adapter class that allows the typed iteration; 320/// through a TCollection. This requires the collection to contain elements; 321/// of the type requested (or a derived class). Any deviation from this expectation; 322/// will only be caught/reported by an assert in debug builds.; 323///; 324/// This is best used with a TClonesArray, for other cases prefered TRangeDynCast.; 325///; 326/// The typical use is:; 327/// ```{.cpp}; 328/// for(auto bcl : TRangeStaticCast<TBaseClass>( *tbaseClassClonesArrayPtr )) {; 329/// ... use bcl as a TBaseClass*; 330/// }; 331/// for(auto bcl : TRangeStaticCast<TBaseClass>( tbaseClassClonesArrayPtr )) {; 332/// ... use bcl as a TBaseClass*; 333/// }; 334/// ```; 335/// \tparam T The new type to convert to.; 336template <typename T>; 337using TRangeStaticCast = TRangeCast<T, false>;; 338 ; 339} // namespace Detail; 340} // namespace ROOT; 341 ; 342/// @brief TRangeDynCast is an adapter class that allows the typed iteration; 343/// through a TCollection.; 344///; 345/// The typical use is:; 346/// ```{.cpp}; 347/// for(auto bcl : TRangeDynCast<TBaseClass>( *cl->GetListOfBases() )) {; 348/// if (!bcl) continue;; 349/// ... use bcl as a TBaseClass*; 350/// }; 351/// for(auto bcl : ",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
Usability,simpl,simple,"n TColorWheel.h:36; TColorWheel::fRmaxDouble_t fRmaxMaximum radius for rectangles.Definition TColorWheel.h:27; TColorWheel::PaintGrayvoid PaintGray() constDraw the gray colors + white + black.Definition TColorWheel.cxx:389; TColorWheel::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideReturn the color number pointed by the mouse.Definition TColorWheel.cxx:155; TColorWheel::Paintvoid Paint(Option_t *option="""") overridePaint the color wheel.Definition TColorWheel.cxx:225; TColorWheel::PaintCirclesvoid PaintCircles(Int_t coffset, Double_t angle) constDraw all colors of type circle.Definition TColorWheel.cxx:279; TColorWheel::fDrDouble_t fDrCircles radius.Definition TColorWheel.h:29; TColorWheel::PaintRectanglesvoid PaintRectangles(Int_t coffset, Double_t angle) constDraw all colors of type rectangle.Definition TColorWheel.cxx:306; TColorWheel::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overridealways return the color wheelDefinition TColorWheel.cxx:106; TColorWheel::Rotatevoid Rotate(Double_t x, Double_t y, Double_t &u, Double_t &v, Double_t ang) constRotate point x,y with an angle=ang.Definition TColorWheel.cxx:428; TColorWheel::fGraphTGraph * fGraph! pointer to utility graphDefinition TColorWheel.h:37; TColorWheel::~TColorWheel~TColorWheel() overridedestructorDefinition TColorWheel.cxx:94; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TTextBase class for several text objects.Definition TText.h:22; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; v@ vDefinition rootcling_impl.cxx:3699; Drawth1 Draw(). graf2dgpadincTColorWheel.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:17 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TColorWheel_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColorWheel_8h_source.html
Availability,avail,available,"s is the following:; 166 ; 167~~~ {.cpp}; 168kWhite = 0, kBlack = 1, kGray = 920, kRed = 632, kGreen = 416,; 169kBlue = 600, kYellow = 400, kMagenta = 616, kCyan = 432, kOrange = 800,; 170kSpring = 820, kTeal = 840, kAzure = 860, kViolet = 880, kPink = 900; 171~~~; 172 ; 173Note the special role of color `kWhite` (color number 0). It is the default; 174background color also. For instance in a PDF or PS files (as paper is usually white); 175it is simply not painted. To have a white color behaving like the other color the; 176simplest is to define an other white color not attached to the color index 0:; 177 ; 178~~~ {.cpp}; 179 Int_t ci = TColor::GetFreeColorIndex();; 180 TColor *color = new TColor(ci, 1., 1., 1.);; 181~~~; 182 ; 183\anchor C03; 184## Bright and dark colors; 185Dark and bright colors are used to add 3D effects to graphical objects like; 186TWbox, TPave, TPaveText, TPaveLabel, etc. and in colored lego plots.; 187 ; 188Two static functions are available that return the bright or dark color number corresponding; 189to a given color index. If these variants don't already exist, they are created as needed:; 190~~~ {.cpp}; 191 Int_t dark = TColor::GetColorDark(color_index);; 192 Int_t bright = TColor::GetColorBright(color_index);; 193~~~; 194 ; 195\anchor C031; 196## Accessible Color Schemes; 197Choosing an appropriate color scheme is essential for making results easy to understand and; 198interpret. Factors like colorblindness and converting colors to grayscale for publications; 199can impact accessibility. Furthermore, results should be aesthetically pleasing. The following; 200three color schemes, recommended by M. Petroff in [arXiv:2107.02270v2](https://arxiv.org/pdf/2107.02270); 201and available on [GitHub](https://github.com/mpetroff/accessible-color-cycles); 202under the MIT License, meet these criteria.; 203 ; 204These three color schemes are available as color sets with 6, 8, and 10 colors, named; 205`kP[6, 8, 10]ColorName`. For example, `kP6Red` re",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
Deployability,toggle,toggle," like colorblindness and converting colors to grayscale for publications; 199can impact accessibility. Furthermore, results should be aesthetically pleasing. The following; 200three color schemes, recommended by M. Petroff in [arXiv:2107.02270v2](https://arxiv.org/pdf/2107.02270); 201and available on [GitHub](https://github.com/mpetroff/accessible-color-cycles); 202under the MIT License, meet these criteria.; 203 ; 204These three color schemes are available as color sets with 6, 8, and 10 colors, named; 205`kP[6, 8, 10]ColorName`. For example, `kP6Red` represents the red color within the P6 color scheme; 206(`P` for Petroff or Preferred).; 207 ; 208Begin_Macro; 209../../../tutorials/graphics/accessiblecolorschemes.C; 210End_Macro; 211 ; 212The example thstackcolorscheme.C illustrates how to use these color schemes in THStack drawings.; 213It also demonstrates that they are effective in grayscale.; 214 ; 215\anchor C04; 216## Grayscale view of of canvas with colors; 217One can toggle between a grayscale preview and the regular colored mode using; 218`TCanvas::SetGrayscale()`. Note that in grayscale mode, access via RGB; 219will return grayscale values according to ITU standards (and close to b&w; 220printer gray-scales), while access via HLS returns de-saturated gray-scales. The; 221image below shows the ROOT color wheel in grayscale mode.; 222 ; 223Begin_Macro(source); 224{; 225 auto w = new TColorWheel();; 226 auto cw = new TCanvas(""cw"",""cw"",0,0,400,400);; 227 cw->GetCanvas()->SetGrayscale();; 228 w->SetCanvas(cw);; 229 w->Draw();; 230}; 231End_Macro; 232 ; 233\anchor C05; 234## Color palettes; 235It is often very useful to represent a variable with a color map. The concept; 236of ""color palette"" allows to do that. One color palette is active at any time.; 237This ""current palette"" is set using:; 238 ; 239~~~ {.cpp}; 240gStyle->SetPalette(...);; 241~~~; 242 ; 243This function has two parameters: the number of colors in the palette and an; 244array of containing the",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
Energy Efficiency,green,green,"D globalPalettesList(0);; 41 return globalPalettesList;; 42 }; 43}; 44 ; 45static Int_t gHighestColorIndex = 0; ///< Highest color index defined; 46static Float_t gColorThreshold = -1.; ///< Color threshold used by GetColor; 47static Int_t gDefinedColors = 0; ///< Number of defined colors.; 48static Int_t gLastDefinedColors = 649; ///< Previous number of defined colors; 49 ; 50#define fgGrayscaleMode TColor__GrayScaleMode(); 51#define fgPalette TColor__Palette(); 52#define fgPalettesList TColor__PalettesList(); 53 ; 54using std::floor;; 55 ; 56/** \class TColor; 57\ingroup Base; 58\ingroup GraphicsAtt; 59 ; 60The color creation and management class.; 61 ; 62 - [Introduction](\ref C00); 63 - [Basic colors](\ref C01); 64 - [The color wheel](\ref C02); 65 - [Bright and dark colors](\ref C03); 66 - [Accessible Color Schemes](\ref C031); 67 - [Gray scale view of of canvas with colors](\ref C04); 68 - [Color palettes](\ref C05); 69 - [High quality predefined palettes](\ref C06); 70 - [Colour Vision Deficiency (CVD) friendly palettes](\ref C06a); 71 - [Non Colour Vision Deficiency (CVD) friendly palettes](\ref C06b); 72 - [Palette inversion](\ref C061); 73 - [Color transparency](\ref C07); 74 ; 75\anchor C00; 76## Introduction; 77 ; 78Colors are defined by their red, green and blue components, simply called the; 79RGB components. The colors are also known by the hue, light and saturation; 80components also known as the HLS components. When a new color is created the; 81components of both color systems are computed.; 82 ; 83At initialization time, a table of colors is generated. An existing color can; 84be retrieved by its index:; 85 ; 86~~~ {.cpp}; 87 TColor *color = gROOT->GetColor(10);; 88~~~; 89 ; 90Then it can be manipulated. For example its RGB components can be modified:; 91 ; 92~~~ {.cpp}; 93 color->SetRGB(0.1, 0.2, 0.3);; 94~~~; 95 ; 96A new color can be created the following way:; 97 ; 98~~~ {.cpp}; 99 Int_t ci = 1756; // color index; 100 auto color = new TColor(ci",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
Integrability,depend,dependent,"ex between [0,FF].; 1920 ; 1921Int_t TColor::GetColor(const char *hexcolor); 1922{; 1923 if (hexcolor && *hexcolor == '#') {; 1924 Int_t r, g, b;; 1925 if (sscanf(hexcolor+1, ""%02x%02x%02x"", &r, &g, &b) == 3); 1926 return GetColor(r, g, b);; 1927 }; 1928 ::Error(""TColor::GetColor(const char*)"", ""incorrect color string"");; 1929 return 0;; 1930}; 1931 ; 1932////////////////////////////////////////////////////////////////////////////////; 1933/// Static method returning color number for color specified by; 1934/// r, g and b. The r,g,b should be in the range [0,1].; 1935///; 1936/// The color retrieval is done using a threshold defined by SetColorThreshold.; 1937///; 1938/// If specified color does not exist it will be created; 1939/// with as name ""#rrggbb"" with rr, gg and bb in hex between; 1940/// [0,FF].; 1941 ; 1942Int_t TColor::GetColor(Float_t r, Float_t g, Float_t b, Float_t a); 1943{; 1944 return GetColor(Int_t(r * 255), Int_t(g * 255), Int_t(b * 255), a);; 1945}; 1946 ; 1947////////////////////////////////////////////////////////////////////////////////; 1948/// Static method returning color number for color specified by; 1949/// system dependent pixel value. Pixel values can be obtained, e.g.,; 1950/// from the GUI color picker.; 1951///; 1952/// The color retrieval is done using a threshold defined by SetColorThreshold.; 1953 ; 1954 ; 1955Int_t TColor::GetColor(ULong_t pixel); 1956{; 1957 Int_t r, g, b;; 1958 ; 1959 Pixel2RGB(pixel, r, g, b);; 1960 ; 1961 return GetColor(r, g, b);; 1962}; 1963 ; 1964////////////////////////////////////////////////////////////////////////////////; 1965/// This method specifies the color threshold used by GetColor to retrieve a color.; 1966///; 1967/// \param[in] t Color threshold. By default is equal to 1./31. or 1./255.; 1968/// depending on the number of available color planes.; 1969///; 1970/// When GetColor is called, it scans the defined colors and compare them to the; 1971/// requested color.; 1972/// If the Red Green ",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
Modifiability,variab,variable,"ColorName`. For example, `kP6Red` represents the red color within the P6 color scheme; 206(`P` for Petroff or Preferred).; 207 ; 208Begin_Macro; 209../../../tutorials/graphics/accessiblecolorschemes.C; 210End_Macro; 211 ; 212The example thstackcolorscheme.C illustrates how to use these color schemes in THStack drawings.; 213It also demonstrates that they are effective in grayscale.; 214 ; 215\anchor C04; 216## Grayscale view of of canvas with colors; 217One can toggle between a grayscale preview and the regular colored mode using; 218`TCanvas::SetGrayscale()`. Note that in grayscale mode, access via RGB; 219will return grayscale values according to ITU standards (and close to b&w; 220printer gray-scales), while access via HLS returns de-saturated gray-scales. The; 221image below shows the ROOT color wheel in grayscale mode.; 222 ; 223Begin_Macro(source); 224{; 225 auto w = new TColorWheel();; 226 auto cw = new TCanvas(""cw"",""cw"",0,0,400,400);; 227 cw->GetCanvas()->SetGrayscale();; 228 w->SetCanvas(cw);; 229 w->Draw();; 230}; 231End_Macro; 232 ; 233\anchor C05; 234## Color palettes; 235It is often very useful to represent a variable with a color map. The concept; 236of ""color palette"" allows to do that. One color palette is active at any time.; 237This ""current palette"" is set using:; 238 ; 239~~~ {.cpp}; 240gStyle->SetPalette(...);; 241~~~; 242 ; 243This function has two parameters: the number of colors in the palette and an; 244array of containing the indices of colors in the palette. The following small; 245example demonstrates how to define and use the color palette:; 246 ; 247Begin_Macro(source); 248{; 249 auto c1 = new TCanvas(""c1"",""c1"",0,0,600,400);; 250 TF2 *f1 = new TF2(""f1"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; 251 Int_t palette[5];; 252 palette[0] = 15;; 253 palette[1] = 20;; 254 palette[2] = 23;; 255 palette[3] = 30;; 256 palette[4] = 32;; 257 gStyle->SetPalette(5,palette);; 258 f1->Draw(""colz"");; 259 return c1;; 260}; 261End_Macro; 262 ; 263To d",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
Performance,tune,tuned,"00];; 296 Double_t Red[] = {0., 0.0, 1.0, 1.0, 1.0};; 297 Double_t Green[] = {0., 0.0, 0.0, 1.0, 1.0};; 298 Double_t Blue[] = {0., 1.0, 0.0, 0.0, 1.0};; 299 Double_t Length[] = {0., .25, .50, .75, 1.0};; 300 Int_t FI = TColor::CreateGradientColorTable(5, Length, Red, Green, Blue, 100);; 301 for (int i=0;i<100;i++) MyPalette[i] = FI+i;; 302~~~; 303 ; 304Later on to reuse the palette `MyPalette` it will be enough to do; 305 ; 306~~~ {.cpp}; 307 gStyle->SetPalette(100, MyPalette);; 308~~~; 309 ; 310As only one palette is active, one need to use `TExec` to be able to; 311display plots using different palettes on the same pad.; 312The tutorial multipalette.C illustrates this feature.; 313 ; 314Begin_Macro(source); 315../../../tutorials/graphs/multipalette.C; 316End_Macro; 317 ; 318\since **6.26:**; 319The function `TColor::CreateColorTableFromFile(""filename.txt"")` allows you to create a color; 320palette based on an input ASCII file. In contrast to `TColor::CreateGradientColorTable()`, here; 321the length (spacing) is constant and can not be tuned. There is no gradient being interpolated; 322between adjacent colors. The palette will contain the exact colors stored in the file, that; 323comprises one line per color in the format ""r g b"" as floats.; 324 ; 325\anchor C06; 326## High quality predefined palettes; 327\since **6.04:**; 32863 high quality palettes are predefined with 255 colors each.; 329 ; 330These palettes can be accessed ""by name"" with `gStyle->SetPalette(num)`.; 331`num` can be taken within the following enum:; 332 ; 333~~~ {.cpp}; 334kDeepSea=51, kGreyScale=52, kDarkBodyRadiator=53,; 335kBlueYellow= 54, kRainBow=55, kInvertedDarkBodyRadiator=56,; 336kBird=57, kCubehelix=58, kGreenRedViolet=59,; 337kBlueRedYellow=60, kOcean=61, kColorPrintableOnGrey=62,; 338kAlpine=63, kAquamarine=64, kArmy=65,; 339kAtlantic=66, kAurora=67, kAvocado=68,; 340kBeach=69, kBlackBody=70, kBlueGreenYellow=71,; 341kBrownCyan=72, kCMYK=73, kCandy=74,; 342kCherry=75, kCoffee=76, kDark",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
Safety,avoid,avoid,"t_t TColor::GetColorPalette(Int_t i); 1506{; 1507 Int_t ncolors = fgPalette.fN;; 1508 if (ncolors == 0) return 0;; 1509 Int_t icol = i%ncolors;; 1510 if (icol < 0) icol = 0;; 1511 return fgPalette.fArray[icol];; 1512}; 1513 ; 1514////////////////////////////////////////////////////////////////////////////////; 1515/// Static function returning the current active palette.; 1516 ; 1517const TArrayI& TColor::GetPalette(); 1518{; 1519 return fgPalette;; 1520}; 1521 ; 1522////////////////////////////////////////////////////////////////////////////////; 1523/// Static function returning number of colors in the color palette.; 1524 ; 1525Int_t TColor::GetNumberOfColors(); 1526{; 1527 return fgPalette.fN;; 1528}; 1529 ; 1530////////////////////////////////////////////////////////////////////////////////; 1531/// Static method returning kTRUE if some new colors have been defined after; 1532/// initialisation or since the last call to this method. This allows to avoid; 1533/// the colors and palette streaming in TCanvas::Streamer if not needed.; 1534/// If method called once with set_always_on = 1, all next canvases will be; 1535// saved with color palette - disregard if new colors created or not.; 1536/// To reset such mode, just call methoid once with set_always_on = -1; 1537 ; 1538Bool_t TColor::DefinedColors(Int_t set_always_on); 1539{; 1540 if (set_always_on > 0); 1541 gLastDefinedColors = -1;; 1542 else if (set_always_on < 0); 1543 gLastDefinedColors = gDefinedColors;; 1544 ; 1545 if (gLastDefinedColors < 0); 1546 return kTRUE;; 1547 ; 1548 // After initialization gDefinedColors == 649. If it is bigger it means some new; 1549 // colors have been defined; 1550 Bool_t hasChanged = (gDefinedColors - gLastDefinedColors) > 50;; 1551 gLastDefinedColors = gDefinedColors;; 1552 return hasChanged;; 1553}; 1554 ; 1555////////////////////////////////////////////////////////////////////////////////; 1556/// Return pixel value corresponding to this color. This pixel value can; 1557//",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
Security,access,accessibility,"olor behaving like the other color the; 176simplest is to define an other white color not attached to the color index 0:; 177 ; 178~~~ {.cpp}; 179 Int_t ci = TColor::GetFreeColorIndex();; 180 TColor *color = new TColor(ci, 1., 1., 1.);; 181~~~; 182 ; 183\anchor C03; 184## Bright and dark colors; 185Dark and bright colors are used to add 3D effects to graphical objects like; 186TWbox, TPave, TPaveText, TPaveLabel, etc. and in colored lego plots.; 187 ; 188Two static functions are available that return the bright or dark color number corresponding; 189to a given color index. If these variants don't already exist, they are created as needed:; 190~~~ {.cpp}; 191 Int_t dark = TColor::GetColorDark(color_index);; 192 Int_t bright = TColor::GetColorBright(color_index);; 193~~~; 194 ; 195\anchor C031; 196## Accessible Color Schemes; 197Choosing an appropriate color scheme is essential for making results easy to understand and; 198interpret. Factors like colorblindness and converting colors to grayscale for publications; 199can impact accessibility. Furthermore, results should be aesthetically pleasing. The following; 200three color schemes, recommended by M. Petroff in [arXiv:2107.02270v2](https://arxiv.org/pdf/2107.02270); 201and available on [GitHub](https://github.com/mpetroff/accessible-color-cycles); 202under the MIT License, meet these criteria.; 203 ; 204These three color schemes are available as color sets with 6, 8, and 10 colors, named; 205`kP[6, 8, 10]ColorName`. For example, `kP6Red` represents the red color within the P6 color scheme; 206(`P` for Petroff or Preferred).; 207 ; 208Begin_Macro; 209../../../tutorials/graphics/accessiblecolorschemes.C; 210End_Macro; 211 ; 212The example thstackcolorscheme.C illustrates how to use these color schemes in THStack drawings.; 213It also demonstrates that they are effective in grayscale.; 214 ; 215\anchor C04; 216## Grayscale view of of canvas with colors; 217One can toggle between a grayscale preview and the regular color",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
Testability,test,test,"olor picker.; 1951///; 1952/// The color retrieval is done using a threshold defined by SetColorThreshold.; 1953 ; 1954 ; 1955Int_t TColor::GetColor(ULong_t pixel); 1956{; 1957 Int_t r, g, b;; 1958 ; 1959 Pixel2RGB(pixel, r, g, b);; 1960 ; 1961 return GetColor(r, g, b);; 1962}; 1963 ; 1964////////////////////////////////////////////////////////////////////////////////; 1965/// This method specifies the color threshold used by GetColor to retrieve a color.; 1966///; 1967/// \param[in] t Color threshold. By default is equal to 1./31. or 1./255.; 1968/// depending on the number of available color planes.; 1969///; 1970/// When GetColor is called, it scans the defined colors and compare them to the; 1971/// requested color.; 1972/// If the Red Green and Blue values passed to GetColor are Rr Gr Br; 1973/// and Rd Gd Bd the values of a defined color. These two colors are considered equal; 1974/// if (abs(Rr-Rd) < t & abs(Br-Bd) < t & abs(Br-Bd) < t). If this test passes,; 1975/// the color defined by Rd Gd Bd is returned by GetColor.; 1976///; 1977/// To make sure GetColor will return a color having exactly the requested; 1978/// R G B values it is enough to specify a nul :; 1979/// ~~~ {.cpp}; 1980/// TColor::SetColorThreshold(0.);; 1981/// ~~~; 1982///; 1983/// To reset the color threshold to its default value it is enough to do:; 1984/// ~~~ {.cpp}; 1985/// TColor::SetColorThreshold(-1.);; 1986/// ~~~; 1987 ; 1988void TColor::SetColorThreshold(Float_t t); 1989{; 1990 gColorThreshold = t;; 1991}; 1992 ; 1993////////////////////////////////////////////////////////////////////////////////; 1994/// Static method returning color number for color specified by; 1995/// r, g and b. The r,g,b should be in the range [0,255].; 1996/// If the specified color does not exist it will be created; 1997/// with as name ""#rrggbb"" with rr, gg and bb in hex between; 1998/// [0,FF].; 1999///; 2000/// The color retrieval is done using a threshold defined by SetColorThreshold.; 2001 ; 2002Int_",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
Usability,simpl,simply,"D globalPalettesList(0);; 41 return globalPalettesList;; 42 }; 43}; 44 ; 45static Int_t gHighestColorIndex = 0; ///< Highest color index defined; 46static Float_t gColorThreshold = -1.; ///< Color threshold used by GetColor; 47static Int_t gDefinedColors = 0; ///< Number of defined colors.; 48static Int_t gLastDefinedColors = 649; ///< Previous number of defined colors; 49 ; 50#define fgGrayscaleMode TColor__GrayScaleMode(); 51#define fgPalette TColor__Palette(); 52#define fgPalettesList TColor__PalettesList(); 53 ; 54using std::floor;; 55 ; 56/** \class TColor; 57\ingroup Base; 58\ingroup GraphicsAtt; 59 ; 60The color creation and management class.; 61 ; 62 - [Introduction](\ref C00); 63 - [Basic colors](\ref C01); 64 - [The color wheel](\ref C02); 65 - [Bright and dark colors](\ref C03); 66 - [Accessible Color Schemes](\ref C031); 67 - [Gray scale view of of canvas with colors](\ref C04); 68 - [Color palettes](\ref C05); 69 - [High quality predefined palettes](\ref C06); 70 - [Colour Vision Deficiency (CVD) friendly palettes](\ref C06a); 71 - [Non Colour Vision Deficiency (CVD) friendly palettes](\ref C06b); 72 - [Palette inversion](\ref C061); 73 - [Color transparency](\ref C07); 74 ; 75\anchor C00; 76## Introduction; 77 ; 78Colors are defined by their red, green and blue components, simply called the; 79RGB components. The colors are also known by the hue, light and saturation; 80components also known as the HLS components. When a new color is created the; 81components of both color systems are computed.; 82 ; 83At initialization time, a table of colors is generated. An existing color can; 84be retrieved by its index:; 85 ; 86~~~ {.cpp}; 87 TColor *color = gROOT->GetColor(10);; 88~~~; 89 ; 90Then it can be manipulated. For example its RGB components can be modified:; 91 ; 92~~~ {.cpp}; 93 color->SetRGB(0.1, 0.2, 0.3);; 94~~~; 95 ; 96A new color can be created the following way:; 97 ; 98~~~ {.cpp}; 99 Int_t ci = 1756; // color index; 100 auto color = new TColor(ci",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
Integrability,depend,dependency,". ROOT: core/base/inc/TColor.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; TColor.h File Reference. #include ""TNamed.h""; #include <vector>. Include dependency graph for TColor.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TColor;  The color creation and management class. More...;  . Enumerations; enum  EColorPalette { ;   kDeepSea =51; , kGreyScale =52; , kDarkBodyRadiator =53; , kBlueYellow = 54; , ;   kRainBow =55; , kInvertedDarkBodyRadiator =56; , kBird =57; , kCubehelix =58; , ;   kGreenRedViolet =59; , kBlueRedYellow =60; , kOcean =61; , kColorPrintableOnGrey =62; , ;   kAlpine =63; , kAquamarine =64; , kArmy =65; , kAtlantic =66; , ;   kAurora =67; , kAvocado =68; , kBeach =69; , kBlackBody =70; , ;   kBlueGreenYellow =71; , kBrownCyan =72; , kCMYK =73; , kCandy =74; , ;   kCherry =75; , kCoffee =76; , kDarkRainBow =77; , kDarkTerrain =78; , ;   kFall =79; , kFruitPunch =80; , kFuchsia =81; , kGreyYellow =82; , ;   kGreenBrownTerrain =83; , kGreenPink =84; , kIsland =85; , kLake =86; , ;   kLightTemperature =87; , kLightTerrain =88; , kMint =89; , kNeon =90; , ;   kPastel =91; , kPearl =92; , kPigeon =93; , kPlum =94; , ;   kRedBlue =95; , kRose =96; , kRust =97; , kSandyTerrain =98; , ;   kSienna =99; , kSolar =100; , kSouthWest =101; , kStarryNight =102; , ;   kSunset =103; , kTemperatureMap =104; , kThermometer =105; , kValentine =106; , ;   kVisibleSpectrum =107; , kWaterMelon =108; , kCool =109; , kCopper =110; , ;   kGistEarth =111; , kViridis =112; , kCividis =113; , kRainbow =kRainBow; , ;   kDarkRainbow =kDarkRainBow. };  . Enumeration Type Documentation. ◆ EColorPalette. enum EColorPalette. EnumeratorkDeepSea ; kGreyScale ; kDarkBodyRadiator ; kBlueYellow ; kRa",MatchSource.WIKI,doc/master/TColor_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8h.html
Integrability,depend,dependent,"ientstatic Int_t GetRadialGradient(Double_t r, const std::vector< Int_t > &colors, const std::vector< Double_t > &positions={})Static function: Returns the radial gradient color number corresponding to specified parameters.Definition TColor.cxx:2287; TColor::GetColorPalettestatic Int_t GetColorPalette(Int_t i)Static function returning the color number i in current palette.Definition TColor.cxx:1504; TColor::GetPalettestatic const TArrayI & GetPalette()Static function returning the current active palette.Definition TColor.cxx:1516; TColor::GetRedFloat_t GetRed() constDefinition TColor.h:60; TColor::lsvoid ls(Option_t *option="""") const overrideList this color with its attributes.Definition TColor.cxx:1698; TColor::SaveColorstatic Bool_t SaveColor(std::ostream &out, Int_t ci)Save a color with index > 228 as a C++ statement(s) on output stream out.Definition TColor.cxx:2543; TColor::fLightFloat_t fLightLight.Definition TColor.h:29; TColor::RGB2Pixelstatic ULong_t RGB2Pixel(Int_t r, Int_t g, Int_t b)Convert r,g,b to graphics system dependent pixel value.Definition TColor.cxx:2475; TColor::Number2Pixelstatic ULong_t Number2Pixel(Int_t ci)Static method that given a color index number, returns the corresponding pixel value.Definition TColor.cxx:2437; TColor::RGB2HSVstatic void RGB2HSV(Float_t r, Float_t g, Float_t b, Float_t &h, Float_t &s, Float_t &v)Static method to compute HSV from RGB.Definition TColor.cxx:1771; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",...Definition TColor.cxx:1920; TColor::InitializeColorsstatic void InitializeColors()Initialize colors used by the TCanvas based graphics (via TColor objects).Definition TColor.cxx:1167; TColor::HSV2RGBstatic void HSV2RGB(Float_t h, Float_t s, Float_t v, Float_t &r, Float_t &g, Float_t &b)Static method to compute RGB from HSV:Definition TColor.cxx:1642; TColor::fAlphaFloat_t fAlphaAlpha (transparency)Definition",MatchSource.WIKI,doc/master/TColor_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8h_source.html
Deployability,release,released,"; 124{; 125 if (!gPad) return 9999;; 126 // Compute distance of point to center of arc; 127 Int_t pxc = gPad->XtoAbsPixel(fX1);; 128 Int_t pyc = gPad->YtoAbsPixel(fY1);; 129 Double_t dist = TMath::Sqrt(Long64_t(pxc-px)*(pxc-px)+Long64_t(pyc-py)*(pyc-py));; 130 Double_t cosa = (px - pxc)/dist;; 131 Double_t sina = (pyc - py)/dist;; 132 Double_t phi = TMath::ATan2(sina,cosa);; 133 if (phi < 0) phi += 2 * TMath::Pi();; 134 phi = phi * 180 / TMath::Pi();; 135 if (fPhimax > fPhimin){; 136 if (phi < fPhimin || phi > fPhimax) return 9999;; 137 } else {; 138 if (phi > fPhimin && phi < fPhimax) return 9999;; 139 }; 140 Int_t pxr = gPad->XtoPixel(fR1)- gPad->XtoPixel(0);; 141 Double_t distr = TMath::Abs(dist-pxr);; 142 return Int_t(distr);; 143}; 144 ; 145////////////////////////////////////////////////////////////////////////////////; 146/// Execute action corresponding to one event.; 147///; 148/// This member function is called when a TCurlyArc is clicked with the locator; 149///; 150/// If Left button clicked on one of the line end points, this point; 151/// follows the cursor until button is released.; 152///; 153/// if Middle button clicked, the line is moved parallel to itself; 154/// until the button is released.; 155 ; 156void TCurlyArc::ExecuteEvent(Int_t event, Int_t px, Int_t py); 157{; 158 if (!gPad) return;; 159 ; 160 Int_t kMaxDiff = 10;; 161 const Int_t np = 10;; 162 const Double_t pi = TMath::Pi();; 163 static Int_t x[np+3], y[np+3];; 164 static Int_t px1,py1,npe,r1;; 165 static Int_t pxold, pyold;; 166 Int_t i, dpx, dpy;; 167 Double_t angle,dx,dy,dphi,rLx,rRx;; 168 Double_t phi0;; 169 static Bool_t pTop, pL, pR, pBot, pINSIDE;; 170 static Int_t pTx,pTy,pLx,pLy,pRx,pRy,pBx,pBy;; 171 ; 172 Bool_t opaque = gPad->OpaqueMoving();; 173 ; 174 switch (event) {; 175 ; 176 case kArrowKeyPress:; 177 case kButton1Down:; 178 if (!opaque) {; 179 gVirtualX->SetLineColor(-1);; 180 TAttLine::Modify();; 181 dphi = (fPhimax-fPhimin) * pi / 180;; 182 if (dphi<0) dphi += 2 * pi;",MatchSource.WIKI,doc/master/TCurlyArc_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCurlyArc_8cxx_source.html
Modifiability,inherit,inheritance,". ROOT: graf2d/graf/src/TCurlyArc.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TCurlyArc.cxx. Go to the documentation of this file. 1// @(#)root/graf:$Id$; 2// Author: Otto Schaile 20/11/99; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TCurlyArc; 13\ingroup BasicGraphics; 14 ; 15Implements curly or wavy arcs used to draw Feynman diagrams.; 16 ; 17Amplitudes and wavelengths may be specified in the constructors,; 18via commands or interactively from popup menus.; 19The class make use of TCurlyLine by inheritance, ExecuteEvent methods; 20are highly inspired from the methods used in TPolyLine and TArc.; 21The picture below has been generated by the tutorial feynman.; 22 ; 23Begin_Macro(source); 24../../../tutorials/graphics/feynman.C; 25End_Macro; 26*/; 27 ; 28#include <iostream>; 29#include ""TCurlyArc.h""; 30#include ""TROOT.h""; 31#include ""TVirtualPad.h""; 32#include ""TVirtualX.h""; 33#include ""TMath.h""; 34#include ""TPoint.h""; 35 ; 36Double_t TCurlyArc::fgDefaultWaveLength = 0.02;; 37Double_t TCurlyArc::fgDefaultAmplitude = 0.01;; 38Bool_t TCurlyArc::fgDefaultIsCurly = kTRUE;; 39 ; 40ClassImp(TCurlyArc);; 41 ; 42////////////////////////////////////////////////////////////////////////////////; 43/// Default constructor; 44 ; 45TCurlyArc::TCurlyArc(); 46{; 47 fR1 = 0.;; 48 fPhimin = 0.;; 49 fPhimax = 0.;; 50 fTheta = 0.;; 51}; 52 ; 53////////////////////////////////////////////////////////////////////////////////; 54/// Create a new TCurlyArc with center (x1, y1) and radius rad.; 55/// The wavelength and amplitude are given in percent of the line length; 56/// phimin and phimax ar",MatchSource.WIKI,doc/master/TCurlyArc_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCurlyArc_8cxx_source.html
Deployability,release,released,"ath::ATan2(py2-py1, px2-px1);; 147 if (angle < 0) angle += 2*TMath::Pi();; 148 ; 149 Double_t cosang = TMath::Cos(angle);; 150 Double_t sinang = TMath::Sin(angle);; 151 Double_t xx, yy;; 152 ; 153 for(i = 0; i < fNsteps; i++){; 154 xx = xv[i] * cosang - yv[i] * sinang;; 155 yy = xv[i] * sinang + yv[i] * cosang;; 156 if (gPad) {; 157 xx *= pixeltoX;; 158 yy *= pixeltoY;; 159 }; 160 xv[i] = xx + fX1;; 161 yv[i] = yy + fY1;; 162 }; 163 if (gPad) gPad->Modified();; 164}; 165 ; 166////////////////////////////////////////////////////////////////////////////////; 167/// Compute distance from point px,py to a line.; 168 ; 169Int_t TCurlyLine::DistancetoPrimitive(Int_t px, Int_t py); 170{; 171 return DistancetoLine(px,py,fX1,fY1,fX2,fY2);; 172}; 173 ; 174////////////////////////////////////////////////////////////////////////////////; 175/// Execute action corresponding to one event.; 176///; 177/// This member function is called when a TCurlyLine is clicked with the locator; 178///; 179/// If Left button clicked on one of the line end points, this point; 180/// follows the cursor until button is released.; 181///; 182/// if Middle button clicked, the line is moved parallel to itself; 183/// until the button is released.; 184 ; 185void TCurlyLine::ExecuteEvent(Int_t event, Int_t px, Int_t py); 186{; 187 if (!gPad) return;; 188 ; 189 Int_t kMaxDiff = 20;; 190 static Int_t d1,d2,px1,px2,py1,py2;; 191 static Int_t pxold, pyold, px1old, py1old, px2old, py2old;; 192 static Bool_t p1, p2, pL;; 193 Int_t dx, dy;; 194 ; 195 Bool_t opaque = gPad->OpaqueMoving();; 196 ; 197 switch (event) {; 198 ; 199 case kArrowKeyPress:; 200 case kButton1Down:; 201 if (!opaque) {; 202 gVirtualX->SetLineColor(-1);; 203 TAttLine::Modify(); //Change line attributes only if necessary; 204 }; 205 ; 206 // No break !!!; 207 ; 208 case kMouseMotion:; 209 ; 210 px1 = gPad->XtoAbsPixel(fX1);; 211 py1 = gPad->YtoAbsPixel(fY1);; 212 px2 = gPad->XtoAbsPixel(fX2);; 213 py2 = gPad->YtoAbsPixel(fY2);; 214 ; 215 p1 ",MatchSource.WIKI,doc/master/TCurlyLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCurlyLine_8cxx_source.html
Modifiability,inherit,inheritance,". ROOT: graf2d/graf/src/TCurlyLine.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TCurlyLine.cxx. Go to the documentation of this file. 1// @(#)root/graf:$Id$; 2// Author: Otto Schaile 20/11/99; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TCurlyLine; 13\ingroup BasicGraphics; 14 ; 15Implements curly or wavy polylines used to draw Feynman diagrams.; 16 ; 17Amplitudes and wavelengths may be specified in the constructors,; 18via commands or interactively from popup menus.; 19The class make use of TPolyLine by inheritance, ExecuteEvent methods; 20are highly inspired from the methods used in TPolyLine and TArc.; 21The picture below has been generated by the tutorial feynman.; 22 ; 23Begin_Macro(source); 24../../../tutorials/graphics/feynman.C; 25End_Macro; 26*/; 27 ; 28#include ""TCurlyLine.h""; 29#include ""TROOT.h""; 30#include ""TVirtualPad.h""; 31#include ""TVirtualX.h""; 32#include ""TMath.h""; 33#include ""TPoint.h""; 34 ; 35#include <iostream>; 36 ; 37Double_t TCurlyLine::fgDefaultWaveLength = 0.02;; 38Double_t TCurlyLine::fgDefaultAmplitude = 0.01;; 39Bool_t TCurlyLine::fgDefaultIsCurly = kTRUE;; 40 ; 41ClassImp(TCurlyLine);; 42 ; 43////////////////////////////////////////////////////////////////////////////////; 44/// Default constructor.; 45 ; 46TCurlyLine::TCurlyLine(); 47{; 48 fX1 = 0.;; 49 fY1 = 0.;; 50 fX2 = 0.;; 51 fY2 = 0.;; 52 fWaveLength = 0.;; 53 fAmplitude = 0.;; 54 fIsCurly = fgDefaultIsCurly;; 55 fNsteps = 0;; 56}; 57 ; 58////////////////////////////////////////////////////////////////////////////////; 59/// Create a new TCurlyLine with starting point (x1, y1), end poi",MatchSource.WIKI,doc/master/TCurlyLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCurlyLine_8cxx_source.html
Usability,simpl,simply,,MatchSource.WIKI,doc/master/TCurlyLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCurlyLine_8cxx_source.html
Integrability,depend,dependency,". ROOT: graf2d/graf/inc/TCutG.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TCutG.h File Reference. #include ""TGraph.h"". Include dependency graph for TCutG.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TCutG;  Graphical cut class. More...;  . graf2dgrafincTCutG.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:16 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TCutG_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCutG_8h.html
Modifiability,variab,variable,"ching...; No Matches. TCutG.h. Go to the documentation of this file. 1// @(#)root/graf:$Id$; 2// Author: Rene Brun 16/05/97; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TCutG; 13#define ROOT_TCutG; 14 ; 15 ; 16#include ""TGraph.h""; 17 ; 18class TH2;; 19 ; 20class TCutG : public TGraph {; 21 ; 22protected:; 23 TString fVarX; ///< X variable; 24 TString fVarY; ///< Y variable; 25 TObject *fObjectX; ///<! pointer to an object corresponding to X; 26 TObject *fObjectY; ///<! pointer to an object corresponding to Y; 27 ; 28public:; 29 TCutG();; 30 TCutG(const TCutG &cutg);; 31 TCutG(const char *name, Int_t n=0);; 32 TCutG(const char *name, Int_t n, const Float_t *x, const Float_t *y);; 33 TCutG(const char *name, Int_t n, const Double_t *x, const Double_t *y);; 34 ~TCutG() override;; 35 ; 36 TCutG &operator=(const TCutG &);; 37 virtual Double_t Area() const;; 38 virtual void Center(Double_t &cx, Double_t &cy) const;; 39 TObject *GetObjectX() const {return fObjectX;}; 40 TObject *GetObjectY() const {return fObjectY;}; 41 const char *GetVarX() const {return fVarX.Data();}; 42 const char *GetVarY() const {return fVarY.Data();}; 43 virtual Double_t IntegralHist(TH2 *h, Option_t *option="""") const;; 44 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 45 virtual void SetObjectX(TObject *obj);; 46 virtual void SetObjectY(TObject *obj);; 47 virtual void SetVarX(const char *varx); // *MENU*; 48 virtual void SetVarY(const char *vary); // *MENU*; 49 ; 50 ClassDefOverride(TCutG,2) // A Graphical cut.; 51};; 52 ; 53#endif; h#define h(i)Definition RSha256.hxx:106; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdo",MatchSource.WIKI,doc/master/TCutG_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCutG_8h_source.html
Integrability,interface,interface,". ROOT: tree/dataframe/inc/ROOT/TDataFrame.hxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TDataFrame.hxx. Go to the documentation of this file. 1// Author: Enrico Guiraud, Danilo Piparo CERN 05/2018; 2 ; 3/*************************************************************************; 4 * Copyright (C) 1995-2018, Rene Brun and Fons Rademakers. *; 5 * All rights reserved. *; 6 * *; 7 * For the licensing terms see $ROOTSYS/LICENSE. *; 8 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11#ifndef ROOT_TDATAFRAME; 12#define ROOT_TDATAFRAME; 13#include ""RDataFrame.hxx""; 14namespace ROOT {; 15 ; 16using TDataFrame = ROOT::RDataFrame;; 17 ; 18} // End NS ROOT; 19 ; 20#warning The TDataFrame.hxx header has been replaced by RDataFrame.hxx; 21 ; 22#endif; RDataFrame.hxx; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. treedataframeincROOTTDataFrame.hxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:02 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TDataFrame_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDataFrame_8hxx_source.html
Integrability,depend,dependency,". ROOT: core/meta/inc/TDataType.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; TDataType.h File Reference. #include ""TDictionary.h"". Include dependency graph for TDataType.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TDataType;  Basic data type descriptor (datatype information is obtained from CINT). More...;  . Enumerations; enum  EDataType { ;   kChar_t = 1; , kUChar_t = 11; , kShort_t = 2; , kUShort_t = 12; , ;   kInt_t = 3; , kUInt_t = 13; , kLong_t = 4; , kULong_t = 14; , ;   kFloat_t = 5; , kDouble_t = 8; , kDouble32_t = 9; , kchar = 10; , ;   kBool_t = 18; , kLong64_t = 16; , kULong64_t = 17; , kOther_t = -1; , ;   kNoType_t = 0; , kFloat16_t = 19; , kCounter = 6; , kCharStar = 7; , ;   kBits = 15; , kVoid_t = 20; , kDataTypeAliasUnsigned_t = 21; , kDataTypeAliasSignedChar_t = 22; , ;   kNumDataTypes. };  . Enumeration Type Documentation. ◆ EDataType. enum EDataType. EnumeratorkChar_t ; kUChar_t ; kShort_t ; kUShort_t ; kInt_t ; kUInt_t ; kLong_t ; kULong_t ; kFloat_t ; kDouble_t ; kDouble32_t ; kchar ; kBool_t ; kLong64_t ; kULong64_t ; kOther_t ; kNoType_t ; kFloat16_t ; kCounter ; kCharStar ; kBits ; kVoid_t ; kDataTypeAliasUnsigned_t ; kDataTypeAliasSignedChar_t ; kNumDataTypes . Definition at line 28 of file TDataType.h. coremetaincTDataType.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TDataType_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDataType_8h.html
Availability,error,error," to GMT,; 174/// as in this example:; 175/// ~~~ {.cpp}; 176/// TDatime now;; 177/// now.Set(now.Convert(kTRUE));; 178/// ~~~; 179/// Caution: the time_t returned from Convert(kTRUE) is incompatible with; 180/// regular Unix time - it contains an artificial, locale-dependent offset.; 181 ; 182UInt_t TDatime::Convert(Bool_t toGMT) const; 183{; 184 UInt_t year = fDatime>>26;; 185 UInt_t month = (fDatime<<6)>>28;; 186 UInt_t day = (fDatime<<10)>>27;; 187 UInt_t hour = (fDatime<<15)>>27;; 188 UInt_t min = (fDatime<<20)>>26;; 189 UInt_t sec = (fDatime<<26)>>26;; 190 ; 191 struct tm tp;; 192 tp.tm_year = year+95;; 193 tp.tm_mon = month-1;; 194 tp.tm_mday = day;; 195 tp.tm_hour = hour;; 196 tp.tm_min = min;; 197 tp.tm_sec = sec;; 198 tp.tm_isdst = -1;; 199 ; 200 time_t t = mktime(&tp);; 201 if ((int)t == -1) {; 202 Error(""TDatime::Convert"", ""error converting fDatime to time_t"");; 203 return 0;; 204 }; 205 if (toGMT) {; 206#ifndef WIN32; 207 struct tm tg;; 208 struct tm *tgp = gmtime_r(&t, &tg);; 209#else; 210 struct tm *tgp = gmtime(&t);; 211#endif; 212 tgp->tm_isdst = -1;; 213 t = mktime(tgp);; 214 }; 215 return (UInt_t)t;; 216}; 217 ; 218////////////////////////////////////////////////////////////////////////////////; 219/// Copy this to datime.; 220 ; 221void TDatime::Copy(TDatime &datime) const; 222{; 223 datime.fDatime = fDatime;; 224}; 225 ; 226////////////////////////////////////////////////////////////////////////////////; 227/// Encode Date/Time into buffer, used by I/O system.; 228 ; 229void TDatime::FillBuffer(char *&buffer); 230{; 231 tobuf(buffer, fDatime);; 232}; 233 ; 234////////////////////////////////////////////////////////////////////////////////; 235/// Return raw date/time as encoded by TDatime. Note, this value cannot; 236/// be used to e.g. calculate time differences, as it is an encoded value.; 237/// To calculate time differences use the Convert() method to get a time; 238/// in seconds and then subtract the values.; 239 ; 240UInt_t TDatime::Get() ",MatchSource.WIKI,doc/master/TDatime_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDatime_8cxx_source.html
Energy Efficiency,allocate,allocated,"ur, Int_t min, Int_t sec); 70{; 71 Set(year, month, day, hour, min, sec);; 72}; 73 ; 74////////////////////////////////////////////////////////////////////////////////; 75/// Expects as input a string in SQL date/time compatible format, like:; 76/// yyyy-mm-dd hh:mm:ss.; 77 ; 78TDatime::TDatime(const char *sqlDateTime); 79{; 80 Set(sqlDateTime);; 81}; 82 ; 83////////////////////////////////////////////////////////////////////////////////; 84/// Returns day of week, with Monday being day 1 and Sunday day 7.; 85 ; 86Int_t TDatime::GetDayOfWeek() const; 87{; 88 static TString weekDays[7] = { ""Mon"", ""Tue"", ""Wed"", ""Thu"", ""Fri"", ""Sat"", ""Sun"" };; 89 TString wd = AsString();; 90 int day;; 91 for (day = 0; day < 7; day++) {; 92 if (wd(0, 3) == weekDays[day]); 93 break;; 94 }; 95 return (day < 7) ? day+1: -1;; 96}; 97 ; 98////////////////////////////////////////////////////////////////////////////////; 99/// Return the date & time as a string (ctime() format).; 100/// Copy result because it points to a statically allocated string.; 101 ; 102const char *TDatime::AsString() const; 103{; 104 time_t t = Convert();; 105 char *retStr = ctime(&t);; 106 if (retStr) {; 107 *(retStr + 24) = 0;; 108 return retStr;; 109 } else {; 110 static const char *defaulttime = ""15/06/96"";; 111 Error(""TDatime::AsString"", ""could not get time string"");; 112 return defaulttime;; 113 }; 114}; 115 ; 116////////////////////////////////////////////////////////////////////////////////; 117/// Return the date & time as a string (ctime() format).; 118/// Result is copied into out (and out is returned). Make sure; 119/// out can at least contain 26 characters. Thread safe.; 120 ; 121const char *TDatime::AsString(char *out) const; 122{; 123 time_t t = Convert();; 124#ifndef WIN32; 125#if defined(R__SOLARIS) && (_POSIX_C_SOURCE - 0 < 199506L); 126 char *retStr = ctime_r(&t, out, 26);; 127#else; 128 char *retStr = ctime_r(&t, out);; 129#endif; 130#else; 131 char *retStr = ctime(&t);; 132#endif; 133 if (retStr) {;",MatchSource.WIKI,doc/master/TDatime_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDatime_8cxx_source.html
Integrability,depend,dependent,"g() const; 153{; 154 static char sqldate[20];; 155 ; 156 UInt_t year = fDatime>>26;; 157 UInt_t month = (fDatime<<6)>>28;; 158 UInt_t day = (fDatime<<10)>>27;; 159 UInt_t hour = (fDatime<<15)>>27;; 160 UInt_t min = (fDatime<<20)>>26;; 161 UInt_t sec = (fDatime<<26)>>26;; 162 ; 163 snprintf(sqldate,20, ""%04d-%02d-%02d %02d:%02d:%02d"", (year+1995), month, day,; 164 hour, min, sec);; 165 ; 166 return sqldate;; 167}; 168 ; 169////////////////////////////////////////////////////////////////////////////////; 170/// Convert fDatime from TDatime format to the standard time_t format.; 171/// If toGMT is true, the time offset of the current local time zone is; 172/// subtracted from the returned time_t. One use of such a non-standard time_t; 173/// value is to convert a TDatime object that contains local time to GMT,; 174/// as in this example:; 175/// ~~~ {.cpp}; 176/// TDatime now;; 177/// now.Set(now.Convert(kTRUE));; 178/// ~~~; 179/// Caution: the time_t returned from Convert(kTRUE) is incompatible with; 180/// regular Unix time - it contains an artificial, locale-dependent offset.; 181 ; 182UInt_t TDatime::Convert(Bool_t toGMT) const; 183{; 184 UInt_t year = fDatime>>26;; 185 UInt_t month = (fDatime<<6)>>28;; 186 UInt_t day = (fDatime<<10)>>27;; 187 UInt_t hour = (fDatime<<15)>>27;; 188 UInt_t min = (fDatime<<20)>>26;; 189 UInt_t sec = (fDatime<<26)>>26;; 190 ; 191 struct tm tp;; 192 tp.tm_year = year+95;; 193 tp.tm_mon = month-1;; 194 tp.tm_mday = day;; 195 tp.tm_hour = hour;; 196 tp.tm_min = min;; 197 tp.tm_sec = sec;; 198 tp.tm_isdst = -1;; 199 ; 200 time_t t = mktime(&tp);; 201 if ((int)t == -1) {; 202 Error(""TDatime::Convert"", ""error converting fDatime to time_t"");; 203 return 0;; 204 }; 205 if (toGMT) {; 206#ifndef WIN32; 207 struct tm tg;; 208 struct tm *tgp = gmtime_r(&t, &tg);; 209#else; 210 struct tm *tgp = gmtime(&t);; 211#endif; 212 tgp->tm_isdst = -1;; 213 t = mktime(tgp);; 214 }; 215 return (UInt_t)t;; 216}; 217 ; 218///////////////////////////////////////",MatchSource.WIKI,doc/master/TDatime_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDatime_8cxx_source.html
Modifiability,portab,portable,"ce Guide ; .  . Loading...; Searching...; No Matches. TDatime.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Rene Brun 05/01/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TDatime; 13\ingroup Base; 14 ; 15This class stores the date and time with a precision of one second; 16in an unsigned 32 bit word (950130 124559).; 17The date is stored with the origin being the 1st January 1995.; 18 ; 19This class has no support for time zones. The time is assumed; 20to be in the local time of the machine where the object was created.; 21As a result, TDatime objects are not portable between machines; 22operating in different time zones and unsuitable for storing the; 23date/time of data taking events and the like. If absolute time is; 24required, use TTimeStamp.; 25*/; 26 ; 27#include <ROOT/RConfig.hxx>; 28 ; 29#include <ctime>; 30 ; 31#ifdef WIN32; 32#include ""Windows4Root.h""; 33#include <string.h>; 34#endif; 35 ; 36#include ""TBuffer.h""; 37#include ""Strlen.h""; 38#include ""snprintf.h""; 39#include ""TDatime.h""; 40#include ""TError.h""; 41#include ""Bytes.h""; 42#include ""TString.h""; 43 ; 44 ; 45ClassImp(TDatime);; 46 ; 47////////////////////////////////////////////////////////////////////////////////; 48/// Create a TDatime and set it to the current time.; 49 ; 50TDatime::TDatime(); 51{; 52 Set();; 53}; 54 ; 55////////////////////////////////////////////////////////////////////////////////; 56/// Create a TDatime and set it to the specified date and time.; 57/// See Set(Int_t, Int_t) about the date, time format.; 58 ; 59TDatime::TDatime(Int_t date, Int_t time); 60{; 61 Set(date, time);; 62}; 63 ; 64////////////",MatchSource.WIKI,doc/master/TDatime_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDatime_8cxx_source.html
Safety,safe,safe,"9 TString wd = AsString();; 90 int day;; 91 for (day = 0; day < 7; day++) {; 92 if (wd(0, 3) == weekDays[day]); 93 break;; 94 }; 95 return (day < 7) ? day+1: -1;; 96}; 97 ; 98////////////////////////////////////////////////////////////////////////////////; 99/// Return the date & time as a string (ctime() format).; 100/// Copy result because it points to a statically allocated string.; 101 ; 102const char *TDatime::AsString() const; 103{; 104 time_t t = Convert();; 105 char *retStr = ctime(&t);; 106 if (retStr) {; 107 *(retStr + 24) = 0;; 108 return retStr;; 109 } else {; 110 static const char *defaulttime = ""15/06/96"";; 111 Error(""TDatime::AsString"", ""could not get time string"");; 112 return defaulttime;; 113 }; 114}; 115 ; 116////////////////////////////////////////////////////////////////////////////////; 117/// Return the date & time as a string (ctime() format).; 118/// Result is copied into out (and out is returned). Make sure; 119/// out can at least contain 26 characters. Thread safe.; 120 ; 121const char *TDatime::AsString(char *out) const; 122{; 123 time_t t = Convert();; 124#ifndef WIN32; 125#if defined(R__SOLARIS) && (_POSIX_C_SOURCE - 0 < 199506L); 126 char *retStr = ctime_r(&t, out, 26);; 127#else; 128 char *retStr = ctime_r(&t, out);; 129#endif; 130#else; 131 char *retStr = ctime(&t);; 132#endif; 133 if (retStr) {; 134 *(retStr + 24) = 0;; 135#ifdef WIN32; 136 strcpy(out, retStr);; 137#endif; 138 return retStr;; 139 } else {; 140 static const char *defaulttime = ""15/06/96"";; 141 strcpy(out, defaulttime);; 142 Error(""TDatime::AsString"", ""could not get time string"");; 143 return defaulttime;; 144 }; 145}; 146 ; 147////////////////////////////////////////////////////////////////////////////////; 148/// Return the date & time in SQL compatible string format, like:; 149/// 1997-01-15 20:16:28. The returned string buffer is static and; 150/// will be reused.; 151 ; 152const char *TDatime::AsSQLString() const; 153{; 154 static char sqldate[20];; 155 ; 156 UIn",MatchSource.WIKI,doc/master/TDatime_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDatime_8cxx_source.html
Modifiability,portab,portable,"***********************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TDatime; 13#define ROOT_TDatime; 14 ; 15#include <string>; 16 ; 17//////////////////////////////////////////////////////////////////////////; 18// //; 19// TDatime //; 20// //; 21// This class stores the date and time with a precision of one second //; 22// in an unsigned 32 bit word (e.g. 950130 124559). The date is stored //; 23// with the origin being the 1st january 1995. //; 24// //; 25// This class has no support for time zones. The time is assumed //; 26// to be in the local time of the machine where the object was created. //; 27// As a result, TDatime objects are not portable between machines //; 28// operating in different time zones and unsuitable for storing the //; 29// date/time of data taking events and the like. If absolute time is //; 30// required, use TTimeStamp. //; 31// //; 32//////////////////////////////////////////////////////////////////////////; 33 ; 34#include ""Rtypes.h""; 35 ; 36 ; 37class TDatime {; 38 ; 39private:; 40 ; 41protected:; 42 UInt_t fDatime; //Date (relative to 1995) + time; 43 ; 44public:; 45 TDatime();; 46 TDatime(const TDatime &d): fDatime(d.fDatime) { }; 47 TDatime(UInt_t tloc, Bool_t dosDate = kFALSE): fDatime(0); 48 { Set(tloc, dosDate); }; 49 TDatime(Int_t date, Int_t time);; 50 TDatime(Int_t year, Int_t month, Int_t day,; 51 Int_t hour, Int_t min, Int_t sec);; 52 TDatime(const char *sqlDateTime);; 53 virtual ~TDatime() { }; 54 ; 55 TDatime& operator=(const TDatime &d);; 56 ; 57 const char *AsString() const;; 58 const char *AsString(char *out) const;; 59 const char *AsSQLString() const;; 60 UInt_t Convert(Bool_t toGMT = kFALSE) const;; 61 void Copy(TDatime &datime",MatchSource.WIKI,doc/master/TDatime_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDatime_8h_source.html
Integrability,depend,dependency,". ROOT: core/meta/inc/TDictionary.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Enumerations ; TDictionary.h File Reference. #include ""TNamed.h""; #include ""ESTLType.h"". Include dependency graph for TDictionary.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TDictionary;  This class defines an abstract interface that must be implemented by all classes that contain dictionary information. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Enumerations; enum  EClassProperty { ;   kClassIsValid = 0x00000001; , kClassHasExplicitCtor = 0x00000010; , kClassHasImplicitCtor = 0x00000020; , kClassHasCtor = 0x00000030; , ;   kClassHasDefaultCtor = 0x00000040; , kClassHasAssignOpr = 0x00000080; , kClassHasExplicitDtor = 0x00000100; , kClassHasImplicitDtor = 0x00000200; , ;   kClassHasDtor = 0x00000300; , kClassHasVirtual = 0x00001000; , kClassIsAbstract = 0x00002000; , kClassIsAggregate = 0x00004000. };  ; enum  ROOT::EFunctionMatchMode { ROOT::kExactMatch = 0; , ROOT::kConversionMatch = 1; };  ; enum  EFunctionProperty { ;   kIsConstructor = 0x00000001; , kIsConversion = 0x00000002; , kIsDestructor = 0x00000004; , kIsOperator = 0x00000008; , ;   kIsInlined = 0x00000010; , kIsTemplateSpec = 0x00000020. };  ; enum  EProperty { ;   kIsClass = 0x00000001; , kIsStruct = 0x00000002; , kIsUnion = 0x00000004; , kIsEnum = 0x00000008; , ;   kIsTypedef = 0x00000010; , kIsFundamental = 0x00000020; , kIsAbstract = 0x00000040; , kIsVirtual = 0x00000080; , ;   kIsPureVirtual = 0x00000100; , kIsUnionMember = 0x00000100; , kIsPublic = 0x00000200; , kIsProtec",MatchSource.WIKI,doc/master/TDictionary_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDictionary_8h.html
Availability,avail,available,"t;; 61class TypedefInfo_t;; 62class TDictAttributeMap;; 63 ; 64enum EProperty {; 65 kIsClass = 0x00000001,; 66 kIsStruct = 0x00000002,; 67 kIsUnion = 0x00000004,; 68 kIsEnum = 0x00000008,; 69 kIsTypedef = 0x00000010,; 70 kIsFundamental = 0x00000020,; 71 kIsAbstract = 0x00000040,; 72 kIsVirtual = 0x00000080,; 73 kIsPureVirtual = 0x00000100,; 74 kIsUnionMember = 0x00000100,; 75 kIsPublic = 0x00000200,; 76 kIsProtected = 0x00000400,; 77 kIsPrivate = 0x00000800,; 78 kIsPointer = 0x00001000,; 79 kIsArray = 0x00002000,; 80 kIsStatic = 0x00004000,; 81 kIsDefault = 0x00008000,; 82 kIsReference = 0x00010000,; 83 kIsDirectInherit = 0x00020000,; 84 kIsCCompiled = 0x00040000,; 85 kIsCPPCompiled = kIsCCompiled,; 86 kIsCompiled = kIsCCompiled,; 87 kIsNotReacheable = 0x00080000, // Indicate that the entity can not be used from the Global Namespace; 88 kIsConstant = 0x00100000,; 89 kIsVirtualBase = 0x00200000,; 90 kIsConstPointer = 0x00400000,; 91 kIsScopedEnum = 0x00800000,; 92 // 0x01000000 is available; 93 kIsConstexpr = 0x02000000,; 94 kIsExplicit = 0x04000000,; 95 kIsNamespace = 0x08000000,; 96 kIsConstMethod = 0x10000000,; 97 kIsUsing = 0x20000000,; 98 kIsDefinedInStd = 0x40000000; 99 // 0x80000000 is available; 100};; 101 ; 102enum EFunctionProperty {; 103/* The following are already defined; 104 in EProperty and 'could' be part of this enums */; 105/*; 106 kIsAbstract = 0x00000040,; 107 kIsVirtual = 0x00000080,; 108 kIsPureVirtual = 0x00000100,; 109 kIsPublic = 0x00000200,; 110 kIsProtected = 0x00000400,; 111 kIsPrivate = 0x00000800,; 112 kIsStatic = 0x00004000,; 113 kIsDefault = 0x00008000,; 114 kIsConstexpr = 0x02000000; 115 kIsExplicit = 0x04000000,; 116 kIsConstMethod = 0x10000000,; 117*/; 118/* The following are already defined; 119 in EProperty and related to the type of the return value */; 120/*; 121 kIsConstant = 0x00100000,; 122 kIsPointer = 0x00001000,; 123 kIsArray = 0x00002000,; 124 kIsReference = 0x00010000,; 125 kIsConstPointer = 0x00400000,; 126*/; 127 kIsCo",MatchSource.WIKI,doc/master/TDictionary_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDictionary_8h_source.html
Deployability,update,updated," kIsReference = 0x00010000,; 125 kIsConstPointer = 0x00400000,; 126*/; 127 kIsConstructor = 0x00000001,; 128 kIsConversion = 0x00000002,; 129 kIsDestructor = 0x00000004,; 130 kIsOperator = 0x00000008,; 131 kIsInlined = 0x00000010,; 132 kIsTemplateSpec= 0x00000020; 133};; 134 ; 135enum EClassProperty {; 136 kClassIsValid = 0x00000001,; 137 kClassHasExplicitCtor = 0x00000010,; 138 kClassHasImplicitCtor = 0x00000020,; 139 kClassHasCtor = 0x00000030,; 140 kClassHasDefaultCtor = 0x00000040,; 141 kClassHasAssignOpr = 0x00000080,; 142 kClassHasExplicitDtor = 0x00000100,; 143 kClassHasImplicitDtor = 0x00000200,; 144 kClassHasDtor = 0x00000300,; 145 kClassHasVirtual = 0x00001000,; 146 kClassIsAbstract = 0x00002000,; 147 kClassIsAggregate = 0x00004000; 148};; 149 ; 150enum ERefTypeValues {; 151 kParaNormal = 0, // not used; 152 kParaReference = 1,; 153 kParaP2P = 2, // not used; 154 kParaP2P2P = 3, // not used; 155 kParaRef = 100,; 156 kParaRefP2P = 102, // not used; 157 kParaRefP2P2P = 103 // not used; 158};; 159 ; 160namespace ROOT {; 161 enum EFunctionMatchMode {; 162 kExactMatch = 0,; 163 kConversionMatch = 1; 164 };; 165}; 166 ; 167 ; 168class TDictionary : public TNamed {; 169 ; 170private:; 171 TDictAttributeMap *fAttributeMap{nullptr}; //pointer to a class attribute map; 172 ULong64_t fUpdatingTransactionCount{0}; //!the Cling ID of the transaction that last updated the object; 173 ; 174protected:; 175 Bool_t UpdateInterpreterStateMarker();; 176 ; 177public:; 178 TDictionary(): fAttributeMap(nullptr), fUpdatingTransactionCount(0) { }; 179 TDictionary(const char* name): TNamed(name, """"), fAttributeMap(nullptr), fUpdatingTransactionCount(0) { }; 180 TDictionary(const TDictionary& dict);; 181 virtual ~TDictionary();; 182 ; 183 TDictionary& operator=(const TDictionary& other);; 184 ; 185 void CreateAttributeMap();; 186 TDictAttributeMap *GetAttributeMap() const; 187 {; 188 //Get the TDictAttributeMap pointer to be able to add attribute; 189 //pairs key-value to the TClass.",MatchSource.WIKI,doc/master/TDictionary_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDictionary_8h_source.html
Integrability,interface,interface,". ROOT: core/meta/inc/TDictionary.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TDictionary.h. Go to the documentation of this file. 1// @(#)root/meta:$Id$; 2// Author: Fons Rademakers 20/06/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13#ifndef ROOT_TDictionary; 14#define ROOT_TDictionary; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TDictionary //; 19// //; 20// This class defines an abstract interface that must be implemented //; 21// by all classes that contain dictionary information. //; 22// //; 23// The dictionary is defined by the followling classes: //; 24// TDataType (typedef definitions) //; 25// TGlobal (global variables) //; 26// TFunction (global functions) //; 27// TClass (classes) //; 28// TBaseClass (base classes) //; 29// TDataMember (class datamembers) //; 30// TMethod (class methods) //; 31// TMethodArg (method arguments) //; 32// //; 33// All the above classes implement the TDictionary abstract interface //; 34// (note: the indentation shows aggregation not inheritance). //; 35// The ROOT dictionary system provides a very extensive RTTI //; 36// environment that facilitates a.o. object inspectors, object I/O, //; 37// ROOT Trees, etc. Most of the type information is provided by the //; 38// CINT C++ interpreter. //; 39// //; 40// TMethodCall (method call environment) //; 41// //; 42//////////////////////////////////////////////////////////////////////////; 43 ; 44#include ""TNamed.h""; 45 ; 46#include ""ESTLType.h""; 47 ; 48// The following are opaque type and are never really declared; 49// The specific impleme",MatchSource.WIKI,doc/master/TDictionary_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDictionary_8h_source.html
Modifiability,variab,variables,"meta:$Id$; 2// Author: Fons Rademakers 20/06/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13#ifndef ROOT_TDictionary; 14#define ROOT_TDictionary; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TDictionary //; 19// //; 20// This class defines an abstract interface that must be implemented //; 21// by all classes that contain dictionary information. //; 22// //; 23// The dictionary is defined by the followling classes: //; 24// TDataType (typedef definitions) //; 25// TGlobal (global variables) //; 26// TFunction (global functions) //; 27// TClass (classes) //; 28// TBaseClass (base classes) //; 29// TDataMember (class datamembers) //; 30// TMethod (class methods) //; 31// TMethodArg (method arguments) //; 32// //; 33// All the above classes implement the TDictionary abstract interface //; 34// (note: the indentation shows aggregation not inheritance). //; 35// The ROOT dictionary system provides a very extensive RTTI //; 36// environment that facilitates a.o. object inspectors, object I/O, //; 37// ROOT Trees, etc. Most of the type information is provided by the //; 38// CINT C++ interpreter. //; 39// //; 40// TMethodCall (method call environment) //; 41// //; 42//////////////////////////////////////////////////////////////////////////; 43 ; 44#include ""TNamed.h""; 45 ; 46#include ""ESTLType.h""; 47 ; 48// The following are opaque type and are never really declared; 49// The specific implementation of TInterpreter will cast the; 50// value of pointer to this types to the correct type (possibly; 51// distinct from these); 52class CallFunc_t;; 53class ClassInfo_t;; 54class BaseClassInf",MatchSource.WIKI,doc/master/TDictionary_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDictionary_8h_source.html
Availability,redundant,redundant," of RecursiveRemove (indirectly done; 84 // by 'Appending' this object to it's mother) before the object is completely; 85 // initialized.; 86 // However a better option would be to delay the publishing until the very end,; 87 // but it is currently done in the middle of the initialization (by Build which; 88 // is a public interface) ....; 89 R__LOCKGUARD(gROOTMutex);; 90 ; 91 fName = name;; 92 fTitle = title;; 93 ; 94 if (!initMotherDir) initMotherDir = gDirectory;; 95 ; 96 if (strchr(name,'/')) {; 97 ::Error(""TDirectoryFile"",""directory name (%s) cannot contain a slash"", name);; 98 gDirectory = nullptr;; 99 return;; 100 }; 101 if (strlen(GetName()) == 0) {; 102 ::Error(""TDirectoryFile"",""directory name cannot be \""\"""");; 103 gDirectory = nullptr;; 104 return;; 105 }; 106 ; 107 BuildDirectoryFile(initMotherDir ? initMotherDir->GetFile() : nullptr, initMotherDir);; 108 ; 109 TDirectory* motherdir = GetMotherDir();; 110 TFile* f = TDirectoryFile::GetFile();; 111 ; 112 if (!motherdir || !f) return;; 113 if (!f->IsWritable()) return; //*-* in case of a directory in memory; 114 if (motherdir->GetKey(name)) {; 115 Error(""TDirectoryFile"",""An object with name %s exists already"", name);; 116 return;; 117 }; 118 TClass *cl = nullptr;; 119 if (classname[0]) {; 120 cl = TClass::GetClass(classname);; 121 if (!cl) {; 122 Error(""TDirectoryFile"",""Invalid class name: %s"",classname);; 123 return;; 124 }; 125 } else {; 126 cl = TDirectoryFile::IsA();; 127 }; 128 ; 129 fBufferSize = 0;; 130 fWritable = kTRUE;; 131 ; 132 InitDirectoryFile(cl);; 133 ; 134 fModified = kFALSE;; 135 ; 136 // Temporarily redundant, see comment on lock early in the function.; 137 // R__LOCKGUARD(gROOTMutex);; 138 gROOT->GetUUIDs()->AddUUID(fUUID,this);; 139 // We should really be doing this now rather than in Build, see; 140 // comment at the start of the function.; 141 // if (initMotherDir && strlen(GetName()) != 0) initMotherDir->Append(this);; 142}; 143 ; 144////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
Deployability,update,updates,"ject(key->GetName());; 1349 if (thing) { delete thing; }; 1350 key->ReadObj();; 1351 }; 1352}; 1353 ; 1354////////////////////////////////////////////////////////////////////////////////; 1355/// Read the linked list of keys.; 1356///; 1357/// Every directory has a linked list (fKeys). This linked list has been; 1358/// written on the file via WriteKeys as a single data record.; 1359///; 1360/// It is interesting to call this function in the following situation.; 1361/// Assume another process1 is connecting this directory in Update mode; 1362/// - Process1 is adding/updating objects in this directory; 1363/// - You want to see the latest status from process1.; 1364/// Example Process1:; 1365/// ~~~{.cpp}; 1366/// obj1.Write();; 1367/// obj2.Write();; 1368/// gDirectory->SaveSelf();; 1369/// ~~~; 1370///; 1371/// Example Process2:; 1372/// ~~~{.cpp}; 1373/// gDirectory->ReadKeys();; 1374/// obj1->Draw();; 1375/// ~~~; 1376/// This is an efficient way (without opening/closing files) to view; 1377/// the latest updates of a file being modified by another process; 1378/// as it is typically the case in a data acquisition system.; 1379 ; 1380Int_t TDirectoryFile::ReadKeys(Bool_t forceRead); 1381{; 1382 if (!fFile || !fKeys) return 0;; 1383 ; 1384 if (!fFile->IsBinary()); 1385 return fFile->DirReadKeys(this);; 1386 ; 1387 TDirectory::TContext ctxt(this);; 1388 ; 1389 char *buffer;; 1390 if (forceRead) {; 1391 fKeys->Delete();; 1392 //In case directory was updated by another process, read new; 1393 //position for the keys; 1394 Int_t nbytes = fNbytesName + TDirectoryFile::Sizeof();; 1395 char *header = new char[nbytes];; 1396 buffer = header;; 1397 fFile->Seek(fSeekDir);; 1398 if ( fFile->ReadBuffer(buffer,nbytes) ) {; 1399 // ReadBuffer return kTRUE in case of failure.; 1400 delete [] header;; 1401 return 0;; 1402 }; 1403 buffer += fNbytesName;; 1404 Version_t versiondir;; 1405 frombuf(buffer,&versiondir);; 1406 fDatimeC.ReadBuffer(buffer);; 1407 fDatimeM.ReadBuffer(buff",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
Energy Efficiency,allocate,allocated,"if (mom); 545 result = mom->GetDirectory(slash+1,printError,funcname);; 546 delete [] path; return result;; 547 }; 548 GetObject(subdir,obj);; 549 if (!obj) {; 550 if (printError) Error(funcname,""Unknown directory %s"", subdir.Data());; 551 delete [] path; return nullptr;; 552 }; 553 ; 554 result = ((TDirectory*)obj)->GetDirectory(slash+1,printError,funcname);; 555 delete [] path; return result;; 556}; 557 ; 558////////////////////////////////////////////////////////////////////////////////; 559/// Delete all objects from memory and directory structure itself.; 560 ; 561void TDirectoryFile::Close(Option_t *option); 562{; 563 if (!fList || !fSeekDir) {; 564 return;; 565 }; 566 ; 567 // Save the directory key list and header; 568 Save();; 569 ; 570 Bool_t nodelete = option ? (!strcmp(option, ""nodelete"") ? kTRUE : kFALSE) : kFALSE;; 571 ; 572 if (!nodelete) {; 573 Bool_t fast = kTRUE;; 574 TObjLink *lnk = fList->FirstLink();; 575 while (lnk) {; 576 if (lnk->GetObject()->IsA() == TDirectoryFile::Class()) {fast = kFALSE;break;}; 577 lnk = lnk->Next();; 578 }; 579 // Delete objects from directory list, this in turn, recursively closes all; 580 // sub-directories (that were allocated on the heap); 581 // if this dir contains subdirs, we must use the slow option for Delete!; 582 // we must avoid ""slow"" as much as possible, in particular Delete(""slow""); 583 // with a large number of objects (eg >10^5) would take for ever.; 584 {; 585 if (fast) fList->Delete();; 586 else fList->Delete(""slow"");; 587 }; 588 }; 589 ; 590 // Delete keys from key list (but don't delete the list header); 591 if (fKeys) {; 592 fKeys->Delete(""slow"");; 593 }; 594 ; 595 TDirectoryFile::CleanTargets();; 596}; 597 ; 598////////////////////////////////////////////////////////////////////////////////; 599/// Delete Objects or/and keys in a directory; 600///; 601/// Properties of the namecycle string:; 602/// - namecycle has the format name;cycle; 603/// - namecycle = """" is same as namecycle =""T*""; 604/// - ",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
Integrability,interface,interface,"///////////////////////////////////////////////; 70/// Create a new TDirectoryFile; 71///; 72/// A new directory with a name and a title is created in the current directory.; 73/// The directory header information is immediately saved on the file; 74/// A new key is added in the parent directory.; 75/// When this constructor is called from a class directly derived; 76/// from TDirectoryFile, the third argument, classname, MUST be specified.; 77/// In this case, classname must be the name of the derived class.; 78///; 79/// Note that the directory name cannot contain slashes.; 80 ; 81TDirectoryFile::TDirectoryFile(const char *name, const char *title, Option_t *classname, TDirectory* initMotherDir); 82{; 83 // We must not publish this objects to the list of RecursiveRemove (indirectly done; 84 // by 'Appending' this object to it's mother) before the object is completely; 85 // initialized.; 86 // However a better option would be to delay the publishing until the very end,; 87 // but it is currently done in the middle of the initialization (by Build which; 88 // is a public interface) ....; 89 R__LOCKGUARD(gROOTMutex);; 90 ; 91 fName = name;; 92 fTitle = title;; 93 ; 94 if (!initMotherDir) initMotherDir = gDirectory;; 95 ; 96 if (strchr(name,'/')) {; 97 ::Error(""TDirectoryFile"",""directory name (%s) cannot contain a slash"", name);; 98 gDirectory = nullptr;; 99 return;; 100 }; 101 if (strlen(GetName()) == 0) {; 102 ::Error(""TDirectoryFile"",""directory name cannot be \""\"""");; 103 gDirectory = nullptr;; 104 return;; 105 }; 106 ; 107 BuildDirectoryFile(initMotherDir ? initMotherDir->GetFile() : nullptr, initMotherDir);; 108 ; 109 TDirectory* motherdir = GetMotherDir();; 110 TFile* f = TDirectoryFile::GetFile();; 111 ; 112 if (!motherdir || !f) return;; 113 if (!f->IsWritable()) return; //*-* in case of a directory in memory; 114 if (motherdir->GetKey(name)) {; 115 Error(""TDirectoryFile"",""An object with name %s exists already"", name);; 116 return;; 117 }; 118 TClass *cl = nul",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
Modifiability,inherit,inherit,"changed appropriately; 367 // by a cd() or needs to be set to zero.; 368 if (gFile == this) {; 369 gFile = nullptr;; 370 }; 371 ; 372 TDirectory::CleanTargets();; 373}; 374 ; 375////////////////////////////////////////////////////////////////////////////////; 376/// Make a clone of an object using the Streamer facility.; 377///; 378/// If the object derives from TNamed, this function is called; 379/// by TNamed::Clone. TNamed::Clone uses the optional argument newname to set; 380/// a new name to the newly created object.; 381///; 382/// If autoadd is true and if the object class has a; 383/// DirectoryAutoAdd function, it will be called at the end of the; 384/// function with the parameter gDirectory. This usually means that; 385/// the object will be appended to the current ROOT directory.; 386 ; 387TObject *TDirectoryFile::CloneObject(const TObject *obj, Bool_t autoadd /* = kTRUE */); 388{; 389 // if no default ctor return immediately (error issued by New()); 390 char *pobj = (char*)obj->IsA()->New();; 391 if (!pobj) return nullptr;; 392 ; 393 Int_t baseOffset = obj->IsA()->GetBaseClassOffset(TObject::Class());; 394 if (baseOffset==-1) {; 395 // cl does not inherit from TObject.; 396 // Since this is not supported in this function, the only reason we could reach this code; 397 // is because something is screwed up in the ROOT code.; 398 Fatal(""CloneObject"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 399 obj->IsA()->GetName());; 400 }; 401 TObject *newobj = (TObject*)(pobj+baseOffset);; 402 ; 403 //create a buffer where the object will be streamed; 404 {; 405 // NOTE: do we still need to make this change to gFile?; 406 // NOTE: This can not be 'gDirectory=0' as at least roofit expect gDirectory to not be null; 407 // during the streaming ....; 408 TFile *filsav = gFile;; 409 gFile = nullptr;; 410 const Int_t bufsize = 10000;; 411 TBufferFile buffer(TBuffer::kWrite,bufsize);; 412 buffer.MapObject(obj); //register obj in map to handle self",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
Performance,perform,performed,"95 ; 996////////////////////////////////////////////////////////////////////////////////; 997/// Return pointer to object identified by namecycle.; 998///; 999/// The returned object may or may not derive from TObject.; 1000///; 1001/// - namecycle has the format name;cycle; 1002/// - name = * is illegal, cycle = * is illegal; 1003/// - cycle = """" or cycle = 9999 ==> apply to a memory object; 1004///; 1005/// ## Very important note; 1006/// The calling application must cast the returned object to; 1007/// the final type, e.g.; 1008///; 1009/// auto objPtr = (MyClass*)directory->GetObject(""some object of MyClass"");; 1010 ; 1011void *TDirectoryFile::GetObjectUnchecked(const char *namecycle); 1012{; 1013 return GetObjectChecked(namecycle,(TClass*)nullptr);; 1014}; 1015 ; 1016////////////////////////////////////////////////////////////////////////////////; 1017/// See documentation of TDirectoryFile::GetObjectCheck(const char *namecycle, const TClass *cl); 1018 ; 1019void *TDirectoryFile::GetObjectChecked(const char *namecycle, const char* classname); 1020{; 1021 return GetObjectChecked(namecycle,TClass::GetClass(classname));; 1022}; 1023 ; 1024 ; 1025////////////////////////////////////////////////////////////////////////////////; 1026/// Return pointer to object identified by namecycle if and only if the actual; 1027/// object is a type suitable to be stored as a pointer to a ""expectedClass""; 1028/// If expectedClass is null, no check is performed.; 1029///; 1030/// - namecycle has the format name;cycle; 1031/// - name = * is illegal, cycle = * is illegal; 1032/// - cycle = """" or cycle = 9999 ==> apply to a memory object; 1033///; 1034/// ### Very important note; 1035/// The calling application must cast the returned pointer to; 1036/// the type described by the 2 arguments (i.e. cl):; 1037///; 1038/// auto objPtr = (MyClass*)directory->GetObjectChecked(""some object of MyClass"",""MyClass""));; 1039///; 1040/// Note: We recommend using the method TDirectoryFile::Get<T>:; ",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
Safety,redund,redundant," of RecursiveRemove (indirectly done; 84 // by 'Appending' this object to it's mother) before the object is completely; 85 // initialized.; 86 // However a better option would be to delay the publishing until the very end,; 87 // but it is currently done in the middle of the initialization (by Build which; 88 // is a public interface) ....; 89 R__LOCKGUARD(gROOTMutex);; 90 ; 91 fName = name;; 92 fTitle = title;; 93 ; 94 if (!initMotherDir) initMotherDir = gDirectory;; 95 ; 96 if (strchr(name,'/')) {; 97 ::Error(""TDirectoryFile"",""directory name (%s) cannot contain a slash"", name);; 98 gDirectory = nullptr;; 99 return;; 100 }; 101 if (strlen(GetName()) == 0) {; 102 ::Error(""TDirectoryFile"",""directory name cannot be \""\"""");; 103 gDirectory = nullptr;; 104 return;; 105 }; 106 ; 107 BuildDirectoryFile(initMotherDir ? initMotherDir->GetFile() : nullptr, initMotherDir);; 108 ; 109 TDirectory* motherdir = GetMotherDir();; 110 TFile* f = TDirectoryFile::GetFile();; 111 ; 112 if (!motherdir || !f) return;; 113 if (!f->IsWritable()) return; //*-* in case of a directory in memory; 114 if (motherdir->GetKey(name)) {; 115 Error(""TDirectoryFile"",""An object with name %s exists already"", name);; 116 return;; 117 }; 118 TClass *cl = nullptr;; 119 if (classname[0]) {; 120 cl = TClass::GetClass(classname);; 121 if (!cl) {; 122 Error(""TDirectoryFile"",""Invalid class name: %s"",classname);; 123 return;; 124 }; 125 } else {; 126 cl = TDirectoryFile::IsA();; 127 }; 128 ; 129 fBufferSize = 0;; 130 fWritable = kTRUE;; 131 ; 132 InitDirectoryFile(cl);; 133 ; 134 fModified = kFALSE;; 135 ; 136 // Temporarily redundant, see comment on lock early in the function.; 137 // R__LOCKGUARD(gROOTMutex);; 138 gROOT->GetUUIDs()->AddUUID(fUUID,this);; 139 // We should really be doing this now rather than in Build, see; 140 // comment at the start of the function.; 141 // if (initMotherDir && strlen(GetName()) != 0) initMotherDir->Append(this);; 142}; 143 ; 144////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
Security,hash,hash,"TObject *obj, Bool_t replace /* = kFALSE */); 211{; 212 if (!obj || !fList) return;; 213 ; 214 TDirectory::Append(obj,replace);; 215 ; 216 if (!fMother) return;; 217 if (fMother->IsA() == TMapFile::Class()) {; 218 TMapFile *mfile = (TMapFile*)fMother;; 219 mfile->Add(obj);; 220 }; 221}; 222 ; 223////////////////////////////////////////////////////////////////////////////////; 224/// Insert key in the linked list of keys of this directory.; 225 ; 226Int_t TDirectoryFile::AppendKey(TKey *key); 227{; 228 if (!fKeys) {; 229 Error(""AppendKey"",""TDirectoryFile not initialized yet."");; 230 return 0;; 231 }; 232 ; 233 fModified = kTRUE;; 234 ; 235 key->SetMotherDir(this);; 236 ; 237 // This is a fast hash lookup in case the key does not already exist; 238 TKey *oldkey = (TKey*)fKeys->FindObject(key->GetName());; 239 if (!oldkey) {; 240 fKeys->Add(key);; 241 return 1;; 242 }; 243 ; 244 // If the key name already exists we have to make a scan for it; 245 // and insert the new key ahead of the current one; 246 TObjLink *lnk = fKeys->FirstLink();; 247 while (lnk) {; 248 oldkey = (TKey*)lnk->GetObject();; 249 if (!strcmp(oldkey->GetName(), key->GetName())); 250 break;; 251 lnk = lnk->Next();; 252 }; 253 ; 254 fKeys->AddBefore(lnk, key);; 255 return oldkey->GetCycle() + 1;; 256}; 257 ; 258////////////////////////////////////////////////////////////////////////////////; 259/// Browse the content of the directory.; 260 ; 261void TDirectoryFile::Browse(TBrowser *b); 262{; 263 TString name;; 264 ; 265 if (b) {; 266 TObject *obj = nullptr;; 267 TIter nextin(fList);; 268 TKey *key = nullptr, *keyo = nullptr;; 269 TIter next(fKeys);; 270 ; 271 cd();; 272 ; 273 //Add objects that are only in memory; 274 while ((obj = nextin())) {; 275 if (fKeys->FindObject(obj->GetName())) continue;; 276 b->Add(obj, obj->GetName());; 277 }; 278 ; 279 //Add keys; 280 while ((key = (TKey *) next())) {; 281 int skip = 0;; 282 if (!keyo || (keyo && strcmp(keyo->GetName(), key->GetName()))) {; 283 skip = 0;; 2",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
Testability,test,tests,"/; 25 ; 26#include <iostream>; 27#include ""Strlen.h""; 28#include ""strlcpy.h""; 29#include ""TDirectoryFile.h""; 30#include ""TFile.h""; 31#include ""TBufferFile.h""; 32#include ""TBufferJSON.h""; 33#include ""TMapFile.h""; 34#include ""TClassTable.h""; 35#include ""TInterpreter.h""; 36#include ""THashList.h""; 37#include ""TBrowser.h""; 38#include ""TFree.h""; 39#include ""TKey.h""; 40#include ""TStreamerInfo.h""; 41#include ""TROOT.h""; 42#include ""TError.h""; 43#include ""Bytes.h""; 44#include ""TClass.h""; 45#include ""TRegexp.h""; 46#include ""TSystem.h""; 47#include ""TStreamerElement.h""; 48#include ""TProcessUUID.h""; 49#include ""TVirtualMutex.h""; 50#include ""TEmulatedCollectionProxy.h""; 51 ; 52const UInt_t kIsBigFile = BIT(16);; 53const Int_t kMaxLen = 2048;; 54 ; 55ClassImp(TDirectoryFile);; 56 ; 57 ; 58////////////////////////////////////////////////////////////////////////////////; 59/// Default TDirectoryFile constructor; 60 ; 61TDirectoryFile::TDirectoryFile(); 62{; 63 /// Intentionally placed here; 64 /// when TDirectoryFile() = default; used, mac1014/cxx17 fails on some tests; 65 /// Problem with TObject::IsOnHeap() failing; 66}; 67 ; 68 ; 69////////////////////////////////////////////////////////////////////////////////; 70/// Create a new TDirectoryFile; 71///; 72/// A new directory with a name and a title is created in the current directory.; 73/// The directory header information is immediately saved on the file; 74/// A new key is added in the parent directory.; 75/// When this constructor is called from a class directly derived; 76/// from TDirectoryFile, the third argument, classname, MUST be specified.; 77/// In this case, classname must be the name of the derived class.; 78///; 79/// Note that the directory name cannot contain slashes.; 80 ; 81TDirectoryFile::TDirectoryFile(const char *name, const char *title, Option_t *classname, TDirectory* initMotherDir); 82{; 83 // We must not publish this objects to the list of RecursiveRemove (indirectly done; 84 // by 'Appending' this object ",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
Usability,simpl,simply,"already"",name);; 1259 return nullptr;; 1260 }; 1261 }; 1262 TDirectoryFile *newdir = nullptr;; 1263 if (const char *slash = strchr(name,'/')) {; 1264 TString workname(name, Long_t(slash-name));; 1265 TDirectoryFile *tmpdir = nullptr;; 1266 GetObject(workname.Data(), tmpdir);; 1267 if (!tmpdir) {; 1268 tmpdir = (TDirectoryFile*)mkdir(workname.Data(),title);; 1269 if (!tmpdir) return nullptr;; 1270 }; 1271 if (!newdir) newdir = tmpdir;; 1272 tmpdir->mkdir(slash+1);; 1273 return newdir;; 1274 }; 1275 ; 1276 TDirectory::TContext ctxt(this);; 1277 ; 1278 newdir = new TDirectoryFile(name, title, """", this);; 1279 ; 1280 return newdir;; 1281}; 1282 ; 1283////////////////////////////////////////////////////////////////////////////////; 1284/// Purge lowest key cycles in a directory.; 1285///; 1286/// By default, only the highest cycle of a key is kept. Keys for which; 1287/// the ""KEEP"" flag has been set are not removed. See TKey::Keep().; 1288/// NOTE: This does not reduce the size of a TFile--; 1289/// the space is simply freed up to be overwritten.; 1290 ; 1291void TDirectoryFile::Purge(Short_t); 1292{; 1293 if (!IsWritable()) return;; 1294 ; 1295 TDirectory::TContext ctxt(this);; 1296 ; 1297 TKey *key;; 1298 TIter prev(GetListOfKeys(), kIterBackward);; 1299 ; 1300 while ((key = (TKey*)prev())) { // reverse loop on keys; 1301 TKey *keyprev = (TKey*)GetListOfKeys()->Before(key);; 1302 if (!keyprev) break;; 1303 if (key->GetKeep() == 0) {; 1304 if (strcmp(key->GetName(), keyprev->GetName()) == 0) {; 1305 key->Delete(); // Remove from the file.; 1306 delete key; // Remove from memory.; 1307 }; 1308 }; 1309 }; 1310 TFile *f = GetFile();; 1311 if (fModified && f) {; 1312 WriteKeys(); // Write new keys structure; 1313 WriteDirHeader(); // Write new directory header; 1314 f->WriteFree(); // Write new free segments list; 1315 f->WriteHeader(); // Write new file header; 1316 }; 1317}; 1318 ; 1319////////////////////////////////////////////////////////////////////////////////; 1320/",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
Availability,error,error,"Wrapper_t)( m->InterfaceMethod() );; 345 }; 346 TBuffer::EMode mode = TBuffer::kWrite;; 347 Int_t size = 10000;; 348 void *args[] = { &mode, &size };; 349 TBuffer *result;; 350 creator(nullptr,2,args,&result);; 351 return result;; 352}; 353 ; 354////////////////////////////////////////////////////////////////////////////////; 355/// Clone an object.; 356/// This function is called when the directory is not a TDirectoryFile.; 357/// This version has to load the I/O package, hence via Cling.; 358///; 359/// If autoadd is true and if the object class has a; 360/// DirectoryAutoAdd function, it will be called at the end of the; 361/// function with the parameter gDirector. This usually means that; 362/// the object will be appended to the current ROOT directory.; 363 ; 364TObject *TDirectory::CloneObject(const TObject *obj, Bool_t autoadd /* = kTRUE */); 365{; 366 // if no default ctor return immediately (error issued by New()); 367 char *pobj = (char*)obj->IsA()->New();; 368 if (!pobj) {; 369 Fatal(""CloneObject"",""Failed to create new object"");; 370 return nullptr;; 371 }; 372 ; 373 Int_t baseOffset = obj->IsA()->GetBaseClassOffset(TObject::Class());; 374 if (baseOffset==-1) {; 375 // cl does not inherit from TObject.; 376 // Since this is not supported in this function, the only reason we could reach this code; 377 // is because something is screwed up in the ROOT code.; 378 Fatal(""CloneObject"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 379 obj->IsA()->GetName());; 380 }; 381 TObject *newobj = (TObject*)(pobj+baseOffset);; 382 ; 383 //create a buffer where the object will be streamed; 384 //We are forced to go via the I/O package (ie TBufferFile).; 385 //Invoking TBufferFile via CINT will automatically load the I/O library; 386 TBuffer *buffer = R__CreateBuffer();; 387 if (!buffer) {; 388 Fatal(""CloneObject"",""Not able to create a TBuffer!"");; 389 return nullptr;; 390 }; 391 buffer->MapObject(obj); //register obj in map to handle self referen",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
Deployability,update,update,"dDirectoryStatus(); 189{; 190 return fgAddDirectory;; 191}; 192 ; 193////////////////////////////////////////////////////////////////////////////////; 194/// Append object to this directory.; 195///; 196/// If `replace` is true:; 197/// remove any existing objects with the same name (if the name is not """"); 198 ; 199void TDirectory::Append(TObject *obj, Bool_t replace /* = kFALSE */); 200{; 201 if (!obj || !fList) return;; 202 ; 203 if (replace && obj->GetName() && obj->GetName()[0]) {; 204 TObject *old;; 205 while (nullptr != (old = GetList()->FindObject(obj->GetName()))) {; 206 Warning(""Append"",""Replacing existing %s: %s (Potential memory leak)."",; 207 obj->IsA()->GetName(),obj->GetName());; 208 ROOT::DirAutoAdd_t func = old->IsA()->GetDirectoryAutoAdd();; 209 if (func) {; 210 func(old,nullptr);; 211 } else {; 212 Remove(old);; 213 }; 214 }; 215 }; 216 ; 217 fList->Add(obj);; 218 // A priori, a `TDirectory` object is assumed to not have shared ownership.; 219 // If it is, let's rely on the user to update the bit.; 220 if (!dynamic_cast<TDirectory*>(obj)); 221 obj->SetBit(kMustCleanup);; 222}; 223 ; 224////////////////////////////////////////////////////////////////////////////////; 225/// Browse the content of the directory.; 226 ; 227void TDirectory::Browse(TBrowser *b); 228{; 229 if (b) {; 230 TObject *obj = nullptr;; 231 TIter nextin(fList);; 232 ; 233 cd();; 234 ; 235 //Add objects that are only in memory; 236 while ((obj = nextin())) {; 237 b->Add(obj, obj->GetName());; 238 }; 239 }; 240}; 241 ; 242////////////////////////////////////////////////////////////////////////////////; 243/// Initialise directory to defaults.; 244///; 245/// If directory is created via default ctor (when dir is read from file); 246/// don't add it here to the directory since its name is not yet known.; 247/// It will be added to the directory in TKey::ReadObj().; 248 ; 249void TDirectory::BuildDirectory(TFile* /*motherFile*/, TDirectory* motherDir); 250{; 251 fList = new THashList(1",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
Energy Efficiency,allocate,allocated,"emory and directory structure itself.; 641/// if option is ""slow"", iterate through the containers in a way to can handle; 642/// 'external' modification (induced by recursions); 643/// if option is ""nodelete"", write the TDirectory but do not delete the contained; 644/// objects.; 645void TDirectory::Close(Option_t *option); 646{; 647 if (!fList) {; 648 return;; 649 }; 650 ; 651 // Save the directory key list and header; 652 Save();; 653 ; 654 Bool_t nodelete = option ? (!strcmp(option, ""nodelete"") ? kTRUE : kFALSE) : kFALSE;; 655 ; 656 if (!nodelete) {; 657 Bool_t slow = option ? (!strcmp(option, ""slow"") ? kTRUE : kFALSE) : kFALSE;; 658 if (!slow) {; 659 // Check if it is wise to use the fast deletion path.; 660 TObjLink *lnk = fList->FirstLink();; 661 while (lnk) {; 662 if (lnk->GetObject()->IsA() == TDirectory::Class()) {; 663 slow = kTRUE;; 664 break;; 665 }; 666 lnk = lnk->Next();; 667 }; 668 }; 669 ; 670 // Delete objects from directory list, this in turn, recursively closes all; 671 // sub-directories (that were allocated on the heap); 672 // if this dir contains subdirs, we must use the slow option for Delete!; 673 // we must avoid ""slow"" as much as possible, in particular Delete(""slow""); 674 // with a large number of objects (eg >10^5) would take for ever.; 675 if (slow) fList->Delete(""slow"");; 676 else fList->Delete();; 677 }; 678 ; 679 TDirectory::CleanTargets();; 680}; 681 ; 682////////////////////////////////////////////////////////////////////////////////; 683/// Delete all objects from memory.; 684 ; 685void TDirectory::DeleteAll(Option_t *); 686{; 687 fList->Delete(""slow"");; 688}; 689 ; 690////////////////////////////////////////////////////////////////////////////////; 691/// Delete Objects or/and keys in a directory.; 692///; 693/// - namecycle has the format name;cycle; 694/// - namecycle = """" same as namecycle =""T*""; 695/// - name = * means all; 696/// - cycle = * means all cycles (memory and keys); 697/// - cycle = """" or cycle = 9999 ==> apply to",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
Integrability,depend,dependency,"!next || next == this) {; 301 if (this == ROOT::Internal::gROOTLocal) { /// in that case next == this.; 302 next = nullptr;; 303 } else {; 304 next = ROOT::Internal::gROOTLocal;; 305 }; 306 } else {; 307 // We can not use 'cd' as this would access the current thread; 308 // rather than the thread corresponding to that gDirectory.; 309 next->RegisterGDirectory(ptr);; 310 }; 311 // Actually do the update of the thread local gDirectory; 312 // using its object specific lock.; 313 auto This = this;; 314 ptr->compare_exchange_strong(This, next);; 315 }; 316 }; 317 }; 318 for(auto &&context : extraWait) {; 319 // Wait until the TContext is done spinning; 320 // over the lock.; 321 while(context->fActiveDestructor);; 322 // And now let the TContext destructor finish.; 323 context->fDirectoryWait = false;; 324 }; 325 ; 326 // Wait until all register attempts are done.; 327 while(fContextPeg) {}; 328 ; 329}; 330 ; 331////////////////////////////////////////////////////////////////////////////////; 332/// Fast execution of 'new TBufferFile(TBuffer::kWrite,10000), without having; 333/// a compile time circular dependency ... alternatively we could (should?); 334/// introduce yet another abstract interface.; 335 ; 336static TBuffer* R__CreateBuffer(); 337{; 338 typedef void (*tcling_callfunc_Wrapper_t)(void*, int, void**, void*);; 339 static tcling_callfunc_Wrapper_t creator = nullptr;; 340 if (!creator) {; 341 R__LOCKGUARD(gROOTMutex);; 342 TClass *c = TClass::GetClass(""TBufferFile"");; 343 TMethod *m = c->GetMethodWithPrototype(""TBufferFile"",""TBuffer::EMode,Int_t"",kFALSE,ROOT::kExactMatch);; 344 creator = (tcling_callfunc_Wrapper_t)( m->InterfaceMethod() );; 345 }; 346 TBuffer::EMode mode = TBuffer::kWrite;; 347 Int_t size = 10000;; 348 void *args[] = { &mode, &size };; 349 TBuffer *result;; 350 creator(nullptr,2,args,&result);; 351 return result;; 352}; 353 ; 354////////////////////////////////////////////////////////////////////////////////; 355/// Clone an object.; 356/// Th",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
Modifiability,variab,variable," 96 ; 97TDirectory::~TDirectory(); 98{; 99 // Use gROOTLocal to avoid triggering undesired initialization of gROOT.; 100 // For example in compiled C++ programs that don't use it directly.; 101 if (!ROOT::Internal::gROOTLocal) {; 102 delete fList;; 103 return; //when called by TROOT destructor; 104 }; 105 ; 106 if (fList) {; 107 if (!fList->IsUsingRWLock()); 108 Fatal(""~TDirectory"",""In %s:%p the fList (%p) is not using the RWLock\n"",; 109 GetName(),this,fList);; 110 fList->Delete(""slow"");; 111 SafeDelete(fList);; 112 }; 113 ; 114 TDirectory::CleanTargets();; 115 ; 116 TDirectory* mom = GetMotherDir();; 117 ; 118 if (mom) {; 119 mom->Remove(this);; 120 }; 121 ; 122 if (gDebug) {; 123 Info(""~TDirectory"", ""dtor called for %s"", GetName());; 124 }; 125}; 126 ; 127 ; 128////////////////////////////////////////////////////////////////////////////////; 129/// Set the current directory to null.; 130/// This is called from the TContext destructor. Since the destructor is; 131/// inline, we do not want to have it directly use a global variable.; 132 ; 133void TDirectory::TContext::CdNull(); 134{; 135 gDirectory = nullptr;; 136}; 137 ; 138////////////////////////////////////////////////////////////////////////////////; 139/// Destructor.; 140///; 141/// Reset the current directory to its previous state.; 142 ; 143TDirectory::TContext::~TContext(); 144{; 145 fActiveDestructor = true;; 146 if (fDirectory) {; 147 // UnregisterContext must not be virtual to allow; 148 // this to work even with fDirectory set to nullptr.; 149 (*fDirectory).UnregisterContext(this);; 150 // While we were waiting for the lock, the TDirectory; 151 // may have been deleted by another thread, so; 152 // we need to recheck the value of fDirectory.; 153 if (fDirectory); 154 (*fDirectory).cd();; 155 else; 156 CdNull();; 157 } else {; 158 CdNull();; 159 }; 160 fActiveDestructor = false;; 161 while(fDirectoryWait);; 162}; 163 ; 164////////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
Performance,load,load,"ext will call Unregister on gROOT.; 278 // Then unregister of this ctxt and its Previous context can actually be run; 279 // in parallel (this takes the gROOT lock, Previous takes the lock of fDirectory); 280 // and thus step on each other.; 281 ctxt->fDirectory = nullptr; // Can not be gROOT; 282 ; 283 if (ctxt->fActiveDestructor) {; 284 extraWait.push_back(fContext);; 285 } else {; 286 ctxt->fDirectoryWait = false;; 287 }; 288 fContext = next;; 289 }; 290 ; 291 // Now loop through the set of thread local 'gDirectory' that; 292 // have a one point or another pointed to this directory.; 293 for (auto &ptr : fGDirectories) {; 294 // If the thread local gDirectory still point to this directory; 295 // we need to reset it using the following sematic:; 296 // we fall back to the mother/owner of this directory or gROOTLocal; 297 // if there is no parent or nullptr if the current object is gROOTLocal.; 298 if (ptr->load() == this) {; 299 TDirectory *next = GetMotherDir();; 300 if (!next || next == this) {; 301 if (this == ROOT::Internal::gROOTLocal) { /// in that case next == this.; 302 next = nullptr;; 303 } else {; 304 next = ROOT::Internal::gROOTLocal;; 305 }; 306 } else {; 307 // We can not use 'cd' as this would access the current thread; 308 // rather than the thread corresponding to that gDirectory.; 309 next->RegisterGDirectory(ptr);; 310 }; 311 // Actually do the update of the thread local gDirectory; 312 // using its object specific lock.; 313 auto This = this;; 314 ptr->compare_exchange_strong(This, next);; 315 }; 316 }; 317 }; 318 for(auto &&context : extraWait) {; 319 // Wait until the TContext is done spinning; 320 // over the lock.; 321 while(context->fActiveDestructor);; 322 // And now let the TContext destructor finish.; 323 context->fDirectoryWait = false;; 324 }; 325 ; 326 // Wait until all register attempts are done.; 327 while(fContextPeg) {}; 328 ; 329}; 330 ; 331////////////////////////////////////////////////////////////////////////////////; 332///",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
Safety,avoid,avoid,"e of the derived class.; 69///; 70/// Note that the directory name cannot contain slashes.; 71 ; 72TDirectory::TDirectory(const char *name, const char *title, Option_t * /*classname*/, TDirectory* initMotherDir); 73 : TNamed(name, title); 74{; 75 // MSVC doesn't support fSpinLock=ATOMIC_FLAG_INIT; in the class definition; 76 std::atomic_flag_clear( &fSpinLock );; 77 ; 78 if (!initMotherDir) initMotherDir = gDirectory;; 79 ; 80 if (strchr(name,'/')) {; 81 ::Error(""TDirectory::TDirectory"",""directory name (%s) cannot contain a slash"", name);; 82 gDirectory = nullptr;; 83 return;; 84 }; 85 if (strlen(GetName()) == 0) {; 86 ::Error(""TDirectory::TDirectory"",""directory name cannot be \""\"""");; 87 gDirectory = nullptr;; 88 return;; 89 }; 90 ; 91 BuildDirectory(initMotherDir ? initMotherDir->GetFile() : nullptr, initMotherDir);; 92}; 93 ; 94////////////////////////////////////////////////////////////////////////////////; 95/// Destructor.; 96 ; 97TDirectory::~TDirectory(); 98{; 99 // Use gROOTLocal to avoid triggering undesired initialization of gROOT.; 100 // For example in compiled C++ programs that don't use it directly.; 101 if (!ROOT::Internal::gROOTLocal) {; 102 delete fList;; 103 return; //when called by TROOT destructor; 104 }; 105 ; 106 if (fList) {; 107 if (!fList->IsUsingRWLock()); 108 Fatal(""~TDirectory"",""In %s:%p the fList (%p) is not using the RWLock\n"",; 109 GetName(),this,fList);; 110 fList->Delete(""slow"");; 111 SafeDelete(fList);; 112 }; 113 ; 114 TDirectory::CleanTargets();; 115 ; 116 TDirectory* mom = GetMotherDir();; 117 ; 118 if (mom) {; 119 mom->Remove(this);; 120 }; 121 ; 122 if (gDebug) {; 123 Info(""~TDirectory"", ""dtor called for %s"", GetName());; 124 }; 125}; 126 ; 127 ; 128////////////////////////////////////////////////////////////////////////////////; 129/// Set the current directory to null.; 130/// This is called from the TContext destructor. Since the destructor is; 131/// inline, we do not want to have it directly use a global variable.; 132 ; ",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
Security,access,access,"80 // and thus step on each other.; 281 ctxt->fDirectory = nullptr; // Can not be gROOT; 282 ; 283 if (ctxt->fActiveDestructor) {; 284 extraWait.push_back(fContext);; 285 } else {; 286 ctxt->fDirectoryWait = false;; 287 }; 288 fContext = next;; 289 }; 290 ; 291 // Now loop through the set of thread local 'gDirectory' that; 292 // have a one point or another pointed to this directory.; 293 for (auto &ptr : fGDirectories) {; 294 // If the thread local gDirectory still point to this directory; 295 // we need to reset it using the following sematic:; 296 // we fall back to the mother/owner of this directory or gROOTLocal; 297 // if there is no parent or nullptr if the current object is gROOTLocal.; 298 if (ptr->load() == this) {; 299 TDirectory *next = GetMotherDir();; 300 if (!next || next == this) {; 301 if (this == ROOT::Internal::gROOTLocal) { /// in that case next == this.; 302 next = nullptr;; 303 } else {; 304 next = ROOT::Internal::gROOTLocal;; 305 }; 306 } else {; 307 // We can not use 'cd' as this would access the current thread; 308 // rather than the thread corresponding to that gDirectory.; 309 next->RegisterGDirectory(ptr);; 310 }; 311 // Actually do the update of the thread local gDirectory; 312 // using its object specific lock.; 313 auto This = this;; 314 ptr->compare_exchange_strong(This, next);; 315 }; 316 }; 317 }; 318 for(auto &&context : extraWait) {; 319 // Wait until the TContext is done spinning; 320 // over the lock.; 321 while(context->fActiveDestructor);; 322 // And now let the TContext destructor finish.; 323 context->fDirectoryWait = false;; 324 }; 325 ; 326 // Wait until all register attempts are done.; 327 while(fContextPeg) {}; 328 ; 329}; 330 ; 331////////////////////////////////////////////////////////////////////////////////; 332/// Fast execution of 'new TBufferFile(TBuffer::kWrite,10000), without having; 333/// a compile time circular dependency ... alternatively we could (should?); 334/// introduce yet another abstract interface.; 3",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
Integrability,depend,dependency,". ROOT: core/base/inc/TDirectory.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Macros ; TDirectory.h File Reference. #include ""TNamed.h""; #include ""TClass.h""; #include ""TUUID.h""; #include <atomic>; #include ""TList.h""; #include ""TBuffer.h"". Include dependency graph for TDirectory.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TDirectory::TContext;  TDirectory::TContext keeps track and restore the current directory. More...;  ; class  TDirectory;  Describe directory structure in memory. More...;  ; struct  ROOT::Internal::TDirectoryAtomicAdapter;  Internal class used in the implementation of gDirectory The objects of type TDirectoryAtomicAdapter should only be used inside the thread that created them. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define gDirectory   (::ROOT::Internal::TDirectoryAtomicAdapter{});  . Macro Definition Documentation. ◆ gDirectory. #define gDirectory   (::ROOT::Internal::TDirectoryAtomicAdapter{}). Definition at line 384 of file TDirectory.h. corebaseincTDirectory.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:12 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TDirectory_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8h.html
Performance,load,load,"revious.; 95 TContext *fNext{nullptr}; //! Pointer to the next TContext in the implied list of context pointing to fPrevious.; 96 ; 97 TContext(TContext&) = delete;; 98 TContext& operator=(TContext&) = delete;; 99 ; 100 void CdNull();; 101 friend class TDirectory;; 102 ; 103 void RegisterCurrentDirectory();; 104 ; 105 public:; 106 // Note: the directory pointed to by `previous` must not be already deleted; 107 // or in the process of being deleted by another thread while this constructor runs.; 108 TContext(TDirectory *previous, TDirectory *newCurrent) : fDirectory(previous); 109 {; 110 // Store the value of `previous` as the directory to return to when; 111 // this object is destructed.; 112 // Then cd to the `newCurrent` directory.; 113 if (fDirectory); 114 (*fDirectory).RegisterContext(this);; 115 if (newCurrent); 116 newCurrent->cd();; 117 else; 118 CdNull();; 119 }; 120 TContext() : fDirectory(TDirectory::CurrentDirectory().load()); 121 {; 122 // Store the current directory so we can restore it; 123 // later and cd to the new directory.; 124 RegisterCurrentDirectory();; 125 }; 126 TContext(TDirectory *newCurrent) : fDirectory(TDirectory::CurrentDirectory().load()); 127 {; 128 // Store the current directory so we can restore it; 129 // later and cd to the new directory.; 130 RegisterCurrentDirectory();; 131 if (newCurrent); 132 newCurrent->cd();; 133 else; 134 CdNull();; 135 }; 136 ~TContext();; 137 };; 138 ; 139protected:; 140 ; 141 TObject *fMother{nullptr}; // pointer to mother of the directory; 142 TList *fList{nullptr}; // List of objects in memory; 143 TUUID fUUID; // Unique identifier; 144 mutable TString fPathBuffer; //! Buffer for GetPath() function; 145 TContext *fContext{nullptr}; //! Pointer to a list of TContext object pointing to this TDirectory; 146 ; 147 using SharedGDirectory_t = std::shared_ptr<std::atomic<TDirectory *>>;; 148 ; 149 static SharedGDirectory_t &GetSharedLocalCurrentDirectory();; 150 ; 151 std::vector<SharedGDirectory_t> fGDirecto",MatchSource.WIKI,doc/master/TDirectory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8h_source.html
Safety,safe,safe,"21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TNamed.h""; 25#include ""TClass.h""; 26#include ""TUUID.h""; 27#include <atomic>; 28 ; 29#ifdef R__LESS_INCLUDES; 30class TList;; 31#else; 32#include ""TList.h""; 33#include ""TBuffer.h""; 34// #include ""TDatime.h""; 35#endif; 36 ; 37class TBrowser;; 38class TKey;; 39class TFile;; 40namespace ROOT {; 41namespace Internal {; 42 struct TDirectoryAtomicAdapter;; 43}}; 44 ; 45class TDirectory : public TNamed {; 46public:; 47 ; 48/** \class TContext; 49\ingroup Base; 50 ; 51TDirectory::TContext keeps track and restore the current directory.; 52With this tool C++ exceptions will be guaranteed to properly restore the; 53current directory pointer.; 54 ; 55For example code like:; 56 ; 57~~~ {.cpp}; 58 TDirectory *sav = gDirectory;; 59 mydirectory->cd();; 60 if (...) {; 61 ....; 62 sav->cd();; 63 return;; 64 } else if (...) {; 65 ....; 66 sav->cd();; 67 return;; 68 }; 69 sav->cd;; 70 return;; 71~~~; 72 ; 73can be replaced with the simpler and exception safe:; 74 ; 75~~~ {.cpp}; 76 TDirectory::TContext context(gDirectory, mydirectory);; 77 if (...) {; 78 ....; 79 return;; 80 } else if (...) {; 81 ....; 82 return;; 83 }; 84 return;; 85~~~; 86 ; 87*/; 88 ; 89 class TContext {; 90 private:; 91 std::atomic<TDirectory*> fDirectory{nullptr}; //! Pointer to the previous current directory.; 92 std::atomic<bool> fActiveDestructor{false}; //! Set to true during the destructor execution; 93 std::atomic<bool> fDirectoryWait{false}; //! Set to true if a TDirectory might still access this object.; 94 TContext *fPrevious{nullptr}; //! Pointer to the next TContext in the implied list of context pointing to fPrevious.; 95 TContext *fNext{nullptr}; //! Pointer to the next TContext in the implied list of context pointing to fPrevious.; 96 ; 97 TContext(TContext&) = delete;; 98 TContext& operator=(TContext&) = delete;; 99 ; 100 void CdNull();; 101 friend class TDirectory;; 102 ; 103 void RegisterCurrentDi",MatchSource.WIKI,doc/master/TDirectory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8h_source.html
Security,access,access," public TNamed {; 46public:; 47 ; 48/** \class TContext; 49\ingroup Base; 50 ; 51TDirectory::TContext keeps track and restore the current directory.; 52With this tool C++ exceptions will be guaranteed to properly restore the; 53current directory pointer.; 54 ; 55For example code like:; 56 ; 57~~~ {.cpp}; 58 TDirectory *sav = gDirectory;; 59 mydirectory->cd();; 60 if (...) {; 61 ....; 62 sav->cd();; 63 return;; 64 } else if (...) {; 65 ....; 66 sav->cd();; 67 return;; 68 }; 69 sav->cd;; 70 return;; 71~~~; 72 ; 73can be replaced with the simpler and exception safe:; 74 ; 75~~~ {.cpp}; 76 TDirectory::TContext context(gDirectory, mydirectory);; 77 if (...) {; 78 ....; 79 return;; 80 } else if (...) {; 81 ....; 82 return;; 83 }; 84 return;; 85~~~; 86 ; 87*/; 88 ; 89 class TContext {; 90 private:; 91 std::atomic<TDirectory*> fDirectory{nullptr}; //! Pointer to the previous current directory.; 92 std::atomic<bool> fActiveDestructor{false}; //! Set to true during the destructor execution; 93 std::atomic<bool> fDirectoryWait{false}; //! Set to true if a TDirectory might still access this object.; 94 TContext *fPrevious{nullptr}; //! Pointer to the next TContext in the implied list of context pointing to fPrevious.; 95 TContext *fNext{nullptr}; //! Pointer to the next TContext in the implied list of context pointing to fPrevious.; 96 ; 97 TContext(TContext&) = delete;; 98 TContext& operator=(TContext&) = delete;; 99 ; 100 void CdNull();; 101 friend class TDirectory;; 102 ; 103 void RegisterCurrentDirectory();; 104 ; 105 public:; 106 // Note: the directory pointed to by `previous` must not be already deleted; 107 // or in the process of being deleted by another thread while this constructor runs.; 108 TContext(TDirectory *previous, TDirectory *newCurrent) : fDirectory(previous); 109 {; 110 // Store the value of `previous` as the directory to return to when; 111 // this object is destructed.; 112 // Then cd to the `newCurrent` directory.; 113 if (fDirectory); 114 (*fDirectory).R",MatchSource.WIKI,doc/master/TDirectory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8h_source.html
Usability,simpl,simpler,"21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TNamed.h""; 25#include ""TClass.h""; 26#include ""TUUID.h""; 27#include <atomic>; 28 ; 29#ifdef R__LESS_INCLUDES; 30class TList;; 31#else; 32#include ""TList.h""; 33#include ""TBuffer.h""; 34// #include ""TDatime.h""; 35#endif; 36 ; 37class TBrowser;; 38class TKey;; 39class TFile;; 40namespace ROOT {; 41namespace Internal {; 42 struct TDirectoryAtomicAdapter;; 43}}; 44 ; 45class TDirectory : public TNamed {; 46public:; 47 ; 48/** \class TContext; 49\ingroup Base; 50 ; 51TDirectory::TContext keeps track and restore the current directory.; 52With this tool C++ exceptions will be guaranteed to properly restore the; 53current directory pointer.; 54 ; 55For example code like:; 56 ; 57~~~ {.cpp}; 58 TDirectory *sav = gDirectory;; 59 mydirectory->cd();; 60 if (...) {; 61 ....; 62 sav->cd();; 63 return;; 64 } else if (...) {; 65 ....; 66 sav->cd();; 67 return;; 68 }; 69 sav->cd;; 70 return;; 71~~~; 72 ; 73can be replaced with the simpler and exception safe:; 74 ; 75~~~ {.cpp}; 76 TDirectory::TContext context(gDirectory, mydirectory);; 77 if (...) {; 78 ....; 79 return;; 80 } else if (...) {; 81 ....; 82 return;; 83 }; 84 return;; 85~~~; 86 ; 87*/; 88 ; 89 class TContext {; 90 private:; 91 std::atomic<TDirectory*> fDirectory{nullptr}; //! Pointer to the previous current directory.; 92 std::atomic<bool> fActiveDestructor{false}; //! Set to true during the destructor execution; 93 std::atomic<bool> fDirectoryWait{false}; //! Set to true if a TDirectory might still access this object.; 94 TContext *fPrevious{nullptr}; //! Pointer to the next TContext in the implied list of context pointing to fPrevious.; 95 TContext *fNext{nullptr}; //! Pointer to the next TContext in the implied list of context pointing to fPrevious.; 96 ; 97 TContext(TContext&) = delete;; 98 TContext& operator=(TContext&) = delete;; 99 ; 100 void CdNull();; 101 friend class TDirectory;; 102 ; 103 void RegisterCurrentDi",MatchSource.WIKI,doc/master/TDirectory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8h_source.html
Integrability,depend,dependency,". ROOT: hist/hist/src/TEfficiencyHelper.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TEfficiencyHelper.h File Reference. #include <algorithm>; #include <cmath>; #include <vector>; #include ""Math/PdfFuncMathCore.h"". Include dependency graph for TEfficiencyHelper.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  BinomialNeymanInterval< Sorter >;  Implement noncentral binomial confidence intervals using the Neyman construction. More...;  ; class  BinomialProbHelper;  Helper class impelementing the binomial probability and the likelihood ratio used for ordering the interval in the FeldmanCousins interval class. More...;  ; class  FeldmanCousinsBinomialInterval;  ; struct  FeldmanCousinsSorter;  . histhistsrcTEfficiencyHelper.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TEfficiencyHelper_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiencyHelper_8h.html
Availability,error,error,"f EFF06); 66 - [VI.1 Information about the internal histograms](\ref EFF061); 67 - [VI.2 Fitting](\ref EFF062); 68 - [VI.3 Draw a TEfficiency object](\ref EFF063); 69 - [VI.4 TEfficiency object's axis customisation](\ref EFF064); 70 ; 71\anchor EFF01; 72## I. Overview; 73This class handles the calculation of efficiencies and their uncertainties. It; 74provides several statistical methods for calculating frequentist and Bayesian; 75confidence intervals as well as a function for combining several efficiencies.; 76 ; 77Efficiencies have a lot of applications and meanings but in principle, they can; 78be described by the fraction of good/passed events k out of sample containing; 79N events. One is usually interested in the dependency of the efficiency on other; 80(binned) variables. The number of passed and total events is therefore stored; 81internally in two histograms (TEfficiency::fTotalHistogram and TEfficiency::fPassedHistogram).; 82Then the efficiency, as well as its upper and lower error, can be calculated for each bin; 83individually.; 84 ; 85As the efficiency can be regarded as a parameter of a binomial distribution, the; 86number of passed and total events must always be integer numbers. Therefore a; 87filling with weights is not possible. However, you can assign a global weight to each; 88TEfficiency object (TEfficiency::SetWeight).; 89It is necessary to create one TEfficiency object; 90for each weight if you investigate a process involving different weights. This; 91procedure needs more effort but enables you to re-use the filled object in cases; 92where you want to change one or more weights. This would not be possible if all; 93events with different weights were filled in the same histogram.; 94 ; 95\anchor EFF02; 96## II. Creating a TEfficiency object; 97If you start a new analysis, it is highly recommended to use the TEfficiency class; 98from the beginning. You can then use one of the constructors for fixed or; 99variable bin size and your desired dimen",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
Deployability,continuous,continuously," possible true efficiencies) coverage probability for; 414different number of total events is shown in the next picture.; 415 ; 416\image html av_cov.png ""Average Coverage""; 417 ; 418\anchor EFF05; 419## V. Merging and combining TEfficiency objects; 420In many applications, the efficiency should be calculated for an inhomogeneous; 421sample in the sense that it contains events with different weights. In order; 422to be able to determine the correct overall efficiency, it is necessary to; 423use for each subsample (= all events with the same weight) a different; 424TEfficiency object. After finishing your analysis you can then construct the; 425overall efficiency with its uncertainty.; 426 ; 427This procedure has the advantage that you can change the weight of one; 428subsample easily without rerunning the whole analysis. On the other hand, more; 429effort is needed to handle several TEfficiency objects instead of one; 430histogram. In the case of many different or even continuously distributed; 431weights, this approach becomes cumbersome. One possibility to overcome this; 432problem is the usage of binned weights.; 433 ; 434\anchor EFF05a; 435### Example; 436In particle physics weights arises from the fact that you want to; 437normalise your results to a certain reference value. A very common formula for; 438calculating weights is; 439 ; 440\f{eqnarray*}{; 441 w &=& \frac{\sigma L}{N_{gen} \epsilon_{trig}} \\; 442 &-& \sigma ...\ cross\ section \\; 443 &-& L ...\ luminosity \\; 444 &-& N_{gen}\ ... number\ of\ generated\ events \\; 445 &-& \epsilon_{trig}\ ...\ (known)\ trigger\ efficiency \\; 446\f}; 447 ; 448The reason for different weights can therefore be:; 449- different processes; 450- other integrated luminosity; 451- varying trigger efficiency; 452- different sample sizes; 453- ...; 454- or even combination of them; 455 ; 456Depending on the actual meaning of different weights in your case, you; 457should either merge or combine them to get the overall effi",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
Energy Efficiency,allocate,allocated,"st char * GetBinLabel(Int_t bin) constReturn label for bin.Definition TAxis.cxx:440; TAxis::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t bin) constReturn low edge of bin.Definition TAxis.cxx:518; TAxis::FindFixBinvirtual Int_t FindFixBin(Double_t x) constFind bin number corresponding to abscissa x.Definition TAxis.cxx:419; TAxis::GetXminDouble_t GetXmin() constDefinition TAxis.h:139; TAxis::GetNbinsInt_t GetNbins() constDefinition TAxis.h:125; TAxis::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width.Definition TAxis.cxx:540; TAxis::GetLabelsTHashList * GetLabels() constDefinition TAxis.h:121; TBinomialEfficiencyFitterBinomial fitter for the division of two histograms.Definition TBinomialEfficiencyFitter.h:42; TBinomialEfficiencyFitter::FitTFitResultPtr Fit(TF1 *f1, Option_t *option="""")Carry out the fit of the given function to the given histograms.Definition TBinomialEfficiencyFitter.cxx:195; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::IsEmptyvirtual Bool_t IsEmpty() constDefinition TCollection.h:188; TDirectory::TContextTDirectory::TContext keeps track and restore the current directory.Definition TDirectory.h:89; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::Appendvirtual void Append(TObject *obj, Bool_t replace=kFALSE)Append object to this directory.Definition TDirectory.cxx:199; TDirectory::Removevirtual TObject * Remove(TObject *)Remove an object from the in-memory list.Definition TDirectory.cxx:1212; TEfficiencyClass to handle efficiency histograms.Definition TEfficiency.h:29; TEfficiency::FillGraph2Dvoid FillGraph2D(TGraph2DAsymmErrors *graph, Option_t *opt) constFill the graph to be painted with information from TEfficiency Internal method called by TEfficiency:...Definition TEfficien",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
Integrability,depend,dependency,"Efficiency objects](\ref EFF05); 60 - [Example](\ref EFF05a); 61 - [V.1 When should I use merging?](\ref EFF051); 62 - [Example](\ref EFF05b); 63 - [V.2 When should I use combining?](\ref EFF052); 64 - [Example](\ref EFF05c); 65- [VI. Further operations](\ref EFF06); 66 - [VI.1 Information about the internal histograms](\ref EFF061); 67 - [VI.2 Fitting](\ref EFF062); 68 - [VI.3 Draw a TEfficiency object](\ref EFF063); 69 - [VI.4 TEfficiency object's axis customisation](\ref EFF064); 70 ; 71\anchor EFF01; 72## I. Overview; 73This class handles the calculation of efficiencies and their uncertainties. It; 74provides several statistical methods for calculating frequentist and Bayesian; 75confidence intervals as well as a function for combining several efficiencies.; 76 ; 77Efficiencies have a lot of applications and meanings but in principle, they can; 78be described by the fraction of good/passed events k out of sample containing; 79N events. One is usually interested in the dependency of the efficiency on other; 80(binned) variables. The number of passed and total events is therefore stored; 81internally in two histograms (TEfficiency::fTotalHistogram and TEfficiency::fPassedHistogram).; 82Then the efficiency, as well as its upper and lower error, can be calculated for each bin; 83individually.; 84 ; 85As the efficiency can be regarded as a parameter of a binomial distribution, the; 86number of passed and total events must always be integer numbers. Therefore a; 87filling with weights is not possible. However, you can assign a global weight to each; 88TEfficiency object (TEfficiency::SetWeight).; 89It is necessary to create one TEfficiency object; 90for each weight if you investigate a process involving different weights. This; 91procedure needs more effort but enables you to re-use the filled object in cases; 92where you want to change one or more weights. This would not be possible if all; 93events with different weights were filled in the same histogram.; 94 ; 95\a",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
Modifiability,variab,variables,"Efficiency objects](\ref EFF05); 60 - [Example](\ref EFF05a); 61 - [V.1 When should I use merging?](\ref EFF051); 62 - [Example](\ref EFF05b); 63 - [V.2 When should I use combining?](\ref EFF052); 64 - [Example](\ref EFF05c); 65- [VI. Further operations](\ref EFF06); 66 - [VI.1 Information about the internal histograms](\ref EFF061); 67 - [VI.2 Fitting](\ref EFF062); 68 - [VI.3 Draw a TEfficiency object](\ref EFF063); 69 - [VI.4 TEfficiency object's axis customisation](\ref EFF064); 70 ; 71\anchor EFF01; 72## I. Overview; 73This class handles the calculation of efficiencies and their uncertainties. It; 74provides several statistical methods for calculating frequentist and Bayesian; 75confidence intervals as well as a function for combining several efficiencies.; 76 ; 77Efficiencies have a lot of applications and meanings but in principle, they can; 78be described by the fraction of good/passed events k out of sample containing; 79N events. One is usually interested in the dependency of the efficiency on other; 80(binned) variables. The number of passed and total events is therefore stored; 81internally in two histograms (TEfficiency::fTotalHistogram and TEfficiency::fPassedHistogram).; 82Then the efficiency, as well as its upper and lower error, can be calculated for each bin; 83individually.; 84 ; 85As the efficiency can be regarded as a parameter of a binomial distribution, the; 86number of passed and total events must always be integer numbers. Therefore a; 87filling with weights is not possible. However, you can assign a global weight to each; 88TEfficiency object (TEfficiency::SetWeight).; 89It is necessary to create one TEfficiency object; 90for each weight if you investigate a process involving different weights. This; 91procedure needs more effort but enables you to re-use the filled object in cases; 92where you want to change one or more weights. This would not be possible if all; 93events with different weights were filled in the same histogram.; 94 ; 95\a",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
Performance,perform,perform,"wer, Double_t & upper); 1405{; 1406 if (a <= 0 || b <= 0) {; 1407 lower = 0; upper = 1;; 1408 gROOT->Error(""TEfficiency::BayesianShortest"",""Invalid input parameters - return [0,1]"");; 1409 return kFALSE;; 1410 }; 1411 ; 1412 // treat here special cases when mode == 0 or 1; 1413 double mode = BetaMode(a,b);; 1414 if (mode == 0.0) {; 1415 lower = 0;; 1416 upper = ROOT::Math::beta_quantile(level, a, b);; 1417 return kTRUE;; 1418 }; 1419 if (mode == 1.0) {; 1420 lower = ROOT::Math::beta_quantile_c(level, a, b);; 1421 upper = 1.0;; 1422 return kTRUE;; 1423 }; 1424 // special case when the shortest interval is undefined return the central interval; 1425 // can happen for a posterior when passed=total=0; 1426 //; 1427 if ( a==b && a<=1.0) {; 1428 lower = BetaCentralInterval(level,a,b,kFALSE);; 1429 upper = BetaCentralInterval(level,a,b,kTRUE);; 1430 return kTRUE;; 1431 }; 1432 ; 1433 // for the other case perform a minimization; 1434 // make a function of the length of the posterior interval as a function of lower bound; 1435 Beta_interval_length intervalLength(level,a,b);; 1436 // minimize the interval length; 1437 ROOT::Math::WrappedFunction<const Beta_interval_length &> func(intervalLength);; 1438 ROOT::Math::BrentMinimizer1D minim;; 1439 minim.SetFunction(func, 0, intervalLength.LowerMax() );; 1440 minim.SetNpx(2); // no need to bracket with many iterations. Just do few times to estimate some better points; 1441 bool ret = minim.Minimize(100, 1.E-10,1.E-10);; 1442 if (!ret) {; 1443 gROOT->Error(""TEfficiency::BayesianShortes"",""Error finding the shortest interval"");; 1444 return kFALSE;; 1445 }; 1446 lower = minim.XMinimum();; 1447 upper = lower + minim.FValMinimum();; 1448 return kTRUE;; 1449}; 1450 ; 1451////////////////////////////////////////////////////////////////////////////////; 1452/// Compute the mean (average) of the beta distribution; 1453///; 1454/// \param[in] a parameter > 0 for the beta distribution (for a posterior is passed + prior_alpha; 1455/// \param",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
Safety,avoid,avoid,"reate a two-dimensional TEfficiency object with; 104- name = ""eff""; 105- title = ""my efficiency""; 106- axis titles: x, y and LaTeX-formatted epsilon as a label for Z axis; 107- 10 bins with constant bin width (= 1) along X axis starting at 0 (lower edge; 108 from the first bin) up to 10 (upper edge of last bin); 109- 20 bins with constant bin width (= 0.5) along Y axis starting at -5 (lower; 110 edge from the first bin) up to 5 (upper edge of last bin); 111 ; 112 TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;y;#epsilon"",10,0,10,20,-5,5);; 113 ; 114If you already have two histograms filled with the number of passed and total; 115events, you will use the constructor TEfficiency(const TH1& passed,const TH1& total); 116to construct the TEfficiency object. The histograms ""passed"" and ""total"" have; 117to fulfill the conditions mentioned in TEfficiency::CheckConsistency, otherwise the construction will fail.; 118As the histograms already exist, the new TEfficiency is by default **not** attached; 119to the current directory to avoid duplication of data. If you want to store the; 120new object anyway, you can either write it directly by calling TObject::Write or attach it to a directory using TEfficiency::SetDirectory.; 121This also applies to TEfficiency objects created by the copy constructor TEfficiency::TEfficiency(const TEfficiency& rEff).; 122 ; 123\anchor EFF02a; 124### Example 1; 125 ; 126~~~~~~~~~~~~~~~{.cpp}; 127TEfficiency* pEff = 0;; 128TFile* pFile = new TFile(""myfile.root"",""recreate"");; 129 ; 130//h_pass and h_total are valid and consistent histograms; 131if(TEfficiency::CheckConsistency(h_pass,h_total)); 132{; 133 pEff = new TEfficiency(h_pass,h_total);; 134 // this will write the TEfficiency object to ""myfile.root""; 135 // AND pEff will be attached to the current directory; 136 pEff->Write();; 137}; 138~~~~~~~~~~~~~~~; 139 ; 140\anchor EFF02b; 141### Example 2; 142 ; 143~~~~~~~~~~~~~~~{.cpp}; 144TEfficiency* pEff = 0;; 145TFile* pFile = new TFile(",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
Security,access,accessed,"F1(""f1"",""gaus"",0,10);; 616 f1->SetParameters(1,5,2);; 617 pEff->Fit(f1);; 618 ; 619 //create a threshold function; 620 TF1* f2 = new TF1(""thres"",""0.8"",0,10);; 621 f2->SetLineColor(kRed);; 622 //add it to the list of functions; 623 //use add first because the parameters of the last function will be displayed; 624 pEff->GetListOfFunctions()->AddFirst(f2);; 625 ; 626 pEff->Draw(""AP"");; 627}; 628End_Macro; 629 ; 630\anchor EFF063; 631### VI.3 Draw a TEfficiency object; 632A TEfficiency object can be drawn by calling the usual TEfficiency::Draw method.; 633At the moment drawing is only supported for 1- and 2-dimensional TEfficiency objects.; 634In the 1-dimensional case, you can use the same options as for the TGraphAsymmErrors::Draw; 635method. For 2-dimensional TEfficiency objects, you can pass the same options as; 636for a TH2::Draw object.; 637 ; 638\anchor EFF064; 639### VI.4 TEfficiency object's axis customisation; 640The axes of a TEfficiency object can be accessed and customised by calling the; 641GetPaintedGraph method and then GetXaxis() or GetYaxis() and the corresponding TAxis; 642methods.; 643Note that in order to access the painted graph via GetPaintedGraph(), one should either; 644call Paint or, better, gPad->Update().; 645 ; 646Begin_Macro(source); 647{; 648 //canvas only needed for this documentation; 649 TCanvas* c1 = new TCanvas(""example"","""",600,400);; 650 c1->SetFillStyle(1001);; 651 c1->SetFillColor(kWhite);; 652 c1->Divide(2,1);; 653 ; 654 //create one-dimensional TEfficiency object with fixed bin size; 655 TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;#epsilon"",20,0,10);; 656 TRandom3 rand3;; 657 ; 658 bool bPassed;; 659 double x;; 660 for(int i=0; i<10000; ++i); 661 {; 662 //simulate events with variable under investigation; 663 x = rand3.Uniform(10);; 664 //check selection: bPassed = DoesEventPassSelection(x); 665 bPassed = rand3.Rndm() < TMath::Gaus(x,5,4);; 666 pEff->Fill(bPassed,x);; 667 }; 668 c1->cd(1);; 669 pEff->Draw(""AP"");; 6",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
Testability,log,logic,"fLevel),; 1063 fDirectory(nullptr),; 1064 fFunctions(nullptr),; 1065 fPaintGraph(nullptr),; 1066 fPaintHisto(nullptr),; 1067 fWeight(rEff.fWeight); 1068{; 1069 // copy TObject bits; 1070 rEff.TObject::Copy(*this);; 1071 ; 1072 // do not add cloned histograms to gDirectory; 1073 {; 1074 TDirectory::TContext ctx(nullptr);; 1075 fTotalHistogram = (TH1*)((rEff.fTotalHistogram)->Clone());; 1076 fPassedHistogram = (TH1*)((rEff.fPassedHistogram)->Clone());; 1077 }; 1078 ; 1079 TString name = rEff.GetName();; 1080 name += ""_copy"";; 1081 SetName(name);; 1082 TString title = ""[copy] "";; 1083 title += rEff.GetTitle();; 1084 SetTitle(title);; 1085 ; 1086 SetStatisticOption(rEff.GetStatisticOption());; 1087 ; 1088 SetDirectory(nullptr);; 1089 ; 1090 //copy style; 1091 rEff.TAttLine::Copy(*this);; 1092 rEff.TAttFill::Copy(*this);; 1093 rEff.TAttMarker::Copy(*this);; 1094}; 1095 ; 1096////////////////////////////////////////////////////////////////////////////////; 1097///default destructor; 1098 ; 1099TEfficiency::~TEfficiency(); 1100{; 1101 //delete all function in fFunctions; 1102 // use same logic as in TH1 destructor; 1103 // (see TH1::~TH1 code in TH1.cxx); 1104 if(fFunctions) {; 1105 fFunctions->SetBit(kInvalidObject);; 1106 TObject* obj = nullptr;; 1107 while ((obj = fFunctions->First())) {; 1108 while(fFunctions->Remove(obj)) { }; 1109 if (ROOT::Detail::HasBeenDeleted(obj)) {; 1110 break;; 1111 }; 1112 delete obj;; 1113 obj = nullptr;; 1114 }; 1115 delete fFunctions;; 1116 fFunctions = nullptr;; 1117 }; 1118 ; 1119 if(fDirectory); 1120 fDirectory->Remove(this);; 1121 ; 1122 delete fTotalHistogram;; 1123 delete fPassedHistogram;; 1124 delete fPaintGraph;; 1125 delete fPaintHisto;; 1126}; 1127 ; 1128////////////////////////////////////////////////////////////////////////////////; 1129/**; 1130 Calculates the boundaries for the frequentist Agresti-Coull interval; 1131 ; 1132 \param total number of total events; 1133 \param passed 0 <= number of passed events <= total; 1134 \",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
Usability,clear,cleared,"nt(bin); 3565 ; 3566Bool_t TEfficiency::SetPassedEvents(Int_t bin,Int_t events); 3567{; 3568 if(events <= fTotalHistogram->GetBinContent(bin)) {; 3569 fPassedHistogram->SetBinContent(bin,events);; 3570 return true;; 3571 }; 3572 else {; 3573 Error(""SetPassedEvents(Int_t,Int_t)"",""total number of events (%.1lf) in bin %i is less than given number of passed events %i"",fTotalHistogram->GetBinContent(bin),bin,events);; 3574 return false;; 3575 }; 3576}; 3577 ; 3578////////////////////////////////////////////////////////////////////////////////; 3579/// Sets the histogram containing the passed events; 3580///; 3581/// The given histogram is cloned and stored internally as histogram containing; 3582/// the passed events. The given histogram has to be consistent with the current; 3583/// fTotalHistogram (see CheckConsistency(const TH1&,const TH1&)).; 3584/// The method returns whether the fPassedHistogram has been replaced (true) or; 3585/// not (false).; 3586///; 3587/// Note: The list of associated functions fFunctions is cleared.; 3588///; 3589/// Option:; 3590/// - ""f"": force the replacement without checking the consistency; 3591/// This can lead to inconsistent histograms and useless results; 3592/// or unexpected behaviour. But sometimes it might be the only; 3593/// way to change the histograms. If you use this option, you; 3594/// should ensure that the fTotalHistogram is replaced by a; 3595/// consistent one (with respect to rPassed) as well.; 3596 ; 3597Bool_t TEfficiency::SetPassedHistogram(const TH1& rPassed,Option_t* opt); 3598{; 3599 TString option = opt;; 3600 option.ToLower();; 3601 ; 3602 Bool_t bReplace = option.Contains(""f"");; 3603 ; 3604 if(!bReplace); 3605 bReplace = CheckConsistency(rPassed,*fTotalHistogram);; 3606 ; 3607 if(bReplace) {; 3608 delete fPassedHistogram;; 3609 // do not add cloned histogram to gDirectory; 3610 {; 3611 TDirectory::TContext ctx(nullptr);; 3612 fPassedHistogram = (TH1*)(rPassed.Clone());; 3613 fPassedHistogram->SetNormFactor(",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
Availability,error,error,"cy::GetDimensionInt_t GetDimension() constreturns the dimension of the current TEfficiency objectDefinition TEfficiency.cxx:2659; TEfficiency::fPaintGraph2DTGraph2DAsymmErrors * fPaintGraph2D! Temporary graph for paintingDefinition TEfficiency.h:56; TEfficiency::operator+=TEfficiency & operator+=(const TEfficiency &rhs)Adds the histograms of another TEfficiency object to current histograms.Definition TEfficiency.cxx:2979; TEfficiency::SetBinsBool_t SetBins(Int_t nx, Double_t xmin, Double_t xmax)Set the bins for the underlined passed and total histograms If the class have been already filled the...Definition TEfficiency.cxx:3389; TEfficiency::Buildvoid Build(const char *name, const char *title)Building standard data structure of a TEfficiency object.Definition TEfficiency.cxx:1505; TEfficiency::GetCopyPassedHistoTH1 * GetCopyPassedHisto() constReturns a cloned version of fPassedHistogram.Definition TEfficiency.cxx:2617; TEfficiency::GetEfficiencyErrorUpDouble_t GetEfficiencyErrorUp(Int_t bin) constReturns the upper error on the efficiency in the given global bin.Definition TEfficiency.cxx:2812; TEfficiency::fBeta_alphaDouble_t fBeta_alphaGlobal parameter for prior beta distribution (default = 1)Definition TEfficiency.h:47; TEfficiency::UsesBayesianStatBool_t UsesBayesianStat() constDefinition TEfficiency.h:161; TEfficiency::GetPassedHistogramconst TH1 * GetPassedHistogram() constDefinition TEfficiency.h:125; TEfficiency::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *opt="""") overrideHave histograms fixed bins along each axis?Definition TEfficiency.cxx:3155; TEfficiency::SetBetaBetavoid SetBetaBeta(Double_t beta)Sets the shape parameter β.Definition TEfficiency.cxx:3347; TEfficiency::GetConfidenceLevelDouble_t GetConfidenceLevel() constDefinition TEfficiency.h:112; TEfficiency::CheckBinningstatic Bool_t CheckBinning(const TH1 &pass, const TH1 &total)Checks binning for each axis.Definition TEfficiency.cxx:1527; TEfficiency::SetNamevoid SetName(const char *",MatchSource.WIKI,doc/master/TEfficiency_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8h_source.html
Integrability,depend,depending,"m() constDefinition TEfficiency.h:123; TEfficiency::TEfficiencyTEfficiency()Default constructor.Definition TEfficiency.cxx:691; TEfficiency::GetBetaAlphaDouble_t GetBetaAlpha(Int_t bin=-1) constDefinition TEfficiency.h:110; TEfficiency::SetPosteriorAveragevoid SetPosteriorAverage(Bool_t on=true)Definition TEfficiency.h:143; TEfficiency::FillWeightedvoid FillWeighted(Bool_t bPassed, Double_t weight, Double_t x, Double_t y=0, Double_t z=0)This function is used for filling the two histograms with a weight.Definition TEfficiency.cxx:2494; TEfficiency::Browsevoid Browse(TBrowser *) overrideBrowse object. May be overridden for another default action.Definition TEfficiency.h:98; TEfficiency::~TEfficiency~TEfficiency() overridedefault destructorDefinition TEfficiency.cxx:1099; TEfficiency::GetListOfFunctionsTList * GetListOfFunctions()Definition TEfficiency.cxx:2897; TEfficiency::Bayesianstatic Double_t Bayesian(Double_t total, Double_t passed, Double_t level, Double_t alpha, Double_t beta, Bool_t bUpper, Bool_t bShortest=false)Calculates the boundaries for a Bayesian confidence interval (shortest or central interval depending ...Definition TEfficiency.cxx:1324; TEfficiency::AgrestiCoullstatic Double_t AgrestiCoull(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Agresti-Coull interval.Definition TEfficiency.cxx:1149; TEfficiency::MergeLong64_t Merge(TCollection *list)Merges the TEfficiency objects in the given list to the given TEfficiency object using the operator+=...Definition TEfficiency.cxx:2915; TEfficiency::fBeta_bin_paramsstd::vector< std::pair< Double_t, Double_t > > fBeta_bin_paramsParameter for prior beta distribution different bin by bin (default vector is empty)Definition TEfficiency.h:49; TEfficiency::FeldmanCousinsstatic Double_t FeldmanCousins(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Feldman-Cousins interval.Definition TEfficiency.",MatchSource.WIKI,doc/master/TEfficiency_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8h_source.html
Deployability,release,released," 167/// Draw this ellipse with its current attributes.; 168 ; 169void TEllipse::Draw(Option_t *option); 170{; 171 AppendPad(option);; 172}; 173 ; 174////////////////////////////////////////////////////////////////////////////////; 175/// Draw this ellipse with new coordinates.; 176 ; 177TEllipse *TEllipse::DrawEllipse(Double_t x1, Double_t y1,Double_t r1,Double_t r2,Double_t phimin,Double_t phimax,Double_t theta,Option_t *option); 178{; 179 TEllipse *newellipse = new TEllipse(x1, y1, r1, r2, phimin, phimax,theta);; 180 TAttLine::Copy(*newellipse);; 181 TAttFill::Copy(*newellipse);; 182 newellipse->SetBit(kCanDelete);; 183 newellipse->AppendPad(option);; 184 if (TestBit(kNoEdges)) newellipse->SetBit(kNoEdges);; 185 return newellipse;; 186}; 187 ; 188////////////////////////////////////////////////////////////////////////////////; 189/// Execute action corresponding to one event.; 190///; 191/// This member function is called when a line is clicked with the locator; 192///; 193/// If Left button clicked on one of the line end points, this point; 194/// follows the cursor until button is released.; 195///; 196/// if Middle button clicked, the line is moved parallel to itself; 197/// until the button is released.; 198///; 199/// NOTE that support for log scale is not implemented; 200 ; 201void TEllipse::ExecuteEvent(Int_t event, Int_t px, Int_t py); 202{; 203 if (!gPad) return;; 204 ; 205 Int_t kMaxDiff = 10;; 206 ; 207 Int_t i, dpx, dpy;; 208 Double_t angle,dx,dy,dphi,ct,st,fTy,fBy,fLx,fRx;; 209 static Int_t px1,py1,npe,r1,r2,sav1,sav2;; 210 const Int_t kMinSize = 25;; 211 const Int_t np = 40;; 212 static Bool_t pTop, pL, pR, pBot, pINSIDE;; 213 static Int_t pTx,pTy,pLx,pLy,pRx,pRy,pBx,pBy;; 214 static Int_t x[np+2], y[np+2];; 215 static Int_t pxold, pyold;; 216 static Int_t sig,impair;; 217 static Double_t sdx, sdy;; 218 static Double_t oldX1, oldY1, oldR1, oldR2;; 219 ; 220 Bool_t opaque = gPad->OpaqueMoving();; 221 ; 222 if (!gPad->IsEditable()) return;; 223 ; 224 sw",MatchSource.WIKI,doc/master/TEllipse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEllipse_8cxx_source.html
Testability,log,log,,MatchSource.WIKI,doc/master/TEllipse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEllipse_8cxx_source.html
Deployability,update,update,". ROOT: tutorials/tree/temperature.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. temperature.C File ReferenceTutorials » Tree tutorials. Detailed Description; This tutorial illustrates how to use the highlight mode with trees. ; It first creates a TTree from a temperature data set in Prague between 1775 and 2004. Then it defines three pads representing the temperature per year, month and day. Thanks to the highlight mechanism it is possible to explore the data set only by moving the mouse on the plots. Movements on the years' plot will update the months' and days' plot. Movements on the months plot will update the days plot. Movements on the days' plot will display the exact temperature for a given day.; ; Int_t year, month, day;; TTree *tree = nullptr;; TProfile *hYear = nullptr, *hMonth = nullptr, *hDay = nullptr;; TCanvas *Canvas = nullptr;; Int_t customhb = -2;; TLatex *info = nullptr;; ; // Ranges for year, month, day and temperature; Int_t rYear[3]; // from tree/data; Int_t rMonth[3] = { 12, 1, 13 };; Int_t rDay[3] = { 31, 1, 32 };; Double_t rTemp[3] = { 55.0, -20.0, 35.0 };; ; void HighlightDay(Int_t xhb); {; if (!info) {; info = new TLatex();; info->SetTextSizePixels(25);; Canvas->cd(3);; info->Draw();; gPad->Update();; }; ; if (xhb != customhb) day = xhb;; TString temp = TString::Format("" %5.1f #circC"", hDay->GetBinContent(day));; if (hDay->GetBinEntries(day) == 0) temp = "" "";; TString m = "" "";; if (month>0) m = TString::Format(""-%02d"",month);; TString d = "" "";; if (day>0) d = TString::Format(""-%02d"",day);; info->SetText(2.0, hDay->GetMinimum()*0.8, TString::Format(""%4d%s%s%s"", year, m.Data(), d.Data(), temp.Data()));; Canvas->GetPad(3)->Modified();; }; ; void HighlightMonth(Int_t xhb); {; if (!hDay) {; hDay = new TProfile(""hDay"", ""; day; temp, #circC"", rDay[0], rDay[1], rDay[2]);; hDay->SetMinimum(rTemp[1]);; hDay->SetMaximum(rTemp[2]);; hDay->GetYaxis()->SetNdivisions(410);; hDay->SetFillColor(kGray);; h",MatchSource.WIKI,doc/master/temperature_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/temperature_8C.html
Usability,simpl,simplification," gROOTDefinition TROOT.h:406; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; gPad#define gPadDefinition TVirtualPad.h:308; TAttAxis::SetNdivisionsvirtual void SetNdivisions(Int_t n=510, Bool_t optim=kTRUE)Set the number of divisions for this axis.Definition TAttAxis.cxx:233; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TAttMarker::SetMarkerSizevirtual void SetMarkerSize(Size_t msize=1)Set the marker size.Definition TAttMarker.h:45; TAttText::SetTextSizePixelsvirtual void SetTextSizePixels(Int_t npixels)Set the text size in pixel.Definition TAttText.cxx:423; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::HighlightConnectvirtual void HighlightConnect(const char *slot)This is ""simplification"" for function TCanvas::Connect with Highlighted signal for specific slot.Definition TCanvas.cxx:1631; TCanvas::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet current canvas & pad.Definition TCanvas.cxx:719; TCanvas::Updatevoid Update() overrideUpdate canvas pad buffers.Definition TCanvas.cxx:2489; TH1::GetMeanvirtual Double_t GetMean(Int_t axis=1) constFor axis = 1,2 or 3 returns the mean value of the histogram along X,Y or Z axis.Definition TH1.cxx:7535; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Definition TH1.h:404; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::SetHighlightvirtual void SetHighlight(Bool_t set=kTRUE)Set highlight (enable/disable) mode for the histogram by default highlight mode ",MatchSource.WIKI,doc/master/temperature_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/temperature_8C.html
Deployability,integrat,integrated,". ROOT: tmva/tmva/inc/TMVA/DNN/TensorDataLoader.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TensorDataLoader.h. Go to the documentation of this file. 1// @(#)root/tmva/tmva/dnn:$Id$; 2// Author: Vladimir Ilievski; 3 ; 4/**********************************************************************************; 5 * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; 6 * Package: TMVA *; 7 * Class : TTensorDataLoader *; 8 * *; 9 * *; 10 * Description: *; 11 * Tensor Data Loader Class *; 12 * *; 13 * Authors (alphabetical): *; 14 * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; 15 * *; 16 * Copyright (c) 2005-2015: *; 17 * CERN, Switzerland *; 18 * U. of Victoria, Canada *; 19 * MPI-K Heidelberg, Germany *; 20 * U. of Bonn, Germany *; 21 * *; 22 * Redistribution and use in source and binary forms, with or without *; 23 * modification, are permitted according to the terms listed in LICENSE *; 24 * (see tmva/doc/LICENSE) *; 25 **********************************************************************************/; 26 ; 27#ifndef TMVA_DNN_TENSORDATALOADER; 28#define TMVA_DNN_TENSORDATALOADER; 29 ; 30#include ""TMatrix.h""; 31#include ""TMVA/Event.h""; 32#include <algorithm>; 33#include <vector>; 34#include <utility>; 35 ; 36namespace TMVA {; 37 class DataSetInfo;; 38namespace DNN {; 39 ; 40//; 41// Input Data Types; 42//______________________________________________________________________________; 43using TensorInput =; 44 std::tuple<const std::vector<TMatrixT<Double_t>> &, const TMatrixT<Double_t> &, const TMatrixT<Double_t> &>;; 45 ; 46using TMVAInput_t = std::tuple<const std::vector<Event *> &, const DataSetInfo &>;; 47using IndexIterator_t = typename std::vector<size_t>::iterator;; 48 ; 49/** TTensorBatch; 50 *; 51 * Class representing training batches consisting of a vector of matrices as input data; 52 * and a matrix of output data. The input and output data can be accessed using; 53 ",MatchSource.WIKI,doc/master/TensorDataLoader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TensorDataLoader_8h_source.html
Integrability,integrat,integrated,". ROOT: tmva/tmva/inc/TMVA/DNN/TensorDataLoader.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TensorDataLoader.h. Go to the documentation of this file. 1// @(#)root/tmva/tmva/dnn:$Id$; 2// Author: Vladimir Ilievski; 3 ; 4/**********************************************************************************; 5 * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; 6 * Package: TMVA *; 7 * Class : TTensorDataLoader *; 8 * *; 9 * *; 10 * Description: *; 11 * Tensor Data Loader Class *; 12 * *; 13 * Authors (alphabetical): *; 14 * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; 15 * *; 16 * Copyright (c) 2005-2015: *; 17 * CERN, Switzerland *; 18 * U. of Victoria, Canada *; 19 * MPI-K Heidelberg, Germany *; 20 * U. of Bonn, Germany *; 21 * *; 22 * Redistribution and use in source and binary forms, with or without *; 23 * modification, are permitted according to the terms listed in LICENSE *; 24 * (see tmva/doc/LICENSE) *; 25 **********************************************************************************/; 26 ; 27#ifndef TMVA_DNN_TENSORDATALOADER; 28#define TMVA_DNN_TENSORDATALOADER; 29 ; 30#include ""TMatrix.h""; 31#include ""TMVA/Event.h""; 32#include <algorithm>; 33#include <vector>; 34#include <utility>; 35 ; 36namespace TMVA {; 37 class DataSetInfo;; 38namespace DNN {; 39 ; 40//; 41// Input Data Types; 42//______________________________________________________________________________; 43using TensorInput =; 44 std::tuple<const std::vector<TMatrixT<Double_t>> &, const TMatrixT<Double_t> &, const TMatrixT<Double_t> &>;; 45 ; 46using TMVAInput_t = std::tuple<const std::vector<Event *> &, const DataSetInfo &>;; 47using IndexIterator_t = typename std::vector<size_t>::iterator;; 48 ; 49/** TTensorBatch; 50 *; 51 * Class representing training batches consisting of a vector of matrices as input data; 52 * and a matrix of output data. The input and output data can be accessed using; 53 ",MatchSource.WIKI,doc/master/TensorDataLoader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TensorDataLoader_8h_source.html
Modifiability,layers,layers,"eBuffer = deviceBuffer.GetSubBuffer(inputTensorSize, outputMatrixSize);; 251 DeviceBuffer_t weightDeviceBuffer = deviceBuffer.GetSubBuffer(inputTensorSize + outputMatrixSize, weightMatrixSize);; 252 ; 253 // here sample index has batch size as offset , while in; 254 // copy tensor input has batch depth.; 255 // We support then now two cases: batchdepth = 1 batchHeight = batch size; 256 // or batch depth = batch; 257 size_t sampleIndex = fBatchIndex * fBatchSize;; 258 IndexIterator_t sampleIndexIterator = fSampleIndices.begin() + sampleIndex;; 259 ; 260 CopyTensorInput(inputHostBuffer, sampleIndexIterator);; 261 CopyTensorOutput(outputHostBuffer, sampleIndexIterator);; 262 CopyTensorWeights(weightHostBuffer, sampleIndexIterator);; 263 ; 264 deviceBuffer.CopyFrom(hostBuffer);; 265 ; 266 assert(fInputLayout.size() == 3);; 267 Tensor_t inputTensor = Architecture_t::CreateTensor( inputDeviceBuffer, fBatchSize, fInputLayout[0], fInputLayout[1], fInputLayout[2] );; 268 // in case of dense layers; 269 if (fBatchDepth == 1 && fBatchHeight == fBatchSize && fInputLayout[0] == 1 && fInputLayout[1] == 1){; 270 inputTensor = Tensor_t( inputDeviceBuffer, {fBatchSize, fInputLayout.back() }, Tensor_t::MemoryLayout::ColumnMajor );; 271 }; 272 ; 273 Matrix_t outputMatrix(outputDeviceBuffer, fBatchSize, fNOutputFeatures);; 274 Matrix_t weightMatrix(weightDeviceBuffer, fBatchSize, 1);; 275 ; 276 fBatchIndex++;; 277 ; 278 ; 279 return TTensorBatch<Architecture_t>(inputTensor, outputMatrix, weightMatrix);; 280}; 281 ; 282//______________________________________________________________________________; 283template <typename Data_t, typename Architecture_t>; 284template <typename RNG>; 285void TTensorDataLoader<Data_t, Architecture_t>::Shuffle(RNG & rng); 286{; 287 std::shuffle(fSampleIndices.begin(), fSampleIndices.end(), rng);; 288}; 289 ; 290} // namespace DNN; 291} // namespace TMVA; 292 ; 293#endif; Event.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle G",MatchSource.WIKI,doc/master/TensorDataLoader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TensorDataLoader_8h_source.html
Performance,load,loaded,"ning data from the input data; 120 * type to the accelerator device or the CPU. A TTensorDataLoader object manages; 121 * a number of host and device buffer pairs that are used in a round-robin manner; 122 * for the transfer of batches to the device.; 123 *; 124 * Each TTensorDataLoader object has an associated batch size and a number of total; 125 * samples in the dataset. One epoch is the number of buffers required to transfer; 126 * the complete training set. Using the begin() and end() member functions allows; 127 * the user to iterate over the batches in one epoch.; 128 *; 129 * \tparam Data_t The input data type.; 130 * \tparam Architecture_t The architecture class of the underlying architecture.; 131 */; 132template <typename Data_t, typename Architecture_t>; 133class TTensorDataLoader {; 134private:; 135 using HostBuffer_t = typename Architecture_t::HostBuffer_t;; 136 using DeviceBuffer_t = typename Architecture_t::DeviceBuffer_t;; 137 using Matrix_t = typename Architecture_t::Matrix_t;; 138 using Tensor_t = typename Architecture_t::Tensor_t;; 139 using Shape_t = typename Architecture_t::Tensor_t::Shape_t;; 140 using BatchIterator_t = TTensorBatchIterator<Data_t, Architecture_t>;; 141 ; 142 const Data_t &fData; ///< The data that should be loaded in the batches.; 143 size_t fNSamples; ///< The total number of samples in the dataset.; 144 size_t fBatchSize; ///< The size of a batch.; 145 Shape_t fInputLayout; ///< The input data layout (does not include batch size); 146 size_t fBatchDepth; ///< The number of matrices in the tensor.; 147 size_t fBatchHeight; ///< The number od rows in each matrix.; 148 size_t fBatchWidth; ///< The number of columns in each matrix.; 149 size_t fNOutputFeatures; ///< The number of outputs from the classifier/regressor.; 150 size_t fBatchIndex; ///< The index of the batch when there are multiple batches in parallel; 151 ; 152 ; 153 size_t fNStreams; ///< Number of buffer pairs.; 154 std::vector<DeviceBuffer_t> fDeviceBuffers; ///<",MatchSource.WIKI,doc/master/TensorDataLoader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TensorDataLoader_8h_source.html
Security,access,accessed,"see tmva/doc/LICENSE) *; 25 **********************************************************************************/; 26 ; 27#ifndef TMVA_DNN_TENSORDATALOADER; 28#define TMVA_DNN_TENSORDATALOADER; 29 ; 30#include ""TMatrix.h""; 31#include ""TMVA/Event.h""; 32#include <algorithm>; 33#include <vector>; 34#include <utility>; 35 ; 36namespace TMVA {; 37 class DataSetInfo;; 38namespace DNN {; 39 ; 40//; 41// Input Data Types; 42//______________________________________________________________________________; 43using TensorInput =; 44 std::tuple<const std::vector<TMatrixT<Double_t>> &, const TMatrixT<Double_t> &, const TMatrixT<Double_t> &>;; 45 ; 46using TMVAInput_t = std::tuple<const std::vector<Event *> &, const DataSetInfo &>;; 47using IndexIterator_t = typename std::vector<size_t>::iterator;; 48 ; 49/** TTensorBatch; 50 *; 51 * Class representing training batches consisting of a vector of matrices as input data; 52 * and a matrix of output data. The input and output data can be accessed using; 53 * the GetInput() and GetOutput() member functions.; 54 *; 55 * \tparam Architecture_t The underlying architecture.; 56 */; 57 ; 58template <typename Architecture_t>; 59class TTensorBatch {; 60public:; 61 using Matrix_t = typename Architecture_t::Matrix_t;; 62 using Tensor_t = typename Architecture_t::Tensor_t;; 63 ; 64private:; 65 Tensor_t fInputTensor; ///< The input tensor batch, one matrix one input.; 66 Matrix_t fOutputMatrix; ///< The output matrix representing the ground truth.; 67 Matrix_t fWeightMatrix; ///< The event/example weights; 68 ; 69public:; 70 TTensorBatch(Tensor_t &, Matrix_t &, Matrix_t &);; 71 TTensorBatch(const TTensorBatch &) = default;; 72 TTensorBatch(TTensorBatch &&) = default;; 73 TTensorBatch &operator=(const TTensorBatch &) = default;; 74 TTensorBatch &operator=(TTensorBatch &&) = default;; 75 ; 76 /** Return the tensor representing the input data */; 77 Tensor_t &GetInput() { return fInputTensor; }; 78 /** Return the matrix representing the output data. *",MatchSource.WIKI,doc/master/TensorDataLoader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TensorDataLoader_8h_source.html
Testability,assert,assert,"uffer = hostBuffer.GetSubBuffer(inputTensorSize + outputMatrixSize, weightMatrixSize);; 248 ; 249 DeviceBuffer_t inputDeviceBuffer = deviceBuffer.GetSubBuffer(0, inputTensorSize);; 250 DeviceBuffer_t outputDeviceBuffer = deviceBuffer.GetSubBuffer(inputTensorSize, outputMatrixSize);; 251 DeviceBuffer_t weightDeviceBuffer = deviceBuffer.GetSubBuffer(inputTensorSize + outputMatrixSize, weightMatrixSize);; 252 ; 253 // here sample index has batch size as offset , while in; 254 // copy tensor input has batch depth.; 255 // We support then now two cases: batchdepth = 1 batchHeight = batch size; 256 // or batch depth = batch; 257 size_t sampleIndex = fBatchIndex * fBatchSize;; 258 IndexIterator_t sampleIndexIterator = fSampleIndices.begin() + sampleIndex;; 259 ; 260 CopyTensorInput(inputHostBuffer, sampleIndexIterator);; 261 CopyTensorOutput(outputHostBuffer, sampleIndexIterator);; 262 CopyTensorWeights(weightHostBuffer, sampleIndexIterator);; 263 ; 264 deviceBuffer.CopyFrom(hostBuffer);; 265 ; 266 assert(fInputLayout.size() == 3);; 267 Tensor_t inputTensor = Architecture_t::CreateTensor( inputDeviceBuffer, fBatchSize, fInputLayout[0], fInputLayout[1], fInputLayout[2] );; 268 // in case of dense layers; 269 if (fBatchDepth == 1 && fBatchHeight == fBatchSize && fInputLayout[0] == 1 && fInputLayout[1] == 1){; 270 inputTensor = Tensor_t( inputDeviceBuffer, {fBatchSize, fInputLayout.back() }, Tensor_t::MemoryLayout::ColumnMajor );; 271 }; 272 ; 273 Matrix_t outputMatrix(outputDeviceBuffer, fBatchSize, fNOutputFeatures);; 274 Matrix_t weightMatrix(weightDeviceBuffer, fBatchSize, 1);; 275 ; 276 fBatchIndex++;; 277 ; 278 ; 279 return TTensorBatch<Architecture_t>(inputTensor, outputMatrix, weightMatrix);; 280}; 281 ; 282//______________________________________________________________________________; 283template <typename Data_t, typename Architecture_t>; 284template <typename RNG>; 285void TTensorDataLoader<Data_t, Architecture_t>::Shuffle(RNG & rng); 286{; 287 std::shuffle(fSampl",MatchSource.WIKI,doc/master/TensorDataLoader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TensorDataLoader_8h_source.html
Availability,redundant,redundant,"); 36 ; 37Use option __entrylist__ to write the results of TTree::Draw and TChain::Draw into; 38an entry list. Example:; 39~~~ {.cpp}; 40 tree->Draw("">>elist"", ""x<0 && y>0"", ""entrylist"");; 41 TEntryList *elist = (TEntryList*)gDirectory->Get(""elist"");; 42~~~; 43## Example of Loop on TEntryList with a TChain; 44~~~ {.cpp}; 45 void loopChain() {; 46 TFile *fe = TFile::Open(""myelist.root"");; 47 TEntryList *myelist = (TEntryList*)fe->Get(""myelist"");; 48 TChain *chain = new TChain(""ntuple"");; 49 chain->Add(""hsimple.root"");; 50 chain->Add(""hsimple2.root"");; 51 Long64_t listEntries = myelist->GetN();; 52 Long64_t chainEntries = chain->GetEntries();; 53 Int_t treenum = 0;; 54 chain->SetEntryList(myelist);; 55 ; 56 for (entry=start;entry < end;entry++) {; 57 entryNumber = chain->GetEntryNumber(entry);; 58 if (entryNumber < 0) break;; 59 localEntry = chain->LoadTree(entryNumber);; 60 if (localEntry < 0) break;; 61 ....; 62 then either call; 63 branch->GetEntry(localEntry);; 64 or; 65 chain->GetEntry(entryNumber);; 66 In the later case the LoadTree is then somewhat redundant.; 67 ...; 68 }; 69 }; 70~~~; 71When using the TEntryList interface directly, you can get the 'tree number' and entry in; 72the current tree (i.e. value similar to the return value of LoadTree) from calling; 73TEntryList::GetEntryAndTree:; 74~~~ {.cpp}; 75 Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; 76~~~; 77to obtain the entry number within the chain you need to add to it the value of; 78`treeEntry+ch->GetTreeOffset()[treenum]`; 79such that the loop in the previous example can also be written as:; 80~~~ {.cpp}; 81 for (Long64_t el = 0; el < listEntries; el++) {; 82 Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; 83 Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum];; 84 printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainEntry, treenum);; 85 ; 86 ch->LoadTree(chainEntry); // this also returns treeEntry; 87 needed_branch->GetEntry(treeEntr",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
Deployability,configurat,configuration,"t){; 522 if (fCurrent->fBlocks){; 523 Int_t currentblock = (fCurrent->fLastIndexReturned)/kBlockSize;; 524 TEntryListBlock *block = (TEntryListBlock*)fCurrent->fBlocks->UncheckedAt(currentblock);; 525 block->ResetIndices();; 526 fCurrent->fLastIndexReturned = 0;; 527 fCurrent->fLastIndexQueried = -1;; 528 }; 529 }; 530 fCurrent = nullptr;; 531 }; 532 ; 533}; 534 ; 535////////////////////////////////////////////////////////////////////////////////; 536/// \brief Add a sub entry list to the current list.; 537/// \param[in] elist an entry list that should be added as a sub list of this list.; 538///; 539/// This function is specifically targeted at situations where there is a global; 540/// TEntryList that should hold one or more sub TEntryList objects. For example,; 541/// if one wants to create a one to one mapping between the sub entry lists and; 542/// the trees in the files that make a TChain. Note that in such cases this; 543/// configuration of the entry list should be used in pair with the option \p ""sync""; 544/// of the function TChain::SetEntryList; 545///; 546/// ~~~{.cpp}; 547/// // Create a TChain with two files. Each contains a tree with 20 entries; 548/// TChain chain{""entries""};; 549/// chain.Add(""file_20entries_1.root"");; 550/// chain.Add(""file_20entries_2.root"");; 551///; 552/// // Create a global, empty TEntryList.; 553/// TEntryList elists;; 554/// // Create two entry lists. Each one will be referring to a different tree in the chain; 555/// TEntryList elist1{"""","""",""entries"",""file_20entries_1.root""};; 556/// TEntryList elist2{"""","""",""entries"",""file_20entries_2.root""};; 557///; 558/// // Select the first ten entries from the first tree and all entries from the second; 559/// for(auto entry = 0; entry < 10; entry++){; 560/// elist1.Enter(entry);; 561/// }; 562/// for(auto entry = 0; entry < 20; entry++){; 563/// elist2.Enter(entry);; 564/// }; 565///; 566/// // Add sub entry lists to the global list; 567/// elists.AddSubList(&elist1);; 568/// elists.Add",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
Integrability,interface,interface,"st"", ""x<0 && y>0"", ""entrylist"");; 41 TEntryList *elist = (TEntryList*)gDirectory->Get(""elist"");; 42~~~; 43## Example of Loop on TEntryList with a TChain; 44~~~ {.cpp}; 45 void loopChain() {; 46 TFile *fe = TFile::Open(""myelist.root"");; 47 TEntryList *myelist = (TEntryList*)fe->Get(""myelist"");; 48 TChain *chain = new TChain(""ntuple"");; 49 chain->Add(""hsimple.root"");; 50 chain->Add(""hsimple2.root"");; 51 Long64_t listEntries = myelist->GetN();; 52 Long64_t chainEntries = chain->GetEntries();; 53 Int_t treenum = 0;; 54 chain->SetEntryList(myelist);; 55 ; 56 for (entry=start;entry < end;entry++) {; 57 entryNumber = chain->GetEntryNumber(entry);; 58 if (entryNumber < 0) break;; 59 localEntry = chain->LoadTree(entryNumber);; 60 if (localEntry < 0) break;; 61 ....; 62 then either call; 63 branch->GetEntry(localEntry);; 64 or; 65 chain->GetEntry(entryNumber);; 66 In the later case the LoadTree is then somewhat redundant.; 67 ...; 68 }; 69 }; 70~~~; 71When using the TEntryList interface directly, you can get the 'tree number' and entry in; 72the current tree (i.e. value similar to the return value of LoadTree) from calling; 73TEntryList::GetEntryAndTree:; 74~~~ {.cpp}; 75 Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; 76~~~; 77to obtain the entry number within the chain you need to add to it the value of; 78`treeEntry+ch->GetTreeOffset()[treenum]`; 79such that the loop in the previous example can also be written as:; 80~~~ {.cpp}; 81 for (Long64_t el = 0; el < listEntries; el++) {; 82 Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; 83 Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum];; 84 printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainEntry, treenum);; 85 ; 86 ch->LoadTree(chainEntry); // this also returns treeEntry; 87 needed_branch->GetEntry(treeEntry);; 88 }; 89~~~; 90## TSelectors; 91 ; 92To fill an TEntryList from a TSelector correctly, one must add the TEntryList object; 93to the output list of the",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
Modifiability,config,configuration,"t){; 522 if (fCurrent->fBlocks){; 523 Int_t currentblock = (fCurrent->fLastIndexReturned)/kBlockSize;; 524 TEntryListBlock *block = (TEntryListBlock*)fCurrent->fBlocks->UncheckedAt(currentblock);; 525 block->ResetIndices();; 526 fCurrent->fLastIndexReturned = 0;; 527 fCurrent->fLastIndexQueried = -1;; 528 }; 529 }; 530 fCurrent = nullptr;; 531 }; 532 ; 533}; 534 ; 535////////////////////////////////////////////////////////////////////////////////; 536/// \brief Add a sub entry list to the current list.; 537/// \param[in] elist an entry list that should be added as a sub list of this list.; 538///; 539/// This function is specifically targeted at situations where there is a global; 540/// TEntryList that should hold one or more sub TEntryList objects. For example,; 541/// if one wants to create a one to one mapping between the sub entry lists and; 542/// the trees in the files that make a TChain. Note that in such cases this; 543/// configuration of the entry list should be used in pair with the option \p ""sync""; 544/// of the function TChain::SetEntryList; 545///; 546/// ~~~{.cpp}; 547/// // Create a TChain with two files. Each contains a tree with 20 entries; 548/// TChain chain{""entries""};; 549/// chain.Add(""file_20entries_1.root"");; 550/// chain.Add(""file_20entries_2.root"");; 551///; 552/// // Create a global, empty TEntryList.; 553/// TEntryList elists;; 554/// // Create two entry lists. Each one will be referring to a different tree in the chain; 555/// TEntryList elist1{"""","""",""entries"",""file_20entries_1.root""};; 556/// TEntryList elist2{"""","""",""entries"",""file_20entries_2.root""};; 557///; 558/// // Select the first ten entries from the first tree and all entries from the second; 559/// for(auto entry = 0; entry < 10; entry++){; 560/// elist1.Enter(entry);; 561/// }; 562/// for(auto entry = 0; entry < 20; entry++){; 563/// elist2.Enter(entry);; 564/// }; 565///; 566/// // Add sub entry lists to the global list; 567/// elists.AddSubList(&elist1);; 568/// elists.Add",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
Performance,load,loadable,"*"");; 1594 }; 1595 ; 1596 if (xrl != roots) {; 1597 xrl->SetOwner(true);; 1598 SafeDelete(xrl);; 1599 }; 1600 ; 1601 // Done; 1602 return nrl;; 1603}; 1604 ; 1605////////////////////////////////////////////////////////////////////////////////; 1606/// Scan TEntryList in 'fn' to find the common parts of paths.; 1607/// If 'roots' is defined, add the found roots to the list as TObjStrings.; 1608/// Return the number of common root paths found.; 1609 ; 1610Int_t TEntryList::Scan(const char *fn, TList *roots); 1611{; 1612 // Open the file for updating; 1613 TFile *fl = TFile::Open(fn);; 1614 if (!fl || (fl&& fl->IsZombie())) {; 1615 ::Error(""TEntryList::Relocate"", ""file '%s' cannot be open for reading"", fn);; 1616 return -1;; 1617 }; 1618 ; 1619 Int_t nrs = 0;; 1620 // Read the lists; 1621 TIter nxk(fl->GetListOfKeys());; 1622 TKey *key = nullptr;; 1623 while ((key = (TKey *) nxk())) {; 1624 if (!strcmp(key->GetClassName(), ""TEntryList"")) {; 1625 TEntryList *enl = dynamic_cast<TEntryList *>(fl->Get(key->GetName()));; 1626 if (enl) {; 1627 nrs += enl->ScanPaths(roots);; 1628 } else {; 1629 ::Error(""TEntryList::Scan"", ""object entry-list '%s' not found or not loadable!"", key->GetName());; 1630 }; 1631 }; 1632 }; 1633 // Close the file; 1634 fl->Close();; 1635 delete fl;; 1636 ; 1637 // Done; 1638 return nrs;; 1639}; 1640 ; 1641////////////////////////////////////////////////////////////////////////////////; 1642/// Custom streamer for class TEntryList to handle the different interpretation; 1643/// of fFileName between version 1 and >1 .; 1644 ; 1645void TEntryList::Streamer(TBuffer &b); 1646{; 1647 if (b.IsReading()) {; 1648 UInt_t R__s, R__c;; 1649 Version_t R__v = b.ReadVersion(&R__s, &R__c);; 1650 b.ReadClassBuffer(TEntryList::Class(), this, R__v, R__s, R__c);; 1651 if (R__v <= 1) {; 1652 // The filename contained also the protocol and host: this was dropped; 1653 // in version > 1 to allow re-localization; 1654 GetFileName(fFileName.Data(), fFileName);; 1655 }; 1656 } ",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
Safety,redund,redundant,"); 36 ; 37Use option __entrylist__ to write the results of TTree::Draw and TChain::Draw into; 38an entry list. Example:; 39~~~ {.cpp}; 40 tree->Draw("">>elist"", ""x<0 && y>0"", ""entrylist"");; 41 TEntryList *elist = (TEntryList*)gDirectory->Get(""elist"");; 42~~~; 43## Example of Loop on TEntryList with a TChain; 44~~~ {.cpp}; 45 void loopChain() {; 46 TFile *fe = TFile::Open(""myelist.root"");; 47 TEntryList *myelist = (TEntryList*)fe->Get(""myelist"");; 48 TChain *chain = new TChain(""ntuple"");; 49 chain->Add(""hsimple.root"");; 50 chain->Add(""hsimple2.root"");; 51 Long64_t listEntries = myelist->GetN();; 52 Long64_t chainEntries = chain->GetEntries();; 53 Int_t treenum = 0;; 54 chain->SetEntryList(myelist);; 55 ; 56 for (entry=start;entry < end;entry++) {; 57 entryNumber = chain->GetEntryNumber(entry);; 58 if (entryNumber < 0) break;; 59 localEntry = chain->LoadTree(entryNumber);; 60 if (localEntry < 0) break;; 61 ....; 62 then either call; 63 branch->GetEntry(localEntry);; 64 or; 65 chain->GetEntry(entryNumber);; 66 In the later case the LoadTree is then somewhat redundant.; 67 ...; 68 }; 69 }; 70~~~; 71When using the TEntryList interface directly, you can get the 'tree number' and entry in; 72the current tree (i.e. value similar to the return value of LoadTree) from calling; 73TEntryList::GetEntryAndTree:; 74~~~ {.cpp}; 75 Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; 76~~~; 77to obtain the entry number within the chain you need to add to it the value of; 78`treeEntry+ch->GetTreeOffset()[treenum]`; 79such that the loop in the previous example can also be written as:; 80~~~ {.cpp}; 81 for (Long64_t el = 0; el < listEntries; el++) {; 82 Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; 83 Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum];; 84 printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainEntry, treenum);; 85 ; 86 ch->LoadTree(chainEntry); // this also returns treeEntry; 87 needed_branch->GetEntry(treeEntr",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
Security,hash,hash,"cal);; 909 ; 910 if (!fLists){; 911 //there are no sublists; 912 if (!strcmp(treename, fTreeName.Data()) && !(strcmp(fn.Data(), fFileName.Data()))){; 913 return this;; 914 } else {; 915 //if the file is local, try the full name, unless ""ne"" option was specified; 916 if (!nexp && local){; 917 gSystem->ExpandPathName(fn);; 918 if (!gSystem->IsAbsoluteFileName(fn)); 919 gSystem->PrependPathName(gSystem->pwd(), fn);; 920 fn = gSystem->UnixPathName(fn);; 921 if (!strcmp(treename, fTreeName.Data()) && !(strcmp(fn.Data(), fFileName.Data()))); 922 return this;; 923 }; 924 return nullptr;; 925 }; 926 }; 927 ; 928 TString stotal = treename;; 929 stotal.Append(fn);; 930 ULong_t newhash = stotal.Hash();; 931 ; 932 TIter next(fLists);; 933 TEntryList *templist;; 934 while ((templist = (TEntryList*)next())){; 935 if (templist->fStringHash==0){; 936 stotal = templist->fTreeName + templist->fFileName;; 937 templist->fStringHash = stotal.Hash();; 938 }; 939 if (gDebug > 1); 940 Info(""GetEntryList"", ""file: %s (fn: %s), hash: %lu, element hash: %lu"",; 941 filename, fn.Data(), newhash, templist->fStringHash);; 942 if (newhash == templist->fStringHash){; 943 if (!strcmp(templist->GetTreeName(), treename) && !strcmp(templist->GetFileName(), fn.Data())){; 944 return templist;; 945 }; 946 }; 947 }; 948 ; 949 //didn't find anything for this filename, try the full name too; 950 if (!nexp && local){; 951 TString longname = fn;; 952 gSystem->ExpandPathName(longname);; 953 if (!gSystem->IsAbsoluteFileName(longname)); 954 gSystem->PrependPathName(gSystem->pwd(), longname);; 955 longname = gSystem->UnixPathName(longname);; 956 stotal = treename;; 957 stotal.Append(longname);; 958 newhash = stotal.Hash();; 959 next.Reset();; 960 while ((templist = (TEntryList*)next())){; 961 if (templist->fStringHash==0){; 962 stotal = templist->fTreeName + templist->fFileName;; 963 templist->fStringHash = stotal.Hash();; 964 }; 965 if (gDebug > 1); 966 Info(""GetEntryList"", ""file: %s (longname: %s), hash: %lu, elem",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
Testability,test,testing,"332{; 333 if (fBlocks){; 334 fBlocks->Delete();; 335 delete fBlocks;; 336 }; 337 fBlocks = nullptr;; 338 if (fLists){; 339 fLists->Delete();; 340 delete fLists;; 341 }; 342 ; 343 fLists = nullptr;; 344 ; 345 if (fDirectory) fDirectory->Remove(this);; 346 fDirectory = nullptr;; 347 ; 348}; 349 ; 350////////////////////////////////////////////////////////////////////////////////; 351/// \brief Add 2 entry lists.; 352///; 353/// \param[in] elist The list that should be added to the current one.; 354///; 355/// \note If you are creating a TEntryList for a TChain and you would like to; 356/// have a one to one mapping between the sub lists of the TEntryList and; 357/// the sub trees in the TChain, please do not call this function but use; 358/// TEntryList::AddSubList instead and pair it with a call to; 359/// TChain::SetEntryList with option ""sync"". See the AddSubList function; 360/// documentation for an example usage. This helps for example in a; 361/// testing or benchmark scenario where a TChain holds multiple times the; 362/// same tree in the same file. In that case, this function would not be; 363/// be able to distinguish different sub entry lists that refer to the; 364/// same treename and filename. Instead it would create a union of all the; 365/// sub entry lists into one list.; 366 ; 367void TEntryList::Add(const TEntryList *elist); 368{; 369 if (fN==0){; 370 if (!fLists && fTreeName=="""" && fFileName==""""){; 371 //this list is empty. copy the other list completely; 372 fNBlocks = elist->fNBlocks;; 373 fTreeName = elist->fTreeName;; 374 fFileName = elist->fFileName;; 375 fStringHash = elist->fStringHash;; 376 fTreeNumber = elist->fTreeNumber;; 377 fLastIndexQueried = -1;; 378 fLastIndexReturned = 0;; 379 fN = elist->fN;; 380 if (elist->fLists){; 381 fLists = new TList();; 382 TEntryList *el1 = nullptr;; 383 TEntryList *el2 = nullptr;; 384 TIter next(elist->fLists);; 385 while((el1 = (TEntryList*)next())){; 386 el2 = new TEntryList(*el1);; 387 if (el1==elist->f",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
Performance,optimiz,optimize,"************************************************************************/; 11 ; 12#ifndef ROOT_TEntryList; 13#define ROOT_TEntryList; 14 ; 15#include ""TNamed.h""; 16 ; 17class TTree;; 18class TDirectory;; 19class TObjArray;; 20class TString;; 21 ; 22class TList;; 23class TCollection;; 24 ; 25class TEntryList: public TNamed; 26{; 27 private:; 28 TEntryList& operator=(const TEntryList&); // Not implemented; 29 ; 30 protected:; 31 TList *fLists; ///< a list of underlying entry lists for each tree of a chain; 32 TEntryList *fCurrent; ///<! currently filled entry list; 33 ; 34 Int_t fNBlocks; ///< number of TEntryListBlocks; 35 TObjArray *fBlocks; ///< blocks with indices of passing events (TEntryListBlocks); 36 Long64_t fN; ///< number of entries in the list; 37 Long64_t fEntriesToProcess; ///< used on proof to set the number of entries to process in a packet; 38 TString fTreeName; ///< name of the tree; 39 TString fFileName; ///< name of the file, where the tree is; 40 ULong_t fStringHash; ///<! Hash value of a string of treename and filename; 41 Int_t fTreeNumber; ///<! the index of the tree in the chain (used when the entry; 42 ///< list is used as input (TTree::SetEntryList()); 43 ; 44 Long64_t fLastIndexQueried; ///<! used to optimize GetEntry() function from a loop; 45 Long64_t fLastIndexReturned; ///<! used to optimize GetEntry() function from a loop; 46 bool fShift; ///<! true when some sub-lists don't correspond to trees; 47 ///< (when the entry list is used as input in TChain); 48 TDirectory *fDirectory; ///<! Pointer to directory holding this tree; 49 bool fReapply; ///< If true, TTree::Draw will 'reapply' the original cut; 50 ; 51 void GetFileName(const char *filename, TString &fn, bool * = nullptr);; 52 ; 53 public:; 54 enum {kBlockSize = 64000}; //number of entries in each block (not the physical size).; 55 ; 56 TEntryList();; 57 TEntryList(const char *name, const char *title);; 58 TEntryList(const char *name, const char *title, const TTree *tree);; 59 TEntr",MatchSource.WIKI,doc/master/TEntryList_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8h_source.html
Availability,error,error,"nv();; 560 return;; 561 }; 562 ; 563 if (!strcmp(opt, ""global"")); 564 PrintEnv(kEnvGlobal);; 565 if (!strcmp(opt, ""user"")); 566 PrintEnv(kEnvUser);; 567 if (!strcmp(opt, ""local"")); 568 PrintEnv(kEnvLocal);; 569}; 570 ; 571////////////////////////////////////////////////////////////////////////////////; 572/// Print all resources for a certain level (global, user, local, changed).; 573 ; 574void TEnv::PrintEnv(EEnvLevel level) const; 575{; 576 if (!fTable) return;; 577 ; 578 TIter next(fTable);; 579 TEnvRec *er;; 580 static const char *lc[] = { ""Global"", ""User"", ""Local"", ""Changed"", ""All"" };; 581 ; 582 while ((er = (TEnvRec*) next())); 583 if (er->fLevel == level || level == kEnvAll); 584 Printf(""%-25s %-30s [%s]"", TString::Format(""%s:"", er->fName.Data()).Data(),; 585 er->fValue.Data(), lc[er->fLevel]);; 586}; 587 ; 588////////////////////////////////////////////////////////////////////////////////; 589/// Read and parse the resource file for a certain level.; 590/// Returns -1 on case of error, 0 in case of success.; 591 ; 592Int_t TEnv::ReadFile(const char *fname, EEnvLevel level); 593{; 594 if (!fname || !fname[0]) {; 595 Error(""ReadFile"", ""no file name specified"");; 596 return -1;; 597 }; 598 ; 599 FILE *ifp;; 600 if ((ifp = fopen(fname, ""r""))) {; 601 TReadEnvParser rp(this, ifp, level);; 602 rp.Parse();; 603 fclose(ifp);; 604 return 0;; 605 }; 606 ; 607 // no Error() here since we are allowed to try to read from a non-existing; 608 // file (like ./.rootrc, $HOME/.rootrc, etc.); 609 return -1;; 610}; 611 ; 612////////////////////////////////////////////////////////////////////////////////; 613/// Write resource records to file fname for a certain level. Use; 614/// level kEnvAll to write all resources. Returns -1 on case of error,; 615/// 0 in case of success.; 616 ; 617Int_t TEnv::WriteFile(const char *fname, EEnvLevel level); 618{; 619 if (!fname || !fname[0]) {; 620 Error(""WriteFile"", ""no file name specified"");; 621 return -1;; 622 }; 623 ; 624 if (!fTable) {; 6",MatchSource.WIKI,doc/master/TEnv_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html
Deployability,install,installation,"elete; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition THashList.cxx:207; THashList::FindObjectTObject * FindObject(const char *name) const overrideFind object using its name.Definition THashList.cxx:262; TIterDefinition TCollection.h:235; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TReadEnvParserDefinition TEnv.cxx:228; TReadEnvParser::KeyValuevoid KeyValue(const TString &name, const TString &value, const TString &type) overrideDefinition TEnv.cxx:235; TReadEnvParser::TReadEnvParserTReadEnvParser(TEnv *e, FILE *f, EEnvLevel l)Definition TEnv.cxx:234; TReadEnvParser::fLevelEEnvLevel fLevelDefinition TEnv.cxx:231; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::CompareToint CompareTo(const char *cs, ECaseCompare cmp=kExact) constCompare a string to char *cs2.Definition TString.cxx:457; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECase",MatchSource.WIKI,doc/master/TEnv_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html
Integrability,message,message,"elvirtual void SaveLevel(EEnvLevel level)Write the resource file for a certain level.Definition TEnv.cxx:664; TEnv::~TEnvvirtual ~TEnv()Delete the resource table.Definition TEnv.cxx:430; TEnv::TEnvTEnv(const TEnv &)=delete; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition THashList.cxx:207; THashList::FindObjectTObject * FindObject(const char *name) const overrideFind object using its name.Definition THashList.cxx:262; TIterDefinition TCollection.h:235; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TReadEnvParserDefinition TEnv.cxx:228; TReadEnvParser::KeyValuevoid KeyValue(const TString &name, const TString &value, const TString &type) overrideDefinition TEnv.cxx:235; TReadEnvParser::TReadEnvParserTReadEnvParser(TEnv *e, FILE *f, EEnvLevel l)Definition TEnv.cxx:234; TReadEnvParser::fLevelEEnvLevel fLevelDefinition TEnv.cxx:231; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::CompareToint CompareTo(const char *cs, ECaseCompare cmp=kExact) constCompare a string to char *cs2.Definition TString.cxx:457; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TStri",MatchSource.WIKI,doc/master/TEnv_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html
Modifiability,config,config,". ROOT: core/base/src/TEnv.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TEnv.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id: 0daf41ec24086ee7af29fdc2f9f2f848b150dcc8 $; 2// Author: Fons Rademakers 22/09/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TEnv; 13\ingroup Base; 14 ; 15The TEnv class reads config files, by default named `.rootrc`.; 16Three types of config files are read: global, user and local files. The; 17global file is `$ROOTSYS/etc/system<name>` (or `ROOTETCDIR/system<name>`); 18the user file is `$HOME/<name>` and the local file is `./<name>`.; 19By setting the shell variable `ROOTENV_NO_HOME=1` the reading of; 20the `$HOME/<name>` resource file will be skipped. This might be useful; 21in case the home directory resides on an auto-mounted remote file; 22system and one wants to avoid this file system from being mounted.; 23 ; 24The format of the `.rootrc` file is similar to the `.Xdefaults` format:; 25~~~ {.cpp}; 26 [+]<SystemName>.<RootName|ProgName>.<name>[(type)]: <value>; 27~~~; 28Where `<SystemName>` is either Unix, WinNT, MacOS or Vms,; 29`<RootName>` the name as given in the TApplication ctor (or ""RootApp""; 30in case no explicit TApplication derived object was created),; 31`<ProgName>` the current program name and `<name>` the resource name,; 32with optionally a type specification. `<value>` can be either a; 33string, an integer, a float/double or a boolean with the values; 34TRUE, FALSE, ON, OFF, YES, NO, OK, NOT. Booleans will be returned as; 35an integer 0 or 1. The options [+] allows the concatenation of; 36values to the same res",MatchSource.WIKI,doc/master/TEnv_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html
Safety,avoid,avoid,"base:$Id: 0daf41ec24086ee7af29fdc2f9f2f848b150dcc8 $; 2// Author: Fons Rademakers 22/09/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TEnv; 13\ingroup Base; 14 ; 15The TEnv class reads config files, by default named `.rootrc`.; 16Three types of config files are read: global, user and local files. The; 17global file is `$ROOTSYS/etc/system<name>` (or `ROOTETCDIR/system<name>`); 18the user file is `$HOME/<name>` and the local file is `./<name>`.; 19By setting the shell variable `ROOTENV_NO_HOME=1` the reading of; 20the `$HOME/<name>` resource file will be skipped. This might be useful; 21in case the home directory resides on an auto-mounted remote file; 22system and one wants to avoid this file system from being mounted.; 23 ; 24The format of the `.rootrc` file is similar to the `.Xdefaults` format:; 25~~~ {.cpp}; 26 [+]<SystemName>.<RootName|ProgName>.<name>[(type)]: <value>; 27~~~; 28Where `<SystemName>` is either Unix, WinNT, MacOS or Vms,; 29`<RootName>` the name as given in the TApplication ctor (or ""RootApp""; 30in case no explicit TApplication derived object was created),; 31`<ProgName>` the current program name and `<name>` the resource name,; 32with optionally a type specification. `<value>` can be either a; 33string, an integer, a float/double or a boolean with the values; 34TRUE, FALSE, ON, OFF, YES, NO, OK, NOT. Booleans will be returned as; 35an integer 0 or 1. The options [+] allows the concatenation of; 36values to the same resource name.; 37 ; 38E.g.:; 39~~~ {.cpp}; 40 Unix.Rint.Root.DynamicPath: .:$(ROOTSYS)/lib:~/lib; 41 myapp.Root.Debug: FALSE; 42 TH.Root.Debug: YES; 43 *.Root.ObjStat: 1; 44~~~; 45`<Syste",MatchSource.WIKI,doc/master/TEnv_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html
Security,hash,hash,"*fname, EEnvLevel level)Read and parse the resource file for a certain level.Definition TEnv.cxx:592; TEnv::SetValuevirtual void SetValue(const char *name, const char *value, EEnvLevel level=kEnvChange, const char *type=nullptr)Set the value of a resource or create a new resource.Definition TEnv.cxx:736; TEnv::Lookupvirtual TEnvRec * Lookup(const char *n) constLoop over all resource records and return the one with name.Definition TEnv.cxx:547; TEnv::Savevirtual void Save()Write the resource files for each level.Definition TEnv.cxx:649; TEnv::fIgnoreDupBool_t fIgnoreDupDefinition TEnv.h:129; TEnv::Getvalueconst char * Getvalue(const char *name) constReturns the character value for a named resource.Definition TEnv.cxx:441; TEnv::SaveLevelvirtual void SaveLevel(EEnvLevel level)Write the resource file for a certain level.Definition TEnv.cxx:664; TEnv::~TEnvvirtual ~TEnv()Delete the resource table.Definition TEnv.cxx:430; TEnv::TEnvTEnv(const TEnv &)=delete; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition THashList.cxx:207; THashList::FindObjectTObject * FindObject(const char *name) const overrideFind object using its name.Definition THashList.cxx:262; TIterDefinition TCollection.h:235; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the",MatchSource.WIKI,doc/master/TEnv_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html
Integrability,depend,dependency,". ROOT: core/base/inc/TEnv.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations |; Variables ; TEnv.h File Reference. #include ""TObject.h""; #include ""TString.h"". Include dependency graph for TEnv.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TEnv;  The TEnv class reads config files, by default named .rootrc. More...;  ; class  TEnvRec;  . Enumerations; enum  EEnvLevel { ;   kEnvGlobal; , kEnvUser; , kEnvLocal; , kEnvChange; , ;   kEnvAll. };  . Variables; R__EXTERN TEnv * gEnv;  . Enumeration Type Documentation. ◆ EEnvLevel. enum EEnvLevel. EnumeratorkEnvGlobal ; kEnvUser ; kEnvLocal ; kEnvChange ; kEnvAll . Definition at line 69 of file TEnv.h. Variable Documentation. ◆ gEnv. R__EXTERN TEnv* gEnv. Definition at line 170 of file TEnv.h. corebaseincTEnv.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:12 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TEnv_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8h.html
Modifiability,config,config,". ROOT: core/base/inc/TEnv.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations |; Variables ; TEnv.h File Reference. #include ""TObject.h""; #include ""TString.h"". Include dependency graph for TEnv.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TEnv;  The TEnv class reads config files, by default named .rootrc. More...;  ; class  TEnvRec;  . Enumerations; enum  EEnvLevel { ;   kEnvGlobal; , kEnvUser; , kEnvLocal; , kEnvChange; , ;   kEnvAll. };  . Variables; R__EXTERN TEnv * gEnv;  . Enumeration Type Documentation. ◆ EEnvLevel. enum EEnvLevel. EnumeratorkEnvGlobal ; kEnvUser ; kEnvLocal ; kEnvChange ; kEnvAll . Definition at line 69 of file TEnv.h. Variable Documentation. ◆ gEnv. R__EXTERN TEnv* gEnv. Definition at line 170 of file TEnv.h. corebaseincTEnv.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:12 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TEnv_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8h.html
Deployability,configurat,configuration,"9// //; 120// TEnv //; 121// //; 122//////////////////////////////////////////////////////////////////////////; 123 ; 124class TEnv : public TObject {; 125 ; 126private:; 127 THashList *fTable; // hash table containing env records; 128 TString fRcName; // resource file base name; 129 Bool_t fIgnoreDup; // ignore duplicates, don't issue warning; 130 ; 131 TEnv(const TEnv&) = delete;; 132 TEnv& operator=(const TEnv&) = delete;; 133 ; 134 const char *Getvalue(const char *name) const;; 135 ; 136public:; 137 TEnv(const char *name="""");; 138 virtual ~TEnv();; 139 ; 140 THashList *GetTable() const { return fTable; }; 141 Bool_t Defined(const char *name) const; 142 { return Getvalue(name) != nullptr; }; 143 ; 144 virtual const char *GetRcName() const { return fRcName; }; 145 virtual void SetRcName(const char *name) { fRcName = name; }; 146 ; 147 virtual Int_t GetValue(const char *name, Int_t dflt) const;; 148 virtual Double_t GetValue(const char *name, Double_t dflt) const;; 149 virtual const char *GetValue(const char *name, const char *dflt) const;; 150 ; 151 virtual void SetValue(const char *name, const char *value,; 152 EEnvLevel level = kEnvChange,; 153 const char *type = nullptr);; 154 virtual void SetValue(const char *name, EEnvLevel level = kEnvChange);; 155 virtual void SetValue(const char *name, Int_t value);; 156 virtual void SetValue(const char *name, Double_t value);; 157 ; 158 virtual TEnvRec *Lookup(const char *n) const;; 159 virtual Int_t ReadFile(const char *fname, EEnvLevel level);; 160 virtual Int_t WriteFile(const char *fname, EEnvLevel level = kEnvAll);; 161 virtual void Save();; 162 virtual void SaveLevel(EEnvLevel level);; 163 void Print(Option_t *option="""") const override;; 164 virtual void PrintEnv(EEnvLevel level = kEnvAll) const;; 165 Bool_t IgnoreDuplicates(Bool_t ignore);; 166 ; 167 ClassDefOverride(TEnv,2) // Handle ROOT configuration resources; 168};; 169 ; 170R__EXTERN TEnv *gEnv;; 171 ; 172#endif; R__EXTERN#define R__EXTERNDefinition DllImport.",MatchSource.WIKI,doc/master/TEnv_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8h_source.html
Modifiability,config,config,". ROOT: core/base/inc/TEnv.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TEnv.h. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Fons Rademakers 22/09/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TEnv; 13#define ROOT_TEnv; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TEnv //; 19// //; 20// The TEnv class reads config files, by default named .rootrc. Three //; 21// types of config files are read: global, user and local files. The //; 22// global file is $ROOTSYS/etc/system<name> (or ROOTETCDIR/system<name>)//; 23// the user file is $HOME/<name> and the local file is ./<name>. //; 24// By setting the shell variable ROOTENV_NO_HOME=1 the reading of //; 25// the $HOME/<name> resource file will be skipped. This might be useful //; 26// in case the home directory resides on an automounted remote file //; 27// system and one wants to avoid this file system from being mounted. //; 28// //; 29// The format of the .rootrc file is similar to the .Xdefaults format: //; 30// //; 31// [+]<SystemName>.<RootName|ProgName>.<name>[(type)]: <value> //; 32// //; 33// Where <SystemName> is either Unix, WinNT, MacOS or Vms, //; 34// <RootName> the name as given in the TApplication ctor (or ""RootApp"" //; 35// in case no explicit TApplication derived object was created), //; 36// <ProgName> the current program name and <name> the resource name, //; 37// with optionally a type specification. <value> can be either a //; 38// string, an integer, a float/double or a boolean with the values //; 39// TRUE, FALSE, ON, ",MatchSource.WIKI,doc/master/TEnv_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8h_source.html
Safety,avoid,avoid,"***************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TEnv; 13#define ROOT_TEnv; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TEnv //; 19// //; 20// The TEnv class reads config files, by default named .rootrc. Three //; 21// types of config files are read: global, user and local files. The //; 22// global file is $ROOTSYS/etc/system<name> (or ROOTETCDIR/system<name>)//; 23// the user file is $HOME/<name> and the local file is ./<name>. //; 24// By setting the shell variable ROOTENV_NO_HOME=1 the reading of //; 25// the $HOME/<name> resource file will be skipped. This might be useful //; 26// in case the home directory resides on an automounted remote file //; 27// system and one wants to avoid this file system from being mounted. //; 28// //; 29// The format of the .rootrc file is similar to the .Xdefaults format: //; 30// //; 31// [+]<SystemName>.<RootName|ProgName>.<name>[(type)]: <value> //; 32// //; 33// Where <SystemName> is either Unix, WinNT, MacOS or Vms, //; 34// <RootName> the name as given in the TApplication ctor (or ""RootApp"" //; 35// in case no explicit TApplication derived object was created), //; 36// <ProgName> the current program name and <name> the resource name, //; 37// with optionally a type specification. <value> can be either a //; 38// string, an integer, a float/double or a boolean with the values //; 39// TRUE, FALSE, ON, OFF, YES, NO, OK, NOT. Booleans will be returned as //; 40// an integer 0 or 1. The options [+] allows the concatenation of //; 41// values to the same resouce name. //; 42// //; 43// E.g.: //; 44// //; 45// Unix.Rint.Root.DynamicPath: .:$ROOTSYS/lib:~/lib //; 46// myapp.Root.Debug:",MatchSource.WIKI,doc/master/TEnv_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8h_source.html
Security,hash,hash,,MatchSource.WIKI,doc/master/TEnv_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8h_source.html
Availability,error,error,". ROOT: core/foundation/src/TError.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TError.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Fons Rademakers 29/07/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/**; 13Error handling routines.; 14 ; 15This file defines a number of global error handling routines:; 16Warning(), Error(), SysError() and Fatal(). They all take a; 17location string (where the error happened) and a printf style format; 18string plus vararg's. In the end these functions call an; 19errorhandler function. Initially the MinimalErrorHandler, which is supposed; 20to be replaced by the proper DefaultErrorHandler(); 21*/; 22 ; 23#include ""TError.h""; 24 ; 25#include <cstdarg>; 26#include <cstdio>; 27#include <cstdlib>; 28#include <cerrno>; 29#include <string>; 30 ; 31Int_t gErrorIgnoreLevel = kUnset;; 32Int_t gErrorAbortLevel = kSysError+1;; 33Bool_t gPrintViaErrorHandler = kFALSE;; 34 ; 35const char *kAssertMsg = ""%s violated at line %d of `%s'"";; 36const char *kCheckMsg = ""%s not true at line %d of `%s'"";; 37 ; 38static ErrorHandlerFunc_t gErrorHandler = ROOT::Internal::MinimalErrorHandler;; 39 ; 40 ; 41static ROOT::Internal::ErrorSystemMsgHandlerFunc_t &GetErrorSystemMsgHandlerRef(); 42{; 43 static ROOT::Internal::ErrorSystemMsgHandlerFunc_t h;; 44 return h;; 45}; 46 ; 47 ; 48namespace ROOT {; 49namespace Internal {; 50 ; 51ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler(); 52{; 53 return GetErrorSystemMsgHandlerRef();; 54}; 55 ; 56ErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h); 57{; 58 auto oldHa",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
Integrability,rout,routines,". ROOT: core/foundation/src/TError.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TError.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Fons Rademakers 29/07/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/**; 13Error handling routines.; 14 ; 15This file defines a number of global error handling routines:; 16Warning(), Error(), SysError() and Fatal(). They all take a; 17location string (where the error happened) and a printf style format; 18string plus vararg's. In the end these functions call an; 19errorhandler function. Initially the MinimalErrorHandler, which is supposed; 20to be replaced by the proper DefaultErrorHandler(); 21*/; 22 ; 23#include ""TError.h""; 24 ; 25#include <cstdarg>; 26#include <cstdio>; 27#include <cstdlib>; 28#include <cerrno>; 29#include <string>; 30 ; 31Int_t gErrorIgnoreLevel = kUnset;; 32Int_t gErrorAbortLevel = kSysError+1;; 33Bool_t gPrintViaErrorHandler = kFALSE;; 34 ; 35const char *kAssertMsg = ""%s violated at line %d of `%s'"";; 36const char *kCheckMsg = ""%s not true at line %d of `%s'"";; 37 ; 38static ErrorHandlerFunc_t gErrorHandler = ROOT::Internal::MinimalErrorHandler;; 39 ; 40 ; 41static ROOT::Internal::ErrorSystemMsgHandlerFunc_t &GetErrorSystemMsgHandlerRef(); 42{; 43 static ROOT::Internal::ErrorSystemMsgHandlerFunc_t h;; 44 return h;; 45}; 46 ; 47 ; 48namespace ROOT {; 49namespace Internal {; 50 ; 51ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler(); 52{; 53 return GetErrorSystemMsgHandlerRef();; 54}; 55 ; 56ErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h); 57{; 58 auto oldHa",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
Modifiability,inherit,inherited," }; 136 va_end(ap_copy);; 137 ; 138 std::string bp = buf;; 139 if (level >= kSysError && level < kFatal) {; 140 bp.push_back(' ');; 141 if (GetErrorSystemMsgHandlerRef()); 142 bp += GetErrorSystemMsgHandlerRef()();; 143 else; 144 bp += std::string(""(errno: "") + std::to_string(errno) + "")"";; 145 }; 146 ; 147 if (level != kFatal); 148 gErrorHandler(level, level >= gErrorAbortLevel, location, bp.c_str());; 149 else; 150 gErrorHandler(level, kTRUE, location, bp.c_str());; 151}; 152 ; 153////////////////////////////////////////////////////////////////////////////////; 154/// This function can be used in abstract base classes in case one does; 155/// not want to make the class a ""real"" (in C++ sense) ABC. If this; 156/// function is called it will warn the user that the function should; 157/// have been overridden.; 158 ; 159void AbstractMethod(const char *method); 160{; 161 Warning(method, ""this method must be overridden!"");; 162}; 163 ; 164////////////////////////////////////////////////////////////////////////////////; 165/// This function can be used in classes that should override a certain; 166/// function, but in the inherited class the function makes no sense.; 167 ; 168void MayNotUse(const char *method); 169{; 170 Warning(method, ""may not use this method"");; 171}; 172 ; 173////////////////////////////////////////////////////////////////////////////////; 174/// Use this function to declare a function obsolete. Specify as of which version; 175/// the method is obsolete and as from which version it will be removed.; 176 ; 177void Obsolete(const char *function, const char *asOfVers, const char *removedFromVers); 178{; 179 Warning(function, ""obsolete as of %s and will be removed from %s"", asOfVers, removedFromVers);; 180}; 181 ; 182////////////////////////////////////////////////////////////////////////////////; 183/// Use this function in case an error occurred.; 184 ; 185void Error(const char *location, const char *fmt, ...); 186{; 187 std::va_list ap;; 188 va_start",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
Performance,multi-thread,multi-threaded,"lerRef(); 42{; 43 static ROOT::Internal::ErrorSystemMsgHandlerFunc_t h;; 44 return h;; 45}; 46 ; 47 ; 48namespace ROOT {; 49namespace Internal {; 50 ; 51ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler(); 52{; 53 return GetErrorSystemMsgHandlerRef();; 54}; 55 ; 56ErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h); 57{; 58 auto oldHandler = GetErrorSystemMsgHandlerRef();; 59 GetErrorSystemMsgHandlerRef() = h;; 60 return oldHandler;; 61}; 62 ; 63/// A very simple error handler that is usually replaced by the TROOT default error handler.; 64/// The minimal error handler is not serialized across threads, so that output of multi-threaded programs; 65/// can get scrambled; 66/// @note `abort()` is only called if `abort_bool` is `true` and `level >= gErrorIgnoreLevel`; 67void MinimalErrorHandler(Int_t level, Bool_t abort_bool, const char *location, const char *msg); 68{; 69 if (level < gErrorIgnoreLevel); 70 return;; 71 ; 72 if (level >= kBreak); 73 fprintf(stderr, ""\n *** Break *** "");; 74 fprintf(stderr, ""<%s>: %s\n"", location ? location : ""unspecified location"", msg);; 75 fflush(stderr);; 76 if (abort_bool) {; 77 fprintf(stderr, ""aborting\n"");; 78 fflush(stderr);; 79 abort();; 80 }; 81}; 82 ; 83} // namespace Internal; 84} // namespace ROOT; 85 ; 86 ; 87////////////////////////////////////////////////////////////////////////////////; 88/// Set an errorhandler function. Returns the old handler.; 89 ; 90ErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler); 91{; 92 ErrorHandlerFunc_t oldhandler = gErrorHandler;; 93 gErrorHandler = newhandler;; 94 return oldhandler;; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Returns the current error handler function.; 99 ; 100ErrorHandlerFunc_t GetErrorHandler(); 101{; 102 return gErrorHandler;; 103}; 104 ; 105 ; 106////////////////////////////////////////////////////////////////////////////////; 107/// General error handler function.",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
Safety,abort,abort,"lerRef(); 42{; 43 static ROOT::Internal::ErrorSystemMsgHandlerFunc_t h;; 44 return h;; 45}; 46 ; 47 ; 48namespace ROOT {; 49namespace Internal {; 50 ; 51ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler(); 52{; 53 return GetErrorSystemMsgHandlerRef();; 54}; 55 ; 56ErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h); 57{; 58 auto oldHandler = GetErrorSystemMsgHandlerRef();; 59 GetErrorSystemMsgHandlerRef() = h;; 60 return oldHandler;; 61}; 62 ; 63/// A very simple error handler that is usually replaced by the TROOT default error handler.; 64/// The minimal error handler is not serialized across threads, so that output of multi-threaded programs; 65/// can get scrambled; 66/// @note `abort()` is only called if `abort_bool` is `true` and `level >= gErrorIgnoreLevel`; 67void MinimalErrorHandler(Int_t level, Bool_t abort_bool, const char *location, const char *msg); 68{; 69 if (level < gErrorIgnoreLevel); 70 return;; 71 ; 72 if (level >= kBreak); 73 fprintf(stderr, ""\n *** Break *** "");; 74 fprintf(stderr, ""<%s>: %s\n"", location ? location : ""unspecified location"", msg);; 75 fflush(stderr);; 76 if (abort_bool) {; 77 fprintf(stderr, ""aborting\n"");; 78 fflush(stderr);; 79 abort();; 80 }; 81}; 82 ; 83} // namespace Internal; 84} // namespace ROOT; 85 ; 86 ; 87////////////////////////////////////////////////////////////////////////////////; 88/// Set an errorhandler function. Returns the old handler.; 89 ; 90ErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler); 91{; 92 ErrorHandlerFunc_t oldhandler = gErrorHandler;; 93 gErrorHandler = newhandler;; 94 return oldhandler;; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Returns the current error handler function.; 99 ; 100ErrorHandlerFunc_t GetErrorHandler(); 101{; 102 return gErrorHandler;; 103}; 104 ; 105 ; 106////////////////////////////////////////////////////////////////////////////////; 107/// General error handler function.",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
Usability,simpl,simple,"g routines.; 14 ; 15This file defines a number of global error handling routines:; 16Warning(), Error(), SysError() and Fatal(). They all take a; 17location string (where the error happened) and a printf style format; 18string plus vararg's. In the end these functions call an; 19errorhandler function. Initially the MinimalErrorHandler, which is supposed; 20to be replaced by the proper DefaultErrorHandler(); 21*/; 22 ; 23#include ""TError.h""; 24 ; 25#include <cstdarg>; 26#include <cstdio>; 27#include <cstdlib>; 28#include <cerrno>; 29#include <string>; 30 ; 31Int_t gErrorIgnoreLevel = kUnset;; 32Int_t gErrorAbortLevel = kSysError+1;; 33Bool_t gPrintViaErrorHandler = kFALSE;; 34 ; 35const char *kAssertMsg = ""%s violated at line %d of `%s'"";; 36const char *kCheckMsg = ""%s not true at line %d of `%s'"";; 37 ; 38static ErrorHandlerFunc_t gErrorHandler = ROOT::Internal::MinimalErrorHandler;; 39 ; 40 ; 41static ROOT::Internal::ErrorSystemMsgHandlerFunc_t &GetErrorSystemMsgHandlerRef(); 42{; 43 static ROOT::Internal::ErrorSystemMsgHandlerFunc_t h;; 44 return h;; 45}; 46 ; 47 ; 48namespace ROOT {; 49namespace Internal {; 50 ; 51ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler(); 52{; 53 return GetErrorSystemMsgHandlerRef();; 54}; 55 ; 56ErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h); 57{; 58 auto oldHandler = GetErrorSystemMsgHandlerRef();; 59 GetErrorSystemMsgHandlerRef() = h;; 60 return oldHandler;; 61}; 62 ; 63/// A very simple error handler that is usually replaced by the TROOT default error handler.; 64/// The minimal error handler is not serialized across threads, so that output of multi-threaded programs; 65/// can get scrambled; 66/// @note `abort()` is only called if `abort_bool` is `true` and `level >= gErrorIgnoreLevel`; 67void MinimalErrorHandler(Int_t level, Bool_t abort_bool, const char *location, const char *msg); 68{; 69 if (level < gErrorIgnoreLevel); 70 return;; 71 ; 72 if (level >= kBreak); 73 fprintf(stderr, ""\n *** ",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
Availability,error,error,". ROOT: core/foundation/inc/TError.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Macros |; Typedefs |; Functions |; Variables ; TError.h File Reference. #include <DllImport.h>; #include ""RtypesCore.h""; #include <ROOT/RConfig.hxx>; #include <cstdarg>; #include <functional>. Include dependency graph for TError.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define R__ASSERT(e);  Checks condition e and reports a fatal error if it's false. ;  ; #define R__CHECK(e);  Checks condition e and reports a warning message if it's false. ;  . Typedefs; typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg);  ; using ROOT::Internal::ErrorSystemMsgHandlerFunc_t = std::function< const char *()>;  Retrieves the error string associated with the last system error. ;  . Functions; void AbstractMethod (const char *method);  This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ;  ; void Break (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg);  The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t Get",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
Deployability,release,release," in warning situations. ;  . Variables; Int_t gErrorAbortLevel;  ; Int_t gErrorIgnoreLevel;  Error handling routines. ;  ; Bool_t gPrintViaErrorHandler;  ; const char * kAssertMsg;  ; constexpr Int_t kBreak = 4000;  ; const char * kCheckMsg;  ; constexpr Int_t kError = 3000;  ; constexpr Int_t kFatal = 6000;  ; constexpr Int_t kInfo = 1000;  ; constexpr Int_t kPrint = 0;  ; constexpr Int_t kSysError = 5000;  ; constexpr Int_t kUnset = -1;  ; constexpr Int_t kWarning = 2000;  . Macro Definition Documentation. ◆ R__ASSERT. #define R__ASSERT; (;  ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Fatal("""", kAssertMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); _QUOTE_#define _QUOTE_(name)Definition RConfig.hxx:446; R__unlikely#define R__unlikely(expr)Definition RConfig.hxx:586; e#define e(i)Definition RSha256.hxx:103; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35. Checks condition e and reports a fatal error if it's false. ; Warning; this check is NOT stripped in release mode, so it should not be used for hot paths. For those cases, prefer a regular assert();; depending on gErrorIgnoreLevel, this might not terminate the program, . See alsoFatal. ; Definition at line 125 of file TError.h. ◆ R__CHECK. #define R__CHECK; (;  ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Warning("""", kCheckMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36. Checks condition e and reports a warning message if it's false. ; Warningthis check is NOT stripped in release mode, so it should not be used for hot paths. ; Definition at line 134 of file TError.h. Typedef Documentation. ◆ ErrorHandlerFunc_t. typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg). Definition at line 71 of file TError.h. Function Documentation. ◆ AbstractMethod(). void AbstractMethod ; (; const char * ; method). This function can be used in abstract base classes in case one does not want to ma",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
Integrability,depend,dependency,". ROOT: core/foundation/inc/TError.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Macros |; Typedefs |; Functions |; Variables ; TError.h File Reference. #include <DllImport.h>; #include ""RtypesCore.h""; #include <ROOT/RConfig.hxx>; #include <cstdarg>; #include <functional>. Include dependency graph for TError.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define R__ASSERT(e);  Checks condition e and reports a fatal error if it's false. ;  ; #define R__CHECK(e);  Checks condition e and reports a warning message if it's false. ;  . Typedefs; typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg);  ; using ROOT::Internal::ErrorSystemMsgHandlerFunc_t = std::function< const char *()>;  Retrieves the error string associated with the last system error. ;  . Functions; void AbstractMethod (const char *method);  This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ;  ; void Break (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg);  The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t Get",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
Modifiability,inherit,inherited,"ak (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg);  The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorHandler ();  Returns the current error handler function. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ();  ; void Info (const char *location, const char *msgfmt,...);  Use this function for informational messages. ;  ; void MayNotUse (const char *method);  This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ;  ; void ROOT::Internal::MinimalErrorHandler (Int_t level, Bool_t abort_bool, const char *location, const char *msg);  A very simple error handler that is usually replaced by the TROOT default error handler. ;  ; void Obsolete (const char *function, const char *asOfVers, const char *removedFromVers);  Use this function to declare a function obsolete. ;  ; ErrorHandlerFunc_t SetErrorHandler (ErrorHandlerFunc_t newhandler);  Set an errorhandler function. Returns the old handler. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::SetErrorSystemMsgHandler (ErrorSystemMsgHandlerFunc_t h);  Returns the previous system error message handler. ;  ; void SysError (const char *location, const char *msgfmt,...);  Use this function in case a system (OS or GUI) related error occurred. ;  ; void Warning (const char *location, const char *msgfmt,...);  Use this function in warning situations. ;  . Variables; Int_t ",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
Safety,abort,abort,": core/foundation/inc/TError.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Macros |; Typedefs |; Functions |; Variables ; TError.h File Reference. #include <DllImport.h>; #include ""RtypesCore.h""; #include <ROOT/RConfig.hxx>; #include <cstdarg>; #include <functional>. Include dependency graph for TError.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define R__ASSERT(e);  Checks condition e and reports a fatal error if it's false. ;  ; #define R__CHECK(e);  Checks condition e and reports a warning message if it's false. ;  . Typedefs; typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg);  ; using ROOT::Internal::ErrorSystemMsgHandlerFunc_t = std::function< const char *()>;  Retrieves the error string associated with the last system error. ;  . Functions; void AbstractMethod (const char *method);  This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ;  ; void Break (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg);  The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorH",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
Testability,assert,assert,"g routines. ;  ; Bool_t gPrintViaErrorHandler;  ; const char * kAssertMsg;  ; constexpr Int_t kBreak = 4000;  ; const char * kCheckMsg;  ; constexpr Int_t kError = 3000;  ; constexpr Int_t kFatal = 6000;  ; constexpr Int_t kInfo = 1000;  ; constexpr Int_t kPrint = 0;  ; constexpr Int_t kSysError = 5000;  ; constexpr Int_t kUnset = -1;  ; constexpr Int_t kWarning = 2000;  . Macro Definition Documentation. ◆ R__ASSERT. #define R__ASSERT; (;  ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Fatal("""", kAssertMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); _QUOTE_#define _QUOTE_(name)Definition RConfig.hxx:446; R__unlikely#define R__unlikely(expr)Definition RConfig.hxx:586; e#define e(i)Definition RSha256.hxx:103; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35. Checks condition e and reports a fatal error if it's false. ; Warning; this check is NOT stripped in release mode, so it should not be used for hot paths. For those cases, prefer a regular assert();; depending on gErrorIgnoreLevel, this might not terminate the program, . See alsoFatal. ; Definition at line 125 of file TError.h. ◆ R__CHECK. #define R__CHECK; (;  ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Warning("""", kCheckMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36. Checks condition e and reports a warning message if it's false. ; Warningthis check is NOT stripped in release mode, so it should not be used for hot paths. ; Definition at line 134 of file TError.h. Typedef Documentation. ◆ ErrorHandlerFunc_t. typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg). Definition at line 71 of file TError.h. Function Documentation. ◆ AbstractMethod(). void AbstractMethod ; (; const char * ; method). This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ; If this function is called it will warn the user that the func",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
Usability,simpl,simple," The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorHandler ();  Returns the current error handler function. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ();  ; void Info (const char *location, const char *msgfmt,...);  Use this function for informational messages. ;  ; void MayNotUse (const char *method);  This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ;  ; void ROOT::Internal::MinimalErrorHandler (Int_t level, Bool_t abort_bool, const char *location, const char *msg);  A very simple error handler that is usually replaced by the TROOT default error handler. ;  ; void Obsolete (const char *function, const char *asOfVers, const char *removedFromVers);  Use this function to declare a function obsolete. ;  ; ErrorHandlerFunc_t SetErrorHandler (ErrorHandlerFunc_t newhandler);  Set an errorhandler function. Returns the old handler. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::SetErrorSystemMsgHandler (ErrorSystemMsgHandlerFunc_t h);  Returns the previous system error message handler. ;  ; void SysError (const char *location, const char *msgfmt,...);  Use this function in case a system (OS or GUI) related error occurred. ;  ; void Warning (const char *location, const char *msgfmt,...);  Use this function in warning situations. ;  . Variables; Int_t gErrorAbortLevel;  ; Int_t gErrorIgnoreLevel;  Error handling routines. ;  ; Bool_t gPrintViaErrorHandler;  ; const char * kAssertMsg;  ; constexpr Int_t kBreak = 4000;  ; const char * kCheckMs",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
Performance,perform,perform," the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::GetTimeInt_t GetTime() constReturn time in form of 123623 (i.e. 12:36:23)Definition TDatime.cxx:259; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23; TGeoTessellated::ImportFromObjFormatstatic TGeoTessellated * ImportFromObjFormat(const char *objfile, bool check=false, bool verbose=false)Reader from .obj format.Definition TGeoTessellated.cxx:579; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; TGeoVolume::SetLineWidthvoid SetLineWidth(Width_t lwidth) overrideSet the line width.Definition TGeoVolume.cxx:2185; TGeoVolume::Raytracevoid Raytrace(Bool_t flag=kTRUE)Draw this volume with current settings and perform raytracing in the pad.Definition TGeoVolume.cxx:1427; TGeoVolume::AddNodevirtual TGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:975; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; TGeoVolume::SetLineColorvoid SetLineColor(Color_t lcolor) overrideSet the line color.Definition TGeoVolume.cxx:2169; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TRandom::SetSeedvirtual void SetSeed(ULong_t seed=0)Set the random generator seed.Definition TRandom.cxx:615; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, con",MatchSource.WIKI,doc/master/tessellatedNav_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tessellatedNav_8C.html
Availability,error,errors,". ROOT: tutorials/fit/TestBinomial.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TestBinomial.C File ReferenceTutorials » Fit Tutorials. Detailed Description; Perform a fit to a set of data with binomial errors like those derived from the division of two histograms. ; Three different fits are performed and compared:. simple least square fit to the divided histogram obtained from TH1::Divide with option b; least square fit to the TGraphAsymmErrors obtained from TGraphAsymmErrors::BayesDivide; likelihood fit performed on the dividing histograms using binomial statistics with the TBinomialEfficiency class. The first two methods are biased while the last one is statistical correct. Running the script passing an integer value n larger than 1, n fits are performed and the bias are also shown. To run the script :; to show the bias performing 100 fits for 1000 events per ""experiment""; root[0]: .x TestBinomial.C+; to show the bias performing 100 fits for 1000 events per ""experiment""; .x TestBinomial.C+(100, 1000). ; 32 68; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 0.350714; NDf = 3; Edm = 1.27001e-06; NCalls = 81; p0 = 0.694132 +/- 0.210029 ; p1 = 19.3471 +/- 5.85483 ; p2 = 5.2245 +/- 5.11013 ; ****************************************; Minimizer is Minuit2 / Migrad; MinFCN = 14.3081; Chi2 = 28.6162; NDf = 21; Edm = 4.11934e-08; NCalls = 91; p0 = 0.822966 +/- 0.0807557 (limited); p1 = 21.9819 +/- 2.14579 ; p2 = 3.36105 +/- 1.05866 ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 1.64738; NDf = 5; Edm = 1.01171e-06; NCalls = 137; p0 = 0.677329 +/- 0.135567 (limited); p1 = 15.5028 +/- 4.11118 ; p2 = 4.10441 +/- 2.77044 ; ****************************************; Minimizer is Minuit2 / Migrad; MinFCN = 19.363; Chi2 = 38.7261; NDf = 25; Edm = 9.40378e-08; NCalls = 80; p0 = 0.778188 +/- 0.0815568 (limited); p1 = 23.7948 +/- 2.21356 ; p2 = 4.58769 +/- 1.24153 ;",MatchSource.WIKI,doc/master/TestBinomial_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html
Energy Efficiency,schedul,scheduler,"ition TLegend.cxx:320; TLegend::Drawvoid Draw(Option_t *option="""") overrideDraw this legend with its current attributes.Definition TLegend.cxx:425; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; TPad::Dividevoid Divide(Int_t nx=1, Int_t ny=1, Float_t xmargin=0.01, Float_t ymargin=0.01, Int_t color=0) overrideAutomatic pad generation by division.Definition TPad.cxx:1249; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TStringBasic string class.Definition TString.h:139; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; TStyle::SetOptFitvoid SetOptFit(Int_t fit=1)The type of information about fit parameters printed in the histogram statistics box can be selected ...Definition TStyle.cxx:1593; TVirtualFitter::SetDefaultFitterstatic void SetDefaultFitter(const char *name="""")static: set name of default fitterDefinition TVirtualFitter.cxx:245; c1return c1Definition legend1.C:41; grTGraphErrors * grDefinition legend1.C:25; h1TH1F * h1Definition legend1.C:5; PyTorch_Generate_CNN_Model.fitfit(model, train_loader, val_loader, num_epochs, batch_size, optimizer, criterion, save_best, scheduler)Definition PyTorch_Generate_CNN_Model.py:34; ROOT::Fit::FillDatavoid FillData(BinData &dv, const TH1 *hist, TF1 *func=nullptr)fill the data vector from a TH1.Definition HFitInterface.cxx:107; AuthorRene Brun ; Definition in file TestBinomial.C. tutorialsfitTestBinomial.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TestBinomial_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html
Performance,perform,performed,". ROOT: tutorials/fit/TestBinomial.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TestBinomial.C File ReferenceTutorials » Fit Tutorials. Detailed Description; Perform a fit to a set of data with binomial errors like those derived from the division of two histograms. ; Three different fits are performed and compared:. simple least square fit to the divided histogram obtained from TH1::Divide with option b; least square fit to the TGraphAsymmErrors obtained from TGraphAsymmErrors::BayesDivide; likelihood fit performed on the dividing histograms using binomial statistics with the TBinomialEfficiency class. The first two methods are biased while the last one is statistical correct. Running the script passing an integer value n larger than 1, n fits are performed and the bias are also shown. To run the script :; to show the bias performing 100 fits for 1000 events per ""experiment""; root[0]: .x TestBinomial.C+; to show the bias performing 100 fits for 1000 events per ""experiment""; .x TestBinomial.C+(100, 1000). ; 32 68; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 0.350714; NDf = 3; Edm = 1.27001e-06; NCalls = 81; p0 = 0.694132 +/- 0.210029 ; p1 = 19.3471 +/- 5.85483 ; p2 = 5.2245 +/- 5.11013 ; ****************************************; Minimizer is Minuit2 / Migrad; MinFCN = 14.3081; Chi2 = 28.6162; NDf = 21; Edm = 4.11934e-08; NCalls = 91; p0 = 0.822966 +/- 0.0807557 (limited); p1 = 21.9819 +/- 2.14579 ; p2 = 3.36105 +/- 1.05866 ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 1.64738; NDf = 5; Edm = 1.01171e-06; NCalls = 137; p0 = 0.677329 +/- 0.135567 (limited); p1 = 15.5028 +/- 4.11118 ; p2 = 4.10441 +/- 2.77044 ; ****************************************; Minimizer is Minuit2 / Migrad; MinFCN = 19.363; Chi2 = 38.7261; NDf = 25; Edm = 9.40378e-08; NCalls = 80; p0 = 0.778188 +/- 0.0815568 (limited); p1 = 23.7948 +/- 2.21356 ; p2 = 4.58769 +/- 1.24153 ;",MatchSource.WIKI,doc/master/TestBinomial_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html
Safety,safe,safely,"; gStyle->SetLineWidth(2.0);; gStyle->SetOptStat(11);; ; TObjArray hbiasNorm;; hbiasNorm.Add(new TH1D(""h0Norm"", ""Bias Histogram fit"",100,-5,5));; hbiasNorm.Add(new TH1D(""h1Norm"",""Bias Binomial fit"",100,-5,5));; TObjArray hbiasThreshold;; hbiasThreshold.Add(new TH1D(""h0Threshold"", ""Bias Histogram fit"",100,-5,5));; hbiasThreshold.Add(new TH1D(""h1Threshold"",""Bias Binomial fit"",100,-5,5));; TObjArray hbiasWidth;; hbiasWidth.Add(new TH1D(""h0Width"", ""Bias Histogram fit"",100,-5,5));; hbiasWidth.Add(new TH1D(""h1Width"",""Bias Binomial fit"",100,-5,5));; TH1D* hChisquared = new TH1D(""hChisquared"",; ""#chi^{2} probability (Baker-Cousins)"", 200, 0.0, 1.0);; ; TVirtualFitter::SetDefaultFitter(""Minuit2"");; ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(""Gauss"");; ; // Note: in order to be able to use TH1::FillRandom() to generate; // pseudo-experiments, we use a trick: generate ""selected""; // and ""non-selected"" samples independently. These are; // statistically independent and therefore can be safely; // added to yield the ""before selection"" sample.; ; ; // Define (arbitrarily?) a distribution of input events.; // Here: assume a x^(-2) distribution. Boundaries: [10, 100].; ; double xmin =10, xmax = 100;; TH1D* hM2D = new TH1D(""hM2D"", ""x^(-2) denominator distribution"",; 45, xmin, xmax);; TH1D* hM2N = new TH1D(""hM2N"", ""x^(-2) numerator distribution"",; 45, xmin, xmax);; TH1D* hM2E = new TH1D(""hM2E"", ""x^(-2) efficiency"",; 45, xmin, xmax);; ; TF1* fM2D = new TF1(""fM2D"", ""(1-[0]/(1+exp(([1]-x)/[2])))/(x*x)"",; xmin, xmax);; TF1* fM2N = new TF1(""fM2N"", ""[0]/(1+exp(([1]-x)/[2]))/(x*x)"",; xmin, xmax);; TF1* fM2Fit = new TF1(""fM2Fit"", ""[0]/(1+exp(([1]-x)/[2]))"",; xmin, xmax);; TF1* fM2Fit2 = nullptr;; ; TRandom3 rb(seed);; ; // First try: use a single set of parameters.; // For each try, we need to find the overall normalization; ; double normalization = 0.80;; double threshold = 25.0;; double width = 5.0;; ; fM2D->SetParameter(0, normalization);; fM2D->SetParameter(1, threshold);; ",MatchSource.WIKI,doc/master/TestBinomial_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html
Usability,simpl,simple,". ROOT: tutorials/fit/TestBinomial.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TestBinomial.C File ReferenceTutorials » Fit Tutorials. Detailed Description; Perform a fit to a set of data with binomial errors like those derived from the division of two histograms. ; Three different fits are performed and compared:. simple least square fit to the divided histogram obtained from TH1::Divide with option b; least square fit to the TGraphAsymmErrors obtained from TGraphAsymmErrors::BayesDivide; likelihood fit performed on the dividing histograms using binomial statistics with the TBinomialEfficiency class. The first two methods are biased while the last one is statistical correct. Running the script passing an integer value n larger than 1, n fits are performed and the bias are also shown. To run the script :; to show the bias performing 100 fits for 1000 events per ""experiment""; root[0]: .x TestBinomial.C+; to show the bias performing 100 fits for 1000 events per ""experiment""; .x TestBinomial.C+(100, 1000). ; 32 68; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 0.350714; NDf = 3; Edm = 1.27001e-06; NCalls = 81; p0 = 0.694132 +/- 0.210029 ; p1 = 19.3471 +/- 5.85483 ; p2 = 5.2245 +/- 5.11013 ; ****************************************; Minimizer is Minuit2 / Migrad; MinFCN = 14.3081; Chi2 = 28.6162; NDf = 21; Edm = 4.11934e-08; NCalls = 91; p0 = 0.822966 +/- 0.0807557 (limited); p1 = 21.9819 +/- 2.14579 ; p2 = 3.36105 +/- 1.05866 ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 1.64738; NDf = 5; Edm = 1.01171e-06; NCalls = 137; p0 = 0.677329 +/- 0.135567 (limited); p1 = 15.5028 +/- 4.11118 ; p2 = 4.10441 +/- 2.77044 ; ****************************************; Minimizer is Minuit2 / Migrad; MinFCN = 19.363; Chi2 = 38.7261; NDf = 25; Edm = 9.40378e-08; NCalls = 80; p0 = 0.778188 +/- 0.0815568 (limited); p1 = 23.7948 +/- 2.21356 ; p2 = 4.58769 +/- 1.24153 ;",MatchSource.WIKI,doc/master/TestBinomial_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html
Security,access,accessors,". ROOT: tutorials/geom/gdml/testoptical.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. testoptical.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Tests importing/exporting optical surfaces from GDML. ; Optical surfaces, skin surfaces and border surfaces are imported in object arrays stored by TGeoManager class. Optical surfaces do not store property arrays but point to GDML matrices describing such properties. One can get the data for such property like: TGeoOpticalSurface *surf = geom->GetOpticalSurface(""surf1""); const char *property = surf=>GetPropertyRef(""REFLECTIVITY""); TGeoGDMLMatrix *m = geom->GetGDMLMatrix(property); Skin surfaces and border surfaces can be retrieved from the TGeoManager object by using: TObjArray *skin_array = geom->GetListOfSkinSurfaces(); TObjArra8 *border_array = geom->GetListOfBorderSurfaces(); Alternatively accessors by name can also be used: GetSkinSurface(name)/GetBorderSurface(name); AuthorAndrei Gheata ; Definition in file testoptical.C. tutorialsgeomgdmltestoptical.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/testoptical_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testoptical_8C.html
Testability,test,testoptical,". ROOT: tutorials/geom/gdml/testoptical.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. testoptical.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Tests importing/exporting optical surfaces from GDML. ; Optical surfaces, skin surfaces and border surfaces are imported in object arrays stored by TGeoManager class. Optical surfaces do not store property arrays but point to GDML matrices describing such properties. One can get the data for such property like: TGeoOpticalSurface *surf = geom->GetOpticalSurface(""surf1""); const char *property = surf=>GetPropertyRef(""REFLECTIVITY""); TGeoGDMLMatrix *m = geom->GetGDMLMatrix(property); Skin surfaces and border surfaces can be retrieved from the TGeoManager object by using: TObjArray *skin_array = geom->GetListOfSkinSurfaces(); TObjArra8 *border_array = geom->GetListOfBorderSurfaces(); Alternatively accessors by name can also be used: GetSkinSurface(name)/GetBorderSurface(name); AuthorAndrei Gheata ; Definition in file testoptical.C. tutorialsgeomgdmltestoptical.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/testoptical_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testoptical_8C.html
Deployability,continuous,continuous," %8.3f"",sw.CpuTime()*cpn);; gRandom = r1;; sw.Start();; for (i=0;i<N;i++) {; x = f1->GetRandom();; }; printf("" %8.3f"",sw.CpuTime()*cpn);; gRandom = r2;; sw.Start();; for (i=0;i<N;i++) {; x = f1->GetRandom();; }; printf("" %8.3f"",sw.CpuTime()*cpn);; gRandom = r3;; sw.Start();; for (i=0;i<N;i++) {; x = f1->GetRandom();; }; printf("" %8.3f\n"",sw.CpuTime()*cpn);; ; TF1 *f2 = new TF1(""f2"",""landau"",-5,15);; f2->SetParameters(1,0,1);; ; gRandom = r0;; sw.Start();; for (i=0;i<N;i++) {; x = f2->GetRandom();; }; printf(""LandauTF1......... %8.3f"",sw.CpuTime()*cpn);; gRandom = r1;; sw.Start();; for (i=0;i<N;i++) {; x = f2->GetRandom();; }; printf("" %8.3f"",sw.CpuTime()*cpn);; gRandom = r2;; sw.Start();; for (i=0;i<N;i++) {; x = f2->GetRandom();; }; printf("" %8.3f"",sw.CpuTime()*cpn);; gRandom = r3;; sw.Start();; for (i=0;i<N;i++) {; x = f2->GetRandom();; }; printf("" %8.3f\n"",sw.CpuTime()*cpn);; ; // test using Unuran; #if __has_include(""TUnuran.h""); TUnuran unr0(r0);; TUnuran unr1(r1);; TUnuran unr2(r2);; TUnuran unr3(r3);; ; // continuous distribution (ex. Gaus); TUnuranContDist dist(f1);; // use arou method (is probably the fastest); unr0.Init(dist,""arou"");; unr1.Init(dist,""arou"");; unr2.Init(dist,""arou"");; unr3.Init(dist,""arou"");; ; sw.Start();; for (i=0;i<N;i++) {; x = unr0.Sample();; }; printf(""GausUNURAN........ %8.3f"",sw.CpuTime()*cpn);; sw.Start();; for (i=0;i<N;i++) {; x = unr1.Sample();; }; printf("" %8.3f"",sw.CpuTime()*cpn);; sw.Start();; for (i=0;i<N;i++) {; x = unr2.Sample();; }; printf("" %8.3f"",sw.CpuTime()*cpn);; sw.Start();; for (i=0;i<N;i++) {; x = unr3.Sample();; }; printf("" %8.3f\n"",sw.CpuTime()*cpn);; ; // Poisson (need to initialize before with Poisson mu value); ; unr0.InitPoisson(10);; unr1.InitPoisson(10);; unr2.InitPoisson(10);; unr3.InitPoisson(10);; ; sw.Start();; for (i=0;i<N;i++) {; x = unr0.SampleDiscr();; }; printf(""PoissonUNURAN(10). %8.3f"",sw.CpuTime()*cpn);; sw.Start();; for (i=0;i<N;i++) {; x = unr1.SampleDiscr();; }; printf("" %8.3f"",sw.CpuTime()*c",MatchSource.WIKI,doc/master/testrandom_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testrandom_8C.html
Testability,test,testrandom,". ROOT: tutorials/math/testrandom.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. testrandom.C File ReferenceTutorials » Math tutorials. Detailed Description; Performance test of all the ROOT random generator (TRandom, TRandom1, TRandom2 and TRandom3) Tests the generator TRandom3 against some ref values and creates a timing table against TRandom, TRandom1 and TRandom2. ; E.g. on an an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running Linux SLC4 64 bit and compiled with gcc 3.4; Distribution nanoseconds/call; TRandom TRandom1 TRandom2 TRandom3; Rndm.............. 5.000 105.000 7.000 10.000; RndmArray......... 4.000 104.000 6.000 9.000; Gaus.............. 36.000 180.000 40.000 48.000; Rannor............ 118.000 220.000 120.000 124.000; Landau............ 22.000 123.000 26.000 31.000; Exponential....... 93.000 198.000 98.000 104.000; Binomial(5,0.5)... 30.000 548.000 46.000 65.000; Binomial(15,0.5).. 75.000 1615.000 125.000 178.000; Poisson(3)........ 96.000 494.000 109.000 125.000; Poisson(10)....... 138.000 1236.000 165.000 203.000; Poisson(70)....... 818.000 1195.000 835.000 844.000; Poisson(100)...... 837.000 1218.000 849.000 864.000; GausTF1........... 83.000 180.000 87.000 88.000; LandauTF1......... 80.000 180.000 83.000 86.000; GausUNURAN........ 40.000 139.000 41.000 44.000; PoissonUNURAN(10). 85.000 271.000 92.000 102.000; PoissonUNURAN(100) 62.000 256.000 69.000 78.000; TRandom1The Ranlux Random number generator class.Definition TRandom1.h:27; TRandom2Random number generator class based on the maximally quidistributed combined Tausworthe generator by ...Definition TRandom2.h:27; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; Note that this tutorial can be executed in interpreted or compiled mode; Root > .x testrandom.C; Root > .x testrandom.C++; ; Distribution nanoseconds/call; TRando",MatchSource.WIKI,doc/master/testrandom_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testrandom_8C.html
Availability,error,error," histo "" << p2 << std::endl;; ; double a1 = h1->AndersonDarlingTest(h2);; double a2 = h1_s->AndersonDarlingTest(h2);; ; std::cout << "" AD test non-smoothed histo "" << a1 << std::endl;; std::cout << "" AD test smoothed histo "" << a2 << std::endl;; ; double k1 = h1->KolmogorovTest(h2);; double k2 = h1_s->KolmogorovTest(h2);; ; std::cout << "" KS test non-smoothed histo "" << k1 << std::endl;; std::cout << "" KS test smoothed histo "" << k2 << std::endl;; ; c1->cd(ipad++);; h1->Draw(""E"");; h1_s->SetLineColor(kRed);; h1_s->Draw(""same"");; h2->Scale(double(n1)/n2);; h2->SetLineColor(kGreen);; h2->Draw(""same"");; }; ; void testSmooth(int n1 = 1000, int n2 = 1000000) {; ; TH1::AddDirectory(false);; ; c1 = new TCanvas();; c1->Divide(1,3);; ; ; smooth_hist(""gaus"",-5,5,n1,n2);; smooth_hist(""landau"",-5,15,n1,n2);; smooth_hist(""expo"",-5,0,n1,n2);; ; }; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::Smoothvirtual void Smooth(Int_t ntimes=1, Option_t *option="""")Smooth bin contents of this histogram.Definition TH1.cxx:6879; TH1::AddDirectorystatic void AddDirectory(Bool_t add=kTRUE)Sets the flag controlling the automatic add of histograms in memory.Definition TH1.cxx:1294; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::SetNamevoid SetName(const char *name) overrid",MatchSource.WIKI,doc/master/testSmooth_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testSmooth_8C.html
Testability,test,testSmooth,". ROOT: tutorials/hist/testSmooth.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. testSmooth.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Histogram smoothing. . ; int ipad = 1;; TCanvas * c1 = 0;; ; void smooth_hist(const char * fname, double xmin, double xmax, int n1, int n2) {; ; std::cout << ""smoothing a "" << fname << "" histogram"" << std::endl;; ; TH1D * h1 = new TH1D(""h1"",""h1"",100,xmin,xmax);; TH1D * h2 = new TH1D(""h2"",""h2"",100,xmin,xmax);; h1->FillRandom(fname,n1);; ; TH1D * h1_s = new TH1D(*h1);; h1_s->SetName(""h1_s"");; h1_s->Smooth();; ; h2->FillRandom(fname,n2);; ; double p1 = h1->Chi2Test(h2,"""");; double p2 = h1_s->Chi2Test(h2,""UU"");; if (p2 < p1) Error(""testSmooth"",""TH1::Smooth is not working correctly - a worst chi2 is obtained"");; ; std::cout << "" chi2 test non-smoothed histo "" << p1 << std::endl;; std::cout << "" chi2 test smoothed histo "" << p2 << std::endl;; ; double a1 = h1->AndersonDarlingTest(h2);; double a2 = h1_s->AndersonDarlingTest(h2);; ; std::cout << "" AD test non-smoothed histo "" << a1 << std::endl;; std::cout << "" AD test smoothed histo "" << a2 << std::endl;; ; double k1 = h1->KolmogorovTest(h2);; double k2 = h1_s->KolmogorovTest(h2);; ; std::cout << "" KS test non-smoothed histo "" << k1 << std::endl;; std::cout << "" KS test smoothed histo "" << k2 << std::endl;; ; c1->cd(ipad++);; h1->Draw(""E"");; h1_s->SetLineColor(kRed);; h1_s->Draw(""same"");; h2->Scale(double(n1)/n2);; h2->SetLineColor(kGreen);; h2->Draw(""same"");; }; ; void testSmooth(int n1 = 1000, int n2 = 1000000) {; ; TH1::AddDirectory(false);; ; c1 = new TCanvas();; c1->Divide(1,3);; ; ; smooth_hist(""gaus"",-5,5,n1,n2);; smooth_hist(""landau"",-5,15,n1,n2);; smooth_hist(""expo"",-5,0,n1,n2);; ; }; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; xminfloat xminDefi",MatchSource.WIKI,doc/master/testSmooth_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testSmooth_8C.html
Availability,error,error,"errideChange the name of this TEventList.Definition TEventList.cxx:367; TIterDefinition TCollection.h:235; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::Streamervoid Streamer(TBuffer &) overrideStream an object of class TObject.; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::fNameTString fNameDefinition TNamed.h:32; TNamed::operator=TNamed & operator=(const TNamed &rhs)TNamed assignment operator.Definition TNamed.cxx:51; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347. treetreesrcTEventList.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:05 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TEventList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEventList_8cxx_source.html
Deployability,update,updated,"nullptr;; 104}; 105 ; 106////////////////////////////////////////////////////////////////////////////////; 107/// Default destructor for a EventList.; 108 ; 109TEventList::~TEventList(); 110{; 111 delete [] fList; fList = nullptr;; 112 if (fDirectory) fDirectory->Remove(this);; 113 fDirectory = nullptr;; 114}; 115 ; 116////////////////////////////////////////////////////////////////////////////////; 117/// Merge contents of alist with this list.; 118///; 119/// Both alist and this list are assumed to be sorted prior to this call; 120 ; 121void TEventList::Add(const TEventList *alist); 122{; 123 Int_t i;; 124 Int_t an = alist->GetN();; 125 if (!an) return;; 126 Long64_t *alst = alist->GetList();; 127 if (!fList) {; 128 fList = new Long64_t[an];; 129 for (i=0;i<an;i++) fList[i] = alst[i];; 130 fN = an;; 131 fSize = an;; 132 return;; 133 }; 134 Int_t newsize = fN + an;; 135 Long64_t *newlist = new Long64_t[newsize];; 136 Int_t newpos, alpos;; 137 newpos = alpos = 0;; 138 for (i=0;i<fN;i++) {; 139 while (alpos < an && fList[i] > alst[alpos]) {; 140 newlist[newpos] = alst[alpos];; 141 newpos++;; 142 alpos++;; 143 }; 144 if (alpos < an && fList[i] == alst[alpos]) alpos++;; 145 newlist[newpos] = fList[i];; 146 newpos++;; 147 }; 148 while (alpos < an) {; 149 newlist[newpos] = alst[alpos];; 150 newpos++;; 151 alpos++;; 152 }; 153 delete [] fList;; 154 fN = newpos;; 155 fSize = newsize;; 156 fList = newlist;; 157 ; 158 TCut orig = GetTitle();; 159 TCut added = alist->GetTitle();; 160 TCut updated = orig || added;; 161 SetTitle(updated.GetTitle());; 162}; 163 ; 164////////////////////////////////////////////////////////////////////////////////; 165/// Return TRUE if list contains entry.; 166 ; 167bool TEventList::Contains(Long64_t entry); 168{; 169 if (GetIndex(entry) < 0) return false;; 170 return true;; 171}; 172 ; 173////////////////////////////////////////////////////////////////////////////////; 174/// Return TRUE if list contains entries from entrymin to entrymax include",MatchSource.WIKI,doc/master/TEventList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEventList_8cxx_source.html
Integrability,interface,interface,"Proxy.cxx:44; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; namechar name[80]Definition TGX11.cxx:110; TList.h; TMath.h; snprintf#define snprintfDefinition civetweb.c:1540; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TCollectionCollection abstract base class.Definition TCollection.h:65; TCutA specialized string object used for TTree selections.Definition TCut.h:25; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::Appendvirtual void Append(TObject *obj, Bool_t replace=kFALSE)Append object to this directory.Definition TDirectory.cxx:199; TDirectory::Removevirtual TObject * Remove(TObject *)Remove an object from the in-memory list.Definition TDirectory.cxx:1212; TEventList<div class=""legacybox""><h2>Legacy Code</h2> TEventList is a legacy interface: there will be no bug fi...Definition TEventList.h:31; TEventList::fListLong64_t * fList[fN]Array of elementsDefinition TEventList.h:38; TEventList::Classstatic TClass * Class(); TEventList::~TEventList~TEventList() overrideDefault destructor for a EventList.Definition TEventList.cxx:109; TEventList::Streamervoid Streamer(TBuffer &) overrideStream an object of class TEventList.Definition TEventList.cxx:400; TEventList::fReapplybool fReapplyIf true, TTree::Draw will 'reapply' the original cut.Definition TEventList.h:37; TEventList::TEventListTEventList()Default constructor for a EventList.Definition TEventList.cxx:63; TEventList::Resetvirtual void Reset(Option_t *option="""")Reset number of entries in event list.Definition TEventList.cxx:333; TEventList::ContainsRangevirtual bool ContainsRange(Long64_t entrymin, Long64_t entrymax)Return TRUE if list contains entries from entrymin to entrymax included.Definition TEventList.cxx:176; TEventList::fDirectory",MatchSource.WIKI,doc/master/TEventList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEventList_8cxx_source.html
Modifiability,inherit,inherits,"ntList::SetNamevoid SetName(const char *name) overrideChange the name of this TEventList.Definition TEventList.cxx:367; TIterDefinition TCollection.h:235; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::Streamervoid Streamer(TBuffer &) overrideStream an object of class TObject.; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::fNameTString fNameDefinition TNamed.h:32; TNamed::operator=TNamed & operator=(const TNamed &rhs)TNamed assignment operator.Definition TNamed.cxx:51; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347. treetreesrcTEventList.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 202",MatchSource.WIKI,doc/master/TEventList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEventList_8cxx_source.html
Security,hash,hashlist,"ew directory dir. dir can be 0 in which case the list; 354/// does not belong to any directory.; 355 ; 356void TEventList::SetDirectory(TDirectory *dir); 357{; 358 if (fDirectory == dir) return;; 359 if (fDirectory) fDirectory->Remove(this);; 360 fDirectory = dir;; 361 if (fDirectory) fDirectory->Append(this);; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Change the name of this TEventList.; 366 ; 367void TEventList::SetName(const char *name); 368{; 369 // TEventLists are named objects in a THashList.; 370 // We must update the hashlist if we change the name; 371 if (fDirectory) fDirectory->Remove(this);; 372 fName = name;; 373 if (fDirectory) fDirectory->Append(this);; 374}; 375 ; 376////////////////////////////////////////////////////////////////////////////////; 377/// Sort list entries in increasing order; 378 ; 379void TEventList::Sort(); 380{; 381 Int_t *index = new Int_t[fN];; 382 Long64_t *newlist = new Long64_t[fSize];; 383 Int_t i,ind;; 384 TMath::Sort(fN,fList,index); //sort in decreasing order; 385 for (i=0;i<fN;i++) {; 386 ind = index[fN-i-1];; 387 newlist[i] = fList[ind];; 388 }; 389 for (i=fN;i<fSize;i++) {; 390 newlist[i] = 0;; 391 }; 392 delete [] index;; 393 delete [] fList;; 394 fList = newlist;; 395}; 396 ; 397////////////////////////////////////////////////////////////////////////////////; 398/// Stream an object of class TEventList.; 399 ; 400void TEventList::Streamer(TBuffer &b); 401{; 402 if (b.IsReading()) {; 403 UInt_t R__s, R__c;; 404 Version_t R__v = b.ReadVersion(&R__s, &R__c);; 405 fDirectory = nullptr;; 406 if (R__v > 1) {; 407 b.ReadClassBuffer(TEventList::Class(), this, R__v, R__s, R__c);; 408 ResetBit(kMustCleanup);; 409 return;; 410 }; 411 //====process old versions before automatic schema evolution; 412 TNamed::Streamer(b);; 413 b >> fN;; 414 b >> fSize;; 415 b >> fDelta;; 416 if (fN) {; 417 Int_t *tlist = new Int_t[fSize];; 418 b.ReadFastArray(tlist,fN);; 419 fList = new ",MatchSource.WIKI,doc/master/TEventList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEventList_8cxx_source.html
Integrability,interface,interface,"st2);; 75 friend TEventList operator*(const TEventList &list1, const TEventList &list2);; 76 ; 77 ClassDefOverride(TEventList,4); //A list of selected entries in a TTree.; 78};; 79 ; 80#endif; 81 ; Int_tint Int_tDefinition RtypesCore.h:45; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; namechar name[80]Definition TGX11.cxx:110; TNamed.h; TCollectionCollection abstract base class.Definition TCollection.h:65; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TEventList<div class=""legacybox""><h2>Legacy Code</h2> TEventList is a legacy interface: there will be no bug fi...Definition TEventList.h:31; TEventList::SetReapplyCutvirtual void SetReapplyCut(bool apply=false)Definition TEventList.h:67; TEventList::fListLong64_t * fList[fN]Array of elementsDefinition TEventList.h:38; TEventList::~TEventList~TEventList() overrideDefault destructor for a EventList.Definition TEventList.cxx:109; TEventList::fReapplybool fReapplyIf true, TTree::Draw will 'reapply' the original cut.Definition TEventList.h:37; TEventList::TEventListTEventList()Default constructor for a EventList.Definition TEventList.cxx:63; TEventList::Resetvirtual void Reset(Option_t *option="""")Reset number of entries in event list.Definition TEventList.cxx:333; TEventList::ContainsRangevirtual bool ContainsRange(Long64_t entrymin, Long64_t entrymax)Return TRUE if list contains entries from entrymin to entrymax included.Definition TEventList.cxx:176; TEventList::operator-friend TEventList operator-(const TEventList &list1, const TEventList",MatchSource.WIKI,doc/master/TEventList_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEventList_8h_source.html
Integrability,depend,dependency,". ROOT: core/base/inc/TExec.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TExec.h File Reference. #include ""TNamed.h"". Include dependency graph for TExec.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TExec;  TExec is a utility class that can be used to execute a C++ command when some event happens in a pad. More...;  . corebaseincTExec.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:12 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TExec_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TExec_8h.html
Usability,simpl,simple,"olor(kBlue);; 8 lv.DrawLine(0.33,0.0,0.33,1.0);; 9 lv.DrawLine(0.6,0.165,1.,0.165);; 10 lv.DrawLine(0.6,0.493,1.,0.493);; 11 lv.DrawLine(0.6,0.823,1.,0.823);; 12 ; 13 // Horizontal alignment.; 14 auto *th1 = new TText(0.33,0.165,""Left adjusted"");; 15 th1->SetTextAlign(11); th1->SetTextSize(0.12);; 16 th1->Draw();; 17 ; 18 auto *th2 = new TText(0.33,0.493,""Center adjusted"");; 19 th2->SetTextAlign(21); th2->SetTextSize(0.12);; 20 th2->Draw();; 21 ; 22 auto *th3 = new TText(0.33,0.823,""Right adjusted"");; 23 th3->SetTextAlign(31); th3->SetTextSize(0.12);; 24 th3->Draw();; 25 ; 26 // Vertical alignment.; 27 auto *tv1 = new TText(0.66,0.165,""Bottom adjusted"");; 28 tv1->SetTextAlign(11); tv1->SetTextSize(0.12);; 29 tv1->Draw();; 30 ; 31 auto *tv2 = new TText(0.66,0.493,""Center adjusted"");; 32 tv2->SetTextAlign(12); tv2->SetTextSize(0.12);; 33 tv2->Draw();; 34 ; 35 auto *tv3 = new TText(0.66,0.823,""Top adjusted"");; 36 tv3->SetTextAlign(13); tv3->SetTextSize(0.12);; 37 tv3->Draw();; 38}; kBlue@ kBlueDefinition Rtypes.h:66; TAttLine::SetLineStylevirtual void SetLineStyle(Style_t lstyle)Set the line style.Definition TAttLine.h:42; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::DrawLinevirtual TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:103; TTextBase class for several text objects.Definition TText.h:22; th3auto * th3Definition textalign.C:22; lvTLine lvDefinition textalign.C:5; tv3auto * tv3Definition textalign.C:35; th2auto * th2Definition textalign.C:18; tv1auto * tv1Definition textalign.C:27; tv2auto * tv2Definition textalign.C:31; th1auto * th1Definition textalign.C:14. corebasedocmacrostextalign.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:02 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/textalign_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/textalign_8C_source.html
Usability,simpl,simple,"; 16 auto *tt = new TText(0.1,0.1,""Text angle is 45 degrees"");; 17 tt->SetTextAlign(11); tt->SetTextSize(0.1);; 18 tt->SetTextAngle(45);; 19 tt->Draw();; 20 auto *t1 = new TLatex(0.3,0.18,""45^{o}"");; 21 t1->Draw();; 22}; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TArcCreate an Arc.Definition TArc.h:26; TArc::DrawArcvirtual TArc * DrawArc(Double_t x1, Double_t y1, Double_t radius, Double_t phimin=0, Double_t phimax=360, Option_t *option="""")Draw this arc with new coordinates.Definition TArc.cxx:79; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineStylevirtual void SetLineStyle(Style_t lstyle)Set the line style.Definition TAttLine.h:42; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::DrawLinevirtual TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:103; TMarkerManages Markers.Definition TMarker.h:22; TMarker::DrawMarkervirtual TMarker * DrawMarker(Double_t x, Double_t y)Draw this marker with new coordinates.Definition TMarker.cxx:208; TTextBase class for several text objects.Definition TText.h:22; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4; aTArc aDefinition textangle.C:12; ttauto * ttDefinition textangle.C:16; t1auto * t1Definition textangle.C:20. corebasedocmacrostextangle.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:02 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/textangle_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/textangle_8C_source.html
Availability,avail,available,"hing...; No Matches. TF1Convolution.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Authors: Lorenzo Moneta, Aurélie Flandi 27/08/14; 3//; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2015 ROOT Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11#include <memory>; 12 ; 13#include ""TF1Convolution.h""; 14#include ""TROOT.h""; 15#include ""TObject.h""; 16#include ""TObjString.h""; 17#include ""TObjArray.h""; 18#include ""TMath.h""; 19#include ""Math/Integrator.h""; 20#include ""Math/IntegratorMultiDim.h""; 21#include ""Math/IntegratorOptions.h""; 22#include ""Math/GaussIntegrator.h""; 23#include ""Math/GaussLegendreIntegrator.h""; 24#include ""Math/AdaptiveIntegratorMultiDim.h""; 25#include ""Math/Functor.h""; 26#include ""TVirtualFFT.h""; 27 ; 28/** \class TF1Convolution; 29 \ingroup Functions; 30 \brief Class wrapping convolution of two functions; 31 ; 32Class wrapping convolution of two functions: evaluation of \f$\int f(x)g(x-t)dx\f$; 33 ; 34The convolution is performed by default using FFTW if it is available .; 35One can pass optionally the range of the convolution (by default the first function range is used).; 36Note that when using Discrete Fourier Transform (as FFTW), it is a circular transform, so the functions should be; 37approximately zero at the end of the range. If they are significantly different than zero on one side (e.g. the left side); 38a spill over will occur on the other side (e.g right side).; 39If no function range is given by default the function1 range + 10% is used; 40One should use also a not too small number of points for the DFT (a minimum of 1000). By default 10000 points are used.; 41*/; 42 ; 43ClassImp(TF1Convolution);; 44 ; 45Double_t TF1Convolution::fgExtraRangeFraction = 0.1;; 46 ; 47class TF1Convolution_EvalWrapper; 48{; 49 TF1 * fFunc1;; 50 TF1 * fFunc2;; 51 Double_t fT0;; 52 ; 53public:; 54 TF1Convolution_EvalWrapper",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
Deployability,integrat,integrator,"18 fGraphConv->SetBit(TGraph::kIsSortedX); // indicate that points are sorted in X to speed up TGraph::Eval; 319 fFlagGraph = true; // we can use the graph; 320 ; 321 // delete the fft objects; 322 delete fft1;; 323 delete fft2;; 324 delete fftinverse;; 325}; 326 ; 327////////////////////////////////////////////////////////////////////////////////; 328/// Perform FFT convolution.; 329 ; 330Double_t TF1Convolution::EvalFFTConv(Double_t t); 331{; 332 if (!fFlagGraph) MakeFFTConv();; 333 // if cannot make FFT use numconv; 334 if (fGraphConv); 335 return fGraphConv -> Eval(t);; 336 else; 337 ; 338 return EvalNumConv(t);; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342/// Perform numerical convolution.; 343///; 344 ; 345Double_t TF1Convolution::EvalNumConv(Double_t t); 346{; 347 /// Could in principle cache the integral in a Graph as it is done for the FFTW; 348 TF1Convolution_EvalWrapper fconv( *fFunction1, *fFunction2, t);; 349 Double_t result = 0;; 350 ; 351 ROOT::Math::IntegratorOneDim integrator(fconv, ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType(), 1e-9, 1e-9);; 352 if (fXmin != - TMath::Infinity() && fXmax != TMath::Infinity() ); 353 result = integrator.Integral(fXmin, fXmax);; 354 else if (fXmin == - TMath::Infinity() && fXmax != TMath::Infinity() ); 355 result = integrator.IntegralLow(fXmax);; 356 else if (fXmin != - TMath::Infinity() && fXmax == TMath::Infinity() ); 357 result = integrator.IntegralUp(fXmin);; 358 else if (fXmin == - TMath::Infinity() && fXmax == TMath::Infinity() ); 359 result = integrator.Integral();; 360 ; 361 return result;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Used in TF1 when doing the fit, will be evaluated at each point.; 366 ; 367Double_t TF1Convolution::operator()(const Double_t *x, const Double_t *p); 368{; 369 if (p!=nullptr) TF1Convolution::SetParameters(p); // first refresh the parameters; 370 ; 371 ",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
Integrability,wrap,wrapping,"hing...; No Matches. TF1Convolution.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Authors: Lorenzo Moneta, Aurélie Flandi 27/08/14; 3//; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2015 ROOT Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11#include <memory>; 12 ; 13#include ""TF1Convolution.h""; 14#include ""TROOT.h""; 15#include ""TObject.h""; 16#include ""TObjString.h""; 17#include ""TObjArray.h""; 18#include ""TMath.h""; 19#include ""Math/Integrator.h""; 20#include ""Math/IntegratorMultiDim.h""; 21#include ""Math/IntegratorOptions.h""; 22#include ""Math/GaussIntegrator.h""; 23#include ""Math/GaussLegendreIntegrator.h""; 24#include ""Math/AdaptiveIntegratorMultiDim.h""; 25#include ""Math/Functor.h""; 26#include ""TVirtualFFT.h""; 27 ; 28/** \class TF1Convolution; 29 \ingroup Functions; 30 \brief Class wrapping convolution of two functions; 31 ; 32Class wrapping convolution of two functions: evaluation of \f$\int f(x)g(x-t)dx\f$; 33 ; 34The convolution is performed by default using FFTW if it is available .; 35One can pass optionally the range of the convolution (by default the first function range is used).; 36Note that when using Discrete Fourier Transform (as FFTW), it is a circular transform, so the functions should be; 37approximately zero at the end of the range. If they are significantly different than zero on one side (e.g. the left side); 38a spill over will occur on the other side (e.g right side).; 39If no function range is given by default the function1 range + 10% is used; 40One should use also a not too small number of points for the DFT (a minimum of 1000). By default 10000 points are used.; 41*/; 42 ; 43ClassImp(TF1Convolution);; 44 ; 45Double_t TF1Convolution::fgExtraRangeFraction = 0.1;; 46 ; 47class TF1Convolution_EvalWrapper; 48{; 49 TF1 * fFunc1;; 50 TF1 * fFunc2;; 51 Double_t fT0;; 52 ; 53public:; 54 TF1Convolution_EvalWrapper",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
Modifiability,variab,variable,"FT); 210{; 211 TF1::InitStandardFunctions();; 212 (TString)formula1.ReplaceAll("" "","""");; 213 (TString)formula2.ReplaceAll("" "","""");; 214 TF1* f1 = (TF1*)(gROOT -> GetListOfFunctions() -> FindObject(formula1));; 215 TF1* f2 = (TF1*)(gROOT -> GetListOfFunctions() -> FindObject(formula2));; 216 // if function do not exists try using TFormula; 217 if (!f1) {; 218 fFunction1 = std::make_unique<TF1>(""f_conv_1"", formula1);; 219 if (!fFunction1->GetFormula()->IsValid() ); 220 Error(""TF1Convolution"",""Invalid formula for : %s"",formula1.Data() );; 221 }; 222 if (!f2) {; 223 fFunction2 = std::make_unique<TF1>(""f_conv_1"", formula2);; 224 if (!fFunction2->GetFormula()->IsValid() ); 225 Error(""TF1Convolution"",""Invalid formula for : %s"",formula2.Data() );; 226 }; 227 // if f1 or f2 are null ptr are not used in InitializeDataMembers; 228 InitializeDataMembers(f1, f2,useFFT);; 229 if (xmin < xmax) {; 230 fXmin = xmin;; 231 fXmax = xmax;; 232 } else {; 233 Info(""TF1Convolution"", ""Using default range [-inf, inf] for TF1Convolution"");; 234 SetRange(-TMath::Infinity(), TMath::Infinity());; 235 }; 236}; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/// Copy constructor (necessary to hold unique_ptr as member variable).; 240 ; 241TF1Convolution::TF1Convolution(const TF1Convolution &conv); 242{; 243 conv.TF1Convolution::Copy(*this);; 244}; 245 ; 246////////////////////////////////////////////////////////////////////////////////; 247/// Operator =; 248 ; 249TF1Convolution &TF1Convolution::operator=(const TF1Convolution &rhs); 250{; 251 if (this != &rhs); 252 rhs.TF1Convolution::Copy(*this);; 253 return *this;; 254}; 255 ; 256////////////////////////////////////////////////////////////////////////////////; 257/// Perform the FFT of the two functions.; 258 ; 259void TF1Convolution::MakeFFTConv(); 260{; 261 if (gDebug); 262 Info(""MakeFFTConv"",""Making FFT convolution using %d points in range [%g,%g]"",fNofPoints,fXmin,fXmax);; 263 ; 264 std::vector < ",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
Performance,perform,performed,"hing...; No Matches. TF1Convolution.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Authors: Lorenzo Moneta, Aurélie Flandi 27/08/14; 3//; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2015 ROOT Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11#include <memory>; 12 ; 13#include ""TF1Convolution.h""; 14#include ""TROOT.h""; 15#include ""TObject.h""; 16#include ""TObjString.h""; 17#include ""TObjArray.h""; 18#include ""TMath.h""; 19#include ""Math/Integrator.h""; 20#include ""Math/IntegratorMultiDim.h""; 21#include ""Math/IntegratorOptions.h""; 22#include ""Math/GaussIntegrator.h""; 23#include ""Math/GaussLegendreIntegrator.h""; 24#include ""Math/AdaptiveIntegratorMultiDim.h""; 25#include ""Math/Functor.h""; 26#include ""TVirtualFFT.h""; 27 ; 28/** \class TF1Convolution; 29 \ingroup Functions; 30 \brief Class wrapping convolution of two functions; 31 ; 32Class wrapping convolution of two functions: evaluation of \f$\int f(x)g(x-t)dx\f$; 33 ; 34The convolution is performed by default using FFTW if it is available .; 35One can pass optionally the range of the convolution (by default the first function range is used).; 36Note that when using Discrete Fourier Transform (as FFTW), it is a circular transform, so the functions should be; 37approximately zero at the end of the range. If they are significantly different than zero on one side (e.g. the left side); 38a spill over will occur on the other side (e.g right side).; 39If no function range is given by default the function1 range + 10% is used; 40One should use also a not too small number of points for the DFT (a minimum of 1000). By default 10000 points are used.; 41*/; 42 ; 43ClassImp(TF1Convolution);; 44 ; 45Double_t TF1Convolution::fgExtraRangeFraction = 0.1;; 46 ; 47class TF1Convolution_EvalWrapper; 48{; 49 TF1 * fFunc1;; 50 TF1 * fFunc2;; 51 Double_t fT0;; 52 ; 53public:; 54 TF1Convolution_EvalWrapper",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
Safety,avoid,avoid,"tIndex); 408 {; 409 k++;; 410 offset2=1;; 411 continue;; 412 }; 413 fFunction2->SetParameter(k, params[i - offset2]);; 414 equalParams &= (fParams2[k - offset2] == params[i - offset2]);; 415 fParams2[k - offset2] = params[i - offset2];; 416 k++;; 417 }; 418 ; 419 if (!equalParams) fFlagGraph = false; // to indicate we need to re-do the convolution; 420}; 421 ; 422////////////////////////////////////////////////////////////////////////////////; 423/// Set the parameter values for the convolution function.; 424 ; 425void TF1Convolution::SetParameters(Double_t p0, Double_t p1, Double_t p2, Double_t p3,; 426 Double_t p4, Double_t p5, Double_t p6, Double_t p7); 427{; 428 Double_t params[]={p0,p1,p2,p3,p4,p5,p6,p7};; 429 TF1Convolution::SetParameters(params);; 430}; 431 ; 432////////////////////////////////////////////////////////////////////////////////; 433/// Set the fraction of extra range used when doing an FFT convolution.; 434/// The extra range is often needed to avoid mirroring effect of the resulting convolution; 435/// function at the borders.; 436/// By default an extra range of 0.1 is used.; 437 ; 438void TF1Convolution::SetExtraRange(Double_t percentage); 439{; 440 if (percentage<0) return;; 441 double range = fXmax - fXmin;; 442 fXmin -= percentage * range;; 443 fXmax += percentage * range;; 444 fFlagGraph = false; // to indicate we need to re-do the convolution; 445}; 446 ; 447////////////////////////////////////////////////////////////////////////////////; 448/// Set the actual range used for the convolution.; 449/// In case a or b are -inf or +inf and FFT convolution is used, then the; 450/// range of the first function will be used and extended by the default extra range fraction.; 451 ; 452void TF1Convolution::SetRange(Double_t a, Double_t b); 453{; 454 if (a >= b) {; 455 Warning(""SetRange"", ""Invalid range: %f >= %f"", a, b);; 456 return;; 457 }; 458 ; 459 fXmin = a;; 460 fXmax = b;; 461 if (fFlagFFT && ( a==-TMath::Infinity() || b==TMath::Infinity() ) ",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
Integrability,depend,dependency,". ROOT: hist/hist/inc/TF1Convolution.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TF1Convolution.h File Reference. #include ""TF1AbsComposition.h""; #include <memory>; #include <vector>; #include ""TF1.h""; #include ""TGraph.h"". Include dependency graph for TF1Convolution.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TF1Convolution;  Class wrapping convolution of two functions. More...;  . histhistincTF1Convolution.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TF1Convolution_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8h.html
Integrability,wrap,wrapping,"; 69 Double_t GetXmin() const { return fXmin; }; 70 Double_t GetXmax() const { return fXmax; }; 71 const char *GetParName(Int_t ipar) const { return fParNames.at(ipar).Data(); }; 72 void GetRange(Double_t &a, Double_t &b) const;; 73 ; 74 void Update() override;; 75 ; 76 Double_t operator()(const Double_t *x, const Double_t *p) override;; 77 ; 78 void Copy(TObject &obj) const override;; 79 ; 80 ClassDefOverride(TF1Convolution, 1);; 81};; 82 ; 83 ; 84#endif; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TF1AbsComposition.h; TF1.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TGraph.h; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TF1AbsCompositionDefinition TF1AbsComposition.h:16; TF1ConvolutionClass wrapping convolution of two functions.Definition TF1Convolution.h:20; TF1Convolution::SetNumConvvoid SetNumConv(Bool_t flag=true)Definition TF1Convolution.h:64; TF1Convolution::fNofParams2Int_t fNofParams2Definition TF1Convolution.h:33; TF1Convolution::fParams1std::vector< Double_t > fParams1Definition TF1Convolution.h:25; TF1Convolution::operator()Double_t operator()(const Double_t *x, const Double_t *p) overrideUsed in TF1 when doing the fit, will be evaluated at each point.Definition TF1Convolution.cxx:367; TF1Convolution::SetParametersvoid SetParameters(const Double_t *params) overrideSet the vector of parameters p for the convolution function g(x,p) = f1 * f2.Definition TF1Convolution.cxx:393; TF1Convolution::~TF1Convolution~TF1Convolution() overrideDefinition TF1Convolution.h:56; TF1Convolution::fCstIndexInt_t fCstIndexIndex of the constant parameter f the first function.Definition TF1Convolution.h:34; TF1Convolution::GetRangevoid GetRange(Double_t &a, Double_t &b) constGet the range u",MatchSource.WIKI,doc/master/TF1Convolution_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8h_source.html
Availability,error,error,"fficients in front of each function.Definition TF1NormSum.h:27; TF1NormSum::GetNparInt_t GetNpar() constReturn the number of (non constant) parameters including the coefficients: for 2 functions: c1,...Definition TF1NormSum.cxx:361; TF1NormSum::fNOfFunctionsunsigned int fNOfFunctionsNumber of functions to add.Definition TF1NormSum.h:22; TF1NormSum::fCstIndexesstd::vector< Int_t > fCstIndexesVector with size of fNOfFunctions containing the index of the constant parameter/ function (the remov...Definition TF1NormSum.h:28; TF11-Dim function classDefinition TF1.h:233; TF1::InitStandardFunctionsstatic void InitStandardFunctions()Create the basic function objects.Definition TF1.cxx:2497; TF1::kNotGlobal@ kNotGlobalDefinition TF1.h:345; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjStringCollectable string class.Definition TObjString.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TStringBasic string class.Definition TString.h:139; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; double; int; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. histhistsrcTF1NormSum.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TF1NormSum_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1NormSum_8cxx_source.html
Deployability,update,update," params[k+fNOfFunctions+offset] = fFunctions[n]->GetParameter(j);; 301 k++;; 302 }; 303 }; 304 nOfNonCstParams = k;; 305 }; 306 return params;; 307}; 308////////////////////////////////////////////////////////////////////////////////; 309/// Initialize array of all parameters.; 310///; 311/// double *params must contains first an array of the coefficients, then an array of the parameters.; 312 ; 313void TF1NormSum::SetParameters(const Double_t *params) // params should have the size [fNOfFunctions][fNOfNonCstParams]; 314{; 315 for (unsigned int n=0; n<fNOfFunctions; n++) //initialization of the coefficients; 316 {; 317 fCoeffs[n] = params[n];; 318 }; 319 Int_t offset = 0;; 320 int k = 0; // k indicates the number of non-constant parameter per function; 321 for (unsigned int n=0; n<fNOfFunctions; n++); 322 {; 323 bool equalParams = true;; 324 Double_t * funcParams = fFunctions[n]->GetParameters();; 325 int npar = fFunctions[n]->GetNpar();; 326 offset += k; // offset to go along the list of parameters; 327 k = 0; // reset k value for next function; 328 for (int i = 0; i < npar; ++i) {; 329 // constant parameters can be only one; 330 if (i != fCstIndexes[n]); 331 {; 332 // check if they are equal; 333 equalParams &= (funcParams[i] == params[k+fNOfFunctions+offset] );; 334 funcParams[i] = params[k+fNOfFunctions+offset];; 335 k++;; 336 }; 337 }; 338 // update function integral if not equal; 339 if (!equalParams) fFunctions[n]->Update();; 340 ; 341 }; 342}; 343 ; 344////////////////////////////////////////////////////////////////////////////////; 345/// Initialize array of all parameters.; 346///; 347/// Overload the TF1::SetParameters() method.; 348/// A maximum of 10 parameters must be used, with first the coefficients, then the parameters; 349 ; 350void TF1NormSum::SetParameters(Double_t p0, Double_t p1, Double_t p2, Double_t p3, Double_t p4,; 351 Double_t p5, Double_t p6, Double_t p7, Double_t p8, Double_t p9, Double_t p10); 352{; 353 const double params[] = {p0,p1,p2",MatchSource.WIKI,doc/master/TF1NormSum_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1NormSum_8cxx_source.html
Energy Efficiency,allocate,allocated,"e GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h offsetDefinition TGWin32VirtualXProxy.cxx:245; namechar name[80]Definition TGX11.cxx:110; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TObjArray.h; TObjString.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; WrappedFunction.h; WrappedTF1.h; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TF1NormSumClass adding two functions: c1*f1+c2*f2.Definition TF1NormSum.h:19; TF1NormSum::Copyvoid Copy(TObject &obj) const overrideCopy this to obj.Definition TF1NormSum.cxx:409; TF1NormSum::fScaleDouble_t fScaleFixed Scale parameter to normalize function (e.g. bin width)Definition TF1NormSum.h:23; TF1NormSum::GetParNameconst char * GetParName(Int_t ipar) constDefinition TF1NormSum.h:66; TF1NormSum::GetRangevoid GetRange(Double_t &a, Double_t &b) constDefinition TF1NormSum.cxx:392; TF1NormSum::TF1NormSumTF1NormSum()Definition TF1NormSum.cxx:129; TF1NormSum::operator=TF1NormSum & operator=(const TF1NormSum &rhs)Operator =.Definition TF1NormSum.cxx:262; TF1NormSum::IsATClass * IsA() const overrideDefinition TF1NormSum.h:78; TF1NormSum::fXmaxDouble_t fXmaxMaximal bound of range of NormSum.Definition TF1NormSum.h:25; TF1NormSum::fParNamesstd::vector< TString > fParNamesParameter names.Defin",MatchSource.WIKI,doc/master/TF1NormSum_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1NormSum_8cxx_source.html
Integrability,message,message,"fficients in front of each function.Definition TF1NormSum.h:27; TF1NormSum::GetNparInt_t GetNpar() constReturn the number of (non constant) parameters including the coefficients: for 2 functions: c1,...Definition TF1NormSum.cxx:361; TF1NormSum::fNOfFunctionsunsigned int fNOfFunctionsNumber of functions to add.Definition TF1NormSum.h:22; TF1NormSum::fCstIndexesstd::vector< Int_t > fCstIndexesVector with size of fNOfFunctions containing the index of the constant parameter/ function (the remov...Definition TF1NormSum.h:28; TF11-Dim function classDefinition TF1.h:233; TF1::InitStandardFunctionsstatic void InitStandardFunctions()Create the basic function objects.Definition TF1.cxx:2497; TF1::kNotGlobal@ kNotGlobalDefinition TF1.h:345; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjStringCollectable string class.Definition TObjString.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TStringBasic string class.Definition TString.h:139; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; double; int; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. histhistsrcTF1NormSum.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TF1NormSum_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1NormSum_8cxx_source.html
Modifiability,variab,variable,"19 ; 220 Double_t old_xmin = 0.0, old_xmax = 0.0;; 221 k = 0; // index of term in funcstringall; 222 for (int i=0; i<noffunctions; i++); 223 {; 224 // first, handle coefficient; 225 if (isacoeff[k]) {; 226 coeffs[i] = funcstringall[k].Atof();; 227 k++;; 228 } else {; 229 coeffs[i] = 1.;; 230 }; 231 ; 232 // then, handle function; 233 functions[i] = (TF1 *)(gROOT->GetListOfFunctions()->FindObject(funcstringall[k]));; 234 if (!functions[i]); 235 Error(""TF1NormSum"", ""Function %s does not exist"", funcstringall[k].Data());; 236 // (set range for first function, which determines range of whole TF1NormSum); 237 else if (i == 0) {; 238 functions[i]->GetRange(old_xmin, old_xmax);; 239 functions[i]->SetRange(xmin, xmax);; 240 }; 241 ; 242 k++;; 243 }; 244 InitializeDataMembers(functions, coeffs,1.);; 245 ; 246 // Set range of first function back to original state; 247 if (noffunctions > 0 && functions[0]); 248 functions[0]->SetRange(old_xmin, old_xmax);; 249}; 250 ; 251////////////////////////////////////////////////////////////////////////////////; 252/// Copy constructor (necessary to hold unique_ptr as member variable); 253 ; 254TF1NormSum::TF1NormSum(const TF1NormSum &nsum); 255{; 256 nsum.TF1NormSum::Copy(*this);; 257}; 258 ; 259////////////////////////////////////////////////////////////////////////////////; 260/// Operator =; 261 ; 262TF1NormSum &TF1NormSum::operator=(const TF1NormSum &rhs); 263{; 264 if (this != &rhs); 265 rhs.TF1NormSum::Copy(*this);; 266 return *this;; 267}; 268 ; 269////////////////////////////////////////////////////////////////////////////////; 270/// Overload the parenthesis to add the functions; 271 ; 272double TF1NormSum::operator()(const Double_t *x, const Double_t *p); 273{; 274 // first refresh the parameters; 275 if (p != nullptr); 276 SetParameters(p);; 277 ; 278 Double_t sum = 0.;; 279 for (unsigned int n=0; n<fNOfFunctions; n++); 280 sum += fCoeffs[n]*(fFunctions[n] -> EvalPar(x,nullptr));; 281 ; 282 // normalize by a scale parameter (ty",MatchSource.WIKI,doc/master/TF1NormSum_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1NormSum_8cxx_source.html
Safety,abort,abort,"/////////////////////////////////; 54 ; 55void TF1NormSum::InitializeDataMembers(const std::vector<TF1 *> &functions, const std::vector<Double_t> &coeffs,; 56 Double_t scale); 57{; 58 ; 59 fScale = scale;; 60 fCoeffs = coeffs;; 61 fNOfFunctions = functions.size();; 62 fCstIndexes = std::vector < Int_t > (fNOfFunctions);; 63 fParNames = std::vector<TString> (fNOfFunctions);; 64 fParNames.reserve(3*fNOfFunctions); // enlarge capacity for function parameters; 65 ; 66 // fill fFunctions with unique_ptr's; 67 fFunctions = std::vector<std::unique_ptr<TF1>>(functions.size());; 68 for (unsigned int n = 0; n < fNOfFunctions; n++) {; 69 // use TF1::Copy and not clone to copy the TF1 pointers; 70 // and use IsA()::New() in case we have base class pointers; 71 TF1 * f = (TF1*) functions[n]->IsA()->New();; 72 functions[n]->Copy(*f);; 73 fFunctions[n] = std::unique_ptr<TF1>(f);; 74 ; 75 ; 76 if (!fFunctions[n]); 77 Fatal(""InitializeDataMembers"", ""Invalid input function -- abort"");; 78 ; 79 fFunctions[n]->SetBit(TF1::kNotGlobal, kTRUE);; 80 }; 81 ; 82 for (unsigned int n=0; n < fNOfFunctions; n++); 83 {; 84 int npar = fFunctions[n] -> GetNpar();; 85 fCstIndexes[n] = fFunctions[n] -> GetParNumber(""Constant"");//return -1 if there is no constant parameter; 86 fParNames[n] = TString::Format(""Coeff%d"",n);; 87 if (fCstIndexes[n]!= -1) //if there exists a constant parameter; 88 {; 89 fFunctions[n] -> FixParameter(fCstIndexes[n], 1.); // fixes the parameters called ""Constant"" to 1; 90 for (int i=0; i<npar; i++) // go through all the parameter to; 91 {; 92 if (i==fCstIndexes[n]) continue; // go to next step if this is the constant parameter; 93 fParNames.push_back( fFunctions[n] -> GetParName(i) );; 94 }; 95 }; 96 else {; 97 for (int i=0; i < npar; i++) //go through all the parameter to; 98 {; 99 fParNames.push_back( fFunctions[n] -> GetParName(i) );; 100 }; 101 }; 102 //normalize the functions if it is not already done (do at the end so constant parameter is not zero); 103 if (!fFunctions",MatchSource.WIKI,doc/master/TF1NormSum_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1NormSum_8cxx_source.html
Integrability,depend,dependency,". ROOT: hist/hist/inc/TF1NormSum.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TF1NormSum.h File Reference. #include ""TF1AbsComposition.h""; #include <vector>; #include <memory>; #include ""TF1.h"". Include dependency graph for TF1NormSum.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TF1NormSum;  Class adding two functions: c1*f1+c2*f2. More...;  . histhistincTF1NormSum.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TF1NormSum_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1NormSum_8h.html
Availability,error,error,"or.h""; 45#include ""Math/AdaptiveIntegratorMultiDim.h""; 46#include ""Math/RichardsonDerivator.h""; 47#include ""Math/Functor.h""; 48#include ""Math/Minimizer.h""; 49#include ""Math/MinimizerOptions.h""; 50#include ""Math/Factory.h""; 51#include ""Math/ChebyshevPol.h""; 52#include ""Fit/FitResult.h""; 53// for I/O backward compatibility; 54#include ""v5/TF1Data.h""; 55 ; 56#include ""AnalyticalIntegrals.h""; 57 ; 58std::atomic<Bool_t> TF1::fgAbsValue(kFALSE);; 59Bool_t TF1::fgRejectPoint = kFALSE;; 60std::atomic<Bool_t> TF1::fgAddToGlobList(kTRUE);; 61static Double_t gErrorTF1 = 0;; 62 ; 63using TF1Updater_t = void (*)(Int_t nobjects, TObject **from, TObject **to);; 64bool R__SetClonesArrayTF1Updater(TF1Updater_t func);; 65 ; 66 ; 67namespace {; 68struct TF1v5Convert : public TF1 {; 69public:; 70 void Convert(ROOT::v5::TF1Data &from); 71 {; 72 // convert old TF1 to new one; 73 fNpar = from.GetNpar();; 74 fNdim = from.GetNdim();; 75 if (from.fType == 0) {; 76 // formula functions; 77 // if ndim is not 1 set xmin max to zero to avoid error in ctor; 78 double xmin = from.fXmin;; 79 double xmax = from.fXmax;; 80 if (fNdim > 1) {; 81 xmin = 0;; 82 xmax = 0;; 83 }; 84 TF1 fnew(from.GetName(), from.GetExpFormula(), xmin, xmax);; 85 if (fNdim > 1) {; 86 fnew.SetRange(from.fXmin, from.fXmax);; 87 }; 88 fnew.Copy(*this);; 89 // need to set parameter values; 90 if (from.GetParameters()); 91 fFormula->SetParameters(from.GetParameters());; 92 } else {; 93 // case of a function pointers; 94 fParams = std::make_unique<TF1Parameters>(fNpar);; 95 fName = from.GetName();; 96 fTitle = from.GetTitle();; 97 // need to set parameter values; 98 if (from.GetParameters()); 99 fParams->SetParameters(from.GetParameters());; 100 }; 101 // copy the other data members; 102 fNpx = from.fNpx;; 103 fType = (EFType)from.fType;; 104 fNpfits = from.fNpfits;; 105 fNDF = from.fNDF;; 106 fChisquare = from.fChisquare;; 107 fMaximum = from.fMaximum;; 108 fMinimum = from.fMinimum;; 109 fXmin = from.fXmin;; 110 fXmax = from.fXm",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
Deployability,integrat,integration,"; ++i) {; 141 if (fromv5[i] && target[i]); 142 target[i]->Convert(*fromv5[i]);; 143 }; 144}; 145 ; 146int R__RegisterTF1UpdaterTrigger = R__SetClonesArrayTF1Updater(R__v5TF1Updater);; 147 ; 148ClassImp(TF1);; 149 ; 150// class wrapping evaluation of TF1(x) - y0; 151class GFunc {; 152 const TF1 *fFunction;; 153 const double fY0;; 154public:; 155 GFunc(const TF1 *function , double y): fFunction(function), fY0(y) {}; 156 double operator()(double x) const; 157 {; 158 return fFunction->Eval(x) - fY0;; 159 }; 160};; 161 ; 162// class wrapping evaluation of -TF1(x); 163class GInverseFunc {; 164 const TF1 *fFunction;; 165public:; 166 GInverseFunc(const TF1 *function): fFunction(function) {}; 167 ; 168 double operator()(double x) const; 169 {; 170 return - fFunction->Eval(x);; 171 }; 172};; 173// class wrapping evaluation of -TF1(x) for multi-dimension; 174class GInverseFuncNdim {; 175 TF1 *fFunction;; 176public:; 177 GInverseFuncNdim(TF1 *function): fFunction(function) {}; 178 ; 179 double operator()(const double *x) const; 180 {; 181 return - fFunction->EvalPar(x, (Double_t *)nullptr);; 182 }; 183};; 184 ; 185// class wrapping function evaluation directly in 1D interface (used for integration); 186// and implementing the methods for the momentum calculations; 187 ; 188class TF1_EvalWrapper : public ROOT::Math::IGenFunction {; 189public:; 190 TF1_EvalWrapper(TF1 *f, const Double_t *par, bool useAbsVal, Double_t n = 1, Double_t x0 = 0) :; 191 fFunc(f),; 192 fPar(((par) ? par : f->GetParameters())),; 193 fAbsVal(useAbsVal),; 194 fN(n),; 195 fX0(x0); 196 {; 197 fFunc->InitArgs(fX, fPar);; 198 if (par) fFunc->SetParameters(par);; 199 }; 200 ; 201 ROOT::Math::IGenFunction *Clone() const override; 202 {; 203 // use default copy constructor; 204 TF1_EvalWrapper *f = new TF1_EvalWrapper(*this);; 205 f->fFunc->InitArgs(f->fX, f->fPar);; 206 return f;; 207 }; 208 // evaluate |f(x)|; 209 Double_t DoEval(Double_t x) const override; 210 {; 211 // use evaluation with stored parameters (i.",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
Energy Efficiency,power,power,"1,value_second_parameter);; 310~~~~; 311 ; 312 ; 313Parameters may be given a name:; 314 ; 315~~~~{.cpp}; 316 fa->SetParName(0,""Constant"");; 317~~~~; 318 ; 319* Example b:; 320 ; 321~~~~{.cpp}; 322 auto fb = new TF1(""fb"",""gaus(0)*expo(3)"",0,10);; 323~~~~; 324 ; 325 ; 326``gaus(0)`` is a substitute for ``[0]*exp(-0.5*((x-[1])/[2])**2)`` and ``(0)`` means start numbering parameters at ``0``. ``expo(3)`` is a substitute for ``exp([3]+[4]*x)``.; 327 ; 328#### Case 2: inline expression using TMath functions with parameters; 329 ; 330Begin_Macro(source); 331{; 332 auto fb2 = new TF1(""fa3"",""TMath::Landau(x,[0],[1],0)"",-5,10);; 333 fb2->SetParameters(0.2,1.3);; 334 fb2->Draw();; 335}; 336End_Macro; 337 ; 338\anchor F3; 339### 3 - A lambda expression with variables and parameters; 340 ; 341\since **6.00/00:**; 342TF1 supports using lambda expressions in the formula. This allows, by using a full C++ syntax the full power of lambda; 343functions and still maintain the capability of storing the function in a file which cannot be done with; 344function pointer or lambda written not as expression, but as code (see items below).; 345 ; 346Example on how using lambda to define a sum of two functions.; 347Note that is necessary to provide the number of parameters; 348 ; 349~~~~{.cpp}; 350TF1 f1(""f1"",""sin(x)"",0,10);; 351TF1 f2(""f2"",""cos(x)"",0,10);; 352TF1 fsum(""f1"",""[&](double *x, double *p){ return p[0]*f1(x) + p[1]*f2(x); }"",0,10,2);; 353~~~~; 354 ; 355\anchor F4; 356### 4 - A general C function with parameters; 357 ; 358Consider the macro myfunc.C below:; 359 ; 360~~~~{.cpp}; 361 // Macro myfunc.C; 362 Double_t myfunction(Double_t *x, Double_t *par); 363 {; 364 Float_t xx =x[0];; 365 Double_t f = TMath::Abs(par[0]*sin(par[1]*xx)/xx);; 366 return f;; 367 }; 368 void myfunc(); 369 {; 370 auto f1 = new TF1(""myfunc"",myfunction,0,10,2);; 371 f1->SetParameters(2,1);; 372 f1->SetParNames(""constant"",""coefficient"");; 373 f1->Draw();; 374 }; 375 void myfit(); 376 {; 377 auto h1 = new TH1F(""",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
Integrability,wrap,wrapping,,MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
Modifiability,variab,variable,":Abs(fFunc->EvalPar(fX, nullptr));; 222 }; 223 // evaluate (x - x0) ^n * f(x); 224 Double_t EvalNMom(Double_t x) const; 225 {; 226 fX[0] = x;; 227 return TMath::Power(fX[0] - fX0, fN) * TMath::Abs(fFunc->EvalPar(fX, nullptr));; 228 }; 229 ; 230 TF1 *fFunc;; 231 mutable Double_t fX[1];; 232 const double *fPar;; 233 Bool_t fAbsVal;; 234 Double_t fN;; 235 Double_t fX0;; 236};; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/** \class TF1; 240 \ingroup Functions; 241 \brief 1-Dim function class; 242 ; 243 ; 244## TF1: 1-Dim function class; 245 ; 246A TF1 object is a 1-Dim function defined between a lower and upper limit.; 247The function may be a simple function based on a TFormula expression or a precompiled user function.; 248The function may have associated parameters.; 249TF1 graphics function is via the TH1 and TGraph drawing functions.; 250 ; 251The following types of functions can be created:; 252 ; 2531. [Expression using variable x and no parameters](\ref F1); 2542. [Expression using variable x with parameters](\ref F2); 2553. [Lambda Expression with variable x and parameters](\ref F3); 2564. [A general C function with parameters](\ref F4); 2575. [A general C++ function object (functor) with parameters](\ref F5); 2586. [A member function with parameters of a general C++ class](\ref F6); 259 ; 260 ; 261 ; 262\anchor F1; 263### 1 - Expression using variable x and no parameters; 264 ; 265#### Case 1: inline expression using standard C++ functions/operators; 266 ; 267Begin_Macro(source); 268{; 269 auto fa1 = new TF1(""fa1"",""sin(x)/x"",0,10);; 270 fa1->Draw();; 271}; 272End_Macro; 273 ; 274#### Case 2: inline expression using a ROOT function (e.g. from TMath) without parameters; 275 ; 276 ; 277Begin_Macro(source); 278{; 279 auto fa2 = new TF1(""fa2"",""TMath::DiLog(x)"",0,10);; 280 fa2->Draw();; 281}; 282End_Macro; 283 ; 284#### Case 3: inline expression using a user defined CLING function by name; 285 ; 286~~~~{.cpp}; 287Dou",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
Performance,cache,cached,"), fXmax(0), fNpar(0), fNdim(0), fType(EFType::kFormula); 973{; 974 f1.TF1::Copy(*this);; 975}; 976 ; 977 ; 978////////////////////////////////////////////////////////////////////////////////; 979/// Static function: set the fgAbsValue flag.; 980/// By default TF1::Integral uses the original function value to compute the integral; 981/// However, TF1::Moment, CentralMoment require to compute the integral; 982/// using the absolute value of the function.; 983 ; 984void TF1::AbsValue(Bool_t flag); 985{; 986 fgAbsValue = flag;; 987}; 988 ; 989 ; 990////////////////////////////////////////////////////////////////////////////////; 991/// Browse.; 992 ; 993void TF1::Browse(TBrowser *b); 994{; 995 Draw(b ? b->GetDrawOption() : """");; 996 gPad->Update();; 997}; 998 ; 999 ; 1000////////////////////////////////////////////////////////////////////////////////; 1001/// Copy this F1 to a new F1.; 1002/// Note that the cached integral with its related arrays are not copied; 1003/// (they are also set as transient data members); 1004 ; 1005void TF1::Copy(TObject &obj) const; 1006{; 1007 delete((TF1 &)obj).fHistogram;; 1008 ; 1009 TNamed::Copy((TF1 &)obj);; 1010 TAttLine::Copy((TF1 &)obj);; 1011 TAttFill::Copy((TF1 &)obj);; 1012 TAttMarker::Copy((TF1 &)obj);; 1013 ((TF1 &)obj).fXmin = fXmin;; 1014 ((TF1 &)obj).fXmax = fXmax;; 1015 ((TF1 &)obj).fNpx = fNpx;; 1016 ((TF1 &)obj).fNpar = fNpar;; 1017 ((TF1 &)obj).fNdim = fNdim;; 1018 ((TF1 &)obj).fType = fType;; 1019 ((TF1 &)obj).fChisquare = fChisquare;; 1020 ((TF1 &)obj).fNpfits = fNpfits;; 1021 ((TF1 &)obj).fNDF = fNDF;; 1022 ((TF1 &)obj).fMinimum = fMinimum;; 1023 ((TF1 &)obj).fMaximum = fMaximum;; 1024 ; 1025 ((TF1 &)obj).fParErrors = fParErrors;; 1026 ((TF1 &)obj).fParMin = fParMin;; 1027 ((TF1 &)obj).fParMax = fParMax;; 1028 ((TF1 &)obj).fParent = fParent;; 1029 ((TF1 &)obj).fSave = fSave;; 1030 ((TF1 &)obj).fHistogram = nullptr;; 1031 ((TF1 &)obj).fMethodCall = nullptr;; 1032 ((TF1 &)obj).fNormalized = fNormalized;; 1033 ((TF1 &)o",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
Safety,avoid,avoid,"or.h""; 45#include ""Math/AdaptiveIntegratorMultiDim.h""; 46#include ""Math/RichardsonDerivator.h""; 47#include ""Math/Functor.h""; 48#include ""Math/Minimizer.h""; 49#include ""Math/MinimizerOptions.h""; 50#include ""Math/Factory.h""; 51#include ""Math/ChebyshevPol.h""; 52#include ""Fit/FitResult.h""; 53// for I/O backward compatibility; 54#include ""v5/TF1Data.h""; 55 ; 56#include ""AnalyticalIntegrals.h""; 57 ; 58std::atomic<Bool_t> TF1::fgAbsValue(kFALSE);; 59Bool_t TF1::fgRejectPoint = kFALSE;; 60std::atomic<Bool_t> TF1::fgAddToGlobList(kTRUE);; 61static Double_t gErrorTF1 = 0;; 62 ; 63using TF1Updater_t = void (*)(Int_t nobjects, TObject **from, TObject **to);; 64bool R__SetClonesArrayTF1Updater(TF1Updater_t func);; 65 ; 66 ; 67namespace {; 68struct TF1v5Convert : public TF1 {; 69public:; 70 void Convert(ROOT::v5::TF1Data &from); 71 {; 72 // convert old TF1 to new one; 73 fNpar = from.GetNpar();; 74 fNdim = from.GetNdim();; 75 if (from.fType == 0) {; 76 // formula functions; 77 // if ndim is not 1 set xmin max to zero to avoid error in ctor; 78 double xmin = from.fXmin;; 79 double xmax = from.fXmax;; 80 if (fNdim > 1) {; 81 xmin = 0;; 82 xmax = 0;; 83 }; 84 TF1 fnew(from.GetName(), from.GetExpFormula(), xmin, xmax);; 85 if (fNdim > 1) {; 86 fnew.SetRange(from.fXmin, from.fXmax);; 87 }; 88 fnew.Copy(*this);; 89 // need to set parameter values; 90 if (from.GetParameters()); 91 fFormula->SetParameters(from.GetParameters());; 92 } else {; 93 // case of a function pointers; 94 fParams = std::make_unique<TF1Parameters>(fNpar);; 95 fName = from.GetName();; 96 fTitle = from.GetTitle();; 97 // need to set parameter values; 98 if (from.GetParameters()); 99 fParams->SetParameters(from.GetParameters());; 100 }; 101 // copy the other data members; 102 fNpx = from.fNpx;; 103 fType = (EFType)from.fType;; 104 fNpfits = from.fNpfits;; 105 fNDF = from.fNDF;; 106 fChisquare = from.fChisquare;; 107 fMaximum = from.fMaximum;; 108 fMinimum = from.fMinimum;; 109 fXmin = from.fXmin;; 110 fXmax = from.fXm",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
Security,sanitiz,sanitized,"!TestBit(kNotGlobal);; 852 if (on) {; 853 if (prevStatus) {; 854 R__LOCKGUARD(gROOTMutex);; 855 assert(gROOT->GetListOfFunctions()->FindObject(this) != nullptr);; 856 return on; // do nothing; 857 }; 858 // do I need to delete previous one with the same name ???; 859 //TF1 * old = dynamic_cast<TF1*>( gROOT->GetListOfFunctions()->FindObject(GetName()) );; 860 //if (old) { gROOT->GetListOfFunctions()->Remove(old); old->SetBit(kNotGlobal, kTRUE); }; 861 R__LOCKGUARD(gROOTMutex);; 862 gROOT->GetListOfFunctions()->Add(this);; 863 SetBit(kNotGlobal, kFALSE);; 864 } else if (prevStatus) {; 865 // if previous status was on and now is off we need to remove the function; 866 SetBit(kNotGlobal, kTRUE);; 867 R__LOCKGUARD(gROOTMutex);; 868 TF1 *old = dynamic_cast<TF1 *>(gROOT->GetListOfFunctions()->FindObject(GetName()));; 869 if (!old) {; 870 Warning(""AddToGlobalList"", ""Function is supposed to be in the global list but it is not present"");; 871 return kFALSE;; 872 }; 873 gROOT->GetListOfFunctions()->Remove(this);; 874 }; 875 return prevStatus;; 876}; 877 ; 878////////////////////////////////////////////////////////////////////////////////; 879/// Helper functions for NSUM parsing; 880 ; 881// Defines the formula that a given term uses, if not already defined,; 882// and appends ""sanitized"" formula to `fullFormula` string; 883void TF1::DefineNSUMTerm(TObjArray *newFuncs, TObjArray *coeffNames, TString &fullFormula, TString &formula,; 884 int termStart, int termEnd, Double_t xmin, Double_t xmax); 885{; 886 TString originalTerm = formula(termStart, termEnd-termStart);; 887 int coeffLength = TermCoeffLength(originalTerm);; 888 if (coeffLength != -1); 889 termStart += coeffLength + 1;; 890 ; 891 // `originalFunc` is the real formula and `cleanedFunc` is the; 892 // sanitized version that will not confuse the TF1NormSum; 893 // constructor; 894 TString originalFunc = formula(termStart, termEnd-termStart);; 895 TString cleanedFunc = TString(formula(termStart, termEnd-termStart)); 896 .",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
Testability,assert,assert,"values; 90 if (from.GetParameters()); 91 fFormula->SetParameters(from.GetParameters());; 92 } else {; 93 // case of a function pointers; 94 fParams = std::make_unique<TF1Parameters>(fNpar);; 95 fName = from.GetName();; 96 fTitle = from.GetTitle();; 97 // need to set parameter values; 98 if (from.GetParameters()); 99 fParams->SetParameters(from.GetParameters());; 100 }; 101 // copy the other data members; 102 fNpx = from.fNpx;; 103 fType = (EFType)from.fType;; 104 fNpfits = from.fNpfits;; 105 fNDF = from.fNDF;; 106 fChisquare = from.fChisquare;; 107 fMaximum = from.fMaximum;; 108 fMinimum = from.fMinimum;; 109 fXmin = from.fXmin;; 110 fXmax = from.fXmax;; 111 ; 112 if (from.fParErrors); 113 fParErrors = std::vector<Double_t>(from.fParErrors, from.fParErrors + fNpar);; 114 if (from.fParMin); 115 fParMin = std::vector<Double_t>(from.fParMin, from.fParMin + fNpar);; 116 if (from.fParMax); 117 fParMax = std::vector<Double_t>(from.fParMax, from.fParMax + fNpar);; 118 if (from.fNsave > 0) {; 119 assert(from.fSave);; 120 fSave = std::vector<Double_t>(from.fSave, from.fSave + from.fNsave);; 121 }; 122 // set the bits; 123 for (int ibit = 0; ibit < 24; ++ibit); 124 if (from.TestBit(BIT(ibit))); 125 SetBit(BIT(ibit));; 126 ; 127 // copy the graph attributes; 128 from.TAttLine::Copy(*this);; 129 from.TAttFill::Copy(*this);; 130 from.TAttMarker::Copy(*this);; 131 }; 132};; 133} // unnamed namespace; 134 ; 135static void R__v5TF1Updater(Int_t nobjects, TObject **from, TObject **to); 136{; 137 auto **fromv5 = (ROOT::v5::TF1Data **)from;; 138 auto **target = (TF1v5Convert **)to;; 139 ; 140 for (int i = 0; i < nobjects; ++i) {; 141 if (fromv5[i] && target[i]); 142 target[i]->Convert(*fromv5[i]);; 143 }; 144}; 145 ; 146int R__RegisterTF1UpdaterTrigger = R__SetClonesArrayTF1Updater(R__v5TF1Updater);; 147 ; 148ClassImp(TF1);; 149 ; 150// class wrapping evaluation of TF1(x) - y0; 151class GFunc {; 152 const TF1 *fFunction;; 153 const double fY0;; 154public:; 155 GFunc(const TF1 *function",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
Usability,simpl,simple,"rameters (i.e. pass zero); 212 fX[0] = x;; 213 Double_t fval = fFunc->EvalPar(fX, nullptr);; 214 if (fAbsVal && fval < 0) return -fval;; 215 return fval;; 216 }; 217 // evaluate x * |f(x)|; 218 Double_t EvalFirstMom(Double_t x); 219 {; 220 fX[0] = x;; 221 return fX[0] * TMath::Abs(fFunc->EvalPar(fX, nullptr));; 222 }; 223 // evaluate (x - x0) ^n * f(x); 224 Double_t EvalNMom(Double_t x) const; 225 {; 226 fX[0] = x;; 227 return TMath::Power(fX[0] - fX0, fN) * TMath::Abs(fFunc->EvalPar(fX, nullptr));; 228 }; 229 ; 230 TF1 *fFunc;; 231 mutable Double_t fX[1];; 232 const double *fPar;; 233 Bool_t fAbsVal;; 234 Double_t fN;; 235 Double_t fX0;; 236};; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/** \class TF1; 240 \ingroup Functions; 241 \brief 1-Dim function class; 242 ; 243 ; 244## TF1: 1-Dim function class; 245 ; 246A TF1 object is a 1-Dim function defined between a lower and upper limit.; 247The function may be a simple function based on a TFormula expression or a precompiled user function.; 248The function may have associated parameters.; 249TF1 graphics function is via the TH1 and TGraph drawing functions.; 250 ; 251The following types of functions can be created:; 252 ; 2531. [Expression using variable x and no parameters](\ref F1); 2542. [Expression using variable x with parameters](\ref F2); 2553. [Lambda Expression with variable x and parameters](\ref F3); 2564. [A general C function with parameters](\ref F4); 2575. [A general C++ function object (functor) with parameters](\ref F5); 2586. [A member function with parameters of a general C++ class](\ref F6); 259 ; 260 ; 261 ; 262\anchor F1; 263### 1 - Expression using variable x and no parameters; 264 ; 265#### Case 1: inline expression using standard C++ functions/operators; 266 ; 267Begin_Macro(source); 268{; 269 auto fa1 = new TF1(""fa1"",""sin(x)/x"",0,10);; 270 fa1->Draw();; 271}; 272End_Macro; 273 ; 274#### Case 2: inline expression using a ROOT function (e.g. fro",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
Integrability,depend,dependency,". ROOT: hist/hist/inc/TF1.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Functions ; TF1.h File Reference. #include ""RConfigure.h""; #include <functional>; #include <cassert>; #include <memory>; #include <string>; #include <vector>; #include ""TFormula.h""; #include ""TMethodCall.h""; #include ""TAttLine.h""; #include ""TAttFill.h""; #include ""TAttMarker.h""; #include ""TF1AbsComposition.h""; #include ""TMath.h""; #include ""Math/Types.h""; #include ""Math/ParamFunctor.h"". Include dependency graph for TF1.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  ROOT::Internal::GetFunctorType< T >;  Internal class used by TF1 for obtaining the type from a functor out of the set of valid operator() signatures. More...;  ; struct  ROOT::Internal::GetFunctorType< T(F::*)(const T *, const double *) const >;  ; struct  ROOT::Internal::GetFunctorType< T(F::*)(const T *, const double *)>;  ; struct  ROOT::Internal::GetFunctorType< T(F::*)(T *, double *) const >;  ; struct  ROOT::Internal::GetFunctorType< T(F::*)(T *, double *)>;  ; class  TF1;  1-Dim function class More...;  ; struct  ROOT::Internal::TF1Builder< Func >;  Internal class used by TF1 for defining template specialization for different TF1 constructors More...;  ; struct  ROOT::Internal::TF1Builder< const char * >;  TF1 building from a string used to build a TFormula based on a lambda function. More...;  ; struct  ROOT::Internal::TF1Builder< Func * >;  ; struct  TF1::TF1FunctorPointer;  ; struct  TF1::TF1FunctorPointerImpl< T >;  ; class  TF1Parameters;  TF1 Parameters class. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declar",MatchSource.WIKI,doc/master/TF1_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h.html
Availability,error,errors,"la = 0, ///< Formula functions which can be stored,; 256 kPtrScalarFreeFcn, ///< Pointer to scalar free function,; 257 kInterpreted, ///< Interpreted functions constructed by name,; 258 kTemplVec, ///< Vectorized free functions or TemplScalar functors evaluating on vectorized parameters,; 259 kTemplScalar, ///< TemplScalar functors evaluating on scalar parameters; 260 kCompositionFcn; 261 }; // formula based on composition class (e.g. NSUM, CONV); 262 ; 263 Double_t fXmin{-1111}; ///< Lower bounds for the range; 264 Double_t fXmax{-1111}; ///< Upper bounds for the range; 265 Int_t fNpar{}; ///< Number of parameters; 266 Int_t fNdim{}; ///< Function dimension; 267 Int_t fNpx{100}; ///< Number of points used for the graphical representation; 268 EFType fType{EFType::kTemplScalar};; 269 Int_t fNpfits{}; ///< Number of points used in the fit; 270 Int_t fNDF{}; ///< Number of degrees of freedom in the fit; 271 Double_t fChisquare{}; ///< Function fit chisquare; 272 Double_t fMinimum{-1111}; ///< Minimum value for plotting; 273 Double_t fMaximum{-1111}; ///< Maximum value for plotting; 274 std::vector<Double_t> fParErrors; ///< Array of errors of the fNpar parameters; 275 std::vector<Double_t> fParMin; ///< Array of lower limits of the fNpar parameters; 276 std::vector<Double_t> fParMax; ///< Array of upper limits of the fNpar parameters; 277 std::vector<Double_t> fSave; ///< Array of fNsave function values; 278 std::vector<Double_t> fIntegral; ///<! Integral of function binned on fNpx bins; 279 std::vector<Double_t> fAlpha; ///<! Array alpha. for each bin in x the deconvolution r of fIntegral; 280 std::vector<Double_t> fBeta; ///<! Array beta. is approximated by x = alpha +beta*r *gamma*r**2; 281 std::vector<Double_t> fGamma; ///<! Array gamma.; 282 TObject *fParent{nullptr}; ///<! Parent object hooking this function (if one); 283 TH1 *fHistogram{nullptr}; ///<! Pointer to histogram used for visualisation; 284 std::unique_ptr<TMethodCall> fMethodCall; ///<! Pointer to Met",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
Energy Efficiency,efficient,efficient,"r(Int_t iparam) constDefinition TF1.h:80; TF1Parameters::SetParNamevoid SetParName(Int_t iparam, const char *name)Definition TF1.h:122; TF1Parameters::operator=TF1Parameters & operator=(const TF1Parameters &rhs)Definition TF1.h:70; TF1Parameters::SetParametervoid SetParameter(Int_t iparam, Double_t value)Definition TF1.h:106; TF1Parameters::SetParametervoid SetParameter(const char *name, Double_t value)Definition TF1.h:118; TF1Parameters::TF1ParametersTF1Parameters(Int_t npar)Definition TF1.h:56; TF1Parameters::fParNamesstd::vector< std::string > fParNamesDefinition TF1.h:139; TF1Parameters::TF1ParametersTF1Parameters()Definition TF1.h:55; TF1Parameters::CheckIndexbool CheckIndex(Int_t i) constDefinition TF1.h:133; TF1Parameters::SetParNamesvoid SetParNames(Args &&... args)Set parameter names.Definition TF1.h:156; TF1Parameters::SetParametersvoid SetParameters(const Double_t *params)Definition TF1.h:111; TF1Parameters::GetParNumberInt_t GetParNumber(const char *name) constReturns the parameter number given a name not very efficient but list of parameters is typically smal...Definition TF1.cxx:3846; TF1Parameters::TF1ParametersTF1Parameters(const TF1Parameters &rhs)Definition TF1.h:65; TF1Parameters::GetParametersconst Double_t * GetParameters() constDefinition TF1.h:88; TF11-Dim function classDefinition TF1.h:233; TF1::fFunctorstd::unique_ptr< TF1FunctorPointer > fFunctor! Functor object to wrap any C++ callable objectDefinition TF1.h:287; TF1::GetMinimumXvirtual Double_t GetMinimumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the X value corresponding to the minimum value of the function on the (xmin,...Definition TF1.cxx:1823; TF1::GetMinimumvirtual Double_t GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the minimum value of the function on the (xmin, xmax) interval.Definition TF1.cxx:1696; TF1::GetXmaxvirtual Double_t GetXmax",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
Integrability,wrap,wrap,"Array of lower limits of the fNpar parameters; 276 std::vector<Double_t> fParMax; ///< Array of upper limits of the fNpar parameters; 277 std::vector<Double_t> fSave; ///< Array of fNsave function values; 278 std::vector<Double_t> fIntegral; ///<! Integral of function binned on fNpx bins; 279 std::vector<Double_t> fAlpha; ///<! Array alpha. for each bin in x the deconvolution r of fIntegral; 280 std::vector<Double_t> fBeta; ///<! Array beta. is approximated by x = alpha +beta*r *gamma*r**2; 281 std::vector<Double_t> fGamma; ///<! Array gamma.; 282 TObject *fParent{nullptr}; ///<! Parent object hooking this function (if one); 283 TH1 *fHistogram{nullptr}; ///<! Pointer to histogram used for visualisation; 284 std::unique_ptr<TMethodCall> fMethodCall; ///<! Pointer to MethodCall in case of interpreted function; 285 Bool_t fNormalized{false}; ///< Normalization option (false by default); 286 Double_t fNormIntegral{}; ///< Integral of the function before being normalized; 287 std::unique_ptr<TF1FunctorPointer> fFunctor; ///<! Functor object to wrap any C++ callable object; 288 std::unique_ptr<TFormula> fFormula; ///< Pointer to TFormula in case when user define formula; 289 std::unique_ptr<TF1Parameters> fParams; ///< Pointer to Function parameters object (exists only for not-formula functions); 290 std::unique_ptr<TF1AbsComposition> fComposition; ///< Pointer to composition (NSUM or CONV); 291 ; 292 /// General constructor for TF1. Most of the other constructors delegate on it; 293 TF1(EFType functionType, const char *name, Double_t xmin, Double_t xmax, Int_t npar, Int_t ndim, EAddToList addToGlobList, TF1Parameters *params = nullptr, TF1FunctorPointer * functor = nullptr):; 294 TNamed(name, name), TAttLine(), TAttFill(), TAttMarker(), fXmin(xmin), fXmax(xmax), fNpar(npar), fNdim(ndim),; 295 fType(functionType), fParErrors(npar), fParMin(npar), fParMax(npar); 296 {; 297 fParams.reset(params);; 298 fFunctor.reset(functor);; 299 DoInitialize(addToGlobList);; 300 }; 301 ;",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
Safety,safe,safety,"; 895void TF1::SetFunction(PtrObj &p, MemFn memFn); 896{; 897 // set from a pointer to a member function; 898 fType = EFType::kPtrScalarFreeFcn;; 899 fFunctor = std::make_unique<TF1::TF1FunctorPointerImpl<double>>(ROOT::Math::ParamFunctor(p, memFn));; 900}; 901 ; 902template <class T>; 903inline T TF1::GradientPar(Int_t ipar, const T *x, Double_t eps); 904{; 905 if (fType == EFType::kTemplVec || fType == EFType::kTemplScalar) {; 906 return GradientParTempl<T>(ipar, x, eps);; 907 } else; 908 return GradientParTempl<Double_t>(ipar, (const Double_t *)x, eps);; 909}; 910 ; 911template <class T>; 912inline T TF1::GradientParTempl(Int_t ipar, const T *x, Double_t eps); 913{; 914 if (GetNpar() == 0); 915 return 0;; 916 ; 917 if (eps < 1e-10 || eps > 1) {; 918 Warning(""Derivative"", ""parameter esp=%g out of allowed range[1e-10,1], reset to 0.01"", eps);; 919 eps = 0.01;; 920 }; 921 Double_t h;; 922 TF1 *func = (TF1 *)this;; 923 Double_t *parameters = GetParameters();; 924 ; 925 // Copy parameters for thread safety; 926 std::vector<Double_t> parametersCopy(parameters, parameters + GetNpar());; 927 parameters = parametersCopy.data();; 928 ; 929 Double_t al, bl, h2;; 930 T f1, f2, g1, g2, d0, d2;; 931 ; 932 ((TF1 *)this)->GetParLimits(ipar, al, bl);; 933 if (al * bl != 0 && al >= bl) {; 934 // this parameter is fixed; 935 return 0;; 936 }; 937 ; 938 // check if error has been computer (is not zero); 939 if (func->GetParError(ipar) != 0); 940 h = eps * func->GetParError(ipar);; 941 else; 942 h = eps;; 943 ; 944 // save original parameters; 945 Double_t par0 = parameters[ipar];; 946 ; 947 parameters[ipar] = par0 + h;; 948 f1 = func->EvalPar(x, parameters);; 949 parameters[ipar] = par0 - h;; 950 f2 = func->EvalPar(x, parameters);; 951 parameters[ipar] = par0 + h / 2;; 952 g1 = func->EvalPar(x, parameters);; 953 parameters[ipar] = par0 - h / 2;; 954 g2 = func->EvalPar(x, parameters);; 955 ; 956 // compute the central differences; 957 h2 = 1 / (2. * h);; 958 d0 = f1 - f2;; 959 d2 = 2 ",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
Testability,log,logx," EFType::kTemplVec) || (fType == EFType::kFormula && fFormula && fFormula->IsVectorized());; 470 }; 471 /// Return the Chisquare after fitting. See ROOT::Fit::FitResult::Chi2(); 472 Double_t GetChisquare() const; 473 {; 474 return fChisquare;; 475 }; 476 virtual TH1 *GetHistogram() const;; 477 virtual TH1 *CreateHistogram(); 478 {; 479 return DoCreateHistogram(fXmin, fXmax);; 480 }; 481 virtual TFormula *GetFormula(); 482 {; 483 return fFormula.get();; 484 }; 485 virtual const TFormula *GetFormula() const; 486 {; 487 return fFormula.get();; 488 }; 489 virtual TString GetExpFormula(Option_t *option = """") const; 490 {; 491 return (fFormula) ? fFormula->GetExpFormula(option) : TString();; 492 }; 493 virtual const TObject *GetLinearPart(Int_t i) const; 494 {; 495 return (fFormula) ? fFormula->GetLinearPart(i) : nullptr;; 496 }; 497 virtual Double_t GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 498 virtual Double_t GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 499 virtual Double_t GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 500 virtual Double_t GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 501 virtual Double_t GetMaximumStored() const; 502 {; 503 return fMaximum;; 504 }; 505 virtual Double_t GetMinimumStored() const; 506 {; 507 return fMinimum;; 508 }; 509 virtual Int_t GetNpar() const; 510 {; 511 return fNpar;; 512 }; 513 virtual Int_t GetNdim() const; 514 {; 515 return fNdim;; 516 }; 517 virtual Int_t GetNDF() const;; 518 virtual Int_t GetNpx() const; 519 {; 520 return fNpx;; 521 }; 522 TMethodCall *GetMethodCall() const; 523 {; 524 return fMethodCall.get();; 525 }; 526 virtual Int_t GetNumber() const; 527 {; 528 return (fFormula) ? fFormula->GetNumber",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
Availability,error,error,"efinition TH1.cxx:8990; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:1",MatchSource.WIKI,doc/master/TF2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html
Deployability,integrat,integrated,"py));; 493 const char *drawOption = GetDrawOption();; 494 Double_t uxmin,uxmax;; 495 Double_t uymin,uymax;; 496 if (gPad->GetView() || strncmp(drawOption,""cont"",4) == 0; 497 || strncmp(drawOption,""CONT"",4) == 0) {; 498 uxmin=gPad->GetUxmin();; 499 uxmax=gPad->GetUxmax();; 500 x = fXmin +(fXmax-fXmin)*(x-uxmin)/(uxmax-uxmin);; 501 uymin=gPad->GetUymin();; 502 uymax=gPad->GetUymax();; 503 y = fYmin +(fYmax-fYmin)*(y-uymin)/(uymax-uymin);; 504 }; 505 snprintf(info,64,""(x=%g, y=%g, f=%.18g)"",x,y,((TF2*)this)->Eval(x,y));; 506 return info;; 507}; 508 ; 509////////////////////////////////////////////////////////////////////////////////; 510/// Return a random number following this function shape; 511 ; 512Double_t TF2::GetRandom(TRandom *, Option_t *); 513{; 514 Error(""GetRandom"",""cannot be called for TF2/3, use GetRandom2/3 instead"");; 515 return 0; // not yet implemented; 516}; 517 ; 518////////////////////////////////////////////////////////////////////////////////; 519/// Return a random number following this function shape; 520 ; 521 ; 522Double_t TF2::GetRandom(Double_t, Double_t, TRandom *, Option_t *); 523{; 524 Error(""GetRandom"",""cannot be called for TF2/3, use GetRandom2/3 instead"");; 525 return 0; // not yet implemented; 526}; 527 ; 528////////////////////////////////////////////////////////////////////////////////; 529/// Return 2 random numbers following this function shape; 530///; 531/// The distribution contained in this TF2 function is integrated; 532/// over the cell contents.; 533/// It is normalized to 1.; 534/// Getting the two random numbers implies:; 535/// - Generating a random number between 0 and 1 (say r1); 536/// - Look in which cell in the normalized integral r1 corresponds to; 537/// - make a linear interpolation in the returned cell; 538///; 539///; 540/// IMPORTANT NOTE; 541///; 542/// The integral of the function is computed at fNpx * fNpy points.; 543/// If the function has sharp peaks, you should increase the number of; 544/// points (Se",MatchSource.WIKI,doc/master/TF2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html
Integrability,integrat,integrated,"py));; 493 const char *drawOption = GetDrawOption();; 494 Double_t uxmin,uxmax;; 495 Double_t uymin,uymax;; 496 if (gPad->GetView() || strncmp(drawOption,""cont"",4) == 0; 497 || strncmp(drawOption,""CONT"",4) == 0) {; 498 uxmin=gPad->GetUxmin();; 499 uxmax=gPad->GetUxmax();; 500 x = fXmin +(fXmax-fXmin)*(x-uxmin)/(uxmax-uxmin);; 501 uymin=gPad->GetUymin();; 502 uymax=gPad->GetUymax();; 503 y = fYmin +(fYmax-fYmin)*(y-uymin)/(uymax-uymin);; 504 }; 505 snprintf(info,64,""(x=%g, y=%g, f=%.18g)"",x,y,((TF2*)this)->Eval(x,y));; 506 return info;; 507}; 508 ; 509////////////////////////////////////////////////////////////////////////////////; 510/// Return a random number following this function shape; 511 ; 512Double_t TF2::GetRandom(TRandom *, Option_t *); 513{; 514 Error(""GetRandom"",""cannot be called for TF2/3, use GetRandom2/3 instead"");; 515 return 0; // not yet implemented; 516}; 517 ; 518////////////////////////////////////////////////////////////////////////////////; 519/// Return a random number following this function shape; 520 ; 521 ; 522Double_t TF2::GetRandom(Double_t, Double_t, TRandom *, Option_t *); 523{; 524 Error(""GetRandom"",""cannot be called for TF2/3, use GetRandom2/3 instead"");; 525 return 0; // not yet implemented; 526}; 527 ; 528////////////////////////////////////////////////////////////////////////////////; 529/// Return 2 random numbers following this function shape; 530///; 531/// The distribution contained in this TF2 function is integrated; 532/// over the cell contents.; 533/// It is normalized to 1.; 534/// Getting the two random numbers implies:; 535/// - Generating a random number between 0 and 1 (say r1); 536/// - Look in which cell in the normalized integral r1 corresponds to; 537/// - make a linear interpolation in the returned cell; 538///; 539///; 540/// IMPORTANT NOTE; 541///; 542/// The integral of the function is computed at fNpx * fNpy points.; 543/// If the function has sharp peaks, you should increase the number of; 544/// points (Se",MatchSource.WIKI,doc/master/TF2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html
Modifiability,variab,variables,"atches. TF2.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Rene Brun 23/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TROOT.h""; 13#include ""TF2.h""; 14#include ""TMath.h""; 15#include ""TRandom.h""; 16#include ""TBuffer.h""; 17#include ""TH2.h""; 18#include ""TVirtualPad.h""; 19#include <iostream>; 20#include ""TColor.h""; 21#include ""TVirtualFitter.h""; 22#include ""Math/IntegratorOptions.h""; 23#include ""snprintf.h""; 24 ; 25ClassImp(TF2);; 26 ; 27/** \class TF2; 28 \ingroup Functions; 29 \brief A 2-Dim function with parameters.; 30 ; 31The following types of functions can be created:; 32 ; 331. [Expression using variables x and y](\ref TF2a); 342. [Expression using a user defined function](\ref TF2b); 353. [Lambda Expression with x and y variables and parameters](\ref TF2c); 36 ; 37\anchor TF2a; 38### Expression using variables x and y; 39 ; 40Begin_Macro (source); 41{; 42 auto f2 = new TF2(""f2"",""sin(x)*sin(y)/(x*y)"",0,5,0,5);; 43 f2->Draw();; 44}; 45End_Macro; 46 ; 47\anchor TF2b; 48### Expression using a user defined function; 49 ; 50~~~~{.cpp}; 51Double_t func(Double_t *val, Double_t *par); 52{; 53 Float_t x = val[0];; 54 Float_t y = val[1];; 55 Double_t f = x*x-y*y;; 56 return f;; 57}; 58 ; 59void fplot(); 60{; 61 auto f = new TF2(""f"",func,-1,1,-1,1);; 62 f->Draw(""surf1"");; 63}; 64~~~~; 65 ; 66\anchor TF2c; 67### Lambda Expression with x and y variables and parameters; 68 ; 69~~~~{.cpp}; 70root [0] TF2 f2(""f2"", [](double* x, double*p) { return x[0] + x[1] * p[0]; }, 0., 1., 0., 1., 1); 71(TF2 &) Name: f2 Title: f2; 72root [1] f2.SetParameter(0, 1.); 73root [2] f2.Eval(1., 2.); 74(double) 3.0000000",MatchSource.WIKI,doc/master/TF2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html
Performance,perform,performed,"vels) {; 330 for (Int_t level=0; level<nlevels; level++) levels[level] = GetContourLevel(level);; 331 }; 332 return nlevels;; 333}; 334 ; 335////////////////////////////////////////////////////////////////////////////////; 336/// Return the number of contour levels; 337 ; 338Double_t TF2::GetContourLevel(Int_t level) const; 339{; 340 if (level <0 || level >= fContour.fN) return 0;; 341 if (fContour.fArray[0] != -9999) return fContour.fArray[level];; 342 if (fHistogram == nullptr) return 0;; 343 return fHistogram->GetContourLevel(level);; 344}; 345 ; 346////////////////////////////////////////////////////////////////////////////////; 347/// Return minimum/maximum value of the function; 348///; 349/// To find the minimum on a range, first set this range via the SetRange function.; 350/// If a vector x of coordinate is passed it will be used as starting point for the minimum.; 351/// In addition on exit x will contain the coordinate values at the minimuma; 352///; 353/// If x is NULL or x is infinity or NaN, first, a grid search is performed to find the initial estimate of the; 354/// minimum location. The range of the function is divided into fNpx and fNpy; 355/// sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; 356/// by SetNpx and SetNpy functions; 357///; 358/// Then, a minimization is used with starting values found by the grid search; 359/// The minimizer algorithm used (by default Minuit) can be changed by callinga; 360/// ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); 361/// Other option for the minimizer can be set using the static method of the MinimizerOptions class; 362 ; 363Double_t TF2::FindMinMax(Double_t *x, Bool_t findmax) const; 364{; 365 //First do a grid search with step size fNpx and fNpy; 366 ; 367 Double_t xx[2];; 368 Double_t rsign = (findmax) ? -1. : 1.;; 369 TF2 & function = const_cast<TF2&>(*this); // needed since EvalPar is not const; 370 Double_t xxmin = 0, yymin = 0, zzmin = 0;; 371 if (x == nullptr || (",MatchSource.WIKI,doc/master/TF2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html
Usability,clear,clear,"; 777 fHistogram->SetLineStyle(GetLineStyle());; 778 fHistogram->SetLineWidth(GetLineWidth());; 779 fHistogram->SetFillColor(GetFillColor());; 780 fHistogram->SetFillStyle(GetFillStyle());; 781 fHistogram->SetMarkerColor(GetMarkerColor());; 782 fHistogram->SetMarkerStyle(GetMarkerStyle());; 783 fHistogram->SetMarkerSize(GetMarkerSize());; 784 fHistogram->SetStats(false);; 785 ; 786//- Draw the histogram; 787 if (!gPad) return;; 788 if (opt.Length() == 0) fHistogram->Paint(""cont3"");; 789 else if (opt == ""same"") fHistogram->Paint(""cont2same"");; 790 else fHistogram->Paint(option);; 791}; 792 ; 793////////////////////////////////////////////////////////////////////////////////; 794/// Save values of function in array fSave; 795 ; 796void TF2::Save(Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t, Double_t); 797{; 798 if (!fSave.empty()); 799 fSave.clear();; 800 Int_t npx = fNpx, npy = fNpy;; 801 if ((npx < 2) || (npy < 2)); 802 return;; 803 Double_t dx = (xmax-xmin)/fNpx;; 804 Double_t dy = (ymax-ymin)/fNpy;; 805 if (dx <= 0) {; 806 dx = (fXmax-fXmin)/fNpx;; 807 npx--;; 808 xmin = fXmin + 0.5*dx;; 809 xmax = fXmax - 0.5*dx;; 810 }; 811 if (dy <= 0) {; 812 dy = (fYmax-fYmin)/fNpy;; 813 npy--;; 814 ymin = fYmin + 0.5*dy;; 815 ymax = fYmax - 0.5*dy;; 816 }; 817 ; 818 Int_t nsave = (npx + 1) * (npy + 1);; 819 fSave.resize(nsave + 6);; 820 Double_t xv[2];; 821 Double_t *parameters = GetParameters();; 822 InitArgs(xv, parameters);; 823 for (Int_t j = 0, k = 0; j <= npy; j++) {; 824 xv[1] = ymin + dy*j;; 825 for (Int_t i = 0; i <= npx; i++) {; 826 xv[0] = xmin + dx*i;; 827 fSave[k++] = EvalPar(xv, parameters);; 828 }; 829 }; 830 fSave[nsave+0] = xmin;; 831 fSave[nsave+1] = xmax;; 832 fSave[nsave+2] = ymin;; 833 fSave[nsave+3] = ymax;; 834 fSave[nsave+4] = npx;; 835 fSave[nsave+5] = npy;; 836}; 837 ; 838////////////////////////////////////////////////////////////////////////////////; 839/// Save primitive as a C++ statement(s) on output stream out; 840 ; 841",MatchSource.WIKI,doc/master/TF2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html
Integrability,depend,dependency,". ROOT: hist/hist/inc/TF2.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TF2.h File Reference. #include ""TF1.h""; #include ""TArrayD.h"". Include dependency graph for TF2.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TF2;  A 2-Dim function with parameters. More...;  . histhistincTF2.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TF2_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8h.html
Testability,log,logx,"n Rtypes.h:346; TArrayD.h; TF1.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; ROOT::Math::ParamFunctorTemplParam Functor class for Multidimensional functions.Definition ParamFunctor.h:274; TArrayDArray of doubles (64 bits per element).Definition TArrayD.h:27; TF11-Dim function classDefinition TF1.h:233; TF1::GetMinimumvirtual Double_t GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the minimum value of the function on the (xmin, xmax) interval.Definition TF1.cxx:1696; TF1::SetRangevirtual void SetRange(Double_t xmin, Double_t xmax)Initialize the upper and lower bounds to draw the function.Definition TF1.cxx:3528; TF1::Integralvirtual Double_t Integral(Double_t a, Double_t b, Double_t epsrel=1.e-12)IntegralOneDim or analytical integral.Definition TF1.cxx:2531; TF1::GetRangevirtual void GetRange(Double_t *xmin, Double_t *xmax) constReturn range of a generic N-D function.Definition TF1.cxx:2281; TF1::fNpxInt_t fNpxNumber of points used for the graphical representation.Definition TF1.h:267; TF1::GetMaximumvirtual Double_t GetMaximum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the maximum value of the function.Definition TF1.cxx:1614; TF2A 2-Dim function with parameters.Definition TF2.h:29; TF2::GetMaximumXYvirtual Double_t GetMaximumXY(Double_t &x, Double_t &y) constCompute the X and Y values correspondin",MatchSource.WIKI,doc/master/TF2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8h_source.html
Availability,recover,recovery,"In case the file does not exist or is not a valid ROOT file,; 297/// it is made a Zombie. One can detect this situation with a code like:; 298/// ~~~{.cpp}; 299/// TFile f(""file.root"");; 300/// if (f.IsZombie()) {; 301/// std::cout << ""Error opening file"" << std::endl;; 302/// exit(-1);; 303/// }; 304/// ~~~; 305/// If you open a file instead with TFile::Open(""file.root"") use rather; 306/// the following code as a nullptr is returned.; 307/// ~~~{.cpp}; 308/// TFile* f = TFile::Open(""file.root"");; 309/// if (!f) {; 310/// std::cout << ""Error opening file"" << std::endl;; 311/// exit(-1);; 312/// }; 313/// ~~~; 314/// When opening the file, the system checks the validity of this directory.; 315/// If something wrong is detected, an automatic Recovery is performed. In; 316/// this case, the file is scanned sequentially reading all logical blocks; 317/// and attempting to rebuild a correct directory (see TFile::Recover).; 318/// One can disable the automatic recovery procedure when reading one; 319/// or more files by setting the environment variable ""TFile.Recover: 0""; 320/// in the system.rootrc file.; 321///; 322/// A bit `TFile::kReproducible` can be enabled specifying; 323/// the `""reproducible""` url option when creating the file:; 324/// ~~~{.cpp}; 325/// TFile *f = TFile::Open(""name.root?reproducible"",""RECREATE"",""File title"");; 326/// ~~~; 327/// Unlike regular `TFile`s, the content of such file has reproducible binary; 328/// content when writing exactly same data. This achieved by writing pre-defined; 329/// values for creation and modification date of TKey/TDirectory objects and; 330/// null value for TUUID objects inside TFile. As drawback, TRef objects stored; 331/// in such file cannot be read correctly.; 332///; 333/// In case the name of the file is not reproducible either (in case of; 334/// creating temporary filenames) a value can be passed to the reproducible; 335/// option to replace the name stored in the file.; 336/// ~~~{.cpp}; 337/// TFile *f = T",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
Deployability,update,update," this) : nullptr;; 408 if (fArchive) {; 409 fname1 = fArchive->GetArchiveName();; 410 // if no archive member is specified then this TFile is just used; 411 // to read the archive contents; 412 if (!strlen(fArchive->GetMemberName())); 413 fIsArchive = kTRUE;; 414 }; 415 }; 416 ; 417 if (fOption.Contains(""_WITHOUT_GLOBALREGISTRATION"")) {; 418 fOption = fOption.ReplaceAll(""_WITHOUT_GLOBALREGISTRATION"", """");; 419 fGlobalRegistration = false;; 420 if (fList) {; 421 fList->UseRWLock(false);; 422 }; 423 }; 424 ; 425 if (fOption == ""NET""); 426 return;; 427 ; 428 if (fOption == ""WEB"") {; 429 fOption = ""READ"";; 430 fWritable = kFALSE;; 431 return;; 432 }; 433 ; 434 if (fOption == ""NEW""); 435 fOption = ""CREATE"";; 436 ; 437 Bool_t create = (fOption == ""CREATE"") ? kTRUE : kFALSE;; 438 Bool_t recreate = (fOption == ""RECREATE"") ? kTRUE : kFALSE;; 439 Bool_t update = (fOption == ""UPDATE"") ? kTRUE : kFALSE;; 440 Bool_t read = (fOption == ""READ"") ? kTRUE : kFALSE;; 441 if (!create && !recreate && !update && !read) {; 442 read = kTRUE;; 443 fOption = ""READ"";; 444 }; 445 ; 446 Bool_t devnull = kFALSE;; 447 ; 448 if (!fname1 || !fname1[0]) {; 449 Error(""TFile"", ""file name is not specified"");; 450 zombify();; 451 return;; 452 }; 453 ; 454 // support dumping to /dev/null on UNIX; 455 if (!strcmp(fname1, ""/dev/null"") &&; 456 !gSystem->AccessPathName(fname1, kWritePermission)) {; 457 devnull = kTRUE;; 458 create = kTRUE;; 459 recreate = kFALSE;; 460 update = kFALSE;; 461 read = kFALSE;; 462 fOption = ""CREATE"";; 463 SetBit(kDevNull);; 464 }; 465 ; 466 TString fname(fname1);; 467 if (!gSystem->ExpandPathName(fname)) {; 468 SetName(fname.Data());; 469 fRealName = GetName();; 470 if (!gSystem->IsAbsoluteFileName(fRealName)) {; 471 gSystem->PrependPathName(gSystem->WorkingDirectory(),fRealName);; 472 }; 473 fname = fRealName.Data();; 474 } else {; 475 Error(""TFile"", ""error expanding path %s"", fname1);; 476 zombify();; 477 return;; 478 }; 479 ; 480 // If the user supplied a value to the option ta",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
Energy Efficiency,adapt,adapt,"513 path.Form(""%s/BUILD.sh"", proofinf);; 3514#ifdef R__WINGCC; 3515 FILE *f = fopen(path.Data(), ""wb"");; 3516#else; 3517 FILE *f = fopen(path.Data(), ""w"");; 3518#endif; 3519 if (!f) {; 3520 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3521 path.Data(), TSystem::GetErrno());; 3522 return -1;; 3523 }; 3524 ; 3525 fprintf(f, ""#! /bin/sh\n"");; 3526 fprintf(f, ""# Build libEvent library.\n"");; 3527 fprintf(f, ""\n"");; 3528 fprintf(f, ""#\n"");; 3529 fprintf(f, ""# The environment variables ROOTPROOFLITE and ROOTPROOFCLIENT can be used to\n"");; 3530 fprintf(f, ""# adapt the script to the calling environment\n"");; 3531 fprintf(f, ""#\n"");; 3532 fprintf(f, ""# if test ! \""x$ROOTPROOFLITE\"" = \""x\""; then\n"");; 3533 fprintf(f, ""# echo \""event-BUILD: PROOF-Lite node (session has $ROOTPROOFLITE workers)\""\n"");; 3534 fprintf(f, ""# elif test ! \""x$ROOTPROOFCLIENT\"" = \""x\""; then\n"");; 3535 fprintf(f, ""# echo \""event-BUILD: PROOF client\""\n"");; 3536 fprintf(f, ""# else\n"");; 3537 fprintf(f, ""# echo \""event-BUILD: standard PROOF node\""\n"");; 3538 fprintf(f, ""# fi\n"");; 3539 fprintf(f, ""\n"");; 3540 fprintf(f, ""if [ \""\"" = \""clean\"" ]; then\n"");; 3541 fprintf(f, "" make distclean\n"");; 3542 fprintf(f, "" exit 0\n"");; 3543 fprintf(f, ""fi\n"");; 3544 fprintf(f, ""\n"");; 3545 fprintf(f, ""make\n"");; 3546 fprintf(f, ""rc=$?\n"");; 3547 fprintf(f, ""echo \""rc=$?\""\n"");; 3548 fprintf(f, ""if [ $? != \""0\"" ] ; then\n"");; 3549 fprintf(f, "" exit 1\n"");; 3550 fprintf(f, ""fi\n"");; 3551 fprintf(f, ""exit 0\n"");; 3552 ; 3553 // Close the file; 3554 fclose(f);; 3555 ; 3556 // Then SETUP.C; 3557 path.Form(""%s/SETUP.C"", proofinf);; 3558#ifdef R__WINGCC; 3559 f = fopen(path.Data(), ""wb"");; 3560#else; 3561 f = fopen(path.Data(), ""w"");; 3562#endif; 3563 if (!f) {; 3564 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3565 path.Data(), TSystem::GetErrno());; 3566 return -1;; 3567 }; 3568 ; 3569 fprintf(f, ""Int_t SETUP()\n"");; 3570 fprintf(f, ""{\n"");; 3571 fprintf(f, ""\n"");;",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
Integrability,rout,routine,"r,1,""END"");; 1692 else; 1693 Printf(""At:%-*lld N=%-8d K= O= %-14s"", nDigits+1, idcur,1,""END"");; 1694}; 1695 ; 1696////////////////////////////////////////////////////////////////////////////////; 1697/// Paint all objects in the file.; 1698 ; 1699void TFile::Paint(Option_t *option); 1700{; 1701 GetList()->R__FOR_EACH(TObject,Paint)(option);; 1702}; 1703 ; 1704////////////////////////////////////////////////////////////////////////////////; 1705/// Print all objects in the file.; 1706 ; 1707void TFile::Print(Option_t *option) const; 1708{; 1709 Printf(""TFile: name=%s, title=%s, option=%s"", GetName(), GetTitle(), GetOption());; 1710 GetList()->R__FOR_EACH(TObject,Print)(option);; 1711}; 1712 ; 1713////////////////////////////////////////////////////////////////////////////////; 1714/// Read a buffer from the file at the offset 'pos' in the file.; 1715///; 1716/// Returns kTRUE in case of failure.; 1717/// Compared to ReadBuffer(char*, Int_t), this routine does _not_; 1718/// change the cursor on the physical file representation (fD); 1719/// if the data is in this TFile's cache.; 1720 ; 1721Bool_t TFile::ReadBuffer(char *buf, Long64_t pos, Int_t len); 1722{; 1723 if (IsOpen()) {; 1724 ; 1725 SetOffset(pos);; 1726 ; 1727 Int_t st;; 1728 Double_t start = 0;; 1729 if (gPerfStats) start = TTimeStamp();; 1730 ; 1731 if ((st = ReadBufferViaCache(buf, len))) {; 1732 if (st == 2); 1733 return kTRUE;; 1734 return kFALSE;; 1735 }; 1736 ; 1737 Seek(pos);; 1738 ssize_t siz;; 1739 ; 1740 while ((siz = SysRead(fD, buf, len)) < 0 && GetErrno() == EINTR); 1741 ResetErrno();; 1742 ; 1743 if (siz < 0) {; 1744 SysError(""ReadBuffer"", ""error reading from file %s"", GetName());; 1745 return kTRUE;; 1746 }; 1747 if (siz != len) {; 1748 Error(""ReadBuffer"", ""error reading all requested bytes from file %s, got %ld of %d"",; 1749 GetName(), (Long_t)siz, len);; 1750 return kTRUE;; 1751 }; 1752 fBytesRead += siz;; 1753 fgBytesRead += siz;; 1754 fReadCalls++;; 1755 fgReadCalls++;; 1756 ; 1757 if (gM",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
Modifiability,plugin,plugin," : TDirectoryFile(), fCompress(ROOT::RCompressionSetting::EAlgorithm::kUseGlobal); 203{; 204 fCacheReadMap = new TMap();; 205 SetBit(kBinaryFile, kTRUE);; 206 ; 207 if (gDebug); 208 Info(""TFile"", ""default ctor"");; 209}; 210 ; 211////////////////////////////////////////////////////////////////////////////////; 212/// Opens or creates a local ROOT file.; 213///; 214/// \param[in] fname1 The name of the file; 215/// \param[in] option Specifies the mode in which the file is opened; 216/// \param[in] ftitle The title of the file; 217/// \param[in] compress Specifies the compression algorithm and level; 218///; 219/// It is recommended to specify fname1 as ""<file>.root"". The suffix "".root""; 220/// will be used by object browsers to automatically identify the file as; 221/// a ROOT file. If the constructor fails in any way IsZombie() will; 222/// return true. Use IsOpen() to check if the file is (still) open.; 223/// To open non-local files use the static TFile::Open() method, that; 224/// will take care of opening the files using the correct remote file; 225/// access plugin.; 226///; 227/// Option | Description; 228/// -------|------------; 229/// NEW or CREATE | Create a new file and open it for writing, if the file already exists the file is not opened.; 230/// RECREATE | Create a new file, if the file already exists it will be overwritten.; 231/// UPDATE | Open an existing file for writing. If no file exists, it is created.; 232/// READ | Open an existing file for reading (default).; 233/// NET | Used by derived remote file access classes, not a user callable option.; 234/// WEB | Used by derived remote http access class, not a user callable option.; 235/// READ_WITHOUT_GLOBALREGISTRATION | Used by TTreeProcessorMT, not a user callable option.; 236///; 237/// If option = """" (default), READ is assumed.; 238/// The file can be specified as a URL of the form:; 239///; 240/// file:///user/rdm/bla.root or file:/user/rdm/bla.root; 241///; 242/// The file can also be a member",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
Performance,perform,performed,"; 292/// Note that the compression settings may be changed at any time.; 293/// The new compression settings will only apply to branches created; 294/// or attached after the setting is changed and other objects written; 295/// after the setting is changed.; 296/// In case the file does not exist or is not a valid ROOT file,; 297/// it is made a Zombie. One can detect this situation with a code like:; 298/// ~~~{.cpp}; 299/// TFile f(""file.root"");; 300/// if (f.IsZombie()) {; 301/// std::cout << ""Error opening file"" << std::endl;; 302/// exit(-1);; 303/// }; 304/// ~~~; 305/// If you open a file instead with TFile::Open(""file.root"") use rather; 306/// the following code as a nullptr is returned.; 307/// ~~~{.cpp}; 308/// TFile* f = TFile::Open(""file.root"");; 309/// if (!f) {; 310/// std::cout << ""Error opening file"" << std::endl;; 311/// exit(-1);; 312/// }; 313/// ~~~; 314/// When opening the file, the system checks the validity of this directory.; 315/// If something wrong is detected, an automatic Recovery is performed. In; 316/// this case, the file is scanned sequentially reading all logical blocks; 317/// and attempting to rebuild a correct directory (see TFile::Recover).; 318/// One can disable the automatic recovery procedure when reading one; 319/// or more files by setting the environment variable ""TFile.Recover: 0""; 320/// in the system.rootrc file.; 321///; 322/// A bit `TFile::kReproducible` can be enabled specifying; 323/// the `""reproducible""` url option when creating the file:; 324/// ~~~{.cpp}; 325/// TFile *f = TFile::Open(""name.root?reproducible"",""RECREATE"",""File title"");; 326/// ~~~; 327/// Unlike regular `TFile`s, the content of such file has reproducible binary; 328/// content when writing exactly same data. This achieved by writing pre-defined; 329/// values for creation and modification date of TKey/TDirectory objects and; 330/// null value for TUUID objects inside TFile. As drawback, TRef objects stored; 331/// in such file cannot be read co",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
Safety,detect,detect,"ight use more memory.; 283/// (For the currently supported algorithms, the maximum level is 9); 284/// If compress is negative it indicates the compression level is not set yet.; 285/// The enumeration ROOT::RCompressionSetting::EAlgorithm associates each; 286/// algorithm with a number. There is a utility function to help; 287/// to set the value of compress. For example,; 288/// ROOT::CompressionSettings(ROOT::kLZMA, 1); 289/// will build an integer which will set the compression to use; 290/// the LZMA algorithm and compression level 1. These are defined; 291/// in the header file <em>Compression.h</em>.; 292/// Note that the compression settings may be changed at any time.; 293/// The new compression settings will only apply to branches created; 294/// or attached after the setting is changed and other objects written; 295/// after the setting is changed.; 296/// In case the file does not exist or is not a valid ROOT file,; 297/// it is made a Zombie. One can detect this situation with a code like:; 298/// ~~~{.cpp}; 299/// TFile f(""file.root"");; 300/// if (f.IsZombie()) {; 301/// std::cout << ""Error opening file"" << std::endl;; 302/// exit(-1);; 303/// }; 304/// ~~~; 305/// If you open a file instead with TFile::Open(""file.root"") use rather; 306/// the following code as a nullptr is returned.; 307/// ~~~{.cpp}; 308/// TFile* f = TFile::Open(""file.root"");; 309/// if (!f) {; 310/// std::cout << ""Error opening file"" << std::endl;; 311/// exit(-1);; 312/// }; 313/// ~~~; 314/// When opening the file, the system checks the validity of this directory.; 315/// If something wrong is detected, an automatic Recovery is performed. In; 316/// this case, the file is scanned sequentially reading all logical blocks; 317/// and attempting to rebuild a correct directory (see TFile::Recover).; 318/// One can disable the automatic recovery procedure when reading one; 319/// or more files by setting the environment variable ""TFile.Recover: 0""; 320/// in the system.rootrc file.; 32",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
Security,access,access," : TDirectoryFile(), fCompress(ROOT::RCompressionSetting::EAlgorithm::kUseGlobal); 203{; 204 fCacheReadMap = new TMap();; 205 SetBit(kBinaryFile, kTRUE);; 206 ; 207 if (gDebug); 208 Info(""TFile"", ""default ctor"");; 209}; 210 ; 211////////////////////////////////////////////////////////////////////////////////; 212/// Opens or creates a local ROOT file.; 213///; 214/// \param[in] fname1 The name of the file; 215/// \param[in] option Specifies the mode in which the file is opened; 216/// \param[in] ftitle The title of the file; 217/// \param[in] compress Specifies the compression algorithm and level; 218///; 219/// It is recommended to specify fname1 as ""<file>.root"". The suffix "".root""; 220/// will be used by object browsers to automatically identify the file as; 221/// a ROOT file. If the constructor fails in any way IsZombie() will; 222/// return true. Use IsOpen() to check if the file is (still) open.; 223/// To open non-local files use the static TFile::Open() method, that; 224/// will take care of opening the files using the correct remote file; 225/// access plugin.; 226///; 227/// Option | Description; 228/// -------|------------; 229/// NEW or CREATE | Create a new file and open it for writing, if the file already exists the file is not opened.; 230/// RECREATE | Create a new file, if the file already exists it will be overwritten.; 231/// UPDATE | Open an existing file for writing. If no file exists, it is created.; 232/// READ | Open an existing file for reading (default).; 233/// NET | Used by derived remote file access classes, not a user callable option.; 234/// WEB | Used by derived remote http access class, not a user callable option.; 235/// READ_WITHOUT_GLOBALREGISTRATION | Used by TTreeProcessorMT, not a user callable option.; 236///; 237/// If option = """" (default), READ is assumed.; 238/// The file can be specified as a URL of the form:; 239///; 240/// file:///user/rdm/bla.root or file:/user/rdm/bla.root; 241///; 242/// The file can also be a member",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
Testability,log,logical,". ROOT: io/io/src/TFile.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TFile.cxx. Go to the documentation of this file. 1// @(#)root/io:$Id: 3a19890259ad6443ee313e090166614971ad4296 $; 2// Author: Rene Brun 28/11/94; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/**; 13\file TFile.cxx; 14\class TFile; 15\ingroup IO; 16\brief A ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-like logical structure, possibly including subdirectory hierarchies.; 17\sa \ref IO; 18\sa \ref rootio (or `io/doc/TFile` folder in your codebase); 19 ; 20<details>; 21<summary>ROOT file data format specification</summary>; 22 ; 23A ROOT file is composed of a header, followed by consecutive data records; 24(`TKey` instances) with a well defined format.; 25 ; 26The first data record starts at byte fBEGIN (currently set to kBEGIN).; 27Bytes 1->kBEGIN contain the file description, when fVersion >= 1000000; 28it is a large file (> 2 GB) and the offsets will be 8 bytes long and; 29fUnits will be set to 8:; 30 ; 31Byte Range | Record Name | Description; 32----------------|-------------|------------; 331->4 | ""root"" | Root file identifier; 345->8 | fVersion | File format version; 359->12 | fBEGIN | Pointer to first data record; 3613->16 [13->20] | fEND | Pointer to first free word at the EOF; 3717->20 [21->28] | fSeekFree | Pointer to FREE data record; 3821->24 [29->32] | fNbytesFree | Number of bytes in FREE data record; 3925->28 [33->36] | nfree | Number of free data records; 4029->32 [37->40] | fNbytesName | Number of bytes in TNamed at creation time; 4133->33 [41->41] | f",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
Usability,usab,usable,"pid,pidf);; 1999 pid->IncrementCount();; 2000 ; 2001 {; 2002 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2003 pidslist->Add(pid);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 204",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
Integrability,depend,dependency,". ROOT: io/io/inc/TFile.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Macros ; TFile.h File Reference. #include <atomic>; #include <string>; #include ""Compression.h""; #include ""TDirectoryFile.h""; #include ""TUrl.h""; #include ""ROOT/RConcurrentHashColl.hxx""; #include ""ROOT/TRWSpinLock.hxx""; #include <mutex>. Include dependency graph for TFile.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  TFile::InfoListRet;  Simple struct of the return value of GetStreamerInfoListImpl. More...;  ; class  TFile;  A ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-like logical structure, possibly including subdirectory hierarchies. More...;  ; class  TFileOpenHandle;  Class holding info about the file being opened. More...;  . Macros; #define gFile   (TFile::CurrentFile());  . Macro Definition Documentation. ◆ gFile. #define gFile   (TFile::CurrentFile()). Definition at line 347 of file TFile.h. ioioincTFile.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TFile_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h.html
Testability,log,logical,". ROOT: io/io/inc/TFile.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Macros ; TFile.h File Reference. #include <atomic>; #include <string>; #include ""Compression.h""; #include ""TDirectoryFile.h""; #include ""TUrl.h""; #include ""ROOT/RConcurrentHashColl.hxx""; #include ""ROOT/TRWSpinLock.hxx""; #include <mutex>. Include dependency graph for TFile.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  TFile::InfoListRet;  Simple struct of the return value of GetStreamerInfoListImpl. More...;  ; class  TFile;  A ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-like logical structure, possibly including subdirectory hierarchies. More...;  ; class  TFileOpenHandle;  Class holding info about the file being opened. More...;  . Macros; #define gFile   (TFile::CurrentFile());  . Macro Definition Documentation. ◆ gFile. #define gFile   (TFile::CurrentFile()). Definition at line 347 of file TFile.h. ioioincTFile.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TFile_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h.html
Availability,recover,recover,"Int_t Write(const char *name=nullptr, Int_t opt=0, Int_t bufsiz=0) overrideWrite memory objects to this file.Definition TFile.cxx:2436; TFile::fAsyncOpenStatusEAsyncOpenStatus fAsyncOpenStatus!Status of an asynchronous open requestDefinition TFile.h:109; TFile::fGlobalRegistrationbool fGlobalRegistration! if true, bypass use of global listsDefinition TFile.h:115; TFile::fSumBufferDouble_t fSumBufferSum of buffer sizes of objects written so far.Definition TFile.h:73; TFile::fIsArchiveBool_t fIsArchive!True if this is a pure archive fileDefinition TFile.h:102; TFile::GetListOfProcessIDsTObjArray * GetListOfProcessIDs() constDefinition TFile.h:236; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TFile::GetCompressionAlgorithmInt_t GetCompressionAlgorithm() constDefinition TFile.h:385; TFile::fgReadCallsstatic std::atomic< Int_t > fgReadCallsNumber of bytes read from all TFile objects.Definition TFile.h:133; TFile::Recovervirtual Int_t Recover()Attempt to recover file if not correctly closed.Definition TFile.cxx:2048; TFile::GetStreamerInfoListvirtual TList * GetStreamerInfoList() finalRead the list of TStreamerInfo objects written to this file.Definition TFile.cxx:1445; TFile::WriteHeadervirtual void WriteHeader()Write File Header.Definition TFile.cxx:2615; TFile::EStatusBitsEStatusBitsTFile status bits. BIT(13) is taken up by TObject.Definition TFile.h:183; TFile::kRecovered@ kRecoveredDefinition TFile.h:191; TFile::kReproducible@ kReproducibleDefinition TFile.h:197; TFile::kDevNull@ kDevNullDefinition TFile.h:193; TFile::kHasReferences@ kHasReferencesDefinition TFile.h:192; TFile::kRedirected@ kRedirectedDefinition TFile.h:196; TFile::k630forwardCompatibility@ k630forwardCompatibilityDefinition TFile.h:190; TFile::kWriteError@ kWriteErrorDefinition TFile.h:194; TFile::kBinaryFile@ kBinaryFileDefinition TFile.h:195; TFile::OpenFromCachestatic TFile * OpenFromCache(const char *name, Option_t *="""", const char *ftitle="""", Int_t ",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
Deployability,release,releases,"nt_t SysSync(Int_t fd);; 165 ; 166 // Interface for text-based TDirectory I/O; 167 virtual Long64_t DirCreateEntry(TDirectory*) { return 0; }; 168 virtual Int_t DirReadKeys(TDirectory*) { return 0; }; 169 virtual void DirWriteKeys(TDirectory*) {}; 170 virtual void DirWriteHeader(TDirectory*) {}; 171 ; 172private:; 173 TFile(const TFile &) = delete; //Files cannot be copied; 174 void operator=(const TFile &) = delete;; 175 ; 176 static void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch &watch);; 177 static TFile *OpenFromCache(const char *name, Option_t * = """",; 178 const char *ftitle = """", Int_t compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault,; 179 Int_t netopt = 0);; 180 ; 181public:; 182 /// TFile status bits. BIT(13) is taken up by TObject; 183 enum EStatusBits {; 184 // Produce files forward compatible with (unpatched) version older than; 185 // v6.30 by recording the internal bits kIsOnHeap and kNotDeleted; Older; 186 // releases were not explicitly setting those bits to the correct value; 187 // but instead used verbatim the value stored in the file.; 188 // Note that to avoid a circular dependency, this value is used; 189 // hard coded in TObject.cxx.; 190 k630forwardCompatibility = BIT(2),; 191 kRecovered = BIT(10),; 192 kHasReferences = BIT(11),; 193 kDevNull = BIT(12),; 194 kWriteError = BIT(14),; 195 kBinaryFile = BIT(15),; 196 kRedirected = BIT(16),; 197 kReproducible = BIT(17); 198 };; 199 enum ERelativeTo { kBeg = 0, kCur = 1, kEnd = 2 };; 200 enum { kStartBigFile = 2000000000 };; 201 /// File type; 202 enum EFileType { kDefault = 0, kLocal = 1, kNet = 2, kWeb = 3, kFile = 4, kMerge = 5 };; 203 ; 204 TFile();; 205 TFile(const char *fname, Option_t *option="""", const char *ftitle="""", Int_t compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);; 206 ~TFile() override;; 207 ; 208 void Close(Option_t *option="""") override; // *MENU*; 209 void Copy(TObject &) const override { MayNotUse(""Copy(TObject &)""); }; 210 ",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
Energy Efficiency,efficient,efficient,"ile::GetCompressionFactorFloat_t GetCompressionFactor()Return the file compression factor.Definition TFile.cxx:1202; TFile::SysWritevirtual Int_t SysWrite(Int_t fd, const void *buf, Int_t len)Interface to system write. All arguments like in POSIX write().Definition TFile.cxx:4514; TFile::GetFileReadCallsstatic Int_t GetFileReadCalls()Static function returning the total number of read calls from all files.Definition TFile.cxx:4591; TFile::GetCacheReadTFileCacheRead * GetCacheRead(const TObject *tree=nullptr) constReturn a pointer to the current read cache.Definition TFile.cxx:1262; TFile::GetOptionOption_t * GetOption() const overrideDefinition TFile.h:240; TFile::fgAsyncOpenRequestsstatic TList * fgAsyncOpenRequestsDefinition TFile.h:122; TFreeService class for TFile.Definition TFree.h:27; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TListA doubly linked list.Definition TList.h:38; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::MayNotUsevoid MayNotUse(const char *method) constUse this method to signal that a method (defined in a base class) may not be called in a derived clas...Definition TObject.cxx:1046; TProcessIDA TProcessID identifies a ROOT job in a unique way in time and space.Definition TProcessID.h:74; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TUrlThis class represents a WWW compatible URL.Definition TUrl.h:33; bool; double; int; unsigned int; nconst Int_t nDefinition legend1.C:16; ROOTtbb::task_",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
Integrability,interface,interface,".; Searching...; No Matches. TFile.h. Go to the documentation of this file. 1// @(#)root/io:$Id$; 2// Author: Rene Brun 28/11/94; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TFile; 13#define ROOT_TFile; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TFile //; 19// //; 20// ROOT file. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include <atomic>; 25#include <string>; 26 ; 27#include ""Compression.h""; 28#include ""TDirectoryFile.h""; 29#include ""TUrl.h""; 30#include ""ROOT/RConcurrentHashColl.hxx""; 31 ; 32// Not a part of TFile interface; provide a forward declaration instead of #include.; 33// #ifndef R__LESS_INCLUDES; 34// #include ""TMap.h""; 35// #endif; 36 ; 37#ifdef R__USE_IMT; 38#include ""ROOT/TRWSpinLock.hxx""; 39#include <mutex>; 40#endif; 41 ; 42class TMap;; 43class TFree;; 44class TArrayC;; 45class TArchiveFile;; 46class TFileOpenHandle;; 47class TFileCacheRead;; 48class TFileCacheWrite;; 49class TProcessID;; 50class TStopwatch;; 51class TFilePrefetch;; 52 ; 53class TFile : public TDirectoryFile {; 54 friend class TDirectoryFile;; 55 friend class TFilePrefetch;; 56// TODO: We need to make sure only one TBasket is being written at a time; 57// if we are writing multiple baskets in parallel.; 58#ifdef R__USE_IMT; 59 friend class TBasket;; 60#endif; 61 ; 62public:; 63 /// Asynchronous open request status; 64 enum EAsyncOpenStatus { kAOSNotAsync = -1, kAOSFailure = 0,; 65 kAOSInProgress = 1, kAOSSuccess = 2 };; 66 /// Open timeout constants; 67 enum EOpenTimeOut { kInstantTimeout = 0, kEternalTimeout = 999999999 };; 6",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
Performance,cache,cache,bjects written so far; 75 Long64_t fBytesWrite{0}; ///<Number of bytes written to this file; 76 Long64_t fBytesRead{0}; ///<Number of bytes read from this file; 77 Long64_t fBytesReadExtra{0}; ///<Number of extra bytes (overhead) read by the readahead buffer; 78 Long64_t fBEGIN{0}; ///<First used byte in file; 79 Long64_t fEND{0}; ///<Last used byte in file; 80 Long64_t fSeekFree{0}; ///<Location on disk of free segments structure; 81 Long64_t fSeekInfo{0}; ///<Location on disk of StreamerInfo record; 82 Int_t fD{-1}; ///<File descriptor; 83 Int_t fVersion{0}; ///<File format version; 84 Int_t fCompress{0}; ///<Compression level and algorithm; 85 Int_t fNbytesFree{0}; ///<Number of bytes for free segments structure; 86 Int_t fNbytesInfo{0}; ///<Number of bytes for StreamerInfo record; 87 Int_t fWritten{0}; ///<Number of objects written so far; 88 Int_t fNProcessIDs{0}; ///<Number of TProcessID written to this file; 89 Int_t fReadCalls{0}; ///<Number of read calls ( not counting the cache calls ); 90 TString fRealName; ///<Effective real file name (not original url); 91 TString fOption; ///<File options; 92 Char_t fUnits{0}; ///<Number of bytes for file pointers; 93 TList *fFree{nullptr}; ///<Free segments linked list table; 94 TArrayC *fClassIndex{nullptr}; ///<!Index of TStreamerInfo classes written to this file; 95 TObjArray *fProcessIDs{nullptr}; ///<!Array of pointers to TProcessIDs; 96 Long64_t fOffset{0}; ///<!Seek offset cache; 97 TArchiveFile *fArchive{nullptr}; ///<!Archive file from which we read this file; 98 TFileCacheRead *fCacheRead{nullptr}; ///<!Pointer to the read cache (if any); 99 TMap *fCacheReadMap{nullptr}; ///<!Pointer to the read cache (if any); 100 TFileCacheWrite *fCacheWrite{nullptr}; ///<!Pointer to the write cache (if any); 101 Long64_t fArchiveOffset{0}; ///<!Offset at which file starts in archive; 102 Bool_t fIsArchive{kFALSE}; ///<!True if this is a pure archive file; 103 Bool_t fNoAnchorInName{kFALSE}; ///<!True if we don't want to f,MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
Safety,timeout,timeout,"; 58#ifdef R__USE_IMT; 59 friend class TBasket;; 60#endif; 61 ; 62public:; 63 /// Asynchronous open request status; 64 enum EAsyncOpenStatus { kAOSNotAsync = -1, kAOSFailure = 0,; 65 kAOSInProgress = 1, kAOSSuccess = 2 };; 66 /// Open timeo",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
Security,hash,hashes,,MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
Testability,log,logical,"d@ kRecoveredDefinition TFile.h:191; TFile::kReproducible@ kReproducibleDefinition TFile.h:197; TFile::kDevNull@ kDevNullDefinition TFile.h:193; TFile::kHasReferences@ kHasReferencesDefinition TFile.h:192; TFile::kRedirected@ kRedirectedDefinition TFile.h:196; TFile::k630forwardCompatibility@ k630forwardCompatibilityDefinition TFile.h:190; TFile::kWriteError@ kWriteErrorDefinition TFile.h:194; TFile::kBinaryFile@ kBinaryFileDefinition TFile.h:195; TFile::OpenFromCachestatic TFile * OpenFromCache(const char *name, Option_t *="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Open a file for reading through the file cache.Definition TFile.cxx:3874; TFile::fNProcessIDsInt_t fNProcessIDsNumber of TProcessID written to this file.Definition TFile.h:88; TFile::fWrittenInt_t fWrittenNumber of objects written so far.Definition TFile.h:87; TFile::GetRecordHeaderInt_t GetRecordHeader(char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen)Read the logical record header starting at a certain postion.Definition TFile.cxx:1301; TFile::ReadBuffervirtual Bool_t ReadBuffer(char *buf, Int_t len)Read a buffer from the file.Definition TFile.cxx:1770; TFile::GetCompressionFactorFloat_t GetCompressionFactor()Return the file compression factor.Definition TFile.cxx:1202; TFile::SysWritevirtual Int_t SysWrite(Int_t fd, const void *buf, Int_t len)Interface to system write. All arguments like in POSIX write().Definition TFile.cxx:4514; TFile::GetFileReadCallsstatic Int_t GetFileReadCalls()Static function returning the total number of read calls from all files.Definition TFile.cxx:4591; TFile::GetCacheReadTFileCacheRead * GetCacheRead(const TObject *tree=nullptr) constReturn a pointer to the current read cache.Definition TFile.cxx:1262; TFile::GetOptionOption_t * GetOption() const overrideDefinition TFile.h:240; TFile::fgAsyncOpenRequestsstatic TList * fgAsyncOpenRequestsDefinition TFile.h:122; TFre",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
Availability,error,error,"////////////////////////////////////////////////////////////////////////; 91/// Assignment operator.; 92/// if needed copy the TFitResult object and delete previous one if existing; 93 ; 94TFitResultPtr & TFitResultPtr::operator=(const TFitResultPtr& rhs); 95{; 96 if ( &rhs == this) return *this; // self assignment; 97 fStatus = rhs.fStatus;; 98 fPointer = rhs.fPointer; ; 99 // if ( fPointer ) delete fPointer;; 100 // fPointer = 0;; 101 // if (rhs.fPointer != 0) fPointer = new TFitResult(*rhs);; 102 return *this;; 103}; 104 ; 105////////////////////////////////////////////////////////////////////////////////; 106/// Print the TFitResultPtr by printing its TFitResult.; 107 ; 108std::string cling::printValue(const TFitResultPtr* val) {; 109 if (TFitResult* fr = val->Get()); 110 return printValue(fr);; 111 return ""<nullptr TFitResult>"";; 112}; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TFitResultPtr.h; TFitResult.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TFitResultPtrProvides an indirection to the TFitResult class and with a semantics identical to a TFitResult pointe...Definition TFitResultPtr.h:32; TFitResultPtr::~TFitResultPtrvirtual ~TFitResultPtr()Destructor.Definition TFitResultPtr.cxx:55; TFitResultPtr::GetTFitResult * Get() constReturn contained pointer.Definition TFitResultPtr.cxx:86; TFitResultPtr::fPointerstd::shared_ptr< TFitResult > fPointer! Smart Pointer to TFitResult classDefinition TFitResultPtr.h:58; TFitResultPtr::fStatusint fStatusfit status codeDefinition TFitResultPtr.h:57; TFitResultPtr::operator*TFitResult & operator*() constImplement the de-reference operator to make the class acts as a pointer to a TFitResult assert in cas...Definition TFitResultPtr.cxx:63; TFitResultPtr::operator->TFitResult * operator->() constImplement the -> operator to make th",MatchSource.WIKI,doc/master/TFitResultPtr_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResultPtr_8cxx_source.html
Modifiability,inherit,inheritance,"///////////////////////////////////////////////////////; 106/// Print the TFitResultPtr by printing its TFitResult.; 107 ; 108std::string cling::printValue(const TFitResultPtr* val) {; 109 if (TFitResult* fr = val->Get()); 110 return printValue(fr);; 111 return ""<nullptr TFitResult>"";; 112}; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TFitResultPtr.h; TFitResult.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TFitResultPtrProvides an indirection to the TFitResult class and with a semantics identical to a TFitResult pointe...Definition TFitResultPtr.h:32; TFitResultPtr::~TFitResultPtrvirtual ~TFitResultPtr()Destructor.Definition TFitResultPtr.cxx:55; TFitResultPtr::GetTFitResult * Get() constReturn contained pointer.Definition TFitResultPtr.cxx:86; TFitResultPtr::fPointerstd::shared_ptr< TFitResult > fPointer! Smart Pointer to TFitResult classDefinition TFitResultPtr.h:58; TFitResultPtr::fStatusint fStatusfit status codeDefinition TFitResultPtr.h:57; TFitResultPtr::operator*TFitResult & operator*() constImplement the de-reference operator to make the class acts as a pointer to a TFitResult assert in cas...Definition TFitResultPtr.cxx:63; TFitResultPtr::operator->TFitResult * operator->() constImplement the -> operator to make the class acts as a pointer to a TFitResult.Definition TFitResultPtr.cxx:75; TFitResultPtr::operator=TFitResultPtr & operator=(const TFitResultPtr &rhs)Assignment operator.Definition TFitResultPtr.cxx:94; TFitResultPtr::TFitResultPtrTFitResultPtr(int status=-1)Definition TFitResultPtr.h:35; TFitResultExtends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O.Definition TFitResult.h:34. histhistsrcTFitResultPtr.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TFitResultPtr_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResultPtr_8cxx_source.html
Testability,assert,assert,",; 30 fPointer(p); 31{; 32 if (fPointer) fStatus = fPointer->Status();; 33}; 34 ; 35////////////////////////////////////////////////////////////////////////////////; 36/// Constructor from a TFitResult pointer; 37 ; 38TFitResultPtr::TFitResultPtr(TFitResult * p) :; 39 fStatus(-1),; 40 fPointer(std::shared_ptr<TFitResult>(p)); 41{; 42 if (fPointer) fStatus = fPointer->Status();; 43}; 44 ; 45TFitResultPtr::TFitResultPtr(const TFitResultPtr& rhs) :; 46 fStatus(rhs.fStatus), fPointer(rhs.fPointer); 47{; 48}; 49 ; 50////////////////////////////////////////////////////////////////////////////////; 51/// Destructor. Delete the contained TFitResult pointer if needed; 52/// if ( fPointer != 0); 53/// delete fPointer;; 54 ; 55TFitResultPtr::~TFitResultPtr(); 56{; 57}; 58 ; 59////////////////////////////////////////////////////////////////////////////////; 60/// Implement the de-reference operator to make the class acts as a pointer to a TFitResult; 61/// assert in case the class does not contain a pointer to TFitResult; 62 ; 63TFitResult& TFitResultPtr::operator*() const; 64{; 65 if (!fPointer) {; 66 Error(""TFitResultPtr"",""TFitResult is empty - use the fit option S"");; 67 }; 68 return *fPointer;; 69}; 70 ; 71////////////////////////////////////////////////////////////////////////////////; 72/// Implement the -> operator to make the class acts as a pointer to a TFitResult.; 73/// assert in case the class does not contain a pointer to TFitResult; 74 ; 75TFitResult* TFitResultPtr::operator->() const; 76{; 77 if (!fPointer) {; 78 Error(""TFitResultPtr"",""TFitResult is empty - use the fit option S"");; 79 }; 80 return fPointer.get();; 81}; 82 ; 83////////////////////////////////////////////////////////////////////////////////; 84/// Return contained pointer; 85 ; 86TFitResult * TFitResultPtr::Get() const {; 87 return fPointer.get();; 88}; 89 ; 90////////////////////////////////////////////////////////////////////////////////; 91/// Assignment operator.; 92/// if needed copy the TFitR",MatchSource.WIKI,doc/master/TFitResultPtr_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResultPtr_8cxx_source.html
Modifiability,inherit,inheritance,">() const;; 48 ; 49 TFitResult* Get() const;; 50 ; 51 TFitResultPtr& operator= (const TFitResultPtr& rhs);; 52 ; 53 virtual ~TFitResultPtr();; 54 ; 55private:; 56 ; 57 int fStatus; ///< fit status code; 58 std::shared_ptr<TFitResult> fPointer; ///<! Smart Pointer to TFitResult class; 59 ; 60 ClassDef(TFitResultPtr,2) //indirection to TFitResult; 61};; 62 ; 63namespace cling {; 64 std::string printValue(const TFitResultPtr* val);; 65}; 66#endif; Rtypes.h; ClassDef#define ClassDef(name, id)Definition Rtypes.h:342; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TFitResultPtrProvides an indirection to the TFitResult class and with a semantics identical to a TFitResult pointe...Definition TFitResultPtr.h:32; TFitResultPtr::~TFitResultPtrvirtual ~TFitResultPtr()Destructor.Definition TFitResultPtr.cxx:55; TFitResultPtr::GetTFitResult * Get() constReturn contained pointer.Definition TFitResultPtr.cxx:86; TFitResultPtr::fPointerstd::shared_ptr< TFitResult > fPointer! Smart Pointer to TFitResult classDefinition TFitResultPtr.h:58; TFitResultPtr::fStatusint fStatusfit status codeDefinition TFitResultPtr.h:57; TFitResultPtr::operator*TFitResult & operator*() constImplement the de-reference operator to make the class acts as a pointer to a TFitResult assert in cas...Definition TFitResultPtr.cxx:63; TFitResultPtr::operator->TFitResult * operator->() constImplement the -> operator to make the class acts as a pointer to a TFitResult.Definition TFitResultPtr.cxx:75; TFitResultPtr::operator=TFitResultPtr & operator=(const TFitResultPtr &rhs)Assignment operator.Definition TFitResultPtr.cxx:94; TFitResultPtr::TFitResultPtrTFitResultPtr(int status=-1)Definition TFitResultPtr.h:35; TFitResultExtends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O.Definition TFitResult.h:34; int. histhistincTFitResultPtr.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TFitResultPtr_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResultPtr_8h_source.html
Testability,assert,assert,">() const;; 48 ; 49 TFitResult* Get() const;; 50 ; 51 TFitResultPtr& operator= (const TFitResultPtr& rhs);; 52 ; 53 virtual ~TFitResultPtr();; 54 ; 55private:; 56 ; 57 int fStatus; ///< fit status code; 58 std::shared_ptr<TFitResult> fPointer; ///<! Smart Pointer to TFitResult class; 59 ; 60 ClassDef(TFitResultPtr,2) //indirection to TFitResult; 61};; 62 ; 63namespace cling {; 64 std::string printValue(const TFitResultPtr* val);; 65}; 66#endif; Rtypes.h; ClassDef#define ClassDef(name, id)Definition Rtypes.h:342; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TFitResultPtrProvides an indirection to the TFitResult class and with a semantics identical to a TFitResult pointe...Definition TFitResultPtr.h:32; TFitResultPtr::~TFitResultPtrvirtual ~TFitResultPtr()Destructor.Definition TFitResultPtr.cxx:55; TFitResultPtr::GetTFitResult * Get() constReturn contained pointer.Definition TFitResultPtr.cxx:86; TFitResultPtr::fPointerstd::shared_ptr< TFitResult > fPointer! Smart Pointer to TFitResult classDefinition TFitResultPtr.h:58; TFitResultPtr::fStatusint fStatusfit status codeDefinition TFitResultPtr.h:57; TFitResultPtr::operator*TFitResult & operator*() constImplement the de-reference operator to make the class acts as a pointer to a TFitResult assert in cas...Definition TFitResultPtr.cxx:63; TFitResultPtr::operator->TFitResult * operator->() constImplement the -> operator to make the class acts as a pointer to a TFitResult.Definition TFitResultPtr.cxx:75; TFitResultPtr::operator=TFitResultPtr & operator=(const TFitResultPtr &rhs)Assignment operator.Definition TFitResultPtr.cxx:94; TFitResultPtr::TFitResultPtrTFitResultPtr(int status=-1)Definition TFitResultPtr.h:35; TFitResultExtends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O.Definition TFitResult.h:34; int. histhistincTFitResultPtr.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TFitResultPtr_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResultPtr_8h_source.html
Availability,error,errors," 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TFitResult.h""; 13#include ""Math/WrappedMultiTF1.h""; 14#include ""TGraph.h""; 15 ; 16 ; 17#include <iostream>; 18 ; 19/** \class TFitResult; 20 \ingroup Hist; 21Extends the ROOT::Fit::Result class with a TNamed inheritance; 22providing easy possibility for I/O; 23*/; 24 ; 25ClassImp(TFitResult);; 26 ; 27////////////////////////////////////////////////////////////////////////////////; 28/// Constructor from a ROOT::Fit::FitResult; 29/// copy the contained TF1 pointer function if it is; 30 ; 31TFitResult::TFitResult(const ROOT::Fit::FitResult& f) :; 32 TNamed(""TFitResult"",""TFitResult""),; 33 ROOT::Fit::FitResult(f); 34{; 35 ROOT::Math::WrappedMultiTF1 * wfunc = dynamic_cast<ROOT::Math::WrappedMultiTF1 *>(ModelFunction().get() );; 36 if (wfunc) wfunc->SetAndCopyFunction();; 37}; 38 ; 39 ; 40////////////////////////////////////////////////////////////////////////////////; 41/// Print result of the fit, by default chi2, parameter values and errors.; 42/// if option ""V"" is given print also error matrix and correlation; 43 ; 44void TFitResult::Print(Option_t *option) const; 45{; 46 TString opt(option);; 47 opt.ToUpper();; 48 bool doCovMat = opt.Contains(""V"");; 49 ROOT::Fit::FitResult::Print( std::cout, doCovMat);; 50}; 51 ; 52////////////////////////////////////////////////////////////////////////////////; 53/// Return the covariance matrix from fit; 54///; 55/// The matrix is a symmetric matrix with a size N equal to; 56/// the total number of parameters considered in the fit including the fixed ones; 57/// The matrix row and columns corresponding to the fixed parameters will contain only zero's; 58 ; 59TMatrixDSym TFitResult::GetCovarianceMatrix() const; 60{; 61 if (CovMatrixStatus() == 0) {; 62 Warning(""GetCovarianceMatrix"",""covariance matrix is not available"");; 63 return TMatrixDSym();; 64 }; 65 TMatrixDSym mat(NP",MatchSource.WIKI,doc/master/TFitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8cxx_source.html
Integrability,interface,interface,"rint(std::ostream &os, bool covmat=false) constprint the result and optionally covariance matrix and correlationsDefinition FitResult.cxx:389; ROOT::Fit::FitResult::ModelFunctionstd::shared_ptr< IModelFunction > ModelFunction()Return pointer non const pointer to model (fit) function with fitted parameter values.Definition FitResult.h:337; ROOT::Fit::FitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel=0.683)create contour of two parameters around the minimum pass as option confidence level: default is a val...Definition FitResult.cxx:660; ROOT::Fit::FitResult::NParunsigned int NPar() consttotal number of parameters (abbreviation)Definition FitResult.h:122; ROOT::Fit::FitResult::CovMatrixStatusint CovMatrixStatus() constcovariance matrix status code using Minuit convention : =0 not calculated, =1 approximated,...Definition FitResult.h:133; ROOT::Math::WrappedMultiTF1TemplClass to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions...Definition WrappedMultiTF1.h:48; ROOT::Math::WrappedMultiTF1Templ::SetAndCopyFunctionvoid SetAndCopyFunction(const TF1 *f=nullptr)method to set a new function pointer and copy it inside.Definition WrappedMultiTF1.h:399; TFitResultExtends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O.Definition TFitResult.h:34; TFitResult::TFitResultTFitResult(int status=0)Definition TFitResult.h:39; TFitResult::GetCorrelationMatrixTMatrixDSym GetCorrelationMatrix() constReturn the correlation matrix from fit.Definition TFitResult.cxx:77; TFitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, TGraph *gr, double confLevel=0.683)Create a 2D contour around the minimum for the parameter ipar and jpar if a minimum does not exist or...Definition TFitResult.cxx:119; TFitResult::GetCovarianceMatrixTMatrixDSym GetCovarianceMatrix() constReturn the covariance matrix from fit.Definition",MatchSource.WIKI,doc/master/TFitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8cxx_source.html
Modifiability,inherit,inheritance," File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TFitResult.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: David Gonzalez Maline 12/11/09; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TFitResult.h""; 13#include ""Math/WrappedMultiTF1.h""; 14#include ""TGraph.h""; 15 ; 16 ; 17#include <iostream>; 18 ; 19/** \class TFitResult; 20 \ingroup Hist; 21Extends the ROOT::Fit::Result class with a TNamed inheritance; 22providing easy possibility for I/O; 23*/; 24 ; 25ClassImp(TFitResult);; 26 ; 27////////////////////////////////////////////////////////////////////////////////; 28/// Constructor from a ROOT::Fit::FitResult; 29/// copy the contained TF1 pointer function if it is; 30 ; 31TFitResult::TFitResult(const ROOT::Fit::FitResult& f) :; 32 TNamed(""TFitResult"",""TFitResult""),; 33 ROOT::Fit::FitResult(f); 34{; 35 ROOT::Math::WrappedMultiTF1 * wfunc = dynamic_cast<ROOT::Math::WrappedMultiTF1 *>(ModelFunction().get() );; 36 if (wfunc) wfunc->SetAndCopyFunction();; 37}; 38 ; 39 ; 40////////////////////////////////////////////////////////////////////////////////; 41/// Print result of the fit, by default chi2, parameter values and errors.; 42/// if option ""V"" is given print also error matrix and correlation; 43 ; 44void TFitResult::Print(Option_t *option) const; 45{; 46 TString opt(option);; 47 opt.ToUpper();; 48 bool doCovMat = opt.Contains(""V"");; 49 ROOT::Fit::FitResult::Print( std::cout, doCovMat);; 50}; 51 ; 52////////////////////////////////////////////////////////////////////////////////; 53/// Return the covariance matrix from fit; 54///; 55/// The matrix is a symmetr",MatchSource.WIKI,doc/master/TFitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8cxx_source.html
Integrability,depend,dependency,". ROOT: hist/hist/inc/TFitResult.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TFitResult.h File Reference. #include ""TNamed.h""; #include ""Fit/FitResult.h""; #include ""TMatrixDSym.h""; #include <string>. Include dependency graph for TFitResult.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TFitResult;  Extends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O. More...;  . histhistincTFitResult.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TFitResult_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8h.html
Modifiability,inherit,inheritance,". ROOT: hist/hist/inc/TFitResult.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TFitResult.h File Reference. #include ""TNamed.h""; #include ""Fit/FitResult.h""; #include ""TMatrixDSym.h""; #include <string>. Include dependency graph for TFitResult.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TFitResult;  Extends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O. More...;  . histhistincTFitResult.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TFitResult_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8h.html
Availability,error,error,"ouble confLevel = 0.683);; 70 ; 71 using TObject::Error;; 72 ; 73 // need to re-implement to solve conflict with TObject::Error; 74 double Error(unsigned int i) const {; 75 return ParError(i);; 76 }; 77 ; 78private:; 79 ClassDefOverride(TFitResult, 0); // Class holding the result of the fit; 80};; 81 ; 82namespace cling {; 83 std::string printValue(const TFitResult* val);; 84}; 85#endif; FitResult.h; f#define f(i)Definition RSha256.hxx:104; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TMatrixDSym.h; TNamed.h; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitResult::ParErrordouble ParError(unsigned int i) constparameter error by indexDefinition FitResult.h:183; ROOT::Fit::FitResult::Scanbool Scan(unsigned int ipar, unsigned int &npoints, double *pntsx, double *pntsy, double xmin=0, double xmax=0)scan likelihood value of parameter and fill the given graph.Definition FitResult.cxx:639; ROOT::Fit::FitResult::FitResultFitResult()Default constructor for an empty (non valid) fit result.Definition FitResult.cxx:45; ROOT::Fit::FitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel=0.683)create contour of two parameters around the minimum pass as option confidence level: default is a val...Definition FitResult.cxx:660; ROOT::Fit::FitResult::fStatusint fStatusminimizer status codeDefinition FitResult.h:348; TFitResultExtends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O.Definition TFitResult.h:34; TFitResult::~TFitResult~TFitResult() overrideDefinition TFitResult",MatchSource.WIKI,doc/master/TFitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8h_source.html
Integrability,message,message,"e ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O.Definition TFitResult.h:34; TFitResult::~TFitResult~TFitResult() overrideDefinition TFitResult.h:53; TFitResult::TFitResultTFitResult(int status=0)Definition TFitResult.h:39; TFitResult::Errordouble Error(unsigned int i) constDefinition TFitResult.h:74; TFitResult::GetCorrelationMatrixTMatrixDSym GetCorrelationMatrix() constReturn the correlation matrix from fit.Definition TFitResult.cxx:77; TFitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, TGraph *gr, double confLevel=0.683)Create a 2D contour around the minimum for the parameter ipar and jpar if a minimum does not exist or...Definition TFitResult.cxx:119; TFitResult::GetCovarianceMatrixTMatrixDSym GetCovarianceMatrix() constReturn the covariance matrix from fit.Definition TFitResult.cxx:59; TFitResult::Printvoid Print(Option_t *option="""") const overridePrint result of the fit, by default chi2, parameter values and errors.Definition TFitResult.cxx:44; TFitResult::TFitResultTFitResult(const char *name, const char *title)Definition TFitResult.h:45; TFitResult::Scanbool Scan(unsigned int ipar, TGraph *gr, double xmin=0, double xmax=0)Scan parameter ipar between value of xmin and xmax A graph must be given which will be on return fill...Definition TFitResult.cxx:93; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TMatrixTSym< Double_t >; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; grTGraphErrors * grDefinition legend1.C:25; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. histhistincTFitResult.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TFitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8h_source.html
Modifiability,inherit,inheritance,"of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitResult::ParErrordouble ParError(unsigned int i) constparameter error by indexDefinition FitResult.h:183; ROOT::Fit::FitResult::Scanbool Scan(unsigned int ipar, unsigned int &npoints, double *pntsx, double *pntsy, double xmin=0, double xmax=0)scan likelihood value of parameter and fill the given graph.Definition FitResult.cxx:639; ROOT::Fit::FitResult::FitResultFitResult()Default constructor for an empty (non valid) fit result.Definition FitResult.cxx:45; ROOT::Fit::FitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel=0.683)create contour of two parameters around the minimum pass as option confidence level: default is a val...Definition FitResult.cxx:660; ROOT::Fit::FitResult::fStatusint fStatusminimizer status codeDefinition FitResult.h:348; TFitResultExtends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O.Definition TFitResult.h:34; TFitResult::~TFitResult~TFitResult() overrideDefinition TFitResult.h:53; TFitResult::TFitResultTFitResult(int status=0)Definition TFitResult.h:39; TFitResult::Errordouble Error(unsigned int i) constDefinition TFitResult.h:74; TFitResult::GetCorrelationMatrixTMatrixDSym GetCorrelationMatrix() constReturn the correlation matrix from fit.Definition TFitResult.cxx:77; TFitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, TGraph *gr, double confLevel=0.683)Create a 2D contour around the minimum for the parameter ipar and jpar if a minimum does not exist or...Definition TFitResult.cxx:119; TFitResult::GetCovarianceMatrixTMatrixDSym GetCovarianceMatrix() constReturn the covariance matrix from fit.Definition TFitResult.cxx:59; TFitResult::Printvoid Print(Option_t *option="""") const overridePrint result of the fit, by default chi2, parameter values and errors.Definition TFitResult.cxx:44; TFitRes",MatchSource.WIKI,doc/master/TFitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8h_source.html
Availability,avail,available,"; 10 *************************************************************************/; 11 ; 12#include ""TROOT.h""; 13#include ""TBuffer.h""; 14#include ""TMethod.h""; 15#include ""TF1.h""; 16#include ""TMethodCall.h""; 17#include <TBenchmark.h>; 18#include ""TError.h""; 19#include ""TInterpreter.h""; 20#include ""TInterpreterValue.h""; 21#include ""TFormula.h""; 22#include ""TRegexp.h""; 23 ; 24#include ""ROOT/StringUtils.hxx""; 25 ; 26#include <array>; 27#include <iostream>; 28#include <memory>; 29#include <unordered_map>; 30#include <functional>; 31#include <set>; 32#include <sstream>; 33 ; 34using std::map, std::pair, std::make_pair, std::list, std::max, std::string;; 35 ; 36#ifdef WIN32; 37#pragma optimize("""",off); 38#endif; 39#include ""v5/TFormula.h""; 40 ; 41ClassImp(TFormula);; 42 ; 43/** \class TFormula TFormula.h ""inc/TFormula.h""; 44 \ingroup Hist; 45 The Formula class; 46 ; 47 This is a new version of the TFormula class based on Cling.; 48 This class is not 100% backward compatible with the old TFormula class, which is still available in ROOT as; 49 `ROOT::v5::TFormula`. Some of the TFormula member functions available in version 5, such as; 50 `Analyze` and `AnalyzeFunction` are not available in the new TFormula.; 51 On the other hand formula expressions which were valid in version 5 are still valid in TFormula version 6; 52 ; 53 This class has been implemented during Google Summer of Code 2013 by Maciej Zimnoch.; 54 ; 55 ### Example of valid expressions:; 56 ; 57 - `sin(x)/x`; 58 - `[0]*sin(x) + [1]*exp(-[2]*x)`; 59 - `x + y**2`; 60 - `x^2 + y^2`; 61 - `[0]*pow([1],4)`; 62 - `2*pi*sqrt(x/y)`; 63 - `gaus(0)*expo(3) + ypol3(5)*x`; 64 - `gausn(0)*expo(3) + ypol3(5)*x`; 65 - `gaus(x, [0..2]) + expo(y, [3..4])`; 66 ; 67 In the last examples above:; 68 ; 69 - `gaus(0)` is a substitute for `[0]*exp(-0.5*((x-[1])/[2])**2)`; 70 and (0) means start numbering parameters at 0; 71 - `gausn(0)` is a substitute for `[0]*exp(-0.5*((x-[1])/[2])**2)/(sqrt(2*pi)*[2]))`; 72 and (0) means start numberin",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
Deployability,update,update,"formula.Index(')', funPos) - openingParenthesisPos - 1)); 1252 .Atoi();; 1253 }; 1254 }; 1255 // std::cout << ""openingParenthesisPos "" << openingParenthesisPos << "" counter is "" << counter << std::endl;; 1256 ; 1257 TString body = (isNormalized ? it->second.second : it->second.first);; 1258 if (isNormalized && body == """") {; 1259 Error(""PreprocessFormula"", ""%d dimension function %s has no normalized form."", it->first.second,; 1260 funName.Data());; 1261 break;; 1262 }; 1263 for (int i = 0; i < body.Length(); ++i) {; 1264 if (body[i] == '{') {; 1265 // replace {Vn} with variable names; 1266 i += 2; // skip '{' and 'V'; 1267 Int_t num = TString(body(i, body.Index('}', i) - i)).Atoi();; 1268 TString variable = variables[num];; 1269 TString pattern = TString::Format(""{V%d}"", num);; 1270 i -= 2; // restore original position; 1271 body.Replace(i, pattern.Length(), variable, variable.Length());; 1272 i += variable.Length() - 1; // update i to reflect change in body string; 1273 } else if (body[i] == '[') {; 1274 // update parameter counters in case of many functions (e.g. gaus(0)+gaus(3) ); 1275 Int_t tmp = i;; 1276 while (tmp < body.Length() && body[tmp] != ']') {; 1277 tmp++;; 1278 }; 1279 Int_t num = TString(body(i + 1, tmp - 1 - i)).Atoi();; 1280 num += counter;; 1281 TString replacement = TString::Format(""%d"", num);; 1282 ; 1283 body.Replace(i + 1, tmp - 1 - i, replacement, replacement.Length());; 1284 i += replacement.Length() + 1;; 1285 }; 1286 }; 1287 TString pattern;; 1288 if (defaultCounter && defaultVariables) {; 1289 pattern = TString::Format(""%s%s"", funName.Data(), (isNormalized ? ""n"" : """"));; 1290 }; 1291 if (!defaultCounter && defaultVariables) {; 1292 pattern = TString::Format(""%s%s(%d)"", funName.Data(), (isNormalized ? ""n"" : """"), counter);; 1293 }; 1294 if (defaultCounter && !defaultVariables) {; 1295 pattern = TString::Format(""%s%s[%s]"", funName.Data(), (isNormalized ? ""n"" : """"), varList.Data());; 1296 }; 1297 if (!defaultCounter && !defaultVariables) {; ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
Integrability,rout,routine," the operator ++.Definition TFormula.cxx:1735; TFormula::fClingNameTString fClingName! Unique name passed to Cling to define the function ( double clingName(double*x, double*p) )Definition TFormula.h:101; TFormula::GetVarNameTString GetVarName(Int_t ivar) constReturns variable name given its position in the array.Definition TFormula.cxx:2712; TFormula::SetVariablevoid SetVariable(const TString &name, Double_t value)Sets variable value.Definition TFormula.cxx:2728; TFormula::HessianParvoid HessianPar(const Double_t *x, TFormula::CladStorage &result)Compute the gradient employing automatic differentiation.Definition TFormula.cxx:3286; TFormula::GetParNumberInt_t GetParNumber(const char *name) constReturn parameter index given a name (return -1 for not existing parameters) non need to print an erro...Definition TFormula.cxx:2821; TFormula::DoSetParametersvoid DoSetParameters(const Double_t *p, Int_t size)Definition TFormula.cxx:2949; TFormula::GenerateHessianParbool GenerateHessianPar()Generate hessian computation routine with respect to the parameters.Definition TFormula.cxx:3256; TFormula::GetGradientFormulaTString GetGradientFormula() constDefinition TFormula.cxx:3594; TFormula::HandleParametrizedFunctionsvoid HandleParametrizedFunctions(TString &formula)Handling parametrized functions Function can be normalized, and have different variable then x.Definition TFormula.cxx:1103; TFormula::~TFormula~TFormula() overrideDefinition TFormula.cxx:465; TFormula::CallFuncSignatureTInterpreter::CallFuncIFacePtr_t::Generic_t CallFuncSignatureDefinition TFormula.h:104; TFormula::GetParametersDouble_t * GetParameters() constDefinition TFormula.cxx:2873; TFormula::SetParNamevoid SetParName(Int_t ipar, const char *name)Definition TFormula.cxx:2990; TFormula::SetNamevoid SetName(const char *name) overrideSet the name of the formula.Definition TFormula.cxx:2640; TFormula::GetHessianFuncNamestd::string GetHessianFuncName() constDefinition TFormula.h:131; TFormula::fGradGenerationInputs",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
Modifiability,variab,variable," means start numbering parameters at 0; 73 - `expo(3)` is a substitute for `exp([3]+[4]*x)`; 74 - `pol3(5)` is a substitute for `par[5]+par[6]*x+par[7]*x**2+par[8]*x**3`; 75 (`PolN` stands for Polynomial of degree N); 76 - `gaus(x, [0..2])` is a more explicit way of writing `gaus(0)`; 77 - `expo(y, [3..4])` is a substitute for `exp([3]+[4]*y)`; 78 ; 79 See below the [full list of predefined functions](\ref FormulaFuncs) which can be used as shortcuts in; 80 TFormula.; 81 ; 82 `TMath` functions can be part of the expression, eg:; 83 ; 84 - `TMath::Landau(x)*sin(x)`; 85 - `TMath::Erf(x)`; 86 ; 87 Formula may contain constants, eg:; 88 ; 89 - `sqrt2`; 90 - `e`; 91 - `pi`; 92 - `ln10`; 93 - `infinity`; 94 ; 95 and more.; 96 ; 97 Formulas may also contain other user-defined ROOT functions defined with a; 98 TFormula, eg, where `f1` is defined on one x-dimension and 2 parameters:; 99 ; 100 - `f1(x, [omega], [phi])`; 101 - `f1([0..1])`; 102 - `f1([1], [0])`; 103 - `f1(y)`; 104 ; 105 To replace only parameter names, the dimension variable can be dropped.; 106 Alternatively, to change only the dimension variable, the parameters can be; 107 dropped. Note that if a parameter is dropped or keeps its old name, its old; 108 value will be copied to the new function. The syntax used in the examples; 109 above also applies to the predefined parametrized functions like `gaus` and; 110 `expo`.; 111 ; 112 Comparisons operators are also supported `(&amp;&amp;, ||, ==, &lt;=, &gt;=, !)`; 113 ; 114 Examples:; 115 ; 116 `sin(x*(x&lt;0.5 || x&gt;1))`; 117 ; 118 If the result of a comparison is TRUE, the result is 1, otherwise 0.; 119 ; 120 Already predefined names can be given. For example, if the formula; 121 ; 122 `TFormula old(""old"",sin(x*(x&lt;0.5 || x&gt;1)))`; 123 ; 124 one can assign a name to the formula. By default the name of the object = title = formula itself.; 125 ; 126 `TFormula new(""new"",""x*old"")`; 127 ; 128 is equivalent to:; 129 ; 130 `TFormula new(""new"",""x*sin(x*(x&lt;0.5 ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
Performance,optimiz,optimize,"ching...; No Matches. TFormula.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Maciej Zimnoch 30/09/2013; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TROOT.h""; 13#include ""TBuffer.h""; 14#include ""TMethod.h""; 15#include ""TF1.h""; 16#include ""TMethodCall.h""; 17#include <TBenchmark.h>; 18#include ""TError.h""; 19#include ""TInterpreter.h""; 20#include ""TInterpreterValue.h""; 21#include ""TFormula.h""; 22#include ""TRegexp.h""; 23 ; 24#include ""ROOT/StringUtils.hxx""; 25 ; 26#include <array>; 27#include <iostream>; 28#include <memory>; 29#include <unordered_map>; 30#include <functional>; 31#include <set>; 32#include <sstream>; 33 ; 34using std::map, std::pair, std::make_pair, std::list, std::max, std::string;; 35 ; 36#ifdef WIN32; 37#pragma optimize("""",off); 38#endif; 39#include ""v5/TFormula.h""; 40 ; 41ClassImp(TFormula);; 42 ; 43/** \class TFormula TFormula.h ""inc/TFormula.h""; 44 \ingroup Hist; 45 The Formula class; 46 ; 47 This is a new version of the TFormula class based on Cling.; 48 This class is not 100% backward compatible with the old TFormula class, which is still available in ROOT as; 49 `ROOT::v5::TFormula`. Some of the TFormula member functions available in version 5, such as; 50 `Analyze` and `AnalyzeFunction` are not available in the new TFormula.; 51 On the other hand formula expressions which were valid in version 5 are still valid in TFormula version 6; 52 ; 53 This class has been implemented during Google Summer of Code 2013 by Maciej Zimnoch.; 54 ; 55 ### Example of valid expressions:; 56 ; 57 - `sin(x)/x`; 58 - `[0]*sin(x) + [1]*exp(-[2]*x)`; 59 - `x + y**2`; 60 - `x^2 + y^2`; 61 - `[0]*p",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
Safety,avoid,avoid,"y in the map; 610 {; 611 R__LOCKGUARD(gROOTMutex);; 612 ; 613 auto funcit = gClingFunctions.find(lambdaExpression);; 614 if (funcit != gClingFunctions.end() ) {; 615 fLambdaPtr = funcit->second;; 616 fClingInitialized = true;; 617 return true;; 618 }; 619 }; 620 ; 621 // to be sure the interpreter is initialized; 622 ROOT::GetROOT();; 623 R__ASSERT(gInterpreter);; 624 ; 625 // set the cling name using hash of the static formulae map; 626 auto hasher = gClingFunctions.hash_function();; 627 TString lambdaName = TString::Format(""lambda__id%zu"", hasher(lambdaExpression) );; 628 ; 629 //lambdaExpression = TString::Format(""[&](double * x, double *){ return %s ;}"",formula);; 630 //TString lambdaName = TString::Format(""mylambda_%s"",GetName() );; 631 TString lineExpr = TString::Format(""std::function<double(double*,double*)> %s = %s ;"",lambdaName.Data(), lambdaExpression.c_str() );; 632 gInterpreter->ProcessLine(lineExpr);; 633 fLambdaPtr = (void*) gInterpreter->ProcessLine(TString(lambdaName)+TString("";"")); // add ; to avoid printing; 634 if (fLambdaPtr != nullptr) {; 635 R__LOCKGUARD(gROOTMutex);; 636 gClingFunctions.insert ( std::make_pair ( lambdaExpression, fLambdaPtr) );; 637 fClingInitialized = true;; 638 return true;; 639 }; 640 fClingInitialized = false;; 641 return false;; 642}; 643 ; 644////////////////////////////////////////////////////////////////////////////////; 645/// Compile the given expression with Cling; 646/// backward compatibility method to be used in combination with the empty constructor; 647/// if no expression is given , the current stored formula (retrieved with GetExpFormula()) or the title is used.; 648/// return 0 if the formula compilation is successful; 649 ; 650Int_t TFormula::Compile(const char *expression); 651{; 652 TString formula = expression;; 653 if (formula.IsNull() ) {; 654 formula = fFormula;; 655 if (formula.IsNull() ) formula = GetTitle();; 656 }; 657 ; 658 if (formula.IsNull() ) return -1;; 659 ; 660 // do not re-process if it wa",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
Security,access,accessed,"o applies to the predefined parametrized functions like `gaus` and; 110 `expo`.; 111 ; 112 Comparisons operators are also supported `(&amp;&amp;, ||, ==, &lt;=, &gt;=, !)`; 113 ; 114 Examples:; 115 ; 116 `sin(x*(x&lt;0.5 || x&gt;1))`; 117 ; 118 If the result of a comparison is TRUE, the result is 1, otherwise 0.; 119 ; 120 Already predefined names can be given. For example, if the formula; 121 ; 122 `TFormula old(""old"",sin(x*(x&lt;0.5 || x&gt;1)))`; 123 ; 124 one can assign a name to the formula. By default the name of the object = title = formula itself.; 125 ; 126 `TFormula new(""new"",""x*old"")`; 127 ; 128 is equivalent to:; 129 ; 130 `TFormula new(""new"",""x*sin(x*(x&lt;0.5 || x&gt;1))"")`; 131 ; 132 The class supports unlimited number of variables and parameters.; 133 By default the names which can be used for the variables are `x,y,z,t` or; 134 `x[0],x[1],x[2],x[3],....x[N]` for N-dimensional formulas.; 135 ; 136 This class is not anymore the base class for the function classes `TF1`, but it has now; 137 a data member of TF1 which can be accessed via `TF1::GetFormula`.; 138 ; 139 TFormula supports gradient and hessian calculations through clad.; 140 To calculate the gradient one needs to first declare a `CladStorage` of the; 141 same size as the number of parameters and then pass the variables and the; 142 created `CladStorage`:; 143 ; 144 ```; 145 TFormula f(""f"", ""x*[0] - y*[1]"");; 146 Double_t p[] = {40, 30};; 147 Double_t x[] = {1, 2};; 148 f.SetParameters(p);; 149 TFormula::CladStorage grad(2);; 150 f.GradientPar(x, grad);; 151 ```; 152 ; 153 The process is similar for hessians, except that the size of the created; 154 CladStorage should be the square of the number of parameters because; 155 `HessianPar` returns a flattened matrix:; 156 ; 157 ```; 158 TFormula::CladStorage hess(4);; 159 f.HessianPar(x, hess);; 160 ```; 161 ; 162 \anchor FormulaFuncs; 163 ### List of predefined functions; 164 ; 165 The list of available predefined functions which can be used as s",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
Testability,assert,assert,"510 TFormula *old = nullptr;; 511 R__LOCKGUARD(gROOTMutex);; 512 old = dynamic_cast<TFormula *>(gROOT->GetListOfFunctions()->FindObject(name));; 513 if (old); 514 gROOT->GetListOfFunctions()->Remove(old);; 515 if (IsReservedName(name)); 516 Error(""TFormula"", ""The name %s is reserved as a TFormula variable name.\n"", name);; 517 else; 518 gROOT->GetListOfFunctions()->Add(this);; 519 }; 520 SetBit(kNotGlobal,!addToGlobList);; 521 }; 522 }; 523}; 524 ; 525////////////////////////////////////////////////////////////////////////////////; 526/// Constructor from a full compile-able C++ expression; 527 ; 528TFormula::TFormula(const char *name, const char *formula, int ndim, int npar, bool addToGlobList) :; 529 TNamed(name,formula),; 530 fClingInput(formula),fFormula(formula); 531{; 532 fReadyToExecute = false;; 533 fClingInitialized = false;; 534 fNpar = 0;; 535 fNumber = 0;; 536 fLambdaPtr = nullptr;; 537 fFuncPtr = nullptr;; 538 fGradFuncPtr = nullptr;; 539 fHessFuncPtr = nullptr;; 540 ; 541 ; 542 fNdim = ndim;; 543 for (int i = 0; i < npar; ++i) {; 544 DoAddParameter(TString::Format(""p%d"",i), 0, false);; 545 }; 546 fAllParametersSetted = true;; 547 assert (fNpar == npar);; 548 ; 549 bool ret = InitLambdaExpression(formula);; 550 ; 551 if (ret) {; 552 ; 553 SetBit(TFormula::kLambda);; 554 ; 555 fReadyToExecute = true;; 556 ; 557 if (addToGlobList && gROOT) {; 558 TFormula *old = nullptr;; 559 R__LOCKGUARD(gROOTMutex);; 560 old = dynamic_cast<TFormula*> ( gROOT->GetListOfFunctions()->FindObject(name) );; 561 if (old); 562 gROOT->GetListOfFunctions()->Remove(old);; 563 if (IsReservedName(name)); 564 Error(""TFormula"",""The name %s is reserved as a TFormula variable name.\n"",name);; 565 else; 566 gROOT->GetListOfFunctions()->Add(this);; 567 }; 568 SetBit(kNotGlobal,!addToGlobList);; 569 }; 570 else; 571 Error(""TFormula"",""Syntax error in building the lambda expression %s"", formula );; 572}; 573 ; 574////////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
Usability,simpl,simple,"T::Math::bigaussian_pdf (x,y,[SigmaX],[SigmaY],[Rho],[MeanX],[MeanY])`, a 2d gaussian including a correlation parameter.; 179 3. Three Dimensional functions:; 180 - `xyzgaus` is for a 3d Gaussians without correlations:; 181 `[Constant]*exp(-0.5*pow(((x-[MeanX])/[SigmaX]),2 )- 0.5*pow(((y-[MeanY])/[SigmaY]),2 )- 0.5*pow(((z-[MeanZ])/[SigmaZ]),2))`; 182 ; 183 ; 184 ### An expanded note on variables and parameters; 185 ; 186 In a TFormula, a variable is a defined by a name `x`, `y`, `z` or `t` or an; 187 index like `x[0]`, `x[1]`, `x[2]`; that is `x[N]` where N is an integer.; 188 ; 189 ```; 190 TFormula("""", ""x[0] * x[1] + 10""); 191 ```; 192 ; 193 Parameters are similar and can take any name. It is specified using brackets; 194 e.g. `[expected_mass]` or `[0]`.; 195 ; 196 ```; 197 TFormula("""", ""exp([expected_mass])-1""); 198 ```; 199 ; 200 Variables and parameters can be combined in the same TFormula. Here we consider; 201 a very simple case where we have an exponential decay after some time t and a; 202 number of events with timestamps for which we want to evaluate this function.; 203 ; 204 ```; 205 TFormula tf ("""", ""[0]*exp(-[1]*t)"");; 206 tf.SetParameter(0, 1);; 207 tf.SetParameter(1, 0.5);; 208 ; 209 for (auto & event : events) {; 210 tf.Eval(event.t);; 211 }; 212 ```; 213 ; 214 The distinction between variables and parameters arose from the TFormula's; 215 application in fitting. There parameters are fitted to the data provided; 216 through variables. In other applications this distinction can go away.; 217 ; 218 Parameter values can be provided dynamically using `TFormula::EvalPar`; 219 instead of `TFormula::Eval`. In this way parameters can be used identically; 220 to variables. See below for an example that uses only parameters to model a; 221 function.; 222 ; 223 ```; 224 Int_t params[2] = {1, 2}; // {vel_x, vel_y}; 225 TFormula tf ("""", ""[vel_x]/sqrt(([vel_x + vel_y])**2)"");; 226 ; 227 tf.EvalPar(nullptr, params);; 228 ```; 229 ; 230 ### A note on operators; 231 ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
Deployability,update,update,"ame object is clicked.; 76 ; 77void TFrame::ExecuteEvent(Int_t event, Int_t px, Int_t py); 78{; 79 if (!gPad) return;; 80 ; 81 if (!gPad->IsEditable()) return;; 82 ; 83 TWbox::ExecuteEvent(event, px, py);; 84 ; 85 Bool_t opaque = gPad->OpaqueMoving();; 86 ; 87 if ((event == kButton1Up) || ((opaque)&&(event == kButton1Motion))) {; 88 // update pad margins; 89 Double_t xmin = gPad->GetUxmin();; 90 Double_t xmax = gPad->GetUxmax();; 91 Double_t ymin = gPad->GetUymin();; 92 Double_t ymax = gPad->GetUymax();; 93 Double_t dx = xmax-xmin;; 94 Double_t dy = ymax-ymin;; 95 Double_t leftMargin = (fX1-gPad->GetX1())/(gPad->GetX2()-gPad->GetX1());; 96 Double_t topMargin = (gPad->GetY2()-fY2)/(gPad->GetY2()-gPad->GetY1());; 97 Double_t rightMargin = (gPad->GetX2()-fX2)/(gPad->GetX2()-gPad->GetX1());; 98 Double_t bottomMargin = (fY1-gPad->GetY1())/(gPad->GetY2()-gPad->GetY1());; 99 // margin may get very small negative values; 100 if (leftMargin < 0) leftMargin = 0;; 101 if (topMargin < 0) topMargin = 0;; 102 if (rightMargin < 0) rightMargin = 0;; 103 if (bottomMargin < 0) bottomMargin = 0;; 104 gPad->SetLeftMargin(leftMargin);; 105 gPad->SetRightMargin(rightMargin);; 106 gPad->SetBottomMargin(bottomMargin);; 107 gPad->SetTopMargin(topMargin);; 108 Double_t dxr = dx/(1 - gPad->GetLeftMargin() - gPad->GetRightMargin());; 109 Double_t dyr = dy/(1 - gPad->GetBottomMargin() - gPad->GetTopMargin());; 110 ; 111 // Range() could change the size of the pad pixmap and therefore should; 112 // be called before the other paint routines; 113 gPad->Range(xmin - dxr*gPad->GetLeftMargin(),; 114 ymin - dyr*gPad->GetBottomMargin(),; 115 xmax + dxr*gPad->GetRightMargin(),; 116 ymax + dyr*gPad->GetTopMargin());; 117 gPad->RangeAxis(xmin, ymin, xmax, ymax);; 118 fX1 = xmin;; 119 fY1 = ymin;; 120 fX2 = xmax;; 121 fY2 = ymax;; 122 }; 123}; 124 ; 125////////////////////////////////////////////////////////////////////////////////; 126/// Paint this wbox with its current attributes.; 127 ; 128void TFrame",MatchSource.WIKI,doc/master/TFrame_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFrame_8cxx_source.html
Integrability,rout,routines,"ame object is clicked.; 76 ; 77void TFrame::ExecuteEvent(Int_t event, Int_t px, Int_t py); 78{; 79 if (!gPad) return;; 80 ; 81 if (!gPad->IsEditable()) return;; 82 ; 83 TWbox::ExecuteEvent(event, px, py);; 84 ; 85 Bool_t opaque = gPad->OpaqueMoving();; 86 ; 87 if ((event == kButton1Up) || ((opaque)&&(event == kButton1Motion))) {; 88 // update pad margins; 89 Double_t xmin = gPad->GetUxmin();; 90 Double_t xmax = gPad->GetUxmax();; 91 Double_t ymin = gPad->GetUymin();; 92 Double_t ymax = gPad->GetUymax();; 93 Double_t dx = xmax-xmin;; 94 Double_t dy = ymax-ymin;; 95 Double_t leftMargin = (fX1-gPad->GetX1())/(gPad->GetX2()-gPad->GetX1());; 96 Double_t topMargin = (gPad->GetY2()-fY2)/(gPad->GetY2()-gPad->GetY1());; 97 Double_t rightMargin = (gPad->GetX2()-fX2)/(gPad->GetX2()-gPad->GetX1());; 98 Double_t bottomMargin = (fY1-gPad->GetY1())/(gPad->GetY2()-gPad->GetY1());; 99 // margin may get very small negative values; 100 if (leftMargin < 0) leftMargin = 0;; 101 if (topMargin < 0) topMargin = 0;; 102 if (rightMargin < 0) rightMargin = 0;; 103 if (bottomMargin < 0) bottomMargin = 0;; 104 gPad->SetLeftMargin(leftMargin);; 105 gPad->SetRightMargin(rightMargin);; 106 gPad->SetBottomMargin(bottomMargin);; 107 gPad->SetTopMargin(topMargin);; 108 Double_t dxr = dx/(1 - gPad->GetLeftMargin() - gPad->GetRightMargin());; 109 Double_t dyr = dy/(1 - gPad->GetBottomMargin() - gPad->GetTopMargin());; 110 ; 111 // Range() could change the size of the pad pixmap and therefore should; 112 // be called before the other paint routines; 113 gPad->Range(xmin - dxr*gPad->GetLeftMargin(),; 114 ymin - dyr*gPad->GetBottomMargin(),; 115 xmax + dxr*gPad->GetRightMargin(),; 116 ymax + dyr*gPad->GetTopMargin());; 117 gPad->RangeAxis(xmin, ymin, xmax, ymax);; 118 fX1 = xmin;; 119 fY1 = ymin;; 120 fX2 = xmax;; 121 fY2 = ymax;; 122 }; 123}; 124 ; 125////////////////////////////////////////////////////////////////////////////////; 126/// Paint this wbox with its current attributes.; 127 ; 128void TFrame",MatchSource.WIKI,doc/master/TFrame_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFrame_8cxx_source.html
Availability,error,errors,". ROOT: math/fumili/src/TFumili.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TFumili.cxx. Go to the documentation of this file. 1// @(#)root/fumili:$Id$; 2// Author: Stanislav Nesterov 07/05/2003; 3 ; 4 ; 5/** \class TFumili; 6 ; 7### FUMILI minimization package; 8 ; 9FUMILI is based on ideas, proposed by I.N. Silin [See NIM A440, 2000 (p431)].; 10It was converted from FORTRAN to C by Sergey Yaschenko <s.yaschenko@fz-juelich.de>; 11 ; 12 ; 13FUMILI is used to minimize Chi-square function or to search maximum of; 14likelihood function.; 15 ; 16Experimentally measured values \f$F_i\f$ are fitted with theoretical; 17functions \f$f_i({\vec x}_i,\vec\theta\,\,)\f$, where \f${\vec x}_i\f$ are; 18coordinates, and \f$\vec\theta\f$ -- vector of parameters.; 19 ; 20For better convergence Chi-square function has to be the following form; 21 ; 22\f[; 23{\chi^2\over2}={1\over2}\sum^n_{i=1}\left(f_i(\vec; 24x_i,\vec\theta\,\,)-F_i\over\sigma_i\right)^2 \tag{1}; 25\f]; 26 ; 27where \f$\sigma_i\f$ are errors of measured function.; 28 ; 29The minimum condition is; 30 ; 31\f[; 32{\partial\chi^2\over\partial\theta_i}=\sum^n_{j=1}{1\over\sigma^2_j}\cdot; 33{\partial f_j\over\partial\theta_i}\left[f_j(\vec; 34x_j,\vec\theta\,\,)-F_j\right]=0,\qquad i=1\ldots m\tag{2}; 35\f]; 36 ; 37where m is the quantity of parameters.; 38 ; 39Expanding left part of (2) over parameter increments and; 40retaining only linear terms one gets; 41 ; 42\f[; 43\left(\partial\chi^2\over\theta_i\right)_{\vec\theta={\vec\theta}^0}; 44+\sum_k\left(\partial^2\chi^2\over\partial\theta_i\partial\theta_k\right)_{; 45\vec\theta={\vec\theta}^0}\cdot(\theta_k-\theta_k^0); 46= 0\tag{3}; 47\f]; 48 ; 49Here \f${\vec\theta}_0\f$ is some initial value of parameters. In general case:; 50 ; 51\f[; 52{\partial^2\chi^2\over\partial\theta_i\partial\theta_k}=; 53\sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; 54{\partial f_j\over\theta_k} +; 55\sum^n_{j=1}{(f_j - F_j)\",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
Deployability,release,release,"> 0) {; 1178 if (nn1 <= fNstepDec) {; 1179 t=2.*(fS-olds-fGT);; 1180 if (fINDFLG[0] == 0) {; 1181 if (TMath::Abs(fS-olds) <= sp && -fGT <= sp) goto L19;; 1182 if( 0.59*t < -fGT) goto L19;; 1183 t = -fGT/t;; 1184 if (t < 0.25 ) t = 0.25;; 1185 }; 1186 else t = 0.25;; 1187 fGT = fGT*t;; 1188 t1 = t1*t;; 1189 nn2=0;; 1190 for( i = 0; i < n; i++) {; 1191 if (fPL[i] > 0.) {; 1192 fA[i]=fA[i]-fDA[i];; 1193 fPL[i]=fPL[i]*t;; 1194 fDA[i]=fDA[i]*t;; 1195 fA[i]=fA[i]+fDA[i];; 1196 }; 1197 }; 1198 nn1=nn1+1;; 1199 goto L4;; 1200 }; 1201 }; 1202 ; 1203L19:; 1204 ; 1205 if(fINDFLG[0] != 0) {; 1206 fENDFLG=-4;; 1207 printf(""trying to execute an illegal jump at L85\n"");; 1208 //goto L85;; 1209 }; 1210 ; 1211 ; 1212 Int_t k1, k2, i1, j, l;; 1213 k1 = 1;; 1214 k2 = 1;; 1215 i1 = 1;; 1216 // In this cycle we removed from fZ contributions from fixed parameters; 1217 // We'll get fixed parameters after boundary check; 1218 for( i = 0; i < n; i++) {; 1219 if (fPL0[i] > .0) {; 1220 // if parameter was fixed - release it; 1221 if (fPL[i] == 0.) fPL[i]=fPL0[i];; 1222 if (fPL[i] > .0) { // ??? it is already non-zero; 1223 // if derivative is negative and we above maximum; 1224 // or vice versa then fix parameter again and increment k1 by i1; 1225 if ((fA[i] >= fAMX[i] && fGr[i] < 0.) ||; 1226 (fA[i] <= fAMN[i] && fGr[i] > 0.)) {; 1227 fPL[i] = 0.;; 1228 k1 = k1 + i1; // i1 stands for fZ-matrix row-number multiplier; 1229 /// - skip this row; 1230 // in case we are fixing parameter number i; 1231 } else {; 1232 for( j=0; j <= i; j++) {// cycle on columns of fZ-matrix; 1233 if (fPL0[j] > .0) {; 1234 // if parameter is not fixed then fZ = fZ0; 1235 // Now matrix fZ of other dimension; 1236 if (fPL[j] > .0) {; 1237 fZ[k2 -1] = fZ0[k1 -1];; 1238 k2=k2+1;; 1239 }; 1240 k1=k1+1;; 1241 }; 1242 }; 1243 }; 1244 }; 1245 else k1 = k1 + i1; // In case of negative fPL[i] - after mconvd; 1246 i1=i1+1; // Next row of fZ0; 1247 }; 1248 }; 1249 ; 1250 // INVERT fZ-matrix (mconvd() procedure); 1251 i1 = 1;; 1",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
Energy Efficiency,reduce,reduce,")) {; 1227 fPL[i] = 0.;; 1228 k1 = k1 + i1; // i1 stands for fZ-matrix row-number multiplier; 1229 /// - skip this row; 1230 // in case we are fixing parameter number i; 1231 } else {; 1232 for( j=0; j <= i; j++) {// cycle on columns of fZ-matrix; 1233 if (fPL0[j] > .0) {; 1234 // if parameter is not fixed then fZ = fZ0; 1235 // Now matrix fZ of other dimension; 1236 if (fPL[j] > .0) {; 1237 fZ[k2 -1] = fZ0[k1 -1];; 1238 k2=k2+1;; 1239 }; 1240 k1=k1+1;; 1241 }; 1242 }; 1243 }; 1244 }; 1245 else k1 = k1 + i1; // In case of negative fPL[i] - after mconvd; 1246 i1=i1+1; // Next row of fZ0; 1247 }; 1248 }; 1249 ; 1250 // INVERT fZ-matrix (mconvd() procedure); 1251 i1 = 1;; 1252 l = 1;; 1253 for( i = 0; i < n; i++) {// extract diagonal elements to fR-vector; 1254 if (fPL[i] > .0) {; 1255 fR[i] = fZ[l - 1];; 1256 i1 = i1+1;; 1257 l = l + i1;; 1258 }; 1259 }; 1260 ; 1261 n0 = i1 - 1;; 1262 InvertZ(n0);; 1263 ; 1264 // fZ matrix now is inverted; 1265 if (fINDFLG[0] != 0) { // problems; 1266 // some PLs now have negative values, try to reduce fZ-matrix again; 1267 fINDFLG[0] = 0;; 1268 fINDFLG[1] = 1; // errors can be infinite; 1269 fixFLG = fixFLG + 1;; 1270 fi = 0;; 1271 goto L19;; 1272 }; 1273 ; 1274 // ... CALCULATE THEORETICAL STEP TO MINIMUM; 1275 i1 = 1;; 1276 for( i = 0; i < n; i++) {; 1277 fDA[i]=0.; // initial step is zero; 1278 if (fPL[i] > .0) { // for non-fixed parameters; 1279 l1=1;; 1280 for( l = 0; l < n; l++) {; 1281 if (fPL[l] > .0) {; 1282 // Calculate offset of Z^-1(i1,l1) element in packed matrix; 1283 // because we skip fixed param numbers we need also i,l; 1284 if (i1 <= l1 ) k=l1*(l1-1)/2+i1;; 1285 else k=i1*(i1-1)/2+l1;; 1286 // dA_i = \sum (-Z^{-1}_{il}*grad(fS)_l); 1287 fDA[i]=fDA[i]-fGr[l]*fZ[k - 1];; 1288 l1=l1+1;; 1289 }; 1290 }; 1291 i1=i1+1;; 1292 }; 1293 }; 1294 // ... CHECK FOR PARAMETERS ON BOUNDARY; 1295 ; 1296 afix=0.;; 1297 ifix = -1;; 1298 i1 = 1;; 1299 l = i1;; 1300 for( i = 0; i < n; i++); 1301 if (fPL[i] > .0) {; 1302 sigi = TMath::Sq",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
Integrability,depend,dependent,"ithm; 94of the likelihood function with the same idea - linearization of; 95function argument.; 96 ; 97*/; 98 ; 99 ; 100#include ""TFumili.h""; 101 ; 102#include <iostream>; 103#include ""TGraphAsymmErrors.h""; 104#include ""TF1.h""; 105#include ""TF2.h""; 106#include ""TF3.h""; 107#include ""TH1.h""; 108#include ""TMath.h""; 109#include ""TROOT.h""; 110#include ""TList.h""; 111#include ""TVirtualFitter.h""; 112 ; 113 ; 114extern void H1FitChisquareFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 115extern void H1FitLikelihoodFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 116extern void GraphFitChisquareFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 117 ; 118 ; 119ClassImp(TFumili);; 120 ; 121TFumili *gFumili=nullptr;; 122// Machine dependent values fiXME!!; 123// But don't set min=max=0 if param is unlimited; 124static const Double_t gMAXDOUBLE=1e300;; 125static const Double_t gMINDOUBLE=-1e300;; 126 ; 127////////////////////////////////////////////////////////////////////////////////; 128 ; 129TFumili::TFumili(Int_t maxpar); 130{//----------- FUMILI constructor ---------; 131 // maxpar is the maximum number of parameters used with TFumili object; 132 //; 133 fMaxParam = TMath::Max(maxpar,25);; 134 BuildArrays();; 135 ; 136 fNumericDerivatives = true;; 137 fLogLike = false;; 138 fNpar = fMaxParam;; 139 fGRAD = false;; 140 fWARN = true;; 141 fDEBUG = false;; 142 fNlog = 0;; 143 fSumLog = nullptr;; 144 fNED1 = 0;; 145 fNED2 = 0;; 146 fNED12 = fNED1+fNED2;; 147 fEXDA = nullptr;; 148 fFCN = nullptr;; 149 fNfcn = 0;; 150 fRP = 1.e-15; //precision; 151 fS = 1e10;; 152 fEPS =0.01;; 153 fENDFLG = 0;; 154 fNlimMul = 2;; 155 fNmaxIter= 150;; 156 fNstepDec= 3;; 157 fLastFixed = -1;; 158 ; 159 fAKAPPA = 0.;; 160 fGT = 0.;; 161 for (int i = 0; i<5; ++i) fINDFLG[i] = 0;; 162 ; 163 SetName(""Fumili"");; 164 gFumili = this;; 165 gROOT->GetListOfSpecials()->Add(gFumili);; 166}; 167 ; 168void TFumili::SetParNumber(Int_t ParN",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
Modifiability,variab,variable,"//////; 280///; 281/// Calculates partial derivatives of theoretical function; 282///; 283/// Input:; 284/// - fX - vector of data point; 285///; 286/// Output:; 287/// - DF - array of derivatives; 288///; 289/// ARITHM.F: Converted from CERNLIB; 290 ; 291void TFumili::Derivatives(Double_t *df,Double_t *fX){; 292 Double_t ff,ai,hi,y,pi;; 293 y = EvalTFN(df,fX);; 294 for (Int_t i=0;i<fNpar;i++) {; 295 df[i]=0;; 296 if(fPL0[i]>0.) {; 297 ai = fA[i]; // save current parameter value; 298 hi = 0.01*fPL0[i]; // diff step; 299 pi = fRP*TMath::Abs(ai);; 300 if (hi<pi) hi = pi; // if diff step is less than precision; 301 fA[i] = ai+hi;; 302 ; 303 if (fA[i]>fAMX[i]) { // if param is out of limits; 304 fA[i] = ai-hi;; 305 hi = -hi;; 306 if (fA[i]<fAMN[i]) { // again out of bounds; 307 fA[i] = fAMX[i]; // set param to high limit; 308 hi = fAMX[i]-ai;; 309 if (fAMN[i]-ai+hi<0) { // if hi < (ai-fAMN); 310 fA[i]=fAMN[i];; 311 hi=fAMN[i]-ai;; 312 }; 313 }; 314 }; 315 ff = EvalTFN(df,fX);; 316 df[i] = (ff-y)/hi;; 317 fA[i] = ai;; 318 }; 319 }; 320}; 321 ; 322 ; 323////////////////////////////////////////////////////////////////////////////////; 324/// Evaluate the minimisation function; 325///; 326/// Input parameters:; 327/// - npar: number of currently variable parameters; 328/// - par: array of (constant and variable) parameters; 329/// - flag: Indicates what is to be calculated; 330/// - grad: array of gradients; 331///; 332/// Output parameters:; 333/// - fval: The calculated function value.; 334/// - grad: The vector of first derivatives.; 335///; 336/// The meaning of the parameters par is of course defined by the user,; 337/// who uses the values of those parameters to calculate their function value.; 338/// The starting values must be specified by the user.; 339///; 340/// Inside FCN user has to define Z-matrix by means TFumili::GetZ; 341/// and TFumili::Derivatives,; 342/// set theoretical function by means of TFumili::SetUserFunc,; 343/// but first - pass number of parame",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
Performance,perform,performs,"(df,fX);; 316 df[i] = (ff-y)/hi;; 317 fA[i] = ai;; 318 }; 319 }; 320}; 321 ; 322 ; 323////////////////////////////////////////////////////////////////////////////////; 324/// Evaluate the minimisation function; 325///; 326/// Input parameters:; 327/// - npar: number of currently variable parameters; 328/// - par: array of (constant and variable) parameters; 329/// - flag: Indicates what is to be calculated; 330/// - grad: array of gradients; 331///; 332/// Output parameters:; 333/// - fval: The calculated function value.; 334/// - grad: The vector of first derivatives.; 335///; 336/// The meaning of the parameters par is of course defined by the user,; 337/// who uses the values of those parameters to calculate their function value.; 338/// The starting values must be specified by the user.; 339///; 340/// Inside FCN user has to define Z-matrix by means TFumili::GetZ; 341/// and TFumili::Derivatives,; 342/// set theoretical function by means of TFumili::SetUserFunc,; 343/// but first - pass number of parameters by TFumili::SetParNumber; 344///; 345/// Later values are determined by Fumili as it searches for the minimum; 346/// or performs whatever analysis is requested by the user.; 347///; 348/// The default function calls the function specified in SetFCN; 349 ; 350Int_t TFumili::Eval(Int_t& npar, Double_t *grad, Double_t &fval, Double_t *par, Int_t flag); 351{; 352 if (fFCN) (*fFCN)(npar,grad,fval,par,flag);; 353 return npar;; 354}; 355 ; 356 ; 357////////////////////////////////////////////////////////////////////////////////; 358/// Evaluate theoretical function; 359/// - df: array of partial derivatives; 360/// - X: vector of theoretical function argument; 361 ; 362Double_t TFumili::EvalTFN(Double_t * /*df*/, Double_t *X); 363{; 364 // for the time being disable possibility to compute derivatives; 365 //if(fTFN); 366 // return (*fTFN)(df,X,fA);; 367 //else if(fTFNF1) {; 368 ; 369 TF1 *f1 = (TF1*)fUserFunc;; 370 return f1->EvalPar(X,fA);; 371 //}; 372 //return 0.",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
Safety,predict,predict,"cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871////////////////////////////////////////////////////////////////////////////////; 1872/// Minimization function for H1s using a Likelihood method.; 1873/// Basically, it forms the likelihood by determining the Poisson; 1874/// probability that given a number of entries in a particular bin,; 1875/// the fit would predict it's value. This is then done for each bin,; 1876/// and the sum of the logs is taken as the likelihood.; 1877///; 1878/// Default method (function evaluated at center of bin); 1879/// for each point the cache contains the following info; 1880/// - 1D : bc,e,xc (bin content, error, x of center of bin); 1881/// - 2D : bc,e,xc,yc; 1882/// - 3D : bc,e,xc,yc,zc; 1883 ; 1884void TFumili::FitLikelihood(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1885{; 1886 Foption_t fitOption = GetFitOption();; 1887 if (fitOption.Integral) {; 1888 FitLikelihoodI(npar,gin,f,u,flag);; 1889 return;; 1890 }; 1891 Double_t cu,fu,fobs,fsub;; 1892 Double_t dersum[100];; 1893 Double_t x[3];; 1894 Int_t icu;; 1895 ; 1896 TH1 *hfit = (TH1*)GetObjectFit();; 1897 TF1 *f1 = (TF1*)GetUserFunc();; 1898 Int_t nd = hfit->GetDimension();; 1899 Int_t j;; 1900 Double_t *zik = GetZ();; 1901 Double_t *pl0 = GetPL0();; 1902 ; ",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
Testability,log,logarithm,"72 ; 73Then the equations for parameter increments are; 74\f[\left(\partial\chi^2\over\partial\theta_i\right)_{\vec\theta={\vec\theta}^0}; 75+\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) = 0,; 76\qquad i=1\ldots m\tag{6}; 77\f]; 78 ; 79Remarkable feature of algorithm is the technique for step; 80restriction. For an initial value of parameter \f${\vec\theta}^0\f$ a; 81parallelepiped \f$P_0\f$ is built with the center at \f${\vec\theta}^0\f$ and; 82axes parallel to coordinate axes \f$\theta_i\f$. The lengths of; 83parallelepiped sides along i-th axis is \f$2b_i\f$, where \f$b_i\f$ is such a; 84value that the functions \f$f_j(\vec\theta)\f$ are quasi-linear all over; 85the parallelepiped.; 86 ; 87FUMILI takes into account simple linear inequalities in the form:; 88\f[; 89\theta_i^{\rm min}\le\theta_i\le\theta^{\rm max}_i\tag{7}; 90\f]; 91 ; 92They form parallelepiped \f$P\f$ (\f$P_0\f$ may be deformed by \f$P\f$).; 93Very similar step formulae are used in FUMILI for negative logarithm; 94of the likelihood function with the same idea - linearization of; 95function argument.; 96 ; 97*/; 98 ; 99 ; 100#include ""TFumili.h""; 101 ; 102#include <iostream>; 103#include ""TGraphAsymmErrors.h""; 104#include ""TF1.h""; 105#include ""TF2.h""; 106#include ""TF3.h""; 107#include ""TH1.h""; 108#include ""TMath.h""; 109#include ""TROOT.h""; 110#include ""TList.h""; 111#include ""TVirtualFitter.h""; 112 ; 113 ; 114extern void H1FitChisquareFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 115extern void H1FitLikelihoodFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 116extern void GraphFitChisquareFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 117 ; 118 ; 119ClassImp(TFumili);; 120 ; 121TFumili *gFumili=nullptr;; 122// Machine dependent values fiXME!!; 123// But don't set min=max=0 if param is unlimited; 124static const Double_t gMAXDOUBLE=1e300;; 125static const Double_t gMINDOUBLE=-1e300;; 126 ; 127///////////////////////////////",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
Usability,simpl,simple,"alue is:; 67\f[{\partial^2\chi^2\over\partial\theta_i\partial\theta_k}\approx; 68Z_{ik}=; 69\sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; 70{\partial f_j\over\theta_k}\tag{5}; 71\f]; 72 ; 73Then the equations for parameter increments are; 74\f[\left(\partial\chi^2\over\partial\theta_i\right)_{\vec\theta={\vec\theta}^0}; 75+\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) = 0,; 76\qquad i=1\ldots m\tag{6}; 77\f]; 78 ; 79Remarkable feature of algorithm is the technique for step; 80restriction. For an initial value of parameter \f${\vec\theta}^0\f$ a; 81parallelepiped \f$P_0\f$ is built with the center at \f${\vec\theta}^0\f$ and; 82axes parallel to coordinate axes \f$\theta_i\f$. The lengths of; 83parallelepiped sides along i-th axis is \f$2b_i\f$, where \f$b_i\f$ is such a; 84value that the functions \f$f_j(\vec\theta)\f$ are quasi-linear all over; 85the parallelepiped.; 86 ; 87FUMILI takes into account simple linear inequalities in the form:; 88\f[; 89\theta_i^{\rm min}\le\theta_i\le\theta^{\rm max}_i\tag{7}; 90\f]; 91 ; 92They form parallelepiped \f$P\f$ (\f$P_0\f$ may be deformed by \f$P\f$).; 93Very similar step formulae are used in FUMILI for negative logarithm; 94of the likelihood function with the same idea - linearization of; 95function argument.; 96 ; 97*/; 98 ; 99 ; 100#include ""TFumili.h""; 101 ; 102#include <iostream>; 103#include ""TGraphAsymmErrors.h""; 104#include ""TF1.h""; 105#include ""TF2.h""; 106#include ""TF3.h""; 107#include ""TH1.h""; 108#include ""TMath.h""; 109#include ""TROOT.h""; 110#include ""TList.h""; 111#include ""TVirtualFitter.h""; 112 ; 113 ; 114extern void H1FitChisquareFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 115extern void H1FitLikelihoodFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 116extern void GraphFitChisquareFumili(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 117 ; 118 ; 119ClassImp(TFumili);; 120 ; 121TFumili *gFumili=nullptr;; 122// Machine dependent va",MatchSource.WIKI,doc/master/TFumili_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html
Availability,error,errors,"itter.h""; 8 ; 9class TF1;; 10 ; 11class TFumili : public TVirtualFitter {; 12private:; 13 Int_t fMaxParam; ///<; 14 Int_t fNlog; ///<; 15 Int_t fNfcn; ///< Number of FCN calls;; 16 Int_t fNED1; ///< Number of experimental vectors X=(x1,x2,...xK); 17 Int_t fNED2; ///< K - Length of vector X plus 2 (for chi2); 18 Int_t fNED12; ///< fNED1+fNED2; 19 Int_t fNpar; ///< fNpar - number of parameters; 20 Int_t fNstepDec; ///< fNstepDec - maximum number of step decreasing counter; 21 Int_t fNlimMul; ///< fNlimMul - after fNlimMul successful iterations permits four-fold increasing of fPL; 22 Int_t fNmaxIter; ///< fNmaxIter - maximum number of iterations; 23 Int_t fLastFixed; ///< Last fixed parameter number; 24 Int_t fENDFLG; ///< End flag of fit; 25 Int_t fINDFLG[5]; ///< internal flags;; 26 ; 27 ; 28 Bool_t fGRAD; ///< user calculated gradients; 29 Bool_t fWARN; ///< warnings; 30 Bool_t fDEBUG; ///< debug info; 31 Bool_t fLogLike; ///< LogLikelihood flag; 32 Bool_t fNumericDerivatives; ///<; 33 ; 34 Double_t *fZ0; ///< [fMaxParam2] Matrix of approximate second derivatives of objective function; 35 ///< This matrix is diagonal and always contain only variable parameter's; 36 ///< derivatives; 37 Double_t *fZ; ///< [fMaxParam2] Inverse fZ0 matrix - covariance matrix; 38 Double_t *fGr; ///< [fMaxParam] Gradients of objective function; 39 Double_t *fParamError; ///< [fMaxParam] Parameter errors; 40 Double_t *fSumLog; ///< [fNlog]; 41 Double_t *fEXDA; ///< [fNED12] experimental data poInt_ter; 42 ; 43 // don't calculate parameter errors - take them from fParamError array; 44 Double_t *fA; ///< [fMaxParam] Fit parameter array; 45 Double_t *fPL0; ///< [fMaxParam] Step initial bounds; 46 Double_t *fPL; ///< [fMaxParam] Limits for parameters step. If <0, then parameter is fixed; 47 ; 48 // Defines multidimensional parallelepiped with center in param. vector; 49 Double_t *fDA; ///< [fMaxParam] Parameter step; 50 Double_t *fAMX; ///< [fMaxParam] Maximum param value; 51 Double_t *fAMN; /",MatchSource.WIKI,doc/master/TFumili_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8h_source.html
Integrability,wrap,wrapper,,MatchSource.WIKI,doc/master/TFumili_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8h_source.html
Modifiability,variab,variable,"itter.h""; 8 ; 9class TF1;; 10 ; 11class TFumili : public TVirtualFitter {; 12private:; 13 Int_t fMaxParam; ///<; 14 Int_t fNlog; ///<; 15 Int_t fNfcn; ///< Number of FCN calls;; 16 Int_t fNED1; ///< Number of experimental vectors X=(x1,x2,...xK); 17 Int_t fNED2; ///< K - Length of vector X plus 2 (for chi2); 18 Int_t fNED12; ///< fNED1+fNED2; 19 Int_t fNpar; ///< fNpar - number of parameters; 20 Int_t fNstepDec; ///< fNstepDec - maximum number of step decreasing counter; 21 Int_t fNlimMul; ///< fNlimMul - after fNlimMul successful iterations permits four-fold increasing of fPL; 22 Int_t fNmaxIter; ///< fNmaxIter - maximum number of iterations; 23 Int_t fLastFixed; ///< Last fixed parameter number; 24 Int_t fENDFLG; ///< End flag of fit; 25 Int_t fINDFLG[5]; ///< internal flags;; 26 ; 27 ; 28 Bool_t fGRAD; ///< user calculated gradients; 29 Bool_t fWARN; ///< warnings; 30 Bool_t fDEBUG; ///< debug info; 31 Bool_t fLogLike; ///< LogLikelihood flag; 32 Bool_t fNumericDerivatives; ///<; 33 ; 34 Double_t *fZ0; ///< [fMaxParam2] Matrix of approximate second derivatives of objective function; 35 ///< This matrix is diagonal and always contain only variable parameter's; 36 ///< derivatives; 37 Double_t *fZ; ///< [fMaxParam2] Inverse fZ0 matrix - covariance matrix; 38 Double_t *fGr; ///< [fMaxParam] Gradients of objective function; 39 Double_t *fParamError; ///< [fMaxParam] Parameter errors; 40 Double_t *fSumLog; ///< [fNlog]; 41 Double_t *fEXDA; ///< [fNED12] experimental data poInt_ter; 42 ; 43 // don't calculate parameter errors - take them from fParamError array; 44 Double_t *fA; ///< [fMaxParam] Fit parameter array; 45 Double_t *fPL0; ///< [fMaxParam] Step initial bounds; 46 Double_t *fPL; ///< [fMaxParam] Limits for parameters step. If <0, then parameter is fixed; 47 ; 48 // Defines multidimensional parallelepiped with center in param. vector; 49 Double_t *fDA; ///< [fMaxParam] Parameter step; 50 Double_t *fAMX; ///< [fMaxParam] Maximum param value; 51 Double_t *fAMN; /",MatchSource.WIKI,doc/master/TFumili_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8h_source.html
Testability,log,log-likelihood,"efinition TFumili.h:13; TFumili::SetParNumbervoid SetParNumber(Int_t ParNum)Definition TFumili.cxx:168; TFumili::SetDatavoid SetData(Double_t *, Int_t, Int_t)Sets pointer to data array provided by user.Definition TFumili.cxx:1616; TFumili::fINDFLGInt_t fINDFLG[5]internal flags;Definition TFumili.h:25; TFumili::EvalTFNDouble_t EvalTFN(Double_t *, Double_t *)Evaluate theoretical function.Definition TFumili.cxx:362; TFumili::GetZDouble_t * GetZ() constDefinition TFumili.h:102; TFumili::fParamErrorDouble_t * fParamError[fMaxParam] Parameter errorsDefinition TFumili.h:39; TFumili::ChisquareDouble_t Chisquare(Int_t npar, Double_t *params) const overridereturn a chisquare equivalentDefinition TFumili.cxx:227; TFumili::fENDFLGInt_t fENDFLGEnd flag of fit.Definition TFumili.h:24; TFumili::fRDouble_t * fR[fMaxParam] Correlation factorsDefinition TFumili.h:52; TFumili::fDADouble_t * fDA[fMaxParam] Parameter stepDefinition TFumili.h:49; TFumili::SetFitMethodvoid SetFitMethod(const char *name) overrideret fit method (chisquare or log-likelihood)Definition TFumili.cxx:1628; TFumili::fNstepDecInt_t fNstepDecfNstepDec - maximum number of step decreasing counterDefinition TFumili.h:20; TFumili::GetErrorsInt_t GetErrors(Int_t ipar, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &globcc) const overrideReturn errors after MINOs not implemented.Definition TFumili.cxx:882; TFumili::fZ0Double_t * fZ0[fMaxParam2] Matrix of approximate second derivatives of objective function This matrix is diagonal a...Definition TFumili.h:34; TFumili::fPL0Double_t * fPL0[fMaxParam] Step initial boundsDefinition TFumili.h:45; TFumili::fADouble_t * fA[fMaxParam] Fit parameter arrayDefinition TFumili.h:44; TFumili::fAKAPPADouble_t fAKAPPADefinition TFumili.h:60; TFumili::MinimizeInt_t Minimize()Main minimization procedure.Definition TFumili.cxx:1085; TFumili::fNmaxIterInt_t fNmaxIterfNmaxIter - maximum number of iterationsDefinition TFumili.h:22; TFumili::ExecuteSetCommandInt_t ExecuteSetComma",MatchSource.WIKI,doc/master/TFumili_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFumili_8h_source.html
Availability,avail,available,"1556736; // months (average # days); 1231 rangeOffset = (Double_t) ((Long_t)(timeoffset)%rangeBase);; 1232 if (range>31536000) {; 1233 tp0 = gmtime(&timetp);; 1234 tp0->tm_mon = 0;; 1235 tp0->tm_mday = 1;; 1236 tp0->tm_hour = 0;; 1237 tp0->tm_min = 0;; 1238 tp0->tm_sec = 0;; 1239 tp0->tm_isdst = 1; // daylight saving time is on.; 1240 rangeBase = (timetp-mktime(tp0)); // years; 1241 rangeOffset = (Double_t) (rangeBase);; 1242 }; 1243 wmax += rangeOffset;; 1244 wmin += rangeOffset;; 1245 }; 1246 ; 1247// Determine number of divisions 1, 2 and 3 and the maximum digits for this axis; 1248 n1a = (ndiv%100);; 1249 n2a = (ndiv%10000 - n1a)/100;; 1250 n3a = (ndiv%1000000 - n2a -n1a)/10000;; 1251 nn3 = TMath::Max(n3a,1);; 1252 nn2 = TMath::Max(n2a,1)*nn3;; 1253 nn1 = TMath::Max(n1a,1)*nn2+1;; 1254 nticks = nn1;; 1255 maxDigits = (ndiv/1000000);; 1256 if (maxDigits==0) maxDigits = gStyle->GetAxisMaxDigits();; 1257 ; 1258// Axis bining optimisation is ignored if:; 1259// - the first and the last label are equal; 1260// - the number of divisions is 0; 1261// - less than 1 primary division is requested; 1262// - logarithmic scale is requested; 1263 ; 1264 if (wmin == wmax || ndiv == 0 || n1a <= 1 || optionLog) {; 1265 optionNoopt = 1;; 1266 optionInt = 0;; 1267 }; 1268 ; 1269// Axis bining optimisation; 1270 if ( (wmax-wmin) < 1 && optionInt) {; 1271 Error(where, ""option I not available"");; 1272 optionInt = 0;; 1273 }; 1274 if (!optionNoopt || optionInt ) {; 1275 ; 1276// Primary divisions optimisation; 1277// When integer labelling is required, Optimize is invoked first; 1278// and only if the result is not an integer labelling, AdjustBinSize is invoked.; 1279 ; 1280 THLimitsFinder::Optimize(wmin,wmax,n1a,binLow,binHigh,nbins,binWidth,fChopt.Data());; 1281 if (optionInt) {; 1282 if (binLow != Double_t(int(binLow)) || binWidth != Double_t(int(binWidth))) {; 1283 AdjustBinSize(wmin,wmax,n1a,binLow,binHigh,nbins,binWidth);; 1284 }; 1285 }; 1286 if ((wmin-binLow) > epsilon) { binLo",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
Deployability,toggle,toggle,"->GetTitleSize());; 972 SetBit(TAxis::kCenterTitle, axis->TestBit(TAxis::kCenterTitle));; 973 SetBit(TAxis::kCenterLabels, axis->TestBit(TAxis::kCenterLabels));; 974 SetBit(TAxis::kRotateTitle, axis->TestBit(TAxis::kRotateTitle));; 975 SetBit(TAxis::kNoExponent, axis->TestBit(TAxis::kNoExponent));; 976 SetBit(TAxis::kTickPlus, axis->TestBit(TAxis::kTickPlus));; 977 SetBit(TAxis::kTickMinus, axis->TestBit(TAxis::kTickMinus));; 978 SetBit(TAxis::kMoreLogLabels, axis->TestBit(TAxis::kMoreLogLabels));; 979 if (axis->GetDecimals()) SetBit(TAxis::kDecimals); //the bit is in TAxis::fAxis2; 980 SetTimeFormat(axis->GetTimeFormat());; 981}; 982 ; 983////////////////////////////////////////////////////////////////////////////////; 984/// Draw this axis with its current attributes.; 985 ; 986void TGaxis::Paint(Option_t *); 987{; 988 if (!gPad) return;; 989 ; 990 Double_t wmin = fWmin;; 991 Double_t wmax = fWmax;; 992 Int_t ndiv = fNdiv;; 993 ; 994 // following code required to support toggle of lin/log scales; 995 Double_t x1 = gPad->XtoPad(fX1);; 996 Double_t y1 = gPad->YtoPad(fY1);; 997 Double_t x2 = gPad->XtoPad(fX2);; 998 Double_t y2 = gPad->YtoPad(fY2);; 999 ; 1000 PaintAxis(x1,y1,x2,y2,wmin,wmax,ndiv,fChopt.Data(),fGridLength);; 1001}; 1002 ; 1003////////////////////////////////////////////////////////////////////////////////; 1004/// Control function to draw an axis.; 1005/// Original authors: O.Couet C.E.Vandoni N.Cremel-Somon.; 1006/// Modified and converted to C++ class by Rene Brun.; 1007 ; 1008void TGaxis::PaintAxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax,; 1009 Double_t &wmin, Double_t &wmax, Int_t &ndiv, Option_t *chopt,; 1010 Double_t gridlength, Bool_t drawGridOnly); 1011{; 1012 if (!gPad) return;; 1013 ; 1014 const char *where = ""PaintAxis"";; 1015 ; 1016 Double_t alfa, beta, ratio1, ratio2, grid_side;; 1017 Double_t axis_lengthN = 0;; 1018 Double_t axis_length0 = 0;; 1019 Double_t axis_length1 = 0;; 1020 Double_t axis_length;; 1021 Double_t at",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
Energy Efficiency,energy,energy,"ar *func, Int_t ndiv, Option_t *chopt,; 115 Double_t gridlength); 116~~~; 117Where:; 118 ; 119- xmin : X origin coordinate in user's coordinates space.; 120- xmax : X end axis coordinate in user's coordinates space.; 121- ymin : Y origin coordinate in user's coordinates space.; 122- ymax : Y end axis coordinate in user's coordinates space.; 123- func : function defining axis labels and tick marks.; 124- ndiv : Number of divisions.; 125 - ndiv=N1 + 100*N2 + 10000*N3; 126 - N1=number of 1st divisions.; 127 - N2=number of 2nd divisions.; 128 - N3=number of 3rd divisions. e.g.:; 129 - ndiv=0 --> no tick marks.; 130 - ndiv=2 --> 2 divisions, one tick mark in the middle of the axis.; 131- chopt : Drawing options (see below).; 132- gridlength: grid length on main tick marks.; 133 ; 134It should be noted that `func` is not defined in the user's coordinate space,; 135but in the new TGaxis space. If `x` is the original axis, `w` the new axis,; 136and `w = f(x)` (for example, `f` is a calibration function converting ADC; 137channels `x` to energy `w`), then `func` must be supplied as `f^{-1}(w)`.; 138 ; 139Examples:; 140 ; 141Begin_Macro(source); 142{; 143 TCanvas *c2 = new TCanvas(""c2"",""c2"",10,10,700,500);; 144 ; 145 gPad->DrawFrame(0.,-2.,10.,2);; 146 ; 147 TF1 *f1=new TF1(""f1"",""-x"",-10,10);; 148 TGaxis *A1 = new TGaxis(0,2,10,2,""f1"",510,""-"");; 149 A1->SetTitle(""axis with decreasing values"");; 150 A1->Draw();; 151 ; 152 TF1 *f2=new TF1(""f2"",""exp(x)"",0,2);; 153 TGaxis *A2 = new TGaxis(1,1,9,1,""f2"");; 154 A2->SetTitle(""exponential axis"");; 155 A2->SetLabelSize(0.03);; 156 A2->SetTitleSize(0.03);; 157 A2->SetTitleOffset(1.2);; 158 A2->Draw();; 159 ; 160 TF1 *f3=new TF1(""f3"",""log10(x)"",1,1000);; 161 TGaxis *A3 = new TGaxis(2,-2,2,0,""f3"",505,"""");; 162 A3->SetTitle(""logarithmic axis"");; 163 A3->SetLabelSize(0.02);; 164 A3->SetTitleSize(0.03);; 165 A3->SetTitleOffset(0.); // Axis title automatically placed; 166 A3->Draw();; 167}; 168End_Macro; 169 ; 170Note that this functionality h",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
Integrability,message,message,"amervoid Streamer(TBuffer &) overrideStream an object of class TLine.Definition TLine.cxx:518; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Streamervirtual void Streamer(TBuffer &)Stream a string object.Definition TString.cxx:1412; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Ind",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
Modifiability,config,configured,"; 845 fChopt=ax.fChopt;; 846 fName=ax.fName;; 847 fTitle=ax.fTitle;; 848 fTimeFormat=ax.fTimeFormat;; 849 fFunctionName=ax.fFunctionName;; 850 fFunction=ax.fFunction;; 851 fAxis=ax.fAxis;; 852 fNModLabs=ax.fNModLabs;; 853 fModLabs = ax.IsOwnedModLabs() ? (TList *) ax.fModLabs->Clone() : ax.fModLabs;; 854 }; 855 return *this;; 856}; 857 ; 858////////////////////////////////////////////////////////////////////////////////; 859/// TGaxis default destructor.; 860 ; 861TGaxis::~TGaxis(); 862{; 863 CleanupModLabs();; 864}; 865 ; 866////////////////////////////////////////////////////////////////////////////////; 867/// Returns kTRUE when fModLabs owned by TGaxis and should be cleaned up; 868 ; 869Bool_t TGaxis::IsOwnedModLabs() const; 870{; 871 if (!fModLabs) return kFALSE;; 872 if (fAxis && (fAxis->GetModifiedLabels() == fModLabs)) return kFALSE;; 873 // TList created by TGaxis configured with owner flag; 874 // If TGaxis object from old ROOT file will be read, memory will be leaked; 875 return fModLabs->IsOwner();; 876}; 877 ; 878////////////////////////////////////////////////////////////////////////////////; 879/// Correctly cleanup fModLabs - delete content when owned by TGaxis; 880 ; 881void TGaxis::CleanupModLabs(); 882{; 883 if (IsOwnedModLabs()) {; 884 fModLabs->Delete();; 885 delete fModLabs;; 886 }; 887 fModLabs = nullptr;; 888 fNModLabs = 0;; 889}; 890 ; 891////////////////////////////////////////////////////////////////////////////////; 892/// If center = kTRUE axis labels are centered in the center of the bin.; 893/// The default is to center on the primary tick marks.; 894/// This option does not make sense if there are more bins than tick marks.; 895 ; 896void TGaxis::CenterLabels(Bool_t center); 897{; 898 ; 899 if (center) SetBit(TAxis::kCenterLabels);; 900 else ResetBit(TAxis::kCenterLabels);; 901}; 902 ; 903////////////////////////////////////////////////////////////////////////////////; 904/// If center = kTRUE axis title will be centered. The default i",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
Performance,optimiz,optimization,"; 349By default the number of divisions on axis is optimised to show a coherent; 350labelling of the main tick marks. The number of division (`ndiv`) is a; 351composite integer given by:; 352 ; 353` ndiv = N1 + 100*N2 + 10000*N3`; 354 ; 355 - `N1` = number of 1st divisions.; 356 - `N2` = number of 2nd divisions.; 357 - `N3` = number of 3rd divisions.; 358 ; 359by default the value of `N1`, `N2` and `N3` are maximum; 360values. After optimisation the real number of divisions will be smaller or; 361equal to these value. If one wants to bypass the optimisation, the option `""N""`; 362should be given when the `TGaxis` is created. The option `""I""`; 363also act on the number of division as it will force an integer labelling of; 364the axis.; 365 ; 366On an histogram pointer `h` the number of divisions can be set in different ways:.; 367 ; 368- Directly on the histogram. The following will set the number of division; 369 to 510 on the X axis of `h`. To avoid optimization the number of divisions; 370 should be negative (ie: -510);; 371~~~ {.cpp}; 372 h->SetNdivisions(510, ""X"");; 373~~~; 374- On the axis itself:; 375~~~ {.cpp}; 376 h->GetXaxis()->SetNdivisions(510, kTRUE);; 377~~~; 378 ; 379The first parameter is the number of division. If it is negative of if the; 380second parameter is kFALSE then the number of divisions is not optimised.; 381And other signature is also allowed:; 382~~~ {.cpp}; 383 h->GetXaxis()->SetNdivisions(10, 5, 0, kTRUE);; 384~~~; 385\anchor GA12; 386## Maximum Number of Digits for the axis labels; 387 ; 388The static method `TGaxis::SetMaxDigits` sets the maximum number of; 389digits permitted for the axis labels above which the notation with 10^N is used.; 390For example, to accept 6 digits number like 900000 on an axis call; 391`TGaxis::SetMaxDigits(6)`. The default value is 5.; 392`fgMaxDigits` must be greater than 0.; 393Warning: even when called on a particular TGaxis* instance, this static function; 394changes globally the number of digits for al",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
Safety,avoid,avoid,"; 349By default the number of divisions on axis is optimised to show a coherent; 350labelling of the main tick marks. The number of division (`ndiv`) is a; 351composite integer given by:; 352 ; 353` ndiv = N1 + 100*N2 + 10000*N3`; 354 ; 355 - `N1` = number of 1st divisions.; 356 - `N2` = number of 2nd divisions.; 357 - `N3` = number of 3rd divisions.; 358 ; 359by default the value of `N1`, `N2` and `N3` are maximum; 360values. After optimisation the real number of divisions will be smaller or; 361equal to these value. If one wants to bypass the optimisation, the option `""N""`; 362should be given when the `TGaxis` is created. The option `""I""`; 363also act on the number of division as it will force an integer labelling of; 364the axis.; 365 ; 366On an histogram pointer `h` the number of divisions can be set in different ways:.; 367 ; 368- Directly on the histogram. The following will set the number of division; 369 to 510 on the X axis of `h`. To avoid optimization the number of divisions; 370 should be negative (ie: -510);; 371~~~ {.cpp}; 372 h->SetNdivisions(510, ""X"");; 373~~~; 374- On the axis itself:; 375~~~ {.cpp}; 376 h->GetXaxis()->SetNdivisions(510, kTRUE);; 377~~~; 378 ; 379The first parameter is the number of division. If it is negative of if the; 380second parameter is kFALSE then the number of divisions is not optimised.; 381And other signature is also allowed:; 382~~~ {.cpp}; 383 h->GetXaxis()->SetNdivisions(10, 5, 0, kTRUE);; 384~~~; 385\anchor GA12; 386## Maximum Number of Digits for the axis labels; 387 ; 388The static method `TGaxis::SetMaxDigits` sets the maximum number of; 389digits permitted for the axis labels above which the notation with 10^N is used.; 390For example, to accept 6 digits number like 900000 on an axis call; 391`TGaxis::SetMaxDigits(6)`. The default value is 5.; 392`fgMaxDigits` must be greater than 0.; 393Warning: even when called on a particular TGaxis* instance, this static function; 394changes globally the number of digits for al",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
Testability,log,logarithmic,"2- gridlength: grid length on main tick marks.; 133 ; 134It should be noted that `func` is not defined in the user's coordinate space,; 135but in the new TGaxis space. If `x` is the original axis, `w` the new axis,; 136and `w = f(x)` (for example, `f` is a calibration function converting ADC; 137channels `x` to energy `w`), then `func` must be supplied as `f^{-1}(w)`.; 138 ; 139Examples:; 140 ; 141Begin_Macro(source); 142{; 143 TCanvas *c2 = new TCanvas(""c2"",""c2"",10,10,700,500);; 144 ; 145 gPad->DrawFrame(0.,-2.,10.,2);; 146 ; 147 TF1 *f1=new TF1(""f1"",""-x"",-10,10);; 148 TGaxis *A1 = new TGaxis(0,2,10,2,""f1"",510,""-"");; 149 A1->SetTitle(""axis with decreasing values"");; 150 A1->Draw();; 151 ; 152 TF1 *f2=new TF1(""f2"",""exp(x)"",0,2);; 153 TGaxis *A2 = new TGaxis(1,1,9,1,""f2"");; 154 A2->SetTitle(""exponential axis"");; 155 A2->SetLabelSize(0.03);; 156 A2->SetTitleSize(0.03);; 157 A2->SetTitleOffset(1.2);; 158 A2->Draw();; 159 ; 160 TF1 *f3=new TF1(""f3"",""log10(x)"",1,1000);; 161 TGaxis *A3 = new TGaxis(2,-2,2,0,""f3"",505,"""");; 162 A3->SetTitle(""logarithmic axis"");; 163 A3->SetLabelSize(0.02);; 164 A3->SetTitleSize(0.03);; 165 A3->SetTitleOffset(0.); // Axis title automatically placed; 166 A3->Draw();; 167}; 168End_Macro; 169 ; 170Note that this functionality has some limitations and does not follow all the TGaxis setting.; 171In particular the number of divisions or the maximum number digits do not apply.; 172 ; 173\anchor GA02; 174## Logarithmic axis; 175 ; 176By default axis are linear. To define a `TGaxis` as logarithmic, it is; 177enough to create it with the option `""G""`.; 178 ; 179When plotting an histogram or a graph the logarithmic scale can be set using:; 180 ; 181 - `gPad->SetLogx(1);` set the logarithmic scale on the X axis; 182 - `gPad->SetLogy(1);` set the logarithmic scale on the Y axis; 183 ; 184When the `SetMoreLogLabels()` method is called more labels are drawn; 185when in logarithmic scale and there is a small number of decades (less than 3).; 186 ; 187\ancho",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
Usability,simpl,simple,":SetOptionvoid SetOption(Option_t *option="""")To set axis options.Definition TGaxis.cxx:2934; TGaxis::IsATClass * IsA() const overrideDefinition TGaxis.h:136; THLimitsFinder::Optimizestatic void Optimize(Double_t A1, Double_t A2, Int_t nold, Double_t &BinLow, Double_t &BinHigh, Int_t &nbins, Double_t &BWID, Option_t *option="""")Static function to compute reasonable axis limits.Definition THLimitsFinder.cxx:184; TIterDefinition TCollection.h:235; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::GetXsizeDouble_t GetXsize()Return size of the formula along X in pad coordinates when the text precision is smaller than 3.Definition TLatex.cxx:2569; TLatex::GetBoundingBoxvoid GetBoundingBox(UInt_t &w, UInt_t &h, Bool_t angle=kFALSE) overrideReturn text size in pixels.Definition TLatex.cxx:2600; TLatex::PaintLatexvirtual void PaintLatex(Double_t x, Double_t y, Double_t angle, Double_t size, const char *text)Main drawing function.Definition TLatex.cxx:2114; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::fY1Double_t fY1Y of 1st point.Definition TLine.h:26; TLine::fX1Double_t fX1X of 1st point.Definition TLine.h:25; TLine::fX2Double_t fX2X of 2nd point.Definition TLine.h:27; TLine::operator=TLine & operator=(const TLine &src)Assignment operator.Definition TLine.cxx:67; TLine::fY2Double_t fY2Y of 2nd point.Definition TLine.h:28; TLine::PaintLineNDCvirtual void PaintLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2)Draw this line with new coordinates in NDC.Definition TLine.cxx:409; TLine::Streamervoid Streamer(TBuffer &) overrideStream an object of class TLine.Definition TLine.cxx:518; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of th",MatchSource.WIKI,doc/master/TGaxis_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html
Integrability,depend,dependency,". ROOT: graf2d/graf/inc/TGaxis.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TGaxis.h File Reference. #include ""TLine.h""; #include ""TAttText.h""; #include ""TString.h"". Include dependency graph for TGaxis.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGaxis;  The axis painter class. More...;  . graf2dgrafincTGaxis.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:16 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGaxis_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8h.html
Usability,simpl,simple,"stDefinition TGaxis.h:88; TGaxis::Paintvoid Paint(Option_t *chopt="""") overrideDraw this axis with its current attributes.Definition TGaxis.cxx:986; TGaxis::fNModLabsInt_t fNModLabsNumber of modified labels.Definition TGaxis.h:39; TGaxis::fWminDouble_t fWminLowest value on the axis.Definition TGaxis.h:28; TGaxis::SetLabelSizevoid SetLabelSize(Float_t labelsize)Definition TGaxis.h:107; TGaxis::SetFunctionvoid SetFunction(const char *funcname="""")Specify a function to map the axis values.Definition TGaxis.cxx:2643; TGaxis::SetNamevirtual void SetName(const char *name)Change the name of the axis.Definition TGaxis.cxx:2904; TGaxis::SetExponentOffsetstatic void SetExponentOffset(Float_t xoff=0., Float_t yoff=0., Option_t *axis=""xy"")Static method to set X and Y offset of the axis 10^n notation.Definition TGaxis.cxx:3035; TGaxis::LabelsLimitsvoid LabelsLimits(const char *label, Int_t &first, Int_t &last)Internal method to find first and last character of a label.Definition TGaxis.cxx:2533; TGaxis::GetWmaxDouble_t GetWmax() constDefinition TGaxis.h:90; TGaxis::IsOwnedModLabsBool_t IsOwnedModLabs() constReturns kTRUE when fModLabs owned by TGaxis and should be cleaned up.Definition TGaxis.cxx:869; TGaxis::ResetLabelAttributesvoid ResetLabelAttributes(TLatex *t)Helper method used by TGaxis::ChangeLabel.Definition TGaxis.cxx:2880; TGaxis::GetLabelSizeFloat_t GetLabelSize() constDefinition TGaxis.h:81; TGaxis::SetOptionvoid SetOption(Option_t *option="""")To set axis options.Definition TGaxis.cxx:2934; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TListA doubly linked list.Definition TList.h:38; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; bool; double; int; v@ vDefinition rootcling_impl.cxx:3699. graf2dgrafincTGaxis.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:18 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGaxis_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGaxis_8h_source.html
Availability,down,down,,MatchSource.WIKI,doc/master/TGButton_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGButton_8h_source.html
Deployability,release,released,"p;; 64class TGButtonGroup;; 65class TGPopupMenu;; 66class TGTextLayout;; 67 ; 68class TGButton : public TGFrame, public TGWidget {; 69 ; 70friend class TGButtonGroup;; 71 ; 72protected:; 73 UInt_t fTWidth; ///< button width; 74 UInt_t fTHeight; ///< button height; 75 EButtonState fState; ///< button state; 76 Bool_t fStayDown; ///< true if button has to stay down; 77 GContext_t fNormGC; ///< graphics context used for drawing button; 78 void *fUserData; ///< pointer to user data structure; 79 TGToolTip *fTip; ///< tool tip associated with button; 80 TGButtonGroup *fGroup; ///< button group this button belongs to; 81 Pixel_t fBgndColor; ///< actual background color; 82 Pixel_t fHighColor; ///< highlight color; 83 UInt_t fStyle; ///< button style (modern or classic); 84 ; 85 virtual void SetToggleButton(Bool_t) {}; 86 virtual void EmitSignals(Bool_t wasUp);; 87 ; 88 static const TGGC *fgDefaultGC;; 89 static const TGGC *fgHibckgndGC;; 90 ; 91 static Window_t fgReleaseBtn; // the last released button; 92 ; 93private:; 94 TGButton(const TGButton&) = delete;; 95 TGButton& operator=(const TGButton&) = delete;; 96 ; 97public:; 98 static const TGGC &GetDefaultGC();; 99 static const TGGC &GetHibckgndGC();; 100 ; 101 TGButton(const TGWindow *p = nullptr, Int_t id = -1, GContext_t norm = GetDefaultGC()(),; 102 UInt_t option = kRaisedFrame | kDoubleBorder);; 103 ~TGButton() override;; 104 ; 105 Bool_t HandleButton(Event_t *event) override;; 106 Bool_t HandleCrossing(Event_t *event) override;; 107 virtual void SetUserData(void *userData) { fUserData = userData; }; 108 virtual void *GetUserData() const { return fUserData; }; 109 virtual void SetToolTipText(const char *text, Long_t delayms = 400); //*MENU*; 110 virtual TGToolTip *GetToolTip() const { return fTip; }; 111 virtual void SetState(EButtonState state, Bool_t emit = kFALSE);; 112 virtual EButtonState GetState() const { return fState; }; 113 virtual void AllowStayDown(Bool_t a) { fStayDown = a; }; 114 virtual void SetGroup(T",MatchSource.WIKI,doc/master/TGButton_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGButton_8h_source.html
Integrability,message,message,"TGRadioButton //; 19// and TGSplitButton //; 20// //; 21// This header defines all GUI button widgets. //; 22// //; 23// TGButton is a button abstract base class. It defines general button //; 24// behaviour. //; 25// //; 26// Selecting a text or picture button will generate the event: //; 27// kC_COMMAND, kCM_BUTTON, button id, user data. //; 28// //; 29// Selecting a check button will generate the event: //; 30// kC_COMMAND, kCM_CHECKBUTTON, button id, user data. //; 31// //; 32// Selecting a radio button will generate the event: //; 33// kC_COMMAND, kCM_RADIOBUTTON, button id, user data. //; 34// //; 35// If a command string has been specified (via SetCommand()) then this //; 36// command string will be executed via the interpreter whenever a //; 37// button is selected. A command string can contain the macros: //; 38// $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message //; 39// (use GET_MSG() and GET_SUBMSG() to unpack) //; 40// $PARM1 -- button id //; 41// $PARM2 -- user data pointer //; 42// Before executing these macros are expanded into the respective //; 43// Long_t's //; 44// //; 45//////////////////////////////////////////////////////////////////////////; 46 ; 47#include ""TGFrame.h""; 48#include ""TGWidget.h""; 49 ; 50//--- Button states; 51 ; 52enum EButtonState {; 53 kButtonUp,; 54 kButtonDown,; 55 kButtonEngaged,; 56 kButtonDisabled; 57};; 58 ; 59 ; 60class TGWidget;; 61class TGHotString;; 62class TGPicture;; 63class TGToolTip;; 64class TGButtonGroup;; 65class TGPopupMenu;; 66class TGTextLayout;; 67 ; 68class TGButton : public TGFrame, public TGWidget {; 69 ; 70friend class TGButtonGroup;; 71 ; 72protected:; 73 UInt_t fTWidth; ///< button width; 74 UInt_t fTHeight; ///< button height; 75 EButtonState fState; ///< button state; 76 Bool_t fStayDown; ///< true if button has to stay down; 77 GContext_t fNormGC; ///< graphics context used for drawing button; 78 void *fUserData; ///< pointer to user data structure; 79 TGToolTip *fTip; ///< tool tip associ",MatchSource.WIKI,doc/master/TGButton_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGButton_8h_source.html
Usability,simpl,simple,"ideEmit signals.Definition TGButton.cxx:1262; TGCheckButton::SetStatevoid SetState(EButtonState state, Bool_t emit=kFALSE) overrideSet check button state.Definition TGButton.cxx:1250; TGCheckButton::fPrevStateEButtonState fPrevStateprevious check button stateDefinition TGButton.h:272; TGCheckButton::DoRedrawvoid DoRedraw() overrideDraw the check button widget.Definition TGButton.cxx:1437; TGCheckButton::fDisOffconst TGPicture * fDisOffbutton disabled and was OFF pictureDefinition TGButton.h:276; TGCheckButton::fDisOnconst TGPicture * fDisOnbutton disabled and was ON pictureDefinition TGButton.h:275; TGCheckButton::GetDefaultSizeTGDimension GetDefaultSize() const overridedefault sizeDefinition TGButton.cxx:1236; TGCheckButton::PSetStatevoid PSetState(EButtonState state, Bool_t emit)Set check button state.Definition TGButton.cxx:1273; TGDimensionDefinition TGDimension.h:18; TGFontEncapsulate fonts used in the GUI system.Definition TGFont.h:140; TGFrameA subclasses of TGWindow, and is used as base class for some simple widgets (buttons,...Definition TGFrame.h:80; TGGCEncapsulate a graphics context used in the low level graphics.Definition TGGC.h:22; TGHotStringTGHotString is a string with a ""hot"" character underlined.Definition TGString.h:42; TGPictureButtonYield an action as soon as it is clicked.Definition TGButton.h:228; TGPictureButton::SetPicturevirtual void SetPicture(const TGPicture *new_pic)Change a picture in a picture button.Definition TGButton.cxx:1040; TGPictureButton::CreateDisabledPicturevirtual void CreateDisabledPicture()Creates disabled picture.Definition TGButton.cxx:1108; TGPictureButton::GetDisabledPictureconst TGPicture * GetDisabledPicture() constDefinition TGButton.h:257; TGPictureButton::SetDisabledPicturevirtual void SetDisabledPicture(const TGPicture *pic)Changes disabled picture.Definition TGButton.cxx:1135; TGPictureButton::GetPictureconst TGPicture * GetPicture() constDefinition TGButton.h:256; TGPictureButton::SavePrimitivevoid SavePrimiti",MatchSource.WIKI,doc/master/TGButton_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGButton_8h_source.html
Availability,error,error,"amerInfoActions.h""; 23#include ""THashTable.h""; 24#include ""THashList.h""; 25#include <cstdlib>; 26 ; 27#define MESSAGE(which,text); 28 ; 29/**; 30\class TGenVectorProxy; 31\ingroup IO; 32Local optimization class.; 33 ; 34Collection proxies get copied. On copy we switch the type of the; 35proxy to the concrete STL type. The concrete types are optimized; 36for element access.; 37*/; 38 ; 39class TGenVectorProxy : public TGenCollectionProxy {; 40public:; 41 // Standard Destructor; 42 TGenVectorProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c); 43 {; 44 }; 45 // Standard Destructor; 46 ~TGenVectorProxy() override; 47 {; 48 }; 49 // Return the address of the value at index 'idx'; 50 void* At(UInt_t idx) override; 51 {; 52 if ( fEnv && fEnv->fObject ) {; 53 fEnv->fIdx = idx;; 54 switch( idx ) {; 55 case 0:; 56 return fEnv->fStart = fFirst.invoke(fEnv);; 57 default:; 58 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 59 return ((char*)fEnv->fStart) + fValDiff*idx;; 60 }; 61 }; 62 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 63 return nullptr;; 64 }; 65 // Call to delete/destruct individual item; 66 void DeleteItem(Bool_t force, void* ptr) const override; 67 {; 68 if ( force && ptr ) {; 69 if ( fVal->fProperties&kNeedDelete) {; 70 TVirtualCollectionProxy *proxy = fVal->fType->GetCollectionProxy();; 71 TPushPop helper(proxy,ptr);; 72 proxy->Clear(""force"");; 73 }; 74 fVal->DeleteItem(ptr);; 75 }; 76 }; 77};; 78 ; 79/**; 80\class TGenVectorBoolProxy; 81\ingroup IO; 82Local optimization class.; 83 ; 84Collection proxies get copied. On copy we switch the type of the; 85proxy to the concrete STL type. The concrete types are optimized; 86for element access.; 87*/; 88class TGenVectorBoolProxy : public TGenCollectionProxy {; 89 Bool_t fLastValue;; 90 ; 91public:; 92 TGenVectorBoolProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c), fLastValue(false); 93 {; 94 // Standard Constructor.; 95 }; 96 ~TGenVectorBoolProxy() override; 97 {;",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
Energy Efficiency,allocate,allocated,"onProxy__StagingCopyIterator(void *dest, const void *source); 1581{; 1582 *(void**)dest = *(void**)source;; 1583 return dest;; 1584}; 1585 ; 1586////////////////////////////////////////////////////////////////////////////////; 1587/// Nothing to do; 1588 ; 1589void TGenCollectionProxy__StagingDeleteSingleIterators(void *); 1590{; 1591}; 1592 ; 1593////////////////////////////////////////////////////////////////////////////////; 1594/// Nothing to do; 1595 ; 1596void TGenCollectionProxy__StagingDeleteTwoIterators(void *, void *); 1597{; 1598}; 1599 ; 1600 ; 1601////////////////////////////////////////////////////////////////////////////////; 1602/// See typedef void (*CreateIterators_t)(void *collection, void *&begin_arena, void *&end_arena);; 1603/// begin_arena and end_arena should contain the location of memory arena of size fgIteratorSize.; 1604/// If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); 1605/// Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena.; 1606 ; 1607TVirtualCollectionProxy::CreateIterators_t TGenCollectionProxy::GetFunctionCreateIterators(Bool_t read); 1608{; 1609 if (read) {; 1610 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1611 if ( (fProperties & kIsAssociative) && read); 1612 return TGenCollectionProxy__StagingCreateIterators;; 1613 }; 1614 ; 1615 if ( fFunctionCreateIterators ) return fFunctionCreateIterators;; 1616 ; 1617 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1618 ; 1619// fprintf(stderr,""GetFunctinCreateIterator for %s will give: "",fClass.GetClassName());; 1620// if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1621// fprintf(stderr,""vector/emulated iterator\n"");; 1622// else if ( (fProperties & kIsAssociative) && read); 1623// fprintf(stderr,""an associative read iterator\n"");; 1624// else; 1625",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
Integrability,rout,routine," %s present."",fName.c_str());; 809 }; 810 if ( 0 == fConstruct ) {; 811 Fatal(""TGenCollectionProxy"",""No 'block constructor' function for class %s present."",fName.c_str());; 812 }; 813 if ( 0 == fDestruct ) {; 814 Fatal(""TGenCollectionProxy"",""No 'block destructor' function for class %s present."",fName.c_str());; 815 }; 816 if ( 0 == fFeed ) {; 817 Fatal(""TGenCollectionProxy"",""No 'data feed' function for class %s present."",fName.c_str());; 818 }; 819 if ( 0 == fCollect ) {; 820 Fatal(""TGenCollectionProxy"",""No 'data collect' function for class %s present."",fName.c_str());; 821 }; 822 if (0 == fCreateEnv.call ) {; 823 Fatal(""TGenCollectionProxy"",""No 'environment creation' function for class %s present."",fName.c_str());; 824 }; 825}; 826 ; 827////////////////////////////////////////////////////////////////////////////////; 828/// Utility routine to issue a Fatal error is the Value object is not valid; 829 ; 830static TGenCollectionProxy::Value *R__CreateValue(const std::string &name, Bool_t silent,; 831 size_t hint_pair_offset = 0, size_t hint_pair_size = 0); 832{; 833 TGenCollectionProxy::Value *val = new TGenCollectionProxy::Value( name, silent, hint_pair_offset, hint_pair_size );; 834 if ( !val->IsValid() ) {; 835 Fatal(""TGenCollectionProxy"",""Could not find %s!"",name.c_str());; 836 }; 837 return val;; 838}; 839 ; 840////////////////////////////////////////////////////////////////////////////////; 841/// Proxy initializer; 842 ; 843TGenCollectionProxy *TGenCollectionProxy::InitializeEx(Bool_t silent); 844{; 845 R__LOCKGUARD(gInterpreterMutex);; 846 if (fValue.load()) return this;; 847 ; 848 TClass *cl = fClass ? fClass.GetClass() : TClass::GetClass(fTypeinfo,kTRUE,silent);; 849 if ( cl ) {; 850 fEnv = 0;; 851 fName = cl->GetName();; 852 fPointers = false;; 853 int nested = 0;; 854 std::vector<std::string> inside;; 855 int num = TClassEdit::GetSplit(cl->GetName(),inside,nested);; 856 if ( num > 1 ) {; 857 std::string nam;; 858 Value* newfValue = nullptr;; 859 if ( inside",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
Modifiability,inherit,inherited,"re.h:54; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TClassEdit.h; TClass.h; EDataTypeEDataTypeDefinition TDataType.h:28; kNoType_t@ kNoType_tDefinition TDataType.h:33; kInt_t@ kInt_tDefinition TDataType.h:30; kBool_t@ kBool_tDefinition TDataType.h:32; kVoid_t@ kVoid_tDefinition TDataType.h:35; kIsPointer@ kIsPointerDefinition TDictionary.h:78; kIsClass@ kIsClassDefinition TDictionary.h:65; kIsEnum@ kIsEnumDefinition TDictionary.h:68; kIsFundamental@ kIsFundamentalDefinition TDictionary.h:70; kIsStruct@ kIsStructDefinition TDictionary.h:66; TEnum.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; MayNotUsevoid MayNotUse(const char *method)This function can be used in classes that should override a certain function, but in the inherited cl...Definition TError.cxx:168; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; destOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t destDefinition TGWin32VirtualXProxy.cxx:164; propOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetL",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
Performance,optimiz,optimization,"ding...; Searching...; No Matches. TGenCollectionProxy.cxx. Go to the documentation of this file. 1// @(#)root/io:$Id$; 2// Author: Markus Frank 28/10/04; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TGenCollectionProxy.h""; 13#include ""TVirtualStreamerInfo.h""; 14#include ""TStreamerElement.h""; 15#include ""TClassEdit.h""; 16#include ""TClass.h""; 17#include ""TError.h""; 18#include ""TEnum.h""; 19#include ""TROOT.h""; 20#include ""TInterpreter.h"" // For gInterpreterMutex; 21#include ""TVirtualMutex.h""; 22#include ""TStreamerInfoActions.h""; 23#include ""THashTable.h""; 24#include ""THashList.h""; 25#include <cstdlib>; 26 ; 27#define MESSAGE(which,text); 28 ; 29/**; 30\class TGenVectorProxy; 31\ingroup IO; 32Local optimization class.; 33 ; 34Collection proxies get copied. On copy we switch the type of the; 35proxy to the concrete STL type. The concrete types are optimized; 36for element access.; 37*/; 38 ; 39class TGenVectorProxy : public TGenCollectionProxy {; 40public:; 41 // Standard Destructor; 42 TGenVectorProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c); 43 {; 44 }; 45 // Standard Destructor; 46 ~TGenVectorProxy() override; 47 {; 48 }; 49 // Return the address of the value at index 'idx'; 50 void* At(UInt_t idx) override; 51 {; 52 if ( fEnv && fEnv->fObject ) {; 53 fEnv->fIdx = idx;; 54 switch( idx ) {; 55 case 0:; 56 return fEnv->fStart = fFirst.invoke(fEnv);; 57 default:; 58 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 59 return ((char*)fEnv->fStart) + fValDiff*idx;; 60 }; 61 }; 62 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 63 return nullptr;; 64 }; 65 // Call to delete/destruct individu",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
Safety,avoid,avoid," = kVoid_t;; 342 return;; 343 }; 344 }; 345 ; 346 if ( intype.substr(0,6) == ""string"" || intype.substr(0,11) == ""std::string"" ) {; 347 fCase = kBIT_ISSTRING;; 348 fType = TClass::GetClass(""string"");; 349 fCtor = fType->GetNew();; 350 fDtor = fType->GetDestructor();; 351 fDelete = fType->GetDelete();; 352 if (isPointer) {; 353 fCase |= kIsPointer;; 354 fSize = sizeof(void*);; 355 } else {; 356 fSize = sizeof(std::string);; 357 }; 358 }; 359 else {; 360 // In the case where we have an emulated class,; 361 // if the class is nested (in a class or a namespace),; 362 // calling G__TypeInfo ti(inside.c_str());; 363 // might fail because CINT does not known the nesting; 364 // scope, so let's first look for an emulated class:; 365 ; 366 fType = TClass::GetClass(intype.c_str(),kTRUE,silent, hint_pair_offset, hint_pair_size);; 367 ; 368 if (fType) {; 369 if (isPointer) {; 370 fCase |= kIsPointer;; 371 fSize = sizeof(void*);; 372 if (fType == TString::Class()) {; 373 fCase |= kBIT_ISTSTRING;; 374 }; 375 }; 376 fCase |= kIsClass;; 377 fCtor = fType->GetNew();; 378 fDtor = fType->GetDestructor();; 379 fDelete = fType->GetDelete();; 380 } else {; 381 R__LOCKGUARD(gInterpreterMutex);; 382 ; 383 // Try to avoid autoparsing.; 384 ; 385 THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );; 386 assert(typeTable && ""The type of the list of type has changed"");; 387 ; 388 TDataType *fundType = (TDataType *)typeTable->THashTable::FindObject( intype.c_str() );; 389 if (fundType && fundType->GetType() < 0x17 && fundType->GetType() > 0) {; 390 fKind = (EDataType)fundType->GetType();; 391 // R__ASSERT((fKind>0 && fKind<0x17) || (fKind==-1&&(prop&kIsPointer)) );; 392 ; 393 fCase |= kIsFundamental;; 394 if (isPointer) {; 395 fCase |= kIsPointer;; 396 fSize = sizeof(void*);; 397 } else {; 398 fSize = fundType->Size();; 399 }; 400 } else if (TEnum::GetEnum( intype.c_str(), TEnum::kNone) ) {; 401 // This is a known enum.; 402 fCase = kIsEnum;; 403 fSize = sizeof(Int_t);; ",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
Security,access,access,"***************************; 5 * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TGenCollectionProxy.h""; 13#include ""TVirtualStreamerInfo.h""; 14#include ""TStreamerElement.h""; 15#include ""TClassEdit.h""; 16#include ""TClass.h""; 17#include ""TError.h""; 18#include ""TEnum.h""; 19#include ""TROOT.h""; 20#include ""TInterpreter.h"" // For gInterpreterMutex; 21#include ""TVirtualMutex.h""; 22#include ""TStreamerInfoActions.h""; 23#include ""THashTable.h""; 24#include ""THashList.h""; 25#include <cstdlib>; 26 ; 27#define MESSAGE(which,text); 28 ; 29/**; 30\class TGenVectorProxy; 31\ingroup IO; 32Local optimization class.; 33 ; 34Collection proxies get copied. On copy we switch the type of the; 35proxy to the concrete STL type. The concrete types are optimized; 36for element access.; 37*/; 38 ; 39class TGenVectorProxy : public TGenCollectionProxy {; 40public:; 41 // Standard Destructor; 42 TGenVectorProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c); 43 {; 44 }; 45 // Standard Destructor; 46 ~TGenVectorProxy() override; 47 {; 48 }; 49 // Return the address of the value at index 'idx'; 50 void* At(UInt_t idx) override; 51 {; 52 if ( fEnv && fEnv->fObject ) {; 53 fEnv->fIdx = idx;; 54 switch( idx ) {; 55 case 0:; 56 return fEnv->fStart = fFirst.invoke(fEnv);; 57 default:; 58 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 59 return ((char*)fEnv->fStart) + fValDiff*idx;; 60 }; 61 }; 62 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 63 return nullptr;; 64 }; 65 // Call to delete/destruct individual item; 66 void DeleteItem(Bool_t force, void* ptr) const override; 67 {; 68 if ( force && ptr ) {; 69 if ( fVal->fProperties&kNeedDelete) {; 70 TVirtualCollectionProxy *proxy = fVal->fType->GetCollectionPr",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
Testability,assert,assert,"4 fSize = sizeof(void*);; 355 } else {; 356 fSize = sizeof(std::string);; 357 }; 358 }; 359 else {; 360 // In the case where we have an emulated class,; 361 // if the class is nested (in a class or a namespace),; 362 // calling G__TypeInfo ti(inside.c_str());; 363 // might fail because CINT does not known the nesting; 364 // scope, so let's first look for an emulated class:; 365 ; 366 fType = TClass::GetClass(intype.c_str(),kTRUE,silent, hint_pair_offset, hint_pair_size);; 367 ; 368 if (fType) {; 369 if (isPointer) {; 370 fCase |= kIsPointer;; 371 fSize = sizeof(void*);; 372 if (fType == TString::Class()) {; 373 fCase |= kBIT_ISTSTRING;; 374 }; 375 }; 376 fCase |= kIsClass;; 377 fCtor = fType->GetNew();; 378 fDtor = fType->GetDestructor();; 379 fDelete = fType->GetDelete();; 380 } else {; 381 R__LOCKGUARD(gInterpreterMutex);; 382 ; 383 // Try to avoid autoparsing.; 384 ; 385 THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );; 386 assert(typeTable && ""The type of the list of type has changed"");; 387 ; 388 TDataType *fundType = (TDataType *)typeTable->THashTable::FindObject( intype.c_str() );; 389 if (fundType && fundType->GetType() < 0x17 && fundType->GetType() > 0) {; 390 fKind = (EDataType)fundType->GetType();; 391 // R__ASSERT((fKind>0 && fKind<0x17) || (fKind==-1&&(prop&kIsPointer)) );; 392 ; 393 fCase |= kIsFundamental;; 394 if (isPointer) {; 395 fCase |= kIsPointer;; 396 fSize = sizeof(void*);; 397 } else {; 398 fSize = fundType->Size();; 399 }; 400 } else if (TEnum::GetEnum( intype.c_str(), TEnum::kNone) ) {; 401 // This is a known enum.; 402 fCase = kIsEnum;; 403 fSize = sizeof(Int_t);; 404 fKind = kInt_t;; 405 if (isPointer) {; 406 fCase |= kIsPointer;; 407 fSize = sizeof(void*);; 408 }; 409 } else {; 410 // This fallback solution should be hardly used ...; 411 // One of the common use case is to 'discover' that this is a; 412 // collection for the content of which we do not have a dictionary; 413 // which can happen at least in th",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
Usability,clear,clear,"1Bool_t TGenCollectionProxy::Value::IsValid(); 512{; 513 ; 514 ; 515 return fSize != std::string::npos;; 516}; 517 ; 518void TGenCollectionProxy::Value::DeleteItem(void* ptr); 519{; 520 // Delete an item.; 521 ; 522 if ( ptr && fCase&kIsPointer ) {; 523 if ( fDelete ) {; 524 (*fDelete)(ptr);; 525 }; 526 else if ( fType ) {; 527 fType->Destructor(ptr);; 528 }; 529 else {; 530 ::operator delete(ptr);; 531 }; 532 }; 533}; 534 ; 535/**; 536 \class TGenCollectionProxy TGenCollectionProxy.cxx; 537 \ingroup IO; 538 ; 539 Proxy around an arbitrary container, which implements basic; 540 functionality and iteration.; 541 ; 542 The purpose of this implementation; 543 is to shield any generated dictionary implementation from the; 544 underlying streamer/proxy implementation and only expose; 545 the creation functions.; 546 ; 547 In particular this is used to implement splitting and abstract; 548 element access of any container. Access to compiled code is necessary; 549 to implement the abstract iteration sequence and functionality like; 550 size(), clear(), resize(). resize() may be a void operation.; 551*/; 552 ; 553////////////////////////////////////////////////////////////////////////////////; 554/// Build a proxy for an emulated container.; 555 ; 556TGenCollectionProxy::TGenCollectionProxy(const TGenCollectionProxy& copy); 557 : TVirtualCollectionProxy(copy.fClass),; 558 fTypeinfo(copy.fTypeinfo); 559{; 560 fEnv = 0;; 561 fName = copy.fName;; 562 fPointers = copy.fPointers;; 563 fSTL_type = copy.fSTL_type;; 564 fSize.call = copy.fSize.call;; 565 fNext.call = copy.fNext.call;; 566 fFirst.call = copy.fFirst.call;; 567 fClear.call = copy.fClear.call;; 568 fResize = copy.fResize;; 569 fDestruct = copy.fDestruct;; 570 fConstruct = copy.fConstruct;; 571 fFeed = copy.fFeed;; 572 fCollect = copy.fCollect;; 573 fCreateEnv.call = copy.fCreateEnv.call;; 574 fValOffset = copy.fValOffset;; 575 fValDiff = copy.fValDiff;; 576 fValue = copy.fValue.load(std::memory_order_relaxed) ? new Val",MatchSource.WIKI,doc/master/TGenCollectionProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html
Safety,safe,safe,"8 &) = delete;; 32 ; 33 void CopyTwist(Double_t *twist = nullptr);; 34 ; 35public:; 36 // constructors; 37 TGeoArb8();; 38 TGeoArb8(Double_t dz, Double_t *vertices = nullptr);; 39 TGeoArb8(const char *name, Double_t dz, Double_t *vertices = nullptr);; 40 // destructor; 41 ~TGeoArb8() override;; 42 // methods; 43 Double_t Capacity() const override;; 44 void ComputeBBox() override;; 45 void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) override;; 46 void ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;; 47 void ComputeTwist();; 48 Bool_t Contains(const Double_t *point) const override;; 49 void Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override;; 50 Double_t DistToPlane(const Double_t *point, const Double_t *dir, Int_t ipl, Bool_t in) const;; 51 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 52 Double_t *safe = nullptr) const override;; 53 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 54 Double_t *step) const override;; 55 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 56 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 57 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 58 Double_t *step) const override;; 59 TGeoVolume *; 60 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 61 Double_t GetAxisRange(Int_t iaxis, Double_t &xlo, Double_t &xhi) const override;; 62 void GetBoundingCylinder(Double_t *param) const override;; 63 Int_t GetByteCount() const override { return 100; }; 64 Double_t GetClosestEdge(const Double_t *point, Double_t *vert, Int_t &isegment) const;; 65 Bool_t GetPointsOnFacet(Int_t /*index*/, Int_t /*npoints*/, Double_t * /*array*/) const ",MatchSource.WIKI,doc/master/TGeoArb8_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoArb8_8h_source.html
Availability,down,down,";; 852 }; 853}; 854 ; 855////////////////////////////////////////////////////////////////////////////////; 856/// Destructor.; 857 ; 858TGeoElemIter::~TGeoElemIter(); 859{; 860 if (fBranch); 861 delete fBranch;; 862}; 863 ; 864////////////////////////////////////////////////////////////////////////////////; 865/// Assignment.; 866 ; 867TGeoElemIter &TGeoElemIter::operator=(const TGeoElemIter &iter); 868{; 869 if (&iter == this); 870 return *this;; 871 fTop = iter.fTop;; 872 fElem = iter.fElem;; 873 fLevel = iter.fLevel;; 874 if (iter.fBranch) {; 875 fBranch = new TObjArray(10);; 876 for (Int_t i = 0; i < fLevel; i++); 877 fBranch->Add(iter.fBranch->At(i));; 878 }; 879 fLimitRatio = iter.fLimitRatio;; 880 fRatio = iter.fRatio;; 881 return *this;; 882}; 883 ; 884////////////////////////////////////////////////////////////////////////////////; 885/// () operator.; 886 ; 887TGeoElementRN *TGeoElemIter::operator()(); 888{; 889 return Next();; 890}; 891 ; 892////////////////////////////////////////////////////////////////////////////////; 893/// Go upwards from the current location until the next branching, then down.; 894 ; 895TGeoElementRN *TGeoElemIter::Up(); 896{; 897 TGeoDecayChannel *dc;; 898 Int_t ind, nd;; 899 while (fLevel) {; 900 // Current decay channel; 901 dc = (TGeoDecayChannel *)fBranch->At(fLevel - 1);; 902 ind = dc->GetIndex();; 903 nd = dc->Parent()->GetNdecays();; 904 fRatio /= 0.01 * dc->BranchingRatio();; 905 fElem = dc->Parent();; 906 fBranch->RemoveAt(--fLevel);; 907 ind++;; 908 while (ind < nd) {; 909 if (Down(ind++)); 910 return (TGeoElementRN *)fElem;; 911 }; 912 }; 913 fElem = nullptr;; 914 return nullptr;; 915}; 916 ; 917////////////////////////////////////////////////////////////////////////////////; 918/// Go downwards from current level via ibranch as low in the tree as possible.; 919/// Return value flags if the operation was successful.; 920 ; 921TGeoElementRN *TGeoElemIter::Down(Int_t ibranch); 922{; 923 if (!fElem); 924 return nullptr;; 9",MatchSource.WIKI,doc/master/TGeoElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html
Deployability,install,installation,"jArray.h:68; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::operator=TObject & operator=(const TObject &rhs)TObject assignment operator.Definition TObject.h:296; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TVirtualGeoPainter::DrawBatemanSolvirtual void DrawBate",MatchSource.WIKI,doc/master/TGeoElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html
Energy Efficiency,power,power,"ing.h:704; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TVirtualGeoPainter::DrawBatemanSolvirtual void DrawBatemanSol(TGeoBatemanSol *sol, Option_t *option="""")=0; bool; double; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; nconst Int_t nDefinition legend1.C:16; TGeant4Unit::alpha_rcl2static constexpr double alpha_rcl2Definition TGeant4PhysicalConstants.h:95; TGeant4Unit::fine_structure_conststatic constexpr double fine_structure_constDefinition TGeant4PhysicalConstants.h:90; TGeoUnit::fine_structure_conststatic constexpr double fine_structure_constDefinition TGeoPhysicalConstants.h:90; TGeoUnit::alpha_rcl2static constexpr double alpha_rcl2Definition TGeoPhysicalConstants.h:95; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::Naconstexpr Double_t Na()Avogadro constant (Avogadro's Number) in .Definition TMath.h:284; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TGeoBatemanSol::BtCoef_tDefinition TGeoElement.h:288; TGeoBatemanSol::BtCoef_t::cnDouble_t cnDefinition TGeoElement.h:289; TGeoBatemanSol::BtCoef_t::lambdaDouble_t lambdaDefinition TGeoElement.h:290. geomgeomsrcTGeoElement.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html
Integrability,message,message,"eReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::RemoveAtTObject * RemoveAt(Int_t idx) overrideRemove object at index idx.Definition TObjArray.cxx:694; TObjArray::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TObjArray.cxx:415; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::operator=TObject & operator=(const TObject &rhs)TObject assignment operator.Definition TObject.h:296; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Defin",MatchSource.WIKI,doc/master/TGeoElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html
Modifiability,extend,extend,"TGeoElementTable *TGeoElement::GetElementTable(); 232{; 233 if (!gGeoManager) {; 234 ::Error(""TGeoElementTable::GetElementTable"", ""Create a geometry manager first"");; 235 return nullptr;; 236 }; 237 return gGeoManager->GetElementTable();; 238}; 239 ; 240////////////////////////////////////////////////////////////////////////////////; 241/// Add an isotope for this element. All isotopes have to be isotopes of the same element.; 242 ; 243void TGeoElement::AddIsotope(TGeoIsotope *isotope, Double_t relativeAbundance); 244{; 245 if (!fIsotopes) {; 246 fNisotopes = 1;; 247 fIsotopes = new TObjArray();; 248 fAbundances = new Double_t[1];; 249 }; 250 Int_t ncurrent = 0;; 251 TGeoIsotope *isocrt;; 252 for (ncurrent = 0; ncurrent < fNisotopes; ncurrent++); 253 if (!fIsotopes->At(ncurrent)); 254 break;; 255 if (ncurrent == fNisotopes) {; 256 // User requested overwriting a standard element - we need to extend dynamically the support arrays; 257 Double_t *abundances = new Double_t[fNisotopes + 1];; 258 memcpy(abundances, fAbundances, fNisotopes * sizeof(Double_t));; 259 delete[] fAbundances;; 260 fAbundances = abundances;; 261 fNisotopes++;; 262 }; 263 // Check Z of the new isotope; 264 if ((fZ != 0) && (isotope->GetZ() != fZ)) {; 265 Fatal(""AddIsotope"", ""Trying to add isotope %s with different Z to the same element %s"", isotope->GetName(),; 266 GetName());; 267 return;; 268 } else {; 269 fZ = isotope->GetZ();; 270 }; 271 fIsotopes->Add(isotope);; 272 fAbundances[ncurrent] = relativeAbundance;; 273 if (ncurrent == fNisotopes - 1) {; 274 Double_t weight = 0.0;; 275 Double_t aeff = 0.0;; 276 Double_t neff = 0.0;; 277 for (Int_t i = 0; i < fNisotopes; i++) {; 278 isocrt = (TGeoIsotope *)fIsotopes->At(i);; 279 aeff += fAbundances[i] * isocrt->GetA();; 280 neff += fAbundances[i] * isocrt->GetN();; 281 weight += fAbundances[i];; 282 }; 283 aeff /= weight;; 284 neff /= weight;; 285 fN = (Int_t)neff;; 286 fA = aeff;; 287 }; 288 ComputeDerivedQuantities();; 289}; 290 ; 291//////////////",MatchSource.WIKI,doc/master/TGeoElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html
Performance,optimiz,optimized,"imitive(out, ""h"");; 1323 else; 1324 elem->SavePrimitive(out);; 1325 i++;; 1326 }; 1327 out.close();; 1328}; 1329 ; 1330////////////////////////////////////////////////////////////////////////////////; 1331/// Search an element by symbol or full name; 1332/// Exact matching; 1333 ; 1334TGeoElement *TGeoElementTable::FindElement(const char *name) const; 1335{; 1336 TGeoElement *elem;; 1337 elem = (TGeoElement *)fList->FindObject(name);; 1338 if (elem); 1339 return elem;; 1340 // Search case insensitive by element name; 1341 TString s(name);; 1342 s.ToUpper();; 1343 elem = (TGeoElement *)fList->FindObject(s.Data());; 1344 if (elem); 1345 return elem;; 1346 // Search by full name; 1347 TIter next(fList);; 1348 while ((elem = (TGeoElement *)next())) {; 1349 if (s == elem->GetTitle()); 1350 return elem;; 1351 }; 1352 return nullptr;; 1353}; 1354 ; 1355////////////////////////////////////////////////////////////////////////////////; 1356/// Find existing isotope by name. Not optimized for a big number of isotopes.; 1357 ; 1358TGeoIsotope *TGeoElementTable::FindIsotope(const char *name) const; 1359{; 1360 if (!fIsotopes); 1361 return nullptr;; 1362 return (TGeoIsotope *)fIsotopes->FindObject(name);; 1363}; 1364 ; 1365////////////////////////////////////////////////////////////////////////////////; 1366/// Retrieve a radionuclide by ENDF code.; 1367 ; 1368TGeoElementRN *TGeoElementTable::GetElementRN(Int_t ENDFcode) const; 1369{; 1370 if (!HasRNElements()) {; 1371 TGeoElementTable *table = (TGeoElementTable *)this;; 1372 table->ImportElementsRN();; 1373 if (!fListRN); 1374 return nullptr;; 1375 }; 1376 ElementRNMap_t::const_iterator it = fElementsRN.find(ENDFcode);; 1377 if (it != fElementsRN.end()); 1378 return it->second;; 1379 return nullptr;; 1380}; 1381 ; 1382////////////////////////////////////////////////////////////////////////////////; 1383/// Retrieve a radionuclide by a, z, and isomeric state.; 1384 ; 1385TGeoElementRN *TGeoElementTable::GetElementRN(Int_t a, Int_",MatchSource.WIKI,doc/master/TGeoElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html
Testability,log,logarithm,"ing.h:704; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TVirtualGeoPainter::DrawBatemanSolvirtual void DrawBatemanSol(TGeoBatemanSol *sol, Option_t *option="""")=0; bool; double; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; nconst Int_t nDefinition legend1.C:16; TGeant4Unit::alpha_rcl2static constexpr double alpha_rcl2Definition TGeant4PhysicalConstants.h:95; TGeant4Unit::fine_structure_conststatic constexpr double fine_structure_constDefinition TGeant4PhysicalConstants.h:90; TGeoUnit::fine_structure_conststatic constexpr double fine_structure_constDefinition TGeoPhysicalConstants.h:90; TGeoUnit::alpha_rcl2static constexpr double alpha_rcl2Definition TGeoPhysicalConstants.h:95; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::Naconstexpr Double_t Na()Avogadro constant (Avogadro's Number) in .Definition TMath.h:284; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TGeoBatemanSol::BtCoef_tDefinition TGeoElement.h:288; TGeoBatemanSol::BtCoef_t::cnDouble_t cnDefinition TGeoElement.h:289; TGeoBatemanSol::BtCoef_t::lambdaDouble_t lambdaDefinition TGeoElement.h:290. geomgeomsrcTGeoElement.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoElement_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html
Availability,down,down,"h:365; TGeoElemIter::SetLimitRatiovoid SetLimitRatio(Double_t limit)Definition TGeoElement.h:387; TGeoElemIter::GetBranchTObjArray * GetBranch() constDefinition TGeoElement.h:381; TGeoElemIter::GetRatioDouble_t GetRatio() constDefinition TGeoElement.h:385; TGeoElemIter::fElemconst TGeoElementRN * fElemDefinition TGeoElement.h:361; TGeoElemIter::fBranchTObjArray * fBranchDefinition TGeoElement.h:362; TGeoElemIter::NextTGeoElementRN * Next()Return next element.Definition TGeoElement.cxx:941; TGeoElemIter::operator=TGeoElemIter & operator=(const TGeoElemIter &iter)Assignment.Definition TGeoElement.cxx:867; TGeoElemIter::~TGeoElemItervirtual ~TGeoElemIter()Destructor.Definition TGeoElement.cxx:858; TGeoElemIter::operator()TGeoElementRN * operator()()() operator.Definition TGeoElement.cxx:887; TGeoElemIter::fTopconst TGeoElementRN * fTopDefinition TGeoElement.h:360; TGeoElemIter::fLimitRatioDouble_t fLimitRatioDefinition TGeoElement.h:364; TGeoElemIter::UpTGeoElementRN * Up()Go upwards from the current location until the next branching, then down.Definition TGeoElement.cxx:895; TGeoElemIter::GetElementconst TGeoElementRN * GetElement() constDefinition TGeoElement.h:383; TGeoElemIter::DownTGeoElementRN * Down(Int_t ibranch)Go downwards from current level via ibranch as low in the tree as possible.Definition TGeoElement.cxx:921; TGeoElemIter::GetTopconst TGeoElementRN * GetTop() constDefinition TGeoElement.h:382; TGeoElemIter::fLevelInt_t fLevelDefinition TGeoElement.h:363; TGeoElemIter::TGeoElemIterTGeoElemIter()Definition TGeoElement.h:368; TGeoElemIter::GetLevelInt_t GetLevel() constDefinition TGeoElement.h:384; TGeoElementRNClass representing a radionuclidevoid TGeoManager::SetDefaultRootUnits() { if ( fgDefaultUnits == kRo...Definition TGeoElement.h:132; TGeoElementRN::fNatAbunDouble_t fNatAbunDefinition TGeoElement.h:139; TGeoElementRN::AddRatiovoid AddRatio(TGeoBatemanSol &ratio)Adds a proportion ratio to the existing one.Definition TGeoElement.cxx:684; TGeoElementR",MatchSource.WIKI,doc/master/TGeoElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8h_source.html
Performance,optimiz,optimized,"le() constChecks status of element table.Definition TGeoElement.cxx:1286; TGeoElementTable::Printvoid Print(Option_t *option="""") const overridePrint table of elements.Definition TGeoElement.cxx:1398; TGeoElementTable::ImportElementsRNvoid ImportElementsRN()Creates the list of radionuclides.Definition TGeoElement.cxx:1247; TGeoElementTable::ElementRNMap_tstd::map< Int_t, TGeoElementRN * > ElementRNMap_tDefinition TGeoElement.h:408; TGeoElementTable::GetElementTGeoElement * GetElement(Int_t z)Definition TGeoElement.h:435; TGeoElementTable::AddElementvoid AddElement(const char *name, const char *title, Int_t z, Double_t a)Add an element to the table. Obsolete.Definition TGeoElement.cxx:1058; TGeoElementTable::fNelementsRNInt_t fNelementsRNDefinition TGeoElement.h:402; TGeoElementTable::GetElementsRNTObjArray * GetElementsRN() constDefinition TGeoElement.h:438; TGeoElementTable::FindIsotopeTGeoIsotope * FindIsotope(const char *name) constFind existing isotope by name. Not optimized for a big number of isotopes.Definition TGeoElement.cxx:1358; TGeoElementTable::BuildDefaultElementsvoid BuildDefaultElements()Creates the default element table.Definition TGeoElement.cxx:1123; TGeoElementTable::GetNelementsInt_t GetNelements() constDefinition TGeoElement.h:442; TGeoElementTable::TGeoElementTableTGeoElementTable()default constructorDefinition TGeoElement.cxx:980; TGeoElementTable::FindElementTGeoElement * FindElement(const char *name) constSearch an element by symbol or full name Exact matching.Definition TGeoElement.cxx:1334; TGeoElementBase class for chemical elements.Definition TGeoElement.h:36; TGeoElement::fADouble_t fADefinition TGeoElement.h:43; TGeoElement::NInt_t N() constDefinition TGeoElement.h:69; TGeoElement::GetSpecificActivityvirtual Double_t GetSpecificActivity() constDefinition TGeoElement.h:79; TGeoElement::fNisotopesInt_t fNisotopesDefinition TGeoElement.h:42; TGeoElement::fRadTsaiDouble_t fRadTsaiDefinition TGeoElement.h:47; TGeoElement::IsDefinedBool_t Is",MatchSource.WIKI,doc/master/TGeoElement_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoElement_8h_source.html
Availability,down,down," instance the; 141previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; 142itself to ROOT and the logical/physical structures will become immediately browsable.; 143The ROOT browser will display starting from the geometry folder : the list of; 144transformations and media, the top volume and the top logical node. These last; 145two can be fully expanded, any intermediate volume/node in the browser being subject; 146of direct access context menu operations (right mouse button click). All user; 147utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; 148context menu.; 149 ; 150\image html geom_browser.jpg; 151 ; 152### Drawing the geometry; 153 ; 154 Any logical volume can be drawn via TGeoVolume::Draw() member function.; 155This can be directly accessed from the context menu of the volume object; 156directly from the browser.; 157 There are several drawing options that can be set with; 158TGeoManager::SetVisOption(Int_t opt) method :; 159 ; 160#### opt=0; 161 only the content of the volume is drawn, N levels down (default N=3).; 162 This is the default behavior. The number of levels to be drawn can be changed; 163 via TGeoManager::SetVisLevel(Int_t level) method.; 164 ; 165\image html geom_frame0.jpg; 166 ; 167#### opt=1; 168 the final leaves (e.g. daughters with no containment) of the branch; 169 starting from volume are drawn down to the current number of levels.; 170 WARNING : This mode is memory consuming; 171 depending of the size of geometry, so drawing from top level within this mode; 172 should be handled with care for expensive geometries. In future there will be; 173 a limitation on the maximum number of nodes to be visualized.; 174 ; 175\image html geom_frame1.jpg; 176 ; 177#### opt=2; 178 only the clicked volume is visualized. This is automatically set by; 179 TGeoVolume::DrawOnly() method; 180 ; 181#### opt=3 - only a given path is visualized. This is automatically set by; 182 TGeoVolume::DrawP",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
Deployability,update,updates,"me is visualized. This is automatically set by; 179 TGeoVolume::DrawOnly() method; 180 ; 181#### opt=3 - only a given path is visualized. This is automatically set by; 182 TGeoVolume::DrawPath(const char *path) method; 183 ; 184 The current view can be exploded in cartesian, cylindrical or spherical; 185coordinates :; 186 TGeoManager::SetExplodedView(Int_t opt). Options may be :; 187- 0 - default (no bombing); 188- 1 - cartesian coordinates. The bomb factor on each axis can be set with; 189 TGeoManager::SetBombX(Double_t bomb) and corresponding Y and Z.; 190- 2 - bomb in cylindrical coordinates. Only the bomb factors on Z and R; 191 are considered; 192 \image html geom_frameexp.jpg; 193 ; 194- 3 - bomb in radial spherical coordinate : TGeoManager::SetBombR(); 195 ; 196Volumes themselves support different visualization settings :; 197 - TGeoVolume::SetVisibility() : set volume visibility.; 198 - TGeoVolume::VisibleDaughters() : set daughters visibility.; 199All these actions automatically updates the current view if any.; 200 ; 201### Checking the geometry; 202 ; 203 Several checking methods are accessible from the volume context menu. They; 204generally apply only to the visible parts of the drawn geometry in order to; 205ease geometry checking, and their implementation is in the TGeoChecker class; 206from the painting package.; 207 ; 208#### Checking a given point.; 209 Can be called from TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z).; 210This method is drawing the daughters of the volume containing the point one; 211level down, printing the path to the deepest physical node holding this point.; 212It also computes the closest distance to any boundary. The point will be drawn; 213in red, as well as a sphere having this closest distance as radius. In case a; 214non-zero distance is given by the user as fifth argument of CheckPoint, this; 215distance will be used as radius of the safety sphere.; 216 ; 217\image html geom_checkpoint.jpg; 218 ; 219#### Sho",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
Energy Efficiency,energy,energy,"////////////////////////////////////////////////////////////////////////; 1302/// Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; 1303/// materials defined by arrays A,Z and WMAT, having an unique id.; 1304 ; 1305TGeoMaterial *; 1306TGeoManager::Mixture(const char *name, Double_t *a, Double_t *z, Double_t dens, Int_t nelem, Double_t *wmat, Int_t uid); 1307{; 1308 return TGeoBuilder::Instance(this)->Mixture(name, a, z, dens, nelem, wmat, uid);; 1309}; 1310 ; 1311////////////////////////////////////////////////////////////////////////////////; 1312/// Create tracking medium; 1313///; 1314/// - numed tracking medium number assigned; 1315/// - name tracking medium name; 1316/// - nmat material number; 1317/// - isvol sensitive volume flag; 1318/// - ifield magnetic field; 1319/// - fieldm max. field value (kilogauss); 1320/// - tmaxfd max. angle due to field (deg/step); 1321/// - stemax max. step allowed; 1322/// - deemax max. fraction of energy lost in a step; 1323/// - epsil tracking precision (cm); 1324/// - stmin min. step due to continuous processes (cm); 1325///; 1326/// - ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; 1327/// - ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; 1328/// performed with g3helix; ifield = 3 if tracking performed with g3helx3.; 1329///; 1330 ; 1331TGeoMedium *TGeoManager::Medium(const char *name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm,; 1332 Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); 1333{; 1334 return TGeoBuilder::Instance(this)->Medium(name, numed, nmat, isvol, ifield, fieldm, tmaxfd, stemax, deemax, epsil,; 1335 stmin);; 1336}; 1337 ; 1338////////////////////////////////////////////////////////////////////////////////; 1339/// Create a node called `<name_nr>` pointing to the volume called `<name>`; 1340/// as daughter of the volume called `<mother>` (gspos). The relative matrix is; 1341/// made of : a ",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
Integrability,depend,depending,"ties of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; 148context menu.; 149 ; 150\image html geom_browser.jpg; 151 ; 152### Drawing the geometry; 153 ; 154 Any logical volume can be drawn via TGeoVolume::Draw() member function.; 155This can be directly accessed from the context menu of the volume object; 156directly from the browser.; 157 There are several drawing options that can be set with; 158TGeoManager::SetVisOption(Int_t opt) method :; 159 ; 160#### opt=0; 161 only the content of the volume is drawn, N levels down (default N=3).; 162 This is the default behavior. The number of levels to be drawn can be changed; 163 via TGeoManager::SetVisLevel(Int_t level) method.; 164 ; 165\image html geom_frame0.jpg; 166 ; 167#### opt=1; 168 the final leaves (e.g. daughters with no containment) of the branch; 169 starting from volume are drawn down to the current number of levels.; 170 WARNING : This mode is memory consuming; 171 depending of the size of geometry, so drawing from top level within this mode; 172 should be handled with care for expensive geometries. In future there will be; 173 a limitation on the maximum number of nodes to be visualized.; 174 ; 175\image html geom_frame1.jpg; 176 ; 177#### opt=2; 178 only the clicked volume is visualized. This is automatically set by; 179 TGeoVolume::DrawOnly() method; 180 ; 181#### opt=3 - only a given path is visualized. This is automatically set by; 182 TGeoVolume::DrawPath(const char *path) method; 183 ; 184 The current view can be exploded in cartesian, cylindrical or spherical; 185coordinates :; 186 TGeoManager::SetExplodedView(Int_t opt). Options may be :; 187- 0 - default (no bombing); 188- 1 - cartesian coordinates. The bomb factor on each axis can be set with; 189 TGeoManager::SetBombX(Double_t bomb) and corresponding Y and Z.; 190- 2 - bomb in cylindrical coordinates. Only the bomb factors on Z and R; 191 are considered; 192 \image html geom_frameexp.jpg; 193 ; 194- 3 - bomb in radial spherica",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
Modifiability,inherit,inherits,"graph. Any volume in the logical graph; 63can become the actual top volume at run time (see TGeoManager::SetTopVolume()).; 64All functionalities of the modeler will behave in this case as if only the; 65corresponding branch starting from this volume is the registered geometry.; 66 ; 67\image html geom_graf.jpg; 68 ; 69 A given volume can be positioned several times in the geometry. A volume; 70can be divided according default or user-defined patterns, creating automatically; 71the list of division nodes inside. The elementary volumes created during the; 72dividing process follow the same scheme as usual volumes, therefore it is possible; 73to position further geometrical structures inside or to divide them further more; 74(see TGeoVolume::Divide()).; 75 ; 76 The primitive shapes supported by the package are basically the GEANT3; 77shapes (see class TGeoShape), arbitrary wedges with eight vertices on two parallel; 78planes. All basic primitives inherits from class TGeoBBox since the bounding box; 79of a solid is essential for the tracking algorithms. They also implement the; 80virtual methods defined in the virtual class TGeoShape (point and segment; 81classification). User-defined primitives can be directly plugged into the modeler; 82provided that they override these methods. Composite shapes will be soon supported; 83by the modeler. In order to build a TGeoCompositeShape, one will have to define; 84first the primitive components. The object that handle boolean; 85operations among components is called TGeoBoolCombinator and it has to be; 86constructed providing a string boolean expression between the components names.; 87 ; 88 ; 89## Example for building a simple geometry; 90 ; 91Begin_Macro(source); 92../../../tutorials/geom/rootgeom.C; 93End_Macro; 94 ; 95## TGeoManager - the manager class for the geometry package.; 96 ; 97 TGeoManager class is embedding all the API needed for building and tracking; 98a geometry. It defines a global pointer (gGeoManager) in order ",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
Performance,cache,cache,"etry; 90 ; 91Begin_Macro(source); 92../../../tutorials/geom/rootgeom.C; 93End_Macro; 94 ; 95## TGeoManager - the manager class for the geometry package.; 96 ; 97 TGeoManager class is embedding all the API needed for building and tracking; 98a geometry. It defines a global pointer (gGeoManager) in order to be fully; 99accessible from external code. The mechanism of handling multiple geometries; 100at the same time will be soon implemented.; 101 ; 102 TGeoManager is the owner of all geometry objects defined in a session,; 103therefore users must not try to control their deletion. It contains lists of; 104media, materials, transformations, shapes and volumes. Logical nodes (positioned; 105volumes) are created and destroyed by the TGeoVolume class. Physical; 106nodes and their global transformations are subjected to a caching mechanism; 107due to the sometimes very large memory requirements of logical graph expansion.; 108The caching mechanism is triggered by the total number of physical instances; 109of volumes and the cache manager is a client of TGeoManager. The manager class; 110also controls the painter client. This is linked with ROOT graphical libraries; 111loaded on demand in order to control visualization actions.; 112 ; 113## Rules for building a valid geometry; 114 ; 115 A given geometry can be built in various ways, but there are mandatory steps; 116that have to be followed in order to be validated by the modeler. There are; 117general rules : volumes needs media and shapes in order to be created,; 118both container and containee volumes must be created before linking them together,; 119and the relative transformation matrix must be provided. All branches must; 120have an upper link point otherwise they will not be considered as part of the; 121geometry. Visibility or tracking properties of volumes can be provided both; 122at build time or after geometry is closed, but global visualization settings; 123(see TGeoPainter class) should not be provided at build ",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
Safety,detect,detector,". ROOT: geom/geom/src/TGeoManager.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGeoManager.cxx. Go to the documentation of this file. 1// @(#)root/geom:$Id$; 2// Author: Andrei Gheata 25/10/01; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TGeoManager; 13\ingroup Geometry_classes; 14 ; 15The manager class for any TGeo geometry. Provides user; 16interface for geometry creation, navigation, state querying,; 17visualization, IO, geometry checking and other utilities.; 18 ; 19## General architecture; 20 ; 21 The ROOT geometry package is a tool designed for building, browsing,; 22tracking and visualizing a detector geometry. The code is independent from; 23other external MC for simulation, therefore it does not contain any; 24constraints related to physics. However, the package defines a number of; 25hooks for tracking, such as media, materials, magnetic field or track state flags,; 26in order to allow interfacing to tracking MC's. The final goal is to be; 27able to use the same geometry for several purposes, such as tracking,; 28reconstruction or visualization, taking advantage of the ROOT features; 29related to bookkeeping, I/O, histogramming, browsing and GUI's.; 30 ; 31 The geometrical modeler is the most important component of the package and; 32it provides answers to the basic questions like ""Where am I ?"" or ""How far; 33from the next boundary ?"", but also to more complex ones like ""How far from; 34the closest surface ?"" or ""Which is the next crossing along a helix ?"".; 35 ; 36 The architecture of the modeler is a combination between a GEANT-like; 37containment scheme and ",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
Security,validat,validated,"al code. The mechanism of handling multiple geometries; 100at the same time will be soon implemented.; 101 ; 102 TGeoManager is the owner of all geometry objects defined in a session,; 103therefore users must not try to control their deletion. It contains lists of; 104media, materials, transformations, shapes and volumes. Logical nodes (positioned; 105volumes) are created and destroyed by the TGeoVolume class. Physical; 106nodes and their global transformations are subjected to a caching mechanism; 107due to the sometimes very large memory requirements of logical graph expansion.; 108The caching mechanism is triggered by the total number of physical instances; 109of volumes and the cache manager is a client of TGeoManager. The manager class; 110also controls the painter client. This is linked with ROOT graphical libraries; 111loaded on demand in order to control visualization actions.; 112 ; 113## Rules for building a valid geometry; 114 ; 115 A given geometry can be built in various ways, but there are mandatory steps; 116that have to be followed in order to be validated by the modeler. There are; 117general rules : volumes needs media and shapes in order to be created,; 118both container and containee volumes must be created before linking them together,; 119and the relative transformation matrix must be provided. All branches must; 120have an upper link point otherwise they will not be considered as part of the; 121geometry. Visibility or tracking properties of volumes can be provided both; 122at build time or after geometry is closed, but global visualization settings; 123(see TGeoPainter class) should not be provided at build time, otherwise the; 124drawing package will be loaded. There is also a list of specific rules :; 125positioned daughters should not extrude their mother or intersect with sisters; 126unless this is specified (see TGeoVolume::AddNodeOverlap()), the top volume; 127(containing all geometry tree) must be specified before closing the geometry; ",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
Testability,log,logical,"tions like ""Where am I ?"" or ""How far; 33from the next boundary ?"", but also to more complex ones like ""How far from; 34the closest surface ?"" or ""Which is the next crossing along a helix ?"".; 35 ; 36 The architecture of the modeler is a combination between a GEANT-like; 37containment scheme and a normal CSG binary tree at the level of shapes. An; 38important common feature of all detector geometry descriptions is the; 39mother-daughter concept. This is the most natural approach when tracking; 40is concerned and imposes a set of constraints to the way geometry is defined.; 41Constructive solid geometry composition is used only in order to create more; 42complex shapes from an existing set of primitives through boolean operations.; 43This feature is not implemented yet but in future full definition of boolean; 44expressions will be supported.; 45 ; 46 Practically every geometry defined in GEANT style can be mapped by the modeler.; 47The basic components used for building the logical hierarchy of the geometry; 48are called ""volumes"" and ""nodes"". Volumes (sometimes called ""solids"") are fully; 49defined geometrical objects having a given shape and medium and possibly; 50containing a list of nodes. Nodes represent just positioned instances of volumes; 51inside a container volume and they are not directly defined by user. They are; 52automatically created as a result of adding one volume inside other or dividing; 53a volume. The geometrical transformation hold by nodes is always defined with; 54respect to their mother (relative positioning). Reflection matrices are allowed.; 55All volumes have to be fully aware of their containees when the geometry is; 56closed. They will build additional structures (voxels) in order to fasten-up; 57the search algorithms. Finally, nodes can be regarded as bidirectional links; 58between containers and containees objects.; 59 ; 60 The structure defined in this way is a graph structure since volumes are; 61replicable (same volume can become d",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
Usability,simpl,simple," inside or to divide them further more; 74(see TGeoVolume::Divide()).; 75 ; 76 The primitive shapes supported by the package are basically the GEANT3; 77shapes (see class TGeoShape), arbitrary wedges with eight vertices on two parallel; 78planes. All basic primitives inherits from class TGeoBBox since the bounding box; 79of a solid is essential for the tracking algorithms. They also implement the; 80virtual methods defined in the virtual class TGeoShape (point and segment; 81classification). User-defined primitives can be directly plugged into the modeler; 82provided that they override these methods. Composite shapes will be soon supported; 83by the modeler. In order to build a TGeoCompositeShape, one will have to define; 84first the primitive components. The object that handle boolean; 85operations among components is called TGeoBoolCombinator and it has to be; 86constructed providing a string boolean expression between the components names.; 87 ; 88 ; 89## Example for building a simple geometry; 90 ; 91Begin_Macro(source); 92../../../tutorials/geom/rootgeom.C; 93End_Macro; 94 ; 95## TGeoManager - the manager class for the geometry package.; 96 ; 97 TGeoManager class is embedding all the API needed for building and tracking; 98a geometry. It defines a global pointer (gGeoManager) in order to be fully; 99accessible from external code. The mechanism of handling multiple geometries; 100at the same time will be soon implemented.; 101 ; 102 TGeoManager is the owner of all geometry objects defined in a session,; 103therefore users must not try to control their deletion. It contains lists of; 104media, materials, transformations, shapes and volumes. Logical nodes (positioned; 105volumes) are created and destroyed by the TGeoVolume class. Physical; 106nodes and their global transformations are subjected to a caching mechanism; 107due to the sometimes very large memory requirements of logical graph expansion.; 108The caching mechanism is triggered by the total number of phy",MatchSource.WIKI,doc/master/TGeoManager_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html
Integrability,depend,dependency,". ROOT: geom/geom/inc/TGeoManager.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Variables ; TGeoManager.h File Reference. #include <mutex>; #include <thread>; #include <map>; #include ""TNamed.h""; #include ""TObjArray.h""; #include ""TGeoNavigator.h"". Include dependency graph for TGeoManager.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGeoManager;  The manager class for any TGeo geometry. More...;  . Variables; R__EXTERN TGeoManager * gGeoManager;  . Variable Documentation. ◆ gGeoManager. R__EXTERN TGeoManager* gGeoManager. Definition at line 608 of file TGeoManager.h. geomgeomincTGeoManager.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:15 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoManager_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h.html
Availability,error,error,"TObjArray *fArrayPNE; //! array of physical node entries; 140 Int_t fSizePNEId; // size of the array of unique ID's for PN entries; 141 Int_t fNPNEId; // number of PN entries having a unique ID; 142 Int_t *fKeyPNEId; //[fSizePNEId] array of uid values for PN entries; 143 Int_t *fValuePNEId; //[fSizePNEId] array of pointers to PN entries with ID's; 144 Int_t fMaxThreads; //! Max number of threads; 145 Bool_t fMultiThread; //! Flag for multi-threading; 146 Int_t fRaytraceMode; //! Raytrace mode: 0=normal, 1=pass through, 2=transparent; 147 Bool_t fUsePWNav; // Activate usage of parallel world in navigation; 148 TGeoParallelWorld *fParallelWorld; // Parallel world; 149 ConstPropMap_t fProperties; // Map of user-defined constant properties; 150 //--- private methods; 151 Bool_t IsLoopingVolumes() const { return fLoopVolumes; }; 152 void Init();; 153 Bool_t InitArrayPNE() const;; 154 Bool_t InsertPNEId(Int_t uid, Int_t ientry);; 155 void SetLoopVolumes(Bool_t flag = kTRUE) { fLoopVolumes = flag; }; 156 void UpdateElements();; 157 void Voxelize(Option_t *option = nullptr);; 158 ; 159public:; 160 // constructors; 161 TGeoManager();; 162 TGeoManager(const char *name, const char *title);; 163 // destructor; 164 ~TGeoManager() override;; 165 //--- adding geometrical objects; 166 Int_t AddMaterial(const TGeoMaterial *material);; 167 Int_t AddOverlap(const TNamed *ovlp);; 168 Int_t AddRegion(TGeoRegion *region);; 169 Int_t AddTransformation(const TGeoMatrix *matrix);; 170 Int_t AddShape(const TGeoShape *shape);; 171 Int_t AddTrack(Int_t id, Int_t pdgcode, TObject *particle = nullptr);; 172 Int_t AddTrack(TVirtualGeoTrack *track);; 173 Int_t AddVolume(TGeoVolume *volume);; 174 TGeoNavigator *AddNavigator();; 175 Bool_t AddProperty(const char *property, Double_t value);; 176 Double_t GetProperty(const char *name, Bool_t *error = nullptr) const;; 177 Double_t GetProperty(size_t i, TString &name, Bool_t *error = nullptr) const;; 178 Int_t GetNproperties() const { return fProperties.",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
Integrability,message,messages,"/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TGeoManager; 13#define ROOT_TGeoManager; 14 ; 15#include <mutex>; 16#include <thread>; 17#include <map>; 18 ; 19#include ""TNamed.h""; 20#include ""TObjArray.h""; 21#include ""TGeoNavigator.h""; 22 ; 23// forward declarations; 24class TVirtualGeoTrack;; 25class TGeoNode;; 26class TGeoPhysicalNode;; 27class TGeoPNEntry;; 28class TGeoVolume;; 29class TGeoVolumeMulti;; 30class TGeoMatrix;; 31class TGeoHMatrix;; 32class TGeoMaterial;; 33class TGeoMedium;; 34class TGeoShape;; 35class TVirtualGeoPainter;; 36class THashList;; 37class TGeoParallelWorld;; 38class TGeoRegion;; 39class TGDMLMatrix;; 40class TGeoOpticalSurface;; 41class TGeoSkinSurface;; 42class TGeoBorderSurface;; 43 ; 44class TGeoManager : public TNamed {; 45public:; 46 enum EDefaultUnits { kG4Units = 0, kRootUnits = 1 };; 47 ; 48protected:; 49 static std::mutex fgMutex; //! mutex for navigator booking in MT mode; 50 static Bool_t fgLock; //! Lock preventing a second geometry to be loaded; 51 static Int_t fgVerboseLevel; //! Verbosity level for Info messages (no IO).; 52 static Int_t fgMaxLevel; //! Maximum level in geometry; 53 static Int_t fgMaxDaughters; //! Maximum number of daughters; 54 static Int_t fgMaxXtruVert; //! Maximum number of Xtru vertices; 55 static UInt_t fgExportPrecision; //! Precision to be used in ASCII exports; 56 static EDefaultUnits fgDefaultUnits; //! Default units in GDML if not explicit in some tags; 57 ; 58 TGeoManager(const TGeoManager &) = delete;; 59 TGeoManager &operator=(const TGeoManager &) = delete;; 60 ; 61private:; 62 Double_t fPhimin; //! lowest range for phi cut; 63 Double_t fPhimax; //! high",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
Performance,load,loaded,"/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TGeoManager; 13#define ROOT_TGeoManager; 14 ; 15#include <mutex>; 16#include <thread>; 17#include <map>; 18 ; 19#include ""TNamed.h""; 20#include ""TObjArray.h""; 21#include ""TGeoNavigator.h""; 22 ; 23// forward declarations; 24class TVirtualGeoTrack;; 25class TGeoNode;; 26class TGeoPhysicalNode;; 27class TGeoPNEntry;; 28class TGeoVolume;; 29class TGeoVolumeMulti;; 30class TGeoMatrix;; 31class TGeoHMatrix;; 32class TGeoMaterial;; 33class TGeoMedium;; 34class TGeoShape;; 35class TVirtualGeoPainter;; 36class THashList;; 37class TGeoParallelWorld;; 38class TGeoRegion;; 39class TGDMLMatrix;; 40class TGeoOpticalSurface;; 41class TGeoSkinSurface;; 42class TGeoBorderSurface;; 43 ; 44class TGeoManager : public TNamed {; 45public:; 46 enum EDefaultUnits { kG4Units = 0, kRootUnits = 1 };; 47 ; 48protected:; 49 static std::mutex fgMutex; //! mutex for navigator booking in MT mode; 50 static Bool_t fgLock; //! Lock preventing a second geometry to be loaded; 51 static Int_t fgVerboseLevel; //! Verbosity level for Info messages (no IO).; 52 static Int_t fgMaxLevel; //! Maximum level in geometry; 53 static Int_t fgMaxDaughters; //! Maximum number of daughters; 54 static Int_t fgMaxXtruVert; //! Maximum number of Xtru vertices; 55 static UInt_t fgExportPrecision; //! Precision to be used in ASCII exports; 56 static EDefaultUnits fgDefaultUnits; //! Default units in GDML if not explicit in some tags; 57 ; 58 TGeoManager(const TGeoManager &) = delete;; 59 TGeoManager &operator=(const TGeoManager &) = delete;; 60 ; 61private:; 62 Double_t fPhimin; //! lowest range for phi cut; 63 Double_t fPhimax; //! high",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
Safety,safe,safety," void SetVisDensity(Double_t dens = 0.01); // *MENU*; 241 void SetVisLevel(Int_t level = 3); // *MENU*; 242 void SetVisOption(Int_t option = 0);; 243 void ViewLeaves(Bool_t flag = kTRUE); // *TOGGLE* *GETTER=IsVisLeaves; 244 void SaveAttributes(const char *filename = ""tgeoatt.C""); // *MENU*; 245 void RestoreMasterVolume(); // *MENU*; 246 void SetMaxVisNodes(Int_t maxnodes = 10000); // *MENU*; 247 //--- geometry checking; 248 void AnimateTracks(Double_t tmin = 0, Double_t tmax = 5E-8, Int_t nframes = 200, Option_t *option = ""/*""); // *MENU*; 249 void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); // *MENU*; 250 void CheckBoundaryReference(Int_t icheck = -1);; 251 void CheckGeometryFull(Int_t ntracks = 1000000, Double_t vx = 0., Double_t vy = 0., Double_t vz = 0.,; 252 Option_t *option = ""ob""); // *MENU*; 253 void CheckGeometry(Option_t *option = """");; 254 void CheckOverlaps(Double_t ovlp = 0.1, Option_t *option = """"); // *MENU*; 255 void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t *option = """", Double_t safety = 0.); // *MENU*; 256 void CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option);; 257 void ConvertReflections();; 258 void DrawCurrentPoint(Int_t color = 2); // *MENU*; 259 void DrawTracks(Option_t *option = """"); // *MENU*; 260 void SetParticleName(const char *pname) { fParticleName = pname; }; 261 const char *GetParticleName() const { return fParticleName.Data(); }; 262 void DrawPath(const char *path, Option_t *option = """");; 263 void PrintOverlaps() const; // *MENU*; 264 void RandomPoints(const TGeoVolume *vol, Int_t npoints = 10000, Option_t *option = """");; 265 void RandomRays(Int_t nrays = 1000, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0,; 266 const char *target_vol = nullptr, Bool_t check_norm = kFALSE);; 267 TGeoNode *SamplePoints(Int_t npoints, Double_t &dist, Double_t epsil = 1E-5, const char *g3path = """");; 268 void SetNmeshPoints(Int_t npoints = 1000);; 269 void Se",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
Security,hash,hash,"9 NavigatorsMap_t fNavigators; //! Map between thread id's and navigator arrays; 120 static ThreadsMap_t *fgThreadId; //! Thread id's map; 121 static Int_t fgNumThreads; //! Number of registered threads; 122 static Bool_t fgLockNavigators; //! Lock existing navigators; 123 TGeoNavigator *fCurrentNavigator; //! current navigator; 124 TGeoVolume *fCurrentVolume; //! current volume; 125 TGeoVolume *fTopVolume; //! top level volume in geometry; 126 TGeoNode *fTopNode; //! top physical node; 127 TGeoVolume *fMasterVolume; // master volume; 128 TGeoHMatrix *fGLMatrix; // matrix to be used for view transformations; 129 TObjArray *fUniqueVolumes; //-> list of unique volumes; 130 TGeoShape *fClippingShape; //! clipping shape for raytracing; 131 TGeoElementTable *fElementTable; //! table of elements; 132 ; 133 Int_t fNLevel; // maximum accepted level in geometry; 134 TGeoVolume *fPaintVolume; //! volume currently painted; 135 TGeoVolume *fUserPaintVolume; //!; 136 THashList *fHashVolumes; //! hash list of volumes providing fast search; 137 THashList *fHashGVolumes; //! hash list of group volumes providing fast search; 138 THashList *fHashPNE; //-> hash list of physical node entries; 139 mutable TObjArray *fArrayPNE; //! array of physical node entries; 140 Int_t fSizePNEId; // size of the array of unique ID's for PN entries; 141 Int_t fNPNEId; // number of PN entries having a unique ID; 142 Int_t *fKeyPNEId; //[fSizePNEId] array of uid values for PN entries; 143 Int_t *fValuePNEId; //[fSizePNEId] array of pointers to PN entries with ID's; 144 Int_t fMaxThreads; //! Max number of threads; 145 Bool_t fMultiThread; //! Flag for multi-threading; 146 Int_t fRaytraceMode; //! Raytrace mode: 0=normal, 1=pass through, 2=transparent; 147 Bool_t fUsePWNav; // Activate usage of parallel world in navigation; 148 TGeoParallelWorld *fParallelWorld; // Parallel world; 149 ConstPropMap_t fProperties; // Map of user-defined constant properties; 150 //--- private methods; 151 Bool_t IsLoopingVol",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
Testability,test,testNo,"e = ""tgeoatt.C""); // *MENU*; 245 void RestoreMasterVolume(); // *MENU*; 246 void SetMaxVisNodes(Int_t maxnodes = 10000); // *MENU*; 247 //--- geometry checking; 248 void AnimateTracks(Double_t tmin = 0, Double_t tmax = 5E-8, Int_t nframes = 200, Option_t *option = ""/*""); // *MENU*; 249 void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); // *MENU*; 250 void CheckBoundaryReference(Int_t icheck = -1);; 251 void CheckGeometryFull(Int_t ntracks = 1000000, Double_t vx = 0., Double_t vy = 0., Double_t vz = 0.,; 252 Option_t *option = ""ob""); // *MENU*; 253 void CheckGeometry(Option_t *option = """");; 254 void CheckOverlaps(Double_t ovlp = 0.1, Option_t *option = """"); // *MENU*; 255 void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t *option = """", Double_t safety = 0.); // *MENU*; 256 void CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option);; 257 void ConvertReflections();; 258 void DrawCurrentPoint(Int_t color = 2); // *MENU*; 259 void DrawTracks(Option_t *option = """"); // *MENU*; 260 void SetParticleName(const char *pname) { fParticleName = pname; }; 261 const char *GetParticleName() const { return fParticleName.Data(); }; 262 void DrawPath(const char *path, Option_t *option = """");; 263 void PrintOverlaps() const; // *MENU*; 264 void RandomPoints(const TGeoVolume *vol, Int_t npoints = 10000, Option_t *option = """");; 265 void RandomRays(Int_t nrays = 1000, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0,; 266 const char *target_vol = nullptr, Bool_t check_norm = kFALSE);; 267 TGeoNode *SamplePoints(Int_t npoints, Double_t &dist, Double_t epsil = 1E-5, const char *g3path = """");; 268 void SetNmeshPoints(Int_t npoints = 1000);; 269 void SetCheckedNode(TGeoNode *node);; 270 void Test(Int_t npoints = 1000000, Option_t *option = """"); // *MENU*; 271 void TestOverlaps(const char *path = """"); // *MENU*; 272 Double_t Weight(Double_t precision = 0.01, Option_t *option = ""va""); // *MENU*; 273 ; 274 //--- GE",MatchSource.WIKI,doc/master/TGeoManager_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoManager_8h_source.html
Availability,error,error,"xtensionABC for user objects attached to TGeoVolume or TGeoNode.Definition TGeoExtension.h:17; TGeoExtension::Grabvirtual TGeoExtension * Grab()=0; TGeoExtension::Releasevirtual void Release() const =0; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::GetDefaultUnitsstatic EDefaultUnits GetDefaultUnits()Definition TGeoManager.cxx:4314; TGeoManager::GetElementTableTGeoElementTable * GetElementTable()Returns material table. Creates it if not existing.Definition TGeoManager.cxx:3624; TGeoManager::SetDefaultUnitsstatic void SetDefaultUnits(EDefaultUnits new_value)Definition TGeoManager.cxx:4319; TGeoManager::AddMaterialInt_t AddMaterial(const TGeoMaterial *material)Add a material to the list. Returns index of the material in list.Definition TGeoManager.cxx:616; TGeoManager::EDefaultUnitsEDefaultUnitsDefinition TGeoManager.h:46; TGeoManager::kRootUnits@ kRootUnitsDefinition TGeoManager.h:46; TGeoManager::GetPropertyDouble_t GetProperty(const char *name, Bool_t *error=nullptr) constGet a user-defined property.Definition TGeoManager.cxx:656; TGeoManager::GetGDMLMatrixTGDMLMatrix * GetGDMLMatrix(const char *name) constGet GDML matrix with a given name;.Definition TGeoManager.cxx:2003; TGeoManager::GetListOfMaterialsTList * GetListOfMaterials() constDefinition TGeoManager.h:471; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMaterial::GetConstPropertyDouble_t GetConstProperty(const char *property, Bool_t *error=nullptr) constDefinition TGeoMaterial.cxx:392; TGeoMaterial::SetUserExtensionvoid SetUserExtension(TGeoExtension *ext)Connect user-defined extension to the material.Definition TGeoMaterial.cxx:346; TGeoMaterial::GetCerenkovPropertiesvirtual TObject * GetCerenkovProperties() constDefinition TGeoMaterial.h:112; TGeoMaterial::fStateEGeoMaterialState fStateDefinition TGeoMaterial.h:48; TGeoMaterial::GetPointerNameconst char * GetPointerName() constProvide a pointer name containing uid.Definition TGe",MatchSource.WIKI,doc/master/TGeoMaterial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html
Deployability,release,released," gm.fTemperature;; 307 fPressure = gm.fPressure;; 308 fState = gm.fState;; 309 fShader = gm.fShader;; 310 fCerenkov = gm.fCerenkov;; 311 fElement = gm.fElement;; 312 fUserExtension = gm.fUserExtension->Grab();; 313 fFWExtension = gm.fFWExtension->Grab();; 314 fProperties.SetOwner();; 315 TIter next(&fProperties);; 316 TNamed *property;; 317 while ((property = (TNamed *)next())); 318 fProperties.Add(new TNamed(*property));; 319 }; 320 return *this;; 321}; 322 ; 323////////////////////////////////////////////////////////////////////////////////; 324/// Destructor; 325 ; 326TGeoMaterial::~TGeoMaterial(); 327{; 328 if (fUserExtension) {; 329 fUserExtension->Release();; 330 fUserExtension = nullptr;; 331 }; 332 if (fFWExtension) {; 333 fFWExtension->Release();; 334 fFWExtension = nullptr;; 335 }; 336}; 337 ; 338////////////////////////////////////////////////////////////////////////////////; 339/// Connect user-defined extension to the material. The material ""grabs"" a copy, so; 340/// the original object can be released by the producer. Release the previously; 341/// connected extension if any.; 342///; 343/// NOTE: This interface is intended for user extensions and is guaranteed not; 344/// to be used by TGeo; 345 ; 346void TGeoMaterial::SetUserExtension(TGeoExtension *ext); 347{; 348 if (fUserExtension); 349 fUserExtension->Release();; 350 fUserExtension = nullptr;; 351 if (ext); 352 fUserExtension = ext->Grab();; 353}; 354 ; 355//_____________________________________________________________________________; 356const char *TGeoMaterial::GetPropertyRef(const char *property) const; 357{; 358 // Find reference for a given property; 359 TNamed *prop = (TNamed *)fProperties.FindObject(property);; 360 return (prop) ? prop->GetTitle() : nullptr;; 361}; 362 ; 363//_____________________________________________________________________________; 364TGDMLMatrix *TGeoMaterial::GetProperty(const char *property) const; 365{; 366 // Find reference for a given property; 367 TNamed *prop ",MatchSource.WIKI,doc/master/TGeoMaterial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html
Energy Efficiency,power,power,"string class.Definition TString.h:139; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; bool; double; int; TGeant4Unit::fine_structure_conststatic constexpr double fine_structure_constDefinition TGeant4PhysicalConstants.h:90; TGeant4Unit::cm2static constexpr double cm2Definition TGeant4SystemOfUnits.h:113; TGeant4Unit::Avogadrostatic constexpr double AvogadroDefinition TGeant4PhysicalConstants.h:43; TGeant4Unit::cmstatic constexpr double cmDefinition TGeant4SystemOfUnits.h:112; TGeoUnit::amustatic constexpr double amuDefinition TGeoPhysicalConstants.h:77; TGeoUnit::cmstatic constexpr double cmDefinition TGeoSystemOfUnits.h:116; TGeoUnit::fine_structure_conststatic constexpr double fine_structure_constDefinition TGeoPhysicalConstants.h:90; TGeoUnit::cm2static constexpr double cm2Definition TGeoSystemOfUnits.h:117; TGeoUnit::Avogadrostatic constexpr double AvogadroDefinition TGeoPhysicalConstants.h:43; TGeoUnit::gstatic constexpr double gDefinition TGeoSystemOfUnits.h:207; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123. geomgeomsrcTGeoMaterial.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoMaterial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html
Integrability,interface,interface,"d(new TNamed(*property));; 319 }; 320 return *this;; 321}; 322 ; 323////////////////////////////////////////////////////////////////////////////////; 324/// Destructor; 325 ; 326TGeoMaterial::~TGeoMaterial(); 327{; 328 if (fUserExtension) {; 329 fUserExtension->Release();; 330 fUserExtension = nullptr;; 331 }; 332 if (fFWExtension) {; 333 fFWExtension->Release();; 334 fFWExtension = nullptr;; 335 }; 336}; 337 ; 338////////////////////////////////////////////////////////////////////////////////; 339/// Connect user-defined extension to the material. The material ""grabs"" a copy, so; 340/// the original object can be released by the producer. Release the previously; 341/// connected extension if any.; 342///; 343/// NOTE: This interface is intended for user extensions and is guaranteed not; 344/// to be used by TGeo; 345 ; 346void TGeoMaterial::SetUserExtension(TGeoExtension *ext); 347{; 348 if (fUserExtension); 349 fUserExtension->Release();; 350 fUserExtension = nullptr;; 351 if (ext); 352 fUserExtension = ext->Grab();; 353}; 354 ; 355//_____________________________________________________________________________; 356const char *TGeoMaterial::GetPropertyRef(const char *property) const; 357{; 358 // Find reference for a given property; 359 TNamed *prop = (TNamed *)fProperties.FindObject(property);; 360 return (prop) ? prop->GetTitle() : nullptr;; 361}; 362 ; 363//_____________________________________________________________________________; 364TGDMLMatrix *TGeoMaterial::GetProperty(const char *property) const; 365{; 366 // Find reference for a given property; 367 TNamed *prop = (TNamed *)fProperties.FindObject(property);; 368 if (!prop); 369 return nullptr;; 370 return gGeoManager->GetGDMLMatrix(prop->GetTitle());; 371}; 372 ; 373//_____________________________________________________________________________; 374TGDMLMatrix *TGeoMaterial::GetProperty(Int_t i) const; 375{; 376 // Find reference for a given property; 377 TNamed *prop = (TNamed *)fProperties.At(i);; 378 i",MatchSource.WIKI,doc/master/TGeoMaterial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html
Safety,avoid,avoid,"< "" absl = "" << fIntLen << "";"" << std::endl;; 605 ; 606 out << "" auto "" << name << "" = new TGeoMaterial(\"""" << GetName() << ""\"", a, z, density, radl, absl);"" << std::endl;; 607 out << "" "" << name << ""->SetIndex("" << GetIndex() << "");"" << std::endl;; 608 SetBit(TGeoMaterial::kMatSavePrimitive);; 609}; 610 ; 611////////////////////////////////////////////////////////////////////////////////; 612/// Get some default color related to this material.; 613 ; 614Int_t TGeoMaterial::GetDefaultColor() const; 615{; 616 Int_t id = 1 + gGeoManager->GetListOfMaterials()->IndexOf(this);; 617 return (2 + id % 6);; 618}; 619 ; 620////////////////////////////////////////////////////////////////////////////////; 621/// Get a pointer to the element this material is made of.; 622/// This second call is to avoid warnings to not call a virtual; 623/// method from the constructor; 624 ; 625TGeoElement *TGeoMaterial::GetElement() const; 626{; 627 if (fElement); 628 return fElement;; 629 TGeoElementTable *table = gGeoManager->GetElementTable();; 630 return table->GetElement(Int_t(fZ));; 631}; 632 ; 633////////////////////////////////////////////////////////////////////////////////; 634/// Get a pointer to the element this material is made of.; 635 ; 636TGeoElement *TGeoMaterial::GetElement(Int_t) const; 637{; 638 if (fElement); 639 return fElement;; 640 TGeoElementTable *table = gGeoManager->GetElementTable();; 641 return table->GetElement(Int_t(fZ));; 642}; 643 ; 644////////////////////////////////////////////////////////////////////////////////; 645/// Single interface to get element properties.; 646 ; 647void TGeoMaterial::GetElementProp(Double_t &a, Double_t &z, Double_t &w, Int_t); 648{; 649 a = fA;; 650 z = fZ;; 651 w = 1.;; 652}; 653 ; 654////////////////////////////////////////////////////////////////////////////////; 655/// Retrieve material index in the list of materials; 656 ; 657Int_t TGeoMaterial::GetIndex(); 658{; 659 if (fIndex >= 0); 660 return fIndex;; 661 TList *matlist = g",MatchSource.WIKI,doc/master/TGeoMaterial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html
Testability,log,logarithm,"string class.Definition TString.h:139; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; bool; double; int; TGeant4Unit::fine_structure_conststatic constexpr double fine_structure_constDefinition TGeant4PhysicalConstants.h:90; TGeant4Unit::cm2static constexpr double cm2Definition TGeant4SystemOfUnits.h:113; TGeant4Unit::Avogadrostatic constexpr double AvogadroDefinition TGeant4PhysicalConstants.h:43; TGeant4Unit::cmstatic constexpr double cmDefinition TGeant4SystemOfUnits.h:112; TGeoUnit::amustatic constexpr double amuDefinition TGeoPhysicalConstants.h:77; TGeoUnit::cmstatic constexpr double cmDefinition TGeoSystemOfUnits.h:116; TGeoUnit::fine_structure_conststatic constexpr double fine_structure_constDefinition TGeoPhysicalConstants.h:90; TGeoUnit::cm2static constexpr double cm2Definition TGeoSystemOfUnits.h:117; TGeoUnit::Avogadrostatic constexpr double AvogadroDefinition TGeoPhysicalConstants.h:43; TGeoUnit::gstatic constexpr double gDefinition TGeoSystemOfUnits.h:207; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123. geomgeomsrcTGeoMaterial.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoMaterial_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html
Integrability,depend,dependency,". ROOT: geom/geom/inc/TGeoMaterial.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Variables ; TGeoMaterial.h File Reference. #include <TNamed.h>; #include <TAttFill.h>; #include <TList.h>; #include ""TGeoElement.h"". Include dependency graph for TGeoMaterial.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGeoMaterial;  Base class describing materials. More...;  ; class  TGeoMixture;  Mixtures of elements. More...;  . Variables; static const Double_t STP_pressure = 6.32420e+8;  ; static const Double_t STP_temperature = 273.15;  . Variable Documentation. ◆ STP_pressure. const Double_t STP_pressure = 6.32420e+8. static . Definition at line 32 of file TGeoMaterial.h. ◆ STP_temperature. const Double_t STP_temperature = 273.15. static . Definition at line 31 of file TGeoMaterial.h. geomgeomincTGeoMaterial.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:15 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoMaterial_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8h.html
Availability,error,error,"ial(const char *name, TGeoElement *elem, Double_t rho);; 69 ; 70 // destructor; 71 ~TGeoMaterial() override;; 72 // methods; 73 static Double_t Coulomb(Double_t z);; 74 // radioactive mixture evolution; 75 virtual TGeoMaterial *DecayMaterial(Double_t time, Double_t precision = 0.001);; 76 virtual void FillMaterialEvolution(TObjArray *population, Double_t precision = 0.001);; 77 // getters & setters; 78 bool AddProperty(const char *property, const char *ref);; 79 bool AddConstProperty(const char *property, const char *ref);; 80 Int_t GetNproperties() const { return fProperties.GetSize(); }; 81 Int_t GetNconstProperties() const { return fConstProperties.GetSize(); }; 82 const char *GetPropertyRef(const char *property) const;; 83 const char *GetPropertyRef(Int_t i) const; 84 {; 85 return (fProperties.At(i) ? fProperties.At(i)->GetTitle() : nullptr);; 86 }; 87 Double_t GetConstProperty(const char *property, Bool_t *error = nullptr) const;; 88 Double_t GetConstProperty(Int_t i, Bool_t *error = nullptr) const;; 89 const char *GetConstPropertyRef(const char *property) const;; 90 const char *GetConstPropertyRef(Int_t i) const; 91 {; 92 return (fConstProperties.At(i) ? fConstProperties.At(i)->GetTitle() : nullptr);; 93 }; 94 TList const &GetProperties() const { return fProperties; }; 95 TList const &GetConstProperties() const { return fConstProperties; }; 96 TGDMLMatrix *GetProperty(const char *name) const;; 97 TGDMLMatrix *GetProperty(Int_t i) const;; 98 virtual Int_t GetByteCount() const { return sizeof(*this); }; 99 virtual Double_t GetA() const { return fA; }; 100 virtual Double_t GetZ() const { return fZ; }; 101 virtual Int_t GetDefaultColor() const;; 102 virtual Double_t GetDensity() const { return fDensity; }; 103 virtual Int_t GetNelements() const { return 1; }; 104 TGeoElement *GetElement() const;; 105 virtual TGeoElement *GetElement(Int_t i) const;; 106 virtual void GetElementProp(Double_t &a, Double_t &z, Double_t &w, Int_t i = 0);; 107 TGeoElement *GetBaseElement",MatchSource.WIKI,doc/master/TGeoMaterial_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8h_source.html
Integrability,interface,interface,"1343; TGeoMaterial::GetConstPropertyRefconst char * GetConstPropertyRef(const char *property) constDefinition TGeoMaterial.cxx:384; TGeoMaterial::GetNconstPropertiesInt_t GetNconstProperties() constDefinition TGeoMaterial.h:81; TGeoMaterial::IsMixturevirtual Bool_t IsMixture() constDefinition TGeoMaterial.h:124; TGeoMaterial::fPressureDouble_t fPressureDefinition TGeoMaterial.h:47; TGeoMaterial::GetByteCountvirtual Int_t GetByteCount() constDefinition TGeoMaterial.h:98; TGeoMaterial::SetFWExtensionvoid SetFWExtension(TGeoExtension *ext)Connect framework defined extension to the material.Definition TGeoMaterial.cxx:449; TGeoMaterial::AddConstPropertybool AddConstProperty(const char *property, const char *ref)Definition TGeoMaterial.cxx:430; TGeoMaterial::fTemperatureDouble_t fTemperatureDefinition TGeoMaterial.h:46; TGeoMaterial::GetConstPropertiesTList const & GetConstProperties() constDefinition TGeoMaterial.h:95; TGeoMaterial::GetElementPropvirtual void GetElementProp(Double_t &a, Double_t &z, Double_t &w, Int_t i=0)Single interface to get element properties.Definition TGeoMaterial.cxx:647; TGeoMaterial::DecayMaterialvirtual TGeoMaterial * DecayMaterial(Double_t time, Double_t precision=0.001)Create the material representing the decay product of this material at a given time.Definition TGeoMaterial.cxx:671; TGeoMaterial::fPropertiesTList fPropertiesDefinition TGeoMaterial.h:52; TGeoMaterial::SetStatevoid SetState(EGeoMaterialState state)Definition TGeoMaterial.h:149; TGeoMaterial::GetStateEGeoMaterialState GetState() constDefinition TGeoMaterial.h:116; TGeoMaterial::AddPropertybool AddProperty(const char *property, const char *ref)Definition TGeoMaterial.cxx:418; TGeoMaterial::GetTemperatureDouble_t GetTemperature() constDefinition TGeoMaterial.h:114; TGeoMaterial::GetSpecificActivityvirtual Double_t GetSpecificActivity(Int_t) constDefinition TGeoMaterial.h:117; TGeoMaterial::GetNelementsvirtual Int_t GetNelements() constDefinition TGeoMaterial.h:103; TGeoMaterial",MatchSource.WIKI,doc/master/TGeoMaterial_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8h_source.html
Availability,error,error,");; 159 TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; 160 t2->Subtract(&t1);; 161~~~; 162 ; 163#### Rotations; 164 Represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; 165 Rotations can be defined either by Euler angles, either, by GEANT3 angles :; 166 ; 167~~~ {.cpp}; 168 TGeoRotation *r1 = new TGeoRotation();; 169 r1->SetAngles(phi, theta, psi); // all angles in degrees; 170~~~; 171 ; 172 This represent the composition of : first a rotation about Z axis with; 173 angle phi, then a rotation with theta about the rotated X axis, and; 174 finally a rotation with psi about the new Z axis.; 175 ; 176~~~ {.cpp}; 177 r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); 178~~~; 179 ; 180 This is a rotation defined in GEANT3 style. Theta and phi are the spherical; 181 angles of each axis of the rotated coordinate system with respect to the; 182 initial one. This construction allows definition of malformed rotations,; 183 e.g. not orthogonal. A check is performed and an error message is issued; 184 in this case.; 185 ; 186 Specific utilities : determinant, inverse.; 187 ; 188#### Scale transformations; 189 Represent a scale shrinking/enlargement. Data; 190 members :Double_t fScale[3]. Not fully implemented yet.; 191 ; 192#### Combined transformations; 193Represent a rotation followed by a translation.; 194Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; 195 ; 196~~~ {.cpp}; 197 TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; 198 TGeoTranslation trans;; 199 ...; 200 TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; 201 TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot); 202~~~; 203 ; 204 ; 205#### TGeoGenTrans; 206Combined transformations including a scale. Not implemented.; 207 ; 208#### TGeoIdentity; 209A generic singleton matrix representing a identity transformation; 210 NOTE: identified by the global variable gGeoIdentity.; 211*/; 212 ; 213#include <iostream>; 214#include ""TObjArray.h""; 215 ; 216#include ""TGeoMan",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
Integrability,interface,interface,"`, `tz` are the translation components; 72 - `sx`, `sy`, `sz` are arbitrary scale constants on each axis,; 73 ; 74 The disadvantage in using this approach is that computation for 4x4 matrices; 75is expensive. Even combining two translation would become a multiplication; 76of their corresponding matrices, which is quite an undesired effect. On the; 77other hand, it is not a good idea to store a translation as a block of 16; 78numbers. We have therefore chosen to implement each basic transformation type; 79as a class deriving from the same basic abstract class and handling its specific; 80data and point/vector transformation algorithms.; 81 ; 82\image html geom_transf.jpg; 83 ; 84### The base class TGeoMatrix defines abstract metods for:; 85 ; 86#### translation, rotation and scale getters. Every derived class stores only; 87 its specific data, e.g. a translation stores an array of 3 doubles and a; 88 rotation an array of 9. However, asking which is the rotation array of a; 89 TGeoTranslation through the base TGeoMatrix interface is a legal operation.; 90 The answer in this case is a pointer to a global constant array representing; 91 an identity rotation.; 92 ; 93~~~ {.cpp}; 94 Double_t *TGeoMatrix::GetTranslation(); 95 Double_t *TGeoMatrix::GetRotation(); 96 Double_t *TGeoMatrix::GetScale(); 97~~~; 98 ; 99#### MasterToLocal() and LocalToMaster() point and vector transformations :; 100 ; 101~~~ {.cpp}; 102 void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); 103 void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); 104 void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); 105 void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); 106~~~; 107 ; 108 These allow correct conversion also for reflections.; 109 ; 110#### Transformation type getters :; 111 ; 112~~~ {.cpp}; 113 Bool_t TGeoMatrix::IsIdentity(); 114 Bool_t TGeoMatrix::IsTranslation(); 115 Bool_t TGeoMatrix::IsRotation(); 116 Bool",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
Modifiability,variab,variable,"nate system with respect to the; 182 initial one. This construction allows definition of malformed rotations,; 183 e.g. not orthogonal. A check is performed and an error message is issued; 184 in this case.; 185 ; 186 Specific utilities : determinant, inverse.; 187 ; 188#### Scale transformations; 189 Represent a scale shrinking/enlargement. Data; 190 members :Double_t fScale[3]. Not fully implemented yet.; 191 ; 192#### Combined transformations; 193Represent a rotation followed by a translation.; 194Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; 195 ; 196~~~ {.cpp}; 197 TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; 198 TGeoTranslation trans;; 199 ...; 200 TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; 201 TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot); 202~~~; 203 ; 204 ; 205#### TGeoGenTrans; 206Combined transformations including a scale. Not implemented.; 207 ; 208#### TGeoIdentity; 209A generic singleton matrix representing a identity transformation; 210 NOTE: identified by the global variable gGeoIdentity.; 211*/; 212 ; 213#include <iostream>; 214#include ""TObjArray.h""; 215 ; 216#include ""TGeoManager.h""; 217#include ""TGeoMatrix.h""; 218#include ""TMath.h""; 219 ; 220TGeoIdentity *gGeoIdentity = nullptr;; 221const Int_t kN3 = 3 * sizeof(Double_t);; 222const Int_t kN9 = 9 * sizeof(Double_t);; 223 ; 224// statics and globals; 225 ; 226ClassImp(TGeoMatrix);; 227 ; 228////////////////////////////////////////////////////////////////////////////////; 229/// dummy constructor; 230 ; 231TGeoMatrix::TGeoMatrix(); 232{; 233 ResetBit(kGeoMatrixBits);; 234}; 235 ; 236////////////////////////////////////////////////////////////////////////////////; 237/// copy constructor; 238 ; 239TGeoMatrix::TGeoMatrix(const TGeoMatrix &other) : TNamed(other); 240{; 241 ResetBit(kGeoRegistered);; 242}; 243 ; 244////////////////////////////////////////////////////////////////////////////////; 245/// Constructor; 246 ; 247TGeoMatrix::TGeoMatri",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
Performance,perform,performance,". ROOT: geom/geom/src/TGeoMatrix.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGeoMatrix.cxx. Go to the documentation of this file. 1// @(#)root/geom:$Id$; 2// Author: Andrei Gheata 25/10/01; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TGeoMatrix; 13\ingroup Geometry_classes; 14 ; 15Geometrical transformation package.; 16 ; 17 All geometrical transformations handled by the modeller are provided as a; 18built-in package. This was designed to minimize memory requirements and; 19optimize performance of point/vector master-to-local and local-to-master; 20computation. We need to have in mind that a transformation in TGeo has 2; 21major use-cases. The first one is for defining the placement of a volume; 22with respect to its container reference frame. This frame will be called; 23'master' and the frame of the positioned volume - 'local'. If T is a; 24transformation used for positioning volume daughters, then:; 25 ; 26~~~ {.cpp}; 27 MASTER = T * LOCAL; 28~~~; 29 ; 30 Therefore a local-to-master conversion will be performed by using T, while; 31a master-to-local by using its inverse. The second use case is the computation; 32of the global transformation of a given object in the geometry. Since the; 33geometry is built as 'volumes-inside-volumes', this global transformation; 34represent the pile-up of all local transformations in the corresponding; 35branch. The conversion from the global reference frame and the given object; 36is also called master-to-local, but it is handled by the manager class.; 37 A general homogenous transformation is defined as a 4x4 matrix embedding; 38a r",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
Testability,test,test,"72{; 973 if (&other == this); 974 return kTRUE;; 975 const Double_t *rot = GetRotationMatrix();; 976 const Double_t *orot = other.GetRotationMatrix();; 977 for (auto i = 0; i < 9; i++); 978 if (TMath::Abs(rot[i] - orot[i]) > 1.E-10); 979 return kFALSE;; 980 return kTRUE;; 981}; 982 ; 983////////////////////////////////////////////////////////////////////////////////; 984/// Return a temporary inverse of this.; 985 ; 986TGeoHMatrix TGeoRotation::Inverse() const; 987{; 988 TGeoHMatrix h;; 989 h = *this;; 990 h.ResetBit(kGeoRegistered);; 991 Double_t newrot[9];; 992 newrot[0] = fRotationMatrix[0];; 993 newrot[1] = fRotationMatrix[3];; 994 newrot[2] = fRotationMatrix[6];; 995 newrot[3] = fRotationMatrix[1];; 996 newrot[4] = fRotationMatrix[4];; 997 newrot[5] = fRotationMatrix[7];; 998 newrot[6] = fRotationMatrix[2];; 999 newrot[7] = fRotationMatrix[5];; 1000 newrot[8] = fRotationMatrix[8];; 1001 h.SetRotation(newrot);; 1002 return h;; 1003}; 1004 ; 1005////////////////////////////////////////////////////////////////////////////////; 1006/// Perform orthogonality test for rotation.; 1007 ; 1008Bool_t TGeoRotation::IsValid() const; 1009{; 1010 const Double_t *r = fRotationMatrix;; 1011 Double_t cij;; 1012 for (Int_t i = 0; i < 2; i++) {; 1013 for (Int_t j = i + 1; j < 3; j++) {; 1014 // check columns; 1015 cij = TMath::Abs(r[i] * r[j] + r[i + 3] * r[j + 3] + r[i + 6] * r[j + 6]);; 1016 if (cij > 1E-4); 1017 return kFALSE;; 1018 // check rows; 1019 cij = TMath::Abs(r[3 * i] * r[3 * j] + r[3 * i + 1] * r[3 * j + 1] + r[3 * i + 2] * r[3 * j + 2]);; 1020 if (cij > 1E-4); 1021 return kFALSE;; 1022 }; 1023 }; 1024 return kTRUE;; 1025}; 1026 ; 1027////////////////////////////////////////////////////////////////////////////////; 1028/// reset data members; 1029 ; 1030void TGeoRotation::Clear(Option_t *); 1031{; 1032 memcpy(fRotationMatrix, kIdentityMatrix, kN9);; 1033 ResetBit(kGeoRotation);; 1034}; 1035 ; 1036//////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
Usability,simpl,simple,"to its container reference frame. This frame will be called; 23'master' and the frame of the positioned volume - 'local'. If T is a; 24transformation used for positioning volume daughters, then:; 25 ; 26~~~ {.cpp}; 27 MASTER = T * LOCAL; 28~~~; 29 ; 30 Therefore a local-to-master conversion will be performed by using T, while; 31a master-to-local by using its inverse. The second use case is the computation; 32of the global transformation of a given object in the geometry. Since the; 33geometry is built as 'volumes-inside-volumes', this global transformation; 34represent the pile-up of all local transformations in the corresponding; 35branch. The conversion from the global reference frame and the given object; 36is also called master-to-local, but it is handled by the manager class.; 37 A general homogenous transformation is defined as a 4x4 matrix embedding; 38a rotation, a translation and a scale. The advantage of this description; 39is that each basic transformation can be represented as a homogenous matrix,; 40composition being performed as simple matrix multiplication.; 41 ; 42 Rotation: Inverse rotation:; 43 ; 44~~~ {.cpp}; 45 r11 r12 r13 0 r11 r21 r31 0; 46 r21 r22 r23 0 r12 r22 r32 0; 47 r31 r32 r33 0 r13 r23 r33 0; 48 0 0 0 1 0 0 0 1; 49~~~; 50 ; 51 Translation: Inverse translation:; 52 ; 53~~~ {.cpp}; 54 1 0 0 tx 1 0 0 -tx; 55 0 1 0 ty 0 1 0 -ty; 56 0 0 1 tz 0 0 1 -tz; 57 0 0 0 1 0 0 0 1; 58~~~; 59 ; 60 Scale: Inverse scale:; 61 ; 62~~~ {.cpp}; 63 sx 0 0 0 1/sx 0 0 0; 64 0 sy 0 0 0 1/sy 0 0; 65 0 0 sz 0 0 0 1/sz 0; 66 0 0 0 1 0 0 0 1; 67~~~; 68 ; 69 where:; 70 - `rij` are the 3x3 rotation matrix components,; 71 - `tx`, `ty`, `tz` are the translation components; 72 - `sx`, `sy`, `sz` are arbitrary scale constants on each axis,; 73 ; 74 The disadvantage in using this approach is that computation for 4x4 matrices; 75is expensive. Even combining two translation would become a multiplication; 76of their corresponding matrices, which is quite an undesired effect.",MatchSource.WIKI,doc/master/TGeoMatrix_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html
Integrability,depend,dependency,". ROOT: geom/geom/inc/TGeoMatrix.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Variables ; TGeoMatrix.h File Reference. #include ""TNamed.h"". Include dependency graph for TGeoMatrix.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGeoCombiTrans;  Class describing rotation + translation. More...;  ; class  TGeoGenTrans;  Most general transformation, holding a translation, a rotation and a scale. More...;  ; class  TGeoHMatrix;  Matrix class used for computing global transformations Should NOT be used for node definition. More...;  ; class  TGeoIdentity;  An identity transformation. More...;  ; class  TGeoMatrix;  Geometrical transformation package. More...;  ; class  TGeoRotation;  Class describing rotations. More...;  ; class  TGeoScale;  Class describing scale transformations. More...;  ; class  TGeoTranslation;  Class describing translations. More...;  . Variables; R__EXTERN TGeoIdentity * gGeoIdentity;  ; const Double_t kIdentityMatrix [3 *3] = {1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0};  ; const Double_t kNullVector [3] = {0.0, 0.0, 0.0};  ; const Double_t kUnitScale [3] = {1.0, 1.0, 1.0};  . Variable Documentation. ◆ gGeoIdentity. R__EXTERN TGeoIdentity* gGeoIdentity. Definition at line 537 of file TGeoMatrix.h. ◆ kIdentityMatrix. const Double_t kIdentityMatrix[3 *3] = {1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0}. Definition at line 26 of file TGeoMatrix.h. ◆ kNullVector. const Double_t kNullVector[3] = {0.0, 0.0, 0.0}. Definition at line 24 of file TGeoMatrix.h. ◆ kUnitScale. const Double_t kUnitScale[3] = {1.0, 1.0, 1.0}. Definition at line 28 of file TGeoMatrix.h. geomgeomincTGeoMatrix.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:15 (GVA Time) using Doxygen 1.9.",MatchSource.WIKI,doc/master/TGeoMatrix_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8h.html
Availability,down,down,"2 void MasterToLocalVect(const Double_t *master, Double_t *local) const override; 433 {; 434 memcpy(local, master, 3 * sizeof(Double_t));; 435 }; 436 void MasterToLocalBomb(const Double_t *master, Double_t *local) const override; 437 {; 438 TGeoIdentity::MasterToLocal(master, local);; 439 }; 440 ; 441 const Double_t *GetTranslation() const override { return &kNullVector[0]; }; 442 const Double_t *GetRotationMatrix() const override { return &kIdentityMatrix[0]; }; 443 const Double_t *GetScale() const override { return &kUnitScale[0]; }; 444 void SavePrimitive(std::ostream &, Option_t * = """") override {}; 445 ; 446 ClassDefOverride(TGeoIdentity, 1) // identity transformation class; 447};; 448 ; 449////////////////////////////////////////////////////////////////////////////; 450// //; 451// TGeoHMatrix - Matrix class used for computing global transformations //; 452// Should NOT be used for node definition. An instance of this class //; 453// is generally used to pile-up local transformations starting from //; 454// the top level physical node, down to the current node. //; 455// //; 456////////////////////////////////////////////////////////////////////////////; 457 ; 458class TGeoHMatrix : public TGeoMatrix {; 459private:; 460 Double_t fTranslation[3]; // translation component; 461 Double_t fRotationMatrix[9]; // rotation matrix; 462 Double_t fScale[3]; // scale component; 463 ; 464public:; 465 TGeoHMatrix();; 466 TGeoHMatrix(const TGeoHMatrix &other) : TGeoHMatrix((TGeoMatrix &)other) {}; 467 TGeoHMatrix(const TGeoMatrix &matrix);; 468 TGeoHMatrix(const char *name);; 469 ~TGeoHMatrix() override;; 470 ; 471 TGeoHMatrix &operator=(const TGeoHMatrix &other) { return TGeoHMatrix::operator=((TGeoMatrix &)other); }; 472 TGeoHMatrix &operator=(const TGeoMatrix *other);; 473 TGeoHMatrix &operator=(const TGeoMatrix &other);; 474 TGeoHMatrix &operator*=(const TGeoMatrix &other);; 475 TGeoHMatrix operator*(const TGeoMatrix &other) const;; 476 Bool_t operator==(const TGeoMatrix",MatchSource.WIKI,doc/master/TGeoMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8h_source.html
Performance,perform,performes,"otation with the one specified by ROT.Definition TGeoMatrix.cxx:1411; TGeoRotation::RotateYvoid RotateY(Double_t angle) overrideRotate about Y axis of the master frame with angle expressed in degrees.Definition TGeoMatrix.cxx:1121; TGeoRotation::operator==Bool_t operator==(const TGeoRotation &other) constIs-equal operator.Definition TGeoMatrix.cxx:971; TGeoRotation::SetMatrixvoid SetMatrix(const Double_t *rot)Definition TGeoMatrix.h:230; TGeoRotation::RotateZvoid RotateZ(Double_t angle) overrideRotate about Z axis of the master frame with angle expressed in degrees.Definition TGeoMatrix.cxx:1144; TGeoRotation::LocalToMastervoid LocalToMaster(const Double_t *local, Double_t *master) const overrideconvert a point by multiplying its column vector (x, y, z, 1) to matrix inverseDefinition TGeoMatrix.cxx:1067; TGeoRotation::operator*=TGeoRotation & operator*=(const TGeoRotation &other)Composition.Definition TGeoMatrix.cxx:946; TGeoRotation::CheckMatrixvoid CheckMatrix()performes an orthogonality check and finds if the matrix is a reflection Warning(""CheckMatrix"",...Definition TGeoMatrix.cxx:1379; TGeoRotation::ReflectYvoid ReflectY(Bool_t leftside, Bool_t rotonly=kFALSE) overrideMultiply by a reflection respect to ZX.Definition TGeoMatrix.cxx:1185; TGeoRotation::GetPhiRotationDouble_t GetPhiRotation(Bool_t fixX=kFALSE) constReturns rotation angle about Z axis in degrees.Definition TGeoMatrix.cxx:1054; TGeoRotation::FastRotZvoid FastRotZ(const Double_t *sincos)Perform a rotation about Z having the sine/cosine of the rotation angle.Definition TGeoMatrix.cxx:1039; TGeoRotation::GetInversevoid GetInverse(Double_t *invmat) constGet the inverse rotation matrix (which is simply the transpose)Definition TGeoMatrix.cxx:1393; TGeoRotation::DeterminantDouble_t Determinant() constcomputes determinant of the rotation matrixDefinition TGeoMatrix.cxx:1364; TGeoRotation::GetAnglesvoid GetAngles(Double_t &theta1, Double_t &phi1, Double_t &theta2, Double_t &phi2, Double_t &theta3, Double_t",MatchSource.WIKI,doc/master/TGeoMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8h_source.html
Testability,test,test,"; TGeoRotation::ReflectYvoid ReflectY(Bool_t leftside, Bool_t rotonly=kFALSE) overrideMultiply by a reflection respect to ZX.Definition TGeoMatrix.cxx:1185; TGeoRotation::GetPhiRotationDouble_t GetPhiRotation(Bool_t fixX=kFALSE) constReturns rotation angle about Z axis in degrees.Definition TGeoMatrix.cxx:1054; TGeoRotation::FastRotZvoid FastRotZ(const Double_t *sincos)Perform a rotation about Z having the sine/cosine of the rotation angle.Definition TGeoMatrix.cxx:1039; TGeoRotation::GetInversevoid GetInverse(Double_t *invmat) constGet the inverse rotation matrix (which is simply the transpose)Definition TGeoMatrix.cxx:1393; TGeoRotation::DeterminantDouble_t Determinant() constcomputes determinant of the rotation matrixDefinition TGeoMatrix.cxx:1364; TGeoRotation::GetAnglesvoid GetAngles(Double_t &theta1, Double_t &phi1, Double_t &theta2, Double_t &phi2, Double_t &theta3, Double_t &phi3) constRetrieve rotation angles.Definition TGeoMatrix.cxx:1310; TGeoRotation::IsValidBool_t IsValid() constPerform orthogonality test for rotation.Definition TGeoMatrix.cxx:1008; TGeoRotation::MasterToLocalvoid MasterToLocal(const Double_t *master, Double_t *local) const overrideconvert a point by multiplying its column vector (x, y, z, 1) to matrixDefinition TGeoMatrix.cxx:1078; TGeoRotation::MakeCloneTGeoMatrix * MakeClone() const overrideMake a clone of this matrix.Definition TGeoMatrix.cxx:1089; TGeoRotation::operator*TGeoRotation operator*(const TGeoRotation &other) constDefinition TGeoMatrix.cxx:954; TGeoRotation::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".Definition TGeoMatrix.cxx:1221; TGeoRotation::GetTranslationconst Double_t * GetTranslation() const overrideDefinition TGeoMatrix.h:238; TGeoRotation::ReflectXvoid ReflectX(Bool_t leftside, Bool_t rotonly=kFALSE) overrideMultiply by a reflection respect to YZ.Definition TGeoMatrix.cxx:1167; TGeoRotation::fRotationMatrixDouble_t f",MatchSource.WIKI,doc/master/TGeoMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8h_source.html
Usability,simpl,simply,"onst Double_t *local, Double_t *master) const overrideconvert a point by multiplying its column vector (x, y, z, 1) to matrix inverseDefinition TGeoMatrix.cxx:1067; TGeoRotation::operator*=TGeoRotation & operator*=(const TGeoRotation &other)Composition.Definition TGeoMatrix.cxx:946; TGeoRotation::CheckMatrixvoid CheckMatrix()performes an orthogonality check and finds if the matrix is a reflection Warning(""CheckMatrix"",...Definition TGeoMatrix.cxx:1379; TGeoRotation::ReflectYvoid ReflectY(Bool_t leftside, Bool_t rotonly=kFALSE) overrideMultiply by a reflection respect to ZX.Definition TGeoMatrix.cxx:1185; TGeoRotation::GetPhiRotationDouble_t GetPhiRotation(Bool_t fixX=kFALSE) constReturns rotation angle about Z axis in degrees.Definition TGeoMatrix.cxx:1054; TGeoRotation::FastRotZvoid FastRotZ(const Double_t *sincos)Perform a rotation about Z having the sine/cosine of the rotation angle.Definition TGeoMatrix.cxx:1039; TGeoRotation::GetInversevoid GetInverse(Double_t *invmat) constGet the inverse rotation matrix (which is simply the transpose)Definition TGeoMatrix.cxx:1393; TGeoRotation::DeterminantDouble_t Determinant() constcomputes determinant of the rotation matrixDefinition TGeoMatrix.cxx:1364; TGeoRotation::GetAnglesvoid GetAngles(Double_t &theta1, Double_t &phi1, Double_t &theta2, Double_t &phi2, Double_t &theta3, Double_t &phi3) constRetrieve rotation angles.Definition TGeoMatrix.cxx:1310; TGeoRotation::IsValidBool_t IsValid() constPerform orthogonality test for rotation.Definition TGeoMatrix.cxx:1008; TGeoRotation::MasterToLocalvoid MasterToLocal(const Double_t *master, Double_t *local) const overrideconvert a point by multiplying its column vector (x, y, z, 1) to matrixDefinition TGeoMatrix.cxx:1078; TGeoRotation::MakeCloneTGeoMatrix * MakeClone() const overrideMake a clone of this matrix.Definition TGeoMatrix.cxx:1089; TGeoRotation::operator*TGeoRotation operator*(const TGeoRotation &other) constDefinition TGeoMatrix.cxx:954; TGeoRotation::SavePrimitivevoid",MatchSource.WIKI,doc/master/TGeoMatrix_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8h_source.html
Availability,error,error,"fParamsDouble_t fParams[20]Definition TGeoMedium.h:29; TGeoMedium::kMedSavePrimitive@ kMedSavePrimitiveDefinition TGeoMedium.h:25; TGeoMedium::operator=TGeoMedium & operator=(const TGeoMedium &)assignment operatorDefinition TGeoMedium.cxx:108; TGeoMedium::fIdInt_t fIdDefinition TGeoMedium.h:28; TGeoMedium::GetPointerNameconst char * GetPointerName() constProvide a pointer name containing uid.Definition TGeoMedium.cxx:128; TGeoMedium::TGeoMediumTGeoMedium()Default constructor.Definition TGeoMedium.cxx:35; TGeoMedium::~TGeoMedium~TGeoMedium() overrideDestructor.Definition TGeoMedium.cxx:123; TIterDefinition TCollection.h:235; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::fNameTString fNameDefinition TNamed.h:32; TNamed::operator=TNamed & operator=(const TNamed &rhs)TNamed assignment operator.Definition TNamed.cxx:51; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TStringBasic string class.Definition TString.h:139; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; double; int; unsigned int. geomgeomsrcTGeoMedium.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoMedium_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMedium_8cxx_source.html
Integrability,interface,interfaces,"2// Author: Rene Brun 26/12/02; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TGeoMedium; 13\ingroup Materials_classes; 14 ; 15Media are used to store properties related to tracking and which are useful; 16only when using geometry with a particle transport MC package (via VMC). One; 17may define several tracking media for a given material. The media ID are user; 18defined values that are not used by the geometry package. In case geometry; 19is used via VMC (in GEANT) these numbers are overwritten, so one can only; 20rely on these values after gMC->FinishGeometry() is called.; 21The media parameters are inspired from GEANT3 and the values defined make sense; 22in context of GEANT (3 but also 4) or FLUKA interfaces.; 23*/; 24 ; 25#include <iostream>; 26#include ""TGeoManager.h""; 27#include ""TGeoMedium.h""; 28#include ""TList.h""; 29 ; 30ClassImp(TGeoMedium);; 31 ; 32////////////////////////////////////////////////////////////////////////////////; 33/// Default constructor; 34 ; 35TGeoMedium::TGeoMedium(); 36{; 37 fId = 0;; 38 for (Int_t i = 0; i < 20; i++); 39 fParams[i] = 0.;; 40 fMaterial = nullptr;; 41}; 42 ; 43////////////////////////////////////////////////////////////////////////////////; 44/// constructor; 45 ; 46TGeoMedium::TGeoMedium(const char *name, Int_t numed, const TGeoMaterial *mat, Double_t *params) : TNamed(name, """"); 47{; 48 fName = fName.Strip();; 49 fId = numed;; 50 for (Int_t i = 0; i < 20; i++); 51 fParams[i] = 0.;; 52 fMaterial = (TGeoMaterial *)mat;; 53 for (Int_t i = 0; i < 10; i++) {; 54 if (params); 55 fParams[i] = params[i];; 56 else; 57 fParams[i] = 0;; 58 }; 59 gGeoManager->GetListOfMedia()->Add(this)",MatchSource.WIKI,doc/master/TGeoMedium_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoMedium_8cxx_source.html
Availability,down,downwards,"lMatrix; //! current pointer to cached global matrix; 83 TGeoHMatrix *fDivMatrix; //! current local matrix of the selected division cell; 84 TString fPath; //! path to current node; 85 ; 86 static Bool_t fgUsePWSafetyCaching; //! global mode is caching enabled for parallel world safety calls; 87 ; 88public:; 89 TGeoNavigator();; 90 TGeoNavigator(TGeoManager *geom);; 91 ~TGeoNavigator() override;; 92 ; 93 void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE);; 94 Bool_t cd(const char *path = """");; 95 Bool_t CheckPath(const char *path) const;; 96 void CdNode(Int_t nodeid);; 97 void CdDown(Int_t index);; 98 void CdDown(TGeoNode *node);; 99 void CdUp();; 100 void CdTop();; 101 void CdNext();; 102 void GetBranchNames(Int_t *names) const;; 103 void GetBranchNumbers(Int_t *copyNumbers, Int_t *volumeNumbers) const;; 104 void GetBranchOnlys(Int_t *isonly) const;; 105 Int_t GetNmany() const { return fNmany; }; 106 //--- geometry queries; 107 TGeoNode *CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode);; 108 TGeoNode *FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char *path = """", Bool_t frombdr = kFALSE);; 109 TGeoNode *FindNextDaughterBoundary(Double_t *point, Double_t *dir, Int_t &idaughter, Bool_t compmatrix = kFALSE);; 110 TGeoNode *FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE);; 111 TGeoNode *FindNode(Bool_t safe_start = kTRUE);; 112 TGeoNode *FindNode(Double_t x, Double_t y, Double_t z);; 113 Double_t *FindNormal(Bool_t forward = kTRUE);; 114 Double_t *FindNormalFast();; 115 TGeoNode *InitTrack(const Double_t *point, const Double_t *dir);; 116 TGeoNode *InitTrack(Double_t x, Double_t y, Double_t z, Double_t nx, Double_t ny, Double_t nz);; 117 void ResetState();; 118 void ResetAll();; 119 Double_t Safety(Bool_t inside = kFALSE);; 120 TGeoNode *SearchNode(Bool_t downwards = kFALSE, const TGeoNode *skipnode = nullptr);; 121 TGeoNode *Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE);; 122 const Doubl",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
Performance,cache,cache,"pClusters; 60 Int_t *fOverlapClusters; //! internal array for overlaps; 61 Bool_t fSearchOverlaps; //! flag set when an overlapping cluster is searched; 62 Bool_t fCurrentOverlapping; //! flags the type of the current node; 63 Bool_t fStartSafe; //! flag a safe start for point classification; 64 Bool_t fIsEntering; //! flag if current step just got into a new node; 65 Bool_t fIsExiting; //! flag that current track is about to leave current node; 66 Bool_t fIsStepEntering; //! flag that next geometric step will enter new volume; 67 Bool_t fIsStepExiting; //! flag that next geometric step will exit current volume; 68 Bool_t fIsOutside; //! flag that current point is outside geometry; 69 Bool_t fIsOnBoundary; //! flag that current point is on some boundary; 70 Bool_t fIsSameLocation; //! flag that a new point is in the same node as previous; 71 Bool_t fIsNullStep; //! flag that last geometric step was null; 72 TGeoManager *fGeometry; //! current geometry; 73 TGeoNodeCache *fCache; //! cache of states; 74 TGeoVolume *fCurrentVolume; //! current volume; 75 TGeoNode *fCurrentNode; //! current node; 76 TGeoNode *fTopNode; //! top physical node; 77 TGeoNode *fLastNode; //! last searched node; 78 TGeoNode *fNextNode; //! next node that will be crossed; 79 TGeoNode *fForcedNode; //! current point is supposed to be inside this node; 80 TGeoCacheState *fBackupState; //! backup state; 81 TGeoHMatrix *fCurrentMatrix; //! current stored global matrix; 82 TGeoHMatrix *fGlobalMatrix; //! current pointer to cached global matrix; 83 TGeoHMatrix *fDivMatrix; //! current local matrix of the selected division cell; 84 TString fPath; //! path to current node; 85 ; 86 static Bool_t fgUsePWSafetyCaching; //! global mode is caching enabled for parallel world safety calls; 87 ; 88public:; 89 TGeoNavigator();; 90 TGeoNavigator(TGeoManager *geom);; 91 ~TGeoNavigator() override;; 92 ; 93 void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE);; 94 Bool_t cd(const char *path = """");; 95 Boo",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
Safety,safe,safety,"; 23// //; 24////////////////////////////////////////////////////////////////////////////; 25 ; 26class TGeoManager;; 27class TGeoNode;; 28class TGeoVolume;; 29class TGeoMatrix;; 30class TGeoHMatrix;; 31 ; 32class TGeoNavigator : public TObject {; 33 ; 34protected:; 35 TGeoNavigator(const TGeoNavigator &) = delete;; 36 TGeoNavigator &operator=(const TGeoNavigator &) = delete;; 37 TGeoNode *FindInCluster(Int_t *cluster, Int_t nc);; 38 Int_t GetTouchedCluster(Int_t start, Double_t *point, Int_t *check_list, Int_t ncheck, Int_t *result);; 39 TGeoNode *CrossDivisionCell();; 40 void SafetyOverlaps();; 41 ; 42private:; 43 Double_t fStep; //! step to be done from current point and direction; 44 Double_t fSafety; //! safety radius from current point; 45 Double_t fLastSafety; //! last computed safety radius; 46 Double_t fNormal[3]; //! cosine of incident angle on current checked surface; 47 Double_t fCldir[3]; //! unit vector to current closest shape; 48 Double_t fCldirChecked[3]; //! unit vector to current checked shape; 49 Double_t fPoint[3]; //! current po",MatchSource.WIKI,doc/master/TGeoNavigator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html
Deployability,A/B,A/B,"tance of approach from point px,py to this nodeDefinition TGeoNode.cxx:251; TGeoNode::TGeoNodeTGeoNode()Default constructor.Definition TGeoNode.cxx:95; TGeoNode::fUserExtensionTGeoExtension * fUserExtensionDefinition TGeoNode.h:46; TGeoNode::GetByteCountvirtual Int_t GetByteCount() constDefinition TGeoNode.h:82; TGeoNode::fOverlapsInt_t * fOverlapsDefinition TGeoNode.h:45; TGeoNode::fNovlpInt_t fNovlpDefinition TGeoNode.h:44; TGeoNode::SetOverlappingvoid SetOverlapping(Bool_t flag=kTRUE)Definition TGeoNode.h:120; TGeoNode::GrabFWExtensionTGeoExtension * GrabFWExtension() constGet a copy of the framework extension pointer.Definition TGeoNode.cxx:545; TGeoNode::SetOverlapsvoid SetOverlaps(Int_t *ovlp, Int_t novlp)set the list of overlaps for this node (ovlp must be created with operator new)Definition TGeoNode.cxx:707; TGeoNode::PrintCandidatesvoid PrintCandidates() constprint daughters candidates for containing current pointDefinition TGeoNode.cxx:616; TGeoNode::lsvoid ls(Option_t *option="""") const overridePrint the path (A/B/C/...) to this node on stdout.Definition TGeoNode.cxx:600; TGeoNode::SetInvisiblevoid SetInvisible()Definition TGeoNode.h:123; TGeoNode::GetNdaughtersInt_t GetNdaughters() constDefinition TGeoNode.h:91; TGeoNode::GetDaughterTGeoNode * GetDaughter(Int_t ind) constDefinition TGeoNode.h:83; TGeoNode::SetCurrentPointvoid SetCurrentPoint(Double_t x, Double_t y, Double_t z)Definition TGeoNode.h:116; TGeoNode::GetOptimalVoxelsvirtual Int_t GetOptimalVoxels() constDefinition TGeoNode.h:101; TGeoNode::GetMatrixvirtual TGeoMatrix * GetMatrix() const =0; TGeoNode::IsClonedBool_t IsCloned() constDefinition TGeoNode.h:103; TGeoNode::SetVisibilityvoid SetVisibility(Bool_t vis=kTRUE) overrideSet visibility of the node (obsolete).Definition TGeoNode.cxx:718; TGeoNode::TGeoNodeTGeoNode(const TGeoNode &)=delete; TGeoNode::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Defi",MatchSource.WIKI,doc/master/TGeoNode_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNode_8h_source.html
Modifiability,plugin,plugins,"GetIndex() const override;; 203 TGeoPatternFinder *GetFinder() const override { return fFinder; }; 204 TGeoMatrix *GetMatrix() const override; 205 {; 206 cd();; 207 return fFinder->GetMatrix();; 208 }; 209 TGeoNode *MakeCopyNode() const override;; 210 void SetFinder(TGeoPatternFinder *finder) { fFinder = finder; }; 211 ; 212 ClassDefOverride(TGeoNodeOffset, 1) // a geometry node with just an offset; 213};; 214 ; 215////////////////////////////////////////////////////////////////////////////; 216// //; 217// TGeoIteratorPlugin - Plugin for a TGeoIterator providing the method //; 218// ProcessNode each time Next is called. //; 219// //; 220////////////////////////////////////////////////////////////////////////////; 221 ; 222class TGeoIterator;; 223 ; 224class TGeoIteratorPlugin : public TObject {; 225protected:; 226 const TGeoIterator *fIterator = nullptr; // Caller iterator; 227private:; 228 // No copy; 229 TGeoIteratorPlugin(const TGeoIteratorPlugin &);; 230 TGeoIteratorPlugin &operator=(const TGeoIteratorPlugin &);; 231 ; 232public:; 233 TGeoIteratorPlugin() : TObject(), fIterator(nullptr) {}; 234 ~TGeoIteratorPlugin() override {}; 235 ; 236 virtual void ProcessNode() = 0;; 237 void SetIterator(const TGeoIterator *iter) { fIterator = iter; }; 238 ; 239 ClassDefOverride(TGeoIteratorPlugin, 0) // ABC for user plugins connecter to a geometry iterator.; 240};; 241 ; 242////////////////////////////////////////////////////////////////////////////; 243// //; 244// TGeoIterator - iterator for the node tree //; 245// //; 246////////////////////////////////////////////////////////////////////////////; 247 ; 248class TGeoIterator {; 249private:; 250 TGeoVolume *fTop = nullptr; // Top volume of the iterated branch; 251 Bool_t fMustResume = kFALSE; // Private flag to resume from current node.; 252 Bool_t fMustStop = kFALSE; // Private flag to signal that the iterator has finished.; 253 Int_t fLevel = 0; // Current level in the tree; 254 Int_t fType = 0; // Type of iteration; 2",MatchSource.WIKI,doc/master/TGeoNode_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNode_8h_source.html
Testability,log,logical,". ROOT: geom/geom/inc/TGeoNode.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGeoNode.h. Go to the documentation of this file. 1// @(#)root/geom:$Id$; 2// Author: Andrei Gheata 24/10/01; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TGeoNode; 13#define ROOT_TGeoNode; 14 ; 15#include ""TGeoAtt.h""; 16 ; 17#include ""TNamed.h""; 18 ; 19#include ""TGeoVolume.h""; 20 ; 21#include ""TGeoPatternFinder.h""; 22 ; 23// forward declarations; 24class TString;; 25class TGeoVolume;; 26class TGeoShape;; 27class TGeoMedium;; 28class TGeoMatrix;; 29class TGeoHMatrix;; 30class TGeoExtension;; 31 ; 32////////////////////////////////////////////////////////////////////////////; 33// //; 34// TGeoNode - base class for logical nodes. They represent volumes //; 35// positioned inside a mother volume //; 36// //; 37////////////////////////////////////////////////////////////////////////////; 38 ; 39class TGeoNode : public TNamed, public TGeoAtt {; 40protected:; 41 TGeoVolume *fVolume = nullptr; // volume associated with this; 42 TGeoVolume *fMother = nullptr; // mother volume; 43 Int_t fNumber = 0; // copy number; 44 Int_t fNovlp = 0; // number of overlaps; 45 Int_t *fOverlaps = nullptr; //[fNovlp] list of indices for overlapping brothers; 46 TGeoExtension *fUserExtension = nullptr; //! Transient user-defined extension to volumes; 47 TGeoExtension *fFWExtension = nullptr; //! Transient framework-defined extension to volumes; 48 ; 49 void CopyOverlaps(Int_t *ovlp, Int_t novlp);; 50 ; 51private:; 52 TGeoNode(const TGeoNode &) = delete;; 53 TGeoNode &operator=(const TGeoNode &) = delete;; 54 ; 55public:; 56 ",MatchSource.WIKI,doc/master/TGeoNode_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNode_8h_source.html
Usability,resume,resume,"rocessNode each time Next is called. //; 219// //; 220////////////////////////////////////////////////////////////////////////////; 221 ; 222class TGeoIterator;; 223 ; 224class TGeoIteratorPlugin : public TObject {; 225protected:; 226 const TGeoIterator *fIterator = nullptr; // Caller iterator; 227private:; 228 // No copy; 229 TGeoIteratorPlugin(const TGeoIteratorPlugin &);; 230 TGeoIteratorPlugin &operator=(const TGeoIteratorPlugin &);; 231 ; 232public:; 233 TGeoIteratorPlugin() : TObject(), fIterator(nullptr) {}; 234 ~TGeoIteratorPlugin() override {}; 235 ; 236 virtual void ProcessNode() = 0;; 237 void SetIterator(const TGeoIterator *iter) { fIterator = iter; }; 238 ; 239 ClassDefOverride(TGeoIteratorPlugin, 0) // ABC for user plugins connecter to a geometry iterator.; 240};; 241 ; 242////////////////////////////////////////////////////////////////////////////; 243// //; 244// TGeoIterator - iterator for the node tree //; 245// //; 246////////////////////////////////////////////////////////////////////////////; 247 ; 248class TGeoIterator {; 249private:; 250 TGeoVolume *fTop = nullptr; // Top volume of the iterated branch; 251 Bool_t fMustResume = kFALSE; // Private flag to resume from current node.; 252 Bool_t fMustStop = kFALSE; // Private flag to signal that the iterator has finished.; 253 Int_t fLevel = 0; // Current level in the tree; 254 Int_t fType = 0; // Type of iteration; 255 Int_t *fArray = nullptr; // Array of node indices for the current path; 256 TGeoHMatrix *fMatrix = nullptr; // Current global matrix; 257 TString fTopName; // User name for top; 258 TGeoIteratorPlugin *fPlugin = nullptr; // User iterator plugin; 259 Bool_t fPluginAutoexec = kFALSE; // Plugin automatically executed during next(); 260 ; 261 void IncreaseArray();; 262 ; 263protected:; 264 TGeoIterator(); 265 : fTop(nullptr),; 266 fMustResume(kFALSE),; 267 fMustStop(kFALSE),; 268 fLevel(0),; 269 fType(0),; 270 fArray(nullptr),; 271 fMatrix(nullptr),; 272 fTopName(),; 273 fPlugin(nullptr",MatchSource.WIKI,doc/master/TGeoNode_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoNode_8h_source.html
Availability,error,errors,":BombTranslation(const Double_t *tr, Double_t *bombtr); 172{; 173 memcpy(bombtr, tr, 3 * sizeof(Double_t));; 174 switch (fExplodedView) {; 175 case kGeoNoBomb: return;; 176 case kGeoBombXYZ:; 177 bombtr[0] *= fBombX;; 178 bombtr[1] *= fBombY;; 179 bombtr[2] *= fBombZ;; 180 return;; 181 case kGeoBombCyl:; 182 bombtr[0] *= fBombR;; 183 bombtr[1] *= fBombR;; 184 bombtr[2] *= fBombZ;; 185 return;; 186 case kGeoBombSph:; 187 bombtr[0] *= fBombR;; 188 bombtr[1] *= fBombR;; 189 bombtr[2] *= fBombR;; 190 return;; 191 default: return;; 192 }; 193}; 194 ; 195////////////////////////////////////////////////////////////////////////////////; 196/// Check pushes and pulls needed to cross the next boundary with respect to the; 197/// position given by FindNextBoundary. If radius is not mentioned the full bounding; 198/// box will be sampled.; 199 ; 200void TGeoPainter::CheckBoundaryErrors(Int_t ntracks, Double_t radius); 201{; 202 fChecker->CheckBoundaryErrors(ntracks, radius);; 203}; 204 ; 205////////////////////////////////////////////////////////////////////////////////; 206/// Check the boundary errors reference file created by CheckBoundaryErrors method.; 207/// The shape for which the crossing failed is drawn with the starting point in red; 208/// and the extrapolated point to boundary (+/- failing push/pull) in yellow.; 209 ; 210void TGeoPainter::CheckBoundaryReference(Int_t icheck); 211{; 212 fChecker->CheckBoundaryReference(icheck);; 213}; 214 ; 215////////////////////////////////////////////////////////////////////////////////; 216/// Geometry checking method (see: TGeoManager::CheckGeometry()); 217 ; 218void TGeoPainter::CheckGeometryFull(Bool_t checkoverlaps, Bool_t checkcrossings, Int_t ntracks, const Double_t *vertex); 219{; 220 fChecker->CheckGeometryFull(checkoverlaps, checkcrossings, ntracks, vertex);; 221}; 222 ; 223////////////////////////////////////////////////////////////////////////////////; 224/// Geometry checking method (see TGeoChecker).; 225 ; 226void T",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
Deployability,update,update,"uble_t phimin,; 1242 Double_t phimax, Double_t rmin, Double_t rmax, Option_t *option); 1243{; 1244 return fChecker->LegoPlot(ntheta, themin, themax, nphi, phimin, phimax, rmin, rmax, option);; 1245}; 1246////////////////////////////////////////////////////////////////////////////////; 1247/// Convert a local vector according view rotation matrix; 1248 ; 1249void TGeoPainter::LocalToMasterVect(const Double_t *local, Double_t *master) const; 1250{; 1251 for (Int_t i = 0; i < 3; i++); 1252 master[i] = -local[0] * fMat[i] - local[1] * fMat[i + 3] - local[2] * fMat[i + 6];; 1253}; 1254 ; 1255////////////////////////////////////////////////////////////////////////////////; 1256/// Check if a pad and view are present and send signal ""Modified"" to pad.; 1257 ; 1258void TGeoPainter::ModifiedPad(Bool_t update) const; 1259{; 1260 if (!gPad); 1261 return;; 1262 if (update) {; 1263 gPad->Update();; 1264 return;; 1265 }; 1266 TView *view = gPad->GetView();; 1267 if (!view); 1268 return;; 1269 view->SetViewChanged();; 1270 gPad->Modified();; 1271 if (gROOT->FromPopUp()); 1272 gPad->Update();; 1273}; 1274 ; 1275////////////////////////////////////////////////////////////////////////////////; 1276/// Paint current geometry according to option.; 1277 ; 1278void TGeoPainter::Paint(Option_t *option); 1279{; 1280 if (!fGeoManager || !fTopVolume); 1281 return;; 1282 Bool_t is_padviewer = kTRUE;; 1283 if (gPad); 1284 is_padviewer = (!strcmp(gPad->GetViewer3D()->ClassName(), ""TViewer3DPad"")) ? kTRUE : kFALSE;; 1285 ; 1286 fIsRaytracing = fTopVolume->IsRaytracing();; 1287 if (fTopVolume->IsVisContainers()); 1288 fVisOption = kGeoVisDefault;; 1289 else if (fTopVolume->IsVisLeaves()); 1290 fVisOption = kGeoVisLeaves;; 1291 else if (fTopVolume->IsVisOnly()); 1292 fVisOption = kGeoVisOnly;; 1293 else if (fTopVolume->IsVisBranch()); 1294 fVisOption = kGeoVisBranch;; 1295 ; 1296 if (!fIsRaytracing || !is_padviewer) {; 1297 if (fGeoManager->IsDrawingExtra()) {; 1298 // loop the list of physical vo",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
Energy Efficiency,green,green,"///////////////////////////////////////; 290/// Get index of a base color with given light intensity (0,1); 291 ; 292Int_t TGeoPainter::GetColor(Int_t base, Float_t light) const; 293{; 294 using IntMap_t = std::map<Int_t, Int_t>;; 295 constexpr Int_t ncolors = 100;; 296 constexpr Float_t lmin = 0.25;; 297 constexpr Float_t lmax = 0.75;; 298 static IntMap_t colmap;; 299 Int_t color = base;; 300 // Search color in the map; 301 auto it = colmap.find(base);; 302 if (it != colmap.end()); 303 return (it->second + light * (ncolors - 1));; 304 // Get color pointer if stored; 305 TColor *col_base = gROOT->GetColor(base);; 306 if (!col_base) {; 307 // If color not defined, use gray palette; 308 it = colmap.find(kBlack);; 309 if (it != colmap.end()); 310 return (it->second + light * (ncolors - 1));; 311 col_base = gROOT->GetColor(kBlack);; 312 color = 1;; 313 }; 314 // Create a color palette for col_base; 315 Float_t r = 0., g = 0., b = 0., h = 0., l = 0., s = 0.;; 316 Double_t red[2], green[2], blue[2];; 317 Double_t stop[] = {0., 1.0};; 318 ; 319 if (col_base); 320 col_base->GetRGB(r, g, b);; 321 TColor::RGB2HLS(r, g, b, h, l, s);; 322 TColor::HLS2RGB(h, lmin, s, r, g, b);; 323 red[0] = r;; 324 green[0] = g;; 325 blue[0] = b;; 326 TColor::HLS2RGB(h, lmax, s, r, g, b);; 327 red[1] = r;; 328 green[1] = g;; 329 blue[1] = b;; 330 Int_t color_map_idx = TColor::CreateGradientColorTable(2, stop, red, green, blue, ncolors, 1., kFALSE);; 331 colmap[color] = color_map_idx;; 332 return (color_map_idx + light * (ncolors - 1));; 333}; 334 ; 335////////////////////////////////////////////////////////////////////////////////; 336/// Get currently drawn volume.; 337 ; 338TGeoVolume *TGeoPainter::GetDrawnVolume() const; 339{; 340 if (!gPad); 341 return nullptr;; 342 return fTopVolume;; 343}; 344 ; 345////////////////////////////////////////////////////////////////////////////////; 346/// Compute the closest distance of approach from point px,py to a volume.; 347 ; 348Int_t TGeoPainter::Distan",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
Integrability,interface,interfaces,". ROOT: geom/geompainter/src/TGeoPainter.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGeoPainter.cxx. Go to the documentation of this file. 1// @(#)root/geompainter:$Id: 58726ead32989b65bb2cbff2af4235fe9c6b12ae $; 2// Author: Andrei Gheata 05/03/02; 3/*************************************************************************; 4 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 5 * All rights reserved. *; 6 * *; 7 * For the licensing terms see $ROOTSYS/LICENSE. *; 8 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11/** \class TGeoPainter; 12\ingroup Geometry_painter; 13 ; 14Class implementing all draw interfaces for a generic 3D viewer; 15using TBuffer3D mechanism.; 16*/; 17 ; 18#include <map>; 19#include ""TROOT.h""; 20#include ""TClass.h""; 21#include ""TColor.h""; 22#include ""TPoint.h""; 23#include ""TView.h""; 24#include ""TAttLine.h""; 25#include ""TAttFill.h""; 26#include ""TVirtualPad.h""; 27#include ""TCanvas.h""; 28#include ""TCanvasImp.h""; 29#include ""TH2F.h""; 30#include ""TF1.h""; 31#include ""TGraph.h""; 32#include ""TPluginManager.h""; 33#include ""TVirtualPadEditor.h""; 34#include ""TStopwatch.h""; 35 ; 36#include ""TPolyMarker3D.h""; 37 ; 38#include ""TGeoAtt.h""; 39#include ""TGeoVolume.h""; 40#include ""TGeoNode.h""; 41#include ""TGeoElement.h""; 42#include ""TGeoManager.h""; 43#include ""TGeoTrack.h""; 44#include ""TGeoOverlap.h""; 45#include ""TGeoChecker.h""; 46#include ""TGeoPhysicalNode.h""; 47#include ""TGeoPolygon.h""; 48#include ""TGeoCompositeShape.h""; 49#include ""TGeoShapeAssembly.h""; 50#include ""TGeoPainter.h""; 51#include ""TMath.h""; 52 ; 53#include ""X3DBuffer.h""; 54 ; 55#include ""TBuffer3D.h""; 56#include ""TBuffer3DTypes.h""; 57#include ""TVirtualViewer3D.h""; 58#include ""TVirtualX.h""; 59 ; 60ClassImp(TGeoPainter);; 61 ; 62////////////////////////////////////////////////////////////////////////////////; 63/// Default constructor.; 64 ;",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
Modifiability,plugin,plugin,".Definition TGeoCompositeShape.cxx:429; TGeoHMatrixMatrix class used for computing global transformations Should NOT be used for node definition.Definition TGeoMatrix.h:458; TGeoHMatrix::Clearvoid Clear(Option_t *option="""") overrideclear the data for this matrixDefinition TGeoMatrix.cxx:2512; TGeoIteratorPlugin::SetIteratorvoid SetIterator(const TGeoIterator *iter)Definition TGeoNode.h:237; TGeoIteratorPlugin::ProcessNodevirtual void ProcessNode()=0; TGeoIteratorA geometry iterator.Definition TGeoNode.h:248; TGeoIterator::GetCurrentMatrixconst TGeoMatrix * GetCurrentMatrix() constReturns global matrix for current node.Definition TGeoNode.cxx:1163; TGeoIterator::SetTopNamevoid SetTopName(const char *name)Set the top name for path.Definition TGeoNode.cxx:1234; TGeoIterator::GetLevelInt_t GetLevel() constDefinition TGeoNode.h:294; TGeoIterator::GetPathvoid GetPath(TString &path) constReturns the path for the current node.Definition TGeoNode.cxx:1193; TGeoIterator::SetUserPluginvoid SetUserPlugin(TGeoIteratorPlugin *plugin)Set a plugin.Definition TGeoNode.cxx:1282; TGeoIterator::Skipvoid Skip()Stop iterating the current branch.Definition TGeoNode.cxx:1243; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::GetMotherTGeoNode * GetMother(Int_t up=1) constDefinition TGeoManager.h:493; TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; TGeoManager::DoRestoreStatevoid DoRestoreState()Restore a backed-up state without affecting the cache stack.Definition TGeoManager.cxx:1106; TGeoManager::GetCurrentDirectionconst Double_t * GetCurrentDirection() constDefinition TGeoManager.h:502; TGeoManager::CdUpvoid CdUp()Go one level up in geometry.Definition TGeoManager.cxx:1681; TGeoManager::DoBackupStatevoid DoBackupState()Backup the current state without affecting the cache stack.Definition TGeoManager.cxx:",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
Performance,load,loaded,"""TGraph.h""; 32#include ""TPluginManager.h""; 33#include ""TVirtualPadEditor.h""; 34#include ""TStopwatch.h""; 35 ; 36#include ""TPolyMarker3D.h""; 37 ; 38#include ""TGeoAtt.h""; 39#include ""TGeoVolume.h""; 40#include ""TGeoNode.h""; 41#include ""TGeoElement.h""; 42#include ""TGeoManager.h""; 43#include ""TGeoTrack.h""; 44#include ""TGeoOverlap.h""; 45#include ""TGeoChecker.h""; 46#include ""TGeoPhysicalNode.h""; 47#include ""TGeoPolygon.h""; 48#include ""TGeoCompositeShape.h""; 49#include ""TGeoShapeAssembly.h""; 50#include ""TGeoPainter.h""; 51#include ""TMath.h""; 52 ; 53#include ""X3DBuffer.h""; 54 ; 55#include ""TBuffer3D.h""; 56#include ""TBuffer3DTypes.h""; 57#include ""TVirtualViewer3D.h""; 58#include ""TVirtualX.h""; 59 ; 60ClassImp(TGeoPainter);; 61 ; 62////////////////////////////////////////////////////////////////////////////////; 63/// Default constructor.; 64 ; 65TGeoPainter::TGeoPainter(TGeoManager *manager) : TVirtualGeoPainter(manager); 66{; 67 TVirtualGeoPainter::SetPainter(this);; 68 if (manager); 69 fGeoManager = manager;; 70 else {; 71 Error(""ctor"", ""No geometry loaded"");; 72 return;; 73 }; 74 fNsegments = fGeoManager->GetNsegments();; 75 fNVisNodes = 0;; 76 fBombX = 1.3;; 77 fBombY = 1.3;; 78 fBombZ = 1.3;; 79 fBombR = 1.3;; 80 fVisLevel = fGeoManager->GetVisLevel();; 81 fVisOption = fGeoManager->GetVisOption();; 82 fExplodedView = fGeoManager->GetBombMode();; 83 fVisBranch = """";; 84 fVolInfo = """";; 85 fVisLock = kFALSE;; 86 fIsRaytracing = kFALSE;; 87 fTopVisible = kFALSE;; 88 fPaintingOverlaps = kFALSE;; 89 fPlugin = nullptr;; 90 fVisVolumes = new TObjArray();; 91 fOverlap = nullptr;; 92 fGlobal = new TGeoHMatrix();; 93 fBuffer = new TBuffer3D(TBuffer3DTypes::kGeneric, 20, 3 * 20, 0, 0, 0, 0);; 94 fClippingShape = nullptr;; 95 fLastVolume = nullptr;; 96 fTopVolume = nullptr;; 97 fIsPaintingShape = kFALSE;; 98 memset(&fCheckedBox[0], 0, 6 * sizeof(Double_t));; 99 ; 100 fCheckedNode = fGeoManager->GetTopNode();; 101 fChecker = new TGeoChecker(fGeoManager);; 102 fIsEditable = kFALSE;; 103 ",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
Safety,safe,safety,"rlaps, checkcrossings, ntracks, vertex);; 221}; 222 ; 223////////////////////////////////////////////////////////////////////////////////; 224/// Geometry checking method (see TGeoChecker).; 225 ; 226void TGeoPainter::CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; 227{; 228 fChecker->CheckGeometry(nrays, startx, starty, startz);; 229}; 230 ; 231////////////////////////////////////////////////////////////////////////////////; 232/// Check overlaps for the top volume of the geometry, within a limit OVLP.; 233 ; 234void TGeoPainter::CheckOverlaps(const TGeoVolume *vol, Double_t ovlp, Option_t *option) const; 235{; 236 fChecker->CheckOverlaps(vol, ovlp, option);; 237}; 238 ; 239////////////////////////////////////////////////////////////////////////////////; 240/// Check current point in the geometry.; 241 ; 242void TGeoPainter::CheckPoint(Double_t x, Double_t y, Double_t z, Option_t *option, Double_t safety); 243{; 244 fChecker->CheckPoint(x, y, z, option, safety);; 245}; 246 ; 247////////////////////////////////////////////////////////////////////////////////; 248/// Test for shape navigation methods. Summary for test numbers:; 249/// - 1: DistFromInside/Outside. Sample points inside the shape. Generate; 250/// directions randomly in cos(theta). Compute DistFromInside and move the; 251/// point with bigger distance. Compute DistFromOutside back from new point.; 252/// Plot d-(d1+d2); 253 ; 254void TGeoPainter::CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option); 255{; 256 fChecker->CheckShape(shape, testNo, nsamples, option);; 257}; 258 ; 259////////////////////////////////////////////////////////////////////////////////; 260/// Clear the list of visible volumes; 261/// reset the kVisOnScreen bit for volumes previously in the list; 262 ; 263void TGeoPainter::ClearVisibleVolumes(); 264{; 265 if (!fVisVolumes); 266 return;; 267 TIter next(fVisVolumes);; 268 TGeoVolume *vol;; 269 while ((vol = (TGeoVolume *)n",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
Testability,test,test,"er).; 225 ; 226void TGeoPainter::CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; 227{; 228 fChecker->CheckGeometry(nrays, startx, starty, startz);; 229}; 230 ; 231////////////////////////////////////////////////////////////////////////////////; 232/// Check overlaps for the top volume of the geometry, within a limit OVLP.; 233 ; 234void TGeoPainter::CheckOverlaps(const TGeoVolume *vol, Double_t ovlp, Option_t *option) const; 235{; 236 fChecker->CheckOverlaps(vol, ovlp, option);; 237}; 238 ; 239////////////////////////////////////////////////////////////////////////////////; 240/// Check current point in the geometry.; 241 ; 242void TGeoPainter::CheckPoint(Double_t x, Double_t y, Double_t z, Option_t *option, Double_t safety); 243{; 244 fChecker->CheckPoint(x, y, z, option, safety);; 245}; 246 ; 247////////////////////////////////////////////////////////////////////////////////; 248/// Test for shape navigation methods. Summary for test numbers:; 249/// - 1: DistFromInside/Outside. Sample points inside the shape. Generate; 250/// directions randomly in cos(theta). Compute DistFromInside and move the; 251/// point with bigger distance. Compute DistFromOutside back from new point.; 252/// Plot d-(d1+d2); 253 ; 254void TGeoPainter::CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option); 255{; 256 fChecker->CheckShape(shape, testNo, nsamples, option);; 257}; 258 ; 259////////////////////////////////////////////////////////////////////////////////; 260/// Clear the list of visible volumes; 261/// reset the kVisOnScreen bit for volumes previously in the list; 262 ; 263void TGeoPainter::ClearVisibleVolumes(); 264{; 265 if (!fVisVolumes); 266 return;; 267 TIter next(fVisVolumes);; 268 TGeoVolume *vol;; 269 while ((vol = (TGeoVolume *)next())) {; 270 vol->ResetAttBit(TGeoAtt::kVisOnScreen);; 271 }; 272 fVisVolumes->Clear();; 273}; 274 ; 275////////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
Usability,progress bar,progress bar,"e->GetMatrix();; 1626 fGeoManager->SetMatrixReflection(matrix->IsReflection());; 1627 fGeoManager->SetPaintVolume(vcrt);; 1628 if (!node->IsVolAttributes() && !strstr(option, ""range"")) {; 1629 col = vcrt->GetLineColor();; 1630 wid = vcrt->GetLineWidth();; 1631 sty = vcrt->GetLineStyle();; 1632 vcrt->SetLineColor(node->GetLineColor());; 1633 vcrt->SetLineWidth(node->GetLineWidth());; 1634 vcrt->SetLineStyle(node->GetLineStyle());; 1635 ((TAttLine *)vcrt)->Modify();; 1636 PaintShape(*shape, option);; 1637 vcrt->SetLineColor(col);; 1638 vcrt->SetLineWidth(wid);; 1639 vcrt->SetLineStyle(sty);; 1640 } else {; 1641 PaintShape(*shape, option);; 1642 }; 1643 } else {; 1644 // Paint full branch, except top node; 1645 for (i = 1; i <= level; i++) {; 1646 vcrt = node->GetVolume(i);; 1647 if (!strstr(option, ""range"")); 1648 ((TAttLine *)vcrt)->Modify();; 1649 shape = vcrt->GetShape();; 1650 *matrix = node->GetMatrix(i);; 1651 fGeoManager->SetMatrixReflection(matrix->IsReflection());; 1652 fGeoManager->SetPaintVolume(vcrt);; 1653 if (!node->IsVolAttributes() && !strstr(option, ""range"")) {; 1654 col = vcrt->GetLineColor();; 1655 wid = vcrt->GetLineWidth();; 1656 sty = vcrt->GetLineStyle();; 1657 vcrt->SetLineColor(node->GetLineColor());; 1658 vcrt->SetLineWidth(node->GetLineWidth());; 1659 vcrt->SetLineStyle(node->GetLineStyle());; 1660 ((TAttLine *)vcrt)->Modify();; 1661 PaintShape(*shape, option);; 1662 vcrt->SetLineColor(col);; 1663 vcrt->SetLineWidth(wid);; 1664 vcrt->SetLineStyle(sty);; 1665 } else {; 1666 PaintShape(*shape, option);; 1667 }; 1668 }; 1669 }; 1670 fGeoManager->SetMatrixReflection(kFALSE);; 1671}; 1672 ; 1673////////////////////////////////////////////////////////////////////////////////; 1674/// Print overlaps (see TGeoChecker::PrintOverlaps()); 1675 ; 1676void TGeoPainter::PrintOverlaps() const; 1677{; 1678 fChecker->PrintOverlaps();; 1679}; 1680 ; 1681////////////////////////////////////////////////////////////////////////////////; 1682/// Text progress bar.",MatchSource.WIKI,doc/master/TGeoPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html
Availability,down,down,"ter::UnbombTranslationvoid UnbombTranslation(const Double_t *tr, Double_t *bombtr) overrideGet the new 'unbombed' translation vector according current exploded view mode.Definition TGeoPainter.cxx:2194; TGeoPainter::fVisLockBool_t fVisLockDefinition TGeoPainter.h:52; TGeoPainter::PaintNodevoid PaintNode(TGeoNode *node, Option_t *option="""", TGeoMatrix *global=nullptr) overridePaint recursively a node and its content according to visualization options.Definition TGeoPainter.cxx:1376; TGeoPainter::DefaultAnglesvoid DefaultAngles() overrideSet default angles for the current view.Definition TGeoPainter.cxx:555; TGeoPainter::fClippingShapeTGeoShape * fClippingShapeDefinition TGeoPainter.h:65; TGeoPainter::PaintShapeBool_t PaintShape(const TGeoShape &shape, Option_t *option) constPaint the supplied shape into the current 3D viewer.Definition TGeoPainter.cxx:1550; TGeoPainter::fIsEditableBool_t fIsEditableDefinition TGeoPainter.h:70; TGeoPainter::CountNodesInt_t CountNodes(TGeoVolume *vol, Int_t level) constCount number of visible nodes down to a given level.Definition TGeoPainter.cxx:582; TGeoPainter::fCheckedBoxDouble_t fCheckedBox[6]Definition TGeoPainter.h:45; TGeoPainter::DrawShapevoid DrawShape(TGeoShape *shape, Option_t *option="""") overrideDraw a shape.Definition TGeoPainter.cxx:875; TGeoPainter::DrawOnlyvoid DrawOnly(Option_t *option="""") overrideDraw only one volume.Definition TGeoPainter.cxx:962; TGeoPainter::fOverlapTGeoOverlap * fOverlapDefinition TGeoPainter.h:60; TGeoPainter::CheckGeometryvoid CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const overrideGeometry checking method (see TGeoChecker).Definition TGeoPainter.cxx:226; TGeoPainter::fBombYDouble_t fBombYDefinition TGeoPainter.h:42; TGeoPainter::fPaintingOverlapsBool_t fPaintingOverlapsDefinition TGeoPainter.h:54; TGeoPainter::CheckOverlapsvoid CheckOverlaps(const TGeoVolume *vol, Double_t ovlp=0.1, Option_t *option="""") const overrideCheck overlaps for the top volume of the g",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
Deployability,update,update,"tracing() const override { return fIsRaytracing; }; 138 Bool_t IsPaintingShape() const override { return fIsPaintingShape; }; 139 TH2F *LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90,; 140 Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999,; 141 Option_t *option = """") override;; 142 void Lock(Bool_t flag = kTRUE) { fVisLock = flag; }; 143 void ModifiedPad(Bool_t update = kFALSE) const override;; 144 void OpProgress(const char *opname, Long64_t current, Long64_t size, TStopwatch *watch = nullptr,; 145 Bool_t last = kFALSE, Bool_t refresh = kFALSE, const char *msg = """") override;; 146 void Paint(Option_t *option = """") override;; 147 void PaintNode(TGeoNode *node, Option_t *option = """", TGeoMatrix *global = nullptr) override;; 148 Bool_t PaintShape(const TGeoShape &shape, Option_t *option) const;; 149 void PaintShape(TGeoShape *shape, Option_t *option = """") override;; 150 void PaintOverlap(void *ovlp, Option_t *option = """") override;; 151 void PaintVolume(TGeoVolume *vol, Option_t *option = """", TGeoMatrix *global = nullptr) override;; 152 void PrintOverlaps() const override;; 153 void PaintPhysicalNode(TGeoPhysicalNode *node, Option_t *option = """");; 154 void RandomPoints(const TGeoVolume *vol, Int_t npoints, Option_t *option = """") override;; 155 void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz, const char *target_vol = nullptr,; 156 Bool_t check_norm = kFALSE) override;; 157 void Raytrace(Option_t *option = """") override;; 158 TGeoNode *SamplePoints(Int_t npoints, Double_t &dist, Double_t epsil, const char *g3path) override;; 159 void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3) override;; 160 void SetClippingShape(TGeoShape *shape) override { fClippingShape = shape; }; 161 void SetExplodedView(Int_t iopt = 0) override;; 162 void SetNsegments(Int_t nseg = 20) override;; 163 void SetNmeshPoints(Int_t np",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
Integrability,interface,interfaces,"Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; TGeoManager.h; TVirtualGeoPainter.h; TBuffer3DGeneric 3D primitive description class.Definition TBuffer3D.h:18; TGeoBatemanSolDefinition TGeoElement.h:286; TGeoCheckerGeometry checking package.Definition TGeoChecker.h:37; TGeoHMatrixMatrix class used for computing global transformations Should NOT be used for node definition.Definition TGeoMatrix.h:458; TGeoIteratorPluginDefinition TGeoNode.h:224; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoMatrixGeometrical transformation package.Definition TGeoMatrix.h:38; TGeoNodeA node represent a volume positioned inside another.They store links to both volumes and to the TGeoM...Definition TGeoNode.h:39; TGeoOverlapBase class describing geometry overlaps.Definition TGeoOverlap.h:37; TGeoPainterClass implementing all draw interfaces for a generic 3D viewer using TBuffer3D mechanism.Definition TGeoPainter.h:39; TGeoPainter::AddTrackTVirtualGeoTrack * AddTrack(Int_t id, Int_t pdgcode, TObject *part) overrideCreate a primary TGeoTrack.Definition TGeoPainter.cxx:130; TGeoPainter::PaintOverlapvoid PaintOverlap(void *ovlp, Option_t *option="""") overridePaint an overlap.Definition TGeoPainter.cxx:1321; TGeoPainter::fBombZDouble_t fBombZDefinition TGeoPainter.h:43; TGeoPainter::EstimateCameraMovevoid EstimateCameraMove(Double_t tmin, Double_t tmax, Double_t *start, Double_t *end) overrideEstimate camera movement between tmin and tmax for best track display.Definition TGeoPainter.cxx:1039; TGeoPainter::fVisVolumesTObjArray * fVisVolumesDefinition TGeoPainter.h:69; TGeoPainter::fPluginTGeoIteratorPlugin * fPluginDefinition TGeoPainter.h:68; TGeoPainter::fMatDouble_t fMat[9]Definition TGeoPainter.h:46; TGeoPainter::SamplePointsTGeoNode * SamplePoints(Int_t npoints, Double_t &dist, Double_t epsil, const char *g3path) overri",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
Modifiability,plugin,plugin," fCheckedBox[6]; // bounding box of checked node; 46 Double_t fMat[9]; // view rotation matrix; 47 Int_t fNsegments; // number of segments approximating circles; 48 Int_t fNVisNodes; // number of visible nodes; 49 Int_t fVisLevel; // depth for drawing; 50 Int_t fVisOption; // global visualization option; 51 Int_t fExplodedView; // type of exploding current view; 52 Bool_t fVisLock; // lock for adding visible volumes; 53 Bool_t fTopVisible; // set top volume visible; 54 Bool_t fPaintingOverlaps; // lock overlaps painting; 55 Bool_t fIsRaytracing; // raytracing flag; 56 Bool_t fIsPaintingShape; // flag for shape painting; 57 TString fVisBranch; // drawn branch; 58 TString fVolInfo; // volume info; 59 TGeoNode *fCheckedNode; // checked node; 60 TGeoOverlap *fOverlap; // current overlap; 61 TGeoHMatrix *fGlobal; // current global matrix; 62 TBuffer3D *fBuffer; // buffer used for painting; 63 TGeoManager *fGeoManager; // geometry to which applies; 64 TGeoChecker *fChecker; // geometry checker; 65 TGeoShape *fClippingShape; // clipping shape; 66 TGeoVolume *fTopVolume; // top drawn volume; 67 TGeoVolume *fLastVolume; // last drawn volume; 68 TGeoIteratorPlugin *fPlugin; // User iterator plugin for changing pain volume properties; 69 TObjArray *fVisVolumes; // list of visible volumes; 70 Bool_t fIsEditable; // flag that geometry is editable; 71 ; 72 void DefineColors() const;; 73 void LocalToMasterVect(const Double_t *local, Double_t *master) const;; 74 ; 75protected:; 76 void ClearVisibleVolumes();; 77 ; 78public:; 79 TGeoPainter(TGeoManager *manager);; 80 ~TGeoPainter() override;; 81 ; 82 void AddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys) override;; 83 TVirtualGeoTrack *AddTrack(Int_t id, Int_t pdgcode, TObject *part) override;; 84 void AddTrackPoint(Double_t *point, Double_t *box, Bool_t reset = kFALSE) override;; 85 void BombTranslation(const Double_t *tr, Double_t *bombtr) override;; 86 void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
Performance,load,loaded,"on TGeoPainter.h:60; TGeoPainter::CheckGeometryvoid CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const overrideGeometry checking method (see TGeoChecker).Definition TGeoPainter.cxx:226; TGeoPainter::fBombYDouble_t fBombYDefinition TGeoPainter.h:42; TGeoPainter::fPaintingOverlapsBool_t fPaintingOverlapsDefinition TGeoPainter.h:54; TGeoPainter::CheckOverlapsvoid CheckOverlaps(const TGeoVolume *vol, Double_t ovlp=0.1, Option_t *option="""") const overrideCheck overlaps for the top volume of the geometry, within a limit OVLP.Definition TGeoPainter.cxx:234; TGeoPainter::SetBombFactorsvoid SetBombFactors(Double_t bombx=1.3, Double_t bomby=1.3, Double_t bombz=1.3, Double_t bombr=1.3) overrideSet cartesian and radial bomb factors for translations.Definition TGeoPainter.cxx:1949; TGeoPainter::DefaultColorsvoid DefaultColors() overrideSet default volume colors according to tracking media.Definition TGeoPainter.cxx:570; TGeoPainter::CheckEditvoid CheckEdit()Check if Ged library is loaded and load geometry editor classe.Definition TGeoPainter.cxx:682; TGeoPainter::GetVisLevelInt_t GetVisLevel() const overrideDefinition TGeoPainter.h:130; TGeoPainter::CheckBoundaryErrorsvoid CheckBoundaryErrors(Int_t ntracks=1000000, Double_t radius=-1.) overrideCheck pushes and pulls needed to cross the next boundary with respect to the position given by FindNe...Definition TGeoPainter.cxx:200; TGeoPainter::ClearVisibleVolumesvoid ClearVisibleVolumes()Clear the list of visible volumes reset the kVisOnScreen bit for volumes previously in the list.Definition TGeoPainter.cxx:263; TGeoPainter::GetColorInt_t GetColor(Int_t base, Float_t light) const overrideGet index of a base color with given light intensity (0,1)Definition TGeoPainter.cxx:292; TGeoPainter::LocalToMasterVectvoid LocalToMasterVect(const Double_t *local, Double_t *master) constConvert a local vector according view rotation matrix.Definition TGeoPainter.cxx:1249; TGeoPainter::DrawVolumevoid DrawVolume(TG",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
Safety,safe,safety,"operties; 69 TObjArray *fVisVolumes; // list of visible volumes; 70 Bool_t fIsEditable; // flag that geometry is editable; 71 ; 72 void DefineColors() const;; 73 void LocalToMasterVect(const Double_t *local, Double_t *master) const;; 74 ; 75protected:; 76 void ClearVisibleVolumes();; 77 ; 78public:; 79 TGeoPainter(TGeoManager *manager);; 80 ~TGeoPainter() override;; 81 ; 82 void AddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys) override;; 83 TVirtualGeoTrack *AddTrack(Int_t id, Int_t pdgcode, TObject *part) override;; 84 void AddTrackPoint(Double_t *point, Double_t *box, Bool_t reset = kFALSE) override;; 85 void BombTranslation(const Double_t *tr, Double_t *bombtr) override;; 86 void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.) override;; 87 void CheckBoundaryReference(Int_t icheck = -1) override;; 88 void CheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000,; 89 const Double_t *vertex = nullptr) override;; 90 void CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const override;; 91 void CheckEdit();; 92 void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t *option = """", Double_t safety = 0.) override;; 93 void CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option) override;; 94 void CheckOverlaps(const TGeoVolume *vol, Double_t ovlp = 0.1, Option_t *option = """") const override;; 95 Int_t CountNodes(TGeoVolume *vol, Int_t level) const;; 96 Int_t CountVisibleNodes() override;; 97 void DefaultAngles() override;; 98 void DefaultColors() override;; 99 Int_t DistanceToPrimitiveVol(TGeoVolume *vol, Int_t px, Int_t py) override;; 100 void Draw(Option_t *option = """") override;; 101 void DrawBatemanSol(TGeoBatemanSol *sol, Option_t *option = """") override;; 102 void DrawOverlap(void *ovlp, Option_t *option = """") override;; 103 void DrawCurrentPoint(Int_t color) override;; 104 void DrawOnly(Option_t *option = """") override;; 105 void",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
Testability,test,testNo,"oManager *manager);; 80 ~TGeoPainter() override;; 81 ; 82 void AddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys) override;; 83 TVirtualGeoTrack *AddTrack(Int_t id, Int_t pdgcode, TObject *part) override;; 84 void AddTrackPoint(Double_t *point, Double_t *box, Bool_t reset = kFALSE) override;; 85 void BombTranslation(const Double_t *tr, Double_t *bombtr) override;; 86 void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.) override;; 87 void CheckBoundaryReference(Int_t icheck = -1) override;; 88 void CheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000,; 89 const Double_t *vertex = nullptr) override;; 90 void CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const override;; 91 void CheckEdit();; 92 void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t *option = """", Double_t safety = 0.) override;; 93 void CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option) override;; 94 void CheckOverlaps(const TGeoVolume *vol, Double_t ovlp = 0.1, Option_t *option = """") const override;; 95 Int_t CountNodes(TGeoVolume *vol, Int_t level) const;; 96 Int_t CountVisibleNodes() override;; 97 void DefaultAngles() override;; 98 void DefaultColors() override;; 99 Int_t DistanceToPrimitiveVol(TGeoVolume *vol, Int_t px, Int_t py) override;; 100 void Draw(Option_t *option = """") override;; 101 void DrawBatemanSol(TGeoBatemanSol *sol, Option_t *option = """") override;; 102 void DrawOverlap(void *ovlp, Option_t *option = """") override;; 103 void DrawCurrentPoint(Int_t color) override;; 104 void DrawOnly(Option_t *option = """") override;; 105 void DrawPanel() override;; 106 void DrawPath(const char *path, Option_t *option = """") override;; 107 void DrawPolygon(const TGeoPolygon *poly) override;; 108 void DrawShape(TGeoShape *shape, Option_t *option = """") override;; 109 void DrawVolume(TGeoVolume *vol, Option_t *option = """") override;; 110 void EditGeometry(Opti",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
Usability,progress bar,progress bar,"ter::PaintPhysicalNodevoid PaintPhysicalNode(TGeoPhysicalNode *node, Option_t *option="""")Paints a physical node associated with a path.Definition TGeoPainter.cxx:1609; TGeoPainter::fNVisNodesInt_t fNVisNodesDefinition TGeoPainter.h:48; TGeoPainter::fExplodedViewInt_t fExplodedViewDefinition TGeoPainter.h:51; TGeoPainter::GetVolumeInfoconst char * GetVolumeInfo(const TGeoVolume *volume, Int_t px, Int_t py) const overrideGet some info about the current selected volume.Definition TGeoPainter.cxx:1151; TGeoPainter::SetClippingShapevoid SetClippingShape(TGeoShape *shape) overrideDefinition TGeoPainter.h:160; TGeoPainter::DrawCurrentPointvoid DrawCurrentPoint(Int_t color) overrideDraw current point in the same view.Definition TGeoPainter.cxx:1004; TGeoPainter::DrawPathvoid DrawPath(const char *path, Option_t *option="""") overrideDraw all volumes for a given path.Definition TGeoPainter.cxx:1026; TGeoPainter::OpProgressvoid OpProgress(const char *opname, Long64_t current, Long64_t size, TStopwatch *watch=nullptr, Bool_t last=kFALSE, Bool_t refresh=kFALSE, const char *msg="""") overrideText progress bar.Definition TGeoPainter.cxx:1684; TGeoPainter::SetCheckedNodevoid SetCheckedNode(TGeoNode *node) overrideSelect a node to be checked for overlaps.Definition TGeoPainter.cxx:2016; TGeoPainter::DrawBatemanSolvoid DrawBatemanSol(TGeoBatemanSol *sol, Option_t *option="""") overrideDraw the time evolution of a radionuclide.Definition TGeoPainter.cxx:726; TGeoPainter::fCheckerTGeoChecker * fCheckerDefinition TGeoPainter.h:64; TGeoPainter::IsRaytracingBool_t IsRaytracing() const overrideDefinition TGeoPainter.h:137; TGeoPainter::fIsRaytracingBool_t fIsRaytracingDefinition TGeoPainter.h:55; TGeoPainter::ExecuteShapeEventvoid ExecuteShapeEvent(TGeoShape *shape, Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on a given shape.Definition TGeoPainter.cxx:1089; TGeoPainter::GetViewBoxDouble_t * GetViewBox() overrideDefinition TGeoPainter.h:134; TGeoPainter::WeightDouble_t Weight(",MatchSource.WIKI,doc/master/TGeoPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html
Availability,avail,available,"//////////////////////////; 472/// Refresh this physical node. Called for all registered physical nodes; 473/// after an Align() call.; 474 ; 475void TGeoPhysicalNode::Refresh(); 476{; 477 SetPath(fName.Data());; 478}; 479 ; 480////////////////////////////////////////////////////////////////////////////////; 481/// Set node branch according to current state; 482 ; 483void TGeoPhysicalNode::SetBranchAsState(); 484{; 485 TGeoNodeCache *cache = gGeoManager->GetCache();; 486 if (!cache) {; 487 Error(""SetBranchAsState"", ""no state available"");; 488 return;; 489 }; 490 if (!cache->IsDummy()) {; 491 Error(""SetBranchAsState"", ""not implemented for full cache"");; 492 return;; 493 }; 494 if (!fNodes); 495 fNodes = new TObjArray(30);; 496 if (!fMatrices); 497 fMatrices = new TObjArray(30);; 498 TGeoHMatrix **matrices = (TGeoHMatrix **)cache->GetMatrices();; 499 TGeoNode **branch = (TGeoNode **)cache->GetBranch();; 500 ; 501 Bool_t refresh = (fLevel > 0) ? kTRUE : kFALSE;; 502 if (refresh) {; 503 TGeoHMatrix *current;; 504 for (Int_t i = 0; i <= fLevel; i++) {; 505 fNodes->AddAtAndExpand(branch[i], i);; 506 current = (TGeoHMatrix *)fMatrices->UncheckedAt(i);; 507 *current = *matrices[i];; 508 }; 509 return;; 510 }; 511 fLevel = gGeoManager->GetLevel();; 512 for (Int_t i = 0; i <= fLevel; i++) {; 513 fNodes->AddAtAndExpand(branch[i], i);; 514 fMatrices->AddAtAndExpand(new TGeoHMatrix(*matrices[i]), i);; 515 }; 516 TGeoNode *node = (TGeoNode *)fNodes->UncheckedAt(fLevel);; 517 if (!fMatrixOrig); 518 fMatrixOrig = new TGeoHMatrix();; 519 *fMatrixOrig = node->GetMatrix();; 520}; 521 ; 522////////////////////////////////////////////////////////////////////////////////; 523/// Allows PN entries (or users) to preset the local original matrix for the; 524/// last node pointed by the path.; 525 ; 526void TGeoPhysicalNode::SetMatrixOrig(const TGeoMatrix *local); 527{; 528 if (!fMatrixOrig); 529 fMatrixOrig = new TGeoHMatrix();; 530 if (!local) {; 531 fMatrixOrig->Clear();; 532 return;; 533",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
Deployability,update,update,"->RemoveAt(i);; 260 vm->GetNodes()->AddAt(newnode, i);; 261 shared = kTRUE;; 262 }; 263 if (!shared); 264 Error(""Align"", ""The matrix replaced for %s is not actually shared"", GetName());; 265 } else {; 266 // The aligned node may have a composite shape containing a shared matrix; 267 if (vd->GetShape()->IsComposite()) {; 268 cs = (TGeoCompositeShape *)vd->GetShape();; 269 if (cs->GetBoolNode()->GetRightMatrix()->IsShared()) {; 270 if (!nnode->GetMatrix()->IsIdentity()) {; 271 Error(""Align"", ""The composite shape having a shared matrix on the subtracted branch must be ""; 272 ""positioned using identity matrix."");; 273 return kFALSE;; 274 }; 275 // We have to put the alignment matrix on top of the left branch; 276 // of the composite shape. The node is already decoupled from logical tree.; 277 TGeoCompositeShape *ncs = new TGeoCompositeShape(cs->GetName(), cs->GetBoolNode()->MakeClone());; 278 TGeoMatrix *oldmat = ncs->GetBoolNode()->GetLeftMatrix();; 279 TGeoHMatrix *newmat1 = new TGeoHMatrix(*newmat);; 280 newmat1->Multiply(oldmat);; 281 ncs->GetBoolNode()->ReplaceMatrix(oldmat, newmat1);; 282 vd->SetShape(ncs);; 283 // The right-side matrix pointer is preserved, so no need to update nodes.; 284 aligned = nullptr; // to prevent updating its matrix; 285 }; 286 }; 287 }; 288 // Register matrix and make it the active one; 289 if (!newmat->IsRegistered()); 290 newmat->RegisterYourself();; 291 if (aligned) {; 292 aligned->SetMatrix(newmat);; 293 // Update the global matrix for the aligned node; 294 TGeoHMatrix *global = GetMatrix();; 295 TGeoHMatrix *up = GetMatrix(fLevel - 1);; 296 *global = up;; 297 global->Multiply(newmat);; 298 }; 299 }; 300 // Change the shape for the aligned node; 301 if (newshape); 302 vd->SetShape(newshape);; 303 ; 304 // Re-compute bounding box of mother(s) if needed; 305 for (i = fLevel - 1; i > 0; i--) {; 306 Bool_t dassm = vd->IsAssembly(); // is daughter assembly ?; 307 vd = GetVolume(i);; 308 if (!vd); 309 break;; 310 Bool_t cassm = vd->IsAsse",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
Integrability,message,message,"ass for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::fNameTString fNameDefinition TNamed.h:32; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AddAtvoid AddAt(TObject *obj, Int_t idx) overrideAdd object at position ids.Definition TObjArray.cxx:254; TObjArray::AddAtAndExpandvirtual void AddAtAndExpand(TObject *obj, Int_t idx)Add object at position idx.Definition TObjArray.cxx:235; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjArray::RemoveAtTObject * RemoveAt(Int_t idx) overrideRemove object at index idx.Definition TObjArray.cxx:694; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TVirtualGeoPainterAbstract class for geometry painters.Definition TVirtualGeoPainter.h:32; bool; double; int. geomgeomsrcTGeoPhysicalNode.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
Modifiability,enhance,enhances,"///////////////////////////////////////////////////; 538/// Specify the path for this node.; 539 ; 540Bool_t TGeoPhysicalNode::SetPath(const char *path); 541{; 542 if (!gGeoManager->cd(path)) {; 543 Error(""SetPath"", ""wrong path -> maybe RestoreMasterVolume"");; 544 return kFALSE;; 545 }; 546 SetBranchAsState();; 547 return kTRUE;; 548}; 549 ; 550////////////////////////////////////////////////////////////////////////////////; 551/// Checks if a given navigator state matches this physical node; 552 ; 553Bool_t TGeoPhysicalNode::IsMatchingState(TGeoNavigator *nav) const; 554{; 555 TGeoNodeCache *cache = nav->GetCache();; 556 if (!cache) {; 557 Fatal(""SetBranchAsState"", ""no state available"");; 558 return kFALSE;; 559 }; 560 // the first condition is that the levels of navigator and this physical node must match; 561 if (cache->GetLevel() != fLevel) {; 562 return kFALSE;; 563 }; 564 // now we compare the nodes at each level; 565 // starting backwards since that enhances the probability of an early return; 566 TGeoNode **branch = (TGeoNode **)cache->GetBranch();; 567 for (Int_t i = fLevel; i >= 1; --i); 568 if (fNodes->At(i) != branch[i]); 569 return kFALSE;; 570 return kTRUE;; 571}; 572 ; 573ClassImp(TGeoPNEntry);; 574 ; 575////////////////////////////////////////////////////////////////////////////////; 576/// Default constructor; 577 ; 578TGeoPNEntry::TGeoPNEntry(); 579{; 580 fNode = nullptr;; 581 fMatrix = nullptr;; 582 fGlobalOrig = nullptr;; 583}; 584 ; 585////////////////////////////////////////////////////////////////////////////////; 586/// Default constructor; 587 ; 588TGeoPNEntry::TGeoPNEntry(const char *name, const char *path) : TNamed(name, path); 589{; 590 if (!gGeoManager || !gGeoManager->IsClosed() || !gGeoManager->CheckPath(path)) {; 591 TString errmsg(""Cannot define a physical node link without a closed geometry and a valid path !"");; 592 Error(""ctor"", ""%s"", errmsg.Data());; 593 throw errmsg;; 594 return;; 595 }; 596 gGeoManager->PushPath();; 597 gGeoMana",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
Performance,perform,perform,"t char *path) : TNamed(path, """"); 93{; 94 if (!path[0]) {; 95 Error(""ctor"", ""path not valid"");; 96 return;; 97 }; 98 fLevel = 0;; 99 fMatrices = new TObjArray(30);; 100 fNodes = new TObjArray(30);; 101 fMatrixOrig = nullptr;; 102 SetPath(path);; 103 SetVisibility(kTRUE);; 104 SetVisibleFull(kFALSE);; 105 SetIsVolAtt(kTRUE);; 106 SetAligned(kFALSE);; 107}; 108 ; 109////////////////////////////////////////////////////////////////////////////////; 110/// Destructor; 111 ; 112TGeoPhysicalNode::~TGeoPhysicalNode(); 113{; 114 if (fMatrices) {; 115 fMatrices->Delete();; 116 delete fMatrices;; 117 }; 118 if (fNodes); 119 delete fNodes;; 120 if (fMatrixOrig); 121 delete fMatrixOrig;; 122}; 123 ; 124////////////////////////////////////////////////////////////////////////////////; 125/// Align a physical node with a new relative matrix/shape.; 126/// Example: /TOP_1/A_1/B_1/C_1; 127/// node->Align(transl_1, box) will perform:; 128/// - change RELATIVE translation of C_1 node (with respect to its; 129/// container volume B) to transl_1; 130/// - change the shape of the C volume; 131/// *NOTE* The operations will affect ONLY the LAST node in the branch. All; 132/// volumes/nodes in the branch represented by this physical node are; 133/// CLONED so the operation does not affect other possible replicas.; 134 ; 135Bool_t TGeoPhysicalNode::Align(TGeoMatrix *newmat, TGeoShape *newshape, Bool_t check, Double_t ovlp); 136{; 137 if (!newmat && !newshape); 138 return kFALSE;; 139 if (TGeoManager::IsLocked()) {; 140 Error(""Align"", ""Not performed. Geometry in LOCKED mode !"");; 141 return kFALSE;; 142 }; 143 if (newmat == gGeoIdentity) {; 144 Error(""Align"", ""Cannot align using gGeoIdentity. Use some default matrix constructor to represent identities."");; 145 return kFALSE;; 146 }; 147 TGeoNode *node = GetNode();; 148 if (node->IsOffset()) {; 149 Error(""Align"", ""Cannot align division nodes: %s\n"", node->GetName());; 150 return kFALSE;; 151 }; 152 // Refresh the node since other Align calls ma",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
Safety,detect,detector," Matches. TGeoPhysicalNode.cxx. Go to the documentation of this file. 1// @(#)root/geom:$Id$; 2// Author: Andrei Gheata 17/02/04; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TGeoPhysicalNode; 13\ingroup Geometry_classes; 14 ; 15Physical nodes are the actual 'touchable' objects in the geometry, representing; 16a path of positioned volumes starting with the top node:; 17 path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes.; 18 ; 19The number of physical nodes is given by the total number of possible of; 20branches in the geometry hierarchy. In case of detector geometries and; 21specially for calorimeters this number can be of the order 1e6-1e9, therefore; 22it is impossible to create all physical nodes as objects in memory. In TGeo,; 23physical nodes are represented by the class TGeoPhysicalNode and can be created; 24on demand for alignment purposes:; 25 ; 26~~~ {.cpp}; 27 TGeoPhysicalNode *pn = new TGeoPhysicalNode(""path_to_object""); 28~~~; 29 ; 30Once created, a physical node can be misaligned, meaning that its position; 31or even shape can be changed:; 32 ; 33~~~ {.cpp}; 34 pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE); 35~~~; 36*/; 37 ; 38/** \class TGeoPNEntry; 39\ingroup Geometry_classes; 40 ; 41The knowledge of the path to the objects that need to be misaligned is; 42essential since there is no other way of identifying them. One can however; 43create 'symbolic links' to any complex path to make it more representable; 44for the object it designates:; 45 ; 46~~~ {.cpp}; 47 TGeoPNEntry *pne = new TGeoPNEntry(""TPC_SECTOR_2"", ""path_to_tpc_sect2"");; 48 pne->SetPhysicalNode(pn); 49~~~; 5",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
Testability,log,logical,";; 252 return kFALSE;; 253 }; 254 newnode->SetVolume(newvol);; 255 newnode->SetMotherVolume(vm);; 256 if (vm->TestBit(TGeoVolume::kVolumeImportNodes)) {; 257 gGeoManager->GetListOfGShapes()->Add(newnode);; 258 }; 259 vm->GetNodes()->RemoveAt(i);; 260 vm->GetNodes()->AddAt(newnode, i);; 261 shared = kTRUE;; 262 }; 263 if (!shared); 264 Error(""Align"", ""The matrix replaced for %s is not actually shared"", GetName());; 265 } else {; 266 // The aligned node may have a composite shape containing a shared matrix; 267 if (vd->GetShape()->IsComposite()) {; 268 cs = (TGeoCompositeShape *)vd->GetShape();; 269 if (cs->GetBoolNode()->GetRightMatrix()->IsShared()) {; 270 if (!nnode->GetMatrix()->IsIdentity()) {; 271 Error(""Align"", ""The composite shape having a shared matrix on the subtracted branch must be ""; 272 ""positioned using identity matrix."");; 273 return kFALSE;; 274 }; 275 // We have to put the alignment matrix on top of the left branch; 276 // of the composite shape. The node is already decoupled from logical tree.; 277 TGeoCompositeShape *ncs = new TGeoCompositeShape(cs->GetName(), cs->GetBoolNode()->MakeClone());; 278 TGeoMatrix *oldmat = ncs->GetBoolNode()->GetLeftMatrix();; 279 TGeoHMatrix *newmat1 = new TGeoHMatrix(*newmat);; 280 newmat1->Multiply(oldmat);; 281 ncs->GetBoolNode()->ReplaceMatrix(oldmat, newmat1);; 282 vd->SetShape(ncs);; 283 // The right-side matrix pointer is preserved, so no need to update nodes.; 284 aligned = nullptr; // to prevent updating its matrix; 285 }; 286 }; 287 }; 288 // Register matrix and make it the active one; 289 if (!newmat->IsRegistered()); 290 newmat->RegisterYourself();; 291 if (aligned) {; 292 aligned->SetMatrix(newmat);; 293 // Update the global matrix for the aligned node; 294 TGeoHMatrix *global = GetMatrix();; 295 TGeoHMatrix *up = GetMatrix(fLevel - 1);; 296 *global = up;; 297 global->Multiply(newmat);; 298 }; 299 }; 300 // Change the shape for the aligned node; 301 if (newshape); 302 vd->SetShape(newshape);; 303 ; 304 // R",MatchSource.WIKI,doc/master/TGeoPhysicalNode_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html
Availability,error,error,"fine ROOT_TGeoShape; 14 ; 15#include ""TNamed.h""; 16 ; 17// forward declarations; 18class TGeoBoolCombinator;; 19class TGeoBBox;; 20class TGeoMatrix;; 21class TGeoHMatrix;; 22class TGeoVolume;; 23class TBuffer3D;; 24 ; 25class TGeoShape : public TNamed {; 26private:; 27 static TGeoMatrix *fgTransform; // current transformation matrix that applies to shape; 28 static Double_t fgEpsMch; // Machine round-off error; 29public:; 30 enum EShapeType {; 31 kBitMask32 = 0xffffffff,; 32 kGeoNoShape = 0,; 33 kGeoBad = BIT(0),; 34 kGeoRSeg = BIT(1),; 35 kGeoPhiSeg = BIT(2),; 36 kGeoThetaSeg = BIT(3),; 37 kGeoVisX = BIT(4),; 38 kGeoVisY = BIT(5),; 39 kGeoVisZ = BIT(6),; 40 kGeoRunTimeShape = BIT(7),; 41 kGeoInvalidShape = BIT(8),; 42 kGeoTorus = BIT(9),; 43 kGeoBox = BIT(10),; 44 kGeoPara = BIT(11),; 45 kGeoSph = BIT(12),; 46 kGeoTube = BIT(13),; 47 kGeoTubeSeg = BIT(14),; 48 kGeoCone = BIT(15),; 49 kGeoConeSeg = BIT(16),; 50 kGeoPcon = BIT(17),; 51 kGeoPgon = BIT(18),; 52 kGeoArb8 = BIT(19),; 53 kGeoEltu = BIT(20),; 54 kGeoTrap = BIT(21),; 55 kGeoCtub = BIT(22),; 56 kGeoTrd1 = BIT(23),; 57 kGeoTrd2 = BIT(24),; 58 kGeoComb = BIT(25),; 59 kGeoClosedShape = BIT(26),; 60 kGeoXtru = BIT(27),; 61 kGeoParaboloid = BIT(28),; 62 kGeoHalfSpace = BIT(29),; 63 kGeoHype = BIT(30),; 64 kGeoSavePrimitive = BIT(20); 65 };; 66 virtual void ClearThreadData() const {}; 67 virtual void CreateThreadData(Int_t) {}; 68 ; 69protected:; 70 // data members; 71 Int_t fShapeId; // shape id; 72 UInt_t fShapeBits; // shape bits; 73 // methods; 74 virtual void FillBuffer3D(TBuffer3D &buffer, Int_t reqSections, Bool_t localFrame) const;; 75 Int_t GetBasicColor() const;; 76 void SetOnBoundary(Bool_t /*flag=kTRUE*/) {}; 77 void TransformPoints(Double_t *points, UInt_t NbPoints) const;; 78 ; 79public:; 80 // constructors; 81 TGeoShape();; 82 TGeoShape(const char *name);; 83 // destructor; 84 ~TGeoShape() override;; 85 // methods; 86 ; 87 static Double_t Big() { return 1.E30; }; 88 static TGeoMatrix *GetTransform();",MatchSource.WIKI,doc/master/TGeoShape_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoShape_8h_source.html
Safety,safe,safe,,MatchSource.WIKI,doc/master/TGeoShape_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoShape_8h_source.html
Testability,test,testNo,,MatchSource.WIKI,doc/master/TGeoShape_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoShape_8h_source.html
Safety,safe,safe," TGeoTube(Double_t *params);; 34 // destructor; 35 ~TGeoTube() override;; 36 // methods; 37 ; 38 Double_t Capacity() const override;; 39 static Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz);; 40 void ComputeBBox() override;; 41 void ComputeNormal(const Double_t *point, const Double_t *dir, Double_t *norm) override;; 42 void ComputeNormal_v(const Double_t *points, const Double_t *dirs, Double_t *norms, Int_t vecsize) override;; 43 static void ComputeNormalS(const Double_t *point, const Double_t *dir, Double_t *norm, Double_t rmin, Double_t rmax,; 44 Double_t dz);; 45 Bool_t Contains(const Double_t *point) const override;; 46 void Contains_v(const Double_t *points, Bool_t *inside, Int_t vecsize) const override;; 47 static Double_t; 48 DistFromInsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax, Double_t dz);; 49 Double_t DistFromInside(const Double_t *point, const Double_t *dir, Int_t iact = 1, Double_t step = TGeoShape::Big(),; 50 Double_t *safe = nullptr) const override;; 51 void DistFromInside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 52 Double_t *step) const override;; 53 static Double_t; 54 DistFromOutsideS(const Double_t *point, const Double_t *dir, Double_t rmin, Double_t rmax, Double_t dz);; 55 Double_t DistFromOutside(const Double_t *point, const Double_t *dir, Int_t iact = 1,; 56 Double_t step = TGeoShape::Big(), Double_t *safe = nullptr) const override;; 57 void DistFromOutside_v(const Double_t *points, const Double_t *dirs, Double_t *dists, Int_t vecsize,; 58 Double_t *step) const override;; 59 static void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t &b, Double_t &delta);; 60 Int_t DistancetoPrimitive(Int_t px, Int_t py) override;; 61 TGeoVolume *; 62 Divide(TGeoVolume *voldiv, const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step) override;; 63 const char *GetAxisName(Int_t iaxis) const override;; 64 Double_t GetAxisR",MatchSource.WIKI,doc/master/TGeoTube_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoTube_8h_source.html
Availability,error,error," para - 1,2,3 means X,Y,Z; for; 305tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and; 306pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi.; 307 In fact, the division operation has the same effect as positioning volumes; 308in a given order inside the divided container - the advantage being that the; 309navigation in such a structure is much faster. When a volume is divided, a; 310volume family corresponding to the slices is created. In case all slices can; 311be represented by a single shape, only one volume is added to the family and; 312positioned N times inside the divided volume, otherwise, each slice will be; 313represented by a distinct volume in the family.; 314 Divisions can be also performed in a given range of one axis. For that, one; 315have to specify also the starting coordinate value and the step:; 316 ; 317~~~ {.cpp}; 318 TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N, start, step);; 319~~~; 320 ; 321A check is always done on the resulting division range : if not fitting into; 322the container limits, an error message is posted. If we will browse the divided; 323volume we will notice that it will contain N nodes starting with index 1 upto; 324N. The first one has the lower X limit at START position, while the last one; 325will have the upper X limit at START+N*STEP. The resulting slices cannot; 326be positioned inside an other volume (they are by default positioned inside the; 327divided one) but can be further divided and may contain other volumes:; 328 ; 329~~~ {.cpp}; 330 TGeoVolume *slicey = slicex->Divide(""SLICEY"", 2, N1);; 331 slicey->AddNode(other_vol, index, some_matrix);; 332~~~; 333 ; 334 When doing that, we have to remember that SLICEY represents a family, therefore; 335all members of the family will be divided on Y and the other volume will be; 336added as node inside all.; 337 In the example above all the resulting slices had the same shape as the; 338divided volume (box). This is not alw",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
Deployability,release,released,"void TGeoVolume::SaveAs(const char *filename, Option_t *option) const; 1448{; 1449 if (!filename); 1450 return;; 1451 std::ofstream out;; 1452 out.open(filename, std::ios::out);; 1453 if (out.bad()) {; 1454 Error(""SavePrimitive"", ""Bad file name: %s"", filename);; 1455 return;; 1456 }; 1457 if (fGeoManager->GetTopVolume() != this); 1458 fGeoManager->SetTopVolume((TGeoVolume *)this);; 1459 ; 1460 TString fname(filename);; 1461 Int_t ind = fname.Index(""."");; 1462 if (ind > 0); 1463 fname.Remove(ind);; 1464 out << ""void "" << fname << ""() {"" << std::endl;; 1465 out << "" gSystem->Load(\""libGeom\"");"" << std::endl;; 1466 const UInt_t prec = TGeoManager::GetExportPrecision();; 1467 out << std::setprecision(prec);; 1468 ((TGeoVolume *)this)->SavePrimitive(out, option);; 1469 out << ""}"" << std::endl;; 1470}; 1471 ; 1472////////////////////////////////////////////////////////////////////////////////; 1473/// Connect user-defined extension to the volume. The volume ""grabs"" a copy, so; 1474/// the original object can be released by the producer. Release the previously; 1475/// connected extension if any.; 1476///; 1477/// NOTE: This interface is intended for user extensions and is guaranteed not; 1478/// to be used by TGeo; 1479 ; 1480void TGeoVolume::SetUserExtension(TGeoExtension *ext); 1481{; 1482 TGeoExtension* tmp = fUserExtension;; 1483 fUserExtension = nullptr;; 1484 if (ext); 1485 fUserExtension = ext->Grab();; 1486 if (tmp); 1487 tmp->Release();; 1488}; 1489 ; 1490////////////////////////////////////////////////////////////////////////////////; 1491/// Connect framework defined extension to the volume. The volume ""grabs"" a copy,; 1492/// so the original object can be released by the producer. Release the previously; 1493/// connected extension if any.; 1494///; 1495/// NOTE: This interface is intended for the use by TGeo and the users should; 1496/// NOT connect extensions using this method; 1497 ; 1498void TGeoVolume::SetFWExtension(TGeoExtension *ext); 1499{; 1500 TGeoE",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
Energy Efficiency,efficient,efficient,", 2, new TGeoTranslation(0.2,0,0));; 185~~~; 186 ; 187 The 2 nodes that we have created inside chamber will both point to a wire_co; 188object, but will be completely distinct : WIRE_CO_1 and WIRE_CO_2. We will; 189want now to place symmetrically 1000 chambers on a pad, following a pattern; 190of 20 rows and 50 columns. One way to do this will be to replicate our chamber; 191by positioning it 1000 times in different positions of the pad. Unfortunately,; 192this is far from being the optimal way of doing what we want.; 193Imagine that we would like to find out which of the 1000 chambers is containing; 194a (x,y,z) point defined in the pad reference. You will never have to do that,; 195since the modeller will take care of it for you, but let's guess what it has; 196to do. The most simple algorithm will just loop over all daughters, convert; 197the point from mother to local reference and check if the current chamber; 198contains the point or not. This might be efficient for pads with few chambers,; 199but definitely not for 1000. Fortunately the modeler is smarter than that and; 200create for each volume some optimization structures called voxels (see Voxelization); 201to minimize the penalty having too many daughters, but if you have 100 pads like; 202this in your geometry you will anyway loose a lot in your tracking performance.; 203 ; 204 The way out when volumes can be arranged according to simple patterns is the; 205usage of divisions. We will describe them in detail later on. Let's think now; 206at a different situation : instead of 1000 chambers of the same type, we may; 207have several types of chambers. Let's say all chambers are cylindrical and have; 208a wire inside, but their dimensions are different. However, we would like all; 209to be represented by a single volume family, since they have the same properties.; 210*/; 211 ; 212/** \class TGeoVolumeMulti; 213\ingroup Geometry_classes; 214 ; 215Volume families; 216 ; 217A volume family is represented by the",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
Integrability,message,message," para - 1,2,3 means X,Y,Z; for; 305tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and; 306pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi.; 307 In fact, the division operation has the same effect as positioning volumes; 308in a given order inside the divided container - the advantage being that the; 309navigation in such a structure is much faster. When a volume is divided, a; 310volume family corresponding to the slices is created. In case all slices can; 311be represented by a single shape, only one volume is added to the family and; 312positioned N times inside the divided volume, otherwise, each slice will be; 313represented by a distinct volume in the family.; 314 Divisions can be also performed in a given range of one axis. For that, one; 315have to specify also the starting coordinate value and the step:; 316 ; 317~~~ {.cpp}; 318 TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N, start, step);; 319~~~; 320 ; 321A check is always done on the resulting division range : if not fitting into; 322the container limits, an error message is posted. If we will browse the divided; 323volume we will notice that it will contain N nodes starting with index 1 upto; 324N. The first one has the lower X limit at START position, while the last one; 325will have the upper X limit at START+N*STEP. The resulting slices cannot; 326be positioned inside an other volume (they are by default positioned inside the; 327divided one) but can be further divided and may contain other volumes:; 328 ; 329~~~ {.cpp}; 330 TGeoVolume *slicey = slicex->Divide(""SLICEY"", 2, N1);; 331 slicey->AddNode(other_vol, index, some_matrix);; 332~~~; 333 ; 334 When doing that, we have to remember that SLICEY represents a family, therefore; 335all members of the family will be divided on Y and the other volume will be; 336added as node inside all.; 337 In the example above all the resulting slices had the same shape as the; 338divided volume (box). This is not alw",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
Modifiability,inherit,inherits,"nique volume object, but may also represent more general a family (class); 25of volume objects having the same shape type and medium, but possibly; 26different shape parameters. It is the user's task to provide different names; 27for different volume families in order to avoid ambiguities at tracking time.; 28A generic family rather than a single volume is created only in two cases :; 29when a generic shape is provided to the volume constructor or when a division; 30operation is applied. Each volume in the geometry stores an unique; 31ID corresponding to its family. In order to ease-up their creation, the manager; 32class is providing an API that allows making a shape and a volume in a single step.; 33 ; 34 Volumes are objects that can be visualized, therefore having visibility,; 35colour, line and fill attributes that can be defined or modified any time after; 36the volume creation. It is advisable however to define these properties just; 37after the first creation of a volume namespace, since in case of volume families; 38any new member created by the modeler inherits these properties.; 39 ; 40 In order to provide navigation features, volumes have to be able to find; 41the proper container of any point defined in the local reference frame. This; 42can be the volume itself, one of its positioned daughter volumes or none if; 43the point is actually outside. On the other hand, volumes have to provide also; 44other navigation methods such as finding the distances to its shape boundaries; 45or which daughter will be crossed first. The implementation of these features; 46is done at shape level, but the local mother-daughters management is handled; 47by volumes that builds additional optimisation structures upon geometry closure.; 48In order to have navigation features properly working one has to follow the; 49general rules for building a valid geometry (see TGeoManager class).; 50 ; 51 Now let's make a simple volume representing a copper wire. We suppose that; 52a mediu",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
Performance,optimiz,optimization,"_CO_2. We will; 189want now to place symmetrically 1000 chambers on a pad, following a pattern; 190of 20 rows and 50 columns. One way to do this will be to replicate our chamber; 191by positioning it 1000 times in different positions of the pad. Unfortunately,; 192this is far from being the optimal way of doing what we want.; 193Imagine that we would like to find out which of the 1000 chambers is containing; 194a (x,y,z) point defined in the pad reference. You will never have to do that,; 195since the modeller will take care of it for you, but let's guess what it has; 196to do. The most simple algorithm will just loop over all daughters, convert; 197the point from mother to local reference and check if the current chamber; 198contains the point or not. This might be efficient for pads with few chambers,; 199but definitely not for 1000. Fortunately the modeler is smarter than that and; 200create for each volume some optimization structures called voxels (see Voxelization); 201to minimize the penalty having too many daughters, but if you have 100 pads like; 202this in your geometry you will anyway loose a lot in your tracking performance.; 203 ; 204 The way out when volumes can be arranged according to simple patterns is the; 205usage of divisions. We will describe them in detail later on. Let's think now; 206at a different situation : instead of 1000 chambers of the same type, we may; 207have several types of chambers. Let's say all chambers are cylindrical and have; 208a wire inside, but their dimensions are different. However, we would like all; 209to be represented by a single volume family, since they have the same properties.; 210*/; 211 ; 212/** \class TGeoVolumeMulti; 213\ingroup Geometry_classes; 214 ; 215Volume families; 216 ; 217A volume family is represented by the class TGeoVolumeMulti. It represents; 218a class of volumes having the same shape type and each member will be; 219identified by the same name and volume ID. Any operation applied to a; 220TGeoVo",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
Safety,avoid,avoid,"or the list of contributors see $ROOTSYS/README/CREDITS. *; 11 *************************************************************************/; 12 ; 13/** \class TGeoVolume; 14\ingroup Shapes_classes; 15 ; 16TGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes; 17 ; 18 Volumes are the basic objects used in building the geometrical hierarchy.; 19They represent unpositioned objects but store all information about the; 20placement of the other volumes they may contain. Therefore a volume can; 21be replicated several times in the geometry. In order to create a volume, one; 22has to put together a shape and a medium which are already defined. Volumes; 23have to be named by users at creation time. Every different name may represent a; 24an unique volume object, but may also represent more general a family (class); 25of volume objects having the same shape type and medium, but possibly; 26different shape parameters. It is the user's task to provide different names; 27for different volume families in order to avoid ambiguities at tracking time.; 28A generic family rather than a single volume is created only in two cases :; 29when a generic shape is provided to the volume constructor or when a division; 30operation is applied. Each volume in the geometry stores an unique; 31ID corresponding to its family. In order to ease-up their creation, the manager; 32class is providing an API that allows making a shape and a volume in a single step.; 33 ; 34 Volumes are objects that can be visualized, therefore having visibility,; 35colour, line and fill attributes that can be defined or modified any time after; 36the volume creation. It is advisable however to define these properties just; 37after the first creation of a volume namespace, since in case of volume families; 38any new member created by the modeler inherits these properties.; 39 ; 40 In order to provide navigation features, volumes have to be able to find; 41the proper container of any point defined in the loc",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
Testability,test,testNo,"=\n"", GetName());; 626 }; 627 painter->CheckOverlaps(this, ovlp, option);; 628 // if (sampling) return;; 629 if (!fGeoManager->IsCheckingOverlaps()) {; 630 fGeoManager->SortOverlaps();; 631 TObjArray *overlaps = fGeoManager->GetListOfOverlaps();; 632 Int_t novlps = overlaps->GetEntriesFast();; 633 TNamed *obj;; 634 TString name;; 635 for (Int_t i = 0; i < novlps; i++) {; 636 obj = (TNamed *)overlaps->At(i);; 637 if (novlps < 1000); 638 name = TString::Format(""ov%03d"", i);; 639 else; 640 name = TString::Format(""ov%06d"", i);; 641 obj->SetName(name);; 642 }; 643 if (novlps); 644 Info(""CheckOverlaps"", ""Number of illegal overlaps/extrusions for volume %s: %d\n"", GetName(), novlps);; 645 }; 646}; 647 ; 648////////////////////////////////////////////////////////////////////////////////; 649/// Tests for checking the shape navigation algorithms. See TGeoShape::CheckShape(); 650 ; 651void TGeoVolume::CheckShape(Int_t testNo, Int_t nsamples, Option_t *option); 652{; 653 fShape->CheckShape(testNo, nsamples, option);; 654}; 655 ; 656////////////////////////////////////////////////////////////////////////////////; 657/// Clean data of the volume.; 658 ; 659void TGeoVolume::CleanAll(); 660{; 661 ClearNodes();; 662 ClearShape();; 663}; 664 ; 665////////////////////////////////////////////////////////////////////////////////; 666/// Clear the shape of this volume from the list held by the current manager.; 667 ; 668void TGeoVolume::ClearShape(); 669{; 670 fGeoManager->ClearShape(fShape);; 671}; 672 ; 673////////////////////////////////////////////////////////////////////////////////; 674/// check for negative parameters in shapes.; 675 ; 676void TGeoVolume::CheckShapes(); 677{; 678 if (fShape->IsRunTimeShape()) {; 679 Error(""CheckShapes"", ""volume %s has run-time shape"", GetName());; 680 InspectShape();; 681 return;; 682 }; 683 if (!fNodes); 684 return;; 685 Int_t nd = fNodes->GetEntriesFast();; 686 TGeoNode *node = nullptr;; 687 TGeoNode *new_node;; 688 const TGeoShape *shape = nul",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
Usability,simpl,simple,"operties just; 37after the first creation of a volume namespace, since in case of volume families; 38any new member created by the modeler inherits these properties.; 39 ; 40 In order to provide navigation features, volumes have to be able to find; 41the proper container of any point defined in the local reference frame. This; 42can be the volume itself, one of its positioned daughter volumes or none if; 43the point is actually outside. On the other hand, volumes have to provide also; 44other navigation methods such as finding the distances to its shape boundaries; 45or which daughter will be crossed first. The implementation of these features; 46is done at shape level, but the local mother-daughters management is handled; 47by volumes that builds additional optimisation structures upon geometry closure.; 48In order to have navigation features properly working one has to follow the; 49general rules for building a valid geometry (see TGeoManager class).; 50 ; 51 Now let's make a simple volume representing a copper wire. We suppose that; 52a medium is already created (see TGeoMedium class on how to create media).; 53We will create a TUBE shape for our wire, having Rmin=0cm, Rmax=0.01cm; 54and a half-length dZ=1cm :; 55 ; 56~~~ {.cpp}; 57 TGeoTube *tube = new TGeoTube(""wire_tube"", 0, 0.01, 1);; 58~~~; 59 ; 60One may omit the name for the shape if no retrieving by name is further needed; 61during geometry building. The same shape can be shared by different volumes; 62having different names and materials. Now let's make the volume for our wire.; 63The prototype for volumes constructor looks like :; 64 ; 65 TGeoVolume::TGeoVolume(const char *name, TGeoShape *shape, TGeoMedium *med); 66 ; 67Since TGeoTube derives from the base shape class, we can provide it to the volume; 68constructor :; 69 ; 70~~~ {.cpp}; 71 TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);; 72~~~; 73 ; 74Do not bother to delete neither the media, shapes or volumes that you have; 75create",MatchSource.WIKI,doc/master/TGeoVolume_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html
Availability,down,down,"tensionTGeoExtension * GrabUserExtension() constGet a copy of the user extension pointer.Definition TGeoVolume.cxx:1513; TGeoVolume::EGeoVolumeTypesEGeoVolumeTypesDefinition TGeoVolume.h:71; TGeoVolume::kVolumeClone@ kVolumeCloneDefinition TGeoVolume.h:80; TGeoVolume::kVolumeOverlap@ kVolumeOverlapDefinition TGeoVolume.h:75; TGeoVolume::kVolumeReplicated@ kVolumeReplicatedDefinition TGeoVolume.h:72; TGeoVolume::kVoxelsCyl@ kVoxelsCylDefinition TGeoVolume.h:79; TGeoVolume::kVolumeDiv@ kVolumeDivDefinition TGeoVolume.h:74; TGeoVolume::kVolumeOC@ kVolumeOCDefinition TGeoVolume.h:82; TGeoVolume::kVolumeSelected@ kVolumeSelectedDefinition TGeoVolume.h:73; TGeoVolume::kVolumeMulti@ kVolumeMultiDefinition TGeoVolume.h:77; TGeoVolume::kVolumeImportNodes@ kVolumeImportNodesDefinition TGeoVolume.h:76; TGeoVolume::kVolumeAdded@ kVolumeAddedDefinition TGeoVolume.h:81; TGeoVolume::kVoxelsXYZ@ kVoxelsXYZDefinition TGeoVolume.h:78; TGeoVolume::CountNodesInt_t CountNodes(Int_t nlevels=1000, Int_t option=0)Count total number of subnodes starting from this volume, nlevels down.Definition TGeoVolume.cxx:730; TGeoVolume::GrabFocusvoid GrabFocus()Move perspective view focus to this volume.Definition TGeoVolume.cxx:1812; TGeoVolume::UnmarkSavedvoid UnmarkSaved()Reset SavePrimitive bits.Definition TGeoVolume.cxx:1699; TGeoVolume::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on this volume.Definition TGeoVolume.cxx:1710; TGeoVolume::CloneVolumevirtual TGeoVolume * CloneVolume() constClone this volume.Definition TGeoVolume.cxx:1831; TGeoVolume::SetFindervoid SetFinder(TGeoPatternFinder *finder)Definition TGeoVolume.h:244; TGeoVolume::GetNdaughtersInt_t GetNdaughters() constDefinition TGeoVolume.h:362; TGeoVolume::IsValidBool_t IsValid() constDefinition TGeoVolume.h:154; TGeoVolume::Grabvoid Grab()Definition TGeoVolume.h:136; TGeoVolume::CheckGeometryvoid CheckGeometry(Int_t nrays=1, Double_t startx=0, Double_t starty=0, Double_t startz=0) const",MatchSource.WIKI,doc/master/TGeoVolume_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8h_source.html
Energy Efficiency,efficient,efficient,"playCreationvoid ReplayCreation(const TGeoVolume *other)Recreate the content of the other volume without pointer copying.Definition TGeoVolume.cxx:1292; TGeoVolume::WeightDouble_t Weight(Double_t precision=0.01, Option_t *option=""va"")Estimate the weight of a volume (in kg) with SIGMA(M)/M better than PRECISION.Definition TGeoVolume.cxx:2501; TGeoVolume::fNumberInt_t fNumberoption - if anyDefinition TGeoVolume.h:55; TGeoVolume::CreateThreadDatavirtual void CreateThreadData(Int_t nthreads)Definition TGeoVolume.cxx:435; TGeoVolume::GetByteCountvirtual Int_t GetByteCount() constget the total size in bytes for this volumeDefinition TGeoVolume.cxx:2204; TGeoVolume::ContainsBool_t Contains(const Double_t *point) constDefinition TGeoVolume.h:104; TGeoVolume::AddNodevirtual TGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:975; TGeoVolume::OptimizeVoxelsBool_t OptimizeVoxels()Perform an extensive sampling to find which type of voxelization is most efficient.Definition TGeoVolume.cxx:1247; TGeoVolume::Browsevoid Browse(TBrowser *b) overrideHow to browse a volume.Definition TGeoVolume.cxx:535; TGeoVolume::SetCylVoxelsvoid SetCylVoxels(Bool_t flag=kTRUE)Definition TGeoVolume.h:218; TGeoVolume::SetCurrentPointvoid SetCurrentPoint(Double_t x, Double_t y, Double_t z)Set the current tracking point.Definition TGeoVolume.cxx:2059; TGeoVolume::Paintvoid Paint(Option_t *option="""") overridepaint volumeDefinition TGeoVolume.cxx:1267; TGeoVolume::SetVisOnlyvoid SetVisOnly(Bool_t flag=kTRUE) overrideSet visibility for leaves.Definition TGeoVolume.cxx:2393; TGeoVolume::fGeoManagerTGeoManager * fGeoManagerDefinition TGeoVolume.h:51; TGeoVolume::LegoPlotTH2F * LegoPlot(Int_t ntheta=20, Double_t themin=0., Double_t themax=180., Int_t nphi=60, Double_t phimin=0., Double_t phimax=360., Double_t rmin=0., Double_t rmax=9999999, Option_t *option="""")Generate a lego plot fot the top volume, acco",MatchSource.WIKI,doc/master/TGeoVolume_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8h_source.html
Performance,concurren,concurrent,,MatchSource.WIKI,doc/master/TGeoVolume_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8h_source.html
Testability,test,testNo,"ClearNodes() { fNodes = nullptr; }; 96 void ClearShape();; 97 void CleanAll();; 98 virtual TGeoVolume *CloneVolume() const;; 99 void CloneNodesAndConnect(TGeoVolume *newmother) const;; 100 void CheckGeometry(Int_t nrays = 1, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0) const;; 101 void CheckOverlaps(Double_t ovlp = 0.1, Option_t *option = """") const; // *MENU*; 102 void CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t *option = """"); // *MENU*; 103 Int_t CountNodes(Int_t nlevels = 1000, Int_t option = 0);; 104 Bool_t Contains(const Double_t *point) const { return fShape->Contains(point); }; 105 static void CreateDummyMedium();; 106 static TGeoMedium *DummyMedium();; 107 virtual Bool_t IsAssembly() const;; 108 Bool_t IsFolder() const override;; 109 Bool_t IsRunTime() const { return fShape->IsRunTimeShape(); }; 110 virtual Bool_t IsVolumeMulti() const { return kFALSE; }; 111 virtual TGeoNode *; 112 AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat = nullptr, Option_t *option = """"); // most general case; 113 void AddNodeOffset(TGeoVolume *vol, Int_t copy_no, Double_t offset = 0, Option_t *option = """");; 114 virtual void AddNodeOverlap(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat = nullptr, Option_t *option = """");; 115 ; 116 virtual TGeoVolume *Divide(const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step,; 117 Int_t numed = 0, Option_t *option = """");; 118 Int_t DistancetoPrimitive(Int_t px, Int_t py) override;; 119 void Draw(Option_t *option = """") override; // *MENU*; 120 virtual void DrawOnly(Option_t *option = """"); // *MENU*; 121 TH2F *LegoPlot(Int_t ntheta = 20, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 60,; 122 Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999,; 123 Option_t *option = """"); // *MENU*; 124 void Paint(Option_t *option = """") override;; 125 void Print(Option_t *option = """") const override; // *MENU*; 126 void PrintNodes() const;; 127 void Print",MatchSource.WIKI,doc/master/TGeoVolume_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8h_source.html
Usability,clear,clear,"; 197 void MakeCopyNodes(const TGeoVolume *other);; 198 TGeoVolume *MakeReflectedVolume(const char *newname = """") const;; 199 Bool_t OptimizeVoxels(); // *MENU*; 200 void RandomPoints(Int_t npoints = 1000000, Option_t *option = """"); // *MENU*; 201 void RandomRays(Int_t nrays = 10000, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0,; 202 const char *target_vol = nullptr, Bool_t check_norm = kFALSE); // *MENU*; 203 void Raytrace(Bool_t flag = kTRUE); // *TOGGLE* *GETTER=IsRaytracing; 204 void RegisterYourself(Option_t *option = """");; 205 void RemoveNode(TGeoNode *node);; 206 TGeoNode *ReplaceNode(TGeoNode *nodeorig, TGeoShape *newshape = nullptr, TGeoMatrix *newpos = nullptr,; 207 TGeoMedium *newmed = nullptr);; 208 void ResetTransparency(Char_t transparency = -1); // *MENU*; 209 void SaveAs(const char *filename = """", Option_t *option = """") const override; // *MENU*; 210 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 211 void SelectVolume(Bool_t clear = kFALSE);; 212 void SetActivity(Bool_t flag = kTRUE) { TGeoAtt::SetActivity(flag); }; 213 void SetActiveDaughters(Bool_t flag = kTRUE) { TGeoAtt::SetActiveDaughters(flag); }; 214 void SetAsTopVolume(); // *TOGGLE* *GETTER=IsTopVolume; 215 void SetAdded() { TObject::SetBit(kVolumeAdded); }; 216 void SetReplicated() { TObject::SetBit(kVolumeReplicated); }; 217 void SetCurrentPoint(Double_t x, Double_t y, Double_t z);; 218 void SetCylVoxels(Bool_t flag = kTRUE); 219 {; 220 TObject::SetBit(kVoxelsCyl, flag);; 221 TObject::SetBit(kVoxelsXYZ, !flag);; 222 }; 223 void SetNodes(TObjArray *nodes); 224 {; 225 fNodes = nodes;; 226 TObject::SetBit(kVolumeImportNodes);; 227 }; 228 void SetOverlappingCandidate(Bool_t flag) { TObject::SetBit(kVolumeOC, flag); }; 229 void SetShape(const TGeoShape *shape);; 230 void SetTransparency(Char_t transparency = 0); // *MENU*; 231 void SetField(TObject *field) { fField = field; }; 232 void SetOption(const char *option);; 233 void SetAttVisibility(Bool_t vis",MatchSource.WIKI,doc/master/TGeoVolume_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGeoVolume_8h_source.html
Integrability,depend,dependency,". ROOT: gui/gui/inc/TGFrame.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; TGFrame.h File Reference. #include ""TGWindow.h""; #include ""TQObject.h""; #include ""TGDimension.h""; #include ""TGGC.h""; #include ""TGFont.h""; #include ""TGLayout.h""; #include ""TGString.h"". Include dependency graph for TGFrame.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGCompositeFrame;  The base class for composite widgets (menu bars, list boxes, etc.). More...;  ; class  TGFrame;  A subclasses of TGWindow, and is used as base class for some simple widgets (buttons, labels, etc.). More...;  ; class  TGGroupFrame;  A composite frame with a border and a title. More...;  ; class  TGHeaderFrame;  Horizontal Frame used to contain header buttons and splitters in a list view. More...;  ; class  TGHorizontalFrame;  A composite frame that layout their children in horizontal way. More...;  ; class  TGMainFrame;  Defines top level windows that interact with the system Window Manager. More...;  ; class  TGMainFrame::TGMapKey;  ; class  TGTransientFrame;  Defines transient windows that typically are used for dialogs windows. More...;  ; class  TGVerticalFrame;  A composite frame that layout their children in vertical way. More...;  . Enumerations; enum  EDNDFlags { kIsDNDSource = (1ULL << ( 0 )); , kIsDNDTarget = (1ULL << ( 1 )); };  ; enum  EFrameCleanup { kNoCleanup = 0; , kLocalCleanup = 1; , kDeepCleanup = -1; };  ; enum  EFrameState { kIsVisible = (1ULL << ( 0 )); , kIsMapped = kIsVisible; , kIsArranged = (1ULL << ( 1 )); };  ; enum  EMWMHints { ;   kMWMFuncAll = (1ULL << ( 0 )); , kMWMFuncResize = (1ULL << ( 1 )); , kMWMFuncMove = (1ULL << ( 2 )); , kMWMFuncMinimize = (1ULL << ( 3 )); , ;   kMWMFuncMaximize = (1UL",MatchSource.WIKI,doc/master/TGFrame_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGFrame_8h.html
Usability,simpl,simple,". ROOT: gui/gui/inc/TGFrame.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; TGFrame.h File Reference. #include ""TGWindow.h""; #include ""TQObject.h""; #include ""TGDimension.h""; #include ""TGGC.h""; #include ""TGFont.h""; #include ""TGLayout.h""; #include ""TGString.h"". Include dependency graph for TGFrame.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGCompositeFrame;  The base class for composite widgets (menu bars, list boxes, etc.). More...;  ; class  TGFrame;  A subclasses of TGWindow, and is used as base class for some simple widgets (buttons, labels, etc.). More...;  ; class  TGGroupFrame;  A composite frame with a border and a title. More...;  ; class  TGHeaderFrame;  Horizontal Frame used to contain header buttons and splitters in a list view. More...;  ; class  TGHorizontalFrame;  A composite frame that layout their children in horizontal way. More...;  ; class  TGMainFrame;  Defines top level windows that interact with the system Window Manager. More...;  ; class  TGMainFrame::TGMapKey;  ; class  TGTransientFrame;  Defines transient windows that typically are used for dialogs windows. More...;  ; class  TGVerticalFrame;  A composite frame that layout their children in vertical way. More...;  . Enumerations; enum  EDNDFlags { kIsDNDSource = (1ULL << ( 0 )); , kIsDNDTarget = (1ULL << ( 1 )); };  ; enum  EFrameCleanup { kNoCleanup = 0; , kLocalCleanup = 1; , kDeepCleanup = -1; };  ; enum  EFrameState { kIsVisible = (1ULL << ( 0 )); , kIsMapped = kIsVisible; , kIsArranged = (1ULL << ( 1 )); };  ; enum  EMWMHints { ;   kMWMFuncAll = (1ULL << ( 0 )); , kMWMFuncResize = (1ULL << ( 1 )); , kMWMFuncMove = (1ULL << ( 2 )); , kMWMFuncMinimize = (1ULL << ( 3 )); , ;   kMWMFuncMaximize = (1UL",MatchSource.WIKI,doc/master/TGFrame_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGFrame_8h.html
Integrability,depend,dependency,". ROOT: gui/guihtml/src/TGHtmlTable.cxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Macros ; TGHtmlTable.cxx File Reference. #include <cstdlib>; #include <cstring>; #include <cctype>; #include <cmath>; #include ""TGHtml.h""; #include ""snprintf.h"". Include dependency graph for TGHtmlTable.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Macros; #define ColMin(A, B)   colMin[(A)-1][(B)-1];  ; #define ColReq(A, B)   colMin[(B)-1][(A)-1];  ; #define DFLT_BORDER   0;  ; #define DFLT_CELLPADDING   2;  ; #define DFLT_CELLSPACING_3D   5;  ; #define DFLT_CELLSPACING_FLAT   0;  ; #define DFLT_HSPACE   0;  ; #define DFLT_VSPACE   0;  ; #define MAX(A, B)   ((A) < (B) ? (B) : (A));  ; #define N   (HTML_MAX_COLUMNS+1);  ; #define SETMAX(A, B)   if ((A) < (B)) { (A) = (B); };  ; #define VAlign_Baseline   4;  ; #define VAlign_Bottom   2;  ; #define VAlign_Center   3;  ; #define VAlign_Top   1;  ; #define VAlign_Unknown   0;  . Macro Definition Documentation. ◆ ColMin. #define ColMin; (;  ; A, .  ; B . );    colMin[(A)-1][(B)-1]. ◆ ColReq. #define ColReq; (;  ; A, .  ; B . );    colMin[(B)-1][(A)-1]. ◆ DFLT_BORDER. #define DFLT_BORDER   0. Definition at line 38 of file TGHtmlTable.cxx. ◆ DFLT_CELLPADDING. #define DFLT_CELLPADDING   2. Definition at line 41 of file TGHtmlTable.cxx. ◆ DFLT_CELLSPACING_3D. #define DFLT_CELLSPACING_3D   5. Definition at line 39 of file TGHtmlTable.cxx. ◆ DFLT_CELLSPACING_FLAT. #define DFLT_CELLSPACING_FLAT   0. Definition at line 40 of file TGHtmlTable.cxx. ◆ DFLT_HSPACE. #define DFLT_HSPACE   0. Definition at line 42 of file TGHtmlTable.cxx. ◆ DFLT_VSPACE. #define DFLT_VSPACE   0. Definition at line 43 of file TGHtmlTable.cxx. ◆ MAX. #define MAX; (;  ; A, .  ; B . );    ((A) < (B) ? (B) : (A)). Definition at line 47 of file TGHtmlTable.cxx. ◆ N. #define N   (HTML_MAX_COLUMNS+1). ◆ SETMAX. #define SETMAX; (;  ; A, .  ; B . );    if ((A) < (B)) { (A) = (B); }. Def",MatchSource.WIKI,doc/master/TGHtmlTable_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGHtmlTable_8cxx.html
Availability,error,error,"Opera instead. Classes; class  TGLUtil::TColorLocker;  ; class  TGLUtil::TDrawQualityModifier;  ; class  TGLUtil::TDrawQualityScaler;  ; class  TGL2DArray< T >;  ; class  TGLCapabilityEnabler;  ; class  TGLCapabilitySwitch;  ; class  TGLColor;  Class encapsulating color information in preferred GL format - an array of four unsigned bytes. More...;  ; class  TGLColorSet;  Class encapsulating a set of colors used throughout standard rendering. More...;  ; class  TGLDisableGuard;  ; class  TGLEnableGuard;  ; class  TGLFloatHolder;  ; class  TGLLevelPalette;  ; class  TGLLine3;  3D space, fixed length, line class, with direction / length 'vector', passing through point 'vertex'. More...;  ; class  TGLMatrix;  16 component (4x4) transform matrix - column MAJOR as per GL. More...;  ; class  TGLPlane;  3D plane class - of format Ax + By + Cz + D = 0 More...;  ; class  TGLRect;  Viewport (pixel base) 2D rectangle class. More...;  ; class  TGLSelectionBuffer;  ; class  TGLUtil;  Wrapper class for various misc static functions - error checking, draw helpers etc. More...;  ; class  TGLVector3;  3 component (x/y/z) vector class. More...;  ; class  TGLVertex3;  3 component (x/y/z) vertex class. More...;  ; class  Rgl::TGuardBase;  ; class  Rgl::TOneArgGuard< Func, Arg >;  ; class  Rgl::TTwoArgsGuard< Func, Arg1, Arg2 >;  . Namespaces; namespace  Rgl;  . Typedefs; typedef std::pair< Int_t, Int_t > Rgl::BinRange_t;  ; typedef std::pair< Double_t, Double_t > Rgl::Range_t;  ; typedef std::vector< TGLPlane >::const_iterator TGLPlaneSet_ci;  ; typedef std::vector< TGLPlane >::iterator TGLPlaneSet_i;  ; typedef std::vector< TGLPlane > TGLPlaneSet_t;  . Enumerations; enum  EGLCoordType { kGLCartesian; , kGLPolar; , kGLCylindrical; , kGLSpherical; };  ; enum  EGLPlotType { ;   kGLLegoPlot; , kGLSurfacePlot; , kGLBoxPlot; , kGLTF3Plot; , ;   kGLStackPlot; , kGLParametricPlot; , kGLIsoPlot; , kGL5D; , ;   kGLTH3Composition; , kGLVoxel; , kGLDefaultPlot. };  ; enum  Rgl::EOverlap { Rgl::kIns",MatchSource.WIKI,doc/master/TGLUtil_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGLUtil_8h.html
Integrability,depend,dependency,". ROOT: graf3d/gl/inc/TGLUtil.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Typedefs |; Enumerations |; Functions |; Variables ; TGLUtil.h File Reference. #include ""Rtypes.h""; #include ""TError.h""; #include <vector>; #include <cmath>; #include <cassert>; #include <utility>. Include dependency graph for TGLUtil.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGLUtil::TColorLocker;  ; class  TGLUtil::TDrawQualityModifier;  ; class  TGLUtil::TDrawQualityScaler;  ; class  TGL2DArray< T >;  ; class  TGLCapabilityEnabler;  ; class  TGLCapabilitySwitch;  ; class  TGLColor;  Class encapsulating color information in preferred GL format - an array of four unsigned bytes. More...;  ; class  TGLColorSet;  Class encapsulating a set of colors used throughout standard rendering. More...;  ; class  TGLDisableGuard;  ; class  TGLEnableGuard;  ; class  TGLFloatHolder;  ; class  TGLLevelPalette;  ; class  TGLLine3;  3D space, fixed length, line class, with direction / length 'vector', passing through point 'vertex'. More...;  ; class  TGLMatrix;  16 component (4x4) transform matrix - column MAJOR as per GL. More...;  ; class  TGLPlane;  3D plane class - of format Ax + By + Cz + D = 0 More...;  ; class  TGLRect;  Viewport (pixel base) 2D rectangle class. More...;  ; class  TGLSelectionBuffer;  ; class  TGLUtil;  Wrapper class for various misc static functions - error checking, draw helpers etc. More...;  ; class  TGLVector3;  3 component (x/y/z) vector class. More...;  ; class  TGLVertex3;  3 component (x/y/z) vertex class. More...;  ; class  Rgl::TGuardBase;  ; class  Rgl::TOneArgGuard< Func, Arg >;  ; class  Rgl::TTwoArgsGuard< Func, Arg1, Arg2 >;  . Namespaces; namespace  Rgl;  . Typedefs; typedef ",MatchSource.WIKI,doc/master/TGLUtil_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGLUtil_8h.html
Modifiability,extend,extend,"uble_t zMin, Double_t zMax, Bool_t color=kTRUE);  ; void Rgl::DrawTrapezoid (const Double_t ver[][3]);  ; void Rgl::DrawTrapezoidTextured (const Double_t ver[][2], Double_t zMin, Double_t zMax, Double_t texMin, Double_t texMax);  In polar coordinates, box became trapezoid. ;  ; void Rgl::DrawTrapezoidTextured (const Double_t ver[][3], Double_t texMin, Double_t texMax);  ; void Rgl::DrawTrapezoidTextured2 (const Double_t ver[][2], Double_t zMin, Double_t zMax, Double_t texMin, Double_t texMax);  In polar coordinates, box became trapezoid. ;  ; void Rgl::GetColor (Float_t v, Float_t vmin, Float_t vmax, Int_t type, Float_t *rgba);  This function creates color for parametric surface's vertex, using its 'u' value. ;  ; std::pair< Bool_t, TGLLine3 > Intersection (const TGLPlane &p1, const TGLPlane &p2);  Find 3D line interestion of this plane with 'other'. ;  ; std::pair< Bool_t, TGLVertex3 > Intersection (const TGLPlane &p1, const TGLPlane &p2, const TGLPlane &p3);  ; std::pair< Bool_t, TGLVertex3 > Intersection (const TGLPlane &plane, const TGLLine3 &line, Bool_t extend);  Find intersection of 3D space 'line' with this plane. ;  ; template<class Func , class Arg > ; TOneArgGuard< Func, Arg > Rgl::make_guard (Func f, Arg a);  ; template<class Func , class Arg1 , class Arg2 > ; TTwoArgsGuard< Func, Arg1, Arg2 > Rgl::make_guard (Func f, Arg1 a1, Arg2 a2);  ; void Rgl::ObjectIDToColor (Int_t objectID, Bool_t highColor);  Object id encoded as rgb triplet. ;  ; TGLMatrix operator* (const TGLMatrix &lhs, const TGLMatrix &rhs);  ; Double_t operator* (const TGLVector3 &a, const TGLVector3 &b);  ; const TGLVector3 operator* (const TGLVector3 &vec, Double_t val);  ; TGLVertex3 operator* (Double_t f, const TGLVertex3 &v);  ; TGLVector3 operator+ (const TGLVector3 &vector1, const TGLVector3 &vector2);  ; TGLVertex3 operator+ (const TGLVertex3 &vertex1, const TGLVector3 &vertex2);  ; TGLVector3 operator- (const TGLVector3 &vector1, const TGLVector3 &vector2);  ; TGLVector3 operator- (",MatchSource.WIKI,doc/master/TGLUtil_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGLUtil_8h.html
Safety,avoid,avoid,"st TGLVector3 &norm2, const TGLVector3 &norm3);  Draw textured triangle. ;  ; void Rgl::DrawFaceTextured (const TGLVertex3 &v1, const TGLVertex3 &v2, const TGLVertex3 &v3, Double_t t1, Double_t t2, Double_t t3, Double_t z, const TGLVector3 &normal);  Draw textured triangle on a plane. ;  ; void Rgl::DrawQuadFilled (const Double_t *v0, const Double_t *v1, const Double_t *v2, const Double_t *v3, const Double_t *normal);  Draw quad face. ;  ; void Rgl::DrawQuadFilled (const TGLVertex3 &v0, const TGLVertex3 &v1, const TGLVertex3 &v2, const TGLVertex3 &v3, const TGLVector3 &normal);  Draw quad face. ;  ; void Rgl::DrawQuadOutline (const TGLVertex3 &v1, const TGLVertex3 &v2, const TGLVertex3 &v3, const TGLVertex3 &v4);  Draw quad outline. ;  ; void Rgl::DrawQuadStripWithRadialGradientFill (unsigned nPoints, const Double_t *inner, const Double_t *innerRGBA, const Double_t *outer, const Double_t *outerRGBA);  TODO: is it possible to use GLdouble to avoid problems with Double_t/GLdouble if they are not the same type? ;  ; void Rgl::DrawSmoothFace (const TGLVertex3 &v1, const TGLVertex3 &v2, const TGLVertex3 &v3, const TGLVector3 &norm1, const TGLVector3 &norm2, const TGLVector3 &norm3);  Draws triangle face, each vertex has its own averaged normal. ;  ; void Rgl::DrawSphere (TGLQuadric *quadric, Double_t xMin, Double_t xMax, Double_t yMin, Double_t yMax, Double_t zMin, Double_t zMax);  Cylinder for lego3. ;  ; void Rgl::DrawTransparentBox (Double_t xMin, Double_t xMax, Double_t yMin, Double_t yMax, Double_t zMin, Double_t zMax, Int_t fp);  Draws lego's bar as a 3d box. ;  ; void Rgl::DrawTrapezoid (const Double_t ver[][2], Double_t zMin, Double_t zMax, Bool_t color=kTRUE);  ; void Rgl::DrawTrapezoid (const Double_t ver[][3]);  ; void Rgl::DrawTrapezoidTextured (const Double_t ver[][2], Double_t zMin, Double_t zMax, Double_t texMin, Double_t texMax);  In polar coordinates, box became trapezoid. ;  ; void Rgl::DrawTrapezoidTextured (const Double_t ver[][3], Double_t texMin, Dou",MatchSource.WIKI,doc/master/TGLUtil_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGLUtil_8h.html
Availability,error,errors,". ROOT: hist/hist/src/TGraph2DErrors.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGraph2DErrors.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id: TGraph2DErrors.cxx,v 1.00; 2// Author: Olivier Couet; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include <iostream>; 13#include ""TBuffer.h""; 14#include ""TGraph2DErrors.h""; 15#include ""TH2.h""; 16#include ""TVirtualPad.h""; 17#include ""TVirtualFitter.h""; 18#include ""THLimitsFinder.h""; 19 ; 20ClassImp(TGraph2DErrors);; 21 ; 22/** \class TGraph2DErrors; 23 \ingroup Graphs; 24Graph 2D class with errors.; 25 ; 26A TGraph2DErrors is a TGraph2D with errors. It behaves like a TGraph2D and has; 27the same drawing options.; 28 ; 29The **""ERR""** drawing option allows to display the error bars. The; 30following example shows how to use it:; 31 ; 32Begin_Macro(source); 33{; 34 auto c = new TCanvas(""c"",""TGraph2DErrors example"",0,0,600,600);; 35 Double_t P = 6.;; 36 Int_t np = 200;; 37 ; 38 Double_t *rx=0, *ry=0, *rz=0;; 39 Double_t *ex=0, *ey=0, *ez=0;; 40 ; 41 rx = new Double_t[np];; 42 ry = new Double_t[np];; 43 rz = new Double_t[np];; 44 ex = new Double_t[np];; 45 ey = new Double_t[np];; 46 ez = new Double_t[np];; 47 ; 48 auto r = new TRandom();; 49 ; 50 for (Int_t N=0; N<np;N++) {; 51 rx[N] = 2*P*(r->Rndm(N))-P;; 52 ry[N] = 2*P*(r->Rndm(N))-P;; 53 rz[N] = rx[N]*rx[N]-ry[N]*ry[N];; 54 rx[N] = 10.+rx[N];; 55 ry[N] = 10.+ry[N];; 56 rz[N] = 40.+rz[N];; 57 ex[N] = r->Rndm(N);; 58 ey[N] = r->Rndm(N);; 59 ez[N] = 10*r->Rndm(N);; 60 }; 61 ; 62 auto g = new TGraph2DErrors(np, rx, ry, rz, ex, ey, ez);; 63 g->SetTitle(""TGraph2D with error bars:",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
Energy Efficiency,allocate,allocate,"w Double_t[fNpoints];; 367 Double_t *newEZ = new Double_t[fNpoints];; 368 ; 369 Int_t j = -1;; 370 for (Int_t i = 0; i < fNpoints + 1; i++) {; 371 if (i == ipoint) continue;; 372 j++;; 373 newX[j] = fX[i];; 374 newY[j] = fY[i];; 375 newZ[j] = fZ[i];; 376 newEX[j] = fEX[i];; 377 newEY[j] = fEY[i];; 378 newEZ[j] = fEZ[i];; 379 }; 380 delete [] fX;; 381 delete [] fY;; 382 delete [] fZ;; 383 delete [] fEX;; 384 delete [] fEY;; 385 delete [] fEZ;; 386 fX = newX;; 387 fY = newY;; 388 fZ = newZ;; 389 fEX = newEX;; 390 fEY = newEY;; 391 fEZ = newEZ;; 392 fSize = fNpoints;; 393 if (fHistogram) {; 394 delete fHistogram;; 395 fHistogram = nullptr;; 396 fDelaunay = nullptr;; 397 }; 398 return ipoint;; 399}; 400 ; 401////////////////////////////////////////////////////////////////////////////////; 402/// Set x, y and z values for point number i; 403 ; 404void TGraph2DErrors::SetPoint(Int_t i, Double_t x, Double_t y, Double_t z); 405{; 406 if (i < 0) return;; 407 if (i >= fNpoints) {; 408 // re-allocate the object; 409 Double_t *savex = new Double_t[i+1];; 410 Double_t *savey = new Double_t[i+1];; 411 Double_t *savez = new Double_t[i+1];; 412 Double_t *saveex = new Double_t[i+1];; 413 Double_t *saveey = new Double_t[i+1];; 414 Double_t *saveez = new Double_t[i+1];; 415 if (fNpoints > 0) {; 416 memcpy(savex, fX, fNpoints*sizeof(Double_t));; 417 memcpy(savey, fY, fNpoints*sizeof(Double_t));; 418 memcpy(savez, fZ, fNpoints*sizeof(Double_t));; 419 memcpy(saveex,fEX,fNpoints*sizeof(Double_t));; 420 memcpy(saveey,fEY,fNpoints*sizeof(Double_t));; 421 memcpy(saveez,fEZ,fNpoints*sizeof(Double_t));; 422 }; 423 if (fX) delete [] fX;; 424 if (fY) delete [] fY;; 425 if (fZ) delete [] fZ;; 426 if (fEX) delete [] fEX;; 427 if (fEY) delete [] fEY;; 428 if (fEZ) delete [] fEZ;; 429 fX = savex;; 430 fY = savey;; 431 fZ = savez;; 432 fEX = saveex;; 433 fEY = saveey;; 434 fEZ = saveez;; 435 fNpoints = i+1;; 436 }; 437 fX[i] = x;; 438 fY[i] = y;; 439 fZ[i] = z;; 440}; 441 ; 442 ; 443//////////////////",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
Integrability,message,message,"s.cxx:356; TGraph2DGraphics object made of three arrays X, Y and Z with the same number of points each.Definition TGraph2D.h:41; TGraph2D::fNpointsInt_t fNpointsNumber of points in the data set.Definition TGraph2D.h:45; TGraph2D::fZDouble_t * fZ[fNpoints]Definition TGraph2D.h:52; TGraph2D::fHistogramTH2D * fHistogram!2D histogram of z values linearly interpolated on the trianglesDefinition TGraph2D.h:58; TGraph2D::fDelaunayTObject * fDelaunay! Pointer to Delaunay interpolator objectDefinition TGraph2D.h:59; TGraph2D::GetNInt_t GetN() constDefinition TGraph2D.h:122; TGraph2D::operator=TGraph2D & operator=(const TGraph2D &)Graph2D operator ""="".Definition TGraph2D.cxx:557; TGraph2D::fXDouble_t * fX[fNpoints]Definition TGraph2D.h:50; TGraph2D::fYDouble_t * fY[fNpoints] Data set to be plottedDefinition TGraph2D.h:51; TGraph2D::Scalevirtual void Scale(Double_t c1=1., Option_t *option=""z"")Multiply the values of a TGraph2D by a constant c1.Definition TGraph2D.cxx:1506; TGraph2D::AddPointvirtual void AddPoint(Double_t x, Double_t y, Double_t z)Append a new point to the graph.Definition TGraph2D.h:93; TGraph2D::fSizeInt_t fSize!Real size of fX, fY and fZDefinition TGraph2D.h:49; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; exDouble_t ex[n]Definition legend1.C:17; v@ vDefinition rootcling_impl.cxx:3699. histhistsrcTGraph2DErrors.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraph2DErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html
Availability,error,errors,". ROOT: hist/hist/inc/TGraph2DErrors.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TGraph2DErrors.h File Reference. #include ""TGraph2D.h"". Include dependency graph for TGraph2DErrors.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGraph2DErrors;  Graph 2D class with errors. More...;  . histhistincTGraph2DErrors.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraph2DErrors_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8h.html
Integrability,depend,dependency,". ROOT: hist/hist/inc/TGraph2DErrors.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TGraph2DErrors.h File Reference. #include ""TGraph2D.h"". Include dependency graph for TGraph2DErrors.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGraph2DErrors;  Graph 2D class with errors. More...;  . histhistincTGraph2DErrors.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraph2DErrors_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8h.html
Availability,error,error,". ROOT: hist/hist/inc/TGraph2DErrors.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGraph2DErrors.h. Go to the documentation of this file. 1// @(#)root/hist:$Id: TGraph2DErrors.h,v 1.00; 2// Author: Olivier Couet 26/11/2003; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TGraph2DErrors; 13#define ROOT_TGraph2DErrors; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TGraph2DErrors //; 19// //; 20// a 2D Graph with error bars //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TGraph2D.h""; 25 ; 26class TGraph2DErrors : public TGraph2D {; 27 ; 28protected:; 29 Double_t *fEX{nullptr}; ///<[fNpoints] array of X errors; 30 Double_t *fEY{nullptr}; ///<[fNpoints] array of Y errors; 31 Double_t *fEZ{nullptr}; ///<[fNpoints] array of Z errors; 32 ; 33public:; 34 TGraph2DErrors();; 35 TGraph2DErrors(Int_t n);; 36 TGraph2DErrors(Int_t n, Double_t *x, Double_t *y, Double_t *z,; 37 Double_t *ex = nullptr, Double_t *ey = nullptr, Double_t *ez = nullptr, Option_t *option = """");; 38 TGraph2DErrors(const TGraph2DErrors&);; 39 TGraph2DErrors& operator=(const TGraph2DErrors&);; 40 ~TGraph2DErrors() override;; 41 virtual void AddPointError(Double_t x, Double_t y, Double_t z, Double_t ex = 0., Double_t ey = 0., Double_t ez = 0.);; 42 Double_t GetErrorX(Int_t bin) const override;; 43 Double_t GetErrorY(Int_t bin) const override;; 44 Double_t GetErrorZ(Int_t bin) const override;; 45 Double_t *GetEX() const override {return fEX;}; 46 Double_t *GetEY() const override {return fEY;}; 47 Double_t ",MatchSource.WIKI,doc/master/TGraph2DErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8h_source.html
Availability,error,errors,"TAttFill(0, 1001), fNpoints(n); 283{; 284 Build(n);; 285 ; 286 // Copy the input vectors into local arrays; 287 for (Int_t i = 0; i < fNpoints; ++i) {; 288 fX[i] = x[i];; 289 fY[i] = y[i];; 290 fZ[i] = z[i];; 291 }; 292}; 293 ; 294 ; 295////////////////////////////////////////////////////////////////////////////////; 296/// Graph2D constructor with three vectors of doubles as input.; 297 ; 298TGraph2D::TGraph2D(Int_t n, Double_t *x, Double_t *y, Double_t *z); 299 : TNamed(""Graph2D"", ""Graph2D""), TAttLine(1, 1, 1), TAttFill(0, 1001), fNpoints(n); 300{; 301 Build(n);; 302 ; 303 // Copy the input vectors into local arrays; 304 for (Int_t i = 0; i < fNpoints; ++i) {; 305 fX[i] = x[i];; 306 fY[i] = y[i];; 307 fZ[i] = z[i];; 308 }; 309}; 310 ; 311 ; 312////////////////////////////////////////////////////////////////////////////////; 313/// Graph2D constructor with a TH2 (h2) as input.; 314/// Only the h2's bins within the X and Y axis ranges are used.; 315/// Empty bins, recognized when both content and errors are zero, are excluded.; 316 ; 317TGraph2D::TGraph2D(TH2 *h2); 318 : TNamed(""Graph2D"", ""Graph2D""), TAttLine(1, 1, 1), TAttFill(0, 1001), fNpoints(0); 319{; 320 Build(h2->GetNbinsX()*h2->GetNbinsY());; 321 ; 322 TString gname = ""Graph2D_from_"" + TString(h2->GetName());; 323 SetName(gname);; 324 // need to call later because sets title in ref histogram; 325 SetTitle(h2->GetTitle());; 326 ; 327 ; 328 ; 329 TAxis *xaxis = h2->GetXaxis();; 330 TAxis *yaxis = h2->GetYaxis();; 331 Int_t xfirst = xaxis->GetFirst();; 332 Int_t xlast = xaxis->GetLast();; 333 Int_t yfirst = yaxis->GetFirst();; 334 Int_t ylast = yaxis->GetLast();; 335 ; 336 ; 337 Double_t x, y, z;; 338 Int_t k = 0;; 339 ; 340 for (Int_t i = xfirst; i <= xlast; i++) {; 341 for (Int_t j = yfirst; j <= ylast; j++) {; 342 x = xaxis->GetBinCenter(i);; 343 y = yaxis->GetBinCenter(j);; 344 z = h2->GetBinContent(i, j);; 345 Double_t ez = h2->GetBinError(i, j);; 346 if (z != 0. || ez != 0) {; 347 SetPoint(k, x, y, z);; 3",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
Deployability,update,update,"//////////////////////////////; 1617/// Set maximum.; 1618 ; 1619void TGraph2D::SetMaximum(Double_t maximum); 1620{; 1621 fMaximum = maximum;; 1622 TH1 * h = GetHistogram();; 1623 if (h) h->SetMaximum(maximum);; 1624}; 1625 ; 1626 ; 1627////////////////////////////////////////////////////////////////////////////////; 1628/// Set minimum.; 1629 ; 1630void TGraph2D::SetMinimum(Double_t minimum); 1631{; 1632 fMinimum = minimum;; 1633 TH1 * h = GetHistogram();; 1634 if (h) h->SetMinimum(minimum);; 1635}; 1636 ; 1637 ; 1638////////////////////////////////////////////////////////////////////////////////; 1639/// Changes the name of this 2D graph; 1640 ; 1641void TGraph2D::SetName(const char *name); 1642{; 1643 // 2D graphs are named objects in a THashList.; 1644 // We must update the hashlist if we change the name; 1645 if (fDirectory) fDirectory->Remove(this);; 1646 fName = name;; 1647 if (fDirectory) fDirectory->Append(this);; 1648}; 1649 ; 1650 ; 1651////////////////////////////////////////////////////////////////////////////////; 1652/// Change the name and title of this 2D graph; 1653///; 1654 ; 1655void TGraph2D::SetNameTitle(const char *name, const char *title); 1656{; 1657 // 2D graphs are named objects in a THashList.; 1658 // We must update the hashlist if we change the name; 1659 if (fDirectory) fDirectory->Remove(this);; 1660 fName = name;; 1661 SetTitle(title);; 1662 if (fDirectory) fDirectory->Append(this);; 1663}; 1664 ; 1665 ; 1666////////////////////////////////////////////////////////////////////////////////; 1667/// Sets the number of bins along X used to draw the function; 1668 ; 1669void TGraph2D::SetNpx(Int_t npx); 1670{; 1671 if (npx < 4) {; 1672 Warning(""SetNpx"", ""Number of points must be >4 && < 500, fNpx set to 4"");; 1673 fNpx = 4;; 1674 } else if (npx > 500) {; 1675 Warning(""SetNpx"", ""Number of points must be >4 && < 500, fNpx set to 500"");; 1676 fNpx = 500;; 1677 } else {; 1678 fNpx = npx;; 1679 }; 1680 if (fHistogram) {; 1681 delete fHistogram",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
Energy Efficiency,allocate,allocated,"fPainter = nullptr;; 625 fUserHisto = kFALSE;; 626 ; 627 if (TH1::AddDirectoryStatus()) {; 628 fDirectory = gDirectory;; 629 if (fDirectory) {; 630 fDirectory->Append(this, kTRUE);; 631 }; 632 }; 633}; 634 ; 635////////////////////////////////////////////////////////////////////////////////; 636/// Performs the operation: `z = z + c1*f(x,y,z)`; 637/// Errors are not recalculated.; 638///; 639/// \param f may be a 2-D function TF2 or 3-d function TF3; 640/// \param c1 a scaling factor, 1 by default; 641 ; 642void TGraph2D::Add(TF2 *f, Double_t c1); 643{; 644 //if (fHistogram) SetBit(kResetHisto);; 645 ; 646 for (Int_t i = 0; i < fNpoints; i++) {; 647 fZ[i] += c1*f->Eval(fX[i], fY[i], fZ[i]);; 648 }; 649 if (gPad) gPad->Modified();; 650}; 651 ; 652////////////////////////////////////////////////////////////////////////////////; 653/// Apply function f to all the data points; 654/// f may be a 2-D function TF2 or 3-d function TF3; 655/// The Z values of the 2D graph are replaced by the new values computed; 656/// using the function; 657 ; 658void TGraph2D::Apply(TF2 *f); 659{; 660 //if (fHistogram) SetBit(kResetHisto);; 661 ; 662 for (Int_t i = 0; i < fNpoints; i++) {; 663 fZ[i] = f->Eval(fX[i], fY[i], fZ[i]);; 664 }; 665 if (gPad) gPad->Modified();; 666}; 667 ; 668////////////////////////////////////////////////////////////////////////////////; 669/// Browse; 670 ; 671void TGraph2D::Browse(TBrowser *); 672{; 673 Draw(""p0"");; 674 gPad->Update();; 675}; 676 ; 677 ; 678////////////////////////////////////////////////////////////////////////////////; 679/// Free all memory allocated by this object.; 680 ; 681void TGraph2D::Clear(Option_t * /*option = """" */); 682{; 683 if (fX) delete [] fX;; 684 fX = nullptr;; 685 if (fY) delete [] fY;; 686 fY = nullptr;; 687 if (fZ) delete [] fZ;; 688 fZ = nullptr;; 689 fSize = fNpoints = 0;; 690 if (fHistogram && !fUserHisto) {; 691 delete fHistogram;; 692 fHistogram = nullptr;; 693 fDelaunay = nullptr;; 694 }; 695 if (fFunctions) {; 696 ",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
Integrability,message,message,"sDigit()) {; 442 Error(""TGraph2D"", ""Incorrect input format! Allowed format tags are {\""%%lg\"",\""%%*lg\"" or \""%%*s\""}"");; 443 return;; 444 }; 445 Int_t ntokens = format_.Length() ;; 446 if (ntokens < 3) {; 447 Error(""TGraph2D"", ""Incorrect input format! Only %d tag(s) in format whereas 3 \""%%lg\"" tags are expected!"", ntokens);; 448 return;; 449 }; 450 Int_t ntokensToBeSaved = 0 ;; 451 Bool_t * isTokenToBeSaved = new Bool_t [ntokens] ;; 452 for (Int_t idx = 0; idx < ntokens; idx++) {; 453 isTokenToBeSaved[idx] = TString::Format(""%c"", format_[idx]).Atoi() ; //atoi(&format_[idx]) does not work for some reason...; 454 if (isTokenToBeSaved[idx] == 1) {; 455 ntokensToBeSaved++ ;; 456 }; 457 }; 458 if (ntokens >= 3 && ntokensToBeSaved != 3) { //first condition not to repeat the previous error message; 459 Error(""TGraph2D"", ""Incorrect input format! There are %d \""%%lg\"" tag(s) in format whereas 3 and only 3 are expected!"", ntokensToBeSaved);; 460 delete [] isTokenToBeSaved ;; 461 return;; 462 }; 463 ; 464 // Initializing loop variables; 465 Bool_t isLineToBeSkipped = kFALSE ; //empty and ill-formed lines; 466 char * token = nullptr ;; 467 TString token_str = """" ;; 468 Int_t token_idx = 0 ;; 469 Double_t * value = new Double_t [3] ; //x,y,z buffers; 470 Int_t value_idx = 0 ;; 471 ; 472 // Looping; 473 char *rest;; 474 while (std::getline(infile, line, '\n')) {; 475 if (!line.empty()) {; 476 if (line[line.size() - 1] == char(13)) { // removing DOS CR character; 477 line.erase(line.end() - 1, line.end()) ;; 478 }; 479 token = R__STRTOK_R(const_cast<char*>(line.c_str()), option, &rest);; 480 while (token != nullptr && value_idx < 3) {; 481 if (isTokenToBeSaved[token_idx]) {; 482 token_str = TString(token) ;; 483 token_str.ReplaceAll(""\t"", """") ;; 484 if (!token_str.IsFloat()) {; 485 isLineToBeSkipped = kTRUE ;; 486 break ;; 487 } else {; 488 value[value_idx] = token_str.Atof() ;; 489 value_idx++ ;; 490 }; 491 }; 492 token = R__STRTOK_R(nullptr, option, &rest); // next token; 493 to",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
Modifiability,extend,extended,"s:; 58- With an array's dimension and three arrays x, y, and z:; 59~~~ {.cpp}; 60 auto g = new TGraph2D(n, x, y, z);; 61~~~; 62 x, y, z arrays can be doubles, floats, or ints.; 63- With an array's dimension only:; 64~~~ {.cpp}; 65 auto g = new TGraph2D(n);; 66~~~; 67 The internal arrays are then filled with `SetPoint()`. The following line; 68 fills the internal arrays at the position `i` with the values; 69 `x`, `y`, `z`.; 70~~~ {.cpp}; 71 g->SetPoint(i, x, y, z);; 72~~~; 73- Without parameters:; 74~~~ {.cpp}; 75 auto g = new TGraph2D();; 76~~~; 77 again `SetPoint()` must be used to fill the internal arrays.; 78- From a file:; 79~~~ {.cpp}; 80 auto g = new TGraph2D(""graph.dat"");; 81~~~; 82 Arrays are read from the ASCII file ""graph.dat"" according to a specifies; 83 format. The default format is `%%lg %%lg %%lg`; 84 ; 85Note that in any of these three cases, `SetPoint()` can be used to change a data; 86point or add a new one. If the data point index (`i`) is greater than the; 87current size of the internal arrays, they are automatically extended.; 88 ; 89Like TGraph some TGraph2D constructors do not have the TGraph2D title and name as parameters.; 90For these constructors TGraph2D has the default title and name ""Graph2D"". To change the; 91default title and name `SetTitle` and `SetName` should be called on the TGraph2D after its; 92creation.; 93 ; 94\anchor G2D01; 95## Drawing options; 96 ; 97Specific drawing options can be used to paint a TGraph2D:; 98 ; 99| Option | Description |; 100|----------|-------------------------------------------------------------------|; 101| ""TRI"" | The Delaunay triangles are drawn using filled area. An hidden surface drawing technique is used. The surface is painted with the current fill area color. The edges of each triangles are painted with the current line color. |; 102| ""TRIW"" | The Delaunay triangles are drawn as wire frame. |; 103| ""TRI1"" | The Delaunay triangles are painted with color levels. The edges of each triangles are paint",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
Safety,avoid,avoid,"rst();; 334 Int_t ylast = yaxis->GetLast();; 335 ; 336 ; 337 Double_t x, y, z;; 338 Int_t k = 0;; 339 ; 340 for (Int_t i = xfirst; i <= xlast; i++) {; 341 for (Int_t j = yfirst; j <= ylast; j++) {; 342 x = xaxis->GetBinCenter(i);; 343 y = yaxis->GetBinCenter(j);; 344 z = h2->GetBinContent(i, j);; 345 Double_t ez = h2->GetBinError(i, j);; 346 if (z != 0. || ez != 0) {; 347 SetPoint(k, x, y, z);; 348 k++;; 349 }; 350 }; 351 }; 352}; 353 ; 354 ; 355////////////////////////////////////////////////////////////////////////////////; 356/// Graph2D constructor with name, title and three vectors of doubles as input.; 357/// name : name of 2D graph (avoid blanks); 358/// title : 2D graph title; 359/// if title is of the form ""stringt;stringx;stringy;stringz""; 360/// the 2D graph title is set to stringt, the x axis title to stringx,; 361/// the y axis title to stringy,etc; 362 ; 363TGraph2D::TGraph2D(const char *name, const char *title,; 364 Int_t n, Double_t *x, Double_t *y, Double_t *z); 365 : TNamed(name, title), TAttLine(1, 1, 1), TAttFill(0, 1001), fNpoints(n); 366{; 367 Build(n);; 368 ; 369 // Copy the input vectors into local arrays; 370 for (Int_t i = 0; i < fNpoints; ++i) {; 371 fX[i] = x[i];; 372 fY[i] = y[i];; 373 fZ[i] = z[i];; 374 }; 375}; 376 ; 377 ; 378////////////////////////////////////////////////////////////////////////////////; 379/// Graph2D constructor. The arrays fX, fY and fZ should be filled via; 380/// calls to SetPoint; 381 ; 382TGraph2D::TGraph2D(Int_t n); 383 : TNamed(""Graph2D"", ""Graph2D""), TAttLine(1, 1, 1), TAttFill(0, 1001), fNpoints(n); 384{; 385 Build(n);; 386 for (Int_t i = 0; i < fNpoints; i++) {; 387 fX[i] = 0.;; 388 fY[i] = 0.;; 389 fZ[i] = 0.;; 390 }; 391}; 392 ; 393 ; 394////////////////////////////////////////////////////////////////////////////////; 395/// Graph2D constructor reading input from filename; 396/// filename is assumed to contain at least three columns of numbers.; 397/// For files separated by a specific delimiter differen",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
Security,access,accessed,"s drawn with one of the 2D histogram drawing option,; 115an intermediate 2D histogram is filled using the Delaunay triangles; 116to interpolate the data set. The 2D histogram has equidistant bins along the X; 117and Y directions. The number of bins along each direction can be change using; 118`SetNpx()` and `SetNpy()`. Each bin is filled with the Z; 119value found via a linear interpolation on the plane defined by the triangle above; 120the (X,Y) coordinates of the bin center.; 121 ; 122The existing (X,Y,Z) points can be randomly scattered.; 123The Delaunay triangles are build in the (X,Y) plane. These 2D triangles are then; 124used to define flat planes in (X,Y,Z) over which the interpolation is done to fill; 125the 2D histogram. The 3D triangles int takes build a 3D surface in; 126the form of tessellating triangles at various angles. The triangles found can be; 127drawn in 3D with one of the TGraph2D specific drawing options.; 128 ; 129The histogram generated by the Delaunay interpolation can be accessed using the; 130`GetHistogram()` method.; 131 ; 132The axis settings (title, ranges etc ...) can be changed accessing the axis via; 133the GetXaxis GetYaxis and GetZaxis methods. They access the histogram axis created; 134at drawing time only. Therefore they should called after the TGraph2D is drawn:; 135 ; 136~~~ {.cpp}; 137 auto g = new TGraph2D();; 138 ; 139 [...]; 140 ; 141 g->Draw(""tri1"");; 142 gPad->Update();; 143 g->GetXaxis()->SetTitle(""X axis title"");; 144~~~; 145 ; 146\anchor G2D02; 147## Examples; 148 ; 149\anchor G2D021; 150### SURF1 Example; 151 ; 152Begin_Macro(source); 153{; 154 auto c = new TCanvas(""c"",""Graph2D example"",0,0,600,400);; 155 Double_t x, y, z, P = 6.;; 156 Int_t np = 200;; 157 auto dt = new TGraph2D();; 158 dt->SetTitle(""Graph title; X axis title; Y axis title; Z axis title"");; 159 auto r = new TRandom();; 160 for (Int_t N=0; N<np; N++) {; 161 x = 2*P*(r->Rndm(N))-P;; 162 y = 2*P*(r->Rndm(N))-P;; 163 z = (sin(x)/x)*(sin(y)/y)+0.2;; 164 dt",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
Testability,assert,assert,"22 if (!fX || !fY || !fZ) return -1;; 1223 x = fX[i];; 1224 y = fY[i];; 1225 z = fZ[i];; 1226 return i;; 1227}; 1228 ; 1229////////////////////////////////////////////////////////////////////////////////; 1230/// Finds the z value at the position (x,y) thanks to; 1231/// the Delaunay interpolation.; 1232 ; 1233Double_t TGraph2D::Interpolate(Double_t x, Double_t y); 1234{; 1235 if (fNpoints <= 0) {; 1236 Error(""Interpolate"", ""Empty TGraph2D"");; 1237 return 0;; 1238 }; 1239 ; 1240 if (!fHistogram) GetHistogram(""empty"");; 1241 if (!fDelaunay) {; 1242 TList *hl = fHistogram->GetListOfFunctions();; 1243 if (!TestBit(kOldInterpolation) ) {; 1244 fDelaunay = hl->FindObject(""TGraphDelaunay2D"");; 1245 if (!fDelaunay) fDelaunay = hl->FindObject(""TGraphDelaunay"");; 1246 }; 1247 else {; 1248 // if using old implementation; 1249 fDelaunay = hl->FindObject(""TGraphDelaunay"");; 1250 if (!fDelaunay) fDelaunay = hl->FindObject(""TGraphDelaunay2D"");; 1251 }; 1252 }; 1253 ; 1254 if (!fDelaunay) return TMath::QuietNaN();; 1255 ; 1256 if (fDelaunay->IsA() == TGraphDelaunay2D::Class() ); 1257 return ((TGraphDelaunay2D*)fDelaunay)->ComputeZ(x, y);; 1258 else if (fDelaunay->IsA() == TGraphDelaunay::Class() ); 1259 return ((TGraphDelaunay*)fDelaunay)->ComputeZ(x, y);; 1260 ; 1261 // cannot be here; 1262 assert(false);; 1263 return TMath::QuietNaN();; 1264}; 1265 ; 1266 ; 1267////////////////////////////////////////////////////////////////////////////////; 1268/// Paints this 2D graph with its current attributes; 1269 ; 1270void TGraph2D::Paint(Option_t *option); 1271{; 1272 if (fNpoints <= 0) {; 1273 Error(""Paint"", ""Empty TGraph2D"");; 1274 return;; 1275 }; 1276 ; 1277 TString opt = option;; 1278 opt.ToLower();; 1279 if (opt.Contains(""p"") && !opt.Contains(""tri"")) {; 1280 if (!opt.Contains(""pol"") &&; 1281 !opt.Contains(""sph"") &&; 1282 !opt.Contains(""psr"")) opt.Append(""tri0"");; 1283 }; 1284 ; 1285 if (opt.Contains(""line"") && !opt.Contains(""tri"")) opt.Append(""tri0"");; 1286 ; 1287 if (opt.Contains(",MatchSource.WIKI,doc/master/TGraph2D_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8cxx_source.html
Integrability,depend,dependency,". ROOT: hist/hist/inc/TGraph2D.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TGraph2D.h File Reference. #include ""TNamed.h""; #include ""TAttLine.h""; #include ""TAttFill.h""; #include ""TAttMarker.h""; #include ""TFitResultPtr.h"". Include dependency graph for TGraph2D.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGraph2D;  Graphics object made of three arrays X, Y and Z with the same number of points each. More...;  . histhistincTGraph2D.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraph2D_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8h.html
Energy Efficiency,allocate,allocated,"ts the histogram to be filled.Definition TGraph2D.cxx:1568; TGraph2D::SetMaximumvoid SetMaximum(Double_t maximum=-1111)Set maximum.Definition TGraph2D.cxx:1619; TGraph2D::GetEXlowvirtual Double_t * GetEXlow() constDefinition TGraph2D.h:129; TGraph2D::Addvirtual void Add(TF2 *f, Double_t c1=1)Performs the operation: z = z + c1*f(x,y,z) Errors are not recalculated.Definition TGraph2D.cxx:642; TGraph2D::GetYmaxDouble_t GetYmax() constReturns the Y maximum.Definition TGraph2D.cxx:1175; TGraph2D::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideComputes distance from point px,py to a graph.Definition TGraph2D.cxx:730; TGraph2D::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default when an 2D graph is created, it is added to the list of 2D graph objects in the current di...Definition TGraph2D.cxx:1544; TGraph2D::fDirectoryTDirectory * fDirectory!Pointer to directory holding this 2D graphDefinition TGraph2D.h:60; TGraph2D::Clearvoid Clear(Option_t *option="""") overrideFree all memory allocated by this object.Definition TGraph2D.cxx:681; TGraph2D::Scalevirtual void Scale(Double_t c1=1., Option_t *option=""z"")Multiply the values of a TGraph2D by a constant c1.Definition TGraph2D.cxx:1506; TGraph2D::GetEXvirtual Double_t * GetEX() constDefinition TGraph2D.h:126; TGraph2D::DirectoryAutoAddvirtual void DirectoryAutoAdd(TDirectory *)Perform the automatic addition of the graph to the given directory.Definition TGraph2D.cxx:715; TGraph2D::CreateInterpolatorvoid CreateInterpolator(Bool_t oldInterp)Add a TGraphDelaunay in the list of the fHistogram's functions.Definition TGraph2D.cxx:968; TGraph2D::GetNpyInt_t GetNpy() constDefinition TGraph2D.h:110; TGraph2D::GetDirectoryTDirectory * GetDirectory() constDefinition TGraph2D.h:108; TGraph2D::fNpyInt_t fNpyNumber of bins along Y in fHistogram.Definition TGraph2D.h:47; TGraph2D::AddPointvirtual void AddPoint(Double_t x, Double_t y, Double_t z)Append a new point to the graph.Definition TGraph2D.h:93; TGr",MatchSource.WIKI,doc/master/TGraph2D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8h_source.html
Integrability,depend,depending,"(Double_t contour)Returns the X and Y graphs building a contour.Definition TGraph2D.cxx:920; TGraph2D::GetXmaxDouble_t GetXmax() constReturns the X maximum.Definition TGraph2D.cxx:1153; TGraph2D::GetPointvirtual Int_t GetPoint(Int_t i, Double_t &x, Double_t &y, Double_t &z) constGet x, y and z values for point number i.Definition TGraph2D.cxx:1219; TGraph2D::GetYaxisTAxis * GetYaxis() constGet y axis of the graph.Definition TGraph2D.cxx:896; TGraph2D::GetEYhighvirtual Double_t * GetEYhigh() constDefinition TGraph2D.h:132; TGraph2D::GetErrorYvirtual Double_t GetErrorY(Int_t bin) constThis function is called by Graph2DFitChisquare.Definition TGraph2D.cxx:949; TGraph2D::GetEYvirtual Double_t * GetEY() constDefinition TGraph2D.h:127; TGraph2D::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TGraph2D.h:112; TGraph2D::fDelaunayTObject * fDelaunay! Pointer to Delaunay interpolator objectDefinition TGraph2D.h:59; TGraph2D::ProjectTH1 * Project(Option_t *option=""x"") constProjects a 2-d graph into 1 or 2-d histograms depending on the option parameter.Definition TGraph2D.cxx:1329; TGraph2D::GetNInt_t GetN() constDefinition TGraph2D.h:122; TGraph2D::GetXmaxEvirtual Double_t GetXmaxE() constDefinition TGraph2D.h:141; TGraph2D::Setvirtual void Set(Int_t n)Set number of points in the 2D graph.Definition TGraph2D.cxx:1528; TGraph2D::SetMinimumvoid SetMinimum(Double_t minimum=-1111)Set minimum.Definition TGraph2D.cxx:1630; TGraph2D::operator=TGraph2D & operator=(const TGraph2D &)Graph2D operator ""="".Definition TGraph2D.cxx:557; TGraph2D::GetEXhighvirtual Double_t * GetEXhigh() constDefinition TGraph2D.h:130; TGraph2D::fXDouble_t * fX[fNpoints]Definition TGraph2D.h:50; TGraph2D::fYDouble_t * fY[fNpoints] Data set to be plottedDefinition TGraph2D.h:51; TGraph2D::SetHistogramvirtual void SetHistogram(TH2 *h, Option_t *option="""")Sets the histogram to be filled.Definition TGraph2D.cxx:1568; TGraph2D::SetMaximumvoid SetMaximum(Double_t maximum=-1111)Set maximum.Definition T",MatchSource.WIKI,doc/master/TGraph2D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph2D_8h_source.html
Availability,error,error,"o Matches. TGraphAsymmErrors.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Rene Brun 03/03/99; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13#include ""TEfficiency.h""; 14#include ""TROOT.h""; 15#include ""TBuffer.h""; 16#include ""TGraphAsymmErrors.h""; 17#include ""TGraphErrors.h""; 18#include ""TStyle.h""; 19#include ""TMath.h""; 20#include ""TVirtualPad.h""; 21#include ""TF1.h""; 22#include ""TH1.h""; 23#include ""TVector.h""; 24#include ""TVectorD.h""; 25#include ""TSystem.h""; 26#include ""Math/QuantFuncMathCore.h""; 27#include ""strtok.h""; 28 ; 29#include <cstring>; 30#include <iostream>; 31#include <fstream>; 32 ; 33 ; 34ClassImp(TGraphAsymmErrors);; 35 ; 36/** \class TGraphAsymmErrors; 37 \ingroup Graphs; 38TGraph with asymmetric error bars.; 39 ; 40The TGraphAsymmErrors painting is performed thanks to the TGraphPainter; 41class. All details about the various painting options are given in this class.; 42 ; 43The picture below gives an example:; 44 ; 45Begin_Macro(source); 46{; 47 auto c1 = new TCanvas(""c1"",""A Simple Graph with asymmetric error bars"",200,10,700,500);; 48 c1->SetFillColor(42);; 49 c1->SetGrid();; 50 c1->GetFrame()->SetFillColor(21);; 51 c1->GetFrame()->SetBorderSize(12);; 52 const Int_t n = 10;; 53 Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; 54 Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; 55 Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; 56 Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; 57 Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; 58 Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; 59 auto gr = new TGraphAsymmErrors(n,x,y,ex",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
Deployability,release,release,"bins); 962 Warning(""Divide"",""Number of graph points is different than histogram bins - %d points have been skipped"",nbins-npoint);; 963 ; 964 ; 965 if (bVerbose) {; 966 Info(""Divide"",""made a graph with %d points from %d bins"",npoint,nbins);; 967 Info(""Divide"",""used confidence level: %.2lf\n"",conf);; 968 if(bIsBayesian); 969 Info(""Divide"",""used prior probability ~ beta(%.2lf,%.2lf)"",alpha,beta);; 970 Print();; 971 }; 972}; 973 ; 974////////////////////////////////////////////////////////////////////////////////; 975/// Compute Range.; 976 ; 977void TGraphAsymmErrors::ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const; 978{; 979 TGraph::ComputeRange(xmin,ymin,xmax,ymax);; 980 ; 981 for (Int_t i=0;i<fNpoints;i++) {; 982 if (fX[i] -fEXlow[i] < xmin) {; 983 if (gPad && gPad->GetLogx()) {; 984 if (fEXlow[i] < fX[i]) xmin = fX[i]-fEXlow[i];; 985 else xmin = TMath::Min(xmin,fX[i]/3);; 986 } else {; 987 xmin = fX[i]-fEXlow[i];; 988 }; 989 }; 990 if (fX[i] +fEXhigh[i] > xmax) xmax = fX[i]+fEXhigh[i];; 991 if (fY[i] -fEYlow[i] < ymin) {; 992 if (gPad && gPad->GetLogy()) {; 993 if (fEYlow[i] < fY[i]) ymin = fY[i]-fEYlow[i];; 994 else ymin = TMath::Min(ymin,fY[i]/3);; 995 } else {; 996 ymin = fY[i]-fEYlow[i];; 997 }; 998 }; 999 if (fY[i] +fEYhigh[i] > ymax) ymax = fY[i]+fEYhigh[i];; 1000 }; 1001}; 1002 ; 1003 ; 1004////////////////////////////////////////////////////////////////////////////////; 1005/// Copy and release.; 1006 ; 1007void TGraphAsymmErrors::CopyAndRelease(Double_t **newarrays,; 1008 Int_t ibegin, Int_t iend, Int_t obegin); 1009{; 1010 CopyPoints(newarrays, ibegin, iend, obegin);; 1011 if (newarrays) {; 1012 delete[] fEXlow;; 1013 fEXlow = newarrays[0];; 1014 delete[] fEXhigh;; 1015 fEXhigh = newarrays[1];; 1016 delete[] fEYlow;; 1017 fEYlow = newarrays[2];; 1018 delete[] fEYhigh;; 1019 fEYhigh = newarrays[3];; 1020 delete[] fX;; 1021 fX = newarrays[4];; 1022 delete[] fY;; 1023 fY = newarrays[5];; 1024 delete[] newarrays;; 1025 }; 10",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
Energy Efficiency,allocate,allocate," 1307 Int_t py = gPad->GetEventY();; 1308 ; 1309 //localize point to be deleted; 1310 Int_t ipoint = -2;; 1311 Int_t i;; 1312 // start with a small window (in case the mouse is very close to one point); 1313 for (i=0;i<fNpoints;i++) {; 1314 Int_t dpx = px - gPad->XtoAbsPixel(gPad->XtoPad(fX[i]));; 1315 Int_t dpy = py - gPad->YtoAbsPixel(gPad->YtoPad(fY[i]));; 1316 if (dpx*dpx+dpy*dpy < 25) {ipoint = i; break;}; 1317 }; 1318 if (ipoint == -2) return;; 1319 ; 1320 fEXlow[ipoint] = exl;; 1321 fEYlow[ipoint] = eyl;; 1322 fEXhigh[ipoint] = exh;; 1323 fEYhigh[ipoint] = eyh;; 1324 gPad->Modified();; 1325}; 1326 ; 1327 ; 1328////////////////////////////////////////////////////////////////////////////////; 1329/// Set ex and ey values for point number i.; 1330 ; 1331void TGraphAsymmErrors::SetPointError(Int_t i, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh); 1332{; 1333 if (i < 0) return;; 1334 if (i >= fNpoints) {; 1335 // re-allocate the object; 1336 TGraphAsymmErrors::SetPoint(i,0,0);; 1337 }; 1338 fEXlow[i] = exl;; 1339 fEYlow[i] = eyl;; 1340 fEXhigh[i] = exh;; 1341 fEYhigh[i] = eyh;; 1342}; 1343 ; 1344 ; 1345////////////////////////////////////////////////////////////////////////////////; 1346/// Set EXlow for point `i`.; 1347 ; 1348void TGraphAsymmErrors::SetPointEXlow(Int_t i, Double_t exl); 1349{; 1350 if (i < 0) return;; 1351 if (i >= fNpoints) {; 1352 // re-allocate the object; 1353 TGraphAsymmErrors::SetPoint(i,0,0);; 1354 }; 1355 fEXlow[i] = exl;; 1356}; 1357 ; 1358 ; 1359////////////////////////////////////////////////////////////////////////////////; 1360/// Set EXhigh for point `i`.; 1361 ; 1362void TGraphAsymmErrors::SetPointEXhigh(Int_t i, Double_t exh); 1363{; 1364 if (i < 0) return;; 1365 if (i >= fNpoints) {; 1366 // re-allocate the object; 1367 TGraphAsymmErrors::SetPoint(i,0,0);; 1368 }; 1369 fEXhigh[i] = exh;; 1370}; 1371 ; 1372 ; 1373////////////////////////////////////////////////////////////////////////////////; 1374/// Set EYlow for point ",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
Integrability,message,message,"IsDigit()) {; 349 Error(""TGraphAsymmErrors"", ""Incorrect input format! Allowed format tags are {\""%%lg\"",\""%%*lg\"" or \""%%*s\""}"");; 350 return ;; 351 }; 352 Int_t ntokens = format_.Length() ;; 353 if (ntokens < 2) {; 354 Error(""TGraphAsymmErrors"", ""Incorrect input format! Only %d tag(s) in format whereas at least 2 \""%%lg\"" tags are expected!"", ntokens);; 355 return ;; 356 }; 357 Int_t ntokensToBeSaved = 0;; 358 Bool_t * isTokenToBeSaved = new Bool_t[ntokens];; 359 for (Int_t idx = 0; idx < ntokens; idx++) {; 360 isTokenToBeSaved[idx] = TString::Format(""%c"", format_[idx]).Atoi(); //atoi(&format_[idx]) does not work for some reason...; 361 if (isTokenToBeSaved[idx] == 1) {; 362 ntokensToBeSaved++ ;; 363 }; 364 }; 365 if (ntokens >= 2 && (ntokensToBeSaved < 2 || ntokensToBeSaved > 4)) { //first condition not to repeat the previous error message; 366 Error(""TGraphAsymmErrors"", ""Incorrect input format! There are %d \""%%lg\"" tag(s) in format whereas 2,3 or 4 are expected!"", ntokensToBeSaved);; 367 delete [] isTokenToBeSaved;; 368 return ;; 369 }; 370 ; 371 // Initializing loop variables; 372 Bool_t isLineToBeSkipped = kFALSE; //empty and ill-formed lines; 373 char *token = nullptr;; 374 TString token_str = """";; 375 Int_t token_idx = 0;; 376 Double_t value[6]; //x,y,exl, exh, eyl, eyh buffers; 377 for (Int_t k = 0; k < 6; k++); 378 value[k] = 0.;; 379 Int_t value_idx = 0;; 380 ; 381 // Looping; 382 char *rest;; 383 while (std::getline(infile, line, '\n')) {; 384 if (!line.empty()) {; 385 if (line[line.size() - 1] == char(13)) { // removing DOS CR character; 386 line.erase(line.end() - 1, line.end()) ;; 387 }; 388 token = R__STRTOK_R(const_cast<char*>(line.c_str()), option, &rest) ;; 389 while (token != nullptr && value_idx < ntokensToBeSaved) {; 390 if (isTokenToBeSaved[token_idx]) {; 391 token_str = TString(token) ;; 392 token_str.ReplaceAll(""\t"", """") ;; 393 if (!token_str.IsFloat()) {; 394 isLineToBeSkipped = kTRUE ;; 395 break ;; 396 } else {; 397 value[value_idx] = tok",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
Modifiability,variab,variables,"IsDigit()) {; 349 Error(""TGraphAsymmErrors"", ""Incorrect input format! Allowed format tags are {\""%%lg\"",\""%%*lg\"" or \""%%*s\""}"");; 350 return ;; 351 }; 352 Int_t ntokens = format_.Length() ;; 353 if (ntokens < 2) {; 354 Error(""TGraphAsymmErrors"", ""Incorrect input format! Only %d tag(s) in format whereas at least 2 \""%%lg\"" tags are expected!"", ntokens);; 355 return ;; 356 }; 357 Int_t ntokensToBeSaved = 0;; 358 Bool_t * isTokenToBeSaved = new Bool_t[ntokens];; 359 for (Int_t idx = 0; idx < ntokens; idx++) {; 360 isTokenToBeSaved[idx] = TString::Format(""%c"", format_[idx]).Atoi(); //atoi(&format_[idx]) does not work for some reason...; 361 if (isTokenToBeSaved[idx] == 1) {; 362 ntokensToBeSaved++ ;; 363 }; 364 }; 365 if (ntokens >= 2 && (ntokensToBeSaved < 2 || ntokensToBeSaved > 4)) { //first condition not to repeat the previous error message; 366 Error(""TGraphAsymmErrors"", ""Incorrect input format! There are %d \""%%lg\"" tag(s) in format whereas 2,3 or 4 are expected!"", ntokensToBeSaved);; 367 delete [] isTokenToBeSaved;; 368 return ;; 369 }; 370 ; 371 // Initializing loop variables; 372 Bool_t isLineToBeSkipped = kFALSE; //empty and ill-formed lines; 373 char *token = nullptr;; 374 TString token_str = """";; 375 Int_t token_idx = 0;; 376 Double_t value[6]; //x,y,exl, exh, eyl, eyh buffers; 377 for (Int_t k = 0; k < 6; k++); 378 value[k] = 0.;; 379 Int_t value_idx = 0;; 380 ; 381 // Looping; 382 char *rest;; 383 while (std::getline(infile, line, '\n')) {; 384 if (!line.empty()) {; 385 if (line[line.size() - 1] == char(13)) { // removing DOS CR character; 386 line.erase(line.end() - 1, line.end()) ;; 387 }; 388 token = R__STRTOK_R(const_cast<char*>(line.c_str()), option, &rest) ;; 389 while (token != nullptr && value_idx < ntokensToBeSaved) {; 390 if (isTokenToBeSaved[token_idx]) {; 391 token_str = TString(token) ;; 392 token_str.ReplaceAll(""\t"", """") ;; 393 if (!token_str.IsFloat()) {; 394 isLineToBeSkipped = kTRUE ;; 395 break ;; 396 } else {; 397 value[value_idx] = tok",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
Performance,perform,performed,"********************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13#include ""TEfficiency.h""; 14#include ""TROOT.h""; 15#include ""TBuffer.h""; 16#include ""TGraphAsymmErrors.h""; 17#include ""TGraphErrors.h""; 18#include ""TStyle.h""; 19#include ""TMath.h""; 20#include ""TVirtualPad.h""; 21#include ""TF1.h""; 22#include ""TH1.h""; 23#include ""TVector.h""; 24#include ""TVectorD.h""; 25#include ""TSystem.h""; 26#include ""Math/QuantFuncMathCore.h""; 27#include ""strtok.h""; 28 ; 29#include <cstring>; 30#include <iostream>; 31#include <fstream>; 32 ; 33 ; 34ClassImp(TGraphAsymmErrors);; 35 ; 36/** \class TGraphAsymmErrors; 37 \ingroup Graphs; 38TGraph with asymmetric error bars.; 39 ; 40The TGraphAsymmErrors painting is performed thanks to the TGraphPainter; 41class. All details about the various painting options are given in this class.; 42 ; 43The picture below gives an example:; 44 ; 45Begin_Macro(source); 46{; 47 auto c1 = new TCanvas(""c1"",""A Simple Graph with asymmetric error bars"",200,10,700,500);; 48 c1->SetFillColor(42);; 49 c1->SetGrid();; 50 c1->GetFrame()->SetFillColor(21);; 51 c1->GetFrame()->SetBorderSize(12);; 52 const Int_t n = 10;; 53 Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; 54 Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; 55 Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; 56 Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; 57 Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; 58 Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; 59 auto gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; 60 gr->SetTitle(""TGraphAsymmErrors Example"");; 61 gr->SetMarkerColor(4);; 62 gr->SetMarkerStyle(21);; 63 gr->Draw(""ALP"");; 64}; 65End",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
Safety,avoid,avoid,"tring(total->GetName());; 271 SetName(sname.c_str());; 272 SetTitle(pass->GetTitle());; 273 ; 274 //copy style from pass; 275 pass->TAttLine::Copy(*this);; 276 pass->TAttFill::Copy(*this);; 277 pass->TAttMarker::Copy(*this);; 278 ; 279 Divide(pass, total, option);; 280}; 281 ; 282 ; 283////////////////////////////////////////////////////////////////////////////////; 284/// TGraphAsymmErrors constructor reading input from filename; 285/// filename is assumed to contain at least 2 columns of numbers; 286///; 287/// convention for format (default=`""%lg %lg %lg %lg %lg %lg""`); 288/// - format = `""%lg %lg""` read only 2 first columns into X, Y; 289/// - format = `""%lg %lg %lg %lg""` read only 4 first columns into X, Y, ELY, EHY; 290/// - format = `""%lg %lg %lg %lg %lg %lg""` read only 6 first columns into X, Y, EXL, EYH, EYL, EHY; 291///; 292/// For files separated by a specific delimiter different from `' '` and `'\\t'` (e.g. `';'` in csv files); 293/// you can avoid using `%*s` to bypass this delimiter by explicitly specify the `""option"" argument,; 294/// e.g. `option="" \\t,;""` for columns of figures separated by any of these characters `(' ', '\\t', ',', ';')`; 295/// used once `(e.g. ""1;1"")` or in a combined way `("" 1;,;; 1"")`.; 296/// Note in that case, the instantiation is about 2 times slower.; 297/// In case a delimiter is specified, the format `""%lg %lg %lg""` will read X,Y,EX.; 298 ; 299TGraphAsymmErrors::TGraphAsymmErrors(const char *filename, const char *format, Option_t *option); 300 : TGraph(100); 301{; 302 if (!CtorAllocate()) return;; 303 Double_t x, y, exl, exh, eyl, eyh;; 304 TString fname = filename;; 305 gSystem->ExpandPathName(fname);; 306 std::ifstream infile(fname.Data());; 307 if (!infile.good()) {; 308 MakeZombie();; 309 Error(""TGraphAsymmErrors"", ""Cannot open file: %s, TGraphAsymmErrors is Zombie"", filename);; 310 fNpoints = 0;; 311 return;; 312 }; 313 std::string line;; 314 Int_t np = 0;; 315 ; 316 if (strcmp(option, """") == 0) { // No delimiters sp",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html
Availability,error,error,". ROOT: hist/hist/inc/TGraphAsymmErrors.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGraphAsymmErrors.h. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Rene Brun 03/03/99; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TGraphAsymmErrors; 13#define ROOT_TGraphAsymmErrors; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TGraphAsymmErrors //; 19// //; 20// a Graph with asymmetric error bars //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TGraph.h""; 25 ; 26class TGraphAsymmErrors : public TGraph {; 27 ; 28protected:; 29 Double_t *fEXlow{nullptr}; ///<[fNpoints] array of X low errors; 30 Double_t *fEXhigh{nullptr}; ///<[fNpoints] array of X high errors; 31 Double_t *fEYlow{nullptr}; ///<[fNpoints] array of Y low errors; 32 Double_t *fEYhigh{nullptr}; ///<[fNpoints] array of Y high errors; 33 ; 34 void SwapPoints(Int_t pos1, Int_t pos2) override;; 35 void UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low) override;; 36 ; 37 Double_t** Allocate(Int_t size) override;; 38 void CopyAndRelease(Double_t **newarrays,; 39 Int_t ibegin, Int_t iend, Int_t obegin) override;; 40 Bool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend,; 41 Int_t obegin) override;; 42 Bool_t CtorAllocate();; 43 void FillZero(Int_t begin, Int_t end,; 44 Bool_t from_ctor = kTRUE) override;; 45 Bool_t DoMerge(const TGraph * g) override;; 46 ; 47public:; 48 TGraphAsymmErrors();; 49 TGraphAsymmErrors(Int_t n);; 50 TGraphAsymmErrors(",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
Deployability,release,release," TGraphAsymmErrors.cxx:1468; TGraphAsymmErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphAsymmErrors.cxx:1456; TGraphAsymmErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphAsymmErrors.h:75; TGraphAsymmErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphAsymmErrors.h:29; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphAsymmErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphAsymmErrors.cxx:444; TGraphAsymmErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphAsymmErrors.h:76; TGraphAsymmErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphAsymmErrors.cxx:1077; TGraphAsymmErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphAsymmErrors.cxx:1007; TGraphAsymmErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exh)Set EXhigh for point i.Definition TGraphAsymmErrors.cxx:1362; TGraphAsymmErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on Y.Definition TGraphAsymmErrors.cxx:1184; TGraphAsymmErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideReturns the combined error along X at point i by computing the average of the lower and upper varianc...Definition TGraphAsymmErrors.cxx:1122; TGraphAsymmErrors::TGraphAsymmErrorsTGraphAsymmErrors()TGraphAsymmErrors default constructor.Definition TGraphAsymmErrors.cxx:72; TGraphAsymmErrors::operator=TGraphAsymmErrors & operator=(const TGraphAsymmErrors &gr)TGraphAsymmErrors assignment operator.Definition TGraphAsymmErrors.cxx:93; TGraphAsymmErrors::~TGraphAsymmErrors~TGraphAsymmErrors() overrideTGraphAsymmErrors default destructo",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
Performance,perform,perform,"const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values.Definition TGraphAsymmErrors.cxx:1468; TGraphAsymmErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphAsymmErrors.cxx:1456; TGraphAsymmErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphAsymmErrors.h:75; TGraphAsymmErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphAsymmErrors.h:29; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphAsymmErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphAsymmErrors.cxx:444; TGraphAsymmErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphAsymmErrors.h:76; TGraphAsymmErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphAsymmErrors.cxx:1077; TGraphAsymmErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphAsymmErrors.cxx:1007; TGraphAsymmErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exh)Set EXhigh for point i.Definition TGraphAsymmErrors.cxx:1362; TGraphAsymmErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on Y.Definition TGraphAsymmErrors.cxx:1184; TGraphAsymmErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideReturns the combined error along X at point i by computing the average of the lower and upper varianc...Definition TGraphAsymmErrors.cxx:1122; TGraphAsymmErrors::TGraphAsymmErrorsTGraphAsymmErrors()TGraphAsymmErrors default constructor.Definition TGraphAsymmErrors.cxx:72; TGraphAsymmErrors::operator=TGraphAsymmErrors & operator=(const TGraphAsymmError",MatchSource.WIKI,doc/master/TGraphAsymmErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html
Availability,error,error,". ROOT: hist/hist/src/TGraphBentErrors.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGraphBentErrors.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Dave Morrison 30/06/2003; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include <cstring>; 13#include <iostream>; 14 ; 15#include ""TROOT.h""; 16#include ""TGraphBentErrors.h""; 17#include ""TMath.h""; 18#include ""TVirtualPad.h""; 19#include ""TH1.h""; 20#include ""TF1.h""; 21 ; 22ClassImp(TGraphBentErrors);; 23 ; 24 ; 25////////////////////////////////////////////////////////////////////////////////; 26 ; 27/** \class TGraphBentErrors; 28 \ingroup Graphs; 29A TGraphBentErrors is a TGraph with bent, asymmetric error bars.; 30 ; 31The TGraphBentErrors painting is performed thanks to the TGraphPainter; 32class. All details about the various painting options are given in this class.; 33 ; 34The picture below gives an example:; 35Begin_Macro(source); 36{; 37 auto c1 = new TCanvas(""c1"",""A Simple Graph with bent error bars"",200,10,700,500);; 38 const Int_t n = 10;; 39 Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; 40 Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; 41 Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; 42 Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; 43 Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; 44 Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; 45 Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 46 Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; 47 Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 48 Double_t eyhd[n] = {.0,.",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
Deployability,release,release,"bars is reversed; 230 if (f->Eval(x,y-eyl) < f->Eval(x,y+eyh)) {; 231 eyl_new = TMath::Abs(fxy - f->Eval(x,y-eyl));; 232 eyh_new = TMath::Abs(f->Eval(x,y+eyh) - fxy);; 233 } else {; 234 eyh_new = TMath::Abs(fxy - f->Eval(x,y-eyl));; 235 eyl_new = TMath::Abs(f->Eval(x,y+eyh) - fxy);; 236 }; 237 ; 238 //error on x doesn't change; 239 SetPointError(i,exl,exh,eyl_new,eyh_new);; 240 }; 241 if (gPad) gPad->Modified();; 242}; 243 ; 244 ; 245////////////////////////////////////////////////////////////////////////////////; 246/// Compute range.; 247 ; 248void TGraphBentErrors::ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const; 249{; 250 TGraph::ComputeRange(xmin,ymin,xmax,ymax);; 251 ; 252 for (Int_t i=0;i<fNpoints;i++) {; 253 if (fX[i] -fEXlow[i] < xmin) {; 254 if (gPad && gPad->GetLogx()) {; 255 if (fEXlow[i] < fX[i]) xmin = fX[i]-fEXlow[i];; 256 else xmin = TMath::Min(xmin,fX[i]/3);; 257 } else {; 258 xmin = fX[i]-fEXlow[i];; 259 }; 260 }; 261 if (fX[i] +fEXhigh[i] > xmax) xmax = fX[i]+fEXhigh[i];; 262 if (fY[i] -fEYlow[i] < ymin) {; 263 if (gPad && gPad->GetLogy()) {; 264 if (fEYlow[i] < fY[i]) ymin = fY[i]-fEYlow[i];; 265 else ymin = TMath::Min(ymin,fY[i]/3);; 266 } else {; 267 ymin = fY[i]-fEYlow[i];; 268 }; 269 }; 270 if (fY[i] +fEYhigh[i] > ymax) ymax = fY[i]+fEYhigh[i];; 271 }; 272}; 273 ; 274 ; 275////////////////////////////////////////////////////////////////////////////////; 276/// Copy and release.; 277 ; 278void TGraphBentErrors::CopyAndRelease(Double_t **newarrays,; 279 Int_t ibegin, Int_t iend, Int_t obegin); 280{; 281 CopyPoints(newarrays, ibegin, iend, obegin);; 282 if (newarrays) {; 283 delete[] fEXlow;; 284 fEXlow = newarrays[0];; 285 delete[] fEXhigh;; 286 fEXhigh = newarrays[1];; 287 delete[] fEYlow;; 288 fEYlow = newarrays[2];; 289 delete[] fEYhigh;; 290 fEYhigh = newarrays[3];; 291 delete[] fEXlowd;; 292 fEXlowd = newarrays[4];; 293 delete[] fEXhighd;; 294 fEXhighd = newarrays[5];; 295 delete[] fEYlowd;; 296 fEYlowd =",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
Energy Efficiency,allocate,allocate," to one point); 601 for (Int_t i = 0; i < fNpoints; i++) {; 602 Int_t dpx = px - gPad->XtoAbsPixel(gPad->XtoPad(fX[i]));; 603 Int_t dpy = py - gPad->YtoAbsPixel(gPad->YtoPad(fY[i]));; 604 if (dpx*dpx+dpy*dpy < 25) {ipoint = i; break;}; 605 }; 606 if (ipoint == -2) return;; 607 ; 608 fEXlow[ipoint] = exl;; 609 fEYlow[ipoint] = eyl;; 610 fEXhigh[ipoint] = exh;; 611 fEYhigh[ipoint] = eyh;; 612 fEXlowd[ipoint] = exld;; 613 fEXhighd[ipoint] = exhd;; 614 fEYlowd[ipoint] = eyld;; 615 fEYhighd[ipoint] = eyhd;; 616 ; 617 gPad->Modified();; 618}; 619 ; 620 ; 621////////////////////////////////////////////////////////////////////////////////; 622/// Set ex and ey values for point number `i`.; 623 ; 624void TGraphBentErrors::SetPointError(Int_t i, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh,; 625 Double_t exld, Double_t exhd, Double_t eyld, Double_t eyhd); 626{; 627 if (i < 0) return;; 628 if (i >= fNpoints) {; 629 // re-allocate the object; 630 TGraphBentErrors::SetPoint(i,0,0);; 631 }; 632 fEXlow[i] = exl;; 633 fEYlow[i] = eyl;; 634 fEXhigh[i] = exh;; 635 fEYhigh[i] = eyh;; 636 fEXlowd[i] = exld;; 637 fEXhighd[i] = exhd;; 638 fEYlowd[i] = eyld;; 639 fEYhighd[i] = eyhd;; 640}; 641 ; 642 ; 643////////////////////////////////////////////////////////////////////////////////; 644/// Swap points.; 645 ; 646void TGraphBentErrors::SwapPoints(Int_t pos1, Int_t pos2); 647{; 648 SwapValues(fEXlow, pos1, pos2);; 649 SwapValues(fEXhigh, pos1, pos2);; 650 SwapValues(fEYlow, pos1, pos2);; 651 SwapValues(fEYhigh, pos1, pos2);; 652 ; 653 SwapValues(fEXlowd, pos1, pos2);; 654 SwapValues(fEXhighd, pos1, pos2);; 655 SwapValues(fEYlowd, pos1, pos2);; 656 SwapValues(fEYhighd, pos1, pos2);; 657 ; 658 TGraph::SwapPoints(pos1, pos2);; 659}; 660 ; 661////////////////////////////////////////////////////////////////////////////////; 662/// Update the fX, fY, fEXlow, fEXhigh, fEXlowd, fEXhighd, fEYlow, fEYhigh, fEYlowd, ; 663/// and fEYhighd arrays with the sorted values.; 664 ; 665void TGraphB",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
Integrability,message,message,"::DoMergevirtual Bool_t DoMerge(const TGraph *g)protected function to perform the merge operation of a graphDefinition TGraph.cxx:2676; TGraph::SwapPointsvirtual void SwapPoints(Int_t pos1, Int_t pos2)Swap points.Definition TGraph.cxx:2583; TGraph::FillZerovirtual void FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE)Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes.Definition TGraph.cxx:1102; TGraph::fXDouble_t * fX[fNpoints] array of X pointsDefinition TGraph.h:47; TGraph::GetPointvirtual Int_t GetPoint(Int_t i, Double_t &x, Double_t &y) constGet x and y values for point number i.Definition TGraph.cxx:1533; TGraph::CopyPointsvirtual Bool_t CopyPoints(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin)Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin !...Definition TGraph.cxx:779; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123. histhistsrcTGraphBentErrors.cxx. ROOT master - Reference Guide Ge",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
Performance,perform,performed,"ches. TGraphBentErrors.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Dave Morrison 30/06/2003; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include <cstring>; 13#include <iostream>; 14 ; 15#include ""TROOT.h""; 16#include ""TGraphBentErrors.h""; 17#include ""TMath.h""; 18#include ""TVirtualPad.h""; 19#include ""TH1.h""; 20#include ""TF1.h""; 21 ; 22ClassImp(TGraphBentErrors);; 23 ; 24 ; 25////////////////////////////////////////////////////////////////////////////////; 26 ; 27/** \class TGraphBentErrors; 28 \ingroup Graphs; 29A TGraphBentErrors is a TGraph with bent, asymmetric error bars.; 30 ; 31The TGraphBentErrors painting is performed thanks to the TGraphPainter; 32class. All details about the various painting options are given in this class.; 33 ; 34The picture below gives an example:; 35Begin_Macro(source); 36{; 37 auto c1 = new TCanvas(""c1"",""A Simple Graph with bent error bars"",200,10,700,500);; 38 const Int_t n = 10;; 39 Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; 40 Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; 41 Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; 42 Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; 43 Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; 44 Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; 45 Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 46 Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; 47 Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 48 Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; 49 auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; 50 gr->SetTitle(""TGrap",MatchSource.WIKI,doc/master/TGraphBentErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html
Availability,error,error,". ROOT: hist/hist/inc/TGraphBentErrors.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGraphBentErrors.h. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Dave Morrison 30/06/2003; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TGraphBentErrors; 13#define ROOT_TGraphBentErrors; 14 ; 15//////////////////////////////////////////////////////////////////////////; 16// //; 17// TGraphBentErrors //; 18// //; 19// a Graph with bent, asymmetric error bars //; 20// //; 21//////////////////////////////////////////////////////////////////////////; 22 ; 23#include ""TGraph.h""; 24 ; 25class TGraphBentErrors : public TGraph {; 26 ; 27protected:; 28 Double_t *fEXlow; ///<[fNpoints] array of X low errors; 29 Double_t *fEXhigh; ///<[fNpoints] array of X high errors; 30 Double_t *fEYlow; ///<[fNpoints] array of Y low errors; 31 Double_t *fEYhigh; ///<[fNpoints] array of Y high errors; 32 ; 33 Double_t *fEXlowd; ///<[fNpoints] array of X low displacements; 34 Double_t *fEXhighd; ///<[fNpoints] array of X high displacements; 35 Double_t *fEYlowd; ///<[fNpoints] array of Y low displacements; 36 Double_t *fEYhighd; ///<[fNpoints] array of Y high displacements; 37 ; 38 void SwapPoints(Int_t pos1, Int_t pos2) override;; 39 void UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low) override;; 40 ; 41 Double_t** Allocate(Int_t size) override;; 42 void CopyAndRelease(Double_t **newarrays,; 43 Int_t ibegin, Int_t iend, Int_t obegin) override;; 44 Bool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend,; 45 Int_t obegin) override;; 46 Bool_",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
Deployability,release,release,""") const overridePrint graph and errors values.Definition TGraphBentErrors.cxx:495; TGraphBentErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphBentErrors by a constant c1.Definition TGraphBentErrors.cxx:510; TGraphBentErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end]Definition TGraphBentErrors.cxx:474; TGraphBentErrors::GetEXlowdDouble_t * GetEXlowd() const overrideDefinition TGraphBentErrors.h:84; TGraphBentErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphBentErrors.cxx:416; TGraphBentErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphBentErrors.h:30; TGraphBentErrors::fEYhighdDouble_t * fEYhighd[fNpoints] array of Y high displacementsDefinition TGraphBentErrors.h:36; TGraphBentErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphBentErrors.cxx:278; TGraphBentErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphBentErrors.cxx:646; TGraphBentErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE***to arrays[***] or to f*** Copy points.Definition TGraphBentErrors.cxx:312; TGraphBentErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideGet low error on Y[i].Definition TGraphBentErrors.cxx:463; TGraphBentErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphBentErrors.cxx:402; TGraphBentErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideGet high error on Y[i].Definition TGraphBentErrors.cxx:452; TGraphBentErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphBentErrors.cxx:210; TGraphA T",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
Performance,perform,perform,"ion TGraphBentErrors.cxx:665; TGraphBentErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphBentErrors.cxx:551; TGraphBentErrors::TGraphBentErrorsTGraphBentErrors()TGraphBentErrors default constructor.Definition TGraphBentErrors.cxx:62; TGraphBentErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphBentErrors.h:80; TGraphBentErrors::fEYhighDouble_t * fEYhigh[fNpoints] array of Y high errorsDefinition TGraphBentErrors.h:31; TGraphBentErrors::fEXlowdDouble_t * fEXlowd[fNpoints] array of X low displacementsDefinition TGraphBentErrors.h:33; TGraphBentErrors::fEYlowdDouble_t * fEYlowd[fNpoints] array of Y low displacementsDefinition TGraphBentErrors.h:35; TGraphBentErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphBentErrors.cxx:346; TGraphBentErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphBentErrors.cxx:367; TGraphBentErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition TGraphBentErrors.h:83; TGraphBentErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideGet low error on X[i].Definition TGraphBentErrors.cxx:441; TGraphBentErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphBentErrors.h:82; TGraphBentErrors::GetEYhighdDouble_t * GetEYhighd() const overrideDefinition TGraphBentErrors.h:87; TGraphBentErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute range.Definition TGraphBentErrors.cxx:248; TGraphBentErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphBentErrors.h:81; TGraphBentErrors::GetEYlowdDouble_t * GetEYlowd() const overrideDefinition TGraphBentErrors.h:86; TGraphBentErrors::fEXhighdDouble_t * fEXhighd[fNpoints] array of X high displacem",MatchSource.WIKI,doc/master/TGraphBentErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html
Availability,error,errors,"360 if (m == 1) {; 361 p1 = pa;; 362 p2 = na;; 363 p3 = ma;; 364 } else if (m == 2) {; 365 p1 = pa;; 366 p2 = ma;; 367 p3 = na;; 368 } else if (m == 3) {; 369 p1 = na;; 370 p2 = ma;; 371 p3 = pa;; 372 }; 373 // get the coordinates of the centre of this side; 374 xm = (fXN[p1]+fXN[p2])/2.;; 375 ym = (fYN[p1]+fYN[p2])/2.;; 376 // we want to add a little to these coordinates to get a point just; 377 // outside the triangle; (sx,sy) will be the vector that represents; 378 // the side; 379 sx = fXN[p1]-fXN[p2];; 380 sy = fYN[p1]-fYN[p2];; 381 // (nx,ny) will be the normal to the side, but don't know if it's; 382 // pointing in or out yet; 383 nx = sy;; 384 ny = -sx;; 385 nn = TMath::Sqrt(nx*nx+ny*ny);; 386 nx = nx/nn;; 387 ny = ny/nn;; 388 mx = fXN[p3]-xm;; 389 my = fYN[p3]-ym;; 390 mdotn = mx*nx+my*ny;; 391 if (mdotn > 0) {; 392 // (nx,ny) is pointing in, we want it pointing out; 393 nx = -nx;; 394 ny = -ny;; 395 }; 396 // increase/decrease xm and ym a little to produce a point; 397 // just outside the triangle (ensuring that the amount added will; 398 // be large enough such that it won't be lost in rounding errors); 399 a = TMath::Abs(TMath::Max(alittlebit*xm,alittlebit*ym));; 400 xx = xm+nx*a;; 401 yy = ym+ny*a;; 402 // try and find a new Delaunay triangle for this point; 403 Interpolate(xx,yy);; 404 ; 405 // this side of t1 should now, hopefully, if it's not part of the; 406 // hull, be shared with a new Delaunay triangle just calculated by Interpolate; 407 }; 408 }; 409 t1++;; 410 }; 411}; 412 ; 413 ; 414////////////////////////////////////////////////////////////////////////////////; 415/// Finds those points which make up the convex hull of the set. If the xy; 416/// plane were a sheet of wood, and the points were nails hammered into it; 417/// at the respective coordinates, then if an elastic band were stretched; 418/// over all the nails it would form the shape of the convex hull. Those; 419/// nails in contact with it are the points that make up the hull.; 420",MatchSource.WIKI,doc/master/TGraphDelaunay_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html
Integrability,message,message,"ucturevoid CreateTrianglesDataStructure()Function used internally only.Definition TGraphDelaunay.cxx:178; TGraphDelaunay::fPTriedInt_t * fPTried!Definition TGraphDelaunay.h:59; TGraphDelaunay::fNhullInt_t fNhull! Number of points in the hullDefinition TGraphDelaunay.h:41; TGraphDelaunay::InterpolateDouble_t Interpolate(Double_t x, Double_t y)Finds the Delaunay triangle that the point (xi,yi) sits in (if any) and calculate a z-value for it by...Definition TGraphDelaunay.cxx:595; TGraphDelaunay::TGraphDelaunayTGraphDelaunay()TGraphDelaunay default constructor.Definition TGraphDelaunay.cxx:49; TGraphDelaunay::fHullPointsInt_t * fHullPoints! Hull points of size fNhullDefinition TGraphDelaunay.h:62; TGraphDelaunay::fXNDouble_t * fXN! fGraph2D vectors normalized of size fNpointsDefinition TGraphDelaunay.h:45; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; bool; double; int; Interpolate#define Interpolate(a, x, b, y)Definition geom.c:179; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; f1TF1 * f1Definition legend1.C:11; c2return c2Definition legend2.C:14; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::IsInsideBool_t IsInside(T xp, T yp, Int_t np, T *x, T *y)Function which returns kTRUE if point xp,yp lies inside the polygon defined by the np points in array...Definition TMath.h:1233; TMath::ATan2Double_t ATan2(Double_t y, Double_t x)Returns the principal value of the arc tangent of y/x, expressed in radians.Definition TMath.h:646; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition",MatchSource.WIKI,doc/master/TGraphDelaunay_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html
Performance,perform,performed,"ffset!Definition TGraphDelaunay.h:51; TGraphDelaunay::fDistDouble_t * fDist! Array used to order mass points by distanceDefinition TGraphDelaunay.h:56; TGraphDelaunay::FileItvoid FileIt(Int_t P, Int_t N, Int_t M)Files the triangle defined by the 3 vertices p, n and m into the fxTried arrays.Definition TGraphDelaunay.cxx:237; TGraphDelaunay::fYNminDouble_t fYNmin! Minimum value of fYNDefinition TGraphDelaunay.h:49; TGraphDelaunay::fTriedSizeInt_t fTriedSize! Real size of the fxTried arraysDefinition TGraphDelaunay.h:58; TGraphDelaunay::fMTriedInt_t * fMTried!Definition TGraphDelaunay.h:61; TGraphDelaunay::fXDouble_t * fX! Pointer to fGraph2D->fXDefinition TGraphDelaunay.h:42; TGraphDelaunay::fGraph2DTGraph2D * fGraph2D! 2D graph containing the user dataDefinition TGraphDelaunay.h:66; TGraphDelaunay::FindAllTrianglesvoid FindAllTriangles()Attempt to find all the Delaunay triangles of the point set.Definition TGraphDelaunay.cxx:290; TGraphDelaunay::fAllTriBool_t fAllTri! True if FindAllTriangles() has been performed on fGraph2DDefinition TGraphDelaunay.h:64; TGraphDelaunay::SetMaxItervoid SetMaxIter(Int_t n=100000)Defines the number of triangles tested for a Delaunay triangle (number of iterations) before abandoni...Definition TGraphDelaunay.cxx:932; TGraphDelaunay::fMaxIterInt_t fMaxIter! Maximum number of iterations to find Delaunay trianglesDefinition TGraphDelaunay.h:57; TGraphDelaunay::fInitBool_t fInit! True if CreateTrianglesDataStructure() and FindHull() have been performedDefinition TGraphDelaunay.h:65; TGraphDelaunay::fOrderInt_t * fOrder! Array used to order mass points by distanceDefinition TGraphDelaunay.h:63; TGraphDelaunay::EncloseBool_t Enclose(Int_t T1, Int_t T2, Int_t T3, Int_t Ex) constIs point e inside the triangle t1-t2-t3 ?Definition TGraphDelaunay.cxx:215; TGraphDelaunay::fXScaleFactorDouble_t fXScaleFactor!Definition TGraphDelaunay.h:53; TGraphDelaunay::fNdtInt_t fNdt! Number of Delaunay triangles foundDefinition TGraphDelaunay.h:39; TGraphDelaun",MatchSource.WIKI,doc/master/TGraphDelaunay_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html
Safety,avoid,avoid," fNTried = nullptr;; 136 fMTried = nullptr;; 137 fHullPoints = nullptr;; 138 fOrder = nullptr;; 139 fDist = nullptr;; 140 fXN = nullptr;; 141 fYN = nullptr;; 142}; 143 ; 144 ; 145////////////////////////////////////////////////////////////////////////////////; 146/// Return the z value corresponding to the (x,y) point in fGraph2D; 147 ; 148Double_t TGraphDelaunay::ComputeZ(Double_t x, Double_t y); 149{; 150 // Initialise the Delaunay algorithm if needed.; 151 // CreateTrianglesDataStructure computes fXoffset, fYoffset,; 152 // fXScaleFactor and fYScaleFactor;; 153 // needed in this function.; 154 if (!fInit) {; 155 CreateTrianglesDataStructure();; 156 FindHull();; 157 fInit = kTRUE;; 158 }; 159 ; 160 // Find the z value corresponding to the point (x,y).; 161 Double_t xx, yy;; 162 xx = (x+fXoffset)*fXScaleFactor;; 163 yy = (y+fYoffset)*fYScaleFactor;; 164 Double_t zz = Interpolate(xx, yy);; 165 ; 166 // Wrong zeros may appear when points sit on a regular grid.; 167 // The following line try to avoid this problem.; 168 if (zz==0) zz = Interpolate(xx+0.0001, yy);; 169 ; 170 return zz;; 171}; 172 ; 173 ; 174////////////////////////////////////////////////////////////////////////////////; 175/// Function used internally only. It creates the data structures needed to; 176/// compute the Delaunay triangles.; 177 ; 178void TGraphDelaunay::CreateTrianglesDataStructure(); 179{; 180 // Offset fX and fY so they average zero, and scale so the average; 181 // of the X and Y ranges is one. The normalized version of fX and fY used; 182 // in Interpolate.; 183 Double_t xmax = fGraph2D->GetXmax();; 184 Double_t ymax = fGraph2D->GetYmax();; 185 Double_t xmin = fGraph2D->GetXmin();; 186 Double_t ymin = fGraph2D->GetYmin();; 187 fXoffset = -(xmax+xmin)/2.;; 188 fYoffset = -(ymax+ymin)/2.;; 189 fXScaleFactor = 1./(xmax-xmin);; 190 fYScaleFactor = 1./(ymax-ymin);; 191 fXNmax = (xmax+fXoffset)*fXScaleFactor;; 192 fXNmin = (xmin+fXoffset)*fXScaleFactor;; 193 fYNmax = (ymax+fYoffset)*fYScale",MatchSource.WIKI,doc/master/TGraphDelaunay_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html
Testability,test,test,,MatchSource.WIKI,doc/master/TGraphDelaunay_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html
Performance,perform,performed,"rs normalized of size fNpoints; 47 Double_t fXNmin; ///<! Minimum value of fXN; 48 Double_t fXNmax; ///<! Maximum value of fXN; 49 Double_t fYNmin; ///<! Minimum value of fYN; 50 Double_t fYNmax; ///<! Maximum value of fYN; 51 Double_t fXoffset; ///<!; 52 Double_t fYoffset; ///<! Parameters used to normalize user data; 53 Double_t fXScaleFactor; ///<!; 54 Double_t fYScaleFactor; ///<!; 55 Double_t fZout; ///<! Histogram bin height for points lying outside the convex hull; 56 Double_t *fDist; ///<! Array used to order mass points by distance; 57 Int_t fMaxIter; ///<! Maximum number of iterations to find Delaunay triangles; 58 Int_t fTriedSize; ///<! Real size of the fxTried arrays; 59 Int_t *fPTried; ///<!; 60 Int_t *fNTried; ///<! Delaunay triangles storage of size fNdt; 61 Int_t *fMTried; ///<!; 62 Int_t *fHullPoints; ///<! Hull points of size fNhull; 63 Int_t *fOrder; ///<! Array used to order mass points by distance; 64 Bool_t fAllTri; ///<! True if FindAllTriangles() has been performed on fGraph2D; 65 Bool_t fInit; ///<! True if CreateTrianglesDataStructure() and FindHull() have been performed; 66 TGraph2D *fGraph2D; ///<! 2D graph containing the user data; 67 ; 68 void CreateTrianglesDataStructure();; 69 Bool_t Enclose(Int_t T1, Int_t T2, Int_t T3, Int_t Ex) const;; 70 void FileIt(Int_t P, Int_t N, Int_t M);; 71 void FindHull();; 72 Bool_t InHull(Int_t E, Int_t X) const;; 73 Double_t InterpolateOnPlane(Int_t TI1, Int_t TI2, Int_t TI3, Int_t E) const;; 74 ; 75public:; 76 ; 77 TGraphDelaunay();; 78 TGraphDelaunay(TGraph2D *g);; 79 ; 80 ~TGraphDelaunay() override;; 81 ; 82 Double_t ComputeZ(Double_t x, Double_t y);; 83 void FindAllTriangles();; 84 TGraph2D *GetGraph2D() const {return fGraph2D;}; 85 Double_t GetMarginBinsContent() const {return fZout;}; 86 Int_t GetNdt() const {return fNdt;}; 87 Int_t *GetPTried() const {return fPTried;}; 88 Int_t *GetNTried() const {return fNTried;}; 89 Int_t *GetMTried() const {return fMTried;}; 90 Double_t *GetXN() const {return",MatchSource.WIKI,doc/master/TGraphDelaunay_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8h_source.html
Testability,test,tested,"ize of the fxTried arraysDefinition TGraphDelaunay.h:58; TGraphDelaunay::fMTriedInt_t * fMTried!Definition TGraphDelaunay.h:61; TGraphDelaunay::operator=TGraphDelaunay & operator=(const TGraphDelaunay &)=delete; TGraphDelaunay::fXDouble_t * fX! Pointer to fGraph2D->fXDefinition TGraphDelaunay.h:42; TGraphDelaunay::fGraph2DTGraph2D * fGraph2D! 2D graph containing the user dataDefinition TGraphDelaunay.h:66; TGraphDelaunay::FindAllTrianglesvoid FindAllTriangles()Attempt to find all the Delaunay triangles of the point set.Definition TGraphDelaunay.cxx:290; TGraphDelaunay::TGraphDelaunayTGraphDelaunay(const TGraphDelaunay &)=delete; TGraphDelaunay::GetXNDouble_t * GetXN() constDefinition TGraphDelaunay.h:90; TGraphDelaunay::fAllTriBool_t fAllTri! True if FindAllTriangles() has been performed on fGraph2DDefinition TGraphDelaunay.h:64; TGraphDelaunay::GetPTriedInt_t * GetPTried() constDefinition TGraphDelaunay.h:87; TGraphDelaunay::SetMaxItervoid SetMaxIter(Int_t n=100000)Defines the number of triangles tested for a Delaunay triangle (number of iterations) before abandoni...Definition TGraphDelaunay.cxx:932; TGraphDelaunay::fMaxIterInt_t fMaxIter! Maximum number of iterations to find Delaunay trianglesDefinition TGraphDelaunay.h:57; TGraphDelaunay::GetNTriedInt_t * GetNTried() constDefinition TGraphDelaunay.h:88; TGraphDelaunay::fInitBool_t fInit! True if CreateTrianglesDataStructure() and FindHull() have been performedDefinition TGraphDelaunay.h:65; TGraphDelaunay::GetYNminDouble_t GetYNmin() constDefinition TGraphDelaunay.h:94; TGraphDelaunay::fOrderInt_t * fOrder! Array used to order mass points by distanceDefinition TGraphDelaunay.h:63; TGraphDelaunay::EncloseBool_t Enclose(Int_t T1, Int_t T2, Int_t T3, Int_t Ex) constIs point e inside the triangle t1-t2-t3 ?Definition TGraphDelaunay.cxx:215; TGraphDelaunay::fXScaleFactorDouble_t fXScaleFactor!Definition TGraphDelaunay.h:53; TGraphDelaunay::fNdtInt_t fNdt! Number of Delaunay triangles foundDefinition TGraphDelaunay.h:3",MatchSource.WIKI,doc/master/TGraphDelaunay_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8h_source.html
Availability,error,error,"ile. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGraphErrors.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Rene Brun 15/09/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13#include ""TROOT.h""; 14#include ""TBuffer.h""; 15#include ""TGraphErrors.h""; 16#include ""TStyle.h""; 17#include ""TMath.h""; 18#include ""TVirtualPad.h""; 19#include ""TH1.h""; 20#include ""TF1.h""; 21#include ""TVectorD.h""; 22#include ""TSystem.h""; 23#include ""strtok.h""; 24 ; 25#include <iostream>; 26#include <fstream>; 27#include <cstring>; 28#include <string>; 29 ; 30ClassImp(TGraphErrors);; 31 ; 32 ; 33////////////////////////////////////////////////////////////////////////////////; 34 ; 35/** \class TGraphErrors; 36 \ingroup Graphs; 37A TGraphErrors is a TGraph with error bars.; 38 ; 39The TGraphErrors painting is performed thanks to the TGraphPainter; 40class. All details about the various painting options are given in this class.; 41 ; 42The picture below gives an example:; 43 ; 44Begin_Macro(source); 45{; 46 auto c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; 47 c1->SetFillColor(42);; 48 c1->SetGrid();; 49 c1->GetFrame()->SetFillColor(21);; 50 c1->GetFrame()->SetBorderSize(12);; 51 const Int_t n = 10;; 52 Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; 53 Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; 54 Double_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; 55 Double_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; 56 auto gr = new TGraphErrors(n,x,y,ex,ey);; 57 gr->SetTitle(""TGraphErrors Example"");; 58 gr->SetMarkerColor(4);; 59 gr->SetMa",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
Deployability,release,release,"*++fmt && ']' == *fmt) ++fmt; // ""%[]a]"" or ""%[^]a]""; 458 while (*fmt && *fmt != ']'); 459 ++fmt;; 460 if (!skip) ++fields;; 461 break;; 462 }; 463 if ('%' == *fmt) break; // %% literal %; 464 if ('*' == *fmt) {; 465 skip = kTRUE; // %*d -- skip a number; 466 } else if (strchr(""dDiouxXxfegEscpn"", *fmt)) {; 467 if (!skip) ++fields;; 468 break;; 469 }; 470 // skip modifiers & field width; 471 }; 472 }; 473 return fields;; 474}; 475 ; 476 ; 477////////////////////////////////////////////////////////////////////////////////; 478/// Compute range.; 479 ; 480void TGraphErrors::ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const; 481{; 482 TGraph::ComputeRange(xmin, ymin, xmax, ymax);; 483 ; 484 for (Int_t i = 0; i < fNpoints; i++) {; 485 if (fX[i] - fEX[i] < xmin) {; 486 if (gPad && gPad->GetLogx()) {; 487 if (fEX[i] < fX[i]) xmin = fX[i] - fEX[i];; 488 else xmin = TMath::Min(xmin, fX[i] / 3);; 489 } else {; 490 xmin = fX[i] - fEX[i];; 491 }; 492 }; 493 if (fX[i] + fEX[i] > xmax) xmax = fX[i] + fEX[i];; 494 if (fY[i] - fEY[i] < ymin) {; 495 if (gPad && gPad->GetLogy()) {; 496 if (fEY[i] < fY[i]) ymin = fY[i] - fEY[i];; 497 else ymin = TMath::Min(ymin, fY[i] / 3);; 498 } else {; 499 ymin = fY[i] - fEY[i];; 500 }; 501 }; 502 if (fY[i] + fEY[i] > ymax) ymax = fY[i] + fEY[i];; 503 }; 504}; 505 ; 506 ; 507////////////////////////////////////////////////////////////////////////////////; 508/// Copy and release.; 509 ; 510void TGraphErrors::CopyAndRelease(Double_t **newarrays,; 511 Int_t ibegin, Int_t iend, Int_t obegin); 512{; 513 CopyPoints(newarrays, ibegin, iend, obegin);; 514 if (newarrays) {; 515 delete[] fX;; 516 fX = newarrays[2];; 517 delete[] fY;; 518 fY = newarrays[3];; 519 delete[] fEX;; 520 fEX = newarrays[0];; 521 delete[] fEY;; 522 fEY = newarrays[1];; 523 delete[] newarrays;; 524 }; 525}; 526 ; 527 ; 528////////////////////////////////////////////////////////////////////////////////; 529/// Copy errors from `fEX` and `fEY` to `arrays",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
Energy Efficiency,allocate,allocate,"/; 508/// Copy and release.; 509 ; 510void TGraphErrors::CopyAndRelease(Double_t **newarrays,; 511 Int_t ibegin, Int_t iend, Int_t obegin); 512{; 513 CopyPoints(newarrays, ibegin, iend, obegin);; 514 if (newarrays) {; 515 delete[] fX;; 516 fX = newarrays[2];; 517 delete[] fY;; 518 fY = newarrays[3];; 519 delete[] fEX;; 520 fEX = newarrays[0];; 521 delete[] fEY;; 522 fEY = newarrays[1];; 523 delete[] newarrays;; 524 }; 525}; 526 ; 527 ; 528////////////////////////////////////////////////////////////////////////////////; 529/// Copy errors from `fEX` and `fEY` to `arrays[0]` and `arrays[1]`; 530/// or to `fEX` and `fEY` if `arrays == 0` and `ibegin != iend`.; 531 ; 532Bool_t TGraphErrors::CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend,; 533 Int_t obegin); 534{; 535 if (TGraph::CopyPoints(arrays ? arrays + 2 : nullptr, ibegin, iend, obegin)) {; 536 Int_t n = (iend - ibegin) * sizeof(Double_t);; 537 if (arrays) {; 538 memmove(&arrays[0][obegin], &fEX[ibegin], n);; 539 memmove(&arrays[1][obegin], &fEY[ibegin], n);; 540 } else {; 541 memmove(&fEX[obegin], &fEX[ibegin], n);; 542 memmove(&fEY[obegin], &fEY[ibegin], n);; 543 }; 544 return kTRUE;; 545 } else {; 546 return kFALSE;; 547 }; 548}; 549 ; 550 ; 551////////////////////////////////////////////////////////////////////////////////; 552/// Constructor allocate.; 553///; 554/// Note: This function should be called only from the constructor; 555/// since it does not delete previously existing arrays.; 556 ; 557Bool_t TGraphErrors::CtorAllocate(); 558{; 559 ; 560 if (!fNpoints) {; 561 fEX = fEY = nullptr;; 562 return kFALSE;; 563 } else {; 564 fEX = new Double_t[fMaxSize];; 565 fEY = new Double_t[fMaxSize];; 566 }; 567 return kTRUE;; 568}; 569 ; 570////////////////////////////////////////////////////////////////////////////////; 571/// Protected function to perform the merge operation of a graph with errors.; 572 ; 573Bool_t TGraphErrors::DoMerge(const TGraph *g); 574{; 575 if (g->GetN() == 0) return kFALSE;; 576 ;",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
Integrability,message,message,"4 if (!format_.IsDigit()) {; 285 Error(""TGraphErrors"", ""Incorrect input format! Allowed format tags are {\""%%lg\"",\""%%*lg\"" or \""%%*s\""}"");; 286 return ;; 287 }; 288 Int_t ntokens = format_.Length() ;; 289 if (ntokens < 2) {; 290 Error(""TGraphErrors"", ""Incorrect input format! Only %d tag(s) in format whereas at least 2 \""%%lg\"" tags are expected!"", ntokens);; 291 return ;; 292 }; 293 Int_t ntokensToBeSaved = 0 ;; 294 Bool_t * isTokenToBeSaved = new Bool_t [ntokens] ;; 295 for (Int_t idx = 0; idx < ntokens; idx++) {; 296 isTokenToBeSaved[idx] = TString::Format(""%c"", format_[idx]).Atoi() ; //atoi(&format_[idx]) does not work for some reason...; 297 if (isTokenToBeSaved[idx] == 1) {; 298 ntokensToBeSaved++ ;; 299 }; 300 }; 301 if (ntokens >= 2 && (ntokensToBeSaved < 2 || ntokensToBeSaved > 4)) { //first condition not to repeat the previous error message; 302 Error(""TGraphErrors"", ""Incorrect input format! There are %d \""%%lg\"" tag(s) in format whereas 2,3 or 4 are expected!"", ntokensToBeSaved);; 303 delete [] isTokenToBeSaved ;; 304 return ;; 305 }; 306 ; 307 // Initializing loop variables; 308 Bool_t isLineToBeSkipped = kFALSE; //empty and ill-formed lines; 309 char *token = nullptr;; 310 TString token_str = """";; 311 Int_t token_idx = 0;; 312 Double_t value[4]; //x,y,ex,ey buffers; 313 for (Int_t k = 0; k < 4; k++); 314 value[k] = 0.;; 315 Int_t value_idx = 0;; 316 ; 317 // Looping; 318 char *rest;; 319 while (std::getline(infile, line, '\n')) {; 320 if (!line.empty()) {; 321 if (line[line.size() - 1] == char(13)) { // removing DOS CR character; 322 line.erase(line.end() - 1, line.end()) ;; 323 }; 324 token = R__STRTOK_R(const_cast<char *>(line.c_str()), option, &rest);; 325 while (token != nullptr && value_idx < ntokensToBeSaved) {; 326 if (isTokenToBeSaved[token_idx]) {; 327 token_str = TString(token) ;; 328 token_str.ReplaceAll(""\t"", """") ;; 329 if (!token_str.IsFloat()) {; 330 isLineToBeSkipped = kTRUE ;; 331 break ;; 332 } else {; 333 value[value_idx] = token_str.At",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
Modifiability,variab,variables,"4 if (!format_.IsDigit()) {; 285 Error(""TGraphErrors"", ""Incorrect input format! Allowed format tags are {\""%%lg\"",\""%%*lg\"" or \""%%*s\""}"");; 286 return ;; 287 }; 288 Int_t ntokens = format_.Length() ;; 289 if (ntokens < 2) {; 290 Error(""TGraphErrors"", ""Incorrect input format! Only %d tag(s) in format whereas at least 2 \""%%lg\"" tags are expected!"", ntokens);; 291 return ;; 292 }; 293 Int_t ntokensToBeSaved = 0 ;; 294 Bool_t * isTokenToBeSaved = new Bool_t [ntokens] ;; 295 for (Int_t idx = 0; idx < ntokens; idx++) {; 296 isTokenToBeSaved[idx] = TString::Format(""%c"", format_[idx]).Atoi() ; //atoi(&format_[idx]) does not work for some reason...; 297 if (isTokenToBeSaved[idx] == 1) {; 298 ntokensToBeSaved++ ;; 299 }; 300 }; 301 if (ntokens >= 2 && (ntokensToBeSaved < 2 || ntokensToBeSaved > 4)) { //first condition not to repeat the previous error message; 302 Error(""TGraphErrors"", ""Incorrect input format! There are %d \""%%lg\"" tag(s) in format whereas 2,3 or 4 are expected!"", ntokensToBeSaved);; 303 delete [] isTokenToBeSaved ;; 304 return ;; 305 }; 306 ; 307 // Initializing loop variables; 308 Bool_t isLineToBeSkipped = kFALSE; //empty and ill-formed lines; 309 char *token = nullptr;; 310 TString token_str = """";; 311 Int_t token_idx = 0;; 312 Double_t value[4]; //x,y,ex,ey buffers; 313 for (Int_t k = 0; k < 4; k++); 314 value[k] = 0.;; 315 Int_t value_idx = 0;; 316 ; 317 // Looping; 318 char *rest;; 319 while (std::getline(infile, line, '\n')) {; 320 if (!line.empty()) {; 321 if (line[line.size() - 1] == char(13)) { // removing DOS CR character; 322 line.erase(line.end() - 1, line.end()) ;; 323 }; 324 token = R__STRTOK_R(const_cast<char *>(line.c_str()), option, &rest);; 325 while (token != nullptr && value_idx < ntokensToBeSaved) {; 326 if (isTokenToBeSaved[token_idx]) {; 327 token_str = TString(token) ;; 328 token_str.ReplaceAll(""\t"", """") ;; 329 if (!token_str.IsFloat()) {; 330 isLineToBeSkipped = kTRUE ;; 331 break ;; 332 } else {; 333 value[value_idx] = token_str.At",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
Performance,perform,performed,"4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13#include ""TROOT.h""; 14#include ""TBuffer.h""; 15#include ""TGraphErrors.h""; 16#include ""TStyle.h""; 17#include ""TMath.h""; 18#include ""TVirtualPad.h""; 19#include ""TH1.h""; 20#include ""TF1.h""; 21#include ""TVectorD.h""; 22#include ""TSystem.h""; 23#include ""strtok.h""; 24 ; 25#include <iostream>; 26#include <fstream>; 27#include <cstring>; 28#include <string>; 29 ; 30ClassImp(TGraphErrors);; 31 ; 32 ; 33////////////////////////////////////////////////////////////////////////////////; 34 ; 35/** \class TGraphErrors; 36 \ingroup Graphs; 37A TGraphErrors is a TGraph with error bars.; 38 ; 39The TGraphErrors painting is performed thanks to the TGraphPainter; 40class. All details about the various painting options are given in this class.; 41 ; 42The picture below gives an example:; 43 ; 44Begin_Macro(source); 45{; 46 auto c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; 47 c1->SetFillColor(42);; 48 c1->SetGrid();; 49 c1->GetFrame()->SetFillColor(21);; 50 c1->GetFrame()->SetBorderSize(12);; 51 const Int_t n = 10;; 52 Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; 53 Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; 54 Double_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; 55 Double_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; 56 auto gr = new TGraphErrors(n,x,y,ex,ey);; 57 gr->SetTitle(""TGraphErrors Example"");; 58 gr->SetMarkerColor(4);; 59 gr->SetMarkerStyle(21);; 60 gr->Draw(""ALP"");; 61}; 62End_Macro; 63*/; 64 ; 65 ; 66////////////////////////////////////////////////////////////////////////////////; 67/// TGraphErrors default constructor.; 68 ; 69",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
Safety,avoid,avoid," from the TH1 object passed as argument; 203 ; 204TGraphErrors::TGraphErrors(const TH1 *h); 205 : TGraph(h); 206{; 207 if (!CtorAllocate()) return;; 208 ; 209 for (Int_t i = 0; i < fNpoints; i++) {; 210 fEX[i] = h->GetBinWidth(i + 1) * gStyle->GetErrorX();; 211 fEY[i] = h->GetBinError(i + 1);; 212 }; 213}; 214 ; 215 ; 216////////////////////////////////////////////////////////////////////////////////; 217/// GraphErrors constructor reading input from `filename`.; 218///; 219/// `filename` is assumed to contain at least 2 columns of numbers; 220///; 221/// Convention for format (default=`""%lg %lg %lg %lg""`); 222///; 223/// - format = `%lg %lg` read only 2 first columns into X,Y; 224/// - format = `%lg %lg %lg` read only 3 first columns into X,Y and EY; 225/// - format = `%lg %lg %lg %lg` read only 4 first columns into X,Y,EX,EY.; 226///; 227/// For files separated by a specific delimiter different from ' ' and `\\t` (e.g. `;` in csv files); 228/// you can avoid using `%*s` to bypass this delimiter by explicitly specify the `option` argument,; 229/// e.g. `option="" \\t,;""` for columns of figures separated by any of these characters (`' ', '\\t', ',', ';'`); 230/// used once (e.g. `""1;1""`) or in a combined way (`"" 1;,;; 1""`).; 231///; 232/// Note in that case, the instantiation is about 2 times slower.; 233/// In case a delimiter is specified, the format `""%lg %lg %lg""` will read X,Y,EX.; 234 ; 235TGraphErrors::TGraphErrors(const char *filename, const char *format, Option_t *option); 236 : TGraph(100); 237{; 238 if (!CtorAllocate()) return;; 239 Double_t x, y, ex, ey;; 240 TString fname = filename;; 241 gSystem->ExpandPathName(fname);; 242 std::ifstream infile(fname.Data());; 243 if (!infile.good()) {; 244 MakeZombie();; 245 Error(""TGraphErrors"", ""Cannot open file: %s, TGraphErrors is Zombie"", filename);; 246 fNpoints = 0;; 247 return;; 248 }; 249 std::string line;; 250 Int_t np = 0;; 251 ; 252 if (strcmp(option, """") == 0) { // No delimiters specified (standard construc",MatchSource.WIKI,doc/master/TGraphErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html
Availability,error,error,". ROOT: hist/hist/inc/TGraphErrors.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TGraphErrors.h File Reference. #include ""TGraph.h"". Include dependency graph for TGraphErrors.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGraphErrors;  A TGraphErrors is a TGraph with error bars. More...;  . histhistincTGraphErrors.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphErrors_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h.html
Integrability,depend,dependency,". ROOT: hist/hist/inc/TGraphErrors.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TGraphErrors.h File Reference. #include ""TGraph.h"". Include dependency graph for TGraphErrors.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGraphErrors;  A TGraphErrors is a TGraph with error bars. More...;  . histhistincTGraphErrors.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphErrors_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h.html
Availability,error,error,". ROOT: hist/hist/inc/TGraphErrors.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGraphErrors.h. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Rene Brun 15/09/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TGraphErrors; 13#define ROOT_TGraphErrors; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TGraphErrors //; 19// //; 20// a Graph with error bars //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TGraph.h""; 25 ; 26class TGraphErrors : public TGraph {; 27 ; 28protected:; 29 Double_t *fEX{nullptr}; ///<[fNpoints] array of X errors; 30 Double_t *fEY{nullptr}; ///<[fNpoints] array of Y errors; 31 ; 32 void SwapPoints(Int_t pos1, Int_t pos2) override;; 33 void UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low) override;; 34 ; 35 Double_t** Allocate(Int_t size) override;; 36 void CopyAndRelease(Double_t **newarrays,; 37 Int_t ibegin, Int_t iend, Int_t obegin) override;; 38 Bool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend,; 39 Int_t obegin) override;; 40 Bool_t CtorAllocate();; 41 void FillZero(Int_t begin, Int_t end,; 42 Bool_t from_ctor = kTRUE) override;; 43 Bool_t DoMerge(const TGraph * g) override;; 44 ; 45 ; 46public:; 47 TGraphErrors();; 48 TGraphErrors(Int_t n);; 49 TGraphErrors(Int_t n, const Float_t *x, const Float_t *y, const Float_t *ex = nullptr, const Float_t *ey = nullptr);; 50 TGraphErrors(Int_t n, const Double_t *x, const Double_t *y, const Double_t *ex = nullptr, const D",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
Deployability,release,release,"rorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:671; TGraphErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:659; TGraphErrors::operator=TGraphErrors & operator=(const TGraphErrors &gr)TGraphErrors assignment operator.Definition TGraphErrors.cxx:184; TGraphErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin !...Definition TGraphErrors.cxx:532; TGraphErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with errors from the collection to this graph.Definition TGraphErrors.cxx:682; TGraphErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphErrors.cxx:510; TGraphErrors::TGraphErrorsTGraphErrors()TGraphErrors default constructor.Definition TGraphErrors.cxx:69; TGraphErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:647; TGraphErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphErrors.cxx:722; TGraphErrors::Applyvoid Apply(TF1 *f) overrideApply function to all the data points .Definition TGraphErrors.cxx:396; TGraphErrors::CtorAllocateBool_t CtorAllocate()Constructor allocate.Definition TGraphErrors.cxx:557; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::AllocateArraysDouble_t ** AllocateArrays(Int_t Narrays, Int_t arraySize)Allocate arrays.Definition TGraph.cxx:598; TH1TH1 is the base c",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
Energy Efficiency,allocate,allocate,"ors.cxx:184; TGraphErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin !...Definition TGraphErrors.cxx:532; TGraphErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with errors from the collection to this graph.Definition TGraphErrors.cxx:682; TGraphErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphErrors.cxx:510; TGraphErrors::TGraphErrorsTGraphErrors()TGraphErrors default constructor.Definition TGraphErrors.cxx:69; TGraphErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:647; TGraphErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphErrors.cxx:722; TGraphErrors::Applyvoid Apply(TF1 *f) overrideApply function to all the data points .Definition TGraphErrors.cxx:396; TGraphErrors::CtorAllocateBool_t CtorAllocate()Constructor allocate.Definition TGraphErrors.cxx:557; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::AllocateArraysDouble_t ** AllocateArrays(Int_t Narrays, Int_t arraySize)Allocate arrays.Definition TGraph.cxx:598; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TVectorTTVectorT.Definition TVectorT.h:27; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; exDouble_t ex[n]Definition legend1.C:17. histhistincTGraphErrors.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
Performance,perform,perform,"rs by a constant c1.Definition TGraphErrors.cxx:752; TGraphErrors::CalculateScanfFieldsstatic Int_t CalculateScanfFields(const char *fmt)Calculate scan fields.Definition TGraphErrors.cxx:449; TGraphErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphErrors.cxx:598; TGraphErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t ex=0., Double_t ey=0.)Add a point with errorbars to the graph.Definition TGraphErrors.cxx:377; TGraphErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraphErrors.h:29; TGraphErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphErrors.cxx:711; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex and ey values for point pointed by the mouse.Definition TGraphErrors.cxx:769; TGraphErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with errors.Definition TGraphErrors.cxx:573; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for newsize points.Definition TGraphErrors.h:81; TGraphErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphErrors.cxx:856; TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply function to all the data points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:671; TGraphErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors",MatchSource.WIKI,doc/master/TGraphErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html
Availability,error,error,"ors.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGraphMultiErrors.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Simon Spies 18/02/19; 3 ; 4/*************************************************************************; 5 * Copyright (C) 2018-2019, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TROOT.h""; 13#include ""TStyle.h""; 14#include ""TVirtualPad.h""; 15#include ""TEfficiency.h""; 16#include ""Riostream.h""; 17 ; 18#include ""TArrayD.h""; 19#include ""TVector.h""; 20#include ""TH1.h""; 21#include ""TF1.h""; 22#include ""TMath.h""; 23#include ""Math/QuantFuncMathCore.h""; 24 ; 25#include ""TGraphMultiErrors.h""; 26 ; 27ClassImp(TGraphMultiErrors); 28 ; 29/** \class TGraphMultiErrors; 30 \ingroup Graphs; 31TGraph with asymmetric error bars and multiple y error dimensions.; 32 ; 33The TGraphMultiErrors painting is performed thanks to the TGraphPainter; 34class. All details about the various painting options are given in this class.; 35 ; 36The picture below gives an example:; 37 ; 38Begin_Macro(source); 39{; 40 auto c1 = new TCanvas(""c1"", ""A Simple Graph with multiple y-errors"", 200, 10, 700, 500);; 41 c1->SetGrid();; 42 c1->GetFrame()->SetBorderSize(12);; 43 const Int_t np = 5;; 44 Double_t x[np] = {0, 1, 2, 3, 4};; 45 Double_t y[np] = {0, 2, 4, 1, 3};; 46 Double_t exl[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; 47 Double_t exh[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; 48 Double_t eylstat[np] = {1, 0.5, 1, 0.5, 1};; 49 Double_t eyhstat[np] = {0.5, 1, 0.5, 1, 2};; 50 Double_t eylsys[np] = {0.5, 0.4, 0.8, 0.3, 1.2};; 51 Double_t eyhsys[np] = {0.6, 0.7, 0.6, 0.4, 0.8};; 52 auto gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", np, x, y, exl, exh, eylstat, eyhstat);; 53 gme->AddY",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
Deployability,release,release,"HSum;; 709 fAttFill.resize(0);; 710 fAttLine.resize(0);; 711}; 712 ; 713////////////////////////////////////////////////////////////////////////////////; 714/// Should be called from ctors after `fNpoints` has been set; 715/// Note: This function should be called only from the constructor; 716/// since it does not delete previously existing arrays; 717 ; 718Bool_t TGraphMultiErrors::CtorAllocate(); 719{; 720 if (!fNpoints || !fNYErrors) {; 721 fExL = fExH = nullptr;; 722 fEyL.resize(0);; 723 fEyH.resize(0);; 724 return kFALSE;; 725 }; 726 ; 727 fExL = new Double_t[fMaxSize];; 728 fExH = new Double_t[fMaxSize];; 729 fEyL.resize(fNYErrors, TArrayD(fMaxSize));; 730 fEyH.resize(fNYErrors, TArrayD(fMaxSize));; 731 fEyLSum = new Double_t[fMaxSize];; 732 fEyHSum = new Double_t[fMaxSize];; 733 fAttFill.resize(fNYErrors);; 734 fAttLine.resize(fNYErrors);; 735 ; 736 Int_t n = fMaxSize * sizeof(Double_t);; 737 memset(fExL, 0, n);; 738 memset(fExH, 0, n);; 739 memset(fEyLSum, 0, n);; 740 memset(fEyHSum, 0, n);; 741 ; 742 return kTRUE;; 743}; 744 ; 745////////////////////////////////////////////////////////////////////////////////; 746/// Copy and release.; 747 ; 748void TGraphMultiErrors::CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin); 749{; 750 CopyPoints(newarrays, ibegin, iend, obegin);; 751 if (newarrays) {; 752 delete[] fX;; 753 fX = newarrays[0];; 754 delete[] fY;; 755 fY = newarrays[1];; 756 ; 757 delete[] fExL;; 758 fExL = newarrays[2];; 759 delete[] fExH;; 760 fExH = newarrays[3];; 761 ; 762 if (fEyLSum); 763 delete[] fEyLSum;; 764 fEyLSum = newarrays[4];; 765 if (fEyHSum); 766 delete[] fEyHSum;; 767 fEyHSum = newarrays[5];; 768 ; 769 delete[] newarrays;; 770 }; 771}; 772 ; 773////////////////////////////////////////////////////////////////////////////////; 774/// Copy errors from `fE***` to `arrays[***]`; 775/// or to `f***` Copy points.; 776 ; 777Bool_t TGraphMultiErrors::CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obeg",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
Energy Efficiency,adapt,adapted,";; 967 ; 968 if (f->Eval(x, y - eyL) < f->Eval(x, y + eyH)) {; 969 eyLNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 970 eyHNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 971 } else {; 972 eyHNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 973 eyLNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 974 }; 975 ; 976 // systematic errors and error on x doesn't change; 977 SetPointEY(i, 0, eyLNew, eyHNew);; 978 }; 979 ; 980 if (gPad); 981 gPad->Modified();; 982}; 983 ; 984////////////////////////////////////////////////////////////////////////////////; 985/// This function is only kept for backward compatibility.; 986/// You should rather use the Divide method.; 987/// It calls `Divide(pass,total,""cl=0.683 b(1,1) mode"")` which is equivalent to the; 988/// former BayesDivide method.; 989 ; 990void TGraphMultiErrors::BayesDivide(const TH1 *pass, const TH1 *total, Option_t *); 991{; 992 Divide(pass, total, ""cl=0.683 b(1,1) mode"");; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// This function was adapted from the TGraphAsymmErrors class.; 997/// See TGraphAsymmErrors::Divide for the documentation; 998///; 999/// Only the first error dimension is affected.; 1000 ; 1001void TGraphMultiErrors::Divide(const TH1 *pass, const TH1 *total, Option_t *opt); 1002{; 1003 // check pointers; 1004 if (!pass || !total) {; 1005 Error(""Divide"", ""one of the passed pointers is zero"");; 1006 return;; 1007 }; 1008 ; 1009 // check dimension of histograms; only 1-dimensional ones are accepted; 1010 if ((pass->GetDimension() > 1) || (total->GetDimension() > 1)) {; 1011 Error(""Divide"", ""passed histograms are not one-dimensional"");; 1012 return;; 1013 }; 1014 ; 1015 // check whether histograms are filled with weights -> use number of effective; 1016 // entries; 1017 Bool_t bEffective = false;; 1018 // compare sum of weights with sum of squares of weights; 1019 // re-compute here to be sure to get the right values; 1020 Double_t psumw = 0;; 1021 Double_t p",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
Integrability,message,message,"etDimensionvirtual Int_t GetDimension() constDefinition TH1.h:283; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t bin) constReturn bin lower edge for 1D histogram.Definition TH1.cxx:9152; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetSumw2virtual TArrayD * GetSumw2()Definition TH1.h:313; TH1::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width for 1D histogram.Definition TH1.cxx:9163; TH1::GetSumOfWeightsvirtual Double_t GetSumOfWeights() constReturn the sum of weights excluding under/overflows.Definition TH1.cxx:7917; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TStyle::GetErrorXFloat_t GetErrorX() constDefinition TStyle.h:186; TVectorTTVectorT.Definition TVectorT.h:27; TVectorT::GetNrowsInt_t GetNrows() constDefinition TVectorT.h:73; TVectorT::GetLwbInt_t GetLwb() constDefinition TVectorT.h:71; bool; double; int; ROOT::Math::norm",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
Modifiability,adapt,adapted,";; 967 ; 968 if (f->Eval(x, y - eyL) < f->Eval(x, y + eyH)) {; 969 eyLNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 970 eyHNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 971 } else {; 972 eyHNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 973 eyLNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 974 }; 975 ; 976 // systematic errors and error on x doesn't change; 977 SetPointEY(i, 0, eyLNew, eyHNew);; 978 }; 979 ; 980 if (gPad); 981 gPad->Modified();; 982}; 983 ; 984////////////////////////////////////////////////////////////////////////////////; 985/// This function is only kept for backward compatibility.; 986/// You should rather use the Divide method.; 987/// It calls `Divide(pass,total,""cl=0.683 b(1,1) mode"")` which is equivalent to the; 988/// former BayesDivide method.; 989 ; 990void TGraphMultiErrors::BayesDivide(const TH1 *pass, const TH1 *total, Option_t *); 991{; 992 Divide(pass, total, ""cl=0.683 b(1,1) mode"");; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// This function was adapted from the TGraphAsymmErrors class.; 997/// See TGraphAsymmErrors::Divide for the documentation; 998///; 999/// Only the first error dimension is affected.; 1000 ; 1001void TGraphMultiErrors::Divide(const TH1 *pass, const TH1 *total, Option_t *opt); 1002{; 1003 // check pointers; 1004 if (!pass || !total) {; 1005 Error(""Divide"", ""one of the passed pointers is zero"");; 1006 return;; 1007 }; 1008 ; 1009 // check dimension of histograms; only 1-dimensional ones are accepted; 1010 if ((pass->GetDimension() > 1) || (total->GetDimension() > 1)) {; 1011 Error(""Divide"", ""passed histograms are not one-dimensional"");; 1012 return;; 1013 }; 1014 ; 1015 // check whether histograms are filled with weights -> use number of effective; 1016 // entries; 1017 Bool_t bEffective = false;; 1018 // compare sum of weights with sum of squares of weights; 1019 // re-compute here to be sure to get the right values; 1020 Double_t psumw = 0;; 1021 Double_t p",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
Performance,perform,performed,"to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Simon Spies 18/02/19; 3 ; 4/*************************************************************************; 5 * Copyright (C) 2018-2019, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TROOT.h""; 13#include ""TStyle.h""; 14#include ""TVirtualPad.h""; 15#include ""TEfficiency.h""; 16#include ""Riostream.h""; 17 ; 18#include ""TArrayD.h""; 19#include ""TVector.h""; 20#include ""TH1.h""; 21#include ""TF1.h""; 22#include ""TMath.h""; 23#include ""Math/QuantFuncMathCore.h""; 24 ; 25#include ""TGraphMultiErrors.h""; 26 ; 27ClassImp(TGraphMultiErrors); 28 ; 29/** \class TGraphMultiErrors; 30 \ingroup Graphs; 31TGraph with asymmetric error bars and multiple y error dimensions.; 32 ; 33The TGraphMultiErrors painting is performed thanks to the TGraphPainter; 34class. All details about the various painting options are given in this class.; 35 ; 36The picture below gives an example:; 37 ; 38Begin_Macro(source); 39{; 40 auto c1 = new TCanvas(""c1"", ""A Simple Graph with multiple y-errors"", 200, 10, 700, 500);; 41 c1->SetGrid();; 42 c1->GetFrame()->SetBorderSize(12);; 43 const Int_t np = 5;; 44 Double_t x[np] = {0, 1, 2, 3, 4};; 45 Double_t y[np] = {0, 2, 4, 1, 3};; 46 Double_t exl[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; 47 Double_t exh[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; 48 Double_t eylstat[np] = {1, 0.5, 1, 0.5, 1};; 49 Double_t eyhstat[np] = {0.5, 1, 0.5, 1, 2};; 50 Double_t eylsys[np] = {0.5, 0.4, 0.8, 0.3, 1.2};; 51 Double_t eyhsys[np] = {0.6, 0.7, 0.6, 0.4, 0.8};; 52 auto gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", np, x, y, exl, exh, eylstat, eyhstat);; 53 gme->AddYError(np, eylsys, eyhsys);; 54 gme->SetMarkerStyle(20);; 55 gme->SetLineColor(kRed);; 56 gme->GetAttLine(0)->SetLineColor(kRed)",MatchSource.WIKI,doc/master/TGraphMultiErrors_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html
Availability,error,error,". ROOT: hist/hist/inc/TGraphMultiErrors.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGraphMultiErrors.h. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Simon Spies 18/02/19; 3 ; 4/*************************************************************************; 5 * Copyright (C) 2018-2019, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TGraphMultiErrors; 13#define ROOT_TGraphMultiErrors; 14 ; 15//////////////////////////////////////////////////////////////////////////; 16// //; 17// TGraphMultiErrors //; 18// //; 19// a Graph with asymmetric error bars and multiple y errors //; 20// //; 21//////////////////////////////////////////////////////////////////////////; 22 ; 23#include ""TGraph.h""; 24#include <vector>; 25 ; 26class TArrayF;; 27class TArrayD;; 28 ; 29class TGraphMultiErrors : public TGraph {; 30 ; 31protected:; 32 Int_t fNYErrors; ///< The amount of different y-errors; 33 Int_t fSumErrorsMode; ///< How y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum =; 34 ///< Absolute Addition; 35 Double_t *fExL; ///<[fNpoints] array of X low errors; 36 Double_t *fExH; ///<[fNpoints] array of X high errors; 37 std::vector<TArrayD> fEyL; ///< Two dimensional array of Y low errors; 38 std::vector<TArrayD> fEyH; ///< Two dimensional array of Y high errors; 39 mutable Double_t *fEyLSum = nullptr; ///<! Array of summed Y low errors for fitting; 40 mutable Double_t *fEyHSum = nullptr; ///<! Array of summed Y high errors for fitting; 41 std::vector<TAttFill> fAttFill; ///< The AttFill attributes of the different errors; 42 std::vector<TAttLine> fAttLine; ///< The AttLine attributes of the different errors; 43 ; 44 Double_t **Allocate(Int_t size) ov",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
Deployability,release,release,"ultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH)Set error e ey values.Definition TGraphMultiErrors.cxx:1973; TGraphMultiErrors::SetSumErrorsModevirtual void SetSumErrorsMode(Int_t m)Set the sum errors mode and recalculate summed errors.Definition TGraphMultiErrors.cxx:2007; TGraphMultiErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphMultiErrors.cxx:990; TGraphMultiErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphMultiErrors.cxx:1708; TGraphMultiErrors::operator=TGraphMultiErrors & operator=(const TGraphMultiErrors &tgme)TGraphMultiErrors assignment operator.Definition TGraphMultiErrors.cxx:599; TGraphMultiErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphMultiErrors.cxx:748; TGraphMultiErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphMultiErrors.cxx:1729; TGraphMultiErrors::fSumErrorsModeInt_t fSumErrorsModeHow y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum = Absolute Addition.Definition TGraphMultiErrors.h:33; TGraphMultiErrors::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TGraphMultiErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphMultiErrors.h:142; TGraphMultiErrors::ESummationModesESummationModesDefinition TGraphMultiErrors.h:57; TGraphMultiErrors::kAbsSum@ kAbsSumCalculate the absolute sum of all errors.Definition TGraphMultiErrors.h:60; TGraphMultiErrors::kSquareSum@ kSquareSumCalculate the square sum of all errors.Definition T",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
Energy Efficiency,adapt,adapted,"ors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2=0., Double_t eyH2=0., Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1504; TGraphMultiErrors::Dividevoid Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1481; TGraphMultiErrors::TGraphMultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH)Set error e ey values.Definition TGraphMultiErrors.cxx:1973; TGraphMultiErrors::SetSumErrorsModevirtual void SetSumErro",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
Modifiability,adapt,adapted,"ors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2=0., Double_t eyH2=0., Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1504; TGraphMultiErrors::Dividevoid Divide(const TH1 *pass, const TH1 *total, Option_t *opt=""cp"")This function was adapted from the TGraphAsymmErrors class.Definition TGraphMultiErrors.cxx:1001; TGraphMultiErrors::fAttLinestd::vector< TAttLine > fAttLineThe AttLine attributes of the different errors.Definition TGraphMultiErrors.h:42; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t i) const overrideGet low error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1481; TGraphMultiErrors::TGraphMultiErrorsTGraphMultiErrors()TGraphMultiErrors default constructor.Definition TGraphMultiErrors.cxx:66; TGraphMultiErrors::SetEYvirtual void SetEY(Int_t e, Int_t np, const Double_t *eyL, const Double_t *eyH)Set error e ey values.Definition TGraphMultiErrors.cxx:1973; TGraphMultiErrors::SetSumErrorsModevirtual void SetSumErro",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
Performance,perform,perform,"yL, const Double_t *eyH)Set ey values for point i.Definition TGraphMultiErrors.cxx:1885; TGraphMultiErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exL)Set exL value for point i.Definition TGraphMultiErrors.cxx:1853; TGraphMultiErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH)Set eyH values for point i.Definition TGraphMultiErrors.cxx:1907; TGraphMultiErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphMultiErrors.cxx:1379; TGraphMultiErrors::fNYErrorsInt_t fNYErrorsThe amount of different y-errors.Definition TGraphMultiErrors.h:32; TGraphMultiErrors::fEyLstd::vector< TArrayD > fEyLTwo dimensional array of Y low errors.Definition TGraphMultiErrors.h:37; TGraphMultiErrors::GetErrorYDouble_t GetErrorY(Int_t i) const overrideGet error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1454; TGraphMultiErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphMultiErrors.cxx:933; TGraphMultiErrors::DoMergeBool_t DoMerge(const TGraph *tg) overrideProtected function to perform the merge operation of a graph with multiple asymmetric errors.Definition TGraphMultiErrors.cxx:838; TGraphMultiErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1530; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TVectorTTVectorT.Definition TVectorT.h:27; bool; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; mTMarker mDefinition textangle.C:8. histhistincTGraphMultiErrors.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphMultiErrors_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html
Availability,error,error,"tualPadEditor.h""; 38#include ""TVirtualX.h""; 39#include ""TRegexp.h""; 40#include ""strlcpy.h""; 41#include ""snprintf.h""; 42#include <memory>; 43 ; 44Int_t TGraphPainter::fgMaxPointsPerLine = 50;; 45 ; 46static Int_t gHighlightPoint = -1; // highlight point of graph; 47static TGraph *gHighlightGraph = nullptr; // pointer to graph with highlight point; 48static std::unique_ptr<TMarker> gHighlightMarker; // highlight marker; 49 ; 50ClassImp(TGraphPainter);; 51 ; 52 ; 53////////////////////////////////////////////////////////////////////////////////; 54 ; 55/*! \class TGraphPainter; 56 \ingroup Histpainter; 57 \brief The graph painter class. Implements all graphs' drawing's options.; 58 ; 59- [Introduction](\ref GrP0); 60- [Graphs' plotting options](\ref GrP1); 61- [Exclusion graphs](\ref GrP2); 62- [Graphs with error bars](\ref GrP3); 63 - [TGraphErrors](\ref GrP3a); 64 - [TGraphAsymmErrors](\ref GrP3b); 65 - [TGraphBentErrors](\ref GrP3c); 66 - [TGraphMultiErrors](\ref GrP3d); 67- [TGraphPolar options](\ref GrP4); 68- [Colors automatically picked in palette](\ref GrP5); 69- [Reverse graphs' axis](\ref GrP6); 70- [Graphs in logarithmic scale](\ref GrP7); 71- [Highlight mode for graph](\ref GrP8); 72 ; 73 ; 74\anchor GrP0; 75### Introduction; 76 ; 77Graphs are drawn via the painter `TGraphPainter` class. This class; 78implements techniques needed to display the various kind of; 79graphs i.e.: `TGraph`, `TGraphErrors`, `TGraphBentErrors` and `TGraphAsymmErrors`.; 80 ; 81To draw a graph `graph` it's enough to do:; 82 ; 83 graph->Draw(""AL"");; 84 ; 85The option `AL` in the `Draw()` method means:; 86 ; 871. The axis should be drawn (option `A`),; 882. The graph should be drawn as a simple line (option `L`).; 89 ; 90 By default a graph is drawn in the current pad in the current coordinate system.; 91To define a suitable coordinate system and draw the axis the option; 92`A` must be specified.; 93 ; 94`TGraphPainter` offers many options to paint the various kind of graphs.; 95 ; 96",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
Deployability,update,updated,"2 ; 73 ; 74\anchor GrP0; 75### Introduction; 76 ; 77Graphs are drawn via the painter `TGraphPainter` class. This class; 78implements techniques needed to display the various kind of; 79graphs i.e.: `TGraph`, `TGraphErrors`, `TGraphBentErrors` and `TGraphAsymmErrors`.; 80 ; 81To draw a graph `graph` it's enough to do:; 82 ; 83 graph->Draw(""AL"");; 84 ; 85The option `AL` in the `Draw()` method means:; 86 ; 871. The axis should be drawn (option `A`),; 882. The graph should be drawn as a simple line (option `L`).; 89 ; 90 By default a graph is drawn in the current pad in the current coordinate system.; 91To define a suitable coordinate system and draw the axis the option; 92`A` must be specified.; 93 ; 94`TGraphPainter` offers many options to paint the various kind of graphs.; 95 ; 96It is separated from the graph classes so that one can have graphs without the; 97graphics overhead, for example in a batch program.; 98 ; 99When a displayed graph is modified, there is no need to call `Draw()` again; the; 100image will be refreshed the next time the pad will be updated. A pad is updated; 101after one of these three actions:; 102 ; 1031. a carriage return on the ROOT command line,; 1042. a click inside the pad,; 1053. a call to `TPad::Update`.; 106 ; 107\anchor GrP1; 108### Graphs' plotting options; 109Graphs can be drawn with the following options:; 110 ; 111| Option | Description |; 112|----------|-------------------------------------------------------------------|; 113| ""A"" | Produce a new plot with Axis around the graph |; 114| ""I"" | Combine with option 'A' it draws invisible axis |; 115| ""L"" | A simple polyline is drawn |; 116| ""F"" | A fill area is drawn ('CF' draw a smoothed fill area) |; 117| ""C"" | A smooth Curve is drawn |; 118| ""*"" | A Star is plotted at each point |; 119| ""P"" | The current marker is plotted at each point |; 120| ""B"" | A Bar chart is drawn |; 121| ""1"" | When a graph is drawn as a bar chart, this option makes the bars start from the bottom of the pad",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
Energy Efficiency,power,power,"Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; exDouble_t ex[n]Definition legend1.C:17; c2return c2Definition legend2.C:14; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf...Definition TMath.cxx:637; TMath::IsInsideBool_t IsInside(T xp, T yp, Int_t np, T *x, T *y)Function which returns kTRUE if point xp,yp lies inside the polygon defined by the np points in array...Definition TMath.h:1233; TMath::ATanDouble_t ATan(Double_t)Returns the principal value of the arc tangent of x, expressed in radians.Definition TMath.h:640; TMath::PiOver2constexpr Double_t PiOver2()Definition TMath.h:51; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; arrowDefinition RArrowDS.hxx:17; lTLine lDefinition textangle.C:4; DrawMarkerm DrawMarker(0.1, 0.1). histhistpaintersrcTGraphPainter.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:35 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
Integrability,rout,routines,">DrawLine(pxp+4, pyp+4, pxp-4, pyp+4);; 964 gVirtualX->DrawLine(pxp-4, pyp+4, pxp-4, pyp-4);; 965 } else {; 966 if (px1old) gVirtualX->DrawLine(px1old, py1old, pxold, pyold);; 967 if (px2old) gVirtualX->DrawLine(pxold, pyold, px2old, py2old);; 968 gVirtualX->DrawLine(pxold-4, pyold-4, pxold+4, pyold-4);; 969 gVirtualX->DrawLine(pxold+4, pyold-4, pxold+4, pyold+4);; 970 gVirtualX->DrawLine(pxold+4, pyold+4, pxold-4, pyold+4);; 971 gVirtualX->DrawLine(pxold-4, pyold+4, pxold-4, pyold-4);; 972 pxold = px;; 973 pxold = TMath::Max(pxold, px1);; 974 pxold = TMath::Min(pxold, px2);; 975 pyold = py;; 976 pyold = TMath::Max(pyold, py2);; 977 pyold = TMath::Min(pyold, py1);; 978 if (px1old) gVirtualX->DrawLine(px1old, py1old, pxold, pyold);; 979 if (px2old) gVirtualX->DrawLine(pxold, pyold, px2old, py2old);; 980 gVirtualX->DrawLine(pxold-4, pyold-4, pxold+4, pyold-4);; 981 gVirtualX->DrawLine(pxold+4, pyold-4, pxold+4, pyold+4);; 982 gVirtualX->DrawLine(pxold+4, pyold+4, pxold-4, pyold+4);; 983 gVirtualX->DrawLine(pxold-4, pyold+4, pxold-4, pyold-4);; 984 }; 985 } else {; 986 xmin = gPad->GetUxmin();; 987 xmax = gPad->GetUxmax();; 988 ymin = gPad->GetUymin();; 989 ymax = gPad->GetUymax();; 990 dx = xmax-xmin;; 991 dy = ymax-ymin;; 992 dxr = dx/(1 - gPad->GetLeftMargin() - gPad->GetRightMargin());; 993 dyr = dy/(1 - gPad->GetBottomMargin() - gPad->GetTopMargin());; 994 ; 995 if (theGraph->GetHistogram()) {; 996 // Range() could change the size of the pad pixmap and therefore should; 997 // be called before the other paint routines; 998 gPad->Range(xmin - dxr*gPad->GetLeftMargin(),; 999 ymin - dyr*gPad->GetBottomMargin(),; 1000 xmax + dxr*gPad->GetRightMargin(),; 1001 ymax + dyr*gPad->GetTopMargin());; 1002 gPad->RangeAxis(xmin, ymin, xmax, ymax);; 1003 }; 1004 if (middle) {; 1005 dpx += px - pxold;; 1006 dpy += py - pyold;; 1007 pxold = px;; 1008 pyold = py;; 1009 for(i=0;i<theNpoints;i++) {; 1010 if (badcase) continue; //do not update if big zoom and points moved; 1011 if (!x.",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
Modifiability,variab,variables,"ht mode and user function</a>; 648(is fully equivalent as for histogram).; 649 ; 650NOTE all parameters of user function are taken from; 651 ; 652 void TCanvas::Highlighted(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y); 653 ; 654 - `pad` is pointer to pad with highlighted graph; 655 - `obj` is pointer to highlighted graph; 656 - `x` is highlighted x-th (i-th) point for graph; 657 - `y` not in use (only for 2D histogram); 658 ; 659For more complex demo please see for example `$ROOTSYS/tutorials/math/hlquantiles.C` file.; 660 ; 661*/; 662 ; 663 ; 664////////////////////////////////////////////////////////////////////////////////; 665/// Default constructor; 666 ; 667TGraphPainter::TGraphPainter(); 668{; 669}; 670 ; 671 ; 672////////////////////////////////////////////////////////////////////////////////; 673/// Destructor.; 674 ; 675TGraphPainter::~TGraphPainter(); 676{; 677}; 678 ; 679 ; 680////////////////////////////////////////////////////////////////////////////////; 681/// Compute the logarithm of variables `gxwork` and `gywork`; 682/// according to the value of Options and put the results; 683/// in the variables `gxworkl` and `gyworkl`.; 684///; 685/// npoints : Number of points in gxwork and in gywork.; 686///; 687/// - opt = 1 ComputeLogs is called from PaintGrapHist; 688/// - opt = 0 ComputeLogs is called from PaintGraph; 689 ; 690void TGraphPainter::ComputeLogs(Int_t npoints, Int_t opt); 691{; 692 if (gPad->GetLogx()) {; 693 for (Int_t i = 0; i < npoints; i++) {; 694 gxworkl[i] = (gxwork[i] > 0.) ? TMath::Log10(gxwork[i]) : gPad->GetX1();; 695 }; 696 } else {; 697 for (Int_t i = 0; i < npoints; i++); 698 gxworkl[i] = gxwork[i];; 699 }; 700 if (!opt && gPad->GetLogy()) {; 701 for (Int_t i = 0; i < npoints; i++) {; 702 gyworkl[i] = (gywork[i] > 0.) ? TMath::Log10(gywork[i]) : gPad->GetY1();; 703 }; 704 } else {; 705 for (Int_t i = 0; i < npoints; i++); 706 gyworkl[i] = gywork[i];; 707 }; 708}; 709 ; 710 ; 711//////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
Performance,load,load,"ormat() constDefinition TStyle.h:199; TStyle::GetStatFormatconst char * GetStatFormat() constDefinition TStyle.h:263; TStyle::GetNumberOfColorsInt_t GetNumberOfColors() constReturn number of colors in the color palette.Definition TStyle.cxx:1175; TStyle::GetOptFitInt_t GetOptFit() constDefinition TStyle.h:244; TStyle::GetStatFontStyle_t GetStatFont() constDefinition TStyle.h:260; TStyle::GetTitleFontSizeFloat_t GetTitleFontSize() constDefinition TStyle.h:274; TStyle::GetTitleAlignInt_t GetTitleAlign() constDefinition TStyle.h:270; TStyle::GetAxisColorColor_t GetAxisColor(Option_t *axis=""X"") constReturn the axis color number in the axis.Definition TStyle.cxx:1089; TStyle::GetTitleWFloat_t GetTitleW() constDefinition TStyle.h:282; TTextBase class for several text objects.Definition TText.h:22; TViewSee TView3D.Definition TView.h:25; TVirtualPadEditorAbstract base class used by ROOT graphics editor.Definition TVirtualPadEditor.h:27; TVirtualPadEditor::GetPadEditorstatic TVirtualPadEditor * GetPadEditor(Bool_t load=kTRUE)Returns the pad editor dialog. Static method.Definition TVirtualPadEditor.cxx:74; TVirtualPadEditor::Showvirtual void Show()Definition TVirtualPadEditor.h:49; TVirtualPad::TContextsmall helper class to store/restore gPad context in TPad methodsDefinition TVirtualPad.h:61; bool; double; int; boxvoid box(Int_t pat, Double_t x1, Double_t y1, Double_t x2, Double_t y2)Definition fillpatterns.C:1; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; exDouble_t ex[n]Definition legend1.C:17; c2return c2Definition legend2.C:14; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probab",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
Safety,risk,risky,"9 ; 1760 first = 1;; 1761 last = npoints;; 1762 nbins = last - first + 1;; 1763 ; 1764 // Draw the Axis with a fixed number of division: 510; 1765 ; 1766 Double_t baroffset = gStyle->GetBarOffset();; 1767 Double_t barwidth = gStyle->GetBarWidth();; 1768 Double_t rwxmin = gPad->GetUxmin();; 1769 Double_t rwxmax = gPad->GetUxmax();; 1770 Double_t rwymin = gPad->GetUymin();; 1771 Double_t rwymax = gPad->GetUymax();; 1772 Double_t uxmin = gPad->PadtoX(rwxmin);; 1773 Double_t uxmax = gPad->PadtoX(rwxmax);; 1774 Double_t rounding = (uxmax-uxmin)*1.e-5;; 1775 drawborder = gStyle->GetDrawBorder();; 1776 if (optionAxis) {; 1777 Int_t nx1, nx2, ndivx, ndivy, ndiv;; 1778 choptaxis[0] = 0;; 1779 Double_t rwmin = rwxmin;; 1780 Double_t rwmax = rwxmax;; 1781 ndivx = gStyle->GetNdivisions(""X"");; 1782 ndivy = gStyle->GetNdivisions(""Y"");; 1783 if (ndivx > 1000) {; 1784 nx2 = ndivx/100;; 1785 nx1 = TMath::Max(1, ndivx%100);; 1786 ndivx = 100*nx2 + Int_t(Double_t(nx1)*gPad->GetAbsWNDC());; 1787 }; 1788 ndiv =TMath::Abs(ndivx);; 1789 // coverity [Calling risky function]; 1790 if (ndivx < 0) strlcat(choptaxis, ""N"",10);; 1791 if (gPad->GetGridx()) {; 1792 // coverity [Calling risky function]; 1793 strlcat(choptaxis, ""W"",10);; 1794 }; 1795 if (gPad->GetLogx()) {; 1796 rwmin = TMath::Power(10,rwxmin);; 1797 rwmax = TMath::Power(10,rwxmax);; 1798 // coverity [Calling risky function]; 1799 strlcat(choptaxis, ""G"",10);; 1800 }; 1801 TGaxis axis;; 1802 axis.SetLineColor(gStyle->GetAxisColor(""X""));; 1803 axis.SetTextColor(gStyle->GetLabelColor(""X""));; 1804 axis.SetTextFont(gStyle->GetLabelFont(""X""));; 1805 axis.SetLabelSize(gStyle->GetLabelSize(""X""));; 1806 axis.SetLabelOffset(gStyle->GetLabelOffset(""X""));; 1807 axis.SetTickSize(gStyle->GetTickLength(""X""));; 1808 ; 1809 axis.PaintAxis(rwxmin,rwymin,rwxmax,rwymin,rwmin,rwmax,ndiv,choptaxis);; 1810 ; 1811 choptaxis[0] = 0;; 1812 rwmin = rwymin;; 1813 rwmax = rwymax;; 1814 if (ndivy < 0) {; 1815 nx2 = ndivy/100;; 1816 nx1 = TMath::Max(1, ndivy%100);",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
Testability,log,logarithmic,"tualPadEditor.h""; 38#include ""TVirtualX.h""; 39#include ""TRegexp.h""; 40#include ""strlcpy.h""; 41#include ""snprintf.h""; 42#include <memory>; 43 ; 44Int_t TGraphPainter::fgMaxPointsPerLine = 50;; 45 ; 46static Int_t gHighlightPoint = -1; // highlight point of graph; 47static TGraph *gHighlightGraph = nullptr; // pointer to graph with highlight point; 48static std::unique_ptr<TMarker> gHighlightMarker; // highlight marker; 49 ; 50ClassImp(TGraphPainter);; 51 ; 52 ; 53////////////////////////////////////////////////////////////////////////////////; 54 ; 55/*! \class TGraphPainter; 56 \ingroup Histpainter; 57 \brief The graph painter class. Implements all graphs' drawing's options.; 58 ; 59- [Introduction](\ref GrP0); 60- [Graphs' plotting options](\ref GrP1); 61- [Exclusion graphs](\ref GrP2); 62- [Graphs with error bars](\ref GrP3); 63 - [TGraphErrors](\ref GrP3a); 64 - [TGraphAsymmErrors](\ref GrP3b); 65 - [TGraphBentErrors](\ref GrP3c); 66 - [TGraphMultiErrors](\ref GrP3d); 67- [TGraphPolar options](\ref GrP4); 68- [Colors automatically picked in palette](\ref GrP5); 69- [Reverse graphs' axis](\ref GrP6); 70- [Graphs in logarithmic scale](\ref GrP7); 71- [Highlight mode for graph](\ref GrP8); 72 ; 73 ; 74\anchor GrP0; 75### Introduction; 76 ; 77Graphs are drawn via the painter `TGraphPainter` class. This class; 78implements techniques needed to display the various kind of; 79graphs i.e.: `TGraph`, `TGraphErrors`, `TGraphBentErrors` and `TGraphAsymmErrors`.; 80 ; 81To draw a graph `graph` it's enough to do:; 82 ; 83 graph->Draw(""AL"");; 84 ; 85The option `AL` in the `Draw()` method means:; 86 ; 871. The axis should be drawn (option `A`),; 882. The graph should be drawn as a simple line (option `L`).; 89 ; 90 By default a graph is drawn in the current pad in the current coordinate system.; 91To define a suitable coordinate system and draw the axis the option; 92`A` must be specified.; 93 ; 94`TGraphPainter` offers many options to paint the various kind of graphs.; 95 ; 96",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
Usability,simpl,simple,"[Introduction](\ref GrP0); 60- [Graphs' plotting options](\ref GrP1); 61- [Exclusion graphs](\ref GrP2); 62- [Graphs with error bars](\ref GrP3); 63 - [TGraphErrors](\ref GrP3a); 64 - [TGraphAsymmErrors](\ref GrP3b); 65 - [TGraphBentErrors](\ref GrP3c); 66 - [TGraphMultiErrors](\ref GrP3d); 67- [TGraphPolar options](\ref GrP4); 68- [Colors automatically picked in palette](\ref GrP5); 69- [Reverse graphs' axis](\ref GrP6); 70- [Graphs in logarithmic scale](\ref GrP7); 71- [Highlight mode for graph](\ref GrP8); 72 ; 73 ; 74\anchor GrP0; 75### Introduction; 76 ; 77Graphs are drawn via the painter `TGraphPainter` class. This class; 78implements techniques needed to display the various kind of; 79graphs i.e.: `TGraph`, `TGraphErrors`, `TGraphBentErrors` and `TGraphAsymmErrors`.; 80 ; 81To draw a graph `graph` it's enough to do:; 82 ; 83 graph->Draw(""AL"");; 84 ; 85The option `AL` in the `Draw()` method means:; 86 ; 871. The axis should be drawn (option `A`),; 882. The graph should be drawn as a simple line (option `L`).; 89 ; 90 By default a graph is drawn in the current pad in the current coordinate system.; 91To define a suitable coordinate system and draw the axis the option; 92`A` must be specified.; 93 ; 94`TGraphPainter` offers many options to paint the various kind of graphs.; 95 ; 96It is separated from the graph classes so that one can have graphs without the; 97graphics overhead, for example in a batch program.; 98 ; 99When a displayed graph is modified, there is no need to call `Draw()` again; the; 100image will be refreshed the next time the pad will be updated. A pad is updated; 101after one of these three actions:; 102 ; 1031. a carriage return on the ROOT command line,; 1042. a click inside the pad,; 1053. a call to `TPad::Update`.; 106 ; 107\anchor GrP1; 108### Graphs' plotting options; 109Graphs can be drawn with the following options:; 110 ; 111| Option | Description |; 112|----------|-------------------------------------------------------------------|; 1",MatchSource.WIKI,doc/master/TGraphPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html
Availability,error,errors,"ter::gxworkstd::vector< Double_t > gxworkDefinition TGraphPainter.h:69; TGraphPainter::gyworkstd::vector< Double_t > gyworkDefinition TGraphPainter.h:69; TGraphPainter::PaintScattervoid PaintScatter(TScatter *theScatter, Option_t *option) overridePaint a scatter plot.Definition TGraphPainter.cxx:4392; TGraphPainter::Smoothvoid Smooth(TGraph *theGraph, Int_t npoints, Double_t *x, Double_t *y, Int_t drawtype)Smooth a curve given by N points.Definition TGraphPainter.cxx:4938; TGraphPainter::gyworklstd::vector< Double_t > gyworklInternal buffers for coordinates. Used for graphs painting.Definition TGraphPainter.h:69; TGraphPainter::SetHighlightvoid SetHighlight(TGraph *theGraph) overrideSet highlight (enable/disable) mode for theGraph.Definition TGraphPainter.cxx:1120; TGraphPainter::GetHighlightPointvirtual Int_t GetHighlightPoint(TGraph *theGraph) constReturn the highlighted point for theGraph.Definition TGraphPainter.cxx:1110; TGraphPainter::PaintGraphSimplevoid PaintGraphSimple(TGraph *theGraph, Option_t *option)Paint a simple graph, without errors bars.Definition TGraphPainter.cxx:4584; TGraphPainter::PaintGraphQQvoid PaintGraphQQ(TGraph *theGraph, Option_t *option)Paint this graphQQ. No options for the time being.Definition TGraphPainter.cxx:4084; TGraphPainter::~TGraphPainter~TGraphPainter() overrideDestructor.Definition TGraphPainter.cxx:675; TGraphPainter::SetMaxPointsPerLinestatic void SetMaxPointsPerLine(Int_t maxp=50)Static function to set fgMaxPointsPerLine for graph painting.Definition TGraphPainter.cxx:5407; TGraphPainter::PaintGraphBentErrorsvoid PaintGraphBentErrors(TGraph *theGraph, Option_t *option)Paint this TGraphBentErrors with its current attributes.Definition TGraphPainter.cxx:3182; TGraphPainter::TGraphPainterTGraphPainter()Default constructor.Definition TGraphPainter.cxx:667; TGraphPainter::PaintHelpervoid PaintHelper(TGraph *theGraph, Option_t *option) overridePaint a any kind of TGraph.Definition TGraphPainter.cxx:1211; TGraphA TGraph is an o",MatchSource.WIKI,doc/master/TGraphPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8h_source.html
Integrability,interface,interface,"r coordinates. Used for graphs painting.Definition TGraphPainter.h:69; TGraphPainter::SetHighlightvoid SetHighlight(TGraph *theGraph) overrideSet highlight (enable/disable) mode for theGraph.Definition TGraphPainter.cxx:1120; TGraphPainter::GetHighlightPointvirtual Int_t GetHighlightPoint(TGraph *theGraph) constReturn the highlighted point for theGraph.Definition TGraphPainter.cxx:1110; TGraphPainter::PaintGraphSimplevoid PaintGraphSimple(TGraph *theGraph, Option_t *option)Paint a simple graph, without errors bars.Definition TGraphPainter.cxx:4584; TGraphPainter::PaintGraphQQvoid PaintGraphQQ(TGraph *theGraph, Option_t *option)Paint this graphQQ. No options for the time being.Definition TGraphPainter.cxx:4084; TGraphPainter::~TGraphPainter~TGraphPainter() overrideDestructor.Definition TGraphPainter.cxx:675; TGraphPainter::SetMaxPointsPerLinestatic void SetMaxPointsPerLine(Int_t maxp=50)Static function to set fgMaxPointsPerLine for graph painting.Definition TGraphPainter.cxx:5407; TGraphPainter::PaintGraphBentErrorsvoid PaintGraphBentErrors(TGraph *theGraph, Option_t *option)Paint this TGraphBentErrors with its current attributes.Definition TGraphPainter.cxx:3182; TGraphPainter::TGraphPainterTGraphPainter()Default constructor.Definition TGraphPainter.cxx:667; TGraphPainter::PaintHelpervoid PaintHelper(TGraph *theGraph, Option_t *option) overridePaint a any kind of TGraph.Definition TGraphPainter.cxx:1211; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TScatterA TScatter is able to draw four variables scatter plot on a single plot.Definition TScatter.h:32; TVirtualGraphPainterAbstract interface to a histogram painter.Definition TVirtualGraphPainter.h:28; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16. histhistpainterincTGraphPainter.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:35 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8h_source.html
Modifiability,variab,variables,"n TGraphPainter.cxx:4820; TGraphPainter::PaintPolyLineHatchesvoid PaintPolyLineHatches(TGraph *theGraph, Int_t n, const Double_t *x, const Double_t *y)Paint a polyline with hatches on one side showing an exclusion zone.Definition TGraphPainter.cxx:4620; TGraphPainter::DrawPanelHelpervoid DrawPanelHelper(TGraph *theGraph) overrideDisplay a panel with all histogram drawing options.Definition TGraphPainter.cxx:796; TGraphPainter::GetObjectInfoHelperchar * GetObjectInfoHelper(TGraph *theGraph, Int_t px, Int_t py) const overrideDefinition TGraphPainter.cxx:1101; TGraphPainter::ExecuteEventHelpervoid ExecuteEventHelper(TGraph *theGraph, Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TGraphPainter.cxx:821; TGraphPainter::HighlightPointvirtual void HighlightPoint(TGraph *theGraph, Int_t hpoint, Int_t distance)Check on highlight point.Definition TGraphPainter.cxx:1136; TGraphPainter::ComputeLogsvoid ComputeLogs(Int_t npoints, Int_t opt)Compute the logarithm of variables gxwork and gywork according to the value of Options and put the re...Definition TGraphPainter.cxx:690; TGraphPainter::gxworklstd::vector< Double_t > gxworklDefinition TGraphPainter.h:69; TGraphPainter::DistancetoPrimitiveHelperInt_t DistancetoPrimitiveHelper(TGraph *theGraph, Int_t px, Int_t py) overrideCompute distance from point px,py to a graph.Definition TGraphPainter.cxx:717; TGraphPainter::gxworkstd::vector< Double_t > gxworkDefinition TGraphPainter.h:69; TGraphPainter::gyworkstd::vector< Double_t > gyworkDefinition TGraphPainter.h:69; TGraphPainter::PaintScattervoid PaintScatter(TScatter *theScatter, Option_t *option) overridePaint a scatter plot.Definition TGraphPainter.cxx:4392; TGraphPainter::Smoothvoid Smooth(TGraph *theGraph, Int_t npoints, Double_t *x, Double_t *y, Int_t drawtype)Smooth a curve given by N points.Definition TGraphPainter.cxx:4938; TGraphPainter::gyworklstd::vector< Double_t > gyworklInternal buffers for coordinates. Used for graphs pa",MatchSource.WIKI,doc/master/TGraphPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8h_source.html
Testability,log,logarithm,"n TGraphPainter.cxx:4820; TGraphPainter::PaintPolyLineHatchesvoid PaintPolyLineHatches(TGraph *theGraph, Int_t n, const Double_t *x, const Double_t *y)Paint a polyline with hatches on one side showing an exclusion zone.Definition TGraphPainter.cxx:4620; TGraphPainter::DrawPanelHelpervoid DrawPanelHelper(TGraph *theGraph) overrideDisplay a panel with all histogram drawing options.Definition TGraphPainter.cxx:796; TGraphPainter::GetObjectInfoHelperchar * GetObjectInfoHelper(TGraph *theGraph, Int_t px, Int_t py) const overrideDefinition TGraphPainter.cxx:1101; TGraphPainter::ExecuteEventHelpervoid ExecuteEventHelper(TGraph *theGraph, Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TGraphPainter.cxx:821; TGraphPainter::HighlightPointvirtual void HighlightPoint(TGraph *theGraph, Int_t hpoint, Int_t distance)Check on highlight point.Definition TGraphPainter.cxx:1136; TGraphPainter::ComputeLogsvoid ComputeLogs(Int_t npoints, Int_t opt)Compute the logarithm of variables gxwork and gywork according to the value of Options and put the re...Definition TGraphPainter.cxx:690; TGraphPainter::gxworklstd::vector< Double_t > gxworklDefinition TGraphPainter.h:69; TGraphPainter::DistancetoPrimitiveHelperInt_t DistancetoPrimitiveHelper(TGraph *theGraph, Int_t px, Int_t py) overrideCompute distance from point px,py to a graph.Definition TGraphPainter.cxx:717; TGraphPainter::gxworkstd::vector< Double_t > gxworkDefinition TGraphPainter.h:69; TGraphPainter::gyworkstd::vector< Double_t > gyworkDefinition TGraphPainter.h:69; TGraphPainter::PaintScattervoid PaintScatter(TScatter *theScatter, Option_t *option) overridePaint a scatter plot.Definition TGraphPainter.cxx:4392; TGraphPainter::Smoothvoid Smooth(TGraph *theGraph, Int_t npoints, Double_t *x, Double_t *y, Int_t drawtype)Smooth a curve given by N points.Definition TGraphPainter.cxx:4938; TGraphPainter::gyworklstd::vector< Double_t > gyworklInternal buffers for coordinates. Used for graphs pa",MatchSource.WIKI,doc/master/TGraphPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8h_source.html
Usability,simpl,simple,"ter::gxworkstd::vector< Double_t > gxworkDefinition TGraphPainter.h:69; TGraphPainter::gyworkstd::vector< Double_t > gyworkDefinition TGraphPainter.h:69; TGraphPainter::PaintScattervoid PaintScatter(TScatter *theScatter, Option_t *option) overridePaint a scatter plot.Definition TGraphPainter.cxx:4392; TGraphPainter::Smoothvoid Smooth(TGraph *theGraph, Int_t npoints, Double_t *x, Double_t *y, Int_t drawtype)Smooth a curve given by N points.Definition TGraphPainter.cxx:4938; TGraphPainter::gyworklstd::vector< Double_t > gyworklInternal buffers for coordinates. Used for graphs painting.Definition TGraphPainter.h:69; TGraphPainter::SetHighlightvoid SetHighlight(TGraph *theGraph) overrideSet highlight (enable/disable) mode for theGraph.Definition TGraphPainter.cxx:1120; TGraphPainter::GetHighlightPointvirtual Int_t GetHighlightPoint(TGraph *theGraph) constReturn the highlighted point for theGraph.Definition TGraphPainter.cxx:1110; TGraphPainter::PaintGraphSimplevoid PaintGraphSimple(TGraph *theGraph, Option_t *option)Paint a simple graph, without errors bars.Definition TGraphPainter.cxx:4584; TGraphPainter::PaintGraphQQvoid PaintGraphQQ(TGraph *theGraph, Option_t *option)Paint this graphQQ. No options for the time being.Definition TGraphPainter.cxx:4084; TGraphPainter::~TGraphPainter~TGraphPainter() overrideDestructor.Definition TGraphPainter.cxx:675; TGraphPainter::SetMaxPointsPerLinestatic void SetMaxPointsPerLine(Int_t maxp=50)Static function to set fgMaxPointsPerLine for graph painting.Definition TGraphPainter.cxx:5407; TGraphPainter::PaintGraphBentErrorsvoid PaintGraphBentErrors(TGraph *theGraph, Option_t *option)Paint this TGraphBentErrors with its current attributes.Definition TGraphPainter.cxx:3182; TGraphPainter::TGraphPainterTGraphPainter()Default constructor.Definition TGraphPainter.cxx:667; TGraphPainter::PaintHelpervoid PaintHelper(TGraph *theGraph, Option_t *option) overridePaint a any kind of TGraph.Definition TGraphPainter.cxx:1211; TGraphA TGraph is an o",MatchSource.WIKI,doc/master/TGraphPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPainter_8h_source.html
Availability,down,down,"4, p5, p6, p7, p8;; 198 Double_t px2, py2;; 199 p2 = p3 = p4 = p5 = p6 = p7 = p8 = kFALSE;; 200 if (!gPad->IsEditable()) return;; 201 switch (event) {; 202 case kMouseMotion:; 203 px1 = gPad->XtoAbsPixel(TMath::Cos(GetAngle()));; 204 py1 = gPad->YtoAbsPixel(TMath::Sin(GetAngle()));; 205 d1 = TMath::Abs(px1 - px) + TMath::Abs(py1-py); //simply take sum of pixels differences; 206 p1 = kFALSE;; 207 px2 = gPad->XtoAbsPixel(-1);; 208 py2 = gPad->YtoAbsPixel(1);; 209 d2 = (Int_t)(TMath::Abs(px2 - px) + TMath::Abs(py2 - py)) ;; 210 px3 = gPad->XtoAbsPixel(-1);; 211 py3 = gPad->YtoAbsPixel(-1);; 212 d3 = TMath::Abs(px3 - px) + TMath::Abs(py3 - py) ; //simply take sum of pixels differences; 213 // check if point is close to the radial axis; 214 if (d1 < kMaxDiff) {; 215 gPad->SetCursor(kMove);; 216 p1 = kTRUE;; 217 }; 218 // check if point is close to the left high axis; 219 if ( d2 < kMaxDiff) {; 220 gPad->SetCursor(kHand);; 221 p7 = kTRUE;; 222 }; 223 // check if point is close to the left down axis; 224 if ( d3 < kMaxDiff) {; 225 gPad->SetCursor(kHand);; 226 p8 = kTRUE;; 227 }; 228 // check if point is close to a main circle; 229 if (!p1 && !p7 ) {; 230 p6 = kTRUE;; 231 gPad->SetCursor(kHand);; 232 }; 233 break;; 234 ; 235 case kButton1Down:; 236 // Record initial coordinates; 237 //px4 = px;; 238 //py4 = py;; 239 ; 240 case kButton1Motion:; 241 if (p1) {; 242 px2 = gPad->AbsPixeltoX(px);; 243 py2 = gPad->AbsPixeltoY(py);; 244 if ( px2 < 0 && py2 < 0) {p2 = kTRUE;};; 245 if ( px2 < 0 && py2 > 0 ) {p3 = kTRUE;};; 246 if ( px2 > 0 && py2 > 0 ) {p4 = kTRUE;};; 247 if ( px2 > 0 && py2 < 0 ) {p5 = kTRUE;};; 248 px2 = TMath::ACos(TMath::Abs(px2));; 249 py2 = TMath::ASin(TMath::Abs(py2));; 250 if (p2) {; 251 fAxisAngle = TMath::Pi()+(px2+py2)/2;; 252 p2 = kFALSE;; 253 };; 254 if (p3) {; 255 fAxisAngle = TMath::Pi()-(px2+py2)/2;; 256 p3 = kFALSE;; 257 };; 258 if (p4) {; 259 fAxisAngle = (px2+py2)/2;; 260 p4 = kFALSE;; 261 };; 262 if (p5) {; 263 fAxisAngle = -(px2+py2)/2;; 264 p5 =",MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
Energy Efficiency,power,power,"; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TText::PaintTextvirtual void PaintText(Double_t x, Double_t y, const char *text)Draw this text with new coordinates.Definition TText.cxx:752; bool; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; TMath::ACosDouble_t ACos(Double_t)Returns the principal value of the arc cosine of x, expressed in radians.Definition TMath.h:632; TMath::ASinDouble_t ASin(Double_t)Returns the principal value of the arc sine of x, expressed in radians.Definition TMath.h:624; TMath::PiOver2constexpr Double_t PiOver2()Definition TMath.h:51; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::TanDouble_t Tan(Double_t)Returns the tangent of an angle of x radians.Definition TMath.h:600; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123. graf2dgrafsrcTGraphPolargram.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:18 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
Performance,optimiz,optimized,"rLabel());; 658 axis.SetLabelFont(GetRadialLabelFont());; 659 axis.SetLabelOffset(GetRadialOffset());; 660 axis.PaintAxis(0, 0, TMath::Cos(GetAngle()), TMath::Sin(GetAngle()),; 661 umin, umax, ndiv, chopt, 0., kFALSE);; 662 }; 663 ; 664 // Paint Circles.; 665 // First paint main circle.; 666 PaintCircle(0.,0.,1,0.,360,0);; 667 // Optimised case.; 668 if (fNdivRad>0 ) {; 669 Double_t frwrmini = 0., frwrmaxi = 0., binWidth2 =0;; 670 THLimitsFinder::Optimize(frwrmin,frwrmin+binWidth,ndivMinor,frwrmini,; 671 frwrmaxi, ndivminor,binWidth2,"""");; 672 Double_t dist2 = dist/(ndivminor);; 673 // Paint major circles.; 674 for (i=1; i<=ndivmajor+2; i++) {; 675 TAttLine::SetLineStyle(1);; 676 TAttLine::Modify();; 677 PaintCircle(0.,0.,rmajmin,0.,360,0);; 678 ; 679 //Paint minor circles.; 680 TAttLine::SetLineStyle(2);; 681 TAttLine::Modify();; 682 for (j=1; j<ndivminor+1; j++) {; 683 if (rmajmin+j*dist2<=1) PaintCircle(0.,0.,rmajmin+j*dist2,0.,360,0);; 684 }; 685 rmajmin = (frwrmin-fRwrmin)/(fRwrmax-fRwrmin)+(i-1)*dist;; 686 }; 687 // Non-optimized case.; 688 } else {; 689 ; 690 // Paint major circles.; 691 for (i=1; i<=ndivMajor; i++) {; 692 TAttLine::SetLineStyle(1);; 693 TAttLine::Modify();; 694 Double_t rmaj = i*1./ndivMajor;; 695 PaintCircle(0.,0.,rmaj,0.,360,0);; 696 ; 697 // Paint minor circles.; 698 for (j=1; j<ndivMinor; j++) {; 699 TAttLine::SetLineStyle(2);; 700 TAttLine::Modify();; 701 PaintCircle(0.,0.,rmaj- j*1./(ndivMajor*ndivMinor),0.,360,0);; 702 }; 703 }; 704 }; 705 } else {; 706 // Draw Log scale on radial axis if option activated.; 707 Int_t big = (Int_t)fRwrmax;; 708 Int_t test= 0;; 709 while (big >= 10) {; 710 big = big/10;; 711 test++;; 712 }; 713 for (i=1; i<=test; i++) {; 714 TAttLine::SetLineStyle(1);; 715 TAttLine::Modify();; 716 Double_t ecart;; 717 ecart = ((double) i)/ ((double) test);; 718 PaintCircle(0.,0.,ecart,0,360,0);; 719 TAttLine::SetLineStyle(GetLineStyle());; 720 TAttLine::Modify();; 721 Double_t a=0;; 722 Double_t b,c,d;; 723 b = TMath::Lo",MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
Testability,test,test,"polarSize());; 507 }; 508 if (theta == 0 || theta ==TMath::Pi()) {; 509 gPad->PaintLine(1-GetTickpolarSize(),0,1+GetTickpolarSize(),0);; 510 gPad->PaintLine(-1+GetTickpolarSize(),0,-1-GetTickpolarSize(),0);; 511 }; 512 }; 513 TAttLine::SetLineStyle(1);; 514 TAttLine::Modify();; 515 gPad->PaintLine(0.,0.,costheta,sintheta);; 516 // Add minor lines w/o text.; 517 Int_t oldLineStyle = GetLineStyle();; 518 TAttLine::SetLineStyle(2); //Minor lines always in this style.; 519 TAttLine::Modify(); //Changes line attributes apart from style.; 520 for (j=1; j<ndivMinor; j++) {; 521 Double_t thetamin = theta+j*2*TMath::Pi()/(ndivMajor*ndivMinor);; 522 gPad->PaintLine(0.,0.,TMath::Cos(thetamin),TMath::Sin(thetamin));; 523 }; 524 TAttLine::SetLineStyle(oldLineStyle);; 525 TAttLine::Modify();; 526 }; 527 } else {; 528 Int_t big = (Int_t)fRwtmax;; 529 Int_t test= 1;; 530 while (big >= 10) {; 531 big = big/10;; 532 test++;; 533 }; 534 for (i=1; i<=test; i++) {; 535 Double_t txtval = pow((double)10,(double)(i-1));; 536 Double_t theta = (i-1)*2*TMath::Pi()/(double)(test);; 537 Double_t costheta = TMath::Cos(theta);; 538 Double_t sintheta = TMath::Sin(theta);; 539 Double_t tantheta = TMath::Tan(theta);; 540 Double_t costhetas = (1+fPolarOffset)*costheta;; 541 Double_t sinthetas = (1+fPolarOffset)*sintheta;; 542 Double_t corr = 0.01;; 543 ; 544 TLatex textangular;; 545 textangular.SetTextColor(GetPolarColorLabel());; 546 textangular.SetTextFont(GetPolarLabelFont());; 547 ; 548 TString form = "" "";; 549 TGaxis axis;; 550 ; 551 if (TestBit(TGraphPolargram::kLabelOrtho)) {; 552 if(!fPolarLabels && optionLabels){; 553 // Polar numbers are aligned with their axis.; 554 form.Form(""%5.3g"",txtval);; 555 axis.LabelsLimits(form.Data(),first,last);; 556 TString s = form;; 557 if (first != 0) s.Remove(0, first);; 558 textangular.SetTextAlign(FindAlign(theta));; 559 textangular.PaintLatex(costhetas,; 560 sinthetas, FindTextAngle(theta), GetPolarLabelSize(), s);; 561 }; 562 else if (fPolarLabels){; 56",MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
Usability,simpl,simply,,MatchSource.WIKI,doc/master/TGraphPolargram_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html
Availability,error,error,". ROOT: graf2d/graf/src/TGraphPolar.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGraphPolar.cxx. Go to the documentation of this file. 1// @(#)root/graf:$Id$; 2// Author: Sebastian Boser, Mathieu Demaret 02/02/06; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TGraphPolar; 13\ingroup BasicGraphics; 14 ; 15To draw a polar graph.; 16 ; 17TGraphPolar creates a polar graph (including error bars). A TGraphPolar is; 18a TGraphErrors represented in polar coordinates.; 19It uses the class TGraphPolargram to draw the polar axis.; 20 ; 21Example:; 22 ; 23Begin_Macro(source); 24{; 25 TCanvas * CPol = new TCanvas(""CPol"",""TGraphPolar Example"",500,500);; 26 ; 27 Double_t theta[8];; 28 Double_t radius[8];; 29 Double_t etheta[8];; 30 Double_t eradius[8];; 31 ; 32 for (int i=0; i<8; i++) {; 33 theta[i] = (i+1)*(TMath::Pi()/4.);; 34 radius[i] = (i+1)*0.05;; 35 etheta[i] = TMath::Pi()/8.;; 36 eradius[i] = 0.05;; 37 }; 38 ; 39 TGraphPolar * grP1 = new TGraphPolar(8, theta, radius, etheta, eradius);; 40 grP1->SetTitle(""TGraphPolar Example"");; 41 ; 42 grP1->SetMarkerStyle(20);; 43 grP1->SetMarkerSize(2.);; 44 grP1->SetMarkerColor(4);; 45 grP1->SetLineColor(2);; 46 grP1->SetLineWidth(3);; 47 grP1->Draw(""PE"");; 48 ; 49 // Update, otherwise GetPolargram returns 0; 50 CPol->Update();; 51 grP1->GetPolargram()->SetToRadian();; 52 ; 53 return CPol;; 54}; 55End_Macro; 56*/; 57 ; 58#include ""TGraphPolar.h""; 59#include ""TGraphPolargram.h""; 60 ; 61ClassImp(TGraphPolar);; 62 ; 63////////////////////////////////////////////////////////////////////////////////; 64/// TGraphPolar default constructor.; 65 ; 66T",MatchSource.WIKI,doc/master/TGraphPolar_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolar_8cxx_source.html
Availability,error,error,"e_t minimum = 0) override {SetMinRadial(minimum);}; 47 void SetMaxPolar(Double_t maximum = 6.28318530717958623); //*MENU*; 48 void SetMinPolar(Double_t minimum = 0); //*MENU*; 49 void SetOptionAxis(Bool_t opt) {fOptionAxis = opt;}; 50 void SetPolargram(TGraphPolargram *p) {fPolargram = p;}; 51 Double_t *GetXpol();; 52 Double_t *GetYpol();; 53 ; 54 ClassDefOverride(TGraphPolar,1); // Polar graph; 55};; 56 ; 57#endif; Double_tdouble Double_tDefinition RtypesCore.h:59; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TGraphErrors.h; TGraphPolargram.h; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphPolarTo draw a polar graph.Definition TGraphPolar.h:23; TGraphPolar::SetMaximumvoid SetMaximum(Double_t maximum=1) overrideSet the maximum of the graph.Definition TGraphPolar.h:45; TGraphPolar::SetMinRadialvoid SetMinRadial(Double_t minimum=0)Set minimum radial in the center of the circle.Definition TGraphPolar.cxx:162; TGraphPolar::fOptionAxisBool_t fOptionAxisForce drawing of new coord system.Definition TGraphPolar.h:26; TGraphPolar::fXpolDouble_t * fXpol[fNpoints] points in polar coordinatesDefinition TGraphPolar.h:30; TGraphPolar::SetMaxPolarvoid SetMaxPolar(Double_t maximum=6.28318530717958623)Set maximum Polar.Definition TGraphPolar.cxx:137; TGraphPolar::GetYpolDouble_t * GetYpol()Return points in polar coordinates.Definition TGraphPolar.cxx:128; TGraphPolar::fPolargramTGraphPolargram * fPolargramThe polar coordinates system.Definition TGraphPolar.h:29; TGraphPolar::GetPolargramTGraphPolargram * GetPolargram()Defini",MatchSource.WIKI,doc/master/TGraphPolar_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphPolar_8h_source.html
Availability,robust,robust,"ed. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TGraphQQ.h""; 13#include ""TAxis.h""; 14#include ""TF1.h""; 15#include ""TMath.h""; 16 ; 17ClassImp(TGraphQQ);; 18 ; 19/** \class TGraphQQ; 20\ingroup BasicGraphics; 21 ; 22This class allows to draw quantile-quantile plots; 23 ; 24Plots can be drawn for 2 datasets or for a dataset and a theoretical; 25distribution function; 26 ; 27## 2 datasets:; 28 Quantile-quantile plots are used to determine whether 2 samples come from; 29 the same distribution.; 30 A qq-plot draws the quantiles of one dataset against the quantile of the; 31 the other. The quantiles of the dataset with fewer entries are on Y axis,; 32 with more entries - on X axis.; 33 A straight line, going through 0.25 and 0.75 quantiles is also plotted; 34 for reference. It represents a robust linear fit, not sensitive to the; 35 extremes of the datasets.; 36 If the datasets come from the same distribution, points of the plot should; 37 fall approximately on the 45 degrees line. If they have the same; 38 distribution function, but location or scale different parameters,; 39 they should still fall on the straight line, but not the 45 degrees one.; 40 The greater their departure from the straight line, the more evidence there; 41 is, that the datasets come from different distributions.; 42 The advantage of qq-plot is that it not only shows that the underlying; 43 distributions are different, but, unlike the analytical methods, it also; 44 gives information on the nature of this difference: heavier tails,; 45 different location/scale, different shape, etc.; 46 ; 47 Some examples of qqplots of 2 datasets:; 48 ; 49\image html graf_graphqq1.png; 50 ; 51## 1 dataset:; 52 Quantile-quantile plots are used to determine if the dataset comes from the; 53 specified theoretical distribution, such as normal.",MatchSource.WIKI,doc/master/TGraphQQ_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraphQQ_8cxx_source.html
Availability,error,error,"!format_.IsDigit()) {; 483 Error(""TGraph"", ""Incorrect input format! Allowed formats are {\""%%lg\"",\""%%*lg\"" or \""%%*s\""}"");; 484 return;; 485 }; 486 Int_t ntokens = format_.Length() ;; 487 if (ntokens < 2) {; 488 Error(""TGraph"", ""Incorrect input format! Only %d tag(s) in format whereas 2 \""%%lg\"" tags are expected!"", ntokens);; 489 return;; 490 }; 491 Int_t ntokensToBeSaved = 0 ;; 492 Bool_t * isTokenToBeSaved = new Bool_t [ntokens] ;; 493 for (Int_t idx = 0; idx < ntokens; idx++) {; 494 isTokenToBeSaved[idx] = TString::Format(""%c"", format_[idx]).Atoi() ; //atoi(&format_[idx]) does not work for some reason...; 495 if (isTokenToBeSaved[idx] == 1) {; 496 ntokensToBeSaved++ ;; 497 }; 498 }; 499 if (ntokens >= 2 && ntokensToBeSaved != 2) { //first condition not to repeat the previous error message; 500 Error(""TGraph"", ""Incorrect input format! There are %d \""%%lg\"" tag(s) in format whereas 2 and only 2 are expected!"", ntokensToBeSaved);; 501 delete [] isTokenToBeSaved ;; 502 return;; 503 }; 504 ; 505 // Initializing loop variables; 506 Bool_t isLineToBeSkipped = kFALSE ; //empty and ill-formed lines; 507 char * token = nullptr ;; 508 TString token_str = """" ;; 509 Int_t token_idx = 0 ;; 510 Double_t * value = new Double_t [2] ; //x,y buffers; 511 Int_t value_idx = 0 ;; 512 ; 513 // Looping; 514 char *rest;; 515 while (std::getline(infile, line, '\n')) {; 516 if (!line.empty()) {; 517 if (line[line.size() - 1] == char(13)) { // removing DOS CR character; 518 line.erase(line.end() - 1, line.end()) ;; 519 }; 520 //token = R__STRTOK_R(const_cast<char *>(line.c_str()), option, rest);; 521 token = R__STRTOK_R(const_cast<char *>(line.c_str()), option, &rest);; 522 while (token != nullptr && value_idx < 2) {; 523 if (isTokenToBeSaved[token_idx]) {; 524 token_str = TString(token) ;; 525 token_str.ReplaceAll(""\t"", """") ;; 526 if (!token_str.IsFloat()) {; 527 isLineToBeSkipped = kTRUE ;; 528 break ;; 529 } else {; 530 value[value_idx] = token_str.Atof() ;; 531 value_idx++ ;; 532 }; 53",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
Deployability,release,released,") {; 1015 low2 = low;; 1016 low = i;; 1017 } else if (low2 == -1) low2 = i;; 1018 } else if (fX[i] > x) {; 1019 if (up == -1 || fX[i] < fX[up]) {; 1020 up2 = up;; 1021 up = i;; 1022 } else if (up2 == -1) up2 = i;; 1023 } else // case x == fX[i]; 1024 return fY[i]; // no interpolation needed; 1025 }; 1026 ; 1027 // treat cases when x is outside graph min max abscissa; 1028 if (up == -1) {; 1029 up = low;; 1030 low = low2;; 1031 }; 1032 if (low == -1) {; 1033 low = up;; 1034 up = up2;; 1035 }; 1036 }; 1037 // do now the linear interpolation; 1038 assert(low != -1 && up != -1);; 1039 ; 1040 if (fX[low] == fX[up]) return fY[low];; 1041 Double_t yn = fY[up] + (x - fX[up]) * (fY[low] - fY[up]) / (fX[low] - fX[up]);; 1042 return yn;; 1043}; 1044 ; 1045////////////////////////////////////////////////////////////////////////////////; 1046/// Execute action corresponding to one event.; 1047///; 1048/// This member function is called when a graph is clicked with the locator; 1049///; 1050/// If Left button clicked on one of the line end points, this point; 1051/// follows the cursor until button is released.; 1052///; 1053/// if Middle button clicked, the line is moved parallel to itself; 1054/// until the button is released.; 1055 ; 1056void TGraph::ExecuteEvent(Int_t event, Int_t px, Int_t py); 1057{; 1058 TVirtualGraphPainter *painter = TVirtualGraphPainter::GetPainter();; 1059 if (painter) painter->ExecuteEventHelper(this, event, px, py);; 1060}; 1061 ; 1062////////////////////////////////////////////////////////////////////////////////; 1063/// If array sizes <= newsize, expand storage to 2*newsize.; 1064 ; 1065void TGraph::Expand(Int_t newsize); 1066{; 1067 Double_t **ps = ExpandAndCopy(newsize, fNpoints);; 1068 CopyAndRelease(ps, 0, 0, 0);; 1069}; 1070 ; 1071////////////////////////////////////////////////////////////////////////////////; 1072/// If graph capacity is less than newsize points then make array sizes; 1073/// equal to least multiple of step to contain newsiz",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
Energy Efficiency,allocate,allocate,"; 1055 ; 1056void TGraph::ExecuteEvent(Int_t event, Int_t px, Int_t py); 1057{; 1058 TVirtualGraphPainter *painter = TVirtualGraphPainter::GetPainter();; 1059 if (painter) painter->ExecuteEventHelper(this, event, px, py);; 1060}; 1061 ; 1062////////////////////////////////////////////////////////////////////////////////; 1063/// If array sizes <= newsize, expand storage to 2*newsize.; 1064 ; 1065void TGraph::Expand(Int_t newsize); 1066{; 1067 Double_t **ps = ExpandAndCopy(newsize, fNpoints);; 1068 CopyAndRelease(ps, 0, 0, 0);; 1069}; 1070 ; 1071////////////////////////////////////////////////////////////////////////////////; 1072/// If graph capacity is less than newsize points then make array sizes; 1073/// equal to least multiple of step to contain newsize points.; 1074 ; 1075void TGraph::Expand(Int_t newsize, Int_t step); 1076{; 1077 if (newsize <= fMaxSize) {; 1078 return;; 1079 }; 1080 Double_t **ps = Allocate(step * (newsize / step + (newsize % step ? 1 : 0)));; 1081 CopyAndRelease(ps, 0, fNpoints, 0);; 1082}; 1083 ; 1084////////////////////////////////////////////////////////////////////////////////; 1085/// if size > fMaxSize allocate new arrays of 2*size points and copy iend first; 1086/// points.; 1087/// Return pointer to new arrays.; 1088 ; 1089Double_t **TGraph::ExpandAndCopy(Int_t size, Int_t iend); 1090{; 1091 if (size <= fMaxSize); 1092 return nullptr;; 1093 Double_t **newarrays = Allocate(2 * size);; 1094 CopyPoints(newarrays, 0, iend, 0);; 1095 return newarrays;; 1096}; 1097 ; 1098////////////////////////////////////////////////////////////////////////////////; 1099/// Set zero values for point arrays in the range [begin, end); 1100/// Should be redefined in descendant classes; 1101 ; 1102void TGraph::FillZero(Int_t begin, Int_t end, Bool_t); 1103{; 1104 memset(fX + begin, 0, (end - begin)*sizeof(Double_t));; 1105 memset(fY + begin, 0, (end - begin)*sizeof(Double_t));; 1106}; 1107 ; 1108///////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
Integrability,depend,depending,"s.; 66 A TGraph has the default title and name ""Graph"". To change the default title; 67 and name `SetTitle` and `SetName` should be called on the TGraph after its creation.; 68 TGraph was a light weight object to start with, like TPolyline or TPolyMarker.; 69 That’s why it did not have any title and name parameters in the constructors.; 70 ; 71#### Example; 72 ; 73The picture below gives an example:; 74 ; 75Begin_Macro(source); 76{; 77 double x[100], y[100];; 78 int n = 20;; 79 for (int i=0;i<n;i++) {; 80 x[i] = i*0.1;; 81 y[i] = 10*sin(x[i]+0.2);; 82 }; 83 auto g = new TGraph(n,x,y);; 84 g->SetTitle(""Graph title;X title;Y title"");; 85 g->Draw(""AC*"");; 86}; 87End_Macro; 88 ; 89#### Default X-Points; 90 ; 91If one doesn't specify the points in the x-axis, they will get the default values 0, 1, 2, 3, (etc. depending; 92on the length of the y-points):; 93 ; 94Begin_Macro(source); 95{; 96 double y[6] = {3, 8, 1, 10, 5, 7};; 97 auto g = new TGraph(6,y);; 98 g->SetTitle(""A Graph with default X points"");; 99 g->Draw();; 100}; 101End_Macro; 102 ; 103*/; 104 ; 105////////////////////////////////////////////////////////////////////////////////; 106/// Graph default constructor.; 107 ; 108TGraph::TGraph() : TAttFill(0, 1000); 109{; 110 fNpoints = -1; //will be reset to 0 in CtorAllocate; 111 if (!CtorAllocate()) return;; 112}; 113 ; 114////////////////////////////////////////////////////////////////////////////////; 115/// Constructor with only the number of points set; 116/// the arrays x and y will be set later; 117 ; 118TGraph::TGraph(Int_t n); 119 : TNamed(""Graph"", ""Graph""), TAttFill(0, 1000); 120{; 121 fNpoints = n;; 122 if (!CtorAllocate()) return;; 123 FillZero(0, fNpoints);; 124}; 125 ; 126////////////////////////////////////////////////////////////////////////////////; 127/// Graph normal constructor with ints.; 128 ; 129TGraph::TGraph(Int_t n, const Int_t *x, const Int_t *y); 130 : TNamed(""Graph"", ""Graph""), TAttFill(0, 1000); 131{; 132 if (!x || !y) {; 133 fNpoints = ",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
Modifiability,variab,variables,"!format_.IsDigit()) {; 483 Error(""TGraph"", ""Incorrect input format! Allowed formats are {\""%%lg\"",\""%%*lg\"" or \""%%*s\""}"");; 484 return;; 485 }; 486 Int_t ntokens = format_.Length() ;; 487 if (ntokens < 2) {; 488 Error(""TGraph"", ""Incorrect input format! Only %d tag(s) in format whereas 2 \""%%lg\"" tags are expected!"", ntokens);; 489 return;; 490 }; 491 Int_t ntokensToBeSaved = 0 ;; 492 Bool_t * isTokenToBeSaved = new Bool_t [ntokens] ;; 493 for (Int_t idx = 0; idx < ntokens; idx++) {; 494 isTokenToBeSaved[idx] = TString::Format(""%c"", format_[idx]).Atoi() ; //atoi(&format_[idx]) does not work for some reason...; 495 if (isTokenToBeSaved[idx] == 1) {; 496 ntokensToBeSaved++ ;; 497 }; 498 }; 499 if (ntokens >= 2 && ntokensToBeSaved != 2) { //first condition not to repeat the previous error message; 500 Error(""TGraph"", ""Incorrect input format! There are %d \""%%lg\"" tag(s) in format whereas 2 and only 2 are expected!"", ntokensToBeSaved);; 501 delete [] isTokenToBeSaved ;; 502 return;; 503 }; 504 ; 505 // Initializing loop variables; 506 Bool_t isLineToBeSkipped = kFALSE ; //empty and ill-formed lines; 507 char * token = nullptr ;; 508 TString token_str = """" ;; 509 Int_t token_idx = 0 ;; 510 Double_t * value = new Double_t [2] ; //x,y buffers; 511 Int_t value_idx = 0 ;; 512 ; 513 // Looping; 514 char *rest;; 515 while (std::getline(infile, line, '\n')) {; 516 if (!line.empty()) {; 517 if (line[line.size() - 1] == char(13)) { // removing DOS CR character; 518 line.erase(line.end() - 1, line.end()) ;; 519 }; 520 //token = R__STRTOK_R(const_cast<char *>(line.c_str()), option, rest);; 521 token = R__STRTOK_R(const_cast<char *>(line.c_str()), option, &rest);; 522 while (token != nullptr && value_idx < 2) {; 523 if (isTokenToBeSaved[token_idx]) {; 524 token_str = TString(token) ;; 525 token_str.ReplaceAll(""\t"", """") ;; 526 if (!token_str.IsFloat()) {; 527 isLineToBeSkipped = kTRUE ;; 528 break ;; 529 } else {; 530 value[value_idx] = token_str.Atof() ;; 531 value_idx++ ;; 532 }; 53",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
Performance,perform,performed,"21#include ""TF1.h""; 22#include ""TStyle.h""; 23#include ""TMath.h""; 24#include ""TVectorD.h""; 25#include ""Foption.h""; 26#include ""TRandom.h""; 27#include ""TSpline.h""; 28#include ""TVirtualFitter.h""; 29#include ""TVirtualPad.h""; 30#include ""TVirtualGraphPainter.h""; 31#include ""TBrowser.h""; 32#include ""TSystem.h""; 33#include ""TPluginManager.h""; 34#include ""strtok.h""; 35 ; 36#include <cstdlib>; 37#include <string>; 38#include <cassert>; 39#include <iostream>; 40#include <fstream>; 41#include <cstring>; 42#include <numeric>; 43 ; 44#include ""HFitInterface.h""; 45#include ""Fit/DataRange.h""; 46#include ""Math/MinimizerOptions.h""; 47 ; 48extern void H1LeastSquareSeqnd(Int_t n, Double_t *a, Int_t idim, Int_t &ifail, Int_t k, Double_t *b);; 49 ; 50ClassImp(TGraph);; 51 ; 52////////////////////////////////////////////////////////////////////////////////; 53 ; 54/** \class TGraph; 55 \ingroup Graphs; 56A TGraph is an object made of two arrays X and Y with npoints each.; 57The TGraph painting is performed thanks to the TGraphPainter; 58class. All details about the various painting options are given in this class.; 59 ; 60#### Notes; 61 ; 62 - Unlike histogram or tree (or even TGraph2D), TGraph objects; 63 are not automatically attached to the current TFile, in order to keep the; 64 management and size of the TGraph as small as possible.; 65 - The TGraph constructors do not have the TGraph title and name as parameters.; 66 A TGraph has the default title and name ""Graph"". To change the default title; 67 and name `SetTitle` and `SetName` should be called on the TGraph after its creation.; 68 TGraph was a light weight object to start with, like TPolyline or TPolyMarker.; 69 That’s why it did not have any title and name parameters in the constructors.; 70 ; 71#### Example; 72 ; 73The picture below gives an example:; 74 ; 75Begin_Macro(source); 76{; 77 double x[100], y[100];; 78 int n = 20;; 79 for (int i=0;i<n;i++) {; 80 x[i] = i*0.1;; 81 y[i] = 10*sin(x[i]+0.2);; 82 }; 83 auto g = new TGrap",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
Safety,avoid,avoid,"points; i++) fY[i] /= integ;; 409 }; 410 ; 411 f->TAttLine::Copy(*this);; 412 f->TAttFill::Copy(*this);; 413 f->TAttMarker::Copy(*this);; 414 ; 415 SetName(f->GetName());; 416 SetTitle(f->GetTitle());; 417}; 418 ; 419////////////////////////////////////////////////////////////////////////////////; 420/// Graph constructor reading input from filename.; 421///; 422/// `filename` is assumed to contain at least two columns of numbers.; 423/// The string format is by default `""%lg %lg""`.; 424/// This is a standard c formatting for `scanf()`.; 425/// For example, set format to `""%lg,%lg""` for a comma-separated file.; 426///; 427/// If columns of numbers should be skipped, a `""%*lg""` or `""%*s""` for each column; 428/// can be added, e.g. `""%lg %*lg %lg""` would read x-values from the first and; 429/// y-values from the third column.; 430///; 431/// For files separated by a specific delimiter different from ' ' and '\\t' (e.g.; 432/// ';' in csv files) you can avoid using `%*s` to bypass this delimiter by explicitly; 433/// specify the `option` argument,; 434/// e.g. option=`"" \\t,;""` for columns of figures separated by any of these characters; 435/// (' ', '\\t', ',', ';'); 436/// used once (e.g. `""1;1""`) or in a combined way (`"" 1;,;; 1""`).; 437/// Note in that case, the instantiation is about two times slower.; 438 ; 439TGraph::TGraph(const char *filename, const char *format, Option_t *option); 440 : TNamed(""Graph"", filename), TAttFill(0, 1000); 441{; 442 Double_t x, y;; 443 TString fname = filename;; 444 gSystem->ExpandPathName(fname);; 445 ; 446 std::ifstream infile(fname.Data());; 447 if (!infile.good()) {; 448 MakeZombie();; 449 Error(""TGraph"", ""Cannot open file: %s, TGraph is Zombie"", filename);; 450 fNpoints = 0;; 451 return;; 452 } else {; 453 fNpoints = 100; //initial number of points; 454 }; 455 if (!CtorAllocate()) return;; 456 std::string line;; 457 Int_t np = 0;; 458 ; 459 // No delimiters specified (standard constructor).; 460 if (strcmp(option, """") == 0) {; 46",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
Security,access,accessing,"ken = nullptr ;; 546 token_idx = 0 ;; 547 value_idx = 0 ;; 548 }; 549 Set(np) ;; 550 ; 551 // Cleaning; 552 delete [] isTokenToBeSaved ;; 553 delete [] value ;; 554 delete token ;; 555 }; 556 infile.close();; 557 if (fNpoints == 0) {; 558 Warning(""TGraph"", ""No points were found in file %s with the specified input format %s"", filename, format);; 559 return;; 560 }; 561}; 562 ; 563////////////////////////////////////////////////////////////////////////////////; 564/// Graph default destructor.; 565 ; 566TGraph::~TGraph(); 567{; 568 delete [] fX;; 569 delete [] fY;; 570 if (fFunctions) {; 571 fFunctions->SetBit(kInvalidObject);; 572 //special logic to support the case where the same object is; 573 //added multiple times in fFunctions.; 574 //This case happens when the same object is added with different; 575 //drawing modes; 576 TObject *obj;; 577 while ((obj = fFunctions->First())) {; 578 while (fFunctions->Remove(obj)) { }; 579 delete obj;; 580 }; 581 delete fFunctions;; 582 fFunctions = nullptr; //to avoid accessing a deleted object in RecursiveRemove; 583 }; 584 delete fHistogram;; 585}; 586 ; 587////////////////////////////////////////////////////////////////////////////////; 588/// Allocate internal data structures for `newsize` points.; 589 ; 590Double_t **TGraph::Allocate(Int_t newsize); 591{; 592 return AllocateArrays(2, newsize);; 593}; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Allocate arrays.; 597 ; 598Double_t** TGraph::AllocateArrays(Int_t Narrays, Int_t arraySize); 599{; 600 if (arraySize < 0) {; 601 arraySize = 0;; 602 }; 603 Double_t **newarrays = new Double_t*[Narrays];; 604 if (!arraySize) {; 605 for (Int_t i = 0; i < Narrays; ++i); 606 newarrays[i] = nullptr;; 607 } else {; 608 for (Int_t i = 0; i < Narrays; ++i); 609 newarrays[i] = new Double_t[arraySize];; 610 }; 611 fMaxSize = arraySize;; 612 return newarrays;; 613}; 614 ; 615//////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
Testability,log,logic,"TRUE ;; 528 break ;; 529 } else {; 530 value[value_idx] = token_str.Atof() ;; 531 value_idx++ ;; 532 }; 533 }; 534 token = R__STRTOK_R(nullptr, option, &rest); // next token; 535 token_idx++ ;; 536 }; 537 if (!isLineToBeSkipped && value_idx == 2) {; 538 x = value[0] ;; 539 y = value[1] ;; 540 SetPoint(np, x, y) ;; 541 np++ ;; 542 }; 543 }; 544 isLineToBeSkipped = kFALSE ;; 545 token = nullptr ;; 546 token_idx = 0 ;; 547 value_idx = 0 ;; 548 }; 549 Set(np) ;; 550 ; 551 // Cleaning; 552 delete [] isTokenToBeSaved ;; 553 delete [] value ;; 554 delete token ;; 555 }; 556 infile.close();; 557 if (fNpoints == 0) {; 558 Warning(""TGraph"", ""No points were found in file %s with the specified input format %s"", filename, format);; 559 return;; 560 }; 561}; 562 ; 563////////////////////////////////////////////////////////////////////////////////; 564/// Graph default destructor.; 565 ; 566TGraph::~TGraph(); 567{; 568 delete [] fX;; 569 delete [] fY;; 570 if (fFunctions) {; 571 fFunctions->SetBit(kInvalidObject);; 572 //special logic to support the case where the same object is; 573 //added multiple times in fFunctions.; 574 //This case happens when the same object is added with different; 575 //drawing modes; 576 TObject *obj;; 577 while ((obj = fFunctions->First())) {; 578 while (fFunctions->Remove(obj)) { }; 579 delete obj;; 580 }; 581 delete fFunctions;; 582 fFunctions = nullptr; //to avoid accessing a deleted object in RecursiveRemove; 583 }; 584 delete fHistogram;; 585}; 586 ; 587////////////////////////////////////////////////////////////////////////////////; 588/// Allocate internal data structures for `newsize` points.; 589 ; 590Double_t **TGraph::Allocate(Int_t newsize); 591{; 592 return AllocateArrays(2, newsize);; 593}; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Allocate arrays.; 597 ; 598Double_t** TGraph::AllocateArrays(Int_t Narrays, Int_t arraySize); 599{; 600 if (arraySize < 0) {; 601 arraySize = 0;; 602 }; 60",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
Usability,simpl,simply,"rt[0], fNpoints);; 982 Double_t result = s.Eval(x);; 983 return result;; 984 }; 985 }; 986 //linear interpolation; 987 //In case x is < fX[0] or > fX[fNpoints-1] return the extrapolated point; 988 ; 989 //find points in graph around x assuming points are not sorted; 990 // (if point are sorted use a binary search); 991 Int_t low = -1;; 992 Int_t up = -1;; 993 if (TestBit(TGraph::kIsSortedX) ) {; 994 low = TMath::BinarySearch(fNpoints, fX, x);; 995 if (low == -1) {; 996 // use first two points for doing an extrapolation; 997 low = 0;; 998 }; 999 if (fX[low] == x) return fY[low];; 1000 if (low == fNpoints-1) low--; // for extrapolating; 1001 up = low+1;; 1002 }; 1003 else {; 1004 // case TGraph is not sorted; 1005 ; 1006 // find neighbours simply looping all points; 1007 // and find also the 2 adjacent points: (low2 < low < x < up < up2 ); 1008 // needed in case x is outside the graph ascissa interval; 1009 Int_t low2 = -1;; 1010 Int_t up2 = -1;; 1011 ; 1012 for (Int_t i = 0; i < fNpoints; ++i) {; 1013 if (fX[i] < x) {; 1014 if (low == -1 || fX[i] > fX[low]) {; 1015 low2 = low;; 1016 low = i;; 1017 } else if (low2 == -1) low2 = i;; 1018 } else if (fX[i] > x) {; 1019 if (up == -1 || fX[i] < fX[up]) {; 1020 up2 = up;; 1021 up = i;; 1022 } else if (up2 == -1) up2 = i;; 1023 } else // case x == fX[i]; 1024 return fY[i]; // no interpolation needed; 1025 }; 1026 ; 1027 // treat cases when x is outside graph min max abscissa; 1028 if (up == -1) {; 1029 up = low;; 1030 low = low2;; 1031 }; 1032 if (low == -1) {; 1033 low = up;; 1034 up = up2;; 1035 }; 1036 }; 1037 // do now the linear interpolation; 1038 assert(low != -1 && up != -1);; 1039 ; 1040 if (fX[low] == fX[up]) return fY[low];; 1041 Double_t yn = fY[up] + (x - fX[up]) * (fY[low] - fY[up]) / (fX[low] - fX[up]);; 1042 return yn;; 1043}; 1044 ; 1045////////////////////////////////////////////////////////////////////////////////; 1046/// Execute action corresponding to one event.; 1047///; 1048/// This member function is ",MatchSource.WIKI,doc/master/TGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html
Integrability,depend,dependency,". ROOT: hist/hist/inc/TGraph.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TGraph.h File Reference. #include ""TNamed.h""; #include ""TAttLine.h""; #include ""TAttFill.h""; #include ""TAttMarker.h""; #include ""TVectorFfwd.h""; #include ""TVectorDfwd.h""; #include ""TFitResultPtr.h"". Include dependency graph for TGraph.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TGraph;  A TGraph is an object made of two arrays X and Y with npoints each. More...;  . histhistincTGraph.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TGraph_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8h.html
Deployability,continuous,continuous,"in this graph.Definition TGraph.cxx:731; TGraph::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideImplementation to get information on point of graph at cursor position Adapted from class TH1.Definition TGraph.cxx:1585; TGraph::AllocateArraysDouble_t ** AllocateArrays(Int_t Narrays, Int_t arraySize)Allocate arrays.Definition TGraph.cxx:598; TGraph::Scalevirtual void Scale(Double_t c1=1., Option_t *option=""y"")Multiply the values of a TGraph by a constant c1.Definition TGraph.cxx:2259; TGraph::fFunctionsTList * fFunctionsPointer to list of functions (fits and user)Definition TGraph.h:49; TGraph::GetCovariancevirtual Double_t GetCovariance() constReturn covariance of vectors x,y.Definition TGraph.cxx:1308; TGraph::GetEYlowdvirtual Double_t * GetEYlowd() constDefinition TGraph.h:149; TGraph::SwapValuesstatic void SwapValues(Double_t *arr, Int_t pos1, Int_t pos2)Swap values.Definition TGraph.cxx:2611; TGraph::Zerovoid Zero(Int_t &k, Double_t AZ, Double_t BZ, Double_t E2, Double_t &X, Double_t &Y, Int_t maxiterations)Find zero of a continuous function.Definition TGraph.cxx:2717; TGraph::Allocatevirtual Double_t ** Allocate(Int_t newsize)Allocate internal data structures for newsize points.Definition TGraph.cxx:590; TGraph::FitPanelvirtual void FitPanel()Display a GUI panel with all graph fit options.Definition TGraph.cxx:1274; TGraph::Browsevoid Browse(TBrowser *b) overrideBrowse.Definition TGraph.cxx:651; TGraph::DoMergevirtual Bool_t DoMerge(const TGraph *g)protected function to perform the merge operation of a graphDefinition TGraph.cxx:2676; TGraph::InsertPointBeforevirtual void InsertPointBefore(Int_t ipoint, Double_t x, Double_t y)Insert a new point with coordinates (x,y) before the point number ipoint.Definition TGraph.cxx:1749; TGraph::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TGraph.h:126; TGraph::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TGra",MatchSource.WIKI,doc/master/TGraph_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8h_source.html
Energy Efficiency,allocate,allocate,"led when either TCanvas::UseCurrentStyle...Definition TGraph.cxx:2623; TGraph::SetPointvirtual void SetPoint(Int_t i, Double_t x, Double_t y)Set x and y values for point number i.Definition TGraph.cxx:2342; TGraph::GetYDouble_t * GetY() constDefinition TGraph.h:140; TGraph::Mergevirtual Int_t Merge(TCollection *list)Adds all graphs from the collection to this graph.Definition TGraph.cxx:2658; TGraph::fMaxSizeInt_t fMaxSize!Current dimension of arrays fX and fYDefinition TGraph.h:45; TGraph::SaveHistogramAndFunctionsvoid SaveHistogramAndFunctions(std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option)Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes.Definition TGraph.cxx:2199; TGraph::fOptionTString fOptionOptions used for drawing the graph.Definition TGraph.h:53; TGraph::~TGraph~TGraph() overrideGraph default destructor.Definition TGraph.cxx:566; TGraph::ShrinkAndCopyDouble_t ** ShrinkAndCopy(Int_t size, Int_t iend)if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend).Definition TGraph.cxx:2453; TGraph::GetRMSvirtual Double_t GetRMS(Int_t axis=1) constReturn RMS of X (axis=1) or Y (axis=2)Definition TGraph.cxx:1339; TGraph::GetEXhighdvirtual Double_t * GetEXhighd() constDefinition TGraph.h:148; TGraph::IsEditablevirtual Bool_t IsEditable() constDefinition TGraph.h:166; TGraph::fHistogramTH1F * fHistogramPointer to histogram used for drawing axis.Definition TGraph.h:50; TGraph::Paintvoid Paint(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:1977; TGraph::EStatusBitsEStatusBitsDefinition TGraph.h:74; TGraph::kNotEditable@ kNotEditableBit set if graph is non editable.Definition TGraph.h:78; TGraph::kIsHighlight@ kIsHighlightBit set if graph is highlight.Definition TGraph.h:80; TGraph::kIsSortedX@ kIsSortedXGraph is sorted in X points.Definition TGraph.h:79; TGraph::kClipFrame@ kClipFrameClip to the frame boundary.Definition TGrap",MatchSource.WIKI,doc/master/TGraph_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8h_source.html
Performance,perform,perform,"59; TGraph::fFunctionsTList * fFunctionsPointer to list of functions (fits and user)Definition TGraph.h:49; TGraph::GetCovariancevirtual Double_t GetCovariance() constReturn covariance of vectors x,y.Definition TGraph.cxx:1308; TGraph::GetEYlowdvirtual Double_t * GetEYlowd() constDefinition TGraph.h:149; TGraph::SwapValuesstatic void SwapValues(Double_t *arr, Int_t pos1, Int_t pos2)Swap values.Definition TGraph.cxx:2611; TGraph::Zerovoid Zero(Int_t &k, Double_t AZ, Double_t BZ, Double_t E2, Double_t &X, Double_t &Y, Int_t maxiterations)Find zero of a continuous function.Definition TGraph.cxx:2717; TGraph::Allocatevirtual Double_t ** Allocate(Int_t newsize)Allocate internal data structures for newsize points.Definition TGraph.cxx:590; TGraph::FitPanelvirtual void FitPanel()Display a GUI panel with all graph fit options.Definition TGraph.cxx:1274; TGraph::Browsevoid Browse(TBrowser *b) overrideBrowse.Definition TGraph.cxx:651; TGraph::DoMergevirtual Bool_t DoMerge(const TGraph *g)protected function to perform the merge operation of a graphDefinition TGraph.cxx:2676; TGraph::InsertPointBeforevirtual void InsertPointBefore(Int_t ipoint, Double_t x, Double_t y)Insert a new point with coordinates (x,y) before the point number ipoint.Definition TGraph.cxx:1749; TGraph::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TGraph.h:126; TGraph::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TGraph.cxx:1056; TGraph::GetXDouble_t * GetX() constDefinition TGraph.h:139; TGraph::SaveAsvoid SaveAs(const char *filename=""graph"", Option_t *option="""") const overrideSave the graph as .csv, .tsv or .txt.Definition TGraph.cxx:2093; TGraph::Evalvirtual Double_t Eval(Double_t x, TSpline *spline=nullptr, Option_t *option="""") constInterpolate points in this graph at x using a TSpline.Definition TGraph.cxx:953; TGraph::GetMaxSizeInt_t GetMaxSize() constDefinition TGraph.h:131; TGraph::InitExpovirtual void In",MatchSource.WIKI,doc/master/TGraph_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8h_source.html
Testability,log,logx,"tMaximum() const {return fMaximum;}; 152 Double_t GetMinimum() const {return fMinimum;}; 153 TAxis *GetXaxis() const ;; 154 TAxis *GetYaxis() const ;; 155 char *GetObjectInfo(Int_t px, Int_t py) const override;; 156 virtual Int_t GetPoint(Int_t i, Double_t &x, Double_t &y) const;; 157 virtual Double_t GetPointX(Int_t i) const;; 158 virtual Double_t GetPointY(Int_t i) const;; 159 ; 160 virtual void InitExpo(Double_t xmin=0, Double_t xmax=0);; 161 virtual void InitGaus(Double_t xmin=0, Double_t xmax=0);; 162 virtual void InitPolynom(Double_t xmin=0, Double_t xmax=0);; 163 virtual Int_t InsertPoint(); // *MENU*; 164 virtual void InsertPointBefore(Int_t ipoint, Double_t x, Double_t y);; 165 virtual Double_t Integral(Int_t first=0, Int_t last=-1) const;; 166 virtual Bool_t IsEditable() const {return !TestBit(kNotEditable);}; 167 virtual Bool_t IsHighlight() const { return TestBit(kIsHighlight); }; 168 virtual Int_t IsInside(Double_t x, Double_t y) const;; 169 virtual void LeastSquareFit(Int_t m, Double_t *a, Double_t xmin=0, Double_t xmax=0);; 170 virtual void LeastSquareLinearFit(Int_t n, Double_t &a0, Double_t &a1, Int_t &ifail, Double_t xmin=0, Double_t xmax=0);; 171 virtual Int_t Merge(TCollection* list);; 172 virtual void MovePoints(Double_t dx, Double_t dy, Bool_t logx = kFALSE, Bool_t logy = kFALSE);; 173 void Paint(Option_t *chopt="""") override;; 174 void PaintGraph(Int_t npoints, const Double_t *x, const Double_t *y, Option_t *chopt);; 175 void PaintGrapHist(Int_t npoints, const Double_t *x, const Double_t *y, Option_t *chopt);; 176 virtual void PaintStats(TF1 *fit);; 177 void Print(Option_t *chopt="""") const override;; 178 void RecursiveRemove(TObject *obj) override;; 179 virtual Int_t RemovePoint(); // *MENU*; 180 virtual Int_t RemovePoint(Int_t ipoint);; 181 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 182 void SaveAs(const char *filename = ""graph"", Option_t *option = """") const override; // *MENU*; 183 virtual void Scale(Double_t c1=1.",MatchSource.WIKI,doc/master/TGraph_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGraph_8h_source.html
Integrability,depend,dependency,". ROOT: graf2d/win32gdk/inc/TGWin32ProxyDefs.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Macros |; Enumerations |; Variables ; TGWin32ProxyDefs.h File Reference. #include ""Rtypes.h"". Include dependency graph for TGWin32ProxyDefs.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Macros; #define _NAME4_(name1, name2, name3, name4)   _NAME3_(name1,name2,name3)name4;  ; #define DEBUG_PROFILE_PROXY_START(method);  ; #define DEBUG_PROFILE_PROXY_STOP(method);  ; #define RETURN_METHOD_ARG0(klass, type, method);  ; #define RETURN_METHOD_ARG0_CONST(klass, type, method);  ; #define RETURN_METHOD_ARG1(klass, type, method, type1, par1);  ; #define RETURN_METHOD_ARG10(klass, type, method, type1, par1, type2, par2, type3, par3, type4, par4, type5, par5, type6, par6, type7, par7, type8, par8, type9, par9, type10, par10);  ; #define RETURN_METHOD_ARG11(klass, type, method, type1, par1, type2, par2, type3, par3, type4, par4, type5, par5, type6, par6, type7, par7, type8, par8, type9, par9, type10, par10, type11, par11);  ; #define RETURN_METHOD_ARG2(klass, type, method, type1, par1, type2, par2);  ; #define RETURN_METHOD_ARG3(klass, type, method, type1, par1, type2, par2, type3, par3);  ; #define RETURN_METHOD_ARG4(klass, type, method, type1, par1, type2, par2, type3, par3, type4, par4);  ; #define RETURN_METHOD_ARG5(klass, type, method, type1, par1, type2, par2, type3, par3, type4, par4, type5, par5);  ; #define RETURN_METHOD_ARG6(klass, type, method, type1, par1, type2, par2, type3, par3, type4, par4, type5, par5, type6, par6);  ; #define RETURN_METHOD_ARG7(klass, type, method, type1, par1, type2, par2, type3, par3, type4, par4, type5, par5, type6, par6, type7, par7);  ; #define RETURN_METHOD_ARG8(klass, type, method, type1, par1, type2,",MatchSource.WIKI,doc/master/TGWin32ProxyDefs_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32ProxyDefs_8h.html
Integrability,interface,interface,". ROOT: graf2d/win32gdk/inc/TGWin32ProxyDefs.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGWin32ProxyDefs.h. Go to the documentation of this file. 1// @(#)root/win32gdk:$Id$; 2// Author: Valeriy Onuchin 08/08/2003; 3 ; 4 ; 5/*************************************************************************; 6 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 7 * All rights reserved. *; 8 * *; 9 * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 *************************************************************************/; 12 ; 13#ifndef ROOT_TGWin32ProxyDefs; 14#define ROOT_TGWin32ProxyDefs; 15 ; 16#include ""Rtypes.h"" // CINT headers; 17 ; 18 ; 19#define _NAME4_(name1,name2,name3,name4) _NAME3_(name1,name2,name3)name4; 20 ; 21 ; 22 ; 23///////////////////// debug & profile interface /////////////////////////////; 24//; 25// - recompile with gDebugProxy = 1; 26//; 27// root [0] gDebug = -123 // start profiling; 28//or; 29// root [0] gDebug = -1234 // start profiling and debugging(call trace); 30//; 31// root [1] .x macro.C // profile macro.C; 32// root [2] gDebug = 0 // stop profiling; 33// root [3] .x macro.C // print results; 34//; 35 ; 36static int gDebugProxy = 0; // if kTRUE - use debug & profile interface; 37 ; 38enum { kDebugProfile = -123, kDebugTrace = -1234 };; 39 ; 40static unsigned int total = 0;; 41static double total_time = 0;; 42 ; 43#define DEBUG_PROFILE_PROXY_START(method)\; 44 static int i = 0;\; 45 static double t = 0;\; 46 double start = 0;\; 47 int gDebugValue = 0;\; 48 int debug = 0;\; 49 if (gDebugProxy) {\; 50 gDebugValue = gDebug;\; 51 debug = (gDebugValue==kDebugProfile) || (gDebugValue==kDebugTrace);\; 52 if (debug) {\; 53 start = GetMilliSeconds();\; 54 } else {\; 55 if (total) {\; 56 printf("" method name hits time/hits(ms) time(ms) | Total = %d hits %6.2f ms\n"",total,total_time );\; 57 printf(""----------------------------",MatchSource.WIKI,doc/master/TGWin32ProxyDefs_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32ProxyDefs_8h_source.html
Integrability,depend,dependency,". ROOT: graf2d/win32gdk/src/TGWin32VirtualGLProxy.cxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions |; Variables ; TGWin32VirtualGLProxy.cxx File Reference. #include ""TGWin32ProxyDefs.h""; #include ""TGWin32VirtualGLProxy.h""; #include ""TGWin32.h""; #include ""TROOT.h""; #include ""TList.h"". Include dependency graph for TGWin32VirtualGLProxy.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Functions; winID h RETURN_METHOD_ARG1 (GLManager, Bool_t, MakeCurrent, Int_t, devInd) VOID_METHOD_ARG1(GLManager;  ; winID RETURN_METHOD_ARG1 (GLManager, Int_t, CreateGLContext, Int_t, winInd) RETURN_METHOD_ARG5(GLManager;  ; winID h RETURN_METHOD_ARG1 (GLManager, Int_t, GetVirtualXInd, Int_t, pixInd) VOID_METHOD_ARG2(GLManager;  ; winID h TVirtualViewer3D TVirtualGLPainter RETURN_METHOD_ARG3 (GLManager, Bool_t, PlotSelected, TVirtualGLPainter *, plot, Int_t, x, Int_t, y) RETURN_METHOD_ARG3(GLManager;  ; winID h TVirtualViewer3D TVirtualGLPainter char TVirtualGLPainter y RETURN_METHOD_ARG4 (GLManager, Bool_t, SelectManip, TVirtualGLManip *, manip, const TGLCamera *, camera, const TGLRect *, rect, const TGLBoundingBox *, box) RETURN_METHOD_ARG1(GLManager;  ; winID h RETURN_METHOD_ARG5 (GLManager, Bool_t, ResizeOffScreenDevice, Int_t, pixInd, Int_t, x, Int_t, y, UInt_t, w, UInt_t, h) VOID_METHOD_ARG1(GLManager;  ;  RETURN_PROXY_OBJECT (GLManager) RETURN_METHOD_ARG1(GLManager;  ; winID h TVirtualViewer3D VOID_METHOD_ARG1 (GLManager, PaintSingleObject, TVirtualGLPainter *, p, 1) VOID_METHOD_ARG3(GLManager;  ; winID h VOID_METHOD_ARG1 (GLManager, ReadGLBuffer, Int_t, devInd, 1) VOID_METHOD_ARG1(GLManager;  ; winID h VOID_METHOD_ARG2 (GLManager, ExtractViewport, Int_t, pixInd, Int_t *, vp, 1) VOID_METHOD_ARG1(GLManager;  . Variables; winID AttachOffScreenDevice;  ; winID Bool_t;  ; winID h DeleteGLContext;  ; winID h devInd;  ; winID h direct;  ; winID h Flush;  ; winID h TVirtualViewer3D TVir",MatchSource.WIKI,doc/master/TGWin32VirtualGLProxy_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualGLProxy_8cxx.html
Availability,mask,mask,"h GetMarkerStyle GetTextAlign GetTextColor GetTextSize void VOID_METHOD_ARG2 (VirtualX, SetWMState, Window_t, id, EInitialState, state, 1) VOID_METHOD_ARG3(VirtualX;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list VOID_METHOD_ARG3 (VirtualX, ChangeActivePointerGrab, Window_t, win, UInt_t, mask, Cursor_t, cur, 1) VOID_METHOD_ARG5(VirtualX;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t VOID_METHOD_ARG3 (VirtualX, GetFontProperties, FontStruct_t, font, Int_t &, max_ascent, Int_t &, max_descent, 1) VOID_METHOD_ARG5(VirtualX;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t VOID_METHOD_ARG3 (VirtualX, GetImageSize, Drawable_t, id, UInt_t &, width, UInt_t &, height, 1) VOID_METHOD_ARG3(VirtualX;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Flo",MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html
Integrability,depend,dependency,". ROOT: graf2d/win32gdk/src/TGWin32VirtualXProxy.cxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions |; Variables ; TGWin32VirtualXProxy.cxx File Reference. #include ""TGWin32ProxyDefs.h""; #include ""TGWin32VirtualXProxy.h""; #include ""TGWin32.h""; #include ""TList.h"". Include dependency graph for TGWin32VirtualXProxy.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Functions; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner RETURN_METHOD_ARG0 (VirtualX, Region_t, CreateRegion) RETURN_METHOD_ARG0_CONST(VirtualX;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t RETURN_METHOD_ARG0 (VirtualX, Window_t, GetInputFocus) RETURN_METHOD_ARG0(VirtualX;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap RETURN_METHOD_ARG0_CONST (VirtualX, Bool_t, HasTTFonts) RETURN_METHOD_ARG0_CONST(VirtualX;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle RETURN_METHOD_ARG0_CONST (VirtualX, Bool_t, IsTransparent) RETURN_METHOD_ARG0_CONST(VirtualX;  ; Option_t Option_t TPoint TPoint const char GetTextMagnitude RETURN_METHO",MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html
Availability,mask,mask,"t&,h,1); 168VOID_METHOD_ARG4(VirtualX,GetRGB,Int_t,index,Float_t&,r,Float_t&,g,Float_t&,b,1); 169VOID_METHOD_ARG3(VirtualX,GetFontProperties,FontStruct_t,font,Int_t&,max_ascent,Int_t&,max_descent,1); 170VOID_METHOD_ARG5(VirtualX,GetWindowSize,Drawable_t,id,Int_t&,x,Int_t&,y,UInt_t&,w,UInt_t&,h,1); 171VOID_METHOD_ARG3(VirtualX,GetImageSize,Drawable_t,id,UInt_t&,width,UInt_t&,height,1); 172VOID_METHOD_ARG3(VirtualX,UnionRectWithRegion,Rectangle_t*,rect,Region_t,src,Region_t,dest,1); 173VOID_METHOD_ARG3(VirtualX,UnionRegion,Region_t,rega,Region_t,regb,Region_t,result,1); 174VOID_METHOD_ARG3(VirtualX,IntersectRegion,Region_t,rega,Region_t,regb,Region_t,result,1); 175VOID_METHOD_ARG3(VirtualX,SubtractRegion,Region_t,rega,Region_t,regb,Region_t,result,1); 176VOID_METHOD_ARG3(VirtualX,XorRegion,Region_t,rega,Region_t,regb,Region_t,result,1); 177VOID_METHOD_ARG2(VirtualX,GetRegionBox,Region_t,reg,Rectangle_t*,rect,1); 178VOID_METHOD_ARG3(VirtualX,CopyGC,GContext_t,org,GContext_t,dest,Mask_t,mask,1); 179VOID_METHOD_ARG3(VirtualX,GetTextExtent,UInt_t&,w,UInt_t&,h,char*,mess,1); 180VOID_METHOD_ARG7(VirtualX,TranslateCoordinates,Window_t,src,Window_t,dest,Int_t,src_x,Int_t,src_y,Int_t&,dest_x,Int_t&,dest_y,Window_t&,child,1); 181VOID_METHOD_ARG8(VirtualX,QueryPointer,Window_t,id,Window_t&,rootw,Window_t&,childw,Int_t&,root_x,Int_t&,root_y,Int_t&,win_x,Int_t&,win_y,UInt_t&,mask,1); 182VOID_METHOD_ARG0(VirtualX,ClearWindow,1); 183VOID_METHOD_ARG1(VirtualX,SetDrawMode,TVirtualX::EDrawMode,mode,1); 184VOID_METHOD_ARG3(VirtualX,MoveWindow,Int_t,wid,Int_t,x,Int_t,y,1); 185VOID_METHOD_ARG1(VirtualX,ResizeWindow,Int_t,winid,1); 186VOID_METHOD_ARG2(VirtualX,SetCursor,Int_t,win,ECursor,cursor,1); 187VOID_METHOD_ARG2(VirtualX,QueryPointer,Int_t&,ix,Int_t&,iy,1); 188VOID_METHOD_ARG5(VirtualX,GetPasteBuffer,Window_t,id,Atom_t,atom,TString&,text,Int_t&,nchar,Bool_t,del,1); 189VOID_METHOD_ARG1(VirtualX,GetPlanes,Int_t&,planes,1); 190VOID_METHOD_ARG2(VirtualX,GetGCValues,GContext_t,gc,GCValues_",MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html
Integrability,interface,interface,". ROOT: graf2d/win32gdk/src/TGWin32VirtualXProxy.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGWin32VirtualXProxy.cxx. Go to the documentation of this file. 1// @(#)root/win32gdk:$Id$; 2// Author: Valeriy Onuchin 08/08/2003; 3 ; 4 ; 5/*************************************************************************; 6 * Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; 7 * All rights reserved. *; 8 * *; 9 * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 *************************************************************************/; 12 ; 13 ; 14//////////////////////////////////////////////////////////////////////////; 15// //; 16// TGWin32Proxy //; 17// //; 18// This class is the proxy interface to the Win32 graphics system. //; 19// //; 20//////////////////////////////////////////////////////////////////////////; 21 ; 22#include ""TGWin32ProxyDefs.h""; 23#include ""TGWin32VirtualXProxy.h""; 24#include ""TGWin32.h""; 25#include ""TList.h""; 26 ; 27TVirtualX *TGWin32VirtualXProxy::fgRealObject = 0;; 28 ; 29////////////////////////////////////////////////////////////////////////////////; 30////////////////////////////////////////////////////////////////////////////////; 31 ; 32TVirtualX *TGWin32VirtualXProxy::RealObject(); 33{; 34 return fgRealObject;; 35}; 36 ; 37RETURN_PROXY_OBJECT(VirtualX); 38VOID_METHOD_ARG0(VirtualX,SetFillAttributes,1); 39VOID_METHOD_ARG0(VirtualX,SetMarkerAttributes,1); 40VOID_METHOD_ARG0(VirtualX,SetLineAttributes,1); 41VOID_METHOD_ARG0(VirtualX,SetTextAttributes,1); 42VOID_METHOD_ARG1(VirtualX,ResetAttMarker,Option_t*,toption,1); 43VOID_METHOD_ARG1(VirtualX,ResetAttFill,Option_t*,option,1); 44VOID_METHOD_ARG1(VirtualX,ResetAttLine,Option_t*,option,1); 45VOID_METHOD_ARG1(VirtualX,ResetAttText,Option_t*,option,1); 46VOID_METHOD_ARG1(VirtualX,SetFillStyle,Style_t,style,1); 47VOID_METHOD_ARG1(VirtualX,SetTextAngle,Float_t,tangle,1); 4",MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html
Performance,queue,queue," 275{; 276 return (Window_t)gdk_window_get_parent((GdkWindow *) id);; 277}; 278 ; 279////////////////////////////////////////////////////////////////////////////////; 280/// Convert the keycode from the event structure to a key symbol (according; 281/// to the modifiers specified in the event structure and the current; 282/// keyboard mapping). In buf a null terminated ASCII string is returned; 283/// representing the string that is currently mapped to the key code.; 284 ; 285void TGWin32VirtualXProxy::LookupString(Event_t * event, char *buf, Int_t buflen,; 286 UInt_t & keysym); 287{; 288 DEBUG_PROFILE_PROXY_START(LookupString); 289 fgRealObject->LookupString(event,buf,buflen,keysym);; 290 DEBUG_PROFILE_PROXY_STOP(LookupString); 291}; 292 ; 293////////////////////////////////////////////////////////////////////////////////; 294/// Return number of pending events.; 295 ; 296Int_t TGWin32VirtualXProxy::EventsPending(); 297{ ; 298 return fgRealObject->EventsPending();; 299}; 300 ; 301////////////////////////////////////////////////////////////////////////////////; 302/// Process next event in the queue - if any.; 303 ; 304void TGWin32VirtualXProxy::NextEvent(Event_t & event); 305{; 306 fgRealObject->NextEvent(event);; 307}; 308 ; 309////////////////////////////////////////////////////////////////////////////////; 310/// Check if there is for window ""id"" an event of type ""type"".; 311 ; 312Bool_t TGWin32VirtualXProxy::CheckEvent(Window_t id, EGEventType type, Event_t &ev); 313{; 314 return fgRealObject->CheckEvent(id,type,ev);; 315}; 316 ; 317////////////////////////////////////////////////////////////////////////////////; 318/// Send event ev to window id.; 319 ; 320void TGWin32VirtualXProxy::SendEvent(Window_t id, Event_t *ev); 321{; 322 fgRealObject->SendEvent(id,ev);; 323}; 324 ; 325////////////////////////////////////////////////////////////////////////////////; 326/// Return kTRUE if we are inside cmd/server thread.; 327 ; 328Bool_t TGWin32VirtualXProxy::IsCmdThread",MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html
Safety,unsafe,unsafe,"_ARG3(VirtualX,ChangeActivePointerGrab,Window_t,win,UInt_t,mask,Cursor_t,cur,1); 247VOID_METHOD_ARG5(VirtualX,ConvertSelection,Window_t,win,Atom_t&,sel,Atom_t&,target,Atom_t&,prop,Time_t&,stamp,1); 248RETURN_METHOD_ARG2(VirtualX,Bool_t,SetSelectionOwner,Window_t,win,Atom_t&,prop); 249VOID_METHOD_ARG6(VirtualX,ChangeProperties,Window_t,id,Atom_t,property,Atom_t,type,Int_t,format,UChar_t*,data,Int_t,len,1); 250VOID_METHOD_ARG2(VirtualX,SetDNDAware,Window_t,id,Atom_t*,typelist,1); 251VOID_METHOD_ARG3(VirtualX,SetTypeList,Window_t,win,Atom_t,prop,Atom_t*,typelist,1);; 252RETURN_METHOD_ARG6(VirtualX,Window_t,FindRWindow,Window_t,win,Window_t,dragwin,Window_t,input,int,x,int,y,int,maxd);; 253RETURN_METHOD_ARG2(VirtualX,Bool_t,IsDNDAware,Window_t,win,Atom_t*,typelist);; 254 ; 255//VOID_METHOD_ARG1(VirtualX,CreateOpenGLContext,Int_t,wid,1); 256//VOID_METHOD_ARG1(VirtualX,DeleteOpenGLContext,Int_t,wid,1); 257//VOID_METHOD_ARG1(VirtualX,RemoveWindow,ULongptr_t,qwid,1); 258//RETURN_METHOD_ARG1(VirtualX,ExecCommand,UInt_t,TGWin32Command*,code); 259//RETURN_METHOD_ARG3(VirtualX,Int_t,AddWindow,ULongptr_t,qwid,UInt_t,w,UInt_t,h); 260 ; 261//////////////////////// some non-standard methods /////////////////////////////; 262////////////////////////////////////////////////////////////////////////////////; 263///; 264 ; 265void TGWin32VirtualXProxy::CloseDisplay(); 266{; 267 if (gDebug) printf(""CloseDisplay\n"");; 268 fgRealObject->CloseDisplay();; 269}; 270 ; 271////////////////////////////////////////////////////////////////////////////////; 272/// might be thread unsafe (?); 273 ; 274Window_t TGWin32VirtualXProxy::GetParent(Window_t id) const; 275{; 276 return (Window_t)gdk_window_get_parent((GdkWindow *) id);; 277}; 278 ; 279////////////////////////////////////////////////////////////////////////////////; 280/// Convert the keycode from the event structure to a key symbol (according; 281/// to the modifiers specified in the event structure and the current; 282/// keyboard mapping).",MatchSource.WIKI,doc/master/TGWin32VirtualXProxy_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html
Availability,error,error,"11.h""; #include ""TPoint.h""; #include ""TMath.h""; #include ""TStorage.h""; #include ""TStyle.h""; #include ""TExMap.h""; #include ""TEnv.h""; #include ""TString.h""; #include ""TObjString.h""; #include ""TObjArray.h""; #include ""RStipples.h""; #include ""strlcpy.h""; #include <X11/Xlib.h>; #include <X11/Xutil.h>; #include <X11/Xatom.h>; #include <X11/cursorfont.h>; #include <X11/keysym.h>; #include <X11/xpm.h>; #include <cstdio>; #include <cstring>; #include <cstdlib>; #include <cctype>; #include <unistd.h>. Include dependency graph for TGX11.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  RVisual;  ; struct  RXColor;  ; struct  RXGCValues;  ; struct  RXImage;  ; struct  RXPoint;  ; struct  RXVisualInfo;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Functions; static Int_t DummyX11ErrorHandler (Display *, XErrorEvent *);  Dummy error handler for X11. Used by FindUsableVisual(). ;  ; static void GetPixel (int y, int width, Byte_t *scline);  Get pixels in line y and put in array scline. ;  ; int GIFdecode (Byte_t *gifArr, Byte_t *pixArr, int *Width, int *Height, int *Ncols, Byte_t *R, Byte_t *G, Byte_t *B);  ; long GIFencode (int Width, int Height, Int_t Ncol, Byte_t R[], Byte_t G[], Byte_t B[], Byte_t ScLine[], void(*get_scline)(int, int, Byte_t *), void(*pb)(Byte_t));  ; int GIFinfo (Byte_t *gifArr, int *Width, int *Height, int *Ncols);  ; int GIFquantize (UInt_t width, UInt_t height, Int_t *ncol, Byte_t *red, Byte_t *green, Byte_t *blue, Byte_t *outputBuf, Byte_t *outputCmap);  ; static void PutByte (Byte_t b);  Put byte b in output stream. ;  ; int XRotDrawAlignedImageString (Display *, XFontStruct *, float, Drawable, GC, int, int, char *, int);  A front end to XRotPaintAlignedString: -does alignment, paints background. ;  ; int XRotDrawAlignedString (Display *, XFontStruct *, f",MatchSource.WIKI,doc/master/TGX11_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx.html
Energy Efficiency,green,green," #include <unistd.h>. Include dependency graph for TGX11.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  RVisual;  ; struct  RXColor;  ; struct  RXGCValues;  ; struct  RXImage;  ; struct  RXPoint;  ; struct  RXVisualInfo;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Functions; static Int_t DummyX11ErrorHandler (Display *, XErrorEvent *);  Dummy error handler for X11. Used by FindUsableVisual(). ;  ; static void GetPixel (int y, int width, Byte_t *scline);  Get pixels in line y and put in array scline. ;  ; int GIFdecode (Byte_t *gifArr, Byte_t *pixArr, int *Width, int *Height, int *Ncols, Byte_t *R, Byte_t *G, Byte_t *B);  ; long GIFencode (int Width, int Height, Int_t Ncol, Byte_t R[], Byte_t G[], Byte_t B[], Byte_t ScLine[], void(*get_scline)(int, int, Byte_t *), void(*pb)(Byte_t));  ; int GIFinfo (Byte_t *gifArr, int *Width, int *Height, int *Ncols);  ; int GIFquantize (UInt_t width, UInt_t height, Int_t *ncol, Byte_t *red, Byte_t *green, Byte_t *blue, Byte_t *outputBuf, Byte_t *outputCmap);  ; static void PutByte (Byte_t b);  Put byte b in output stream. ;  ; int XRotDrawAlignedImageString (Display *, XFontStruct *, float, Drawable, GC, int, int, char *, int);  A front end to XRotPaintAlignedString: -does alignment, paints background. ;  ; int XRotDrawAlignedString (Display *, XFontStruct *, float, Drawable, GC, int, int, char *, int);  A front end to XRotPaintAlignedString: -does alignment, no background. ;  ; int XRotDrawImageString (Display *, XFontStruct *, float, Drawable, GC, int, int, char *);  A front end to XRotPaintAlignedString: -no alignment, paints background. ;  ; int XRotDrawString (Display *, XFontStruct *, float, Drawable, GC, int, int, char *);  A front end to XRotPaintAlignedString: -no alignment, no background. ;  ; void XRotSetBounding",MatchSource.WIKI,doc/master/TGX11_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx.html
Integrability,depend,dependency,". ROOT: graf2d/x11/src/TGX11.cxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Functions |; Variables ; TGX11.cxx File Reference. #include ""TROOT.h""; #include ""TColor.h""; #include ""TGX11.h""; #include ""TPoint.h""; #include ""TMath.h""; #include ""TStorage.h""; #include ""TStyle.h""; #include ""TExMap.h""; #include ""TEnv.h""; #include ""TString.h""; #include ""TObjString.h""; #include ""TObjArray.h""; #include ""RStipples.h""; #include ""strlcpy.h""; #include <X11/Xlib.h>; #include <X11/Xutil.h>; #include <X11/Xatom.h>; #include <X11/cursorfont.h>; #include <X11/keysym.h>; #include <X11/xpm.h>; #include <cstdio>; #include <cstring>; #include <cstdlib>; #include <cctype>; #include <unistd.h>. Include dependency graph for TGX11.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  RVisual;  ; struct  RXColor;  ; struct  RXGCValues;  ; struct  RXImage;  ; struct  RXPoint;  ; struct  RXVisualInfo;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Functions; static Int_t DummyX11ErrorHandler (Display *, XErrorEvent *);  Dummy error handler for X11. Used by FindUsableVisual(). ;  ; static void GetPixel (int y, int width, Byte_t *scline);  Get pixels in line y and put in array scline. ;  ; int GIFdecode (Byte_t *gifArr, Byte_t *pixArr, int *Width, int *Height, int *Ncols, Byte_t *R, Byte_t *G, Byte_t *B);  ; long GIFencode (int Width, int Height, Int_t Ncol, Byte_t R[], Byte_t G[], Byte_t B[], Byte_t ScLine[], void(*get_scline)(int, int, Byte_t *), void(*pb)(Byte_t));  ; int GIFinfo (Byte_t *gifArr, int *Width, int *Height, int *Ncols);  ; int GIFquantize (UInt_t width, UInt_t height, Int_t *ncol, Byte_t *red, Byte_t *green, Byte_t *blue, Byte_t *outputBuf, Byte_t *outputCmap);  ; static void PutByte (Byte_t b);  Put byte b i",MatchSource.WIKI,doc/master/TGX11_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx.html
Availability,echo,echo,"isplay*, XFontStruct*, float,; 73 Drawable, GC, int, int, char*, int);; 74extern int XRotDrawAlignedImageString(Display*, XFontStruct*, float,; 75 Drawable, GC, int, int, char*, int);; 76extern XPoint *XRotTextExtents(Display*, XFontStruct*, float,; 77 int, int, char*, int);; 78 ; 79//---- globals; 80 ; 81static XWindow_t *gCws; // gCws: pointer to the current window; 82static XWindow_t *gTws; // gTws: temporary pointer; 83 ; 84const Int_t kBIGGEST_RGB_VALUE = 65535;; 85 ; 86//; 87// Primitives Graphic Contexts global for all windows; 88//; 89const int kMAXGC = 7;; 90static GC gGClist[kMAXGC];; 91static GC *gGCline = &gGClist[0]; // PolyLines; 92static GC *gGCmark = &gGClist[1]; // PolyMarker; 93static GC *gGCfill = &gGClist[2]; // Fill areas; 94static GC *gGCtext = &gGClist[3]; // Text; 95static GC *gGCinvt = &gGClist[4]; // Inverse text; 96static GC *gGCdash = &gGClist[5]; // Dashed lines; 97static GC *gGCpxmp = &gGClist[6]; // Pixmap management; 98 ; 99static GC gGCecho; // Input echo; 100 ; 101static Int_t gFillHollow; // Flag if fill style is hollow; 102static Pixmap gFillPattern = 0; // Fill pattern; 103 ; 104//; 105// Text management; 106//; 107const Int_t kMAXFONT = 4;; 108static struct {; 109 XFontStruct *id;; 110 char name[80]; // Font name; 111} gFont[kMAXFONT]; // List of fonts loaded; 112 ; 113static XFontStruct *gTextFont; // Current font; 114static Int_t gCurrentFontNumber = 0; // Current font number in gFont[]; 115 ; 116//; 117// Markers; 118//; 119const Int_t kMAXMK = 100;; 120static struct {; 121 int type;; 122 int n;; 123 XPoint xy[kMAXMK];; 124} gMarker; // Point list to draw marker; 125static int gMarkerLineWidth = 0;; 126static int gMarkerLineStyle = LineSolid;; 127static int gMarkerCapStyle = CapRound;; 128static int gMarkerJoinStyle = JoinRound;; 129 ; 130//; 131// Keep style values for line GC; 132//; 133static int gLineWidth = 0;; 134static int gLineStyle = LineSolid;; 135static int gCapStyle = CapButt;; 136static int gJoinStyle = JoinMiter;",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
Deployability,update,update,"f line; 607 ; 608void TGX11::DrawLine(Int_t x1, Int_t y1, Int_t x2, Int_t y2); 609{; 610 if (gLineStyle == LineSolid); 611 XDrawLine((Display*)fDisplay, gCws->fDrawing, *gGCline, x1, y1, x2, y2);; 612 else {; 613 XSetDashes((Display*)fDisplay, *gGCdash, gDashOffset, gDashList, gDashSize);; 614 XDrawLine((Display*)fDisplay, gCws->fDrawing, *gGCdash, x1, y1, x2, y2);; 615 }; 616}; 617 ; 618////////////////////////////////////////////////////////////////////////////////; 619/// Draw a line through all points.; 620///; 621/// \param [in] n number of points; 622/// \param [in] xy list of points; 623 ; 624void TGX11::DrawPolyLine(int n, TPoint *xy); 625{; 626 XPoint *xyp = (XPoint*)xy;; 627 ; 628 const Int_t kMaxPoints = 1000001;; 629 ; 630 if (n > kMaxPoints) {; 631 int ibeg = 0;; 632 int iend = kMaxPoints - 1;; 633 while (iend < n) {; 634 DrawPolyLine( kMaxPoints, &xy[ibeg] );; 635 ibeg = iend;; 636 iend += kMaxPoints - 1;; 637 }; 638 if (ibeg < n) {; 639 int npt = n - ibeg;; 640 DrawPolyLine( npt, &xy[ibeg] );; 641 }; 642 } else if (n > 1) {; 643 if (gLineStyle == LineSolid); 644 XDrawLines((Display*)fDisplay, gCws->fDrawing, *gGCline, xyp, n, CoordModeOrigin);; 645 else {; 646 int i;; 647 XSetDashes((Display*)fDisplay, *gGCdash,; 648 gDashOffset, gDashList, gDashSize);; 649 XDrawLines((Display*)fDisplay, gCws->fDrawing, *gGCdash, xyp, n, CoordModeOrigin);; 650 ; 651 // calculate length of line to update dash offset; 652 for (i = 1; i < n; i++) {; 653 int dx = xyp[i].x - xyp[i-1].x;; 654 int dy = xyp[i].y - xyp[i-1].y;; 655 if (dx < 0) dx = - dx;; 656 if (dy < 0) dy = - dy;; 657 gDashOffset += dx > dy ? dx : dy;; 658 }; 659 gDashOffset %= gDashLength;; 660 }; 661 } else {; 662 int px,py;; 663 px=xyp[0].x;; 664 py=xyp[0].y;; 665 XDrawPoint((Display*)fDisplay, gCws->fDrawing,; 666 gLineStyle == LineSolid ? *gGCline : *gGCdash, px, py);; 667 }; 668}; 669 ; 670////////////////////////////////////////////////////////////////////////////////; 671/// Draw n markers with the c",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
Energy Efficiency,green,green,"c(fWindows);; 328 ; 329 if (!fColors) return;; 330 Long64_t key, value;; 331 TExMapIter it(fColors);; 332 while (it.Next(key, value)) {; 333 XColor_t *col = (XColor_t *) (Long_t)value;; 334 delete col;; 335 }; 336 delete fColors;; 337}; 338 ; 339////////////////////////////////////////////////////////////////////////////////; 340/// Initialize X11 system. Returns kFALSE in case of failure.; 341 ; 342Bool_t TGX11::Init(void *display); 343{; 344 if (OpenDisplay(display) == -1) return kFALSE;; 345 return kTRUE;; 346}; 347 ; 348////////////////////////////////////////////////////////////////////////////////; 349/// Allocate color in colormap. If we are on an <= 8 plane machine; 350/// we will use XAllocColor. If we are on a >= 15 (15, 16 or 24) plane; 351/// true color machine we will calculate the pixel value using:; 352/// for 15 and 16 bit true colors have 6 bits precision per color however; 353/// only the 5 most significant bits are used in the color index.; 354/// Except for 16 bits where green uses all 6 bits. I.e.:; 355/// ~~~ {.cpp}; 356/// 15 bits = rrrrrgggggbbbbb; 357/// 16 bits = rrrrrggggggbbbbb; 358/// ~~~; 359/// for 24 bits each r, g and b are represented by 8 bits.; 360///; 361/// Since all colors are set with a max of 65535 (16 bits) per r, g, b; 362/// we just right shift them by 10, 11 and 10 bits for 16 planes, and; 363/// (10, 10, 10 for 15 planes) and by 8 bits for 24 planes.; 364/// Returns kFALSE in case color allocation failed.; 365 ; 366Bool_t TGX11::AllocColor(Colormap cmap, RXColor *color); 367{; 368 if (fRedDiv == -1) {; 369 if (XAllocColor((Display*)fDisplay, cmap, color)); 370 return kTRUE;; 371 } else {; 372 color->pixel = (color->red >> fRedDiv) << fRedShift |; 373 (color->green >> fGreenDiv) << fGreenShift |; 374 (color->blue >> fBlueDiv) << fBlueShift;; 375 return kTRUE;; 376 }; 377 return kFALSE;; 378}; 379 ; 380////////////////////////////////////////////////////////////////////////////////; 381/// Returns the current RGB value for",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
Integrability,interface,interface,". ROOT: graf2d/x11/src/TGX11.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGX11.cxx. Go to the documentation of this file. 1// @(#)root/x11:$Id$; 2// Author: Rene Brun, Olivier Couet, Fons Rademakers 28/11/94; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/// \defgroup x11 X11 backend; 13/// \brief Interface to X11 graphics.; 14/// \ingroup GraphicsBackends; 15 ; 16/** \class TGX11; 17\ingroup x11; 18This class is the basic interface to the X11 (Xlib) graphics system.; 19It is an implementation of the abstract TVirtualX class.; 20 ; 21This class gives access to basic X11 graphics, pixmap, text and font handling; 22routines.; 23 ; 24The companion class for Win32 is TGWin32.; 25 ; 26The file G11Gui.cxx contains the implementation of the GUI methods of the; 27TGX11 class. Most of the methods are used by the machine independent; 28GUI classes (libGUI.so).; 29 ; 30This code was initially developed in the context of HIGZ and PAW; 31by Olivier Couet (package X11INT).; 32*/; 33 ; 34#include ""TROOT.h""; 35#include ""TColor.h""; 36#include ""TGX11.h""; 37#include ""TPoint.h""; 38#include ""TMath.h""; 39#include ""TStorage.h""; 40#include ""TStyle.h""; 41#include ""TExMap.h""; 42#include ""TEnv.h""; 43#include ""TString.h""; 44#include ""TObjString.h""; 45#include ""TObjArray.h""; 46#include ""RStipples.h""; 47#include ""strlcpy.h""; 48 ; 49#include <X11/Xlib.h>; 50#include <X11/Xutil.h>; 51#include <X11/Xatom.h>; 52#include <X11/cursorfont.h>; 53#include <X11/keysym.h>; 54#include <X11/xpm.h>; 55 ; 56#include <cstdio>; 57#include <cstring>; 58#include <cstdlib>; 59#include <cctype>; 60#include <unistd.h>; 61#ifdef R__AIX",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
Performance,load,loaded,XWindow_t *gCws; // gCws: pointer to the current window; 82static XWindow_t *gTws; // gTws: temporary pointer; 83 ; 84const Int_t kBIGGEST_RGB_VALUE = 65535;; 85 ; 86//; 87// Primitives Graphic Contexts global for all windows; 88//; 89const int kMAXGC = 7;; 90static GC gGClist[kMAXGC];; 91static GC *gGCline = &gGClist[0]; // PolyLines; 92static GC *gGCmark = &gGClist[1]; // PolyMarker; 93static GC *gGCfill = &gGClist[2]; // Fill areas; 94static GC *gGCtext = &gGClist[3]; // Text; 95static GC *gGCinvt = &gGClist[4]; // Inverse text; 96static GC *gGCdash = &gGClist[5]; // Dashed lines; 97static GC *gGCpxmp = &gGClist[6]; // Pixmap management; 98 ; 99static GC gGCecho; // Input echo; 100 ; 101static Int_t gFillHollow; // Flag if fill style is hollow; 102static Pixmap gFillPattern = 0; // Fill pattern; 103 ; 104//; 105// Text management; 106//; 107const Int_t kMAXFONT = 4;; 108static struct {; 109 XFontStruct *id;; 110 char name[80]; // Font name; 111} gFont[kMAXFONT]; // List of fonts loaded; 112 ; 113static XFontStruct *gTextFont; // Current font; 114static Int_t gCurrentFontNumber = 0; // Current font number in gFont[]; 115 ; 116//; 117// Markers; 118//; 119const Int_t kMAXMK = 100;; 120static struct {; 121 int type;; 122 int n;; 123 XPoint xy[kMAXMK];; 124} gMarker; // Point list to draw marker; 125static int gMarkerLineWidth = 0;; 126static int gMarkerLineStyle = LineSolid;; 127static int gMarkerCapStyle = CapRound;; 128static int gMarkerJoinStyle = JoinRound;; 129 ; 130//; 131// Keep style values for line GC; 132//; 133static int gLineWidth = 0;; 134static int gLineStyle = LineSolid;; 135static int gCapStyle = CapButt;; 136static int gJoinStyle = JoinMiter;; 137static char gDashList[10];; 138static int gDashLength = 0;; 139static int gDashOffset = 0;; 140static int gDashSize = 0;; 141 ; 142//; 143// Event masks; 144//; 145static ULong_t gMouseMask = ButtonPressMask | ButtonReleaseMask |; 146 EnterWindowMask | LeaveWindowMask |; 147 PointerMotionMask | KeyPressMask ,MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
Security,access,access,". ROOT: graf2d/x11/src/TGX11.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TGX11.cxx. Go to the documentation of this file. 1// @(#)root/x11:$Id$; 2// Author: Rene Brun, Olivier Couet, Fons Rademakers 28/11/94; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/// \defgroup x11 X11 backend; 13/// \brief Interface to X11 graphics.; 14/// \ingroup GraphicsBackends; 15 ; 16/** \class TGX11; 17\ingroup x11; 18This class is the basic interface to the X11 (Xlib) graphics system.; 19It is an implementation of the abstract TVirtualX class.; 20 ; 21This class gives access to basic X11 graphics, pixmap, text and font handling; 22routines.; 23 ; 24The companion class for Win32 is TGWin32.; 25 ; 26The file G11Gui.cxx contains the implementation of the GUI methods of the; 27TGX11 class. Most of the methods are used by the machine independent; 28GUI classes (libGUI.so).; 29 ; 30This code was initially developed in the context of HIGZ and PAW; 31by Olivier Couet (package X11INT).; 32*/; 33 ; 34#include ""TROOT.h""; 35#include ""TColor.h""; 36#include ""TGX11.h""; 37#include ""TPoint.h""; 38#include ""TMath.h""; 39#include ""TStorage.h""; 40#include ""TStyle.h""; 41#include ""TExMap.h""; 42#include ""TEnv.h""; 43#include ""TString.h""; 44#include ""TObjString.h""; 45#include ""TObjArray.h""; 46#include ""RStipples.h""; 47#include ""strlcpy.h""; 48 ; 49#include <X11/Xlib.h>; 50#include <X11/Xutil.h>; 51#include <X11/Xatom.h>; 52#include <X11/cursorfont.h>; 53#include <X11/keysym.h>; 54#include <X11/xpm.h>; 55 ; 56#include <cstdio>; 57#include <cstring>; 58#include <cstdlib>; 59#include <cctype>; 60#include <unistd.h>; 61#ifdef R__AIX",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
Usability,usab,usable,"fDisplay, fScreenNumber);; 819 ; 820 if (!fVisual) {; 821 fDepth = DefaultDepth((Display*)fDisplay, fScreenNumber);; 822 fVisual = (RVisual*)DefaultVisual((Display*)fDisplay, fScreenNumber);; 823 fVisRootWin = fRootWin;; 824 if (fDepth > 1); 825 fColormap = DefaultColormap((Display*)fDisplay, fScreenNumber);; 826 fBlackPixel = BlackPixel((Display*)fDisplay, fScreenNumber);; 827 fWhitePixel = WhitePixel((Display*)fDisplay, fScreenNumber);; 828 }; 829 if (gDebug > 1); 830 Printf(""Selected visual 0x%lx: depth %d, class %d, colormap: %s"",; 831 fVisual->visualid, fDepth, fVisual->c_class,; 832 fColormap == DefaultColormap((Display*)fDisplay, fScreenNumber) ? ""default"" :; 833 ""custom"");; 834}; 835 ; 836////////////////////////////////////////////////////////////////////////////////; 837/// Dummy error handler for X11. Used by FindUsableVisual().; 838 ; 839static Int_t DummyX11ErrorHandler(Display *, XErrorEvent *); 840{; 841 return 0;; 842}; 843 ; 844////////////////////////////////////////////////////////////////////////////////; 845/// Check if visual is usable, if so set fVisual, fDepth, fColormap,; 846/// fBlackPixel and fWhitePixel.; 847 ; 848void TGX11::FindUsableVisual(RXVisualInfo *vlist, Int_t nitems); 849{; 850 Int_t (*oldErrorHandler)(Display *, XErrorEvent *) =; 851 XSetErrorHandler(DummyX11ErrorHandler);; 852 ; 853 XSetWindowAttributes attr;; 854 memset(&attr, 0, sizeof(attr));; 855 ; 856 Window root = RootWindow((Display*)fDisplay, fScreenNumber);; 857 ; 858 for (Int_t i = 0; i < nitems; i++) {; 859 Window w = None, wjunk;; 860 UInt_t width, height, ujunk;; 861 Int_t junk;; 862 ; 863 // try and use default colormap when possible; 864 if (vlist[i].visual == DefaultVisual((Display*)fDisplay, fScreenNumber)) {; 865 attr.colormap = DefaultColormap((Display*)fDisplay, fScreenNumber);; 866 } else {; 867 attr.colormap = XCreateColormap((Display*)fDisplay, root, vlist[i].visual, AllocNone);; 868 }; 869 ; 870 static XColor black_xcol = { 0, 0x0000, 0x0000, 0x0000, Do",MatchSource.WIKI,doc/master/TGX11_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html
Integrability,depend,dependency,". ROOT: hist/hist/inc/TH1F.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TH1F.h File Reference. #include ""TH1.h"". Include dependency graph for TH1F.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. histhistincTH1F.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TH1F_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1F_8h.html
Integrability,depend,dependency,". ROOT: hist/hist/inc/TH1I.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TH1I.h File Reference. #include ""TH1.h"". Include dependency graph for TH1I.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. histhistincTH1I.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TH1I_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1I_8h.html
Integrability,depend,dependency,"ence. #include <array>; #include <cctype>; #include <climits>; #include <cmath>; #include <cstdio>; #include <cstdlib>; #include <cstring>; #include <iostream>; #include <sstream>; #include <fstream>; #include ""TROOT.h""; #include ""TBuffer.h""; #include ""TEnv.h""; #include ""TClass.h""; #include ""TMath.h""; #include ""THashList.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TH3.h""; #include ""TF2.h""; #include ""TF3.h""; #include ""TPluginManager.h""; #include ""TVirtualPad.h""; #include ""TRandom.h""; #include ""TVirtualFitter.h""; #include ""THLimitsFinder.h""; #include ""TProfile.h""; #include ""TStyle.h""; #include ""TVectorF.h""; #include ""TVectorD.h""; #include ""TBrowser.h""; #include ""TError.h""; #include ""TVirtualHistPainter.h""; #include ""TVirtualFFT.h""; #include ""TVirtualPaveStats.h""; #include ""HFitInterface.h""; #include ""Fit/DataRange.h""; #include ""Fit/BinData.h""; #include ""Math/GoFTest.h""; #include ""Math/MinimizerOptions.h""; #include ""Math/QuantFuncMathCore.h""; #include ""TH1Merger.h"". Include dependency graph for TH1.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Functions; static Bool_t AlmostEqual (Double_t a, Double_t b, Double_t epsilon=0.00000001);  Test if two double are almost equal. ;  ; static Bool_t AlmostInteger (Double_t a, Double_t epsilon=0.00000001);  Test if a double is almost an integer. ;  ; void H1InitExpo ();  Compute Initial values of parameters for an exponential. ;  ; void H1InitGaus ();  Compute Initial values of parameters for a gaussian. ;  ; void H1InitPolynom ();  Compute Initial values of parameters for a polynom. ;  ; void H1LeastSquareFit (Int_t n, Int_t m, Double_t *a);  Least squares lpolynomial fitting without weights. ;  ; void H1LeastSquareLinearFit (Int_t ndata, Double_t &a0, Double_t &a1, Int_t &ifail);  Least sq",MatchSource.WIKI,doc/master/TH1_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx.html
Availability,error,errors,"\brief 1-D histogram with a double per channel (see TH1 documentation); 72@}; 73*/; 74 ; 75/** \class TH1; 76 \ingroup Histograms; 77TH1 is the base class of all histogram classes in %ROOT.; 78 ; 79It provides the common interface for operations such as binning, filling, drawing, which; 80will be detailed below.; 81 ; 82-# [Creating histograms](\ref creating-histograms); 83 - [Labelling axes](\ref labelling-axis); 84-# [Binning](\ref binning); 85 - [Fix or variable bin size](\ref fix-var); 86 - [Convention for numbering bins](\ref convention); 87 - [Alphanumeric Bin Labels](\ref alpha); 88 - [Histograms with automatic bins](\ref auto-bin); 89 - [Rebinning](\ref rebinning); 90-# [Filling histograms](\ref filling-histograms); 91 - [Associated errors](\ref associated-errors); 92 - [Associated functions](\ref associated-functions); 93 - [Projections of histograms](\ref prof-hist); 94 - [Random Numbers and histograms](\ref random-numbers); 95 - [Making a copy of a histogram](\ref making-a-copy); 96 - [Normalizing histograms](\ref normalizing); 97-# [Drawing histograms](\ref drawing-histograms); 98 - [Setting Drawing histogram contour levels (2-D hists only)](\ref cont-level); 99 - [Setting histogram graphics attributes](\ref graph-att); 100 - [Customising how axes are drawn](\ref axis-drawing); 101-# [Fitting histograms](\ref fitting-histograms); 102-# [Saving/reading histograms to/from a ROOT file](\ref saving-histograms); 103-# [Operations on histograms](\ref operations-on-histograms); 104-# [Miscellaneous operations](\ref misc); 105 ; 106ROOT supports the following histogram types:; 107 ; 108 - 1-D histograms:; 109 - TH1C : histograms with one byte per channel. Maximum bin content = 127; 110 - TH1S : histograms with one short per channel. Maximum bin content = 32767; 111 - TH1I : histograms with one int per channel. Maximum bin content = INT_MAX (\ref intmax ""*""); 112 - TH1L : histograms with one long64 per channel. Maximum bin content = LLONG_MAX (\ref llongmax ""**"")",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
Deployability,update,updated,"errors and functions, e.g.:; 456~~~ {.cpp}; 457 TH1F *hnew = (TH1F*)h->Clone(""hnew"");; 458~~~; 459 ; 460\anchor normalizing; 461### Normalizing histograms; 462 ; 463 One can scale a histogram such that the bins integral is equal to; 464 the normalization parameter via TH1::Scale(Double_t norm), where norm; 465 is the desired normalization divided by the integral of the histogram.; 466 ; 467 ; 468\anchor drawing-histograms; 469## Drawing histograms; 470 ; 471 Histograms are drawn via the THistPainter class. Each histogram has; 472 a pointer to its own painter (to be usable in a multithreaded program).; 473 Many drawing options are supported.; 474 See THistPainter::Paint() for more details.; 475 ; 476 The same histogram can be drawn with different options in different pads.; 477 When a histogram drawn in a pad is deleted, the histogram is; 478 automatically removed from the pad or pads where it was drawn.; 479 If a histogram is drawn in a pad, then filled again, the new status; 480 of the histogram will be automatically shown in the pad next time; 481 the pad is updated. One does not need to redraw the histogram.; 482 To draw the current version of a histogram in a pad, one can use; 483~~~ {.cpp}; 484 h->DrawCopy();; 485~~~; 486 This makes a clone (see Clone below) of the histogram. Once the clone; 487 is drawn, the original histogram may be modified or deleted without; 488 affecting the aspect of the clone.; 489 ; 490 One can use TH1::SetMaximum() and TH1::SetMinimum() to force a particular; 491 value for the maximum or the minimum scale on the plot. (For 1-D; 492 histograms this means the y-axis, while for 2-D histograms these; 493 functions affect the z-axis).; 494 ; 495 TH1::UseCurrentStyle() can be used to change all histogram graphics; 496 attributes to correspond to the current selected style.; 497 This function must be called for each histogram.; 498 In case one reads and draws many histograms from a file, one can force; 499 the histograms to inherit automatica",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
Energy Efficiency,power,power,"ehavior; 1276 ; 1277void TH1::AddBinContent(Int_t, Double_t); 1278{; 1279 AbstractMethod(""AddBinContent"");; 1280}; 1281 ; 1282////////////////////////////////////////////////////////////////////////////////; 1283/// Sets the flag controlling the automatic add of histograms in memory; 1284///; 1285/// By default (fAddDirectory = kTRUE), histograms are automatically added; 1286/// to the list of objects in memory.; 1287/// Note that one histogram can be removed from its support directory; 1288/// by calling h->SetDirectory(nullptr) or h->SetDirectory(dir) to add it; 1289/// to the list of objects in the directory dir.; 1290///; 1291/// NOTE that this is a static function. To call it, use;; 1292/// TH1::AddDirectory; 1293 ; 1294void TH1::AddDirectory(Bool_t add); 1295{; 1296 fgAddDirectory = add;; 1297}; 1298 ; 1299////////////////////////////////////////////////////////////////////////////////; 1300/// Auxiliary function to get the power of 2 next (larger) or previous (smaller); 1301/// a given x; 1302///; 1303/// next = kTRUE : next larger; 1304/// next = kFALSE : previous smaller; 1305///; 1306/// Used by the autobin power of 2 algorithm; 1307 ; 1308inline Double_t TH1::AutoP2GetPower2(Double_t x, Bool_t next); 1309{; 1310 Int_t nn;; 1311 Double_t f2 = std::frexp(x, &nn);; 1312 return ((next && x > 0.) || (!next && x <= 0.)) ? std::ldexp(std::copysign(1., f2), nn); 1313 : std::ldexp(std::copysign(1., f2), --nn);; 1314}; 1315 ; 1316////////////////////////////////////////////////////////////////////////////////; 1317/// Auxiliary function to get the next power of 2 integer value larger then n; 1318///; 1319/// Used by the autobin power of 2 algorithm; 1320 ; 1321inline Int_t TH1::AutoP2GetBins(Int_t n); 1322{; 1323 Int_t nn;; 1324 Double_t f2 = std::frexp(n, &nn);; 1325 if (TMath::Abs(f2 - .5) > 0.001); 1326 return (Int_t)std::ldexp(1., nn);; 1327 return n;; 1328}; 1329 ; 1330////////////////////////////////////////////////////////////////////////////////; 1331/// Bu",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
Integrability,interface,interface,"TVirtualPaveStats.h""; 48 ; 49#include ""HFitInterface.h""; 50#include ""Fit/DataRange.h""; 51#include ""Fit/BinData.h""; 52#include ""Math/GoFTest.h""; 53#include ""Math/MinimizerOptions.h""; 54#include ""Math/QuantFuncMathCore.h""; 55 ; 56#include ""TH1Merger.h""; 57 ; 58/** \addtogroup Histograms; 59@{; 60\class TH1C; 61\brief 1-D histogram with a byte per channel (see TH1 documentation); 62\class TH1S; 63\brief 1-D histogram with a short per channel (see TH1 documentation); 64\class TH1I; 65\brief 1-D histogram with an int per channel (see TH1 documentation); 66\class TH1L; 67\brief 1-D histogram with a long64 per channel (see TH1 documentation); 68\class TH1F; 69\brief 1-D histogram with a float per channel (see TH1 documentation); 70\class TH1D; 71\brief 1-D histogram with a double per channel (see TH1 documentation); 72@}; 73*/; 74 ; 75/** \class TH1; 76 \ingroup Histograms; 77TH1 is the base class of all histogram classes in %ROOT.; 78 ; 79It provides the common interface for operations such as binning, filling, drawing, which; 80will be detailed below.; 81 ; 82-# [Creating histograms](\ref creating-histograms); 83 - [Labelling axes](\ref labelling-axis); 84-# [Binning](\ref binning); 85 - [Fix or variable bin size](\ref fix-var); 86 - [Convention for numbering bins](\ref convention); 87 - [Alphanumeric Bin Labels](\ref alpha); 88 - [Histograms with automatic bins](\ref auto-bin); 89 - [Rebinning](\ref rebinning); 90-# [Filling histograms](\ref filling-histograms); 91 - [Associated errors](\ref associated-errors); 92 - [Associated functions](\ref associated-functions); 93 - [Projections of histograms](\ref prof-hist); 94 - [Random Numbers and histograms](\ref random-numbers); 95 - [Making a copy of a histogram](\ref making-a-copy); 96 - [Normalizing histograms](\ref normalizing); 97-# [Drawing histograms](\ref drawing-histograms); 98 - [Setting Drawing histogram contour levels (2-D hists only)](\ref cont-level); 99 - [Setting histogram graphics attributes](\ref graph-att);",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
Modifiability,variab,variable,"\brief 1-D histogram with a double per channel (see TH1 documentation); 72@}; 73*/; 74 ; 75/** \class TH1; 76 \ingroup Histograms; 77TH1 is the base class of all histogram classes in %ROOT.; 78 ; 79It provides the common interface for operations such as binning, filling, drawing, which; 80will be detailed below.; 81 ; 82-# [Creating histograms](\ref creating-histograms); 83 - [Labelling axes](\ref labelling-axis); 84-# [Binning](\ref binning); 85 - [Fix or variable bin size](\ref fix-var); 86 - [Convention for numbering bins](\ref convention); 87 - [Alphanumeric Bin Labels](\ref alpha); 88 - [Histograms with automatic bins](\ref auto-bin); 89 - [Rebinning](\ref rebinning); 90-# [Filling histograms](\ref filling-histograms); 91 - [Associated errors](\ref associated-errors); 92 - [Associated functions](\ref associated-functions); 93 - [Projections of histograms](\ref prof-hist); 94 - [Random Numbers and histograms](\ref random-numbers); 95 - [Making a copy of a histogram](\ref making-a-copy); 96 - [Normalizing histograms](\ref normalizing); 97-# [Drawing histograms](\ref drawing-histograms); 98 - [Setting Drawing histogram contour levels (2-D hists only)](\ref cont-level); 99 - [Setting histogram graphics attributes](\ref graph-att); 100 - [Customising how axes are drawn](\ref axis-drawing); 101-# [Fitting histograms](\ref fitting-histograms); 102-# [Saving/reading histograms to/from a ROOT file](\ref saving-histograms); 103-# [Operations on histograms](\ref operations-on-histograms); 104-# [Miscellaneous operations](\ref misc); 105 ; 106ROOT supports the following histogram types:; 107 ; 108 - 1-D histograms:; 109 - TH1C : histograms with one byte per channel. Maximum bin content = 127; 110 - TH1S : histograms with one short per channel. Maximum bin content = 32767; 111 - TH1I : histograms with one int per channel. Maximum bin content = INT_MAX (\ref intmax ""*""); 112 - TH1L : histograms with one long64 per channel. Maximum bin content = LLONG_MAX (\ref llongmax ""**"")",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
Performance,perform,performance,"t; 3263/// - option of transform type; 3264/// - ""R2C"" - real to complex transforms - default; 3265/// - ""R2HC"" - real to halfcomplex (special format of storing output data,; 3266/// results the same as for R2C); 3267/// - ""DHT"" - discrete Hartley transform; 3268/// real to real transforms (sine and cosine):; 3269/// - ""R2R_0"", ""R2R_1"", ""R2R_2"", ""R2R_3"" - discrete cosine transforms of types I-IV; 3270/// - ""R2R_4"", ""R2R_5"", ""R2R_6"", ""R2R_7"" - discrete sine transforms of types I-IV; 3271/// To specify the type of each dimension of a 2-dimensional real to real; 3272/// transform, use options of form ""R2R_XX"", for example, ""R2R_02"" for a transform,; 3273/// which is of type ""R2R_0"" in 1st dimension and ""R2R_2"" in the 2nd.; 3274/// - option of transform flag; 3275/// - ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; 3276/// performance; 3277/// - ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; 3278/// - ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; 3279/// - ""EX"" (from ""exhaustive"") - the most optimal way is found; 3280/// This option should be chosen depending on how many transforms of the same size and; 3281/// type are going to be done. Planning is only done once, for the first transform of this; 3282/// size and type. Default is ""ES"".; 3283///; 3284/// Examples of valid options: ""Mag R2C M"" ""Re R2R_11"" ""Im R2C ES"" ""PH R2HC EX""; 3285 ; 3286TH1* TH1::FFT(TH1* h_output, Option_t *option); 3287{; 3288 ; 3289 Int_t ndim[3];; 3290 ndim[0] = this->GetNbinsX();; 3291 ndim[1] = this->GetNbinsY();; 3292 ndim[2] = this->GetNbinsZ();; 3293 ; 3294 TVirtualFFT *fft;; 3295 TString opt = option;; 3296 opt.ToUpper();; 3297 if (!opt.Contains(""2R"")){; 3298 if (!opt.Contains(""2C"") && !opt.Contains(""2HC"") && !opt.Contains(""DHT"")) {; 3299 //no type specified, ""R2C"" by default; 3300 opt.Append(""R2C"");; 3301 }; 3302 fft = TVirtualFFT::FFT(this->GetDimension(), ndim, opt.Da",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
Safety,avoid,avoid,"c to support the case where the same object is; 658 //added multiple times in fFunctions.; 659 //This case happens when the same object is added with different; 660 //drawing modes; 661 //In the loop below we must be careful with objects (eg TCutG) that may; 662 // have been added to the list of functions of several histograms; 663 //and may have been already deleted.; 664 while ((obj = fFunctions->First())) {; 665 while(fFunctions->Remove(obj)) { }; 666 if (ROOT::Detail::HasBeenDeleted(obj)) {; 667 break;; 668 }; 669 delete obj;; 670 obj = nullptr;; 671 }; 672 delete fFunctions;; 673 fFunctions = nullptr;; 674 }; 675 if (fDirectory) {; 676 fDirectory->Remove(this);; 677 fDirectory = nullptr;; 678 }; 679 delete fPainter;; 680 fPainter = nullptr;; 681}; 682 ; 683////////////////////////////////////////////////////////////////////////////////; 684/// Constructor for fix bin size histograms.; 685/// Creates the main histogram structure.; 686///; 687/// \param[in] name name of histogram (avoid blanks); 688/// \param[in] title histogram title.; 689/// If title is of the form `stringt;stringx;stringy;stringz`,; 690/// the histogram title is set to `stringt`,; 691/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 692/// \param[in] nbins number of bins; 693/// \param[in] xlow low edge of first bin; 694/// \param[in] xup upper edge of last bin (not included in last bin); 695 ; 696 ; 697TH1::TH1(const char *name,const char *title,Int_t nbins,Double_t xlow,Double_t xup); 698 :TNamed(name,title); 699{; 700 Build();; 701 if (nbins <= 0) {Warning(""TH1"",""nbins is <=0 - set to nbins = 1""); nbins = 1; }; 702 fXaxis.Set(nbins,xlow,xup);; 703 fNcells = fXaxis.GetNbins()+2;; 704}; 705 ; 706////////////////////////////////////////////////////////////////////////////////; 707/// Constructor for variable bin size histograms using an input array of type float.; 708/// Creates the main histogram structure.; 709///; 710/// \param[in] name name of histogram (avoid blanks);",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
Security,access,access,"Axis"", 100, 0, 1);; 188~~~; 189 The histogram title and the axis titles can be any TLatex string, and; 190 are persisted if a histogram is written to a file.; 191 ; 192 Any title can be omitted:; 193~~~ {.cpp}; 194 TH1F* h=new TH1F(""h"", ""Histogram title;;Y Axis"", 100, 0, 1);; 195 TH1F* h=new TH1F(""h"", "";;Y Axis"", 100, 0, 1);; 196~~~; 197 The method SetTitle() has the same syntax:; 198~~~ {.cpp}; 199 h->SetTitle(""Histogram title;Another X title Axis"");; 200~~~; 201Alternatively, the title of each axis can be set directly:; 202~~~ {.cpp}; 203 h->GetXaxis()->SetTitle(""X axis title"");; 204 h->GetYaxis()->SetTitle(""Y axis title"");; 205~~~; 206For bin labels see \ref binning.; 207 ; 208\anchor binning; 209## Binning; 210 ; 211\anchor fix-var; 212### Fix or variable bin size; 213 ; 214 All histogram types support either fix or variable bin sizes.; 215 2-D histograms may have fix size bins along X and variable size bins; 216 along Y or vice-versa. The functions to fill, manipulate, draw or access; 217 histograms are identical in both cases.; 218 ; 219 Each histogram always contains 3 axis objects of type TAxis: fXaxis, fYaxis and fZaxis.; 220 To access the axis parameters, use:; 221~~~ {.cpp}; 222 TAxis *xaxis = h->GetXaxis(); etc.; 223 Double_t binCenter = xaxis->GetBinCenter(bin), etc.; 224~~~; 225 See class TAxis for a description of all the access functions.; 226 The axis range is always stored internally in double precision.; 227 ; 228\anchor convention; 229### Convention for numbering bins; 230 ; 231 For all histogram types: nbins, xlow, xup; 232~~~ {.cpp}; 233 bin = 0; underflow bin; 234 bin = 1; first bin with low-edge xlow INCLUDED; 235 bin = nbins; last bin with upper-edge xup EXCLUDED; 236 bin = nbins+1; overflow bin; 237~~~; 238 In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; 239 For example, assuming a 3-D histogram with (binx, biny, binz), the function; 240~~~ {.cpp}; 241 Int_t gbin = h->GetBin(binx, biny, binz);; 242~~~; 243 returns a glob",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
Testability,test,test,"38 ; 539 The following statements create a ROOT file and store a histogram; 540 on the file. Because TH1 derives from TNamed, the key identifier on; 541 the file is the histogram name:; 542~~~ {.cpp}; 543 TFile f(""histos.root"", ""new"");; 544 TH1F h1(""hgaus"", ""histo from a gaussian"", 100, -3, 3);; 545 h1.FillRandom(""gaus"", 10000);; 546 h1->Write();; 547~~~; 548 To read this histogram in another Root session, do:; 549~~~ {.cpp}; 550 TFile f(""histos.root"");; 551 TH1F *h = (TH1F*)f.Get(""hgaus"");; 552~~~; 553 One can save all histograms in memory to the file by:; 554~~~ {.cpp}; 555 file->Write();; 556~~~; 557 ; 558 ; 559\anchor misc; 560## Miscellaneous operations; 561 ; 562~~~ {.cpp}; 563 TH1::KolmogorovTest(): statistical test of compatibility in shape; 564 between two histograms; 565 TH1::Smooth() smooths the bin contents of a 1-d histogram; 566 TH1::Integral() returns the integral of bin contents in a given bin range; 567 TH1::GetMean(int axis) returns the mean value along axis; 568 TH1::GetStdDev(int axis) returns the sigma distribution along axis; 569 TH1::GetEntries() returns the number of entries; 570 TH1::Reset() resets the bin contents and errors of a histogram; 571~~~; 572 IMPORTANT NOTE: The returned values for GetMean and GetStdDev depend on how the; 573 histogram statistics are calculated. By default, if no range has been set, the; 574 returned values are the (unbinned) ones calculated at fill time. If a range has been; 575 set, however, the values are calculated using the bins in range; THIS IS TRUE EVEN; 576 IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset the range.; 577 To ensure that the returned values are always those of the binned data stored in the; 578 histogram, call TH1::ResetStats. See TH1::GetStats.; 579*/; 580 ; 581TF1 *gF1=nullptr; //left for back compatibility (use TVirtualFitter::GetUserFunc instead); 582 ; 583Int_t TH1::fgBufferSize = 1000;; 584Bool_t TH1::fgAddDirectory = kTRUE;; 585Bool_t TH1::fgDefaultSumw2 = kFALSE;; 5",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
Usability,usab,usable,"rom a gaussian"", 100, -3, 3);; 446 h1.FillRandom(""gaus"", 10000);; 447~~~; 448 TH1::GetRandom can be used to return a random number distributed; 449 according to the contents of a histogram.; 450 ; 451\anchor making-a-copy; 452### Making a copy of a histogram; 453 Like for any other ROOT object derived from TObject, one can use; 454 the Clone() function. This makes an identical copy of the original; 455 histogram including all associated errors and functions, e.g.:; 456~~~ {.cpp}; 457 TH1F *hnew = (TH1F*)h->Clone(""hnew"");; 458~~~; 459 ; 460\anchor normalizing; 461### Normalizing histograms; 462 ; 463 One can scale a histogram such that the bins integral is equal to; 464 the normalization parameter via TH1::Scale(Double_t norm), where norm; 465 is the desired normalization divided by the integral of the histogram.; 466 ; 467 ; 468\anchor drawing-histograms; 469## Drawing histograms; 470 ; 471 Histograms are drawn via the THistPainter class. Each histogram has; 472 a pointer to its own painter (to be usable in a multithreaded program).; 473 Many drawing options are supported.; 474 See THistPainter::Paint() for more details.; 475 ; 476 The same histogram can be drawn with different options in different pads.; 477 When a histogram drawn in a pad is deleted, the histogram is; 478 automatically removed from the pad or pads where it was drawn.; 479 If a histogram is drawn in a pad, then filled again, the new status; 480 of the histogram will be automatically shown in the pad next time; 481 the pad is updated. One does not need to redraw the histogram.; 482 To draw the current version of a histogram in a pad, one can use; 483~~~ {.cpp}; 484 h->DrawCopy();; 485~~~; 486 This makes a clone (see Clone below) of the histogram. Once the clone; 487 is drawn, the original histogram may be modified or deleted without; 488 affecting the aspect of the clone.; 489 ; 490 One can use TH1::SetMaximum() and TH1::SetMinimum() to force a particular; 491 value for the maximum or the minimum sc",MatchSource.WIKI,doc/master/TH1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html
Integrability,depend,dependency,". ROOT: hist/hist/inc/TH1.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Functions ; TH1.h File Reference. #include ""TAxis.h""; #include ""TAttLine.h""; #include ""TAttFill.h""; #include ""TAttMarker.h""; #include ""TArrayC.h""; #include ""TArrayS.h""; #include ""TArrayI.h""; #include ""TArrayL64.h""; #include ""TArrayF.h""; #include ""TArrayD.h""; #include ""Foption.h""; #include ""TVectorFfwd.h""; #include ""TVectorDfwd.h""; #include ""TFitResultPtr.h""; #include <cfloat>; #include <string>. Include dependency graph for TH1.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TH1;  TH1 is the base class of all histogram classes in ROOT. More...;  ; class  TH1C;  1-D histogram with a byte per channel (see TH1 documentation) More...;  ; class  TH1D;  1-D histogram with a double per channel (see TH1 documentation) More...;  ; class  TH1F;  1-D histogram with a float per channel (see TH1 documentation) More...;  ; class  TH1I;  1-D histogram with an int per channel (see TH1 documentation) More...;  ; class  TH1L;  1-D histogram with a long64 per channel (see TH1 documentation) More...;  ; class  TH1S;  1-D histogram with a short per channel (see TH1 documentation) More...;  . Functions; TH1C operator* (const TH1C &h1, const TH1C &h2);  Operator *. ;  ; TH1C operator* (const TH1C &h1, Double_t c1);  ; TH1D operator* (const TH1D &h1, const TH1D &h2);  Operator *. ;  ; TH1D operator* (const TH1D &h1, Double_t c1);  ; TH1F operator* (const TH1F &h1, const TH1F &h2);  Operator *. ;  ; TH1F operator* (const TH1F &h1, Double_t c1);  ; TH1I operator* (const TH1I &h1, const TH1I &h2);  Operator *. ;  ; TH1I operator* (const TH1I &h1, Double_t c1);  ; TH1L operator* (const TH1L &h1, const TH1L &h2);  Operator *. ;  ; TH1L operator* (const",MatchSource.WIKI,doc/master/TH1_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h.html
Availability,error,errors,"*******************************/; 11 ; 12#ifndef ROOT_TH1; 13#define ROOT_TH1; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TH1 //; 19// //; 20// 1-Dim histogram base class. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TAxis.h""; 25 ; 26#include ""TAttLine.h""; 27 ; 28#include ""TAttFill.h""; 29 ; 30#include ""TAttMarker.h""; 31 ; 32#include ""TArrayC.h""; 33#include ""TArrayS.h""; 34#include ""TArrayI.h""; 35#include ""TArrayL64.h""; 36#include ""TArrayF.h""; 37#include ""TArrayD.h""; 38#include ""Foption.h""; 39 ; 40#include ""TVectorFfwd.h""; 41#include ""TVectorDfwd.h""; 42 ; 43#include ""TFitResultPtr.h""; 44 ; 45#include <cfloat>; 46#include <string>; 47 ; 48class TF1;; 49class TH1D;; 50class TBrowser;; 51class TDirectory;; 52class TList;; 53class TCollection;; 54class TVirtualFFT;; 55class TVirtualHistPainter;; 56class TRandom;; 57 ; 58 ; 59class TH1 : public TNamed, public TAttLine, public TAttFill, public TAttMarker {; 60 ; 61public:; 62 ; 63 /// Enumeration specifying type of statistics for bin errors; 64 enum EBinErrorOpt {; 65 kNormal = 0, ///< Errors with Normal (Wald) approximation: errorUp=errorLow= sqrt(N); 66 kPoisson = 1 , ///< Errors from Poisson interval at 68.3% (1 sigma); 67 kPoisson2 = 2 ///< Errors from Poisson interval at 95% CL (~ 2 sigma); 68 };; 69 ; 70 /// Enumeration specifying which axes can be extended; 71 enum {; 72 kNoAxis = 0, ///< NOTE: Must always be 0 !!!; 73 kXaxis = BIT(0),; 74 kYaxis = BIT(1),; 75 kZaxis = BIT(2),; 76 kAllAxes = kXaxis | kYaxis | kZaxis; 77 };; 78 ; 79 /// Enumeration specifying the way to treat statoverflow; 80 enum EStatOverflows {; 81 kIgnore = 0, ///< Override global flag ignoring the overflows; 82 kConsider = 1, ///< Override global flag considering the overflows; 83 kNeutral = 2, ///< Adapt to the global flag; 84 };; 85 ; 86 friend class TH1Merger;; 87 ; 88protected:; 89 Int_t fNcells; ///< Number of bins(1D), c",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
Deployability,update,update,"a byte per channel (see TH1 documentation)Definition TH1.h:458; TH1C::~TH1C~TH1C() overrideDestructor.Definition TH1.cxx:9521; TH1C::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH1.cxx:9577; TH1C::operator=TH1C & operator=(const TH1C &h1)Operator =.Definition TH1.cxx:9587; TH1C::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.h:485; TH1C::TH1CTH1C()Constructor.Definition TH1.cxx:9473; TH1C::Copyvoid Copy(TObject &hnew) const overrideCopy this to newth1.Definition TH1.cxx:9559; TH1C::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH1.cxx:9538; TH1C::Resetvoid Reset(Option_t *option="""") overrideReset.Definition TH1.cxx:9567; TH1C::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.h:486; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1D::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.h:703; TH1D::~TH1D~TH1D() overrideDestructor.Definition TH1.cxx:10467; TH1D::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH1.cxx:10501; TH1D::Copyvoid Copy(TObject &hnew) const overrideCopy this to newth1.Definition TH1.cxx:10483; TH1D::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.h:704; TH1D::TH1DTH1D()Constructor.Definition TH1.cxx:10402; TH1D",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
Energy Efficiency,power,power," TH1.cxx:9707; TH1S::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH1.cxx:9724; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::~TH1~TH1() overrideHistogram default destructor.Definition TH1.cxx:643; TH1::SetLabelFontvirtual void SetLabelFont(Style_t font=62, Option_t *axis=""X"")Set font number used to draw axis labels.Definition Haxis.cxx:249; TH1::SetErrorvirtual void SetError(const Double_t *error)Replace bin errors by values in array error.Definition TH1.cxx:8951; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::FitPanelvirtual void FitPanel()Display a panel with all histogram fit options.Definition TH1.cxx:4284; TH1::fBufferDouble_t * fBuffer[fBufferSize] entry bufferDefinition TH1.h:108; TH1::AutoP2FindLimitsvirtual Int_t AutoP2FindLimits(Double_t min, Double_t max)Buffer-based estimate of the histogram range using the power of 2 algorithm.Definition TH1.cxx:1343; TH1::SetStatOverflowsvoid SetStatOverflows(EStatOverflows statOverflows)See GetStatOverflows for more information.Definition TH1.h:417; TH1::GetEffectiveEntriesvirtual Double_t GetEffectiveEntries() constNumber of effective entries of the histogram.Definition TH1.cxx:4448; TH1::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideRedefines TObject::GetObjectInfo.Definition TH1.cxx:4502; TH1::Smoothvirtual void Smooth(Int_t ntimes=1, Option_t *option="""")Smooth bin contents of this histogram.Definition TH1.cxx:6879; TH1::SetNormFactorvirtual void SetNormFactor(Double_t factor=1)Definition TH1.h:410; TH1::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn bin center for 1D histogram.Definition TH1.cxx:9141; TH1::Rebuildvirtual void Rebuild(Option_t *option="""")Using the current bin info, recompute the arrays for contents and errors.Definition TH1.cxx:7087; ",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
Integrability,rout,routine," of weight*X*X.Definition TH1.h:99; TH1::GetStdDevvirtual Double_t GetStdDev(Int_t axis=1) constReturns the Standard Deviation (Sigma).Definition TH1.cxx:7607; TH1::TH1TH1()Histogram default constructor.Definition TH1.cxx:615; TH1::TransformHistostatic TH1 * TransformHisto(TVirtualFFT *fft, TH1 *h_output, Option_t *option)For a given transform (first parameter), fills the histogram (second parameter) with the transform ou...Definition TH1.cxx:9319; TH1::UseCurrentStylevoid UseCurrentStyle() overrideCopy current attributes from/to current style.Definition TH1.cxx:7469; TH1::LabelsOptionvirtual void LabelsOption(Option_t *option=""h"", Option_t *axis=""X"")Sort bins with labels or set option(s) to draw axis with labels.Definition TH1.cxx:5382; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::fBarOffsetShort_t fBarOffset(1000*offset) for bar charts or legosDefinition TH1.h:93; TH1::Chi2TestXvirtual Double_t Chi2TestX(const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) constThe computation routine of the Chisquare test.Definition TH1.cxx:2067; TH1::CheckBinLimitsstatic bool CheckBinLimits(const TAxis *a1, const TAxis *a2)Check bin limits.Definition TH1.cxx:1541; TH1::AddBinContentvirtual void AddBinContent(Int_t bin)Increment bin content by 1.Definition TH1.cxx:1268; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associated to bin number bin.Definition TH1.cxx:9063; TH1::FitOptionsMakestatic Int_t FitOptionsMake(Option_t *option, Foption_t &Foption)Decode string choptin and fill fitOption structure.Definition TH1.cxx:4652; TH1::GetNbinsZvirtual Int_t GetNbinsZ() constDefinition TH1.h:299; TH1::GetNormFactorvirtual Double_t GetNormFactor() constDefinition TH1.h:301; TH1::GetMeanvirtual Double_t GetMean(Int_t axis=1) constFor axis = 1,2 or 3 returns the mean value of the histogram along X,Y or Z axis.Definition TH1.cxx:7535; TH1::TH1TH1(const TH1 &)=delete; TH1::GetSke",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
Modifiability,extend,extended,3% (1 sigma); 67 kPoisson2 = 2 ///< Errors from Poisson interval at 95% CL (~ 2 sigma); 68 };; 69 ; 70 /// Enumeration specifying which axes can,MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
Testability,log,log,"s& axis1, const TAxis& axis2);; 141 Bool_t IsEmpty() const;; 142 UInt_t GetAxisLabelStatus() const;; 143 ; 144 inline static Double_t AutoP2GetPower2(Double_t x, Bool_t next = kTRUE);; 145 inline static Int_t AutoP2GetBins(Int_t n);; 146 virtual Int_t AutoP2FindLimits(Double_t min, Double_t max);; 147 ; 148 virtual Double_t DoIntegral(Int_t ix1, Int_t ix2, Int_t iy1, Int_t iy2, Int_t iz1, Int_t iz2, Double_t & err,; 149 Option_t * opt, Bool_t doerr = kFALSE) const;; 150 ; 151 virtual void DoFillN(Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1);; 152 Bool_t GetStatOverflowsBehaviour() const { return EStatOverflows::kNeutral == fStatOverflows ? fgStatOverflows : EStatOverflows::kConsider == fStatOverflows; }; 153 ; 154 static bool CheckAxisLimits(const TAxis* a1, const TAxis* a2);; 155 static bool CheckBinLimits(const TAxis* a1, const TAxis* a2);; 156 static bool CheckBinLabels(const TAxis* a1, const TAxis* a2);; 157 static bool CheckEqualAxes(const TAxis* a1, const TAxis* a2);; 158 static bool CheckConsistentSubAxes(const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0);; 159 static int CheckConsistency(const TH1* h1, const TH1* h2);; 160 int LoggedInconsistency(const char* name, const TH1* h1, const TH1* h2, bool useMerge=false) const;; 161 ; 162public:; 163 /// TH1 status bits; 164 enum EStatusBits {; 165 kNoStats = BIT(9), ///< Don't draw stats box; 166 kUserContour = BIT(10), ///< User specified contour levels; 167 // kCanRebin = BIT(11), ///< FIXME DEPRECATED - to be removed, replaced by SetCanExtend / CanExtendAllAxes; 168 kLogX = BIT(15), ///< X-axis in log scale; 169 kIsZoomed = BIT(16), ///< Bit set when zooming on Y axis; 170 kNoTitle = BIT(17), ///< Don't draw the histogram title; 171 kIsAverage = BIT(18), ///< Bin contents are average (used by Add); 172 kIsNotW = BIT(19), ///< Histogram is forced to be not weighted even when the histogram is filled with weighted; 173 /// different than 1.",MatchSource.WIKI,doc/master/TH1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html
Availability,down,downloaded,". ROOT: tutorials/hist/th2polyEurope.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. th2polyEurope.C File ReferenceTutorials » Histograms tutorials. Detailed Description; This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it. ; The initial data are stored in TMultiGraphs. They represent the european countries. The histogram filling is done according to a Mercator projection, therefore the bin contains should be proportional to the real surface of the countries.; The initial data have been downloaded from: http://www.maproom.psu.edu/dcw/ This database was developed in 1991/1992 and national boundaries reflect political reality as of that time.; The script is shooting npoints (script argument) randomly over the Europe area. The number of points inside the countries should be proportional to the country surface The estimated surface is compared to the surfaces taken from wikipedia. ; Partitioning: Real Time = 1.31 seconds Cpu Time = 1.31 seconds; Filling : Real Time = 4.01 seconds Cpu Time = 4.01 seconds; THPoly Europe surface estimation error wrt wikipedia = 1.260096 per cent when using 500000 points; ; void th2polyEurope(Int_t npoints=500000); {; Int_t i,j;; Double_t lon1 = -25;; Double_t lon2 = 35;; Double_t lat1 = 34;; Double_t lat2 = 72;; Double_t R = (lat2-lat1)/(lon2-lon1);; Int_t W = 800;; Int_t H = (Int_t)(R*800);; gStyle->SetStatX(0.28);; gStyle->SetStatY(0.45);; gStyle->SetStatW(0.15);; ; // Canvas used to draw TH2Poly (the map); TCanvas *ce = new TCanvas(""ce"", ""ce"",0,0,W,H);; ce->ToggleEventStatus();; ce->SetGridx();; ce->SetGridy();; ; // Real surfaces taken from Wikipedia.; const Int_t nx = 36;; // see http://en.wikipedia.org/wiki/Area_and_population_of_European_countries; const char *countries[nx] = {; ""france"", ""spain"", ""sweden"", ""germany"", ""finland"",; ""norway"", ""poland"", ""italy"", ""yugoslavia"", ""united_kingdom"",; ""romania"", ""belarus"",""greece"", ""czechoslov",MatchSource.WIKI,doc/master/th2polyEurope_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyEurope_8C.html
Modifiability,inherit,inherits,"=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH2Poly2D Histogram with Polygonal BinsDefinition TH2Poly.h:66; TIterDefinition TCollection.h:235; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TKey::ReadObjvirtual TObject * ReadObj()To read a TObject* from the file.Definition TKey.cxx:759; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects.Definition TMultiGraph.h:34; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPad::SetGridxvoid SetGridx(Int_t value=1) overrideDefinition TPad.h:336; TPad::SetGridyvoid SetGridy(Int_t value=1) overrideDefinition TPad.h:337; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; TStyle::SetStatXvoid SetStatX(Float_t x=0)Definition TStyle.h:397; TStyle::SetStatWvoid SetStatW(Float_t w=0.19)Definition TStyle.h:399; TStyle::SetStatYvoid SetStatY(Float_t y=0)Definition TStyle.h:398; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; leglegDefinition legend1.C:34; H#define H(x, y, z)",MatchSource.WIKI,doc/master/th2polyEurope_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyEurope_8C.html
Performance,cache,cacheread," *countries[nx] = {; ""france"", ""spain"", ""sweden"", ""germany"", ""finland"",; ""norway"", ""poland"", ""italy"", ""yugoslavia"", ""united_kingdom"",; ""romania"", ""belarus"",""greece"", ""czechoslovakia"",""bulgaria"",; ""iceland"", ""hungary"",""portugal"",""austria"", ""ireland"",; ""lithuania"", ""latvia"", ""estonia"", ""denmark"", ""netherlands"",; ""switzerland"",""moldova"",""belgium"", ""albania"", ""cyprus"",; ""luxembourg"", ""andorra"",""malta"", ""liechtenstein"", ""san_marino"", ""monaco"" };; Float_t surfaces[nx] = {; 547030, 505580, 449964, 357021, 338145,; 324220, 312685, 301230, 255438, 244820,; 237500, 207600, 131940, 127711, 110910,; 103000, 93030, 89242, 83870, 70280,; 65200, 64589, 45226, 43094, 41526,; 41290, 33843, 30528, 28748, 9250,; 2586, 468, 316, 160, 61, 2};; ; TH1F *h = new TH1F(""h"",""Countries surfaces (in km^{2})"",3,0,3);; for (i=0; i<nx; i++) h->Fill(countries[i], surfaces[i]);; h->LabelsDeflate();; ; TFile::SetCacheFileDir(""."");; TFile *f;; f = TFile::Open(""http://root.cern/files/europe.root"",""cacheread"");; ; if (!f) {; printf(""Cannot access europe.root. Is internet working ?\n"");; return;; }; ; TH2Poly *p = new TH2Poly(; ""Europe"",; ""Europe (bin contents are normalized to the surfaces in km^{2})"",; lon1,lon2,lat1,lat2);; p->GetXaxis()->SetNdivisions(520);; p->GetXaxis()->SetTitle(""longitude"");; p->GetYaxis()->SetTitle(""latitude"");; ; p->SetContour(100);; ; TMultiGraph *mg;; TKey *key;; TIter nextkey(gDirectory->GetListOfKeys());; while ((key = (TKey*)nextkey())) {; TObject *obj = key->ReadObj();; if (obj->InheritsFrom(""TMultiGraph"")) {; mg = (TMultiGraph*)obj;; p->AddBin(mg);; }; }; ; TRandom r;; Double_t longitude, latitude;; Double_t x, y, pi4 = TMath::Pi()/4, alpha = TMath::Pi()/360;; ; gBenchmark->Start(""Partitioning"");; p->ChangePartition(100, 100);; gBenchmark->Show(""Partitioning"");; ; // Fill TH2Poly according to a Mercator projection.; gBenchmark->Start(""Filling"");; for (i=0; i<npoints; i++) {; longitude = r.Uniform(lon1,lon2);; latitude = r.Uniform(lat1,lat2);; x = longitude;; y = 38*TMath:",MatchSource.WIKI,doc/master/th2polyEurope_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyEurope_8C.html
Security,access,access," *countries[nx] = {; ""france"", ""spain"", ""sweden"", ""germany"", ""finland"",; ""norway"", ""poland"", ""italy"", ""yugoslavia"", ""united_kingdom"",; ""romania"", ""belarus"",""greece"", ""czechoslovakia"",""bulgaria"",; ""iceland"", ""hungary"",""portugal"",""austria"", ""ireland"",; ""lithuania"", ""latvia"", ""estonia"", ""denmark"", ""netherlands"",; ""switzerland"",""moldova"",""belgium"", ""albania"", ""cyprus"",; ""luxembourg"", ""andorra"",""malta"", ""liechtenstein"", ""san_marino"", ""monaco"" };; Float_t surfaces[nx] = {; 547030, 505580, 449964, 357021, 338145,; 324220, 312685, 301230, 255438, 244820,; 237500, 207600, 131940, 127711, 110910,; 103000, 93030, 89242, 83870, 70280,; 65200, 64589, 45226, 43094, 41526,; 41290, 33843, 30528, 28748, 9250,; 2586, 468, 316, 160, 61, 2};; ; TH1F *h = new TH1F(""h"",""Countries surfaces (in km^{2})"",3,0,3);; for (i=0; i<nx; i++) h->Fill(countries[i], surfaces[i]);; h->LabelsDeflate();; ; TFile::SetCacheFileDir(""."");; TFile *f;; f = TFile::Open(""http://root.cern/files/europe.root"",""cacheread"");; ; if (!f) {; printf(""Cannot access europe.root. Is internet working ?\n"");; return;; }; ; TH2Poly *p = new TH2Poly(; ""Europe"",; ""Europe (bin contents are normalized to the surfaces in km^{2})"",; lon1,lon2,lat1,lat2);; p->GetXaxis()->SetNdivisions(520);; p->GetXaxis()->SetTitle(""longitude"");; p->GetYaxis()->SetTitle(""latitude"");; ; p->SetContour(100);; ; TMultiGraph *mg;; TKey *key;; TIter nextkey(gDirectory->GetListOfKeys());; while ((key = (TKey*)nextkey())) {; TObject *obj = key->ReadObj();; if (obj->InheritsFrom(""TMultiGraph"")) {; mg = (TMultiGraph*)obj;; p->AddBin(mg);; }; }; ; TRandom r;; Double_t longitude, latitude;; Double_t x, y, pi4 = TMath::Pi()/4, alpha = TMath::Pi()/360;; ; gBenchmark->Start(""Partitioning"");; p->ChangePartition(100, 100);; gBenchmark->Show(""Partitioning"");; ; // Fill TH2Poly according to a Mercator projection.; gBenchmark->Start(""Filling"");; for (i=0; i<npoints; i++) {; longitude = r.Uniform(lon1,lon2);; latitude = r.Uniform(lat1,lat2);; x = longitude;; y = 38*TMath:",MatchSource.WIKI,doc/master/th2polyEurope_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyEurope_8C.html
Testability,log,logarithm,"entries.Definition TLegend.h:23; TMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects.Definition TMultiGraph.h:34; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPad::SetGridxvoid SetGridx(Int_t value=1) overrideDefinition TPad.h:336; TPad::SetGridyvoid SetGridy(Int_t value=1) overrideDefinition TPad.h:337; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; TStyle::SetStatXvoid SetStatX(Float_t x=0)Definition TStyle.h:397; TStyle::SetStatWvoid SetStatW(Float_t w=0.19)Definition TStyle.h:399; TStyle::SetStatYvoid SetStatY(Float_t y=0)Definition TStyle.h:398; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; leglegDefinition legend1.C:34; H#define H(x, y, z); TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::TanDouble_t Tan(Double_t)Returns the tangent of an angle of x radians.Definition TMath.h:600; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; surfacesDefinition surfaces.py:1; AuthorOlivier Couet ; Definition in file th2polyEurope.C. tutorialshistth2polyEurope.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/th2polyEurope_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyEurope_8C.html
Availability,down,downloaded,". ROOT: tutorials/hist/th2polyUSA.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. th2polyUSA.C File ReferenceTutorials » Histograms tutorials. Detailed Description; This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option. ; The initial data are stored in TMultiGraphs. They represent the USA map. Such histograms can be rendered in 3D using the option legogl.; The initial data have been downloaded from: http://www.maproom.psu.edu/dcw/ This database was developed in 1991/1992 and national boundaries reflect political reality as of that time.; ; void th2polyUSA(); {; Int_t i, bin;; const Int_t nx = 48;; const char *states [nx] = {; ""alabama"", ""arizona"", ""arkansas"", ""california"",; ""colorado"", ""connecticut"", ""delaware"", ""florida"",; ""georgia"", ""idaho"", ""illinois"", ""indiana"",; ""iowa"", ""kansas"", ""kentucky"", ""louisiana"",; ""maine"", ""maryland"", ""massachusetts"", ""michigan"",; ""minnesota"", ""mississippi"", ""missouri"", ""montana"",; ""nebraska"", ""nevada"", ""new_hampshire"", ""new_jersey"",; ""new_mexico"", ""new_york"", ""north_carolina"", ""north_dakota"",; ""ohio"", ""oklahoma"", ""oregon"", ""pennsylvania"",; ""rhode_island"", ""south_carolina"", ""south_dakota"", ""tennessee"",; ""texas"", ""utah"", ""vermont"", ""virginia"",; ""washington"", ""west_virginia"", ""wisconsin"", ""wyoming""; };; Double_t pop[nx] = {; 4708708, 6595778, 2889450, 36961664, 5024748, 3518288, 885122, 18537969,; 9829211, 1545801, 12910409, 6423113, 3007856, 2818747, 4314113, 4492076,; 1318301, 5699478, 6593587, 9969727, 5266214, 2951996, 5987580, 974989,; 1796619, 2643085, 1324575, 8707739, 2009671, 19541453, 9380884, 646844,; 11542645, 3687050, 3825657, 12604767, 1053209, 4561242, 812383, 6296254,; 24782302, 2784572, 621760, 7882590, 6664195, 1819777, 5654774, 544270; };; ; TCanvas *usa = new TCanvas(""USA"", ""USA"");; usa->ToggleEventStatus();; Double_t lon1 = -130;; Double_t lon2 = -65;; Double_t lat1 = 24;; Double_t lat2 = 50;; TH2Po",MatchSource.WIKI,doc/master/th2polyUSA_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyUSA_8C.html
Modifiability,inherit,inherits,"finition TDirectory.h:384; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TH2Poly2D Histogram with Polygonal BinsDefinition TH2Poly.h:66; TIterDefinition TCollection.h:235; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TKey::ReadObjvirtual TObject * ReadObj()To read a TObject* from the file.Definition TKey.cxx:759; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects.Definition TMultiGraph.h:34; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; usaDefinition civetweb.c:1823; . AuthorOlivier Couet ; Definition in file th2polyUSA.C. tutorialshistth2polyUSA.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/th2polyUSA_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyUSA_8C.html
Performance,cache,cacheDir," the population; TLatex pupulationRef(-128, 27, ""#scale[.55]{#splitline{Source:}{http://eadiv.state.wy.us/pop/st-09est.htm}}"");; pupulationRef.DrawClone();; }; f#define f(i)Definition RSha256.hxx:104; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; gDirectory#define gDirectoryDefinition TDirectory.h:384; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TH2Poly2D Histogram with Polygonal BinsDefinition TH2Poly.h:66; TIterDefinition TCollection.h:235; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TKey::ReadObjvirtual TObject * ReadObj()To read a TObject* from the file.Definition TKey.cxx:759; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects.Definition TMultiGraph.h:34; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information prin",MatchSource.WIKI,doc/master/th2polyUSA_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyUSA_8C.html
Security,access,access,"_island"", ""south_carolina"", ""south_dakota"", ""tennessee"",; ""texas"", ""utah"", ""vermont"", ""virginia"",; ""washington"", ""west_virginia"", ""wisconsin"", ""wyoming""; };; Double_t pop[nx] = {; 4708708, 6595778, 2889450, 36961664, 5024748, 3518288, 885122, 18537969,; 9829211, 1545801, 12910409, 6423113, 3007856, 2818747, 4314113, 4492076,; 1318301, 5699478, 6593587, 9969727, 5266214, 2951996, 5987580, 974989,; 1796619, 2643085, 1324575, 8707739, 2009671, 19541453, 9380884, 646844,; 11542645, 3687050, 3825657, 12604767, 1053209, 4561242, 812383, 6296254,; 24782302, 2784572, 621760, 7882590, 6664195, 1819777, 5654774, 544270; };; ; TCanvas *usa = new TCanvas(""USA"", ""USA"");; usa->ToggleEventStatus();; Double_t lon1 = -130;; Double_t lon2 = -65;; Double_t lat1 = 24;; Double_t lat2 = 50;; TH2Poly *p = new TH2Poly(""Lower48"",""Lower 48 Population (2009);Latitude;Longitude"",lon1,lon2,lat1,lat2);; ; TFile::SetCacheFileDir(""."");; TFile *f = TFile::Open(""http://root.cern/files/usa.root"", ""CACHEREAD"");; ; if (!f) {; printf(""Cannot access usa.root. Is internet working ?\n"");; return;; }; ; // Define the TH2Poly bins.; TMultiGraph *mg;; TKey *key;; TIter nextkey(gDirectory->GetListOfKeys());; while ((key = (TKey*)nextkey())) {; TObject *obj = key->ReadObj();; if (obj->InheritsFrom(""TMultiGraph"")) {; mg = (TMultiGraph*)obj;; bin = p->AddBin(mg);; }; }; ; // Fill TH2Poly, with capital letters for the states names; for (i=0; i<nx; i++) p->Fill(states[i], pop[i]);; ; gStyle->SetOptStat(0);; p->Draw(""colz textn"");; ; // Add the reference for the population; TLatex pupulationRef(-128, 27, ""#scale[.55]{#splitline{Source:}{http://eadiv.state.wy.us/pop/st-09est.htm}}"");; pupulationRef.DrawClone();; }; f#define f(i)Definition RSha256.hxx:104; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; gDirectory#define gDirectoryDefinition TDirectory.h:384; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; gStyleR__EXTERN TStyle * gStyle",MatchSource.WIKI,doc/master/th2polyUSA_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/th2polyUSA_8C.html
Availability,error,errors,"AddBinToPartition((TH2PolyBin*) obj);; 547 }; 548}; 549 ; 550////////////////////////////////////////////////////////////////////////////////; 551/// Make a complete copy of the underlying object. If 'newname' is set,; 552/// the copy's name will be set to that name.; 553 ; 554TObject* TH2Poly::Clone(const char* newname) const; 555{; 556 // TH1::Clone relies on ::Copy to implemented by the derived class.; 557 // Until this is implemented, revert to the much slower default version; 558 // (and possibly non-thread safe).; 559 ; 560 return TNamed::Clone(newname);; 561}; 562 ; 563////////////////////////////////////////////////////////////////////////////////; 564/// Clears the contents of all bins in the histogram.; 565 ; 566void TH2Poly::ClearBinContents(); 567{; 568 TIter next(fBins);; 569 TObject *obj;; 570 TH2PolyBin *bin;; 571 ; 572 // Clears the bin contents; 573 while ((obj = next())) {; 574 bin = (TH2PolyBin*) obj;; 575 bin->ClearContent();; 576 }; 577 ; 578 // Clears the statistics; 579 fTsumw = 0;; 580 fTsumw2 = 0;; 581 fTsumwx = 0;; 582 fTsumwx2 = 0;; 583 fTsumwy = 0;; 584 fTsumwy2 = 0;; 585 fEntries = 0;; 586}; 587 ; 588////////////////////////////////////////////////////////////////////////////////; 589/// Reset this histogram: contents, errors, etc.; 590 ; 591void TH2Poly::Reset(Option_t *opt); 592{; 593 TIter next(fBins);; 594 TObject *obj;; 595 TH2PolyBin *bin;; 596 ; 597 // Clears the bin contents; 598 while ((obj = next())) {; 599 bin = (TH2PolyBin*) obj;; 600 bin->ClearContent();; 601 }; 602 ; 603 TH2::Reset(opt);; 604}; 605 ; 606////////////////////////////////////////////////////////////////////////////////; 607/// Returns the bin number of the bin at the given coordinate. -1 to -9 are; 608/// the overflow and underflow bins. overflow bin -5 is the unbinned areas in; 609/// the histogram (also called ""the sea""). The third parameter can be left; 610/// blank.; 611/// The overflow/underflow bins are:; 612///~~~ {.cpp}; 613/// -1 | -2 | -3; 614/// ----",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
Deployability,update,updated,"cation is binned later.; 52 ; 53If there are two overlapping bins, the first one in the list will be incremented; 54by `Fill()`.; 55 ; 56The histogram may automatically extends its limits if a bin outside the; 57histogram limits is added. This is done when the default constructor (with no; 58arguments) is used. It generates a histogram with no limits along the X and Y; 59axis. Adding bins to it will extend it up to a proper size.; 60 ; 61`TH2Poly` implements a partitioning algorithm to speed up bins' filling; 62(see the ""Partitioning Algorithm"" section for details).; 63The partitioning algorithm divides the histogram into regions called cells.; 64The bins that each cell intersects are recorded in an array of `TList`s.; 65When a coordinate in the histogram is to be filled; the method (quickly) finds; 66which cell the coordinate belongs. It then only loops over the bins; 67intersecting that cell to find the bin the input coordinate corresponds to.; 68The partitioning of the histogram is updated continuously as each bin is added.; 69The default number of cells on each axis is 25. This number could be set to; 70another value in the constructor or adjusted later by calling the; 71`ChangePartition(Int_t, Int_t)` method. The partitioning algorithm is; 72considerably faster than the brute force algorithm (i.e. checking if each bin; 73contains the input coordinates), especially if the histogram is to be filled; 74many times.; 75 ; 76The following very simple macro shows how to build and fill a `TH2Poly`:; 77~~~ {.cpp}; 78{; 79 auto h2p = new TH2Poly();; 80 ; 81 Double_t x1[] = {0, 5, 6};; 82 Double_t y1[] = {0, 0, 5};; 83 Double_t x2[] = {0, -1, -1, 0};; 84 Double_t y2[] = {0, 0, -1, 3};; 85 Double_t x3[] = {4, 3, 0, 1, 2.4};; 86 Double_t y3[] = {4, 3.7, 1, 3.7, 2.5};; 87 ; 88 h2p->AddBin(3, x1, y1);; 89 h2p->AddBin(4, x2, y2);; 90 h2p->AddBin(5, x3, y3);; 91 ; 92 h2p->Fill(0.1, 0.01, 3);; 93 h2p->Fill(-0.5, -0.5, 7);; 94 h2p->Fill(-0.7, -0.5, 1);; 95 h2p->Fill(1, 3, 1.5);; 9",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
Energy Efficiency,reduce,reduces,"s an essential part of the `TH2Poly`; 104class. It is implemented to speed up the filling of bins.; 105 ; 106With the brute force approach, the filling is done in the following way: An; 107iterator loops over all bins in the `TH2Poly` and invokes the; 108method `IsInside()` for each of them.; 109This method checks if the input location is in that bin. If the filling; 110coordinate is inside, the bin is filled. Looping over all the bin is; 111very slow.; 112 ; 113The alternative is to divide the histogram into virtual rectangular regions; 114called ""cells"". Each cell stores the pointers of the bins intersecting it.; 115When a coordinate is to be filled, the method finds which cell the coordinate; 116falls into. Since the cells are rectangular, this can be done very quickly.; 117It then only loops over the bins associated with that cell and calls `IsInside()`; 118only on that bins. This reduces considerably the number of bins on which `IsInside()`; 119is called and therefore speed up by a huge factor the filling compare to the brute force; 120approach where `IsInside()` is called for all bins.; 121 ; 122The addition of bins to the appropriate cells is done when the bin is added; 123to the histogram. To do this, `AddBin()` calls the; 124`AddBinToPartition()` method.; 125This method adds the input bin to the partitioning matrix.; 126 ; 127The number of partition cells per axis can be specified in the constructor.; 128If it is not specified, the default value of 25 along each axis will be; 129assigned. This value was chosen because it is small enough to avoid slowing; 130down AddBin(), while being large enough to enhance Fill() by a considerable; 131amount. Regardless of how it is initialized at construction time, it can be; 132changed later with the `ChangePartition()` method.; 133`ChangePartition()` deletes the; 134old partition matrix and generates a new one with the specified number of cells; 135on each axis.; 136 ; 137The optimum number of partition cells per axis c",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
Integrability,depend,depending,"76 ; 377 // Check if the bins are the same.; 378 TList *h1pBins = h1p->GetBins();; 379 TH2PolyBin *thisBin, *h1pBin;; 380 for (bin = 1; bin <= GetNumberOfBins(); bin++) {; 381 thisBin = (TH2PolyBin *)fBins->At(bin - 1);; 382 h1pBin = (TH2PolyBin *)h1pBins->At(bin - 1);; 383 if (thisBin->GetXMin() != h1pBin->GetXMin() ||; 384 thisBin->GetXMax() != h1pBin->GetXMax() ||; 385 thisBin->GetYMin() != h1pBin->GetYMin() ||; 386 thisBin->GetYMax() != h1pBin->GetYMax()) {; 387 Error(""Add"", ""Attempt to add histograms with different bin limits"");; 388 return kFALSE;; 389 }; 390 }; 391 ; 392 ; 393 // Create Sumw2 if h1p has Sumw2 set; 394 if (fSumw2.fN == 0 && h1p->GetSumw2N() != 0) Sumw2();; 395 ; 396 // statistics can be preserved only in case of positive coefficients; 397 // otherwise with negative c1 (histogram subtraction) one risks to get negative variances; 398 Bool_t resetStats = (c1 < 0);; 399 Double_t s1[kNstat] = {0};; 400 Double_t s2[kNstat] = {0};; 401 if (!resetStats) {; 402 // need to initialize to zero s1 and s2 since; 403 // GetStats fills only used elements depending on dimension and type; 404 GetStats(s1);; 405 h1->GetStats(s2);; 406 }; 407 // get number of entries now because afterwards UpdateBinContent will change it; 408 Double_t entries = TMath::Abs( GetEntries() + c1 * h1->GetEntries() );; 409 ; 410 ; 411 // Perform the Add.; 412 Double_t factor = 1;; 413 if (h1p->GetNormFactor() != 0); 414 factor = h1p->GetNormFactor() / h1p->GetSumOfWeights();; 415 for (bin = 0; bin < fNcells; bin++) {; 416 Double_t y = this->RetrieveBinContent(bin) + c1 * h1p->RetrieveBinContent(bin);; 417 UpdateBinContent(bin, y);; 418 if (fSumw2.fN) {; 419 Double_t esq = factor * factor * h1p->GetBinErrorSqUnchecked(bin);; 420 fSumw2.fArray[bin] += c1 * c1 * factor * factor * esq;; 421 }; 422 }; 423 ; 424 // update statistics (do here to avoid changes by SetBinContent); 425 if (resetStats) {; 426 // statistics need to be reset in case coefficient are negative; 427 ResetStats();; 428 }",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
Modifiability,extend,extends,"d; 34as `TGraph`s or `TMultiGraph`s ) and contents of the polygonal; 35bin as well as several related functions.; 36 ; 37Essentially, a `TH2Poly` is a TList of `TH2PolyBin` objects; 38with methods to manipulate them.; 39 ; 40Bins are defined using one of the `AddBin()` methods. The bin definition; 41should be done before filling.; 42 ; 43The histogram can be filled with `Fill(Double_t x, Double_t y, Double_t w); 44`. `w` is the weight.; 45If no weight is specified, it is assumed to be 1.; 46 ; 47Not all histogram's area need to be binned. Filling an area without bins,; 48will falls into the overflows. Adding a bin is not retroactive; it doesn't; 49affect previous fillings. A `Fill()` call, that; 50was previously ignored due to the lack of a bin at the specified location, is; 51not reconsidered when that location is binned later.; 52 ; 53If there are two overlapping bins, the first one in the list will be incremented; 54by `Fill()`.; 55 ; 56The histogram may automatically extends its limits if a bin outside the; 57histogram limits is added. This is done when the default constructor (with no; 58arguments) is used. It generates a histogram with no limits along the X and Y; 59axis. Adding bins to it will extend it up to a proper size.; 60 ; 61`TH2Poly` implements a partitioning algorithm to speed up bins' filling; 62(see the ""Partitioning Algorithm"" section for details).; 63The partitioning algorithm divides the histogram into regions called cells.; 64The bins that each cell intersects are recorded in an array of `TList`s.; 65When a coordinate in the histogram is to be filled; the method (quickly) finds; 66which cell the coordinate belongs. It then only loops over the bins; 67intersecting that cell to find the bin the input coordinate corresponds to.; 68The partitioning of the histogram is updated continuously as each bin is added.; 69The default number of cells on each axis is 25. This number could be set to; 70another value in the constructor or adjusted later by call",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
Performance,optimiz,optimize,"lete[] newth2p.fIsEmpty;; 229 delete[] newth2p.fCompletelyInside;; 230 // allocate arrays; 231 newth2p.fCells = new TList [fNCells];; 232 newth2p.fIsEmpty = new Bool_t [fNCells]; // Empty partition; 233 newth2p.fCompletelyInside = new Bool_t [fNCells]; // Cell is completely inside bin; 234 // Initializes the flags; 235 for (int i = 0; i<fNCells; i++) {; 236 newth2p.fIsEmpty[i] = fIsEmpty[i];; 237 newth2p.fCompletelyInside[i] = fCompletelyInside[i];; 238 }; 239 // need to use Clone to copy the contained bin list; 240 delete newth2p.fBins; // in case there was something before there; 241 if (!fBins) {; 242 newth2p.fBins = nullptr;; 243 }; 244 else {; 245 newth2p.fBins = dynamic_cast<TList *>(fBins->Clone());; 246 if (!newth2p.fBins); 247 Error(""Copy"",""Error cloning the TH2Poly bin list"");; 248 else {; 249 // add bins in the fCells partition. We need to add the TH2PolyBin objects; 250 // of the new copied histograms. For this we call AddBinToPartition; 251 // we could probably optimize this by implementing a copy of the partition; 252 for (auto bin : *(newth2p.fBins)) {; 253 newth2p.AddBinToPartition(dynamic_cast<TH2PolyBin*>(bin));; 254 }; 255 }; 256 }; 257 // copy overflow contents; 258 for(int i = 0; i < kNOverflow; i++ ) {; 259 newth2p.fOverflow[i] = fOverflow[i];; 260 }; 261 // copy other data members; 262 newth2p.fFloat = fFloat;; 263 newth2p.fNewBinAdded = fNewBinAdded;; 264 newth2p.fBinContentChanged = fBinContentChanged;; 265}; 266 ; 267 ; 268////////////////////////////////////////////////////////////////////////////////; 269/// Create appropriate histogram bin.; 270/// e.g. TH2Poly creates TH2PolyBin,; 271/// TProfile2Poly creates TProfile2PolyBin; 272/// This is done so that TH2Poly::AddBin does not have to be duplicated,; 273/// but only create needs to be reimplemented for additional histogram types; 274 ; 275TH2PolyBin *TH2Poly::CreateBin(TObject *poly); 276{; 277 if (!poly) return nullptr;; 278 ; 279 if (fBins == nullptr) {; 280 fBins = new TList();; 281",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
Safety,avoid,avoid,"ins intersecting it.; 115When a coordinate is to be filled, the method finds which cell the coordinate; 116falls into. Since the cells are rectangular, this can be done very quickly.; 117It then only loops over the bins associated with that cell and calls `IsInside()`; 118only on that bins. This reduces considerably the number of bins on which `IsInside()`; 119is called and therefore speed up by a huge factor the filling compare to the brute force; 120approach where `IsInside()` is called for all bins.; 121 ; 122The addition of bins to the appropriate cells is done when the bin is added; 123to the histogram. To do this, `AddBin()` calls the; 124`AddBinToPartition()` method.; 125This method adds the input bin to the partitioning matrix.; 126 ; 127The number of partition cells per axis can be specified in the constructor.; 128If it is not specified, the default value of 25 along each axis will be; 129assigned. This value was chosen because it is small enough to avoid slowing; 130down AddBin(), while being large enough to enhance Fill() by a considerable; 131amount. Regardless of how it is initialized at construction time, it can be; 132changed later with the `ChangePartition()` method.; 133`ChangePartition()` deletes the; 134old partition matrix and generates a new one with the specified number of cells; 135on each axis.; 136 ; 137The optimum number of partition cells per axis changes with the number of; 138times `Fill()` will be called. Although partitioning greatly speeds up; 139filling, it also adds a constant time delay into the code. When `Fill()`; 140is to be called many times, it is more efficient to divide the histogram into; 141a large number cells. However, if the histogram is to be filled only a few; 142times, it is better to divide into a small number of cells.; 143*/; 144 ; 145////////////////////////////////////////////////////////////////////////////////; 146/// Default Constructor. No boundaries specified.; 147 ; 148TH2Poly::TH2Poly(); 149{; 150 Initia",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
Testability,assert,assert," coordinates belong to; 700 Int_t n = (Int_t)(floor((x-fXaxis.GetXmin())/fStepX));; 701 Int_t m = (Int_t)(floor((y-fYaxis.GetXmin())/fStepY));; 702 ; 703 // Make sure the array indices are correct.; 704 if (n>=fCellX) n = fCellX-1;; 705 if (m>=fCellY) m = fCellY-1;; 706 if (n<0) n = 0;; 707 if (m<0) m = 0;; 708 ; 709 if (fIsEmpty[n+fCellX*m]) {; 710 fOverflow[4]+= w;; 711 if (fSumw2.fN) fSumw2.fArray[4] += w*w;; 712 return -5;; 713 }; 714 ; 715 TH2PolyBin *bin;; 716 Int_t bi;; 717 ; 718 TIter next(&fCells[n+fCellX*m]);; 719 TObject *obj;; 720 ; 721 while ((obj=next())) {; 722 bin = (TH2PolyBin*)obj;; 723 // needs to account offset in array for overflow bins; 724 bi = bin->GetBinNumber()-1+kNOverflow;; 725 if (bin->IsInside(x,y)) {; 726 bin->Fill(w);; 727 ; 728 // Statistics; 729 fTsumw = fTsumw + w;; 730 fTsumw2 = fTsumw2 + w*w;; 731 fTsumwx = fTsumwx + w*x;; 732 fTsumwx2 = fTsumwx2 + w*x*x;; 733 fTsumwy = fTsumwy + w*y;; 734 fTsumwy2 = fTsumwy2 + w*y*y;; 735 if (fSumw2.fN) {; 736 assert(bi < fSumw2.fN);; 737 fSumw2.fArray[bi] += w*w;; 738 }; 739 fEntries++;; 740 ; 741 SetBinContentChanged(kTRUE);; 742 ; 743 return bin->GetBinNumber();; 744 }; 745 }; 746 ; 747 fOverflow[4]+= w;; 748 if (fSumw2.fN) fSumw2.fArray[4] += w*w;; 749 return -5;; 750}; 751 ; 752////////////////////////////////////////////////////////////////////////////////; 753/// Increment the bin named ""name"" by w.; 754 ; 755Int_t TH2Poly::Fill(const char* name, Double_t w); 756{; 757 TString sname(name);; 758 ; 759 TIter next(fBins);; 760 TObject *obj;; 761 TH2PolyBin *bin;; 762 ; 763 while ((obj = next())) {; 764 bin = (TH2PolyBin*) obj;; 765 if (!sname.CompareTo(bin->GetPolygon()->GetName())) {; 766 bin->Fill(w);; 767 fEntries++;; 768 SetBinContentChanged(kTRUE);; 769 return bin->GetBinNumber();; 770 }; 771 }; 772 ; 773 return 0;; 774}; 775 ; 776////////////////////////////////////////////////////////////////////////////////; 777/// Fills a 2-D histogram with an array of values and weights.; 778///; 7",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
Usability,simpl,simple,"niz Gunceler, Danilo Piparo; 4 ; 5/*************************************************************************; 6 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 7 * All rights reserved. *; 8 * *; 9 * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 *************************************************************************/; 12 ; 13#include ""TH2Poly.h""; 14#include ""TMultiGraph.h""; 15#include ""TGraph.h""; 16#include ""TInterpreter.h""; 17#include ""Riostream.h""; 18#include ""TList.h""; 19#include ""TMath.h""; 20#include <cassert>; 21 ; 22ClassImp(TH2Poly);; 23 ; 24/** \class TH2Poly; 25 \ingroup Histograms; 262D Histogram with Polygonal Bins; 27 ; 28## Overview; 29`TH2Poly` is a 2D Histogram class (TH2) allowing to define polygonal; 30bins of arbitrary shape.; 31 ; 32Each bin in the `TH2Poly` histogram is a `TH2PolyBin` object.; 33`TH2PolyBin` is a very simple class containing the vertices (stored; 34as `TGraph`s or `TMultiGraph`s ) and contents of the polygonal; 35bin as well as several related functions.; 36 ; 37Essentially, a `TH2Poly` is a TList of `TH2PolyBin` objects; 38with methods to manipulate them.; 39 ; 40Bins are defined using one of the `AddBin()` methods. The bin definition; 41should be done before filling.; 42 ; 43The histogram can be filled with `Fill(Double_t x, Double_t y, Double_t w); 44`. `w` is the weight.; 45If no weight is specified, it is assumed to be 1.; 46 ; 47Not all histogram's area need to be binned. Filling an area without bins,; 48will falls into the overflows. Adding a bin is not retroactive; it doesn't; 49affect previous fillings. A `Fill()` call, that; 50was previously ignored due to the lack of a bin at the specified location, is; 51not reconsidered when that location is binned later.; 52 ; 53If there are two overlapping bins, the first one in the list will be incremented; 54by `Fill()`.; 55 ; 56The histogram may automatically extends its limits if a bin outside",MatchSource.WIKI,doc/master/TH2Poly_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html
Availability,error,error,"return fBinContentChanged;}; 104 Double_t GetBinError(Int_t bin) const override;; 105 const char *GetBinName(Int_t bin) const;; 106 const char *GetBinTitle(Int_t bin) const;; 107 Bool_t GetFloat(){return fFloat;}; 108 Double_t GetMaximum() const;; 109 Double_t GetMaximum(Double_t maxval) const override;; 110 Double_t GetMinimum() const;; 111 Double_t GetMinimum(Double_t minval) const override;; 112 Bool_t GetNewBinAdded() const{return fNewBinAdded;}; 113 Int_t GetNumberOfBins() const;; 114 void Honeycomb(Double_t xstart, Double_t ystart, Double_t a, Int_t k, Int_t s, Option_t* option = ""v"");; 115 Double_t Integral(Option_t* option = """") const override;; 116 Long64_t Merge(TCollection *) override;; 117 void Reset(Option_t *option) override;; 118 void Scale(Double_t c1 = 1, Option_t* option = """") override;; 119 void SavePrimitive(std::ostream& out, Option_t* option = """") override;; 120 void SetBinContent(Int_t bin, Double_t content) override;; 121 void SetBinError(Int_t bin, Double_t error) override;; 122 void SetBinContentChanged(Bool_t flag){fBinContentChanged = flag;}; 123 void SetFloat(Bool_t flag = true);; 124 void SetNewBinAdded(Bool_t flag){fNewBinAdded = flag;}; 125 Bool_t IsInsideBin(Int_t binnr, Double_t x, Double_t y);; 126 void GetStats(Double_t *stats) const override;; 127 ; 128 ; 129protected:; 130 ; 131 //functions not to be used for TH2Poly; 132 ; 133 Int_t Fill(Double_t) override{return -1;} ///< NOT IMPLEMENTED for TH2Poly; 134 Int_t Fill(Double_t , const char *, Double_t) override{return -1;} ///< NOT IMPLEMENTED for TH2Poly; 135 Int_t Fill(const char *, Double_t , Double_t ) override{return -1;} ///< NOT IMPLEMENTED for TH2Poly; 136 Int_t Fill(const char *, const char *, Double_t ) override{return -1;} ///< NOT IMPLEMENTED for TH2Poly; 137 void FillN(Int_t, const Double_t*, const Double_t*, Int_t) override{return;} ///< NOT IMPLEMENTED for TH2Poly; 138 ; 139 Double_t Integral(Int_t, Int_t, const Option_t*) const override{return 0;} ///< NOT IMPLEME",MatchSource.WIKI,doc/master/TH2Poly_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8h_source.html
Deployability,update,update,"n::GetXMaxDouble_t GetXMax()Returns the maximum value for the x coordinates of the bin.Definition TH2Poly.cxx:1529; TH2PolyBin::GetContentDouble_t GetContent() constDefinition TH2Poly.h:35; TH2PolyBin::fYminDouble_t fYminY minimum value.Definition TH2Poly.h:54; TH2PolyBin::SetChangedvoid SetChanged(Bool_t flag)Definition TH2Poly.h:44; TH2PolyBin::GetBinNumberInt_t GetBinNumber() constDefinition TH2Poly.h:37; TH2PolyBin::fXminDouble_t fXminX minimum value.Definition TH2Poly.h:53; TH2PolyBin::GetPolygonTObject * GetPolygon() constDefinition TH2Poly.h:38; TH2PolyBin::fPolyTObject * fPolyObject holding the polygon definition.Definition TH2Poly.h:50; TH2PolyBin::fChangedBool_t fChangedFor the 3D Painter.Definition TH2Poly.h:48; TH2Poly2D Histogram with Polygonal BinsDefinition TH2Poly.h:66; TH2Poly::MultiplyBool_t Multiply(TF1 *, Double_t) overrideNOT IMPLEMENTED for TH2Poly.Definition TH2Poly.cxx:1721; TH2Poly::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH2Poly.h:180; TH2Poly::GetBinErrorDouble_t GetBinError(Int_t, Int_t) const overrideNOT IMPLEMENTED for TH2Poly.Definition TH2Poly.h:146; TH2Poly::operator=TH2Poly & operator=(const TH2Poly &rhs)Assignment operator.Definition TH2Poly.cxx:203; TH2Poly::GetBinsTList * GetBins()Returns the TList of all bins in the histogram.Definition TH2Poly.h:101; TH2Poly::ClearBinContentsvoid ClearBinContents()Clears the contents of all bins in the histogram.Definition TH2Poly.cxx:566; TH2Poly::fOverflowDouble_t fOverflow[kNOverflow]Overflow bins.Definition TH2Poly.h:159; TH2Poly::kNOverflow@ kNOverflowDefinition TH2Poly.h:157; TH2Poly::fFloatBool_t fFloatWhen set to kTRUE, allows the histogram to expand if a bin outside the limits is added.Definition TH2Poly.h:167; TH2Poly::FillInt_t Fill(const char *, Double_t, Double_t) overrideNOT IMPLEMENTED for TH2Poly.Definition TH2Poly.h:135; TH2Poly::",MatchSource.WIKI,doc/master/TH2Poly_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2Poly_8h_source.html
Availability,mask,mask,"e of the sum of squares of; 546/// weights is automatically triggered and the sum of the squares of weights is incremented; 547/// by w^2 in the bin corresponding to namex,y; 548///; 549/// The function returns the corresponding global bin number which has its content; 550/// incremented by w; 551 ; 552Int_t TH2::Fill(const char *namex, Double_t y, Double_t w); 553{; 554 Int_t binx, biny, bin;; 555 fEntries++;; 556 binx = fXaxis.FindBin(namex);; 557 biny = fYaxis.FindBin(y);; 558 if (binx <0 || biny <0) return -1;; 559 bin = biny*(fXaxis.GetNbins()+2) + binx;; 560 if (!fSumw2.fN && w != 1.0 && !TestBit(TH1::kIsNotW)) Sumw2(); // must be called before AddBinContent; 561 if (fSumw2.fN) fSumw2.fArray[bin] += w*w;; 562 AddBinContent(bin,w);; 563 if (binx == 0 || binx > fXaxis.GetNbins()) return -1;; 564 if (biny == 0 || biny > fYaxis.GetNbins()) {; 565 if (!GetStatOverflowsBehaviour()) return -1;; 566 }; 567 Double_t z= w; //(w > 0 ? w : -w);; 568 fTsumw += z;; 569 fTsumw2 += z*z;; 570 fTsumwy += z*y;; 571 fTsumwy2 += z*y*y;; 572 // skip statistics along x axis, for only one axis no need to use bit mask from GetAxisLabelStatus; 573 if (!fXaxis.CanExtend() || !fXaxis.IsAlphanumeric()) {; 574 Double_t x = fXaxis.GetBinCenter(binx);; 575 fTsumwx += z * x;; 576 fTsumwx2 += z * x * x;; 577 fTsumwxy += z * x * y;; 578 }; 579 return bin;; 580}; 581 ; 582 ; 583////////////////////////////////////////////////////////////////////////////////; 584/// Increment cell defined by x,namey by a weight w; 585///; 586/// - if x or/and y is less than the low-edge of the corresponding axis first bin,; 587/// the Underflow cell is incremented.; 588/// - if x or/and y is equal to or greater than the upper edge of corresponding axis last bin,; 589/// the Overflow cell is incremented.; 590///; 591/// - If the weight is not equal to 1, the storage of the sum of squares of; 592/// weights is automatically triggered and the sum of the squares of weights is incremented; 593/// by w^2 in the bin cor",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
Deployability,integrat,integrated,"0) continue;; 673 bin = biny*(fXaxis.GetNbins()+2) + binx;; 674 if (w) ww = w[i];; 675 if (!fSumw2.fN && ww != 1.0 && !TestBit(TH1::kIsNotW)) Sumw2();; 676 if (fSumw2.fN) fSumw2.fArray[bin] += ww*ww;; 677 AddBinContent(bin,ww);; 678 if (binx == 0 || binx > fXaxis.GetNbins()) {; 679 if (!GetStatOverflowsBehaviour()) continue;; 680 }; 681 if (biny == 0 || biny > fYaxis.GetNbins()) {; 682 if (!GetStatOverflowsBehaviour()) continue;; 683 }; 684 Double_t z= ww; //(ww > 0 ? ww : -ww);; 685 fTsumw += z;; 686 fTsumw2 += z*z;; 687 fTsumwx += z*x[i];; 688 fTsumwx2 += z*x[i]*x[i];; 689 fTsumwy += z*y[i];; 690 fTsumwy2 += z*y[i]*y[i];; 691 fTsumwxy += z*x[i]*y[i];; 692 }; 693}; 694 ; 695 ; 696////////////////////////////////////////////////////////////////////////////////; 697/// Fill histogram following distribution in function fname.; 698///; 699/// @param fname : Function name used for filling the histogram; 700/// @param ntimes : number of times the histogram is filled; 701/// @param rng : (optional) Random number generator used to sample; 702///; 703/// The distribution contained in the function fname (TF2) is integrated; 704/// over the channel contents.; 705/// It is normalized to 1.; 706/// Getting one random number implies:; 707/// - Generating a random number between 0 and 1 (say r1); 708/// - Look in which bin in the normalized integral r1 corresponds to; 709/// - Fill histogram channel; 710/// ntimes random numbers are generated; 711///; 712/// One can also call TF2::GetRandom2 to get a random variate from a function.; 713 ; 714void TH2::FillRandom(const char *fname, Int_t ntimes, TRandom * rng); 715{; 716 Int_t bin, binx, biny, ibin, loop;; 717 Double_t r1, x, y;; 718 //*-*- Search for fname in the list of ROOT defined functions; 719 TObject *fobj = gROOT->GetFunction(fname);; 720 if (!fobj) { Error(""FillRandom"", ""Unknown function: %s"",fname); return; }; 721 TF2 * f1 = dynamic_cast<TF2*>(fobj);; 722 if (!f1) { Error(""FillRandom"", ""Function: %s is not a TF2, is a %s""",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
Energy Efficiency,adapt,adapted,"2, using Kolmogorov test.; 1450/// Default: Ignore under- and overflow bins in comparison; 1451///; 1452/// option is a character string to specify options; 1453/// - ""U"" include Underflows in test; 1454/// - ""O"" include Overflows; 1455/// - ""N"" include comparison of normalizations; 1456/// - ""D"" Put out a line of ""Debug"" printout; 1457/// - ""M"" Return the Maximum Kolmogorov distance instead of prob; 1458///; 1459/// The returned function value is the probability of test; 1460/// (much less than one means NOT compatible); 1461///; 1462/// The KS test uses the distance between the pseudo-CDF's obtained; 1463/// from the histogram. Since in 2D the order for generating the pseudo-CDF is; 1464/// arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; 1465/// other from the y axis and the maximum distance is the average of the two maximum; 1466/// distances obtained.; 1467///; 1468/// Code adapted by Rene Brun from original HBOOK routine HDIFF; 1469 ; 1470Double_t TH2::KolmogorovTest(const TH1 *h2, Option_t *option) const; 1471{; 1472 TString opt = option;; 1473 opt.ToUpper();; 1474 ; 1475 Double_t prb = 0;; 1476 TH1 *h1 = (TH1*)this;; 1477 if (h2 == nullptr) return 0;; 1478 const TAxis *xaxis1 = h1->GetXaxis();; 1479 const TAxis *xaxis2 = h2->GetXaxis();; 1480 const TAxis *yaxis1 = h1->GetYaxis();; 1481 const TAxis *yaxis2 = h2->GetYaxis();; 1482 Int_t ncx1 = xaxis1->GetNbins();; 1483 Int_t ncx2 = xaxis2->GetNbins();; 1484 Int_t ncy1 = yaxis1->GetNbins();; 1485 Int_t ncy2 = yaxis2->GetNbins();; 1486 ; 1487 // Check consistency of dimensions; 1488 if (h1->GetDimension() != 2 || h2->GetDimension() != 2) {; 1489 Error(""KolmogorovTest"",""Histograms must be 2-D\n"");; 1490 return 0;; 1491 }; 1492 ; 1493 // Check consistency in number of channels; 1494 if (ncx1 != ncx2) {; 1495 Error(""KolmogorovTest"",""Number of channels in X is different, %d and %d\n"",ncx1,ncx2);; 1496 return 0;; 1497 }; 1498 if (ncy1 != ncy2) {; 1499 Error(""KolmogorovTest"",""Number of ch",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
Integrability,integrat,integrated,"0) continue;; 673 bin = biny*(fXaxis.GetNbins()+2) + binx;; 674 if (w) ww = w[i];; 675 if (!fSumw2.fN && ww != 1.0 && !TestBit(TH1::kIsNotW)) Sumw2();; 676 if (fSumw2.fN) fSumw2.fArray[bin] += ww*ww;; 677 AddBinContent(bin,ww);; 678 if (binx == 0 || binx > fXaxis.GetNbins()) {; 679 if (!GetStatOverflowsBehaviour()) continue;; 680 }; 681 if (biny == 0 || biny > fYaxis.GetNbins()) {; 682 if (!GetStatOverflowsBehaviour()) continue;; 683 }; 684 Double_t z= ww; //(ww > 0 ? ww : -ww);; 685 fTsumw += z;; 686 fTsumw2 += z*z;; 687 fTsumwx += z*x[i];; 688 fTsumwx2 += z*x[i]*x[i];; 689 fTsumwy += z*y[i];; 690 fTsumwy2 += z*y[i]*y[i];; 691 fTsumwxy += z*x[i]*y[i];; 692 }; 693}; 694 ; 695 ; 696////////////////////////////////////////////////////////////////////////////////; 697/// Fill histogram following distribution in function fname.; 698///; 699/// @param fname : Function name used for filling the histogram; 700/// @param ntimes : number of times the histogram is filled; 701/// @param rng : (optional) Random number generator used to sample; 702///; 703/// The distribution contained in the function fname (TF2) is integrated; 704/// over the channel contents.; 705/// It is normalized to 1.; 706/// Getting one random number implies:; 707/// - Generating a random number between 0 and 1 (say r1); 708/// - Look in which bin in the normalized integral r1 corresponds to; 709/// - Fill histogram channel; 710/// ntimes random numbers are generated; 711///; 712/// One can also call TF2::GetRandom2 to get a random variate from a function.; 713 ; 714void TH2::FillRandom(const char *fname, Int_t ntimes, TRandom * rng); 715{; 716 Int_t bin, binx, biny, ibin, loop;; 717 Double_t r1, x, y;; 718 //*-*- Search for fname in the list of ROOT defined functions; 719 TObject *fobj = gROOT->GetFunction(fname);; 720 if (!fobj) { Error(""FillRandom"", ""Unknown function: %s"",fname); return; }; 721 TF2 * f1 = dynamic_cast<TF2*>(fobj);; 722 if (!f1) { Error(""FillRandom"", ""Function: %s is not a TF2, is a %s""",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
Modifiability,variab,variable,"43\class TH2F; 44\brief 2-D histogram with a float per channel (see TH1 documentation); 45\class TH2D; 46\brief 2-D histogram with a double per channel (see TH1 documentation); 47@}; 48*/; 49 ; 50/** \class TH2; 51 Service class for 2-D histogram classes; 52 ; 53- TH2C a 2-D histogram with one byte per cell (char). Maximum bin content = 127; 54- TH2S a 2-D histogram with two bytes per cell (short integer). Maximum bin content = 32767; 55- TH2I a 2-D histogram with four bytes per cell (32 bit integer). Maximum bin content = INT_MAX (\ref intmax2 ""*""); 56- TH2L a 2-D histogram with eight bytes per cell (64 bit integer). Maximum bin content = LLONG_MAX (\ref llongmax2 ""**""); 57- TH2F a 2-D histogram with four bytes per cell (float). Maximum precision 7 digits, maximum integer bin content = +/-16777216 (\ref floatmax2 ""***""); 58- TH2D a 2-D histogram with eight bytes per cell (double). Maximum precision 14 digits, maximum integer bin content = +/-9007199254740992 (\ref doublemax2 ""****""); 59 ; 60<sup>; 61\anchor intmax2 (*) INT_MAX = 2147483647 is the [maximum value for a variable of type int.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 62\anchor llongmax2 (**) LLONG_MAX = 9223372036854775807 is the [maximum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 63\anchor floatmax2 (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br>; 64\anchor doublemax2 (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760); 65</sup>; 66 ; 67*/; 68 ; 69 ; 70////////////////////////////////////////////////////////////////////////////////; 71/// 2-D histogram default constructor.; 72 ; 73TH2::TH2(); 74{; 75 fDimension = 2;; 76 fScalefactor = 1;; 77 fTsumwy = fTsumwy2 = fTsumwxy = ",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
Performance,perform,performing,"nd a NULL pointer is returned.; 2147///; 2148/// NOTE that the Y axis attributes of the TH2 are copied to the X axis of the profile.; 2149///; 2150/// NOTE that the default under- / overflow behavior differs from what ProjectionX; 2151/// does! Profiles take the bin center into account, so here the under- and overflow; 2152/// bins are ignored by default.; 2153///; 2154/// NOTE that the return profile histogram is computed using the X bin center values instead of; 2155/// the real X values which are used to fill the 2d histogram. Therefore the obtained profile is just an approximation of the; 2156/// correct profile histogram that would be obtained when filling it directly with the original data (see ROOT-7770); 2157 ; 2158 ; 2159TProfile *TH2::ProfileY(const char *name, Int_t firstxbin, Int_t lastxbin, Option_t *option) const; 2160{; 2161 return DoProfile(false, name, firstxbin, lastxbin, option);; 2162}; 2163 ; 2164 ; 2165////////////////////////////////////////////////////////////////////////////////; 2166/// Internal (protected) method for performing projection on the X or Y axis; 2167/// called by ProjectionX or ProjectionY; 2168 ; 2169TH1D *TH2::DoProjection(bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) const; 2170{; 2171 const char *expectedName = nullptr;; 2172 Int_t inNbin;; 2173 const TAxis* outAxis;; 2174 const TAxis* inAxis;; 2175 ; 2176 TString opt = option;; 2177 TString cut;; 2178 Int_t i1 = opt.Index(""["");; 2179 if (i1>=0) {; 2180 Int_t i2 = opt.Index(""]"");; 2181 cut = opt(i1,i2-i1+1);; 2182 }; 2183 opt.ToLower(); //must be called after having parsed the cut name; 2184 bool originalRange = opt.Contains(""o"");; 2185 ; 2186 if ( onX ); 2187 {; 2188 expectedName = ""_px"";; 2189 inNbin = fYaxis.GetNbins();; 2190 outAxis = GetXaxis();; 2191 inAxis = GetYaxis();; 2192 }; 2193 else; 2194 {; 2195 expectedName = ""_py"";; 2196 inNbin = fXaxis.GetNbins();; 2197 outAxis = GetYaxis();; 2198 inAxis = GetXaxis();; 2199 }; 2200 ; 2201 // ",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
Safety,avoid,avoid,"mum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 63\anchor floatmax2 (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br>; 64\anchor doublemax2 (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760); 65</sup>; 66 ; 67*/; 68 ; 69 ; 70////////////////////////////////////////////////////////////////////////////////; 71/// 2-D histogram default constructor.; 72 ; 73TH2::TH2(); 74{; 75 fDimension = 2;; 76 fScalefactor = 1;; 77 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 78}; 79 ; 80 ; 81////////////////////////////////////////////////////////////////////////////////; 82/// Constructor for fix bin size 2-D histograms.; 83/// Creates the main histogram structure.; 84///; 85/// \param[in] name name of histogram (avoid blanks); 86/// \param[in] title histogram title.; 87/// If title is of the form `stringt;stringx;stringy;stringz`,; 88/// the histogram title is set to `stringt`,; 89/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 90/// \param[in] nbinsx number of bins along the X axis; 91/// \param[in] xlow low edge of the X axis first bin; 92/// \param[in] xup upper edge of the X axis last bin (not included in last bin); 93/// \param[in] nbinsy number of bins along the Y axis; 94/// \param[in] ylow low edge of the Y axis first bin; 95/// \param[in] yup upper edge of the Y axis last bin (not included in last bin); 96 ; 97TH2::TH2(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 98 ,Int_t nbinsy,Double_t ylow,Double_t yup); 99 :TH1(name,title,nbinsx,xlow,xup); 100{; 101 fDimension = 2;; 102 fScalefactor = 1;; 103 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 104 if (nbinsy <= 0) {Warning(""TH2"",""nbinsy is <=0 - set to nbinsy = 1""); nbinsy = 1; }; 105 fYaxis.S",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
Security,access,access,"rameters) contains the chi2 distribution of; 991/// the fits.; 992///; 993/// If arr is NULL, the generated histograms are added to the list of objects; 994/// in the current directory. It is the user's responsibility to delete; 995/// these histograms.; 996///; 997/// Example: Assume a 2-d histogram h2; 998/// ~~~ {.cpp}; 999/// Root > h2->FitSlicesX(); produces 4 TH1D histograms; 1000/// with h2_0 containing parameter 0(Constant) for a Gaus fit; 1001/// of each bin in Y projected along X; 1002/// with h2_1 containing parameter 1(Mean) for a gaus fit; 1003/// with h2_2 containing parameter 2(StdDev) for a gaus fit; 1004/// with h2_chi2 containing the chisquare/number of degrees of freedom for a gaus fit; 1005///; 1006/// Root > h2->FitSlicesX(0,15,22,10);; 1007/// same as above, but only for bins 15 to 22 along Y; 1008/// and only for bins in Y for which the corresponding projection; 1009/// along X has more than cut bins filled.; 1010/// ~~~; 1011/// NOTE: To access the generated histograms in the current directory, do eg:; 1012/// ~~~ {.cpp}; 1013/// TH1D *h2_1 = (TH1D*)gDirectory->Get(""h2_1"");; 1014/// ~~~; 1015 ; 1016void TH2::FitSlicesX(TF1 *f1, Int_t firstybin, Int_t lastybin, Int_t cut, Option_t *option, TObjArray* arr); 1017{; 1018 DoFitSlices(true, f1, firstybin, lastybin, cut, option, arr);; 1019 ; 1020}; 1021 ; 1022 ; 1023////////////////////////////////////////////////////////////////////////////////; 1024/// Project slices along Y in case of a 2-D histogram, then fit each slice; 1025/// with function f1 and make a histogram for each fit parameter; 1026/// Only bins along X between firstxbin and lastxbin are considered.; 1027/// By default (firstxbin == 0, lastxbin == -1), all bins in x including; 1028/// over- and underflows are taken into account.; 1029/// If f1=0, a gaussian is assumed; 1030/// Before invoking this function, one can set a subrange to be fitted along Y; 1031/// via f1->SetRange(ymin,ymax); 1032/// The argument option (default=""QNR"") c",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
Testability,test,test,"f(bin_x2>GetNbinsX()) bin_x2=GetNbinsX();; 1419 Int_t bin_y1 = fYaxis.FindFixBin(y1);; 1420 if(bin_y1<1) bin_y1=1;; 1421 Int_t bin_y2 = fYaxis.FindFixBin(y2);; 1422 if(bin_y2>GetNbinsY()) bin_y2=GetNbinsY();; 1423 Int_t bin_q22 = GetBin(bin_x2,bin_y2);; 1424 Int_t bin_q12 = GetBin(bin_x1,bin_y2);; 1425 Int_t bin_q11 = GetBin(bin_x1,bin_y1);; 1426 Int_t bin_q21 = GetBin(bin_x2,bin_y1);; 1427 Double_t q11 = RetrieveBinContent(bin_q11);; 1428 Double_t q12 = RetrieveBinContent(bin_q12);; 1429 Double_t q21 = RetrieveBinContent(bin_q21);; 1430 Double_t q22 = RetrieveBinContent(bin_q22);; 1431 Double_t d = 1.0*(x2-x1)*(y2-y1);; 1432 f = 1.0*q11/d*(x2-x)*(y2-y)+1.0*q21/d*(x-x1)*(y2-y)+1.0*q12/d*(x2-x)*(y-y1)+1.0*q22/d*(x-x1)*(y-y1);; 1433 return f;; 1434}; 1435 ; 1436 ; 1437////////////////////////////////////////////////////////////////////////////////; 1438///illegal for a TH2; 1439 ; 1440Double_t TH2::Interpolate(Double_t, Double_t, Double_t) const; 1441{; 1442 Error(""Interpolate"",""This function must be called with 2 arguments for a TH2"");; 1443 return 0;; 1444}; 1445 ; 1446 ; 1447////////////////////////////////////////////////////////////////////////////////; 1448/// Statistical test of compatibility in shape between; 1449/// THIS histogram and h2, using Kolmogorov test.; 1450/// Default: Ignore under- and overflow bins in comparison; 1451///; 1452/// option is a character string to specify options; 1453/// - ""U"" include Underflows in test; 1454/// - ""O"" include Overflows; 1455/// - ""N"" include comparison of normalizations; 1456/// - ""D"" Put out a line of ""Debug"" printout; 1457/// - ""M"" Return the Maximum Kolmogorov distance instead of prob; 1458///; 1459/// The returned function value is the probability of test; 1460/// (much less than one means NOT compatible); 1461///; 1462/// The KS test uses the distance between the pseudo-CDF's obtained; 1463/// from the histogram. Since in 2D the order for generating the pseudo-CDF is; 1464/// arbitrary, two pairs of pseudo-CDF ",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
Usability,simpl,simply,"l == TMath::QuietNaN() ) { x = TMath::QuietNaN(); y = TMath::QuietNaN(); return;}; 1216 ; 1217 if (!rng) rng = gRandom;; 1218 Double_t r1 = rng->Rndm();; 1219 Int_t ibin = TMath::BinarySearch(nbins,fIntegral,(Double_t) r1);; 1220 Int_t biny = ibin/nbinsx;; 1221 Int_t binx = ibin - nbinsx*biny;; 1222 x = fXaxis.GetBinLowEdge(binx+1);; 1223 if (r1 > fIntegral[ibin]) x +=; 1224 fXaxis.GetBinWidth(binx+1)*(r1-fIntegral[ibin])/(fIntegral[ibin+1] - fIntegral[ibin]);; 1225 y = fYaxis.GetBinLowEdge(biny+1) + fYaxis.GetBinWidth(biny+1)*rng->Rndm();; 1226}; 1227 ; 1228 ; 1229////////////////////////////////////////////////////////////////////////////////; 1230/// Fill the array stats from the contents of this histogram; 1231/// The array stats must be correctly dimensioned in the calling program.; 1232/// ~~~ {.cpp}; 1233/// stats[0] = sumw; 1234/// stats[1] = sumw2; 1235/// stats[2] = sumwx; 1236/// stats[3] = sumwx2; 1237/// stats[4] = sumwy; 1238/// stats[5] = sumwy2; 1239/// stats[6] = sumwxy; 1240/// ~~~; 1241///; 1242/// If no axis-subranges are specified (via TAxis::SetRange), the array stats; 1243/// is simply a copy of the statistics quantities computed at filling time.; 1244/// If sub-ranges are specified, the function recomputes these quantities; 1245/// from the bin contents in the current axis ranges.; 1246///; 1247/// Note that the mean value/StdDev is computed using the bins in the currently; 1248/// defined ranges (see TAxis::SetRange). By default the ranges include; 1249/// all bins from 1 to nbins included, excluding underflows and overflows.; 1250/// To force the underflows and overflows in the computation, one must; 1251/// call the static function TH1::StatOverflows(kTRUE) before filling; 1252/// the histogram.; 1253 ; 1254void TH2::GetStats(Double_t *stats) const; 1255{; 1256 if (fBuffer) ((TH2*)this)->BufferEmpty();; 1257 ; 1258 if ((fTsumw == 0 && fEntries > 0) || fXaxis.TestBit(TAxis::kAxisRange) || fYaxis.TestBit(TAxis::kAxisRange)) {; 1259 std::fill",MatchSource.WIKI,doc/master/TH2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html
Integrability,depend,dependency,". ROOT: hist/hist/inc/TH2.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TH2.h File Reference. #include ""TH1.h""; #include ""TMatrixFBasefwd.h""; #include ""TMatrixDBasefwd.h"". Include dependency graph for TH2.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TH2;  Service class for 2-D histogram classes. More...;  ; class  TH2C;  2-D histogram with a byte per channel (see TH1 documentation) More...;  ; class  TH2D;  2-D histogram with a double per channel (see TH1 documentation) More...;  ; class  TH2F;  2-D histogram with a float per channel (see TH1 documentation) More...;  ; class  TH2I;  2-D histogram with an int per channel (see TH1 documentation) More...;  ; class  TH2L;  2-D histogram with a long64 per channel (see TH1 documentation) More...;  ; class  TH2S;  2-D histogram with a short per channel (see TH1 documentation) More...;  . histhistincTH2.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TH2_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8h.html
Availability,error,error,"bits per element).Definition TArrayF.h:27; TArrayF::fArrayFloat_t * fArrayDefinition TArrayF.h:30; TArrayF::Resetvoid Reset()Definition TArrayF.h:47; TArrayIArray of integers (32 bits per element).Definition TArrayI.h:27; TArrayI::fArrayInt_t * fArrayDefinition TArrayI.h:30; TArrayI::Resetvoid Reset()Definition TArrayI.h:47; TArrayL64Array of long64s (64 bits per element).Definition TArrayL64.h:27; TArrayL64::fArrayLong64_t * fArrayDefinition TArrayL64.h:30; TArrayL64::Resetvoid Reset()Definition TArrayL64.h:47; TArraySArray of shorts (16 bits per element).Definition TArrayS.h:27; TArrayS::Resetvoid Reset()Definition TArrayS.h:47; TArrayS::fArrayShort_t * fArrayDefinition TArrayS.h:30; TF11-Dim function classDefinition TF1.h:233; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2] and its error.Definition TH1.cxx:7968; TH1::GetBinErrorLowvirtual Double_t GetBinErrorLow(Int_t bin) constReturn lower error associated to bin number bin.Definition TH1.cxx:9079; TH1::Integralvirtual Double_t Integral(Option_t *option="""") constReturn integral of bin contents.Definition TH1.cxx:7941; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t bin) constReturn upper error associated to bin number bin.Definition TH1.cxx:9110; TH2C2-D histogram with a byte per channel (see TH1 documentation)Definition TH2.h:139; TH2C::operator*friend TH2C operator*(TH2C const &h1, Float_t c1)Definition TH2.h:166; TH2C::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH2.cxx:2990; TH2C::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny,",MatchSource.WIKI,doc/master/TH2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8h_source.html
Deployability,update,update," channel (see TH1 documentation)Definition TH2.h:139; TH2C::operator*friend TH2C operator*(TH2C const &h1, Float_t c1)Definition TH2.h:166; TH2C::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH2.cxx:2990; TH2C::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Double_t w) overrideIncrement 2D bin content by a weight w.Definition TH2.h:159; TH2C::operator+friend TH2C operator+(TH2C const &h1, TH2C const &h2)Operator +.Definition TH2.cxx:3070; TH2C::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH2.h:173; TH2C::operator*friend TH2C operator*(Float_t c1, TH2C const &h1)Operator *.Definition TH2.cxx:3058; TH2C::operator/friend TH2C operator/(TH2C const &h1, TH2C const &h2)Operator /.Definition TH2.cxx:3106; TH2C::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH2.h:174; TH2C::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny) overrideIncrement 2D bin content by 1.Definition TH2.h:158; TH2C::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH2.cxx:2958; TH2C::TH2CTH2C()Constructor.Definition TH2.cxx:2864; TH2C::operator=TH2C & operator=(const TH2C &h1)Operator =.Definition TH2.cxx:3047; TH2C::~TH2C~TH2C() overrideDestructor.Definition TH2.cxx:2874; TH2C::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH2.cxx:2981; TH2C::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH2.cxx:3001; TH2C::operator-friend TH2C operator-(TH2C const &h1, TH2C const &h2)Operator -.Definition TH2.cxx:3082; TH2D2-D histogram with a double per channel (see TH1 documentation)Definition TH2.h:357; TH2D::UpdateBin",MatchSource.WIKI,doc/master/TH2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8h_source.html
Modifiability,variab,variable,"cesY(TF1 *f1=nullptr, Int_t firstxbin=0, Int_t lastxbin=-1, Int_t cut=0, Option_t *option=""QNR"", TObjArray *arr=nullptr)Project slices along Y in case of a 2-D histogram, then fit each slice with function f1 and make a hi...Definition TH2.cxx:1081; TH2::GetBinWithContent2virtual Double_t GetBinWithContent2(Double_t c, Int_t &binx, Int_t &biny, Int_t firstxbin=1, Int_t lastxbin=-1, Int_t firstybin=1, Int_t lastybin=-1, Double_t maxdiff=0) constcompute first cell (binx,biny) in the range [firstxbin,lastxbin][firstybin,lastybin] for which diff =...Definition TH2.cxx:1117; TH2::ProfileXTProfile * ProfileX(const char *name=""_pfx"", Int_t firstybin=1, Int_t lastybin=-1, Option_t *option="""") constProject a 2-D histogram into a profile histogram along X.Definition TH2.cxx:2109; TH2::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH2.cxx:238; TH2::TH2TH2(const TH2 &)=delete; TH2::RebinTH2 * Rebin(Int_t ngroup=2, const char *newname="""", const Double_t *xbins=nullptr) overrideOverride TH1::Rebin as TH2::RebinX Rebinning in variable binning as for TH1 is not allowed If a non-n...Definition TH2.cxx:1663; TH2::FillNvoid FillN(Int_t, const Double_t *, const Double_t *, Int_t) overrideFill this histogram with an array x and weights w.Definition TH2.h:84; TH2::BufferFillInt_t BufferFill(Double_t, Double_t) overrideaccumulate arguments in buffer.Definition TH2.h:56; TH2::QuantilesYTH1D * QuantilesY(Double_t prob=0.5, const char *name=""_qy"") constCompute the Y distribution of quantiles in the other variable X name is the name of the returned hist...Definition TH2.cxx:2518; TH2::ProfileYTProfile * ProfileY(const char *name=""_pfy"", Int_t firstxbin=1, Int_t lastxbin=-1, Option_t *option="""") constProject a 2-D histogram into a profile histogram along Y.Definition TH2.cxx:2159; TH2::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH2.cxx:380; TH2::DoQuantilesvirtual TH1D * DoQuantiles(bool onX, const char *name, Double_t prob) constImpleme",MatchSource.WIKI,doc/master/TH2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8h_source.html
Performance,perform,performing,"tribution of quantiles in the other variable Y name is the name of the returned hist...Definition TH2.cxx:2505; TH2::SetShowProjectionYvirtual void SetShowProjectionY(Int_t nbins=1)When the mouse is moved in a pad containing a 2-d view of this histogram a second canvas shows the pr...Definition TH2.cxx:2650; TH2::SetBinContentvoid SetBinContent(Int_t binx, Int_t biny, Int_t, Double_t content) overrideDefinition TH2.h:125; TH2::FillRandomvoid FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr) overrideFill histogram following distribution in function fname.Definition TH2.cxx:714; TH2::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t binx, Int_t biny)Definition TH2.h:98; TH2::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH2.cxx:2600; TH2::fScalefactorDouble_t fScalefactorScale factor.Definition TH2.h:33; TH2::DoProjectionvirtual TH1D * DoProjection(bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) constInternal (protected) method for performing projection on the X or Y axis called by ProjectionX or Pro...Definition TH2.cxx:2169; TH2::RebinXTH2 * RebinX(Int_t ngroup=2, const char *newname="""") overrideRebin only the X axis see Rebin2D.Definition TH2.cxx:1642; TH2::fTsumwy2Double_t fTsumwy2Total Sum of weight*Y*Y.Definition TH2.h:35; TH2::GetRandom2virtual void GetRandom2(Double_t &x, Double_t &y, TRandom *rng=nullptr)Return 2 random numbers along axis x and y distributed according to the cell-contents of this 2-D his...Definition TH2.cxx:1200; TH2::SetBinContentvoid SetBinContent(Int_t binx, Int_t biny, Double_t content) overrideDefinition TH2.h:124; TH2::GetCovariancevirtual Double_t GetCovariance(Int_t axis1=1, Int_t axis2=2) constReturn covariance between axis1 and axis2.Definition TH2.cxx:1163; TH2::GetBinInt_t GetBin(Int_t binx, Int_t biny, Int_t binz=0) const overrideReturn Global bin number corresponding to binx,y,z.Definition TH2.cxx:1086; TH2::GetBinContentDoubl",MatchSource.WIKI,doc/master/TH2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8h_source.html
Testability,test,test,"onY(const char *name=""_py"", Int_t firstxbin=0, Int_t lastxbin=-1, Option_t *option="""") constProject a 2-D histogram into a 1-D histogram along Y.Definition TH2.cxx:2476; TH2::GetStatsvoid GetStats(Double_t *stats) const overrideFill the array stats from the contents of this histogram The array stats must be correctly dimensione...Definition TH2.cxx:1254; TH2::ShowPeaksInt_t ShowPeaks(Double_t sigma=2, Option_t *option="""", Double_t threshold=0.05) overrideInterface to TSpectrum2::Search the function finds peaks in this histogram where the width is > sigma...Definition TH2.cxx:2695; TH2::GetCorrelationFactorvirtual Double_t GetCorrelationFactor(Int_t axis1=1, Int_t axis2=2) constReturn correlation factor between axis1 and axis2.Definition TH2.cxx:1145; TH2::DoProfilevirtual TProfile * DoProfile(bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) constDefinition TH2.cxx:1880; TH2::KolmogorovTestDouble_t KolmogorovTest(const TH1 *h2, Option_t *option="""") const overrideStatistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test.Definition TH2.cxx:1470; TH2::FitSlicesYvirtual void FitSlicesY(TF1 *f1=nullptr, Int_t firstxbin=0, Int_t lastxbin=-1, Int_t cut=0, Option_t *option=""QNR"", TObjArray *arr=nullptr)Project slices along Y in case of a 2-D histogram, then fit each slice with function f1 and make a hi...Definition TH2.cxx:1081; TH2::GetBinWithContent2virtual Double_t GetBinWithContent2(Double_t c, Int_t &binx, Int_t &biny, Int_t firstxbin=1, Int_t lastxbin=-1, Int_t firstybin=1, Int_t lastybin=-1, Double_t maxdiff=0) constcompute first cell (binx,biny) in the range [firstxbin,lastxbin][firstybin,lastybin] for which diff =...Definition TH2.cxx:1117; TH2::ProfileXTProfile * ProfileX(const char *name=""_pfx"", Int_t firstybin=1, Int_t lastybin=-1, Option_t *option="""") constProject a 2-D histogram into a profile histogram along X.Definition TH2.cxx:2109; TH2::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrem",MatchSource.WIKI,doc/master/TH2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH2_8h_source.html
Availability,mask,mask,"66/// incremented by w; 667 ; 668Int_t TH3::Fill(const char * namex, Double_t y, Double_t z, Double_t w); 669{; 670 Int_t binx, biny, binz, bin;; 671 fEntries++;; 672 binx = fXaxis.FindBin(namex);; 673 biny = fYaxis.FindBin(y);; 674 binz = fZaxis.FindBin(z);; 675 if (binx < 0 || biny < 0 || binz < 0); 676 return -1;; 677 bin = binx + (fXaxis.GetNbins() + 2) * (biny + (fYaxis.GetNbins() + 2) * binz);; 678 if (!fSumw2.fN && w != 1.0 && !TestBit(TH1::kIsNotW)); 679 Sumw2(); // must be called before AddBinContent; 680 if (fSumw2.fN); 681 fSumw2.fArray[bin] += w * w;; 682 AddBinContent(bin, w);; 683 if (binx == 0 || binx > fXaxis.GetNbins()) {; 684 return -1;; 685 }; 686 if (biny == 0 || biny > fYaxis.GetNbins()) {; 687 if (!GetStatOverflowsBehaviour()); 688 return -1;; 689 }; 690 if (binz == 0 || binz > fZaxis.GetNbins()) {; 691 if (!GetStatOverflowsBehaviour()); 692 return -1;; 693 }; 694 Double_t v = w;; 695 fTsumw += v;; 696 fTsumw2 += v * v;; 697 fTsumwy += v * y;; 698 fTsumwy2 += v * y * y;; 699 fTsumwz += v * z;; 700 fTsumwz2 += v * z * z;; 701 fTsumwyz += v * y * z;; 702 // skip computation for x axis : for only one axis no need to use bit mask; 703 if (!fXaxis.CanExtend() || !fXaxis.IsAlphanumeric()) {; 704 Double_t x = fXaxis.GetBinCenter(binx);; 705 fTsumwx += v * x;; 706 fTsumwx2 += v * x * x;; 707 fTsumwxy += v * x * y;; 708 fTsumwxz += v * x * z;; 709 }; 710 return bin;; 711}; 712 ; 713////////////////////////////////////////////////////////////////////////////////; 714/// Increment cell defined by x,namey,z by a weight w; 715///; 716/// If the weight is not equal to 1, the storage of the sum of squares of; 717/// weights is automatically triggered and the sum of the squares of weights is incremented; 718/// by w^2 in the corresponding cell.; 719/// The function returns the corresponding global bin number which has its content; 720/// incremented by w; 721 ; 722Int_t TH3::Fill(Double_t x, const char *namey, Double_t z, Double_t w); 723{; 724 Int_t binx, biny",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
Deployability,integrat,integrated,"rn -1;; 785 }; 786 if (biny == 0 || biny > fYaxis.GetNbins()) {; 787 if (!GetStatOverflowsBehaviour()) return -1;; 788 }; 789 if (binz == 0 || binz > fZaxis.GetNbins()) return -1;; 790 ; 791 Double_t v = w;; 792 fTsumw += v;; 793 fTsumw2 += v*v;; 794 fTsumwx += v*x;; 795 fTsumwx2 += v*x*x;; 796 fTsumwy += v*y;; 797 fTsumwy2 += v*y*y;; 798 fTsumwxy += v*x*y;; 799 ; 800 // skip computation for z axis : for only one axis no need to use bit mask; 801 if (!fZaxis.CanExtend() || !fZaxis.IsAlphanumeric()) {; 802 Double_t z = fZaxis.GetBinCenter(binz);; 803 fTsumwz += v*z;; 804 fTsumwz2 += v*z*z;; 805 fTsumwxz += v*x*z;; 806 fTsumwyz += v*y*z;; 807 }; 808 return bin;; 809}; 810 ; 811 ; 812////////////////////////////////////////////////////////////////////////////////; 813/// Fill histogram following distribution in function fname.; 814///; 815/// @param fname : Function name used for filling the historam; 816/// @param ntimes : number of times the histogram is filled; 817/// @param rng : (optional) Random number generator used to sample; 818///; 819/// The distribution contained in the function fname (TF1) is integrated; 820/// over the channel contents.; 821/// It is normalized to 1.; 822/// Getting one random number implies:; 823/// - Generating a random number between 0 and 1 (say r1); 824/// - Look in which bin in the normalized integral r1 corresponds to; 825/// - Fill histogram channel; 826/// ntimes random numbers are generated; 827///; 828/// N.B. By dfault this methods approximates the integral of the function in each bin with the; 829/// function value at the center of the bin, mutiplied by the bin width; 830///; 831/// One can also call TF1::GetRandom to get a random variate from a function.; 832 ; 833void TH3::FillRandom(const char *fname, Int_t ntimes, TRandom * rng); 834{; 835 Int_t bin, binx, biny, binz, ibin, loop;; 836 Double_t r1, x, y,z, xv[3];; 837 // Search for fname in the list of ROOT defined functions; 838 TObject *fobj = gROOT->GetFunction(fname);;",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
Integrability,integrat,integrated,"rn -1;; 785 }; 786 if (biny == 0 || biny > fYaxis.GetNbins()) {; 787 if (!GetStatOverflowsBehaviour()) return -1;; 788 }; 789 if (binz == 0 || binz > fZaxis.GetNbins()) return -1;; 790 ; 791 Double_t v = w;; 792 fTsumw += v;; 793 fTsumw2 += v*v;; 794 fTsumwx += v*x;; 795 fTsumwx2 += v*x*x;; 796 fTsumwy += v*y;; 797 fTsumwy2 += v*y*y;; 798 fTsumwxy += v*x*y;; 799 ; 800 // skip computation for z axis : for only one axis no need to use bit mask; 801 if (!fZaxis.CanExtend() || !fZaxis.IsAlphanumeric()) {; 802 Double_t z = fZaxis.GetBinCenter(binz);; 803 fTsumwz += v*z;; 804 fTsumwz2 += v*z*z;; 805 fTsumwxz += v*x*z;; 806 fTsumwyz += v*y*z;; 807 }; 808 return bin;; 809}; 810 ; 811 ; 812////////////////////////////////////////////////////////////////////////////////; 813/// Fill histogram following distribution in function fname.; 814///; 815/// @param fname : Function name used for filling the historam; 816/// @param ntimes : number of times the histogram is filled; 817/// @param rng : (optional) Random number generator used to sample; 818///; 819/// The distribution contained in the function fname (TF1) is integrated; 820/// over the channel contents.; 821/// It is normalized to 1.; 822/// Getting one random number implies:; 823/// - Generating a random number between 0 and 1 (say r1); 824/// - Look in which bin in the normalized integral r1 corresponds to; 825/// - Fill histogram channel; 826/// ntimes random numbers are generated; 827///; 828/// N.B. By dfault this methods approximates the integral of the function in each bin with the; 829/// function value at the center of the bin, mutiplied by the bin width; 830///; 831/// One can also call TF1::GetRandom to get a random variate from a function.; 832 ; 833void TH3::FillRandom(const char *fname, Int_t ntimes, TRandom * rng); 834{; 835 Int_t bin, binx, biny, binz, ibin, loop;; 836 Double_t r1, x, y,z, xv[3];; 837 // Search for fname in the list of ROOT defined functions; 838 TObject *fobj = gROOT->GetFunction(fname);;",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
Modifiability,variab,variable,"he 3-D histogram classes derived from the 1-D histogram classes.; 50All operations are supported (fill, fit).; 51Drawing is currently restricted to one single option.; 52A cloud of points is drawn. The number of points is proportional to; 53cell content.; 54 ; 55- TH3C a 3-D histogram with one byte per cell (char). Maximum bin content = 127; 56- TH3S a 3-D histogram with two bytes per cell (short integer). Maximum bin content = 32767; 57- TH3I a 3-D histogram with four bytes per cell (32 bit integer). Maximum bin content = INT_MAX (\ref intmax3 ""*""); 58- TH3L a 3-D histogram with eight bytes per cell (64 bit integer). Maximum bin content = LLONG_MAX (\ref llongmax3 ""**""); 59- TH3F a 3-D histogram with four bytes per cell (float). Maximum precision 7 digits, maximum integer bin content = +/-16777216 (\ref floatmax3 ""***""); 60- TH3D a 3-D histogram with eight bytes per cell (double). Maximum precision 14 digits, maximum integer bin content = +/-9007199254740992 (\ref doublemax3 ""****""); 61 ; 62<sup>; 63\anchor intmax3 (*) INT_MAX = 2147483647 is the [maximum value for a variable of type int.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 64\anchor llongmax3 (**) LLONG_MAX = 9223372036854775807 is the [maximum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 65\anchor floatmax3 (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br>; 66\anchor doublemax3 (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760); 67</sup>; 68*/; 69 ; 70 ; 71////////////////////////////////////////////////////////////////////////////////; 72/// Default constructor.; 73 ; 74TH3::TH3(); 75{; 76 fDimension = 3;; 77 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 78 fTsumwz = fTsumwz2 = fTsumwxz = fT",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
Performance,perform,performing," but only bins inside the selected range will be filled.; 1806///; 1807/// NOTE that if a TH1D named ""name"" exists in the current directory or pad,; 1808/// the histogram is reset and filled again with the projected contents of the TH3.; 1809///; 1810/// implemented using Project3D; 1811 ; 1812TH1D *TH3::ProjectionZ(const char *name, Int_t ixmin, Int_t ixmax,; 1813 Int_t iymin, Int_t iymax, Option_t *option) const; 1814{; 1815 ; 1816 TString hname = name;; 1817 if (hname == ""_pz"") hname = TString::Format(""%s%s"", GetName(), name);; 1818 TString title = TString::Format(""%s ( Projection Z )"",GetTitle());; 1819 ; 1820 // when projecting in Z outer axis are X and Y (order is important. It is defined in the DoProject1D function); 1821 return DoProject1D(hname, title, ixmin, ixmax, iymin, iymax, &fZaxis, &fXaxis, &fYaxis, option);; 1822}; 1823 ; 1824 ; 1825////////////////////////////////////////////////////////////////////////////////; 1826/// internal method performing the projection to 1D histogram; 1827/// called from TH3::Project3D; 1828 ; 1829TH1D *TH3::DoProject1D(const char* name, const char * title, int imin1, int imax1, int imin2, int imax2,; 1830 const TAxis* projAxis, const TAxis * axis1, const TAxis * axis2, Option_t * option) const; 1831{; 1832 ; 1833 TString opt = option;; 1834 opt.ToLower();; 1835 ; 1836 // save previous axis range and bits; 1837 // Int_t iminOld1 = axis1->GetFirst();; 1838 // Int_t imaxOld1 = axis1->GetLast();; 1839 // Int_t iminOld2 = axis2->GetFirst();; 1840 // Int_t imaxOld2 = axis2->GetLast();; 1841 // Bool_t hadRange1 = axis1->TestBit(TAxis::kAxisRange);; 1842 // Bool_t hadRange2 = axis2->TestBit(TAxis::kAxisRange);; 1843 ; 1844 // need to cast-away constness to set range; 1845 TAxis out1(*axis1);; 1846 TAxis out2(*axis2);; 1847 // const_cast<TAxis *>(axis1)->SetRange(imin1, imax1);; 1848 // const_cast<TAxis*>(axis2)->SetRange(imin2,imax2);; 1849 out1.SetRange(imin1, imax1);; 1850 out2.SetRange(imin2, imax2);; 1851 ; 1852 Bool_t compu",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
Safety,avoid,avoid," for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; 65\anchor floatmax3 (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br>; 66\anchor doublemax3 (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760); 67</sup>; 68*/; 69 ; 70 ; 71////////////////////////////////////////////////////////////////////////////////; 72/// Default constructor.; 73 ; 74TH3::TH3(); 75{; 76 fDimension = 3;; 77 fTsumwy = fTsumwy2 = fTsumwxy = 0;; 78 fTsumwz = fTsumwz2 = fTsumwxz = fTsumwyz = 0;; 79}; 80 ; 81 ; 82////////////////////////////////////////////////////////////////////////////////; 83/// Constructor for fix bin size 3-D histograms.; 84/// Creates the main histogram structure.; 85///; 86/// \param[in] name name of histogram (avoid blanks); 87/// \param[in] title histogram title.; 88/// If title is of the form `stringt;stringx;stringy;stringz`,; 89/// the histogram title is set to `stringt`,; 90/// the x axis title to `stringx`, the y axis title to `stringy`, etc.; 91/// \param[in] nbinsx number of bins along the X axis; 92/// \param[in] xlow low edge of the X axis first bin; 93/// \param[in] xup upper edge of the X axis last bin (not included in last bin); 94/// \param[in] nbinsy number of bins along the Y axis; 95/// \param[in] ylow low edge of the Y axis first bin; 96/// \param[in] yup upper edge of the Y axis last bin (not included in last bin); 97/// \param[in] nbinsz number of bins along the Z axis; 98/// \param[in] zlow low edge of the Z axis first bin; 99/// \param[in] zup upper edge of the Z axis last bin (not included in last bin); 100 ; 101TH3::TH3(const char *name,const char *title,Int_t nbinsx,Double_t xlow,Double_t xup; 102 ,Int_t nbinsy,Double_t ylow,Double_t yup; 103 ,Int_t nbinsz,Double_t zlo",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
Security,access,access,"///; 958/// Note that the generated histograms are added to the list of objects; 959/// in the current directory. It is the user's responsibility to delete; 960/// these histograms.; 961///; 962/// Example: Assume a 3-d histogram h3; 963/// Root > h3->FitSlicesZ(); produces 4 TH2D histograms; 964/// with h3_0 containing parameter 0(Constant) for a Gaus fit; 965/// of each cell in X,Y projected along Z; 966/// with h3_1 containing parameter 1(Mean) for a gaus fit; 967/// with h3_2 containing parameter 2(StdDev) for a gaus fit; 968/// with h3_chi2 containing the chisquare/number of degrees of freedom for a gaus fit; 969///; 970/// Root > h3->Fit(0,15,22,0,0,10);; 971/// same as above, but only for bins 15 to 22 along X; 972/// and only for cells in X,Y for which the corresponding projection; 973/// along Z has more than cut bins filled.; 974///; 975/// NOTE: To access the generated histograms in the current directory, do eg:; 976/// TH2D *h3_1 = (TH2D*)gDirectory->Get(""h3_1"");; 977 ; 978void TH3::FitSlicesZ(TF1 *f1, Int_t binminx, Int_t binmaxx, Int_t binminy, Int_t binmaxy, Int_t cut, Option_t *option); 979{; 980 //Int_t nbinsz = fZaxis.GetNbins();; 981 ; 982 // get correct first and last bins for outer axes used in the loop doing the slices; 983 // when using default values (0,-1) check if an axis range is set in outer axis; 984 // do same as in DoProjection for inner axis; 985 auto computeFirstAndLastBin = [](const TAxis & outerAxis, Int_t &firstbin, Int_t &lastbin) {; 986 Int_t nbins = outerAxis.GetNbins();; 987 if ( lastbin < firstbin && outerAxis.TestBit(TAxis::kAxisRange) ) {; 988 firstbin = outerAxis.GetFirst();; 989 lastbin = outerAxis.GetLast();; 990 // For special case of TAxis::SetRange, when first == 1 and last; 991 // = N and the range bit has been set, the TAxis will return 0; 992 // for both.; 993 if (firstbin == 0 && lastbin == 0) {; 994 firstbin = 1;; 995 lastbin = nbins;; 996 }; 997 }; 998 if (firstbin < 0) firstbin = 0;; 999 if (lastbin < 0 || last",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
Testability,test,test,"tNbins() || obz > fZaxis.GetNbins() ) {; 1477 Error(""Interpolate"",""Cannot interpolate outside histogram domain."");; 1478 return 0;; 1479 }; 1480 ; 1481 Double_t xw = fXaxis.GetBinCenter(obx) - fXaxis.GetBinCenter(ubx);; 1482 Double_t yw = fYaxis.GetBinCenter(oby) - fYaxis.GetBinCenter(uby);; 1483 Double_t zw = fZaxis.GetBinCenter(obz) - fZaxis.GetBinCenter(ubz);; 1484 ; 1485 Double_t xd = (x - fXaxis.GetBinCenter(ubx)) / xw;; 1486 Double_t yd = (y - fYaxis.GetBinCenter(uby)) / yw;; 1487 Double_t zd = (z - fZaxis.GetBinCenter(ubz)) / zw;; 1488 ; 1489 ; 1490 Double_t v[] = { GetBinContent( ubx, uby, ubz ), GetBinContent( ubx, uby, obz ),; 1491 GetBinContent( ubx, oby, ubz ), GetBinContent( ubx, oby, obz ),; 1492 GetBinContent( obx, uby, ubz ), GetBinContent( obx, uby, obz ),; 1493 GetBinContent( obx, oby, ubz ), GetBinContent( obx, oby, obz ) };; 1494 ; 1495 ; 1496 Double_t i1 = v[0] * (1 - zd) + v[1] * zd;; 1497 Double_t i2 = v[2] * (1 - zd) + v[3] * zd;; 1498 Double_t j1 = v[4] * (1 - zd) + v[5] * zd;; 1499 Double_t j2 = v[6] * (1 - zd) + v[7] * zd;; 1500 ; 1501 ; 1502 Double_t w1 = i1 * (1 - yd) + i2 * yd;; 1503 Double_t w2 = j1 * (1 - yd) + j2 * yd;; 1504 ; 1505 ; 1506 Double_t result = w1 * (1 - xd) + w2 * xd;; 1507 ; 1508 return result;; 1509}; 1510 ; 1511 ; 1512////////////////////////////////////////////////////////////////////////////////; 1513/// Statistical test of compatibility in shape between; 1514/// THIS histogram and h2, using Kolmogorov test.; 1515/// Default: Ignore under- and overflow bins in comparison; 1516///; 1517/// option is a character string to specify options; 1518/// ""U"" include Underflows in test; 1519/// ""O"" include Overflows; 1520/// ""N"" include comparison of normalizations; 1521/// ""D"" Put out a line of ""Debug"" printout; 1522/// ""M"" Return the Maximum Kolmogorov distance instead of prob; 1523///; 1524/// The returned function value is the probability of test; 1525/// (much less than one means NOT compatible); 1526///; 1527/// The KS t",MatchSource.WIKI,doc/master/TH3_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html
Availability,error,error,"Array of integers (32 bits per element).Definition TArrayI.h:27; TArrayI::fArrayInt_t * fArrayDefinition TArrayI.h:30; TArrayI::Resetvoid Reset()Definition TArrayI.h:47; TArrayL64Array of long64s (64 bits per element).Definition TArrayL64.h:27; TArrayL64::fArrayLong64_t * fArrayDefinition TArrayL64.h:30; TArrayL64::Resetvoid Reset()Definition TArrayL64.h:47; TArraySArray of shorts (16 bits per element).Definition TArrayS.h:27; TArrayS::Resetvoid Reset()Definition TArrayS.h:47; TArrayS::fArrayShort_t * fArrayDefinition TArrayS.h:30; TAtt3DUse this attribute class when an object should have 3D capabilities.Definition TAtt3D.h:19; TAxisClass to manage histogram axis.Definition TAxis.h:31; TF11-Dim function classDefinition TF1.h:233; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2] and its error.Definition TH1.cxx:7968; TH1::GetBinErrorLowvirtual Double_t GetBinErrorLow(Int_t bin) constReturn lower error associated to bin number bin.Definition TH1.cxx:9079; TH1::Integralvirtual Double_t Integral(Option_t *option="""") constReturn integral of bin contents.Definition TH1.cxx:7941; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t bin) constReturn upper error associated to bin number bin.Definition TH1.cxx:9110; TH2D2-D histogram with a double per channel (see TH1 documentation)Definition TH2.h:357; TH3C3-D histogram with a byte per channel (see TH1 documentation)Definition TH3.h:157; TH3C::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH3.cxx:3647; TH3C::operator*",MatchSource.WIKI,doc/master/TH3_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html
Deployability,update,update,"ator+(TH3C const &h1, TH3C const &h2)Operator +.Definition TH3.cxx:3743; TH3C::operator/friend TH3C operator/(TH3C const &h1, TH3C const &h2)Operator /.Definition TH3.cxx:3779; TH3C::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Int_t binz, Double_t w) overrideIncrement 3D bin content by a weight w.Definition TH3.h:175; TH3C::RetrieveBinContentDouble_t RetrieveBinContent(Int_t bin) const overrideRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH3.h:189; TH3C::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH3.cxx:3603; TH3C::operator=TH3C & operator=(const TH3C &h1)Operator =.Definition TH3.cxx:3720; TH3C::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Int_t binz) overrideIncrement 3D bin content by 1.Definition TH3.h:174; TH3C::TH3CTH3C()Constructor.Definition TH3.cxx:3530; TH3C::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH3.h:190; TH3C::Copyvoid Copy(TObject &hnew) const overrideCopy this 3-D histogram structure to newth3.Definition TH3.cxx:3626; TH3D3-D histogram with a double per channel (see TH1 documentation)Definition TH3.h:363; TH3D::operator*friend TH3D operator*(TH3D const &h1, Float_t c1)Definition TH3.h:393; TH3D::UpdateBinContentvoid UpdateBinContent(Int_t bin, Double_t content) overrideRaw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH3.h:401; TH3D::TH3DTH3D()Constructor.Definition TH3.cxx:4669; TH3D::operator+friend TH3D operator+(TH3D const &h1, TH3D const &h2)Operator +.Definition TH3.cxx:4831; TH3D::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH3.cxx:4763; TH3D::~TH3D~TH3D() overrideDestructor.Definition TH3.cxx:467",MatchSource.WIKI,doc/master/TH3_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html
Integrability,depend,depending,"const TH3 &)=delete; TH3::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2] for a 3-D histogra...Definition TH3.cxx:1421; TH3::ProjectionZvirtual TH1D * ProjectionZ(const char *name=""_pz"", Int_t ixmin=0, Int_t ixmax=-1, Int_t iymin=0, Int_t iymax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along Z.Definition TH3.cxx:1812; TH3::SetBinContentvoid SetBinContent(Int_t binx, Int_t biny, Int_t binz, Double_t content) overrideDefinition TH3.h:132; TH3::ProjectionXvirtual TH1D * ProjectionX(const char *name=""_px"", Int_t iymin=0, Int_t iymax=-1, Int_t izmin=0, Int_t izmax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along X.Definition TH3.cxx:1747; TH3::Project3DProfilevirtual TProfile2D * Project3DProfile(Option_t *option=""xy"") constProject a 3-d histogram into a 2-d profile histograms depending on the option parameter option may co...Definition TH3.cxx:2806; TH3::fTsumwz2Double_t fTsumwz2Total Sum of weight*Z*Z.Definition TH3.h:38; TH3::fTsumwxyDouble_t fTsumwxyTotal Sum of weight*X*Y.Definition TH3.h:36; TH3::FillInt_t Fill(Double_t, Double_t) overrideIncrement bin with abscissa X with a weight w.Definition TH3.h:59; TH3::Project3Dvirtual TH1 * Project3D(Option_t *option=""x"") constProject a 3-d histogram into 1 or 2-d histograms depending on the option parameter,...Definition TH3.cxx:2409; TH3::GetBinErrorLowvirtual Double_t GetBinErrorLow(Int_t binx, Int_t biny, Int_t binz)Definition TH3.h:104; TH3::FillInt_t Fill(Double_t, const char *, Double_t)Definition TH3.h:61; TH3::GetBinWithContent3virtual Double_t GetBinWithContent3(Double_t c, Int_t &binx, Int_t &biny, Int_t &binz, Int_t firstx=0, Int_t lastx=0, Int_t firsty=0, Int_t lasty=0, Int_t firstz=0, Int_t lastz=0, Double_t maxdiff=0) constCompute first cell (bin",MatchSource.WIKI,doc/master/TH3_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html
Performance,perform,performing,"6; TH3::BufferEmptyInt_t BufferEmpty(Int_t action=0) overrideFill histogram with all entries in the buffer.Definition TH3.cxx:264; TH3::fTsumwyDouble_t fTsumwyTotal Sum of weight*Y.Definition TH3.h:34; TH3::FillInt_t Fill(const char *, const char *, Double_t)Definition TH3.h:63; TH3::BufferFillvirtual Int_t BufferFill(Double_t, Double_t, Double_t)Definition TH3.h:57; TH3::fTsumwy2Double_t fTsumwy2Total Sum of weight*Y*Y.Definition TH3.h:35; TH3::GetCovariancevirtual Double_t GetCovariance(Int_t axis1=1, Int_t axis2=2) constReturn covariance between axis1 and axis2.Definition TH3.cxx:1209; TH3::GetStatsvoid GetStats(Double_t *stats) const overrideFill the array stats from the contents of this histogram The array stats must be correctly dimensione...Definition TH3.cxx:1307; TH3::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH3.cxx:208; TH3::DoProject2Dvirtual TH2D * DoProject2D(const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) constinternal method performing the projection to a 2D histogram called from TH3::Project3DDefinition TH3.cxx:2103; TH3::fTsumwxzDouble_t fTsumwxzTotal Sum of weight*X*Z.Definition TH3.h:39; TH3::FillRandomvoid FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr) overrideFill histogram following distribution in function fname.Definition TH3.cxx:833; TH3::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t binx, Int_t biny, Int_t binz)Definition TH3.h:105; TH3::KolmogorovTestDouble_t KolmogorovTest(const TH1 *h2, Option_t *option="""") const overrideStatistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test.Definition TH3.cxx:1532; TH3::ProjectionYvirtual TH1D * ProjectionY(const char *name=""_py"", Int_t ixmin=0, Int_t ixmax=-1, Int_t izmin=0, Int_t izmax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along Y.Definition TH3.cxx:1780; TH3::FillInt_t Fill(const char *, ",MatchSource.WIKI,doc/master/TH3_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html
Testability,test,test,"id GetStats(Double_t *stats) const overrideFill the array stats from the contents of this histogram The array stats must be correctly dimensione...Definition TH3.cxx:1307; TH3::Copyvoid Copy(TObject &hnew) const overrideCopy.Definition TH3.cxx:208; TH3::DoProject2Dvirtual TH2D * DoProject2D(const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) constinternal method performing the projection to a 2D histogram called from TH3::Project3DDefinition TH3.cxx:2103; TH3::fTsumwxzDouble_t fTsumwxzTotal Sum of weight*X*Z.Definition TH3.h:39; TH3::FillRandomvoid FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr) overrideFill histogram following distribution in function fname.Definition TH3.cxx:833; TH3::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t binx, Int_t biny, Int_t binz)Definition TH3.h:105; TH3::KolmogorovTestDouble_t KolmogorovTest(const TH1 *h2, Option_t *option="""") const overrideStatistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test.Definition TH3.cxx:1532; TH3::ProjectionYvirtual TH1D * ProjectionY(const char *name=""_py"", Int_t ixmin=0, Int_t ixmax=-1, Int_t izmin=0, Int_t izmax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along Y.Definition TH3.cxx:1780; TH3::FillInt_t Fill(const char *, Double_t) overrideIncrement bin with namex with a weight w.Definition TH3.h:60; TH3::GetRandom3virtual void GetRandom3(Double_t &x, Double_t &y, Double_t &, TRandom *rng=nullptr)Return 3 random numbers along axis x , y and z distributed according to the cell-contents of this 3-d...Definition TH3.cxx:1259; TH3::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH3.cxx:3449; TH3::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH3.cxx:224; TH3::~TH3~TH3() overrideDestructor.Definition TH3.cxx:200; TH3::FillInt_t Fil",MatchSource.WIKI,doc/master/TH3_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TH3_8h_source.html
Integrability,depend,dependency,". ROOT: hist/hbook/src/THbookFile.cxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Macros |; Functions |; Variables ; THbookFile.cxx File Reference. #include <cstdlib>; #include <cstring>; #include <cctype>; #include ""TROOT.h""; #include ""THbookFile.h""; #include ""TH2.h""; #include ""THbookTree.h""; #include ""THbookBranch.h""; #include ""THbookKey.h""; #include ""TGraph.h""; #include ""TProfile.h""; #include ""TTreeFormula.h""; #include ""TLeafI.h""; #include ""TBrowser.h""; #include ""TSystem.h""; #include ""TMath.h""; #include ""strlcpy.h""; #include ""snprintf.h"". Include dependency graph for THbookFile.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Macros; #define DEFCHAR   const char*;  ; #define hbnam   hbnam_;  ; #define hbnamc   hbnamc_;  ; #define hbname   hbname_;  ; #define hcbits   hcbits_;  ; #define hcbook   hcbook_;  ; #define hcdir   hcdir_;  ; #define hdcofl   hdcofl_;  ; #define hdelet   hdelet_;  ; #define hgive   hgive_;  ; #define hgiven   hgiven_;  ; #define hgnf   hgnf_;  ; #define hgnpar   hgnpar_;  ; #define hgnt   hgnt_;  ; #define hgnt1   hgnt1_;  ; #define hgntf   hgntf_;  ; #define hi   hi_;  ; #define hie   hie_;  ; #define hif   hif_;  ; #define hij   hij_;  ; #define hije   hije_;  ; #define hijxy   hijxy_;  ; #define hix   hix_;  ; #define hldir   hldir_;  ; #define hlimit   hlimit_;  ; #define hmaxim   hmaxim_;  ; #define hminim   hminim_;  ; #define hnoent   hnoent_;  ; #define hntvar2   hntvar2_;  ; #define hntvar3   hntvar3_;  ; #define hrend   hrend_;  ; #define hrin   hrin_;  ; #define hropen   hropen_;  ; #define PASSCHAR(string)   string;  ; #define pawc   pawc_;  ; #define PAWC_SIZE   4000000;  ; #define quest   quest_;  ; #define rzcl   rzcl_;  ; #defin",MatchSource.WIKI,doc/master/THbookFile_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THbookFile_8cxx.html
Availability,error,error,,MatchSource.WIKI,doc/master/THbookFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THbookFile_8cxx_source.html
Integrability,interface,interface,". ROOT: hist/hbook/src/THbookFile.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. THbookFile.cxx. Go to the documentation of this file. 1// @(#)root/hbook:$Id$; 2// Author: Rene Brun 18/02/2002; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class THbookFile; 13 \ingroup Hist; 14 This class is an interface to the Hbook objects in Hbook files.; 15 Any Hbook object (1-D, 2-D, Profile, RWN or CWN can be read; 16 ; 17 NB: a THbookFile can only be used in READ mode; 18 Use the utility in $ROOTSYS/bin/h2root to convert Hbook to Root; 19 ; 20 Example of use:; 21 ; 22 gSystem->Load(""libHbook"");; 23 THbookFile f(""myfile.hbook"");; 24 f.ls();; 25 TH1F *h1 = (TH1F*)f.Get(1); //import histogram ID=1 in h1; 26 h1->Fit(""gaus"");; 27 THbookTree *T = (THbookTree*)f.Get(111); //import ntuple header; 28 T->Print(); //show the Hbook ntuple variables; 29 T->Draw(""x"",""y<0""); // as in normal TTree::Draw; 30 ; 31 THbookFile can be browsed via TBrowser.; 32*/; 33 ; 34#include <cstdlib>; 35#include <cstring>; 36#include <cctype>; 37 ; 38#include ""TROOT.h""; 39#include ""THbookFile.h""; 40#include ""TH2.h""; 41#include ""THbookTree.h""; 42#include ""THbookBranch.h""; 43#include ""THbookKey.h""; 44#include ""TGraph.h""; 45#include ""TProfile.h""; 46#include ""TTreeFormula.h""; 47#include ""TLeafI.h""; 48#include ""TBrowser.h""; 49#include ""TSystem.h""; 50#include ""TMath.h""; 51#include ""strlcpy.h""; 52#include ""snprintf.h""; 53 ; 54// NOTE: THe following comments and declarations are a duplicate; 55// of those in main/src/h2root.cxx; 56 ; 57// Note that with gcc3.4 or above the size of PAWC_SIZE must be the same; 58// as in the Fortran ",MatchSource.WIKI,doc/master/THbookFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THbookFile_8cxx_source.html
Modifiability,variab,variables,"002; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class THbookFile; 13 \ingroup Hist; 14 This class is an interface to the Hbook objects in Hbook files.; 15 Any Hbook object (1-D, 2-D, Profile, RWN or CWN can be read; 16 ; 17 NB: a THbookFile can only be used in READ mode; 18 Use the utility in $ROOTSYS/bin/h2root to convert Hbook to Root; 19 ; 20 Example of use:; 21 ; 22 gSystem->Load(""libHbook"");; 23 THbookFile f(""myfile.hbook"");; 24 f.ls();; 25 TH1F *h1 = (TH1F*)f.Get(1); //import histogram ID=1 in h1; 26 h1->Fit(""gaus"");; 27 THbookTree *T = (THbookTree*)f.Get(111); //import ntuple header; 28 T->Print(); //show the Hbook ntuple variables; 29 T->Draw(""x"",""y<0""); // as in normal TTree::Draw; 30 ; 31 THbookFile can be browsed via TBrowser.; 32*/; 33 ; 34#include <cstdlib>; 35#include <cstring>; 36#include <cctype>; 37 ; 38#include ""TROOT.h""; 39#include ""THbookFile.h""; 40#include ""TH2.h""; 41#include ""THbookTree.h""; 42#include ""THbookBranch.h""; 43#include ""THbookKey.h""; 44#include ""TGraph.h""; 45#include ""TProfile.h""; 46#include ""TTreeFormula.h""; 47#include ""TLeafI.h""; 48#include ""TBrowser.h""; 49#include ""TSystem.h""; 50#include ""TMath.h""; 51#include ""strlcpy.h""; 52#include ""snprintf.h""; 53 ; 54// NOTE: THe following comments and declarations are a duplicate; 55// of those in main/src/h2root.cxx; 56 ; 57// Note that with gcc3.4 or above the size of PAWC_SIZE must be the same; 58// as in the Fortran definition in hbook.f and zebra; 59// Also, the arrays must be declared extern like on Windows; 60#define PAWC_SIZE 4000000; 61 ; 62// Define the names of the Fortran common blocks for the different OSs; 63 ; 64#ifndef WIN32; 65# define paw",MatchSource.WIKI,doc/master/THbookFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THbookFile_8cxx_source.html
Testability,log,logical,");; 244extern ""C"" void type_of_call hldir(DEFCHAR,DEFCHAR);; 245#endif; 246 ; 247Bool_t THbookFile::fgPawInit = kFALSE;; 248Int_t *THbookFile::fgLuns = nullptr;; 249 ; 250ClassImp(THbookFile);; 251 ; 252////////////////////////////////////////////////////////////////////////////////; 253///the constructor; 254 ; 255THbookFile::THbookFile() : fLun(0),fLrecl(0); 256{; 257 fList = new TList();; 258 fKeys = new TList();; 259}; 260 ; 261////////////////////////////////////////////////////////////////////////////////; 262/// Constructor for an HBook file object; 263 ; 264THbookFile::THbookFile(const char *fname, Int_t lrecl); 265 :TNamed(fname,""""); 266{; 267 // Initialize the Hbook/Zebra store; 268 Int_t i;; 269 if (!fgPawInit) {; 270 fgPawInit = kTRUE;; 271 lq = &pawc[9];; 272 iq = &pawc[17];; 273 void *qq = iq;; 274 q = (float*)qq;; 275 int pawc_size = PAWC_SIZE;; 276 hlimit(pawc_size);; 277 fgLuns = new Int_t[10];; 278 for (i=0;i<10;i++) fgLuns[i] = 0;; 279 }; 280 ; 281 //find a free logical unit (max 10); 282 fLun = 0;; 283 for (i=0;i<10;i++) {; 284 if (fgLuns[i] == 0) {; 285 fLun = 10+i;; 286 fgLuns[i] = 1;; 287 break;; 288 }; 289 }; 290 if (fLun == 0) {; 291 Error(""THbookFile"",""Too many HbookFiles\n"");; 292 return;; 293 }; 294 char topdir[20];; 295 snprintf(topdir,19,""lun%d"",fLun);; 296 ; 297 Int_t ier = 0;; 298#ifndef WIN32; 299 hropen(fLun,PASSCHAR(topdir),PASSCHAR(fname),PASSCHAR(""p""),lrecl,ier,strlen(topdir),strlen(fname),1);; 300#else; 301 hropen(fLun,PASSCHAR(topdir),PASSCHAR(fname),PASSCHAR(""p""),lrecl,ier);; 302#endif; 303 fLrecl = lrecl;; 304 SetTitle(topdir);; 305 snprintf(topdir,19,""//lun%d"",fLun);; 306 fCurDir = topdir;; 307 ; 308 if (ier) printf ("" Error on hropen was %d \n"", ier);; 309 if (quest[0]) {; 310 printf(""Error cannot open input file: %s\n"",fname);; 311 }; 312 if (ier || quest[0]) {; 313 fgLuns[fLun-10]=0;; 314 fLun = 0;; 315 fList = nullptr;; 316 fKeys = nullptr;; 317 MakeZombie();; 318 return;; 319 }; 320 ; 321 gROOT->GetListOfBrowsables()->A",MatchSource.WIKI,doc/master/THbookFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THbookFile_8cxx_source.html
Availability,error,error,,MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
Deployability,update,updated,"D. To choose how the histogram will; 154be drawn, the `Draw()` method can be invoked with an option. For instance; 155to draw a 2D histogram as a lego plot it is enough to do:; 156 ; 157 h->Draw(""lego"");; 158 ; 159`THistPainter` offers many options to paint 1D, 2D and 3D histograms.; 160 ; 161When the `Draw()` method of a histogram is called for the first time; 162(`TH1::Draw`), it creates a `THistPainter` object and saves a; 163pointer to this ""painter"" as a data member of the histogram. The; 164`THistPainter` class specializes in the drawing of histograms. It is; 165separated from the histogram so that one can have histograms without the; 166graphics overhead, for example in a batch program. Each histogram having its own; 167painter (rather than a central singleton painter painting all histograms), allows; 168two histograms to be drawn in two threads without overwriting the painter's; 169values.; 170 ; 171When a displayed histogram is filled again, there is no need to call the; 172`Draw()` method again; the image will be refreshed the next time the; 173pad will be updated.; 174 ; 175A pad is updated after one of these three actions:; 176 ; 1771. a carriage control on the ROOT command line,; 1782. a click inside the pad,; 1793. a call to `TPad::Update`.; 180 ; 181 ; 182By default a call to `TH1::Draw()` clears the pad of all objects; 183before drawing the new image of the histogram. One can use the `SAME`; 184option to leave the previous display intact and superimpose the new histogram.; 185The same histogram can be drawn with different graphics options in different; 186pads.; 187 ; 188When a displayed histogram is deleted, its image is automatically removed; 189from the pad.; 190 ; 191To create a copy of the histogram when drawing it, one can use; 192`TH1::DrawClone()`. This will clone the histogram and allow to change; 193and delete the original one without affecting the clone.; 194 ; 195 ; 196\anchor HP01; 197### Histograms' plotting options; 198 ; 199 ; 200Most ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
Energy Efficiency,reduce,reduces,"href=""http://en.wikipedia.org/wiki/Box_plot"">A Candle plot</a> (also known as; 1282a ""box plot"" or ""whisker plot"") was invented in 1977 by John Tukey. It is a convenient; 1283way to describe graphically a data distribution (D) with only five numbers:; 1284 ; 1285 1. The minimum value of the distribution D (bottom or left whisker).; 1286 2. The lower quartile (Q1): 25% of the data points in D are less than Q1 (bottom of the box).; 1287 3. The median (M): 50% of the data points in D are less than M.; 1288 4. The upper quartile (Q3): 75% of the data points in D are less than Q3 (top of the box).; 1289 5. The maximum value of the distribution D (top or right whisker).; 1290 ; 1291In this implementation a TH2 is considered as a collection of TH1 along; 1292X (option `CANDLE` or `CANDLEX`) or Y (option `CANDLEY`).; 1293Each TH1 is represented as one candle.; 1294 ; 1295Begin_Macro(source); 1296../../../tutorials/hist/candleplotwhiskers.C; 1297End_Macro; 1298 ; 1299The candle reduces the information coming from a whole distribution into few values.; 1300Independently from the number of entries or the significance of the underlying distribution; 1301a candle will always look like a candle. So candle plots should be used carefully in; 1302particular with unknown distributions. The definition of a candle is based on; 1303__unbinned data__. Here, candles are created from binned data. Because of this, the; 1304deviation is connected to the bin width used. The calculation of the quantiles; 1305normally done on unbinned data also. Because data are binned, this will; 1306only work the best possible way within the resolution of one bin; 1307 ; 1308Because of all these facts one should take care that:; 1309 ; 1310 - there are enough points per candle; 1311 - the bin width is small enough (more bins will increase the maximum; 1312 available resolution of the quantiles although there will be some; 1313 bins with no entries); 1314 - never make a candle-plot if the underlying distributio",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
Integrability,depend,depends,"(x,y,4);; 1154 if(x<0 && y<0) h2->Fill(x,y,3);; 1155 if(x>0 && y<0) h3->Fill(x,y,2);; 1156 if(x<0 && y>0) h4->Fill(x,y,1);; 1157 }; 1158 h1->Draw(""colz"");; 1159 h2->Draw(""col same"");; 1160 h3->Draw(""col same"");; 1161 h4->Draw(""col same"");; 1162}; 1163End_Macro; 1164 ; 1165The option `COL` can be combined with the option `POL`:; 1166 ; 1167Begin_Macro(source); 1168{; 1169 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 1170 auto hcol1 = new TH2F(""hcol1"",""Option COLor combined with POL"",40,-4,4,40,-4,4);; 1171 float px, py;; 1172 for (Int_t i = 0; i < 25000; i++) {; 1173 gRandom->Rannor(px,py);; 1174 hcol1->Fill(px,py);; 1175 }; 1176 hcol1->Draw(""COLZPOL"");; 1177}; 1178End_Macro; 1179 ; 1180\since **ROOT version 6.07/03:**; 1181 ; 1182A second rendering technique is also available with the COL2 and COLZ2 options.; 1183 ; 1184These options provide potential performance improvements compared to the standard; 1185COL option. The performance comparison of the COL2 to the COL option depends on; 1186the histogram and the size of the rendering region in the current pad. In general,; 1187a small (approx. less than 100 bins per axis), sparsely populated TH2 will render; 1188faster with the COL option.; 1189 ; 1190However, for larger histograms (approx. more than 100 bins per axis); 1191that are not sparse, the COL2 option will provide up to 20 times performance improvements.; 1192For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude; 1193faster with the COL2 option.; 1194 ; 1195The COL2 option will also scale its performance based on the size of the; 1196pixmap the histogram image is being rendered into. It also is much better optimized for; 1197sessions where the user is forwarding X11 windows through an `ssh` connection.; 1198 ; 1199For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; 1200and COLZ options. There is one major difference and that concerns the treatment of; 1201bins with zero content. The COL2 and COLZ2 ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
Modifiability,inherit,inherit," is subdivided into a number of pads equal to the number of histograms in the stack and each histogram is paint into a separate pad.|; 355| ""PFC"" | Palette Fill Color: stack's fill color is taken in the current palette. |; 356| ""PLC"" | Palette Line Color: stack's line color is taken in the current palette. |; 357| ""PMC"" | Palette Marker Color: stack's marker color is taken in the current palette. |; 358 ; 359 ; 360 ; 361\anchor HP02; 362### Setting the Style; 363 ; 364 ; 365Histograms use the current style (`gStyle`). When one changes the current; 366style and would like to propagate the changes to the histogram,; 367`TH1::UseCurrentStyle` should be called. Call `UseCurrentStyle` on; 368each histogram is needed.; 369 ; 370To force all the histogram to use the current style use:; 371 ; 372 gROOT->ForceStyle();; 373 ; 374All the histograms read after this call will use the current style.; 375 ; 376 ; 377\anchor HP03; 378### Setting line, fill, marker, and text attributes; 379 ; 380 ; 381The histogram classes inherit from the attribute classes:; 382`TAttLine`, `TAttFill` and `TAttMarker`.; 383See the description of these classes for the list of options.; 384 ; 385 ; 386\anchor HP04; 387### Setting Tick marks on the histogram axis; 388 ; 389 ; 390The `TPad::SetTicks` method specifies the type of tick marks on the axis.; 391If ` tx = gPad->GetTickx()` and `ty = gPad->GetTicky()` then:; 392 ; 393 tx = 1; tick marks on top side are drawn (inside); 394 tx = 2; tick marks and labels on top side are drawn; 395 ty = 1; tick marks on right side are drawn (inside); 396 ty = 2; tick marks and labels on right side are drawn; 397 ; 398By default only the left Y axis and X bottom axis are drawn; 399(`tx = ty = 0`); 400 ; 401`TPad::SetTicks(tx,ty)` allows to set these options.; 402See also The `TAxis` functions to set specific axis attributes.; 403 ; 404In case multiple color filled histograms are drawn on the same pad, the fill; 405area may hide the axis tick marks. One can force a ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
Performance,perform,performance,"he content's absolute value. A negative content is marked with a X. |; 283| ""BOX1"" | A button is drawn for each cell with surface proportional to content's absolute value. A sunken button is drawn for negative values a raised one for positive.|; 284| ""COL"" | A box is drawn for each cell with a color scale varying with contents. All the none empty bins are painted. Empty bins are not painted unless some bins have a negative content because in that case the null bins might be not empty. `TProfile2D` histograms are handled differently because, for this type of 2D histograms, it is possible to know if an empty bin has been filled or not. So even if all the bins' contents are positive some empty bins might be painted. And vice versa, if some bins have a negative content some empty bins might be not painted (default).|; 285| ""COLZ"" | Same as ""COL"". In addition the color palette is also drawn.|; 286| ""COL2"" | Alternative rendering algorithm to ""COL"". Can significantly improve rendering performance for large, non-sparse 2-D histograms.|; 287| ""COLZ2"" | Same as ""COL2"". In addition the color palette is also drawn.|; 288| ""Z CJUST"" | In combination with colored options ""COL"",""CONT0"" etc: Justify labels in the color palette at color boundaries. For more details see `TPaletteAxis`|; 289| ""CANDLE"" | Draw a candle plot along X axis.|; 290| ""CANDLEX"" | Same as ""CANDLE"".|; 291| ""CANDLEY"" | Draw a candle plot along Y axis.|; 292| ""CANDLEXn"" | Draw a candle plot along X axis. Different candle-styles with n from 1 to 6.|; 293| ""CANDLEYn"" | Draw a candle plot along Y axis. Different candle-styles with n from 1 to 6.|; 294| ""VIOLIN"" | Draw a violin plot along X axis.|; 295| ""VIOLINX"" | Same as ""VIOLIN"".|; 296| ""VIOLINY"" | Draw a violin plot along Y axis.|; 297| ""VIOLINXn"" | Draw a violin plot along X axis. Different violin-styles with n being 1 or 2.|; 298| ""VIOLINYn"" | Draw a violin plot along Y axis. Different violin-styles with n being 1 or 2.|; 299| ""CONT"" | Draw a contour plot (same",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
Safety,avoid,avoids," The Y-axis is drawn on the right side of the plot. |; 244| ""MIN0"" | Set minimum value for the Y axis to 0, equivalent to gStyle->SetHistMinimumZero(). |; 245 ; 246\anchor HP01b; 247#### Options supported for 1D histograms; 248 ; 249| Option | Description |; 250|----------|-------------------------------------------------------------------|; 251| "" "" | Default. |; 252| ""AH"" | Draw histogram without axis. ""A"" can be combined with any drawing option. For instance, ""AC"" draws the histogram as a smooth Curve without axis.|; 253| ""]["" | When this option is selected the first and last vertical lines of the histogram are not drawn.|; 254| ""B"" | Bar chart option.|; 255| ""BAR"" | Like option ""B"", but bars can be drawn with a 3D effect.|; 256| ""HBAR"" | Like option ""BAR"", but bars are drawn horizontally.|; 257| ""C"" | Draw a smooth Curve through the histogram bins.|; 258| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 259| ""E1"" | Draw error bars with perpendicular lines at the edges.|; 260| ""E2"" | Draw error bars with rectangles.|; 261| ""E3"" | Draw a fill area through the end points of the vertical error bars.|; 262| ""E4"" | Draw a smoothed filled area through the end points of the error bars.|; 263| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 264| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 265| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 266| ""L"" | Draw a line through the bin contents.|; 267| ""P"" | Draw current marker at each bin except empty bins.|; 268| ""P*"" | Draw a star marker at each bin except empty bins.|; 269| ""P0"" | Draw current marker at each bin including empty bins.|; 270| ""PIE"" | Draw histogram as a Pie Chart.|; 271| ""*H"" | Draw histogram with a * at each bin.|; 272| ""LF2"" | Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws also a fill area if the hist fill color is set b",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
Security,access,accessed,"d; 586 I : integral of bins with option ""width"" printed; 587 o : number of overflows printed; 588 u : number of underflows printed; 589 r : standard deviation printed; 590 R : standard deviation and standard deviation error printed; 591 m : mean value printed; 592 M : mean value mean error values printed; 593 e : number of entries printed; 594 n : name of histogram is printed; 595 ; 596For example, to print only name of histogram and number of entries do:; 597 ; 598 gStyle->SetOptStat(""ne"");; 599 ; 600To print only the name of the histogram do:; 601 ; 602 gStyle->SetOptStat(""n"");; 603 ; 604The default value is:; 605 ; 606 gStyle->SetOptStat(""nemr"");; 607 ; 608When a histogram is painted, a `TPaveStats` object is created and added; 609to the list of functions of the histogram. If a `TPaveStats` object; 610already exists in the histogram list of functions, the existing object is just; 611updated with the current histogram parameters.; 612 ; 613Once a histogram is painted, the statistics box can be accessed using; 614`h->FindObject(""stats"")`. In the command line it is enough to do:; 615 ; 616 Root > h->Draw(); 617 Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); 618 ; 619because after `h->Draw()` the histogram is automatically painted. But; 620in a script file the painting should be forced using `gPad->Update()`; 621in order to make sure the statistics box is created:; 622 ; 623 h->Draw();; 624 gPad->Update();; 625 TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");; 626 ; 627Without `gPad->Update()` the line `h->FindObject(""stats"")` returns a null pointer.; 628 ; 629When a histogram is drawn with the option `SAME`, the statistics box; 630is not drawn. To force the statistics box drawing with the option; 631`SAME`, the option `SAMES` must be used.; 632If the new statistics box hides the previous statistics box, one can change; 633its position with these lines (`h` being the pointer to the histogram):; 634 ; 635 Root > TPaveStats *st = (TPaveStats*)h->Find",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
Testability,log,logarithmic," 1250 ; 1251 - `a = 0`; no anchor drawn; 1252 - `a = 1`; the anchors are drawn; 1253 ; 1254 - `p = 0`; no points drawn; 1255 - `p = 1`; only outliers are drawn; 1256 - `p = 2`; all datapoints are drawn; 1257 - `p = 3`: all datapoints are drawn scattered; 1258 ; 1259 - `h = 0`; no histogram is drawn; 1260 - `h = 1`; histogram at the left or bottom side is drawn; 1261 - `h = 2`; histogram at the right or top side is drawn; 1262 - `h = 3`; histogram at left and right or top and bottom (violin-style) is drawn; 1263 ; 1264 - `z = 0`; no zero indicator line is drawn; 1265 - `z = 1`; zero indicator line is drawn.; 1266 ; 1267As one can see all individual options for both candle and violin plots can be accessed by this; 1268mechanism. In deed the keywords CANDLE(<option-string>) and VIOLIN(<option-string>) have the same; 1269meaning. So you can parametrise an option-string for a candle plot and use the keywords VIOLIN and; 1270vice versa, if you wish.; 1271 ; 1272Using a logarithmic x- or y-axis is possible for candle and violin charts.; 1273 ; 1274\since **ROOT version 6.11/01**; 1275 ; 1276a logarithmic z-axis is possible, too but will only affect violin charts of course.; 1277 ; 1278\anchor HP140a; 1279#### The CANDLE option; 1280 ; 1281<a href=""http://en.wikipedia.org/wiki/Box_plot"">A Candle plot</a> (also known as; 1282a ""box plot"" or ""whisker plot"") was invented in 1977 by John Tukey. It is a convenient; 1283way to describe graphically a data distribution (D) with only five numbers:; 1284 ; 1285 1. The minimum value of the distribution D (bottom or left whisker).; 1286 2. The lower quartile (Q1): 25% of the data points in D are less than Q1 (bottom of the box).; 1287 3. The median (M): 50% of the data points in D are less than M.; 1288 4. The upper quartile (Q3): 75% of the data points in D are less than Q3 (top of the box).; 1289 5. The maximum value of the distribution D (top or right whisker).; 1290 ; 1291In this implementation a TH2 is considered as a collection of",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
Usability,usab,usable,"ing using OpenGL](\ref HP29); 118 - [General information: plot types and supported options](\ref HP29a); 119 - [TH3 as color boxes](\ref HP290); 120 - [TH3 as boxes (spheres)](\ref HP29b); 121 - [TH3 as iso-surface(s)](\ref HP29c); 122 - [TF3 (implicit function)](\ref HP29d); 123 - [Parametric surfaces](\ref HP29e); 124 - [Interaction with the plots](\ref HP29f); 125 - [Selectable parts](\ref HP29g); 126 - [Rotation and zooming](\ref HP29h); 127 - [Panning](\ref HP29i); 128 - [Box cut](\ref HP29j); 129 - [Plot specific interactions (dynamic slicing etc.)](\ref HP29k); 130 - [Surface with option ""GLSURF""](\ref HP29l); 131 - [TF3](\ref HP29m); 132 - [Box](\ref HP29n); 133 - [Iso](\ref HP29o); 134 - [Parametric plot](\ref HP29p); 135- [Highlight mode for histogram](\ref HP30); 136 - [Highlight mode and user function](\ref HP30a); 137 ; 138 ; 139\anchor HP00; 140## Introduction; 141 ; 142 ; 143Histograms are drawn via the `THistPainter` class. Each histogram has a; 144pointer to its own painter (to be usable in a multithreaded program). When the; 145canvas has to be redrawn, the `Paint` function of each objects in the; 146pad is called. In case of histograms, `TH1::Paint` invokes directly; 147`THistPainter::Paint`.; 148 ; 149To draw a histogram `h` it is enough to do:; 150 ; 151 h->Draw();; 152 ; 153`h` can be of any kind: 1D, 2D or 3D. To choose how the histogram will; 154be drawn, the `Draw()` method can be invoked with an option. For instance; 155to draw a 2D histogram as a lego plot it is enough to do:; 156 ; 157 h->Draw(""lego"");; 158 ; 159`THistPainter` offers many options to paint 1D, 2D and 3D histograms.; 160 ; 161When the `Draw()` method of a histogram is called for the first time; 162(`TH1::Draw`), it creates a `THistPainter` object and saves a; 163pointer to this ""painter"" as a data member of the histogram. The; 164`THistPainter` class specializes in the drawing of histograms. It is; 165separated from the histogram so that one can have histograms without the; ",MatchSource.WIKI,doc/master/THistPainter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html
Integrability,depend,dependency,". ROOT: hist/histpainter/inc/THistPainter.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Variables ; THistPainter.h File Reference. #include ""TVirtualHistPainter.h""; #include ""TString.h""; #include <vector>; #include <utility>; #include <memory>. Include dependency graph for THistPainter.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  THistPainter;  The histogram painter class. More...;  ; struct  THistRenderingRegion;  . Variables; const Int_t kMaxCuts = 16;  . Variable Documentation. ◆ kMaxCuts. const Int_t kMaxCuts = 16. Definition at line 41 of file THistPainter.h. histhistpainterincTHistPainter.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/THistPainter_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8h.html
Availability,error,error,"; THistPainterThe histogram painter class.Definition THistPainter.h:50; THistPainter::ProjectSinusoidal2xystatic Int_t ProjectSinusoidal2xy(Double_t l, Double_t b, Double_t &Al, Double_t &Ab)Static function code for sinusoidal projection from Ernst-Jan Buis Source https://en....Definition THistPainter.cxx:10380; THistPainter::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histogramsDefinition THistPainter.cxx:4470; THistPainter::fYaxisTAxis * fYaxisPointer to Y axis.Definition THistPainter.h:55; THistPainter::fLegostd::unique_ptr< TPainter3dAlgorithms > fLegoPointer to a TPainter3dAlgorithms object.Definition THistPainter.h:58; THistPainter::fXbufstd::vector< Double_t > fXbufX buffer coordinates.Definition THistPainter.h:61; THistPainter::fXHighlightBinInt_t fXHighlightBinX highlight bin.Definition THistPainter.h:70; THistPainter::fCurrentF3TF3 * fCurrentF3Current TF3 function.Definition THistPainter.h:72; THistPainter::PaintErrorsvirtual void PaintErrors(Option_t *option)Draw 1D histograms error bars.Definition THistPainter.cxx:6314; THistPainter::~THistPainter~THistPainter() overridedestructor.Definition THistPainter.cxx:3242; THistPainter::fShowProjection2Int_t fShowProjection2True if a second projection must be drawn (when calling SetShowProjectionXY on a TH2)Definition THistPainter.h:68; THistPainter::PaintTF3virtual void PaintTF3()Control function to draw a 3D implicit functions.Definition THistPainter.cxx:10152; THistPainter::TableInitvirtual Int_t TableInit()Initialize various options to draw 2D histograms.Definition THistPainter.cxx:10536; THistPainter::PaintTH2PolyScatterPlotvirtual void PaintTH2PolyScatterPlot(Option_t *option)Control function to draw a TH2Poly as a scatter plot.Definition THistPainter.cxx:9885; THistPainter::ProjectMollweide2xystatic Int_t ProjectMollweide2xy(Double_t l, Double_t b, Double_t &Al, Double_t &Ab)Static function.Definition THistPainter.cxx:10412; THistPainter::ProjectAitoff2xystatic Int_t Pr",MatchSource.WIKI,doc/master/THistPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8h_source.html
Integrability,rout,routine,"Win32VirtualXProxy.cxx:70; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; kMaxCutsconst Int_t kMaxCutsDefinition THistPainter.h:41; TString.h; TVirtualHistPainter.h; TAxisClass to manage histogram axis.Definition TAxis.h:31; TCutGGraphical cut class.Definition TCutG.h:20; TF11-Dim function classDefinition TF1.h:233; TF3A 3-Dim function with parameters.Definition TF3.h:28; TGaxisThe axis painter class.Definition TGaxis.h:24; TGraph2DPainterThe TGraphDelaunay painting class.Definition TGraph2DPainter.h:31; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; THistPainterThe histogram painter class.Definition THistPainter.h:50; THistPainter::ProjectSinusoidal2xystatic Int_t ProjectSinusoidal2xy(Double_t l, Double_t b, Double_t &Al, Double_t &Ab)Static function code for sinusoidal projection from Ernst-Jan Buis Source https://en....Definition THistPainter.cxx:10380; THistPainter::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histogramsDefinition THistPainter.cxx:4470; THistPainter::fYaxisTAxis * fYaxisPointer to Y axis.Definition THistPainter.h:55; THistPainter::fLegostd::unique_ptr< TPainter3dAlgorithms > fLegoPointer to a TPainter3dAlgorithms object.Definition THistPainter.h:58; THistPainter::fXbufstd::vector< Double_t > fXbufX buffer coordinates.Definition THistPainter.h:61; THistPainter::fXHighlightBinInt_t fXHighlightBinX highlight bin.Definition THistPainter.h:70; THistPainter::fCurrentF3TF3 * fCurrentF3Current TF3 function.Definition THistPainter.h:72; THistPainter::PaintErrorsvirtual void PaintErrors(Option_t *option)Draw 1D histograms error bars.Definition THistPainter.cxx:6314; THistPainter::~THistPainter~THistPainter() overridedestructor.Definition THistPainter.cxx:3242; THistPainter::fShowProjection2Int_t fShowProjection2True if a second projection must be drawn (when calling SetShowProjectionXY on a TH2)Definition THistPainter.h:68; THistPainter::PaintTF3vir",MatchSource.WIKI,doc/master/THistPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8h_source.html
Usability,clear,clear,"ter::GetBestFormatstatic const char * GetBestFormat(Double_t v, Double_t e, const char *f)This function returns the best format to print the error value (e) knowing the parameter value (v) an...Definition THistPainter.cxx:10714; THistPainter::PaintContourvirtual void PaintContour(Option_t *option)Control function to draw a 2D histogram as a contour plot.Definition THistPainter.cxx:5932; THistPainter::fCutsTCutG * fCuts[kMaxCuts]Pointers to graphical cuts.Definition THistPainter.h:65; THistPainter::PaintTablevirtual void PaintTable(Option_t *option)Control function to draw 2D/3D histograms (tables).Definition THistPainter.cxx:9629; THistPainter::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute the actions corresponding to event.Definition THistPainter.cxx:3464; THistPainter::PaintInitHvirtual Int_t PaintInitH()Compute histogram parameters used by the drawing routines for a rotated pad.Definition THistPainter.cxx:7334; THistPainter::PaintFramevirtual void PaintFrame()Calculate range and clear pad (canvas).Definition THistPainter.cxx:6777; THistPainter::fCutsOptInt_t fCutsOpt[kMaxCuts]Sign of each cut.Definition THistPainter.h:64; THistPainter::GetYHighlightBinvirtual Int_t GetYHighlightBin() constDefinition THistPainter.h:88; THistPainter::PaintH3Isovirtual void PaintH3Iso()Control function to draw a 3D histogram with Iso Surfaces.Definition THistPainter.cxx:7892; THistPainter::fYbufstd::vector< Double_t > fYbufY buffer coordinates.Definition THistPainter.h:62; THistPainter::PaintH3BoxRastervirtual void PaintH3BoxRaster()Control function to draw a 3D histogram with boxes.Definition THistPainter.cxx:7690; THistPainter::PaintHistvirtual void PaintHist(Option_t *option)Control routine to draw 1D histogramsDefinition THistPainter.cxx:6837; THistPainter::SetHighlightvoid SetHighlight() overrideSet highlight (enable/disable) mode for fH.Definition THistPainter.cxx:3857; THistPainter::DefineColorLevelsvirtual void DefineColorLevels(Int_t ndivz)D",MatchSource.WIKI,doc/master/THistPainter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THistPainter_8h_source.html
Availability,error,errors,"; 388/// Initialize a THnSparseCompactBinCoord object with ""dim"" dimensions; 389/// and ""bins"" holding the number of bins for each dimension.; 390 ; 391THnSparseCompactBinCoord::THnSparseCompactBinCoord(Int_t dim, const Int_t* nbins):; 392 THnSparseCoordCompression(dim, nbins),; 393 fHash(0), fCoordBuffer(nullptr), fCurrentBin(nullptr); 394{; 395 fCurrentBin = new Int_t[dim];; 396 size_t bufAllocSize = GetBufferSize();; 397 if (bufAllocSize < sizeof(Long64_t)); 398 bufAllocSize = sizeof(Long64_t);; 399 fCoordBuffer = new Char_t[bufAllocSize];; 400}; 401 ; 402 ; 403////////////////////////////////////////////////////////////////////////////////; 404/// destruct a THnSparseCompactBinCoord; 405 ; 406THnSparseCompactBinCoord::~THnSparseCompactBinCoord(); 407{; 408 delete [] fCoordBuffer;; 409 delete [] fCurrentBin;; 410}; 411 ; 412/** \class THnSparseArrayChunk; 413THnSparseArrayChunk is used internally by THnSparse.; 414THnSparse stores its (dynamic size) array of bin coordinates and their; 415contents (and possibly errors) in a TObjArray of THnSparseArrayChunk. Each; 416of the chunks holds an array of THnSparseCompactBinCoord and the content; 417(a TArray*), which is created outside (by the templated derived classes of; 418THnSparse) and passed in at construction time.; 419*/; 420 ; 421ClassImp(THnSparseArrayChunk);; 422 ; 423////////////////////////////////////////////////////////////////////////////////; 424/// (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; 425/// and create an ArrayF for errors if ""errors"" is true.; 426 ; 427THnSparseArrayChunk::THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont):; 428 fCoordinateAllocationSize(-1), fSingleCoordinateSize(coordsize), fCoordinatesSize(0),; 429 fCoordinates(nullptr), fContent(cont),; 430 fSumw2(nullptr); 431{; 432 fCoordinateAllocationSize = fSingleCoordinateSize * cont->GetSize();; 433 fCoordinates = new Char_t[fCoordinateAllocationSize];; 434 if (errors) Sumw2();",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
Energy Efficiency,allocate,allocated,,MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
Integrability,depend,depend,"; 82 && !fHist->IsInRange(useCoordBuf); 83 && (fHaveSkippedBin = kTRUE /* assignment! */));; 84 ; 85 if (coord && coord[0] == -1) {; 86 if (fCoord[0] == -1) {; 87 fHist->GetBinContent(fIndex, coord);; 88 } else {; 89 memcpy(coord, fCoord, fHist->GetNdimensions() * sizeof(Int_t));; 90 }; 91 }; 92 ; 93 return fIndex;; 94}; 95 ; 96 ; 97 ; 98/** \class THnSparseCoordCompression; 99THnSparseCoordCompression is a class used by THnSparse internally. It; 100represents a compacted n-dimensional array of bin coordinates (indices).; 101As the total number of bins in each dimension is known by THnSparse, bin; 102indices can be compacted to only use the amount of bins needed by the total; 103number of bins in each dimension. E.g. for a THnSparse with; 104{15, 100, 2, 20, 10, 100} bins per dimension, a bin index will only occupy; 10528 bits (4+7+1+5+4+7), i.e. less than a 32bit integer. The tricky part is; 106the fast compression and decompression, the platform-independent storage; 107(think of endianness: the bits of the number 0x123456 depend on the; 108platform), and the hashing needed by THnSparseArrayChunk.; 109*/; 110 ; 111 ; 112class THnSparseCoordCompression {; 113public:; 114 THnSparseCoordCompression(Int_t dim, const Int_t* nbins);; 115 THnSparseCoordCompression(const THnSparseCoordCompression& other);; 116 ~THnSparseCoordCompression();; 117 ; 118 THnSparseCoordCompression& operator=(const THnSparseCoordCompression& other);; 119 ; 120 ULong64_t GetHashFromBuffer(const Char_t* buf) const;; 121 Int_t GetBufferSize() const { return fCoordBufferSize; }; 122 Int_t GetNdimensions() const { return fNdimensions; }; 123 void SetCoordFromBuffer(const Char_t* buf_in, Int_t* coord_out) const;; 124 ULong64_t SetBufferFromCoord(const Int_t* coord_in, Char_t* buf_out) const;; 125 ; 126protected:; 127 Int_t GetNumBits(Int_t n) const {; 128 // return the number of bits allocated by the number ""n""; 129 Int_t r = (n > 0);; 130 while (n/=2) ++r;; 131 return r;; 132 }; 133private:; 134 Int_",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
Security,hash,hashing,"; 82 && !fHist->IsInRange(useCoordBuf); 83 && (fHaveSkippedBin = kTRUE /* assignment! */));; 84 ; 85 if (coord && coord[0] == -1) {; 86 if (fCoord[0] == -1) {; 87 fHist->GetBinContent(fIndex, coord);; 88 } else {; 89 memcpy(coord, fCoord, fHist->GetNdimensions() * sizeof(Int_t));; 90 }; 91 }; 92 ; 93 return fIndex;; 94}; 95 ; 96 ; 97 ; 98/** \class THnSparseCoordCompression; 99THnSparseCoordCompression is a class used by THnSparse internally. It; 100represents a compacted n-dimensional array of bin coordinates (indices).; 101As the total number of bins in each dimension is known by THnSparse, bin; 102indices can be compacted to only use the amount of bins needed by the total; 103number of bins in each dimension. E.g. for a THnSparse with; 104{15, 100, 2, 20, 10, 100} bins per dimension, a bin index will only occupy; 10528 bits (4+7+1+5+4+7), i.e. less than a 32bit integer. The tricky part is; 106the fast compression and decompression, the platform-independent storage; 107(think of endianness: the bits of the number 0x123456 depend on the; 108platform), and the hashing needed by THnSparseArrayChunk.; 109*/; 110 ; 111 ; 112class THnSparseCoordCompression {; 113public:; 114 THnSparseCoordCompression(Int_t dim, const Int_t* nbins);; 115 THnSparseCoordCompression(const THnSparseCoordCompression& other);; 116 ~THnSparseCoordCompression();; 117 ; 118 THnSparseCoordCompression& operator=(const THnSparseCoordCompression& other);; 119 ; 120 ULong64_t GetHashFromBuffer(const Char_t* buf) const;; 121 Int_t GetBufferSize() const { return fCoordBufferSize; }; 122 Int_t GetNdimensions() const { return fNdimensions; }; 123 void SetCoordFromBuffer(const Char_t* buf_in, Int_t* coord_out) const;; 124 ULong64_t SetBufferFromCoord(const Int_t* coord_in, Char_t* buf_out) const;; 125 ; 126protected:; 127 Int_t GetNumBits(Int_t n) const {; 128 // return the number of bits allocated by the number ""n""; 129 Int_t r = (n > 0);; 130 while (n/=2) ++r;; 131 return r;; 132 }; 133private:; 134 Int_",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
Testability,log,logic,"// Use THnIter instead.; 895 ; 896ROOT::Internal::THnBaseBinIter* THnSparse::CreateIter(Bool_t respectAxisRange) const; 897{; 898 return new THnSparseBinIter(respectAxisRange, this);; 899}; 900 ; 901////////////////////////////////////////////////////////////////////////////////; 902/// Set content of bin with index ""bin"" to ""v""; 903 ; 904void THnSparse::SetBinContent(Long64_t bin, Double_t v); 905{; 906 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 907 chunk->fContent->SetAt(v, bin % fChunkSize);; 908 ++fEntries;; 909}; 910 ; 911////////////////////////////////////////////////////////////////////////////////; 912/// Set error of bin with index ""bin"" to ""e"", enable errors if needed; 913 ; 914void THnSparse::SetBinError2(Long64_t bin, Double_t e2); 915{; 916 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 917 if (!chunk->fSumw2 ) {; 918 // if fSumw2 is zero GetCalculateErrors should return false; 919 if (GetCalculateErrors()) {; 920 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 921 }; 922 Sumw2(); // enable error calculation; 923 }; 924 ; 925 chunk->fSumw2->SetAt(e2, bin % fChunkSize);; 926}; 927 ; 928////////////////////////////////////////////////////////////////////////////////; 929/// Add ""e"" to error of bin with index ""bin"", enable errors if needed; 930 ; 931void THnSparse::AddBinError2(Long64_t bin, Double_t e2); 932{; 933 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 934 if (!chunk->fSumw2 ) {; 935 // if fSumw2 is zero GetCalculateErrors should return false; 936 if (GetCalculateErrors()) {; 937 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 938 }; 939 Sumw2(); // enable error calculation; 940 }; 941 ; 942 (*chunk->fSumw2)[bin % fChunkSize] += e2;; 943}; 944 ; 945////////////////////////////////////////////////////////////////////////////////; 946/// Enable calculation of errors; 947 ; 948void THnSparse::Sumw2(); 949{; 950 if (GetCalculateErrors()) return;; 951 ; 952 fTsumw2 = 0.;; 953 TIter iChunk(&fB",MatchSource.WIKI,doc/master/THnSparse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html
Availability,error,error,"t Double_t *xmax=nullptr, Int_t chunksize=1024 *16)Definition THnSparse.h:210; THnSparseEfficient multidimensional histogram.Definition THnSparse.h:37; THnSparse::ProjectionTH1D * Projection(Int_t xDim, Option_t *option="""") constForwards to THnBase::Projection().Definition THnSparse.h:134; THnSparse::GetSparseFractionBinsDouble_t GetSparseFractionBins() constReturn the amount of filled bins over all bins.Definition THnSparse.cxx:854; THnSparse::GetSparseFractionMemDouble_t GetSparseFractionMem() constReturn the amount of used memory over memory that would be used by a non-sparse n-dimensional histogr...Definition THnSparse.cxx:865; THnSparse::RebinTHnSparse * Rebin(Int_t group) constDefinition THnSparse.h:159; THnSparse::Resetvoid Reset(Option_t *option="""") overrideClear the histogram.Definition THnSparse.cxx:962; THnSparse::GetNChunksInt_t GetNChunks() constDefinition THnSparse.h:89; THnSparse::operator=THnSparse & operator=(const THnSparse &)=delete; THnSparse::AddBinError2void AddBinError2(Long64_t bin, Double_t e2) overrideAdd ""e"" to error of bin with index ""bin"", enable errors if needed.Definition THnSparse.cxx:931; THnSparse::ProjectionTH3D * Projection(Int_t xDim, Int_t yDim, Int_t zDim, Option_t *option="""") constForwards to THnBase::Projection().Definition THnSparse.h:149; THnSparse::SetBinContentvoid SetBinContent(const Int_t *idx, Double_t v)Forwards to THnBase::SetBinContent().Definition THnSparse.h:105; THnSparse::GetChunkTHnSparseArrayChunk * GetChunk(Int_t idx) constDefinition THnSparse.h:56; THnSparse::fCompactCoordTHnSparseCompactBinCoord * fCompactCoord! Compact coordinateDefinition THnSparse.h:44; THnSparse::GetChunkSizeInt_t GetChunkSize() constDefinition THnSparse.h:88; THnSparse::GetBinContentDouble_t GetBinContent(const Int_t *idx) constForwards to THnBase::GetBinContent() overload.Definition THnSparse.h:121; THnSparse::fFilledBinsLong64_t fFilledBinsNumber of filled bins.Definition THnSparse.h:40; THnSparse::GetBinLong64_t GetBin(const Int_t *i",MatchSource.WIKI,doc/master/THnSparse_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html
Energy Efficiency,efficient,efficient,". ROOT: hist/hist/inc/THnSparse.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. THnSparse.h. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Axel Naumann (2007-09-11); 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_THnSparse; 13#define ROOT_THnSparse; 14 ; 15/*************************************************************************; 16 ; 17 THnSparse: histogramming multi-dimensional, sparse distributions in; 18 a memory-efficient way.; 19 ; 20*************************************************************************/; 21 ; 22 ; 23#include ""THnBase.h""; 24#include ""TExMap.h""; 25#include ""THnSparse_Internal.h""; 26 ; 27// needed only for template instantiations of THnSparseT:; 28#include ""TArrayF.h""; 29#include ""TArrayL.h""; 30#include ""TArrayL64.h""; 31#include ""TArrayI.h""; 32#include ""TArrayS.h""; 33#include ""TArrayC.h""; 34 ; 35class THnSparseCompactBinCoord;; 36 ; 37class THnSparse: public THnBase {; 38 private:; 39 Int_t fChunkSize; ///< Number of entries for each chunk; 40 Long64_t fFilledBins; ///< Number of filled bins; 41 TObjArray fBinContent; ///< Array of THnSparseArrayChunk; 42 TExMap fBins; ///<! Filled bins; 43 TExMap fBinsContinued; ///<! Filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1); 44 THnSparseCompactBinCoord *fCompactCoord; ///<! Compact coordinate; 45 ; 46 THnSparse(const THnSparse&) = delete;; 47 THnSparse& operator=(const THnSparse&) = delete;; 48 ; 49 protected:; 50 ; 51 THnSparse();; 52 THnSparse(const char* name, const char* title, Int_t dim,; 53 const Int_t* nbins, const Double_t* xmin, const Double",MatchSource.WIKI,doc/master/THnSparse_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html
Integrability,interface,interfaces,"t of a using; 148 /// declaration.; 149 TH3D* Projection(Int_t xDim, Int_t yDim, Int_t zDim,; 150 Option_t* option = """") const {; 151 return THnBase::Projection(xDim, yDim, zDim, option);; 152 }; 153 ; 154 THnSparse* Projection(Int_t ndim, const Int_t* dim,; 155 Option_t* option = """") const {; 156 return (THnSparse*) ProjectionND(ndim, dim, option);; 157 }; 158 ; 159 THnSparse* Rebin(Int_t group) const {; 160 return (THnSparse*) RebinBase(group);; 161 }; 162 THnSparse* Rebin(const Int_t* group) const {; 163 return (THnSparse*) RebinBase(group);; 164 }; 165 ; 166 void Reset(Option_t* option = """") override;; 167 void Sumw2() override;; 168 ; 169 ClassDefOverride(THnSparse, 3); // Interfaces of sparse n-dimensional histogram; 170};; 171 ; 172 ; 173 ; 174//______________________________________________________________________________; 175/** \class THnSparseT; 176 Templated implementation of the abstract base THnSparse.; 177 All functionality and the interfaces to be used are in THnSparse!; 178 ; 179 THnSparse does not know how to store any bin content itself. Instead, this; 180 is delegated to the derived, templated class: the template parameter decides; 181 what the format for the bin content is. In fact it even defines the array; 182 itself; possible implementations probably derive from TArray.; 183 ; 184 Typedefs exist for template parameters with ROOT's generic types:; 185 ; 186 Templated name | Typedef | Bin content type; 187 ----------------------|---------------|--------------------; 188 THnSparseT<TArrayC> | THnSparseC | Char_t; 189 THnSparseT<TArrayS> | THnSparseS | Short_t; 190 THnSparseT<TArrayI> | THnSparseI | Int_t; 191 THnSparseT<TArrayL64> | THnSparseL | Long64_t; 192 THnSparseT<TArrayF> | THnSparseF | Float_t; 193 THnSparseT<TArrayD> | THnSparseD | Double_t; 194 ; 195 We recommend to use THnSparseC wherever possible, and to map its value space; 196 of 256 possible values to e.g. float values outside the class. This saves an; 197 enormous amount of memory",MatchSource.WIKI,doc/master/THnSparse_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html
Security,hash,hashes,"20*************************************************************************/; 21 ; 22 ; 23#include ""THnBase.h""; 24#include ""TExMap.h""; 25#include ""THnSparse_Internal.h""; 26 ; 27// needed only for template instantiations of THnSparseT:; 28#include ""TArrayF.h""; 29#include ""TArrayL.h""; 30#include ""TArrayL64.h""; 31#include ""TArrayI.h""; 32#include ""TArrayS.h""; 33#include ""TArrayC.h""; 34 ; 35class THnSparseCompactBinCoord;; 36 ; 37class THnSparse: public THnBase {; 38 private:; 39 Int_t fChunkSize; ///< Number of entries for each chunk; 40 Long64_t fFilledBins; ///< Number of filled bins; 41 TObjArray fBinContent; ///< Array of THnSparseArrayChunk; 42 TExMap fBins; ///<! Filled bins; 43 TExMap fBinsContinued; ///<! Filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1); 44 THnSparseCompactBinCoord *fCompactCoord; ///<! Compact coordinate; 45 ; 46 THnSparse(const THnSparse&) = delete;; 47 THnSparse& operator=(const THnSparse&) = delete;; 48 ; 49 protected:; 50 ; 51 THnSparse();; 52 THnSparse(const char* name, const char* title, Int_t dim,; 53 const Int_t* nbins, const Double_t* xmin, const Double_t* xmax,; 54 Int_t chunksize);; 55 THnSparseCompactBinCoord* GetCompactCoord() const;; 56 THnSparseArrayChunk* GetChunk(Int_t idx) const {; 57 return (THnSparseArrayChunk*) fBinContent[idx]; }; 58 ; 59 THnSparseArrayChunk* AddChunk();; 60 void Reserve(Long64_t nbins) override;; 61 void FillExMap();; 62 virtual TArray* GenerateArray() const = 0;; 63 Long64_t GetBinIndexForCurrentBin(Bool_t allocate);; 64 ; 65 /// Increment the bin content of ""bin"" by ""w"",; 66 /// return the bin index.; 67 void FillBin(Long64_t bin, Double_t w) override {; 68 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 69 chunk->AddBinContent(bin % fChunkSize, w);; 70 FillBinBase(w);; 71 }; 72 void InitStorage(Int_t* nbins, Int_t chunkSize) override;; 73 ; 74 public:; 75 ~THnSparse() override;; 76 ; 77 static THnSparse* CreateSparse(const char* name, const char* title,; 78 co",MatchSource.WIKI,doc/master/THnSparse_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html
Availability,error,errors," 139 THnD (typedef for THnT<Double_t>): bin content held by a Double_t,; 140 THnF (typedef for THnT<Float_t>): bin content held by a Float_t,; 141 THnL (typedef for THnT<Long64_t>): bin content held by a Long64_t,; 142 THnI (typedef for THnT<Int_t>): bin content held by an Int_t,; 143 THnS (typedef for THnT<Short_t>): bin content held by a Short_t,; 144 THnC (typedef for THnT<Char_t>): bin content held by a Char_t,; 145 ; 146They take name and title, the number of dimensions, and for each dimension; 147the number of bins, the minimal, and the maximal value on the dimension's; 148axis. A TH2F h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; 149 ; 150 Int_t bins[2] = {10, 20};; 151 Double_t xmin[2] = {0., -5.};; 152 Double_t xmax[2] = {10., 5.};; 153 THnF hn(""hn"", ""hn"", 2, bins, xmin, xmax);; 154 ; 155## Filling; 156A THn is filled just like a regular histogram, using; 157THn::Fill(x, weight), where x is a n-dimensional Double_t value.; 158To take errors into account, Sumw2() must be called before filling the; 159histogram.; 160Storage is allocated when the first bin content is stored.; 161 ; 162## Projections; 163The dimensionality of a THn can be reduced by projecting it to; 1641, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; 165a THn. See the Projection() members. To only project parts of the; 166histogram, call; 167 ; 168 hn->GetAxis(12)->SetRange(from_bin, to_bin);; 169 ; 170## Conversion from other histogram classes; 171The static factory function THn::CreateHn() can be used to create a THn; 172from a TH1, TH2, TH3, THnSparse and (for copying) even from a THn. The; 173created THn will have compatble storage type, i.e. calling CreateHn() on; 174a TH2F will create a THnF.; 175*/; 176 ; 177ClassImp(THn);; 178 ; 179////////////////////////////////////////////////////////////////////////////////; 180/// Construct a THn.; 181 ; 182THn::THn(const char* name, const char* title,; 183 Int_t dim, const Int_t* nbins,; 184 const Double_t* xm",MatchSource.WIKI,doc/master/THn_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THn_8cxx_source.html
Energy Efficiency,allocate,allocated," THnF (typedef for THnT<Float_t>): bin content held by a Float_t,; 141 THnL (typedef for THnT<Long64_t>): bin content held by a Long64_t,; 142 THnI (typedef for THnT<Int_t>): bin content held by an Int_t,; 143 THnS (typedef for THnT<Short_t>): bin content held by a Short_t,; 144 THnC (typedef for THnT<Char_t>): bin content held by a Char_t,; 145 ; 146They take name and title, the number of dimensions, and for each dimension; 147the number of bins, the minimal, and the maximal value on the dimension's; 148axis. A TH2F h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; 149 ; 150 Int_t bins[2] = {10, 20};; 151 Double_t xmin[2] = {0., -5.};; 152 Double_t xmax[2] = {10., 5.};; 153 THnF hn(""hn"", ""hn"", 2, bins, xmin, xmax);; 154 ; 155## Filling; 156A THn is filled just like a regular histogram, using; 157THn::Fill(x, weight), where x is a n-dimensional Double_t value.; 158To take errors into account, Sumw2() must be called before filling the; 159histogram.; 160Storage is allocated when the first bin content is stored.; 161 ; 162## Projections; 163The dimensionality of a THn can be reduced by projecting it to; 1641, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; 165a THn. See the Projection() members. To only project parts of the; 166histogram, call; 167 ; 168 hn->GetAxis(12)->SetRange(from_bin, to_bin);; 169 ; 170## Conversion from other histogram classes; 171The static factory function THn::CreateHn() can be used to create a THn; 172from a TH1, TH2, TH3, THnSparse and (for copying) even from a THn. The; 173created THn will have compatble storage type, i.e. calling CreateHn() on; 174a TH2F will create a THnF.; 175*/; 176 ; 177ClassImp(THn);; 178 ; 179////////////////////////////////////////////////////////////////////////////////; 180/// Construct a THn.; 181 ; 182THn::THn(const char* name, const char* title,; 183 Int_t dim, const Int_t* nbins,; 184 const Double_t* xmin, const Double_t* xmax):; 185 THnBase(name, title, dim, nbins, xmin, xmax),",MatchSource.WIKI,doc/master/THn_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THn_8cxx_source.html
Integrability,interface,interface," type, i.e. calling CreateHn() on; 174a TH2F will create a THnF.; 175*/; 176 ; 177ClassImp(THn);; 178 ; 179////////////////////////////////////////////////////////////////////////////////; 180/// Construct a THn.; 181 ; 182THn::THn(const char* name, const char* title,; 183 Int_t dim, const Int_t* nbins,; 184 const Double_t* xmin, const Double_t* xmax):; 185 THnBase(name, title, dim, nbins, xmin, xmax),; 186 fSumw2(dim, nbins, kTRUE /*overflow*/); 187{; 188}; 189 ; 190THn::THn(const char *name, const char *title, Int_t dim, const Int_t *nbins,; 191 const std::vector<std::vector<double>> &xbins); 192 : THnBase(name, title, dim, nbins, xbins), fSumw2(dim, nbins, kTRUE /*overflow*/); 193{; 194}; 195 ; 196////////////////////////////////////////////////////////////////////////////////; 197/// Destruct a THn; 198 ; 199THn::~THn(); 200{; 201}; 202 ; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Create an iterator over all bins. Public interface is THnIter.; 206 ; 207ROOT::Internal::THnBaseBinIter* THn::CreateIter(Bool_t respectAxisRange) const; 208{; 209 return new THnBinIter(GetNdimensions(), GetListOfAxes(), &GetArray(),; 210 respectAxisRange);; 211}; 212 ; 213////////////////////////////////////////////////////////////////////////////////; 214/// Enable calculation of errors; 215 ; 216void THn::Sumw2() {; 217 if (!GetCalculateErrors()) {; 218 fTsumw2 = 0.;; 219 }; 220 // fill sumw2 array with current content; 221 TNDArray & content = GetArray();; 222 Long64_t nbins = GetNbins();; 223 for (Long64_t ibin = 0; ibin < nbins; ++ibin); 224 fSumw2.At(ibin) = content.AtAsDouble(ibin);; 225}; 226 ; 227 ; 228////////////////////////////////////////////////////////////////////////////////; 229/// Create the coordinate buffer. Outlined to hide allocation; 230/// from inlined functions.; 231 ; 232void THn::AllocCoordBuf() const; 233{; 234 fCoordBuf.assign(fNdimensions, 0);; 235}; 236 ; 237////////////////////////////////////////////",MatchSource.WIKI,doc/master/THn_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THn_8cxx_source.html
Integrability,depend,dependency,". ROOT: hist/hist/inc/THn.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Typedefs ; THn.h File Reference. #include ""THnBase.h""; #include ""TNDArray.h""; #include ""TArrayD.h""; #include ""TAxis.h"". Include dependency graph for THn.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  THn;  Multidimensional histogram. More...;  ; class  THnT< T >;  Templated implementation of the abstract base THn. More...;  . Typedefs; typedef THnT< Char_t > THnC;  ; typedef THnT< Double_t > THnD;  ; typedef THnT< Float_t > THnF;  ; typedef THnT< Int_t > THnI;  ; typedef THnT< Long64_t > THnL;  ; typedef THnT< Long64_t > THnL64;  ; typedef THnT< Short_t > THnS;  . Typedef Documentation. ◆ THnC. typedef THnT<Char_t> THnC. Definition at line 245 of file THn.h. ◆ THnD. typedef THnT<Double_t> THnD. Definition at line 244 of file THn.h. ◆ THnF. typedef THnT<Float_t> THnF. Definition at line 243 of file THn.h. ◆ THnI. typedef THnT<Int_t> THnI. Definition at line 247 of file THn.h. ◆ THnL. typedef THnT<Long64_t> THnL. Definition at line 248 of file THn.h. ◆ THnL64. typedef THnT<Long64_t> THnL64. Definition at line 249 of file THn.h. ◆ THnS. typedef THnT<Short_t> THnS. Definition at line 246 of file THn.h. histhistincTHn.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/THn_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THn_8h.html
Availability,error,error," TH1D* Projection(Int_t xDim, Option_t* option = """") const {; 148 return THnBase::Projection(xDim, option);; 149 }; 150 ; 151 /// Forwards to THnBase::Projection().; 152 /// Non-virtual, as a CINT-compatible replacement of a using declaration.; 153 TH2D* Projection(Int_t yDim, Int_t xDim,; 154 Option_t* option = """") const {; 155 return THnBase::Projection(yDim, xDim, option);; 156 }; 157 ; 158 /// Forwards to THnBase::Projection().; 159 /// Non-virtual, as a CINT-compatible replacement of a using declaration.; 160 TH3D* Projection(Int_t xDim, Int_t yDim, Int_t zDim,; 161 Option_t* option = """") const {; 162 return THnBase::Projection(xDim, yDim, zDim, option);; 163 }; 164 ; 165 THn* Projection(Int_t ndim, const Int_t* dim,; 166 Option_t* option = """") const {; 167 return (THn*) ProjectionND(ndim, dim, option);; 168 }; 169 ; 170 THn* Rebin(Int_t group) const {; 171 return (THn*) RebinBase(group);; 172 }; 173 THn* Rebin(const Int_t* group) const {; 174 return (THn*) RebinBase(group);; 175 }; 176 ; 177 void Reset(Option_t* option = """") override;; 178 ; 179protected:; 180 TNDArrayT<Double_t> fSumw2; // bin error, lazy allocation happens in TNDArrayT; 181 mutable std::vector<Int_t> fCoordBuf; //! Temporary buffer; 182 ; 183 ClassDefOverride(THn, 1); //Base class for multi-dimensional histogram; 184};; 185 ; 186 ; 187//______________________________________________________________________________; 188/** \class THnT; 189 Templated implementation of the abstract base THn.; 190 All functionality and the interfaces to be used are in THn!; 191 ; 192 THn does not know how to store any bin content itself. Instead, this; 193 is delegated to the derived, templated class: the template parameter decides; 194 what the format for the bin content is. The actual storage is delegated to; 195 TNDArrayT<T>.; 196 ; 197 Typedefs exist for template parameters with ROOT's generic types:; 198 ; 199 Templated name | Typedef | Bin content type; 200 -----------------|---------------|----------------",MatchSource.WIKI,doc/master/THn_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THn_8h_source.html
Energy Efficiency,allocate,allocate,"aseBinIter* CreateIter(Bool_t respectAxisRange) const override;; 54 Long64_t GetNbins() const override { return GetArray().GetNbins(); }; 55 ; 56 Long64_t GetBin(const Int_t* idx) const override {; 57 return GetArray().GetBin(idx);; 58 }; 59 Long64_t GetBin(const Double_t* x) const override {; 60 if (fCoordBuf.empty()); 61 AllocCoordBuf();; 62 for (Int_t d = 0; d < fNdimensions; ++d) {; 63 fCoordBuf[d] = GetAxis(d)->FindFixBin(x[d]);; 64 }; 65 return GetArray().GetBin(fCoordBuf.data());; 66 }; 67 Long64_t GetBin(const char* name[]) const override {; 68 if (fCoordBuf.empty()); 69 AllocCoordBuf();; 70 for (Int_t d = 0; d < fNdimensions; ++d) {; 71 fCoordBuf[d] = GetAxis(d)->FindBin(name[d]);; 72 }; 73 return GetArray().GetBin(fCoordBuf.data());; 74 }; 75 ; 76 Long64_t GetBin(const Int_t* idx, Bool_t /*allocate*/ = kTRUE) override {; 77 return const_cast<const THn*>(this)->GetBin(idx);; 78 }; 79 Long64_t GetBin(const Double_t* x, Bool_t /*allocate*/ = kTRUE) override {; 80 return const_cast<const THn*>(this)->GetBin(x);; 81 }; 82 Long64_t GetBin(const char* name[], Bool_t /*allocate*/ = kTRUE) override {; 83 return const_cast<const THn*>(this)->GetBin(name);; 84 }; 85 ; 86 /// Increment the bin content of ""bin"" by ""w"", return the bin index.; 87 void FillBin(Long64_t bin, Double_t w) override {; 88 GetArray().AddAt(bin, w);; 89 if (GetCalculateErrors()) {; 90 fSumw2.AddAt(bin, w * w);; 91 }; 92 FillBinBase(w);; 93 }; 94 ; 95 /// Forwards to THnBase::SetBinContent().; 96 /// Non-virtual, CINT-compatible replacement of a using declaration.; 97 void SetBinContent(const Int_t* idx, Double_t v) {; 98 THnBase::SetBinContent(idx, v);; 99 }; 100 void SetBinContent(Long64_t bin, Double_t v) override {; 101 GetArray().SetAsDouble(bin, v);; 102 }; 103 void SetBinError2(Long64_t bin, Double_t e2) override {; 104 if (!GetCalculateErrors()) Sumw2();; 105 fSumw2.At(bin) = e2;; 106 }; 107 /// Forwards to THnBase::SetBinContent().; 108 /// Non-virtual, CINT-compatible replacement of a us",MatchSource.WIKI,doc/master/THn_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THn_8h_source.html
Integrability,interface,interfaces,"_t yDim, Int_t zDim,; 161 Option_t* option = """") const {; 162 return THnBase::Projection(xDim, yDim, zDim, option);; 163 }; 164 ; 165 THn* Projection(Int_t ndim, const Int_t* dim,; 166 Option_t* option = """") const {; 167 return (THn*) ProjectionND(ndim, dim, option);; 168 }; 169 ; 170 THn* Rebin(Int_t group) const {; 171 return (THn*) RebinBase(group);; 172 }; 173 THn* Rebin(const Int_t* group) const {; 174 return (THn*) RebinBase(group);; 175 }; 176 ; 177 void Reset(Option_t* option = """") override;; 178 ; 179protected:; 180 TNDArrayT<Double_t> fSumw2; // bin error, lazy allocation happens in TNDArrayT; 181 mutable std::vector<Int_t> fCoordBuf; //! Temporary buffer; 182 ; 183 ClassDefOverride(THn, 1); //Base class for multi-dimensional histogram; 184};; 185 ; 186 ; 187//______________________________________________________________________________; 188/** \class THnT; 189 Templated implementation of the abstract base THn.; 190 All functionality and the interfaces to be used are in THn!; 191 ; 192 THn does not know how to store any bin content itself. Instead, this; 193 is delegated to the derived, templated class: the template parameter decides; 194 what the format for the bin content is. The actual storage is delegated to; 195 TNDArrayT<T>.; 196 ; 197 Typedefs exist for template parameters with ROOT's generic types:; 198 ; 199 Templated name | Typedef | Bin content type; 200 -----------------|---------------|--------------------; 201 THnT<Char_t> | THnC | Char_t; 202 THnT<Short_t> | THnS | Short_t; 203 THnT<Int_t> | THnI | Int_t; 204 THnT<Long64_t> | THnL | Long64_t; 205 THnT<Float_t> | THnF | Float_t; 206 THnT<Double_t> | THnD | Double_t; 207 ; 208 We recommend to use THnC wherever possible, and to map its value space; 209 of 256 possible values to e.g. float values outside the class. This saves an; 210 enormous amount of memory. Only if more than 256 values need to be; 211 distinguished should e.g. THnS or even THnF be chosen.; 212 ; 213 Implementation detail: the",MatchSource.WIKI,doc/master/THn_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THn_8h_source.html
Security,access,accessible,". ROOT: tutorials/hist/thstackcolorscheme.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. thstackcolorscheme.C File ReferenceTutorials » Histograms tutorials. Detailed Description; This example demonstrates how to use the accessible color schemes with THStack. ; In this example, the color scheme with six colors is used. It also shows that the grayscale version is an acceptable alternative. ; void thstackcolorscheme(); {; auto c1 = new TCanvas();; auto hs = new THStack(""hs"",""Stacked 1D histograms colored using 6-colors scheme"");; ; // Create six 1-d histograms and add them in the stack; auto h1st = new TH1F(""h1st"",""A"",100,-4,4);; h1st->FillRandom(""gaus"",20000);; h1st->SetFillColor(kP6Blue);; hs->Add(h1st);; ; auto h2st = new TH1F(""h2st"",""B"",100,-4,4);; h2st->FillRandom(""gaus"",15000);; h2st->SetFillColor(kP6Yellow);; hs->Add(h2st);; ; auto h3st = new TH1F(""h3st"",""C"",100,-4,4);; h3st->FillRandom(""gaus"",10000);; h3st->SetFillColor(kP6Red);; hs->Add(h3st);; ; auto h4st = new TH1F(""h4st"",""D"",100,-4,4);; h4st->FillRandom(""gaus"",10000);; h4st->SetFillColor(kP6Grape);; hs->Add(h4st);; ; auto h5st = new TH1F(""h5st"",""E"",100,-4,4);; h5st->FillRandom(""gaus"",10000);; h5st->SetFillColor(kP6Gray);; hs->Add(h5st);; ; auto h6st = new TH1F(""h6st"",""F"",100,-4,4);; h6st->FillRandom(""gaus"",10000);; h6st->SetFillColor(kP6Violet);; hs->Add(h6st);; ; // draw the stack with colors; hs->Draw();; TLegend *l = gPad->BuildLegend(.8,.55,1.,.9,"""",""F"");; l->SetLineWidth(0);; l->SetFillStyle(0);; ; // draw the stack using gray-scale; auto c2 = new TCanvas();; c2->SetGrayscale();; hs->Draw();; l->Draw();; }; kP6Red@ kP6RedDefinition Rtypes.h:69; kP6Grape@ kP6GrapeDefinition Rtypes.h:69; kP6Gray@ kP6GrayDefinition Rtypes.h:69; kP6Yellow@ kP6YellowDefinition Rtypes.h:69; kP6Violet@ kP6VioletDefinition Rtypes.h:69; kP6Blue@ kP6BlueDefinition Rtypes.h:69; gPad#define gPadDefinition TVirtualPad.h:308; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t ",MatchSource.WIKI,doc/master/thstackcolorscheme_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/thstackcolorscheme_8C.html
Testability,test,test,". ROOT: tutorials/hist/thstackpalettecolor.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. thstackpalettecolor.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; When one of these options is given to THStack::Draw the histograms in the THStack get their color from the current color palette defined by gStyle->SetPalette(...). The color is determined according to the number of histograms.; In this example four histograms are displayed with palette coloring. The color of each histogram is picked inside the palette kOcean. ; void thstackpalettecolor(); {; auto hs = new THStack(""hs"",""Stacked 1D histograms colored using kOcean palette"");; ; gStyle->SetPalette(kOcean);; ; // Create three 1-d histograms and add them in the stack; auto h1st = new TH1F(""h1st"",""test hstack"",100,-4,4);; h1st->FillRandom(""gaus"",20000);; hs->Add(h1st);; ; auto h2st = new TH1F(""h2st"",""test hstack"",100,-4,4);; h2st->FillRandom(""gaus"",15000);; hs->Add(h2st);; ; auto h3st = new TH1F(""h3st"",""test hstack"",100,-4,4);; h3st->FillRandom(""gaus"",10000);; hs->Add(h3st);; ; // draw the stack; hs->Draw(""pfc nostack"");; }; kOcean@ kOceanDefinition TColor.h:119; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; THStackThe Histogram stack class.Definition THStack.h:40; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; AuthorOlivier Couet ; Definition in file thstackpalettecolor.C. tutorialshistthstackpalettecolor.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/thstackpalettecolor_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/thstackpalettecolor_8C.html
Availability,avail,available,"extFont(42); T.SetTextAlign(21);; 97 cs->Divide(2,2);; 98 cs->cd(1); hs->Draw(); T.DrawTextNDC(.5,.95,""Default drawing option"");; 99 cs->cd(2); hs->Draw(""nostack""); T.DrawTextNDC(.5,.95,""Option \""nostack\"""");; 100 cs->cd(3); hs->Draw(""nostackb""); T.DrawTextNDC(.5,.95,""Option \""nostackb\"""");; 101 cs->cd(4); hs->Draw(""lego1""); T.DrawTextNDC(.5,.95,""Option \""lego1\"""");; 102}; 103End_Macro; 104 ; 105A more complex example:; 106 ; 107Begin_Macro(source); 108../../../tutorials/hist/hstack.C; 109End_Macro; 110 ; 111Note that picking is supported for all drawing modes.; 112 ; 113\since **ROOT version 6.07/07:**; 114Stacks of 2D histograms can also be painted as candle plots:; 115\since **ROOT version 6.09/02:**; 116Stacks of 2D histograms can also be painted as violin plots, combinations of candle and; 117violin plots are possible as well:; 118 ; 119Begin_Macro(source); 120../../../tutorials/hist/candleplotstack.C; 121End_Macro; 122 ; 123Automatic coloring according to the current palette is available as shown in the; 124following example:; 125 ; 126Begin_Macro(source); 127../../../tutorials/hist/thstackpalettecolor.C; 128End_Macro; 129*/; 130 ; 131 ; 132////////////////////////////////////////////////////////////////////////////////; 133/// constructor with name and title; 134 ; 135THStack::THStack(const char *name, const char *title); 136 : TNamed(name,title); 137{; 138 R__LOCKGUARD(gROOTMutex);; 139 gROOT->GetListOfCleanups()->Add(this);; 140}; 141 ; 142 ; 143////////////////////////////////////////////////////////////////////////////////; 144/// Creates a new THStack from a TH2 or TH3.; 145/// It is filled with the 1D histograms from GetProjectionX or GetProjectionY; 146/// for each bin of the histogram. It illustrates the differences and total; 147/// sum along an axis.; 148///; 149/// Parameters:; 150/// - hist: the histogram used for the projections. Can be an object deriving; 151/// from TH2 or TH3.; 152/// - axis: for TH2: ""x"" for ProjectionX, ""y"" for ProjectionY.; ",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
Integrability,depend,depends,"; 451/// stacked on top of each other.; 452 ; 453void THStack::Draw(Option_t *option); 454{; 455 TString opt = option;; 456 opt.ToLower();; 457 if (gPad) {; 458 if (!gPad->IsEditable()) gROOT->MakeDefCanvas();; 459 if (!opt.Contains(""same"") && !opt.Contains(""pads"")) {; 460 //the following statement is necessary in case one attempts to draw; 461 //a temporary histogram already in the current pad; 462 if (TestBit(kCanDelete)) gPad->Remove(this);; 463 gPad->Clear();; 464 }; 465 }; 466 AppendPad(opt.Data());; 467}; 468 ; 469////////////////////////////////////////////////////////////////////////////////; 470/// Returns a pointer to the histogram used to draw the axis.; 471/// Takes into account the two following cases:; 472/// 1- option 'A' was specified in THStack::Draw. Return fHistogram; 473/// 2- user had called TPad::DrawFrame. return pointer to hframe histogram; 474///; 475/// IMPORTANT NOTES; 476/// - You must call Draw before calling this function. The returned histogram; 477/// depends on the selected Draw options.; 478/// - This function returns a pointer to an intermediate fixed bin size; 479/// histogram used to set the range and for picking.; 480/// You cannot use this histogram to return the bin information.; 481/// You must get a pointer to one of the histograms in the stack,; 482/// the first one, for example.; 483 ; 484TH1 *THStack::GetHistogram() const; 485{; 486 if (fHistogram) return fHistogram;; 487 if (!gPad) return nullptr;; 488 gPad->Modified();; 489 gPad->Update();; 490 if (fHistogram) return fHistogram;; 491 return (TH1*)gPad->FindObject(""hframe"");; 492}; 493 ; 494////////////////////////////////////////////////////////////////////////////////; 495/// Returns the maximum of all added histograms smaller than maxval.; 496/// Returns the maximum of all histograms, smaller than maxval, if option ""nostack"".; 497 ; 498Double_t THStack::GetMaximum(Option_t *option, Double_t maxval); 499{; 500 TString opt = option;; 501 opt.ToLower();; 502 Bool_t lerr =",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
Modifiability,inherit,inherit,"== 1); 651 Warning(""GetZaxis"",""1D Histograms don't have a Z axis"");; 652 return h->GetZaxis();; 653}; 654 ; 655////////////////////////////////////////////////////////////////////////////////; 656/// List histograms in the stack.; 657 ; 658void THStack::ls(Option_t *option) const; 659{; 660 TROOT::IndentLevel();; 661 std::cout <<IsA()->GetName(); 662 <<"" Name= ""<<GetName()<<"" Title= ""<<GetTitle()<<"" Option=""<<option<<std::endl;; 663 TROOT::IncreaseDirLevel();; 664 if (fHists) fHists->ls(option);; 665 TROOT::DecreaseDirLevel();; 666}; 667////////////////////////////////////////////////////////////////////////////////; 668/// Merge the THStack in the TList into this stack.; 669/// Returns the total number of histograms in the result or -1 in case of an error.; 670 ; 671Long64_t THStack::Merge(TCollection* li, TFileMergeInfo * /* info */); 672{; 673 if (li==nullptr || li->GetEntries()==0) {; 674 return fHists->GetEntries();; 675 }; 676 TIter next(li);; 677 TList histLists;; 678 while (TObject* o = next()) {; 679 THStack *stack = dynamic_cast<THStack*> (o);; 680 if (!stack) {; 681 Error(""Merge"",; 682 ""Cannot merge - an object which doesn't inherit from THStack found in the list"");; 683 return -1;; 684 }; 685 histLists.Add(stack->GetHists());; 686 }; 687 fHists->Merge(&histLists);; 688 return fHists->GetEntries();; 689}; 690 ; 691////////////////////////////////////////////////////////////////////////////////; 692/// Note: this method invalidates the sum of histograms.; 693 ; 694void THStack::Modified(); 695{; 696 if (!fStack) return;; 697 fStack->Delete();; 698 delete fStack;; 699 fStack = nullptr;; 700 delete fHistogram;; 701 fHistogram = nullptr;; 702}; 703 ; 704////////////////////////////////////////////////////////////////////////////////; 705/// [Paint the list of histograms.](#HS00); 706 ; 707void THStack::Paint(Option_t *chopt); 708{; 709 BuildAndPaint(chopt, kTRUE);; 710}; 711 ; 712////////////////////////////////////////////////////////////////////////////////;",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
Performance,load,load," TAxis.cxx:469; TAxis::GetNbinsInt_t GetNbins() constDefinition TAxis.h:125; TAxis::SetRangevirtual void SetRange(Int_t first=0, Int_t last=0)Set the viewing range for the axis using bin numbers.Definition TAxis.cxx:1052; TAxis::GetFirstInt_t GetFirst() constReturn first bin on the axis i.e.Definition TAxis.cxx:458; TAxis::GetLabelsTHashList * GetLabels() constDefinition TAxis.h:121; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::GetEntriesvirtual Int_t GetEntries() constDefinition TCollection.h:179; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TFileMergeInfoDefinition TFileMergeInfo.h:42; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::SetBarOffsetvirtual void SetBarOffset(Float_t offset=0.25)Set the bar offset as fraction of the bin width for drawing mode ""B"".Definition TH1.h:364; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
Safety,avoid,avoids,"is painted; 49 - then the sum of the first and second histograms is painted, and so on; 50 ; 51The axis ranges are computed automatically along the X and Y axes to display the complete; 52histogram collection.; 53 ; 54Warning: Histogram bins with negative content may produce wrong plots.; 55 ; 56### Stack's drawing options; 57 ; 58The specific stack's drawing options are:; 59 ; 60 - **NOSTACK** If option ""nostack"" is specified, histograms are all painted in the same pad; 61 as if the option ""same"" had been specified.; 62 ; 63 - **NOSTACKB** If the option ""nostackb"" is specified histograms are all painted on the same pad; 64 next to each other as bar plots.; 65 ; 66 - **PADS** if option ""pads"" is specified, the current pad/canvas is subdivided into; 67 a number of pads equal to the number of histograms and each histogram; 68 is painted into a separate pad.; 69 ; 70 - **NOCLEAR** By default the background of the histograms is erased before drawing the; 71 histograms. The option ""noclear"" avoids this behavior. This is useful when drawing a; 72 THStack on top of another plot. If the patterns used to draw the histograms in the; 73 stack are transparent, then the plot behind will be visible.; 74 ; 75See the THistPainter class for the list of valid histograms' painting options.; 76 ; 77 ; 78Example;; 79 ; 80Begin_Macro(source); 81{; 82 auto hs = new THStack(""hs"","""");; 83 auto h1 = new TH1F(""h1"",""test hstack"",10,-4,4);; 84 h1->FillRandom(""gaus"",20000);; 85 h1->SetFillColor(kRed);; 86 hs->Add(h1);; 87 auto h2 = new TH1F(""h2"",""test hstack"",10,-4,4);; 88 h2->FillRandom(""gaus"",15000);; 89 h2->SetFillColor(kBlue);; 90 hs->Add(h2);; 91 auto h3 = new TH1F(""h3"",""test hstack"",10,-4,4);; 92 h3->FillRandom(""gaus"",10000);; 93 h3->SetFillColor(kGreen);; 94 hs->Add(h3);; 95 auto cs = new TCanvas(""cs"",""cs"",10,10,700,900);; 96 TText T; T.SetTextFont(42); T.SetTextAlign(21);; 97 cs->Divide(2,2);; 98 cs->cd(1); hs->Draw(); T.DrawTextNDC(.5,.95,""Default drawing option"");; 99 cs->cd(2); hs->Dra",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
Security,hash,hash,"to draw the stack.Definition THStack.cxx:646; THStack::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition THStack.cxx:1031; THStack::Browsevoid Browse(TBrowser *b) overrideBrowse.Definition THStack.cxx:381; THStack::Classstatic TClass * Class(); THStack::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute distance from point px, py to each graph.Definition THStack.cxx:416; THStack::Modifiedvirtual void Modified()Note: this method invalidates the sum of histograms.Definition THStack.cxx:694; THStack::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Set minimum.Definition THStack.cxx:1090; THStack::GetXaxisTAxis * GetXaxis() constGet the x-axis of the histogram used to draw the stack.Definition THStack.cxx:620; THStack::fMaximumDouble_t fMaximumMaximum value for plotting along y.Definition THStack.h:48; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::Clearvoid Clear(Option_t *option="""") overrideRemove all objects from the list.Definition TList.cxx:400; TList::LastLinkvirtual TObjLink * LastLink() constDefinition TList.h:107; TList::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TList.cxx:762; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition TList.cxx:820; TList::FirstTObject * First() const overrideReturn the first object in the list. Returns 0 when list is empty.Definition TList.cxx:657; TList::FirstLinkvirtual TObjLink * FirstLink() constDefinition TList.h:104; TList::AtTObject * At(Int_t idx) const overrideReturns the object a",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
Testability,test,test,"kb"" is specified histograms are all painted on the same pad; 64 next to each other as bar plots.; 65 ; 66 - **PADS** if option ""pads"" is specified, the current pad/canvas is subdivided into; 67 a number of pads equal to the number of histograms and each histogram; 68 is painted into a separate pad.; 69 ; 70 - **NOCLEAR** By default the background of the histograms is erased before drawing the; 71 histograms. The option ""noclear"" avoids this behavior. This is useful when drawing a; 72 THStack on top of another plot. If the patterns used to draw the histograms in the; 73 stack are transparent, then the plot behind will be visible.; 74 ; 75See the THistPainter class for the list of valid histograms' painting options.; 76 ; 77 ; 78Example;; 79 ; 80Begin_Macro(source); 81{; 82 auto hs = new THStack(""hs"","""");; 83 auto h1 = new TH1F(""h1"",""test hstack"",10,-4,4);; 84 h1->FillRandom(""gaus"",20000);; 85 h1->SetFillColor(kRed);; 86 hs->Add(h1);; 87 auto h2 = new TH1F(""h2"",""test hstack"",10,-4,4);; 88 h2->FillRandom(""gaus"",15000);; 89 h2->SetFillColor(kBlue);; 90 hs->Add(h2);; 91 auto h3 = new TH1F(""h3"",""test hstack"",10,-4,4);; 92 h3->FillRandom(""gaus"",10000);; 93 h3->SetFillColor(kGreen);; 94 hs->Add(h3);; 95 auto cs = new TCanvas(""cs"",""cs"",10,10,700,900);; 96 TText T; T.SetTextFont(42); T.SetTextAlign(21);; 97 cs->Divide(2,2);; 98 cs->cd(1); hs->Draw(); T.DrawTextNDC(.5,.95,""Default drawing option"");; 99 cs->cd(2); hs->Draw(""nostack""); T.DrawTextNDC(.5,.95,""Option \""nostack\"""");; 100 cs->cd(3); hs->Draw(""nostackb""); T.DrawTextNDC(.5,.95,""Option \""nostackb\"""");; 101 cs->cd(4); hs->Draw(""lego1""); T.DrawTextNDC(.5,.95,""Option \""lego1\"""");; 102}; 103End_Macro; 104 ; 105A more complex example:; 106 ; 107Begin_Macro(source); 108../../../tutorials/hist/hstack.C; 109End_Macro; 110 ; 111Note that picking is supported for all drawing modes.; 112 ; 113\since **ROOT version 6.07/07:**; 114Stacks of 2D histograms can also be painted as candle plots:; 115\since **ROOT version 6.09/02:**; 116St",MatchSource.WIKI,doc/master/THStack_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html
Availability,avail,available,"OTSYS + ""/files/online.htm"").Data());; 998 ; 999 } else {; 1000 auto wsptr = FindWS(arg->GetPathName());; 1001 ; 1002 auto handler = wsptr.get();; 1003 ; 1004 if (!handler); 1005 handler = dynamic_cast<THttpWSHandler *>(fSniffer->FindTObjectInHierarchy(arg->fPathName.Data()));; 1006 ; 1007 if (handler) {; 1008 ; 1009 arg->fContent = handler->GetDefaultPageContent().Data();; 1010 ; 1011 if (arg->fContent.find(""file:"") == 0) {; 1012 const char *fname = arg->fContent.c_str() + 5;; 1013 TString resolve;; 1014 if (!IsFileRequested(fname, resolve)) resolve = fname;; 1015 arg->fContent = ReadFileContent(resolve.Data());; 1016 }; 1017 ; 1018 version = handler->GetCodeVersion();; 1019 ; 1020 handler->VerifyDefaultPageContent(arg);; 1021 }; 1022 }; 1023 ; 1024 if (arg->fContent.empty() && arg->fFileName.IsNull() && arg->fPathName.IsNull() && IsWSOnly()) {; 1025 // Creating page with list of available widgets is disabled now for security reasons; 1026 // Later one can provide functionality back only if explicitly desired by the user; 1027 // BuildWSEntryPage();; 1028 ; 1029 arg->SetContent(""refused"");; 1030 arg->Set404();; 1031 }; 1032 ; 1033 if (arg->fContent.empty() && !IsWSOnly()) {; 1034 ; 1035 if (fDefaultPageCont.empty()); 1036 fDefaultPageCont = ReadFileContent(fDefaultPage);; 1037 ; 1038 arg->fContent = fDefaultPageCont;; 1039 }; 1040 ; 1041 if (arg->fContent.empty()) {; 1042 ; 1043 arg->Set404();; 1044 } else if (!arg->Is404()) {; 1045 ; 1046 ReplaceJSROOTLinks(arg, version);; 1047 ; 1048 const char *hjsontag = ""\""$$$h.json$$$\"""";; 1049 ; 1050 // add h.json caching; 1051 if (arg->fContent.find(hjsontag) != std::string::npos) {; 1052 TString h_json;; 1053 TRootSnifferStoreJson store(h_json, kTRUE);; 1054 const char *topname = fTopName.Data();; 1055 if (arg->fTopName.Length() > 0); 1056 topname = arg->fTopName.Data();; 1057 fSniffer->ScanHierarchy(topname, arg->fPathName.Data(), &store);; 1058 ; 1059 arg->ReplaceAllinContent(hjsontag, h_json.Data());; 1060 ; 1061 arg->A",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
Deployability,update,updated,"ipt user interface.; 95Any registered object can be requested and displayed in the browser.; 96There are many benefits of such approach:; 97 ; 981. standard http interface to ROOT application; 992. no any temporary ROOT files when access data; 1003. user interface running in all browsers; 101 ; 102To start http server simply create instance; 103of the THttpServer class like:; 104 ; 105 serv = new THttpServer(""http:8080"");; 106 ; 107This will starts civetweb-based http server with http port 8080.; 108Than one should be able to open address ""http://localhost:8080""; 109in any modern web browser (Firefox, Chrome, Opera, ...) and browse objects,; 110created in ROOT application. By default, server can access files,; 111canvases and histograms via `gROOT` pointer. All such objects; 112can be displayed with JSROOT graphics.; 113 ; 114At any time one could register other objects with the command:; 115 ; 116 TGraph* gr = new TGraph(10);; 117 gr->SetName(""gr1"");; 118 serv->Register(""graphs/subfolder"", gr);; 119 ; 120If objects content is changing in the application, one could; 121enable monitoring flag in the browser - than objects view; 122will be regularly updated.; 123 ; 124More information: https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html; 125*/; 126 ; 127ClassImp(THttpServer);; 128 ; 129////////////////////////////////////////////////////////////////////////////////; 130/// constructor; 131///; 132/// As argument, one specifies engine kind which should be; 133/// created like ""http:8080"". One could specify several engines; 134/// at once, separating them with semicolon ("";""). Following engines are supported:; 135///; 136/// http - TCivetweb, civetweb-based implementation of http protocol; 137/// fastcgi - TFastCgi, special protocol for communicating with web servers; 138///; 139/// For each created engine one should provide socket port number like ""http:8080"" or ""fastcgi:9000"".; 140/// Additional engine-specific options can be supplied with URL syntax like ",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
Energy Efficiency,monitor,monitoring,"ipt user interface.; 95Any registered object can be requested and displayed in the browser.; 96There are many benefits of such approach:; 97 ; 981. standard http interface to ROOT application; 992. no any temporary ROOT files when access data; 1003. user interface running in all browsers; 101 ; 102To start http server simply create instance; 103of the THttpServer class like:; 104 ; 105 serv = new THttpServer(""http:8080"");; 106 ; 107This will starts civetweb-based http server with http port 8080.; 108Than one should be able to open address ""http://localhost:8080""; 109in any modern web browser (Firefox, Chrome, Opera, ...) and browse objects,; 110created in ROOT application. By default, server can access files,; 111canvases and histograms via `gROOT` pointer. All such objects; 112can be displayed with JSROOT graphics.; 113 ; 114At any time one could register other objects with the command:; 115 ; 116 TGraph* gr = new TGraph(10);; 117 gr->SetName(""gr1"");; 118 serv->Register(""graphs/subfolder"", gr);; 119 ; 120If objects content is changing in the application, one could; 121enable monitoring flag in the browser - than objects view; 122will be regularly updated.; 123 ; 124More information: https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html; 125*/; 126 ; 127ClassImp(THttpServer);; 128 ; 129////////////////////////////////////////////////////////////////////////////////; 130/// constructor; 131///; 132/// As argument, one specifies engine kind which should be; 133/// created like ""http:8080"". One could specify several engines; 134/// at once, separating them with semicolon ("";""). Following engines are supported:; 135///; 136/// http - TCivetweb, civetweb-based implementation of http protocol; 137/// fastcgi - TFastCgi, special protocol for communicating with web servers; 138///; 139/// For each created engine one should provide socket port number like ""http:8080"" or ""fastcgi:9000"".; 140/// Additional engine-specific options can be supplied with URL syntax like ",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
Integrability,interface,interface,"THttpTimer : public TTimer {; 43 Long_t fNormalTmout{0};; 44 Bool_t fSlow{kFALSE};; 45 Int_t fSlowCnt{0};; 46 ; 47public:; 48 THttpServer &fServer; ///!< server processing requests; 49 ; 50 /// constructor; 51 THttpTimer(Long_t milliSec, Bool_t mode, THttpServer &serv) : TTimer(milliSec, mode), fNormalTmout(milliSec), fServer(serv) {}; 52 ; 53 void SetSlow(Bool_t flag); 54 {; 55 fSlow = flag;; 56 fSlowCnt = 0;; 57 Long_t ms = fNormalTmout;; 58 if (fSlow) {; 59 if (ms < 100); 60 ms = 500;; 61 else if (ms < 500); 62 ms = 3000;; 63 else; 64 ms = 10000;; 65 }; 66 ; 67 SetTime(ms);; 68 }; 69 Bool_t IsSlow() const { return fSlow; }; 70 ; 71 /// timeout handler; 72 /// used to process http requests in main ROOT thread; 73 void Timeout() override; 74 {; 75 Int_t nprocess = fServer.ProcessRequests();; 76 ; 77 if (nprocess > 0) {; 78 fSlowCnt = 0;; 79 if (IsSlow()); 80 SetSlow(kFALSE);; 81 } else if (!IsSlow() && (fSlowCnt++ > 10)) {; 82 SetSlow(kTRUE);; 83 }; 84 }; 85};; 86 ; 87 ; 88/** \class THttpServer; 89\ingroup http; 90 ; 91Online http server for arbitrary ROOT application; 92 ; 93Idea of THttpServer - provide remote http access to running; 94ROOT application and enable HTML/JavaScript user interface.; 95Any registered object can be requested and displayed in the browser.; 96There are many benefits of such approach:; 97 ; 981. standard http interface to ROOT application; 992. no any temporary ROOT files when access data; 1003. user interface running in all browsers; 101 ; 102To start http server simply create instance; 103of the THttpServer class like:; 104 ; 105 serv = new THttpServer(""http:8080"");; 106 ; 107This will starts civetweb-based http server with http port 8080.; 108Than one should be able to open address ""http://localhost:8080""; 109in any modern web browser (Firefox, Chrome, Opera, ...) and browse objects,; 110created in ROOT application. By default, server can access files,; 111canvases and histograms via `gROOT` pointer. All such objects; 112can be display",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
Modifiability,config,configure,"hould be; 133/// created like ""http:8080"". One could specify several engines; 134/// at once, separating them with semicolon ("";""). Following engines are supported:; 135///; 136/// http - TCivetweb, civetweb-based implementation of http protocol; 137/// fastcgi - TFastCgi, special protocol for communicating with web servers; 138///; 139/// For each created engine one should provide socket port number like ""http:8080"" or ""fastcgi:9000"".; 140/// Additional engine-specific options can be supplied with URL syntax like ""http:8080?thrds=10"".; 141/// Full list of supported options should be checked in engines docu.; 142///; 143/// One also can configure following options, separated by semicolon:; 144///; 145/// readonly, ro - set read-only mode (default); 146/// readwrite, rw - allows methods execution of registered objects; 147/// global - scans global ROOT lists for existing objects (default); 148/// noglobal - disable scan of global lists; 149/// cors - enable CORS header with origin=""*""; 150/// cors=domain - enable CORS header with origin=""domain""; 151/// basic_sniffer - use basic sniffer without support of hist, gpad, graph classes; 152///; 153/// For example, create http server, which allows cors headers and disable scan of global lists,; 154/// one should provide ""http:8080;cors;noglobal"" as parameter; 155///; 156/// THttpServer uses JavaScript ROOT (https://root.cern/js) to implement web clients UI.; 157/// Normally JSROOT sources are used from $ROOTSYS/js directory,; 158/// but one could set JSROOTSYS shell variable to specify alternative location; 159 ; 160THttpServer::THttpServer(const char *engine) : TNamed(""http"", ""ROOT http server""); 161{; 162 const char *jsrootsys = gSystem->Getenv(""JSROOTSYS"");; 163 if (!jsrootsys); 164 jsrootsys = gEnv->GetValue(""HttpServ.JSRootPath"", jsrootsys);; 165 ; 166 if (jsrootsys && *jsrootsys) {; 167 if ((strncmp(jsrootsys, ""http://"", 7)==0) || (strncmp(jsrootsys, ""https://"", 8)==0)); 168 fJSROOT = jsrootsys;; 169 else; 170 fJSROOT",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
Performance,load,load,"8/// serv->AddLocation(""mydir/"", ""/home/user/specials"");; 329///; 330/// Than files from this directory could be addressed via server like `http://localhost:8080/mydir/myfile.root`; 331 ; 332void THttpServer::AddLocation(const char *prefix, const char *path); 333{; 334 if (!prefix || (*prefix == 0)); 335 return;; 336 ; 337 if (!path); 338 fLocations.erase(fLocations.find(prefix));; 339 else; 340 fLocations[prefix] = path;; 341}; 342 ; 343////////////////////////////////////////////////////////////////////////////////; 344/// Set location of JSROOT to use with the server; 345///; 346/// One could specify address like:; 347///; 348/// * https://root.cern/js/7.6.0/; 349/// * https://jsroot.gsi.de/7.6.0/; 350///; 351/// This allows to get new JSROOT features with old server,; 352/// reduce load on THttpServer instance, also startup time can be improved; 353/// When empty string specified (default), local copy of JSROOT is used (distributed with ROOT); 354 ; 355void THttpServer::SetJSROOT(const char *location); 356{; 357 fJSROOT = location ? location : """";; 358}; 359 ; 360////////////////////////////////////////////////////////////////////////////////; 361/// Set default HTML page; 362///; 363/// Sets file name, delivered by the server when http address is opened in the browser.; 364///; 365/// By default, $ROOTSYS/js/files/online.htm page is used; 366/// When empty filename is specified, default page will be used; 367 ; 368void THttpServer::SetDefaultPage(const std::string &filename); 369{; 370 if (!filename.empty()); 371 fDefaultPage = filename;; 372 else; 373 fDefaultPage = fJSROOTSYS + ""/files/online.htm"";; 374 ; 375 // force to read page content next time again; 376 fDefaultPageCont.clear();; 377}; 378 ; 379////////////////////////////////////////////////////////////////////////////////; 380/// Set drawing HTML page; 381///; 382/// Set file name of HTML page, delivered by the server when; 383/// objects drawing page is requested from the browser; 384/// By default, $",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
Safety,timeout,timeout,"*************/; 11 ; 12#include ""THttpServer.h""; 13 ; 14#include ""TThread.h""; 15#include ""TTimer.h""; 16#include ""TSystem.h""; 17#include ""TROOT.h""; 18#include ""TUrl.h""; 19#include ""TEnv.h""; 20#include ""TError.h""; 21#include ""TClass.h""; 22#include ""RConfigure.h""; 23#include ""TRegexp.h""; 24#include ""TObjArray.h""; 25 ; 26#include ""THttpEngine.h""; 27#include ""THttpLongPollEngine.h""; 28#include ""THttpWSHandler.h""; 29#include ""TRootSniffer.h""; 30#include ""TRootSnifferStore.h""; 31#include ""TCivetweb.h""; 32#include ""TFastCgi.h""; 33 ; 34#include <chrono>; 35#include <cstdlib>; 36#include <cstring>; 37#include <fstream>; 38#include <memory>; 39#include <string>; 40#include <thread>; 41 ; 42class THttpTimer : public TTimer {; 43 Long_t fNormalTmout{0};; 44 Bool_t fSlow{kFALSE};; 45 Int_t fSlowCnt{0};; 46 ; 47public:; 48 THttpServer &fServer; ///!< server processing requests; 49 ; 50 /// constructor; 51 THttpTimer(Long_t milliSec, Bool_t mode, THttpServer &serv) : TTimer(milliSec, mode), fNormalTmout(milliSec), fServer(serv) {}; 52 ; 53 void SetSlow(Bool_t flag); 54 {; 55 fSlow = flag;; 56 fSlowCnt = 0;; 57 Long_t ms = fNormalTmout;; 58 if (fSlow) {; 59 if (ms < 100); 60 ms = 500;; 61 else if (ms < 500); 62 ms = 3000;; 63 else; 64 ms = 10000;; 65 }; 66 ; 67 SetTime(ms);; 68 }; 69 Bool_t IsSlow() const { return fSlow; }; 70 ; 71 /// timeout handler; 72 /// used to process http requests in main ROOT thread; 73 void Timeout() override; 74 {; 75 Int_t nprocess = fServer.ProcessRequests();; 76 ; 77 if (nprocess > 0) {; 78 fSlowCnt = 0;; 79 if (IsSlow()); 80 SetSlow(kFALSE);; 81 } else if (!IsSlow() && (fSlowCnt++ > 10)) {; 82 SetSlow(kTRUE);; 83 }; 84 }; 85};; 86 ; 87 ; 88/** \class THttpServer; 89\ingroup http; 90 ; 91Online http server for arbitrary ROOT application; 92 ; 93Idea of THttpServer - provide remote http access to running; 94ROOT application and enable HTML/JavaScript user interface.; 95Any registered object can be requested and displayed in the browser.; 96There are man",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
Security,access,access,"THttpTimer : public TTimer {; 43 Long_t fNormalTmout{0};; 44 Bool_t fSlow{kFALSE};; 45 Int_t fSlowCnt{0};; 46 ; 47public:; 48 THttpServer &fServer; ///!< server processing requests; 49 ; 50 /// constructor; 51 THttpTimer(Long_t milliSec, Bool_t mode, THttpServer &serv) : TTimer(milliSec, mode), fNormalTmout(milliSec), fServer(serv) {}; 52 ; 53 void SetSlow(Bool_t flag); 54 {; 55 fSlow = flag;; 56 fSlowCnt = 0;; 57 Long_t ms = fNormalTmout;; 58 if (fSlow) {; 59 if (ms < 100); 60 ms = 500;; 61 else if (ms < 500); 62 ms = 3000;; 63 else; 64 ms = 10000;; 65 }; 66 ; 67 SetTime(ms);; 68 }; 69 Bool_t IsSlow() const { return fSlow; }; 70 ; 71 /// timeout handler; 72 /// used to process http requests in main ROOT thread; 73 void Timeout() override; 74 {; 75 Int_t nprocess = fServer.ProcessRequests();; 76 ; 77 if (nprocess > 0) {; 78 fSlowCnt = 0;; 79 if (IsSlow()); 80 SetSlow(kFALSE);; 81 } else if (!IsSlow() && (fSlowCnt++ > 10)) {; 82 SetSlow(kTRUE);; 83 }; 84 }; 85};; 86 ; 87 ; 88/** \class THttpServer; 89\ingroup http; 90 ; 91Online http server for arbitrary ROOT application; 92 ; 93Idea of THttpServer - provide remote http access to running; 94ROOT application and enable HTML/JavaScript user interface.; 95Any registered object can be requested and displayed in the browser.; 96There are many benefits of such approach:; 97 ; 981. standard http interface to ROOT application; 992. no any temporary ROOT files when access data; 1003. user interface running in all browsers; 101 ; 102To start http server simply create instance; 103of the THttpServer class like:; 104 ; 105 serv = new THttpServer(""http:8080"");; 106 ; 107This will starts civetweb-based http server with http port 8080.; 108Than one should be able to open address ""http://localhost:8080""; 109in any modern web browser (Firefox, Chrome, Opera, ...) and browse objects,; 110created in ROOT application. By default, server can access files,; 111canvases and histograms via `gROOT` pointer. All such objects; 112can be display",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
Usability,simpl,simply,"etTime(ms);; 68 }; 69 Bool_t IsSlow() const { return fSlow; }; 70 ; 71 /// timeout handler; 72 /// used to process http requests in main ROOT thread; 73 void Timeout() override; 74 {; 75 Int_t nprocess = fServer.ProcessRequests();; 76 ; 77 if (nprocess > 0) {; 78 fSlowCnt = 0;; 79 if (IsSlow()); 80 SetSlow(kFALSE);; 81 } else if (!IsSlow() && (fSlowCnt++ > 10)) {; 82 SetSlow(kTRUE);; 83 }; 84 }; 85};; 86 ; 87 ; 88/** \class THttpServer; 89\ingroup http; 90 ; 91Online http server for arbitrary ROOT application; 92 ; 93Idea of THttpServer - provide remote http access to running; 94ROOT application and enable HTML/JavaScript user interface.; 95Any registered object can be requested and displayed in the browser.; 96There are many benefits of such approach:; 97 ; 981. standard http interface to ROOT application; 992. no any temporary ROOT files when access data; 1003. user interface running in all browsers; 101 ; 102To start http server simply create instance; 103of the THttpServer class like:; 104 ; 105 serv = new THttpServer(""http:8080"");; 106 ; 107This will starts civetweb-based http server with http port 8080.; 108Than one should be able to open address ""http://localhost:8080""; 109in any modern web browser (Firefox, Chrome, Opera, ...) and browse objects,; 110created in ROOT application. By default, server can access files,; 111canvases and histograms via `gROOT` pointer. All such objects; 112can be displayed with JSROOT graphics.; 113 ; 114At any time one could register other objects with the command:; 115 ; 116 TGraph* gr = new TGraph(10);; 117 gr->SetName(""gr1"");; 118 serv->Register(""graphs/subfolder"", gr);; 119 ; 120If objects content is changing in the application, one could; 121enable monitoring flag in the browser - than objects view; 122will be regularly updated.; 123 ; 124More information: https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html; 125*/; 126 ; 127ClassImp(THttpServer);; 128 ; 129/////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/THttpServer_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html
Energy Efficiency,allocate,allocated,"h""; 18 ; 19#include <mutex>; 20#include <map>; 21#include <string>; 22#include <memory>; 23#include <queue>; 24#include <thread>; 25#include <vector>; 26 ; 27class THttpEngine;; 28class THttpTimer;; 29class TRootSniffer;; 30 ; 31class THttpServer : public TNamed {; 32 ; 33protected:; 34 TList fEngines; ///<! engines which runs http server; 35 std::unique_ptr<THttpTimer> fTimer; ///<! timer used to access main thread; 36 std::unique_ptr<TRootSniffer> fSniffer; ///<! sniffer provides access to ROOT objects hierarchy; 37 Bool_t fTerminated{kFALSE}; ///<! termination flag, disables all requests processing; 38 Long_t fMainThrdId{0}; ///<! id of the thread for processing requests; 39 Long_t fProcessingThrdId{0}; ///<! id of the thread where events are recently processing; 40 Bool_t fOwnThread{kFALSE}; ///<! true when specialized thread allocated for processing requests; 41 std::thread fThrd; ///<! own thread; 42 Bool_t fWSOnly{kFALSE}; ///<! when true, handle only websockets / longpoll engine; 43 ; 44 TString fJSROOTSYS; ///<! location of local JSROOT files; 45 TString fTopName{""ROOT""}; ///<! name of top folder, default - ""ROOT""; 46 TString fJSROOT; ///<! location of external JSROOT files; 47 ; 48 std::map<std::string, std::string> fLocations; //",MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
Integrability,protocol,protocol,"nt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t UChar_t lenDefinition TGWin32VirtualXProxy.cxx:249; modeOption_t Option_t TPoint TPoint const char modeDefinition TGWin32VirtualXProxy.cxx:68; namechar name[80]Definition TGX11.cxx:110; THttpCallArg.h; TList.h; TNamed.h; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; THttpCallArgContains arguments for single HTTP call.Definition THttpCallArg.h:27; THttpEngineAbstract class for implementing http protocol for THttpServer.Definition THttpEngine.h:19; THttpServerOnline http server for arbitrary ROOT application.Definition THttpServer.h:31; THttpServer::IsReadOnlyBool_t IsReadOnly() constreturns read-only modeDefinition THttpServer.cxx:285; THttpServer::RegisterCommandBool_t RegisterCommand(const char *cmdname, const char *method, const char *icon=nullptr)Register command which can be executed from web interface.Definition THttpServer.cxx:1428; THttpServer::fJSROOTTString fJSROOT! location of external JSROOT filesDefinition THttpServer.h:46; THttpServer::ProcessRequestvirtual void ProcessRequest(std::shared_ptr< THttpCallArg > arg)Process single http request.Definition THttpServer.cxx:978; THttpServer::GetTopNameconst char * GetTopName() constreturns name of top item in objects hierarchyDefinition THttpServer.h:130; THttpServer::FindWSstd::shared_ptr< THttpWSHandler > FindWS(const char *name)Find web-socket handler with given name.Definition THttpServer.cxx:1285; THt",MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
Modifiability,config,configured,"ng BuildWSEntryPage();; 72 ; 73 void ReplaceJSROOTLinks(std::shared_ptr<THttpCallArg> &arg, const std::string &version = """");; 74 ; 75 static Bool_t VerifyFilePath(const char *fname);; 76 ; 77 THttpServer(const THttpServer &) = delete;; 78 THttpServer &operator=(const THttpServer &) = delete;; 79 ; 80public:; 81 THttpServer(const char *engine = ""http:8080"");; 82 virtual ~THttpServer();; 83 ; 84 Bool_t CreateEngine(const char *engine);; 85 ; 86 Bool_t IsAnyEngine() const { return fEngines.GetSize() > 0; }; 87 ; 88 /** returns pointer on objects sniffer */; 89 TRootSniffer *GetSniffer() const { return fSniffer.get(); }; 90 ; 91 void SetSniffer(TRootSniffer *sniff);; 92 ; 93 Bool_t IsReadOnly() const;; 94 ; 95 void SetReadOnly(Bool_t readonly = kTRUE);; 96 ; 97 Bool_t IsWSOnly() const;; 98 ; 99 void SetWSOnly(Bool_t on = kTRUE);; 100 ; 101 /** set termination flag, no any further requests will be processed */; 102 void SetTerminate();; 103 ; 104 /** returns kTRUE, if server was terminated */; 105 Bool_t IsTerminated() const { return fTerminated; }; 106 ; 107 /** Enable CORS header to ProcessRequests() responses; 108 * Specified location (typically ""*"") add as ""Access-Control-Allow-Origin"" header */; 109 void SetCors(const std::string &domain = ""*"") { fCors = domain; }; 110 ; 111 /** Returns kTRUE if CORS was configured */; 112 Bool_t IsCors() const { return !fCors.empty(); }; 113 ; 114 /** Returns specified CORS domain */; 115 const char *GetCors() const { return fCors.c_str(); }; 116 ; 117 /** Enable/disable usage Access-Control-Allow-Credentials response header */; 118 void SetCorsCredentials(const std::string &value = ""true"") { fCorsCredentials = value; }; 119 ; 120 /** Returns kTRUE if Access-Control-Allow-Credentials header should be used */; 121 Bool_t IsCorsCredentials() const { return !fCorsCredentials.empty(); }; 122 ; 123 /** Returns specified CORS credentials value - if any */; 124 const char *GetCorsCredentials() const { return fCorsCredentials.c_str(); }; ",MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
Performance,queue,queue,"h""; 18 ; 19#include <mutex>; 20#include <map>; 21#include <string>; 22#include <memory>; 23#include <queue>; 24#include <thread>; 25#include <vector>; 26 ; 27class THttpEngine;; 28class THttpTimer;; 29class TRootSniffer;; 30 ; 31class THttpServer : public TNamed {; 32 ; 33protected:; 34 TList fEngines; ///<! engines which runs http server; 35 std::unique_ptr<THttpTimer> fTimer; ///<! timer used to access main thread; 36 std::unique_ptr<TRootSniffer> fSniffer; ///<! sniffer provides access to ROOT objects hierarchy; 37 Bool_t fTerminated{kFALSE}; ///<! termination flag, disables all requests processing; 38 Long_t fMainThrdId{0}; ///<! id of the thread for processing requests; 39 Long_t fProcessingThrdId{0}; ///<! id of the thread where events are recently processing; 40 Bool_t fOwnThread{kFALSE}; ///<! true when specialized thread allocated for processing requests; 41 std::thread fThrd; ///<! own thread; 42 Bool_t fWSOnly{kFALSE}; ///<! when true, handle only websockets / longpoll engine; 43 ; 44 TString fJSROOTSYS; ///<! location of local JSROOT files; 45 TString fTopName{""ROOT""}; ///<! name of top folder, default - ""ROOT""; 46 TString fJSROOT; ///<! location of external JSROOT files; 47 ; 48 std::map<std::string, std::string> fLocations; //",MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
Safety,safe,safe,,MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
Security,access,access,"h""; 18 ; 19#include <mutex>; 20#include <map>; 21#include <string>; 22#include <memory>; 23#include <queue>; 24#include <thread>; 25#include <vector>; 26 ; 27class THttpEngine;; 28class THttpTimer;; 29class TRootSniffer;; 30 ; 31class THttpServer : public TNamed {; 32 ; 33protected:; 34 TList fEngines; ///<! engines which runs http server; 35 std::unique_ptr<THttpTimer> fTimer; ///<! timer used to access main thread; 36 std::unique_ptr<TRootSniffer> fSniffer; ///<! sniffer provides access to ROOT objects hierarchy; 37 Bool_t fTerminated{kFALSE}; ///<! termination flag, disables all requests processing; 38 Long_t fMainThrdId{0}; ///<! id of the thread for processing requests; 39 Long_t fProcessingThrdId{0}; ///<! id of the thread where events are recently processing; 40 Bool_t fOwnThread{kFALSE}; ///<! true when specialized thread allocated for processing requests; 41 std::thread fThrd; ///<! own thread; 42 Bool_t fWSOnly{kFALSE}; ///<! when true, handle only websockets / longpoll engine; 43 ; 44 TString fJSROOTSYS; ///<! location of local JSROOT files; 45 TString fTopName{""ROOT""}; ///<! name of top folder, default - ""ROOT""; 46 TString fJSROOT; ///<! location of external JSROOT files; 47 ; 48 std::map<std::string, std::string> fLocations; //",MatchSource.WIKI,doc/master/THttpServer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html
Testability,test,test,". ROOT: tutorials/graphs/timeonaxis2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. timeonaxis2.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Define the time offset as 2003, January 1st. . ; void timeonaxis2() {; auto ct2 = new TCanvas(""ct2"",""ct2"",10,10,700,500);; ; TDatime T0(2003, 1, 1, 0, 0, 0);; int X0 = T0.Convert();; gStyle->SetTimeOffset(X0);; ; // Define the lowest histogram limit as 2002, September 23rd; TDatime T1(2002, 9, 23, 0, 0, 0);; int X1 = T1.Convert()-X0;; ; // Define the highest histogram limit as 2003, March 7th; TDatime T2(2003, 3, 7, 0, 0, 0);; int X2 = T2.Convert(1)-X0;; ; auto h1 = new TH1F(""h1"",""test"",100,X1,X2);; ; TRandom r;; for (Int_t i=0;i<30000;i++) {; Double_t noise = r.Gaus(0.5*(X1+X2),0.1*(X2-X1));; h1->Fill(noise);; }; ; h1->GetXaxis()->SetTimeDisplay(1);; h1->GetXaxis()->SetLabelSize(0.03);; h1->GetXaxis()->SetTimeFormat(""%Y/%m/%d"");; h1->Draw();; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TAttAxis::SetLabelSizevirtual void SetLabelSize(Float_t size=0.04)Set size of axis labels.Definition TAttAxis.cxx:203; TAxis::SetTimeDisplayvirtual void SetTimeDisplay(Int_t value)Definition TAxis.h:171; TAxis::SetTimeFormatvirtual void SetTimeFormat(const char *format="""")Change the format used for time plotting.Definition TAxis.cxx:1157; TCanvasThe Canvas class.Definition TCanvas.h:23; TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::GetXaxis",MatchSource.WIKI,doc/master/timeonaxis2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/timeonaxis2_8C.html
Security,access,accessor,"extColor(kBlue+2);; ; TLatex tex2;; tex2.SetNDC();; tex2.SetTextFont(102);; tex2.SetTextSize(0.07*f);; tex2.SetTextColor(kOrange+3);; ; time_t offset[] = {0, 0, 1325376000, 1341100800};; time_t t[] = {1331150400, 1336417200, 0, 36000};; ; c->SetTopMargin(0); c->SetBottomMargin(0);; c->SetLeftMargin(0); c->SetRightMargin(0);; c->Divide(2, 4, -1, -1);; TLine l;; l.DrawLine(0.5, 0, 0.5, 1.);; ; for(int i = 0; i < 4; ++i){; for(int gmt = 0; gmt < 2; ++gmt){; const char* opt = (gmt ? ""gmt"" : ""local"");; TVirtualPad* p = c->cd(2*i + gmt + 1);; p->SetTopMargin(0); p->SetBottomMargin(0);; p->SetLeftMargin(0); p->SetRightMargin(0);; p->SetFillStyle(4000);; ; TGaxis* ga = new TGaxis (.4, .25, 5., .25, t[i], t[i] + 1, 1, ""t"");; ga->SetTimeFormat(""TGaxis label: #color[2]{%Y-%m-%d %H:%M:%S}"");; ga->SetLabelFont(102);; ga->SetLabelColor(kBlue+2);; ; ga->SetTimeOffset(offset[i], opt);; ga->SetLabelOffset(0.04*f);; ga->SetLabelSize(0.07*f);; ga->SetLineColor(0);; ga->Draw();; ; // Get offset string of axis time format: there is not accessor; // to time format in TGaxis.; // Assumes TAxis use the same format.; TAxis a(10, 0, 1600000000);; a.SetTimeOffset(offset[i], opt);; const char* offsettimeformat = a.GetTimeFormat();; ; char buf[256];; if (offset[i] < t[i]) {; snprintf(buf, 256, ""#splitline{%s, %s}{offset: %ld, option %s}"",; stime(t+i).Data(), stime(t+i, true).Data(), offset[i], opt);; } else {; int h = t[i] / 3600;; int m = (t[i] - 3600 * h) / 60 ;; int s = (t[i] - h * 3600 - m * 60);; snprintf(buf, 256, ""#splitline{%d h %d m %d s}{offset: %s, option %s}"",; h, m, s, stime(offset + i, gmt).Data(), opt);; }; tex1.DrawLatex(.01, .75, buf);; tex2.DrawLatex(.01, .50, offsettimeformat);; time_t t_ = t[i] + offset[i];; snprintf(buf, 256, ""Expecting: #color[2]{%s}"", stime(&t_, gmt, false).Data());; tex3.DrawLatex(.01, .24, buf);; if(i > 0) l.DrawLine(0, 0.95, 1, 0.95);; }; }; }; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSh",MatchSource.WIKI,doc/master/timeonaxis3_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/timeonaxis3_8C.html
Testability,test,test,". ROOT: tutorials/graphs/timeonaxis3.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. timeonaxis3.C File ReferenceTutorials » Graphs tutorials. Detailed Description; This example compares what the system time function gmtime and localtime give with what gives TGaxis. ; It can be used as referenced test to check if TGaxis is working properly. The original code was developed by Philippe Gras (CEA Saclay. IRFU/SEDI). ; #include ""TAxis.h""; #include ""TGaxis.h""; #include ""TCanvas.h""; #include ""TString.h""; #include ""TLine.h""; #include ""TLatex.h""; #include <ctime>; #include <cstdio>; ; TString stime(time_t* t, bool utc = false, bool display_time_zone = true) {; struct tm* tt;; if (utc) tt = gmtime(t);; else tt = localtime(t);; char buf[256];; if (display_time_zone) strftime(buf, sizeof(buf), ""%Y-%m-%d %H:%M:%S %Z"", tt);; else strftime(buf, sizeof(buf), ""%Y-%m-%d %H:%M:%S"", tt);; return TString(buf);; }; ; ; void timeonaxis3() {; double f = 1.8;; ; auto c = new TCanvas;; ; TLatex tex1;; tex1.SetNDC();; tex1.SetTextFont(102);; tex1.SetTextSize(0.055*f);; ; TLatex tex3;; tex3.SetNDC();; tex3.SetTextFont(102);; tex3.SetTextSize(0.07*f);; tex3.SetTextColor(kBlue+2);; ; TLatex tex2;; tex2.SetNDC();; tex2.SetTextFont(102);; tex2.SetTextSize(0.07*f);; tex2.SetTextColor(kOrange+3);; ; time_t offset[] = {0, 0, 1325376000, 1341100800};; time_t t[] = {1331150400, 1336417200, 0, 36000};; ; c->SetTopMargin(0); c->SetBottomMargin(0);; c->SetLeftMargin(0); c->SetRightMargin(0);; c->Divide(2, 4, -1, -1);; TLine l;; l.DrawLine(0.5, 0, 0.5, 1.);; ; for(int i = 0; i < 4; ++i){; for(int gmt = 0; gmt < 2; ++gmt){; const char* opt = (gmt ? ""gmt"" : ""local"");; TVirtualPad* p = c->cd(2*i + gmt + 1);; p->SetTopMargin(0); p->SetBottomMargin(0);; p->SetLeftMargin(0); p->SetRightMargin(0);; p->SetFillStyle(4000);; ; TGaxis* ga = new TGaxis (.4, .25, 5., .25, t[i], t[i] + 1, 1, ""t"");; ga->SetTimeFormat(""TGaxis label: #color[2]{%Y-%m-%d %H:%M:%S}"");; ga->Se",MatchSource.WIKI,doc/master/timeonaxis3_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/timeonaxis3_8C.html
Usability,simpl,simple,"Class to manage histogram axis.Definition TAxis.h:31; TCanvasThe Canvas class.Definition TCanvas.h:23; TGaxisThe axis painter class.Definition TGaxis.h:24; TGaxis::SetTimeFormatvoid SetTimeFormat(const char *tformat)Change the format used for time plotting.Definition TGaxis.cxx:2969; TGaxis::SetLabelFontvoid SetLabelFont(Int_t labelfont)Definition TGaxis.h:105; TGaxis::SetLabelOffsetvoid SetLabelOffset(Float_t labeloffset)Definition TGaxis.h:106; TGaxis::SetTimeOffsetvoid SetTimeOffset(Double_t toffset, Option_t *option=""local"")Change the time offset. If option = ""gmt"", set display mode to GMT.Definition TGaxis.cxx:2993; TGaxis::SetLabelColorvoid SetLabelColor(Int_t labelcolor)Definition TGaxis.h:104; TGaxis::SetLabelSizevoid SetLabelSize(Float_t labelsize)Definition TGaxis.h:107; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::DrawLatexTLatex * DrawLatex(Double_t x, Double_t y, const char *text)Make a copy of this object with the new parameters And copy object attributes.Definition TLatex.cxx:1943; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::DrawLinevirtual TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:103; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TStringBasic string class.Definition TString.h:139; TText::SetNDCvirtual void SetNDC(Bool_t isNDC=kTRUE)Set NDC mode on if isNDC = kTRUE, off otherwise.Definition TText.cxx:823; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4; ttauto * ttDefinition textangle.C:16; AuthorsPhilippe Gras, Bertrand Bellenot, Olivier Couet ; Definition in file timeonaxis3.C. tutorialsgraphstimeonaxis3.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/timeonaxis3_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/timeonaxis3_8C.html
Usability,simpl,simple,"he time offset is the one that will be used by all graphs.; // If one changes it, it will be changed even on the graphs already defined; gStyle->SetTimeOffset(script_time);; ; auto ct = new TCanvas(""ct"",""Time on axis"",10,10,700,900);; ct->Divide(1,3);; ; int i;; ; //### Build a signal: noisy damped sine; // Time interval: 30 minutes; ; gStyle->SetTitleH(0.08);; float noise;; auto ht = new TH1F(""ht"",""Love at first sight"",3000,0.,2000.);; for (i=1;i<3000;i++) {; noise = gRandom->Gaus(0,120);; if (i>700) {; noise += 1000*sin((i-700)*6.28/30)*exp((double)(700-i)/300);; }; ht->SetBinContent(i,noise);; }; ct->cd(1);; ht->SetLineColor(2);; ht->GetXaxis()->SetLabelSize(0.05);; ht->Draw();; // Sets time on the X axis; // The time used is the one set as time offset added to the value; // of the axis. This is converted into day/month/year hour:min:sec and; // a reasonable tick interval value is chosen.; ht->GetXaxis()->SetTimeDisplay(1);; ; //### Build a simple graph beginning at a different time; // Time interval: 5 seconds; ; float x[100], t[100];; for (i=0;i<100;i++) {; x[i] = sin(i*4*3.1415926/50)*exp(-(double)i/20);; t[i] = 6000+(double)i/20;; }; auto gt = new TGraph(100,t,x);; gt->SetTitle(""Politics"");; ct->cd(2);; gt->SetLineColor(5);; gt->SetLineWidth(2);; gt->Draw(""AL"");; gt->GetXaxis()->SetLabelSize(0.05);; // Sets time on the X axis; gt->GetXaxis()->SetTimeDisplay(1);; gPad->Modified();; ; //### Build a second simple graph for a very long time interval; // Time interval: a few years; ; auto gt2 = new TGraph();; TDatime dateBegin(2000,1,1,0,0,0);; for (i=0;i<10;i++) {; TDatime datePnt(2000 + i,1,1,0,0,0);; gt2->AddPoint(datePnt.Convert() - dateBegin.Convert(), 100 + gRandom->Gaus(500,100)*i);; }; gt2->SetTitle(""Number of monkeys on the moon"");; ct->cd(3);; gt2->SetMarkerColor(4);; gt2->SetMarkerStyle(29);; gt2->SetMarkerSize(1.3);; gt2->Draw(""AP"");; gt2->GetXaxis()->SetLabelSize(0.04);; gt2->GetXaxis()->SetNdivisions(10);; // Sets time on the X axis; gt2->GetXaxis()-",MatchSource.WIKI,doc/master/timeonaxis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/timeonaxis_8C.html
Availability,error,error,"//////////////////////////////////////////; 46/// TInterpreter ctor only called by derived classes.; 47 ; 48TInterpreter::TInterpreter(const char *name, const char *title); 49 : TNamed(name, title); 50{; 51 gInterpreterLocal = this;; 52 gCling = this;; 53}; 54 ; 55////////////////////////////////////////////////////////////////////////////////; 56/// returns gInterpreter global; 57 ; 58TInterpreter *TInterpreter::Instance(); 59{; 60 if (gInterpreterLocal == nullptr) {; 61 static TROOT *getROOT = ROOT::GetROOT(); // Make sure gInterpreterLocal is set; 62 if (!getROOT) {; 63 ::Fatal(""TInterpreter::Instance"",""TROOT object is required before accessing a TInterpreter"");; 64 }; 65 }; 66 return gInterpreterLocal;; 67}; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TError.h; namechar name[80]Definition TGX11.cxx:110; TGlobal.h; gInterpreterLocalstatic TInterpreter * gInterpreterLocalDefinition TInterpreter.cxx:25; gClingTInterpreter * gClingDefinition TInterpreter.cxx:24; TInterpreter.h; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; TROOT.h; TGlobalMappedFunction::MakeFunctorstatic void MakeFunctor(const char *name, const char *type, GlobFunc &func)Definition TGlobal.h:73; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::TInterpreterTInterpreter()Definition TInterpreter.h:135; TInterpreter::Instancestatic TInterpreter * Instance()returns gInterpreter globalDefinition TInterpreter.cxx:58; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TROOTROOT top level object description.Definition TROOT.h:94; ROOT::GetROOTTROOT * GetROOT()Definition TROOT.cxx:472. coremetasrcTInterpreter.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TInterpreter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8cxx_source.html
Integrability,interface,interface,". ROOT: core/meta/src/TInterpreter.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TInterpreter.cxx. Go to the documentation of this file. 1// @(#)root/meta:$Id$; 2// Author: Fons Rademakers 01/03/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TInterpreter; 13This class defines an abstract interface to a generic command line; 14interpreter.; 15*/; 16 ; 17#include ""TInterpreter.h""; 18 ; 19#include ""TROOT.h""; 20#include ""TError.h""; 21#include ""TGlobal.h""; 22 ; 23 ; 24TInterpreter* gCling = nullptr; // returns pointer to global TCling object; 25static TInterpreter *gInterpreterLocal = nullptr; // The real holder of the pointer.; 26 ; 27 ; 28namespace {; 29static struct AddPseudoGlobals {; 30AddPseudoGlobals() {; 31 ; 32 // use special functor to extract pointer on gInterpreterLocal variable; 33 TGlobalMappedFunction::MakeFunctor(""gInterpreter"", ""TInterpreter*"", TInterpreter::Instance, [] {; 34 TInterpreter::Instance();; 35 return (void *) &gInterpreterLocal;; 36 });; 37 ; 38}; 39} gAddPseudoGlobals;; 40}; 41 ; 42 ; 43ClassImp(TInterpreter);; 44 ; 45////////////////////////////////////////////////////////////////////////////////; 46/// TInterpreter ctor only called by derived classes.; 47 ; 48TInterpreter::TInterpreter(const char *name, const char *title); 49 : TNamed(name, title); 50{; 51 gInterpreterLocal = this;; 52 gCling = this;; 53}; 54 ; 55////////////////////////////////////////////////////////////////////////////////; 56/// returns gInterpreter global; 57 ; 58TInterpreter *TInterpreter::Instance(); 59{; 60 if (gInterpreterLocal == nullptr) {; 61 static TROOT *getROOT =",MatchSource.WIKI,doc/master/TInterpreter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8cxx_source.html
Modifiability,variab,variable,"**************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TInterpreter; 13This class defines an abstract interface to a generic command line; 14interpreter.; 15*/; 16 ; 17#include ""TInterpreter.h""; 18 ; 19#include ""TROOT.h""; 20#include ""TError.h""; 21#include ""TGlobal.h""; 22 ; 23 ; 24TInterpreter* gCling = nullptr; // returns pointer to global TCling object; 25static TInterpreter *gInterpreterLocal = nullptr; // The real holder of the pointer.; 26 ; 27 ; 28namespace {; 29static struct AddPseudoGlobals {; 30AddPseudoGlobals() {; 31 ; 32 // use special functor to extract pointer on gInterpreterLocal variable; 33 TGlobalMappedFunction::MakeFunctor(""gInterpreter"", ""TInterpreter*"", TInterpreter::Instance, [] {; 34 TInterpreter::Instance();; 35 return (void *) &gInterpreterLocal;; 36 });; 37 ; 38}; 39} gAddPseudoGlobals;; 40}; 41 ; 42 ; 43ClassImp(TInterpreter);; 44 ; 45////////////////////////////////////////////////////////////////////////////////; 46/// TInterpreter ctor only called by derived classes.; 47 ; 48TInterpreter::TInterpreter(const char *name, const char *title); 49 : TNamed(name, title); 50{; 51 gInterpreterLocal = this;; 52 gCling = this;; 53}; 54 ; 55////////////////////////////////////////////////////////////////////////////////; 56/// returns gInterpreter global; 57 ; 58TInterpreter *TInterpreter::Instance(); 59{; 60 if (gInterpreterLocal == nullptr) {; 61 static TROOT *getROOT = ROOT::GetROOT(); // Make sure gInterpreterLocal is set; 62 if (!getROOT) {; 63 ::Fatal(""TInterpreter::Instance"",""TROOT object is required before accessing a TInterpreter"");; 64 }; 65 }; 66 return gInterpreterLocal;; 67}; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TError.h; namechar name[80]Definition T",MatchSource.WIKI,doc/master/TInterpreter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8cxx_source.html
Security,access,accessing,"ing object; 25static TInterpreter *gInterpreterLocal = nullptr; // The real holder of the pointer.; 26 ; 27 ; 28namespace {; 29static struct AddPseudoGlobals {; 30AddPseudoGlobals() {; 31 ; 32 // use special functor to extract pointer on gInterpreterLocal variable; 33 TGlobalMappedFunction::MakeFunctor(""gInterpreter"", ""TInterpreter*"", TInterpreter::Instance, [] {; 34 TInterpreter::Instance();; 35 return (void *) &gInterpreterLocal;; 36 });; 37 ; 38}; 39} gAddPseudoGlobals;; 40}; 41 ; 42 ; 43ClassImp(TInterpreter);; 44 ; 45////////////////////////////////////////////////////////////////////////////////; 46/// TInterpreter ctor only called by derived classes.; 47 ; 48TInterpreter::TInterpreter(const char *name, const char *title); 49 : TNamed(name, title); 50{; 51 gInterpreterLocal = this;; 52 gCling = this;; 53}; 54 ; 55////////////////////////////////////////////////////////////////////////////////; 56/// returns gInterpreter global; 57 ; 58TInterpreter *TInterpreter::Instance(); 59{; 60 if (gInterpreterLocal == nullptr) {; 61 static TROOT *getROOT = ROOT::GetROOT(); // Make sure gInterpreterLocal is set; 62 if (!getROOT) {; 63 ::Fatal(""TInterpreter::Instance"",""TROOT object is required before accessing a TInterpreter"");; 64 }; 65 }; 66 return gInterpreterLocal;; 67}; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TError.h; namechar name[80]Definition TGX11.cxx:110; TGlobal.h; gInterpreterLocalstatic TInterpreter * gInterpreterLocalDefinition TInterpreter.cxx:25; gClingTInterpreter * gClingDefinition TInterpreter.cxx:24; TInterpreter.h; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; TROOT.h; TGlobalMappedFunction::MakeFunctorstatic void MakeFunctor(const char *name, const char *type, GlobFunc &func)Definition TGlobal.h:73; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::TInterpreterTInterpreter()Definition TInterpreter.h:135; TInterpreter::Instancestatic",MatchSource.WIKI,doc/master/TInterpreter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8cxx_source.html
Integrability,depend,dependency,". ROOT: core/meta/inc/TInterpreter.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Macros |; Typedefs |; Variables ; TInterpreter.h File Reference. #include ""TDataType.h""; #include ""TDictionary.h""; #include ""TInterpreterValue.h""; #include ""TNamed.h""; #include ""TVirtualRWMutex.h""; #include <map>; #include <typeinfo>; #include <vector>; #include <string>; #include <utility>. Include dependency graph for TInterpreter.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  TInterpreter::CallFuncIFacePtr_t;  ; struct  ROOT::Internal::InterpreterMutexRegistrationRAII;  ; class  TInterpreter::SuspendAutoLoadingRAII;  ; class  TInterpreter::SuspendAutoParsing;  ; class  TInterpreter;  This class defines an abstract interface to a generic command line interpreter. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define gInterpreter   (TInterpreter::Instance());  ; #define R__LOCKGUARD_CLING(mutex)   ::ROOT::Internal::InterpreterMutexRegistrationRAII _R__UNIQUE_(R__guard)(mutex); { };  . Typedefs; typedef TInterpreter * CreateInterpreter_t(void *shlibHandle, const char *argv[]);  ; typedef void * DestroyInterpreter_t(TInterpreter *);  . Variables; R__EXTERN TInterpreter * gCling;  ; R__EXTERN TVirtualMutex * gInterpreterMutex;  . Macro Definition Documentation. ◆ gInterpreter. #define gInterpreter   (TInterpreter::Instance()). Definition at line 573 of file TInterpreter.h. ◆ R__LOCKGUARD_CLING. #define R__LOCKGUARD_CLING; (;  ; mutex);    ::ROOT::Internal::InterpreterMutexRegistrationRAII _R__UNIQUE_(R__guard",MatchSource.WIKI,doc/master/TInterpreter_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h.html
Availability,error,error,"ndef ROOT_TInterpreter; 14#define ROOT_TInterpreter; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TInterpreter //; 19// //; 20// This class defines an abstract interface to a generic command line //; 21// interpreter. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TDataType.h""; 26#include ""TDictionary.h""; 27#include ""TInterpreterValue.h""; 28#include ""TNamed.h""; 29#include ""TVirtualRWMutex.h""; 30 ; 31#include <map>; 32#include <typeinfo>; 33#include <vector>; 34#include <string>; 35#include <utility>; 36 ; 37class TClass;; 38class TEnv;; 39class TFunction;; 40class TMethod;; 41class TObjArray;; 42class TEnum;; 43class TListOfEnums;; 44class TSeqCollection;; 45 ; 46R__EXTERN TVirtualMutex *gInterpreterMutex;; 47 ; 48# define R__LOCKGUARD_CLING(mutex) ::ROOT::Internal::InterpreterMutexRegistrationRAII _R__UNIQUE_(R__guard)(mutex); { }; 49 ; 50namespace ROOT {; 51namespace Internal {; 52struct InterpreterMutexRegistrationRAII {; 53 TLockGuard fLockGuard;; 54 InterpreterMutexRegistrationRAII(TVirtualMutex* mutex);; 55 ~InterpreterMutexRegistrationRAII();; 56};; 57}; 58}; 59 ; 60class TInterpreter : public TNamed {; 61 ; 62protected:; 63 void Execute(TMethod *method, TObjArray *params, int *error = nullptr) override = 0;; 64 virtual Bool_t SetSuspendAutoParsing(Bool_t value) = 0;; 65 ; 66 friend class SuspendAutoParsing;; 67 ; 68public:; 69 // See as in TSchemaType.h.; 70 typedef class std::map<std::string, std::string> MembersMap_t;; 71 ; 72 enum EErrorCode {; 73 kNoError = 0,; 74 kRecoverable = 1,; 75 kDangerous = 2,; 76 kFatal = 3,; 77 kProcessing = 99; 78 };; 79 ; 80 enum class EReturnType { kLong, kDouble, kString, kOther, kNoReturnType };; 81 ; 82 struct CallFuncIFacePtr_t {; 83 enum EKind {; 84 kUninitialized,; 85 kGeneric,; 86 kCtor,; 87 kDtor; 88 };; 89 ; 90 typedef void (*Generic_t)(void*, int, void**, void*);; 91 typedef void (*Ctor_t)(void**, void*,",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
Deployability,release,release,"unc(void (*)()) const {}; 263 virtual void SetAllocunlockfunc(void (*)()) const {}; 264 virtual int SetClassAutoLoading(int) const {return 0;}; 265 int SetClassAutoloading(int a) const { return SetClassAutoLoading(a); } // Deprecated; 266 virtual int SetClassAutoparsing(int) {return 0;};; 267 virtual void SetErrmsgcallback(void * /* p */) const {}; 268 /// \brief Report diagnostics to the ROOT error handler (see TError.h).; 269 virtual void ReportDiagnosticsToErrorHandler(bool /*enable*/ = true) {}; 270 virtual void SetTempLevel(int /* val */) const {}; 271 virtual int UnloadFile(const char * /* path */) const {return 0;}; 272 ; 273 /// The created temporary must be deleted by the caller.; 274 /// Deprecated! Please use MakeInterpreterValue().; 275 TInterpreterValue *CreateTemporary() const {; 276 return MakeInterpreterValue().release();; 277 }; 278 virtual std::unique_ptr<TInterpreterValue> MakeInterpreterValue() const { return nullptr; }; 279 virtual void CodeComplete(const std::string&, size_t&,; 280 std::vector<std::string>&) {}; 281 virtual int Evaluate(const char*, TInterpreterValue&) {return 0;}; 282 ; 283 // core/meta helper functions.; 284 virtual EReturnType MethodCallReturnType(TFunction *func) const = 0;; 285 virtual ULong64_t GetInterpreterStateMarker() const = 0;; 286 virtual bool DiagnoseIfInterpreterException(const std::exception &e) const = 0;; 287 ; 288 typedef TDictionary::DeclId_t DeclId_t;; 289 virtual DeclId_t GetDeclId(CallFunc_t *info) const = 0;; 290 virtual DeclId_t GetDeclId(ClassInfo_t *info) const = 0;; 291 virtual DeclId_t GetDeclId(DataMemberInfo_t *info) const = 0;; 292 virtual DeclId_t GetDeclId(FuncTempInfo_t *info) const = 0;; 293 virtual DeclId_t GetDeclId(MethodInfo_t *info) const = 0;; 294 virtual DeclId_t GetDeclId(TypedefInfo_t *info) const = 0;; 295 ; 296 virtual void SetDeclAttr(DeclId_t, const char* /* attribute */) = 0 ;; 297 ; 298 virtual DeclId_t GetDataMember(ClassInfo_t *cl, const char *name) const = 0;; 299 virtual De",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
Integrability,interface,interface,". ROOT: core/meta/inc/TInterpreter.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TInterpreter.h. Go to the documentation of this file. 1// @(#)root/meta:$Id$; 2// Author: Fons Rademakers 01/03/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13#ifndef ROOT_TInterpreter; 14#define ROOT_TInterpreter; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TInterpreter //; 19// //; 20// This class defines an abstract interface to a generic command line //; 21// interpreter. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TDataType.h""; 26#include ""TDictionary.h""; 27#include ""TInterpreterValue.h""; 28#include ""TNamed.h""; 29#include ""TVirtualRWMutex.h""; 30 ; 31#include <map>; 32#include <typeinfo>; 33#include <vector>; 34#include <string>; 35#include <utility>; 36 ; 37class TClass;; 38class TEnv;; 39class TFunction;; 40class TMethod;; 41class TObjArray;; 42class TEnum;; 43class TListOfEnums;; 44class TSeqCollection;; 45 ; 46R__EXTERN TVirtualMutex *gInterpreterMutex;; 47 ; 48# define R__LOCKGUARD_CLING(mutex) ::ROOT::Internal::InterpreterMutexRegistrationRAII _R__UNIQUE_(R__guard)(mutex); { }; 49 ; 50namespace ROOT {; 51namespace Internal {; 52struct InterpreterMutexRegistrationRAII {; 53 TLockGuard fLockGuard;; 54 InterpreterMutexRegistrationRAII(TVirtualMutex* mutex);; 55 ~InterpreterMutexRegistrationRAII();; 56};; 57}; 58}; 59 ; 60class TInterpreter : public TNamed {; 61 ; 62protected:; 63 void Execute(TMethod *method, TObjArray *params, int *error = nullptr) override = 0;; 64 virtual Boo",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
Modifiability,config,config,"xx:110; TInterpreterValue.h; gInterpreterMutexR__EXTERN TVirtualMutex * gInterpreterMutexDefinition TInterpreter.h:46; CreateInterpreter_tTInterpreter * CreateInterpreter_t(void *shlibHandle, const char *argv[])Definition TInterpreter.h:570; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; DestroyInterpreter_tvoid * DestroyInterpreter_t(TInterpreter *)Definition TInterpreter.h:571; TNamed.h; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; TVirtualRWMutex.h; protoconst char * protoDefinition civetweb.c:17535; ROOT::TVirtualRWMutexDefinition TVirtualRWMutex.h:39; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TDictionary::EMemberSelectionEMemberSelectionKinds of members to include in lists.Definition TDictionary.h:216; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TEnumThe TEnum class implements the enum type.Definition TEnum.h:33; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TInterpreterValueDefinition TInterpreterValue.h:32; TInterpreter::SuspendAutoLoadingRAIIDefinition TInterpreter.h:120; TInterpreter::SuspendAutoLoadingRAII::~SuspendAutoLoadingRAII~SuspendAutoLoadingRAII()Definition TInterpreter.h:129; TInterpreter::SuspendAutoLoadingRAII::fOldValuebool fOldValueDefinition TInterpreter.h:122; TInterpreter::SuspendAutoLoadingRAII::fInterpTInterpreter * fInterpDefinition TInterpreter.h:121; TInterpreter::SuspendAutoLoadingRAII::SuspendAutoLoadingRAIISuspendAutoLoadingRAII(TInterpreter *interp)Definition TInterpreter.h:125; TInterpreter::SuspendAutoParsingDefinition TInterpreter.h:111; TInterpreter::SuspendAutoParsing::SuspendAutoParsingSuspendAutoParsing(TInterpreter *where, Bool_t value=kTRUE)Definition TInterpreter.h:115; TInterpreter::SuspendAutoParsing::fPreviousBool_t fPreviousDefinition TI",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
Performance,load,load,"_t fGeneric;; 106 Ctor_t fCtor;; 107 Dtor_t fDtor;; 108 };; 109 };; 110 ; 111 class SuspendAutoParsing {; 112 TInterpreter *fInterp;; 113 Bool_t fPrevious;; 114 public:; 115 SuspendAutoParsing(TInterpreter *where, Bool_t value = kTRUE) : fInterp(where), fPrevious(fInterp->SetSuspendAutoParsing(value)) {}; 116 ~SuspendAutoParsing() { fInterp->SetSuspendAutoParsing(fPrevious); }; 117 };; 118 virtual Bool_t IsAutoParsingSuspended() const = 0;; 119 ; 120 class SuspendAutoLoadingRAII {; 121 TInterpreter *fInterp = nullptr;; 122 bool fOldValue;; 123 ; 124 public:; 125 SuspendAutoLoadingRAII(TInterpreter *interp) : fInterp(interp); 126 {; 127 fOldValue = fInterp->SetClassAutoLoading(false);; 128 }; 129 ~SuspendAutoLoadingRAII() { fInterp->SetClassAutoLoading(fOldValue); }; 130 };; 131 ; 132 typedef int (*AutoLoadCallBack_t)(const char*);; 133 typedef std::vector<std::pair<std::string, int> > FwdDeclArgsToKeepCollection_t;; 134 ; 135 TInterpreter() { } // for Dictionary; 136 TInterpreter(const char *name, const char *title = ""Generic Interpreter"");; 137 virtual ~TInterpreter() { }; 138 ; 139 virtual void AddIncludePath(const char *path) = 0;; 140 virtual void *SetAutoLoadCallBack(void* /*cb*/) { return nullptr; }; 141 virtual void *GetAutoLoadCallBack() const { return nullptr; }; 142 virtual Int_t AutoLoad(const char *classname, Bool_t knowDictNotLoaded = kFALSE) = 0;; 143 virtual Int_t AutoLoad(const std::type_info& typeinfo, Bool_t knowDictNotLoaded = kFALSE) = 0;; 144 virtual Int_t AutoParse(const char* cls) = 0;; 145 virtual void ClearFileBusy() = 0;; 146 virtual void ClearStack() = 0; // Delete existing temporary values; 147 virtual Bool_t Declare(const char* code) = 0;; 148 virtual void EndOfLineAction() = 0;; 149 virtual TClass *GetClass(const std::type_info& typeinfo, Bool_t load) const = 0;; 150 virtual Int_t GetExitCode() const = 0;; 151 virtual TEnv *GetMapfile() const { return nullptr; }; 152 ///\brief Returns whether the interpreter is waiting for more input, i.",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
Security,access,access," *info) const =0; TInterpreter::FuncTempInfo_IsValidvirtual Bool_t FuncTempInfo_IsValid(FuncTempInfo_t *) const =0; TInterpreter::CallFunc_SetArgImplvoid CallFunc_SetArgImpl(CallFunc_t *func, const U &head)Definition TInterpreter.h:367; TInterpreter::BaseClassInfo_Propertyvirtual Long_t BaseClassInfo_Property(BaseClassInfo_t *) constDefinition TInterpreter.h:447; TInterpreter::CallFunc_ExecDoublevirtual Double_t CallFunc_ExecDouble(CallFunc_t *, void *) constDefinition TInterpreter.h:321; TInterpreter::CallFunc_SetArgvirtual void CallFunc_SetArg(CallFunc_t *, Long_t) const =0; TInterpreter::GetInterfaceMethodvirtual void * GetInterfaceMethod(TClass *cl, const char *method, const char *params, Bool_t objectIsConst=kFALSE)=0; TInterpreter::GetCurrentMacroNamevirtual const char * GetCurrentMacroName() constDefinition TInterpreter.h:257; TInterpreter::Executevirtual void Execute(TObject *obj, TClass *cl, const char *method, const char *params, int *error=nullptr)=0; TInterpreter::TypeNamevirtual const char * TypeName(const char *s)=0; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TLockGuardDefinition TVirtualMutex.h:70; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string class.Definition TString.h:139; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; double; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOTtbb::task_arena is an alias of tbb::",MatchSource.WIKI,doc/master/TInterpreter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html
Energy Efficiency,efficient,efficient,"features in this enum.; 63};; 64 ; 65 ; 66} // namespace Experimental; 67 ; 68 ; 69class TIOFeatures {; 70friend class ::TTree;; 71friend class ::TBranch;; 72friend class ::TBasket;; 73 ; 74public:; 75 TIOFeatures() {}; 76 ; 77 void Clear(EIOFeatures bits);; 78 void Clear(Experimental::EIOUnsupportedFeatures bits);; 79 void Clear(Experimental::EIOFeatures bits);; 80 bool Set(EIOFeatures bits);; 81 bool Set(Experimental::EIOFeatures bits);; 82 bool Set(const std::string &);; 83 bool Test(EIOFeatures bits) const;; 84 bool Test(Experimental::EIOFeatures bits) const;; 85 bool Test(Experimental::EIOUnsupportedFeatures bits) const;; 86 void Print() const;; 87 ; 88 // The number of known, defined IO features (supported / unsupported / experimental).; 89 static constexpr int kIOFeatureCount = 1;; 90 ; 91private:; 92 // These methods allow access to the raw bitset underlying; 93 // this object, breaking type safety. They are necessary for; 94 // efficient interaction with TTree / TBranch / TBasket, but left; 95 // private to prevent users from interacting with the raw bits.; 96 TIOFeatures(UChar_t IOBits) : fIOBits(IOBits) {}; 97 UChar_t GetFeatures() const;; 98 void Set(UChar_t newBits) {fIOBits = newBits;}; 99 ; 100 UChar_t fIOBits{0};; 101};; 102 ; 103} // namespace ROOT; 104 ; 105#endif // ROOT_TIO_FEATURES; UChar_tunsigned char UChar_tDefinition RtypesCore.h:38; Rtypes.h; BIT#define BIT(n)Definition Rtypes.h:90; ROOT::TIOFeaturesTIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TT...Definition TIOFeatures.hxx:69; ROOT::TIOFeatures::GetFeaturesUChar_t GetFeatures() constDefinition TIOFeatures.cxx:250; ROOT::TIOFeatures::TIOFeaturesTIOFeatures(UChar_t IOBits)Definition TIOFeatures.hxx:96; ROOT::TIOFeatures::Testbool Test(Experimental::EIOUnsupportedFeatures bits) const; ROOT::TIOFeatures::Printvoid Print() constPrint a human-readable representation of the TIOFeatures to stdout.Definition TIOFeatures.cxx:197; ROOT::TIOFeature",MatchSource.WIKI,doc/master/TIOFeatures_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TIOFeatures_8hxx_source.html
Safety,safe,safety,"re is never an IO feature that goes into the ROOT:: namespace; 60// but is unsupported.; 61enum class EIOUnsupportedFeatures {; 62 kUnsupported = 0 // Union of all features in this enum.; 63};; 64 ; 65 ; 66} // namespace Experimental; 67 ; 68 ; 69class TIOFeatures {; 70friend class ::TTree;; 71friend class ::TBranch;; 72friend class ::TBasket;; 73 ; 74public:; 75 TIOFeatures() {}; 76 ; 77 void Clear(EIOFeatures bits);; 78 void Clear(Experimental::EIOUnsupportedFeatures bits);; 79 void Clear(Experimental::EIOFeatures bits);; 80 bool Set(EIOFeatures bits);; 81 bool Set(Experimental::EIOFeatures bits);; 82 bool Set(const std::string &);; 83 bool Test(EIOFeatures bits) const;; 84 bool Test(Experimental::EIOFeatures bits) const;; 85 bool Test(Experimental::EIOUnsupportedFeatures bits) const;; 86 void Print() const;; 87 ; 88 // The number of known, defined IO features (supported / unsupported / experimental).; 89 static constexpr int kIOFeatureCount = 1;; 90 ; 91private:; 92 // These methods allow access to the raw bitset underlying; 93 // this object, breaking type safety. They are necessary for; 94 // efficient interaction with TTree / TBranch / TBasket, but left; 95 // private to prevent users from interacting with the raw bits.; 96 TIOFeatures(UChar_t IOBits) : fIOBits(IOBits) {}; 97 UChar_t GetFeatures() const;; 98 void Set(UChar_t newBits) {fIOBits = newBits;}; 99 ; 100 UChar_t fIOBits{0};; 101};; 102 ; 103} // namespace ROOT; 104 ; 105#endif // ROOT_TIO_FEATURES; UChar_tunsigned char UChar_tDefinition RtypesCore.h:38; Rtypes.h; BIT#define BIT(n)Definition Rtypes.h:90; ROOT::TIOFeaturesTIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TT...Definition TIOFeatures.hxx:69; ROOT::TIOFeatures::GetFeaturesUChar_t GetFeatures() constDefinition TIOFeatures.cxx:250; ROOT::TIOFeatures::TIOFeaturesTIOFeatures(UChar_t IOBits)Definition TIOFeatures.hxx:96; ROOT::TIOFeatures::Testbool Test(Experimental::EIOUnsupportedFeatures bits)",MatchSource.WIKI,doc/master/TIOFeatures_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TIOFeatures_8hxx_source.html
Security,access,access,"re is never an IO feature that goes into the ROOT:: namespace; 60// but is unsupported.; 61enum class EIOUnsupportedFeatures {; 62 kUnsupported = 0 // Union of all features in this enum.; 63};; 64 ; 65 ; 66} // namespace Experimental; 67 ; 68 ; 69class TIOFeatures {; 70friend class ::TTree;; 71friend class ::TBranch;; 72friend class ::TBasket;; 73 ; 74public:; 75 TIOFeatures() {}; 76 ; 77 void Clear(EIOFeatures bits);; 78 void Clear(Experimental::EIOUnsupportedFeatures bits);; 79 void Clear(Experimental::EIOFeatures bits);; 80 bool Set(EIOFeatures bits);; 81 bool Set(Experimental::EIOFeatures bits);; 82 bool Set(const std::string &);; 83 bool Test(EIOFeatures bits) const;; 84 bool Test(Experimental::EIOFeatures bits) const;; 85 bool Test(Experimental::EIOUnsupportedFeatures bits) const;; 86 void Print() const;; 87 ; 88 // The number of known, defined IO features (supported / unsupported / experimental).; 89 static constexpr int kIOFeatureCount = 1;; 90 ; 91private:; 92 // These methods allow access to the raw bitset underlying; 93 // this object, breaking type safety. They are necessary for; 94 // efficient interaction with TTree / TBranch / TBasket, but left; 95 // private to prevent users from interacting with the raw bits.; 96 TIOFeatures(UChar_t IOBits) : fIOBits(IOBits) {}; 97 UChar_t GetFeatures() const;; 98 void Set(UChar_t newBits) {fIOBits = newBits;}; 99 ; 100 UChar_t fIOBits{0};; 101};; 102 ; 103} // namespace ROOT; 104 ; 105#endif // ROOT_TIO_FEATURES; UChar_tunsigned char UChar_tDefinition RtypesCore.h:38; Rtypes.h; BIT#define BIT(n)Definition Rtypes.h:90; ROOT::TIOFeaturesTIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TT...Definition TIOFeatures.hxx:69; ROOT::TIOFeatures::GetFeaturesUChar_t GetFeatures() constDefinition TIOFeatures.cxx:250; ROOT::TIOFeatures::TIOFeaturesTIOFeatures(UChar_t IOBits)Definition TIOFeatures.hxx:96; ROOT::TIOFeatures::Testbool Test(Experimental::EIOUnsupportedFeatures bits)",MatchSource.WIKI,doc/master/TIOFeatures_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TIOFeatures_8hxx_source.html
Integrability,interface,interface,". ROOT: core/cont/inc/TIterator.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TIterator.h. Go to the documentation of this file. 1// @(#)root/cont:$Id$; 2// Author: Fons Rademakers 13/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TIterator; 13#define ROOT_TIterator; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TIterator //; 19// //; 20// Iterator abstract base class. This base class provides the interface //; 21// for collection iterators. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""Rtypes.h""; 26 ; 27class TCollection;; 28class TObject;; 29 ; 30class TIterator {; 31 ; 32protected:; 33 TIterator() { }; 34 TIterator(const TIterator &) { }; 35 ; 36public:; 37 virtual TIterator &operator=(const TIterator &) = 0;; 38 virtual ~TIterator() { }; 39 virtual const TCollection *GetCollection() const = 0;; 40 virtual Option_t *GetOption() const { return """"; }; 41 virtual TObject *Next() = 0;; 42 virtual void Reset() = 0;; 43 TObject *operator()() { return Next(); }; 44 virtual Bool_t operator!=(const TIterator &) const;; 45 Bool_t operator==(const TIterator & other) const { return !(*this != other); }; 46 virtual TObject *operator*() const;; 47 ; 48 ClassDef(TIterator,0) //Iterator abstract base class; 49};; 50 ; 51#endif; Bool_tbool Bool_tDefinition RtypesCore.h:63; Option_tconst char Option_tDefinition RtypesCore.h:66; Rtypes.h; ClassDef#define ClassDef(name, id)Definition Rtypes.h:342; TCollectionCollection abstract base class.Definition TCollection.h:65; TI",MatchSource.WIKI,doc/master/TIterator_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TIterator_8h_source.html
Availability,redundant,redundant,"; 10 *************************************************************************/; 11 ; 12/**; 13\class TKey; 14\ingroup IO; 15 ; 16 Book space in a file, create I/O buffers, to fill them, (un)compress them.; 17 ; 18 The TKey class includes functions to book space in a file, to create I/O; 19 buffers, to fill these buffers, to compress/uncompress data buffers.; 20 Before saving (making persistent) an object in a file, a key must; 21 be created. The key structure contains all the information to; 22 uniquely identify a persistent object in a file.; 23 | Data Member | Explanation |; 24 |-------------|-------------|; 25 | fNbytes | Number of bytes for the compressed object and key. |; 26 | fObjlen | Length of uncompressed object. |; 27 | fDatime | Date/Time when the object was written. |; 28 | fKeylen | Number of bytes for the key structure. |; 29 | fCycle | Cycle number of the object. |; 30 | fSeekKey | Address of the object on file (points to fNbytes). This is a redundant information used to cross-check the data base integrity. |; 31 | fSeekPdir | Pointer to the directory supporting this object.|; 32 | fClassName | Object class name. |; 33 | fName | Name of the object. |; 34 | fTitle | Title of the object. |; 35 ; 36 In the 16 highest bits of fSeekPdir is encoded a pid offset. This; 37 offset is to be added to the pid index stored in the TRef object; 38 and the referenced TObject.; 39 ; 40 The TKey class is used by ROOT to:; 41 - Write an object in the current directory; 42 - Write a new ntuple buffer; 43 ; 44 The structure of a file is shown in TFile::TFile.; 45 The structure of a directory is shown in TDirectoryFile::TDirectoryFile.; 46 The TKey class is used by the TBasket class.; 47 See also TTree.; 48*/; 49 ; 50#include <atomic>; 51#include <iostream>; 52 ; 53#include ""TROOT.h""; 54#include ""TClass.h""; 55#include ""TDirectoryFile.h""; 56#include ""TFile.h""; 57#include ""TKey.h""; 58#include ""TBufferFile.h""; 59#include ""TFree.h""; 60#include ""TBrowser.h""; 61#include ""Bytes.",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
Deployability,update,updates,"ze+sizeof(Int_t)];; 513 }; 514 char *buffer = fBuffer+nsize;; 515 Int_t nbytesleft = -fLeft; // set header of remaining record; 516 tobuf(buffer, nbytesleft);; 517 bestfree->SetFirst(fSeekKey+nsize);; 518 }; 519 ; 520 fSeekPdir = externFile ? externFile->GetSeekDir() : fMotherDir->GetSeekDir();; 521}; 522 ; 523////////////////////////////////////////////////////////////////////////////////; 524/// TKey default destructor.; 525 ; 526TKey::~TKey(); 527{; 528 if (fMotherDir && fMotherDir->GetListOfKeys()); 529 fMotherDir->GetListOfKeys()->Remove(this);; 530 TKey::DeleteBuffer();; 531}; 532 ; 533////////////////////////////////////////////////////////////////////////////////; 534/// Delete an object from the file.; 535///; 536/// Note: the key is not deleted. You still have to call ""delete key"".; 537/// This is different from the behaviour of TObject::Delete()!; 538 ; 539void TKey::Delete(Option_t *option); 540{; 541 if (TestBit(kIsDirectoryFile)) {; 542 // TDirectoryFile assumes that its location on file never change (for example updates are partial); 543 // and never checks if the space might have been released and thus over-write any data that might; 544 // have been written there.; 545 if (option && option[0] == 'v'); 546 printf(""Rejected attempt to delete TDirectoryFile key: %s at address %lld, nbytes = %d\n"",; 547 GetName(), fSeekKey, fNbytes);; 548 return;; 549 }; 550 if (option && option[0] == 'v') printf(""Deleting key: %s at address %lld, nbytes = %d\n"",GetName(),fSeekKey,fNbytes);; 551 Long64_t first = fSeekKey;; 552 Long64_t last = fSeekKey + fNbytes -1;; 553 if (GetFile()) GetFile()->MakeFree(first, last); // release space used by this key; 554 fMotherDir->GetListOfKeys()->Remove(this);; 555}; 556 ; 557////////////////////////////////////////////////////////////////////////////////; 558/// Delete key buffer(s).; 559 ; 560void TKey::DeleteBuffer(); 561{; 562 if (fBufferRef) {; 563 delete fBufferRef;; 564 fBufferRef = 0;; 565 } else {; 566 // We only need to de",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
Energy Efficiency,allocate,allocated,"he key references a; 425/// folder in which case we don't want to re-read the folder object; 426/// since it might contain new objects not yet saved.; 427 ; 428void TKey::Browse(TBrowser *b); 429{; 430 if (fMotherDir==0) return;; 431 ; 432 TClass *objcl = TClass::GetClass(GetClassName());; 433 ; 434 void* obj = fMotherDir->GetList()->FindObject(GetName());; 435 if (obj && objcl->IsTObject()) {; 436 TObject *tobj = (TObject*) objcl->DynamicCast(TObject::Class(), obj);; 437 if (!tobj->IsFolder()) {; 438 if (tobj->InheritsFrom(TCollection::Class())); 439 tobj->Delete(); // delete also collection elements; 440 delete tobj;; 441 obj = 0;; 442 }; 443 }; 444 ; 445 if (!obj); 446 obj = ReadObj();; 447 ; 448 if (b && obj) {; 449 objcl->Browse(obj,b);; 450 b->SetRefreshFlag(kTRUE);; 451 }; 452}; 453 ; 454////////////////////////////////////////////////////////////////////////////////; 455/// Create a TKey object of specified size.; 456///; 457/// If externFile!=0, key will be allocated in specified file, otherwise file; 458/// of mother directory will be used.; 459 ; 460void TKey::Create(Int_t nbytes, TFile* externFile); 461{; 462 keyAbsNumber++; SetUniqueID(keyAbsNumber);; 463 ; 464 TFile *f = externFile;; 465 if (!f) f = GetFile();; 466 if (!f) {; 467 Error(""Create"",""Cannot create key without file"");; 468 return;; 469 }; 470 ; 471 Int_t nsize = nbytes + fKeylen;; 472 TList *lfree = f->GetListOfFree();; 473 TFree *f1 = (TFree*)lfree->First();; 474//*-*-------------------find free segment; 475//*-* =================; 476 TFree *bestfree = f1->GetBestFree(lfree,nsize);; 477 if (bestfree == 0) {; 478 Error(""Create"",""Cannot allocate %d bytes for ID = %s Title = %s"",; 479 nsize,GetName(),GetTitle());; 480 return;; 481 }; 482 ; 483 if (f->TestBit(TFile::kReproducible)); 484 SetBit(TKey::kReproducible);; 485 ; 486 fDatime.Set();; 487 fSeekKey = bestfree->GetFirst();; 488//*-*----------------- Case Add at the end of the file; 489 if (fSeekKey >= f->GetEND()) {; 490 f->SetEND(fSeekKe",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
Integrability,wrap,wrapper,"stDefinition TBuffer.h:96; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Streamervoid Streamer(void *obj, TBuffer &b, const TClass *onfile_class=nullptr) constDefinition TClass.h:607; TClass::Browsevoid Browse(TBrowser *b) overrideThis method is called by a browser to get the class information.Definition TClass.cxx:2077; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::kDummyNew@ kDummyNewDefinition TClass.h:107; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7460; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::GetActualClassTClass * Get",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
Modifiability,inherit,inheritance,"//; 713/// Print key contents.; 714 ; 715void TKey::Print(Option_t *) const; 716{; 717 printf(""TKey Name = %s, Title = %s, Cycle = %d\n"",GetName(),GetTitle(),GetCycle());; 718}; 719 ; 720////////////////////////////////////////////////////////////////////////////////; 721/// To read a TObject* from the file.; 722///; 723/// The object associated to this key is read from the file into memory; 724/// Once the key structure is read (via Streamer) the class identifier; 725/// of the object is known.; 726/// Using the class identifier we find the TClass object for this class.; 727/// A TClass object contains a full description (i.e. dictionary) of the; 728/// associated class. In particular the TClass object can create a new; 729/// object of the class type it describes. This new object now calls its; 730/// Streamer function to rebuilt itself.; 731///; 732/// Use TKey::ReadObjectAny to read any object non-derived from TObject; 733///; 734/// ### Note; 735/// A C style cast can only be used in the case where the final class; 736/// of this object derives from TObject as a first inheritance, otherwise; 737/// one must use a dynamic_cast.; 738///; 739/// #### Example1: simplified case; 740/// ~~~{.cpp}; 741/// class MyClass : public TObject, public AnotherClass; 742/// ~~~; 743/// then on return, one get away with using:; 744/// ~~~{.cpp}; 745/// MyClass *obj = (MyClass*)key->ReadObj();; 746/// ~~~; 747///; 748/// #### Example2: Usual case (recommended unless performance is critical); 749/// ~~~{.cpp}; 750/// MyClass *obj = dynamic_cast<MyClass*>(key->ReadObj());; 751/// ~~~; 752/// which support also the more complex inheritance like:; 753/// ~~~{.cpp}; 754/// class MyClass : public AnotherClass, public TObject; 755/// ~~~; 756///; 757/// Of course, `dynamic_cast<>` can also be used in the example 1.; 758 ; 759TObject *TKey::ReadObj(); 760{; 761 TClass *cl = TClass::GetClass(fClassName.Data());; 762 if (!cl) {; 763 Error(""ReadObj"", ""Unknown class %s"", fClassName.Data());;",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
Performance,perform,performance," (via Streamer) the class identifier; 725/// of the object is known.; 726/// Using the class identifier we find the TClass object for this class.; 727/// A TClass object contains a full description (i.e. dictionary) of the; 728/// associated class. In particular the TClass object can create a new; 729/// object of the class type it describes. This new object now calls its; 730/// Streamer function to rebuilt itself.; 731///; 732/// Use TKey::ReadObjectAny to read any object non-derived from TObject; 733///; 734/// ### Note; 735/// A C style cast can only be used in the case where the final class; 736/// of this object derives from TObject as a first inheritance, otherwise; 737/// one must use a dynamic_cast.; 738///; 739/// #### Example1: simplified case; 740/// ~~~{.cpp}; 741/// class MyClass : public TObject, public AnotherClass; 742/// ~~~; 743/// then on return, one get away with using:; 744/// ~~~{.cpp}; 745/// MyClass *obj = (MyClass*)key->ReadObj();; 746/// ~~~; 747///; 748/// #### Example2: Usual case (recommended unless performance is critical); 749/// ~~~{.cpp}; 750/// MyClass *obj = dynamic_cast<MyClass*>(key->ReadObj());; 751/// ~~~; 752/// which support also the more complex inheritance like:; 753/// ~~~{.cpp}; 754/// class MyClass : public AnotherClass, public TObject; 755/// ~~~; 756///; 757/// Of course, `dynamic_cast<>` can also be used in the example 1.; 758 ; 759TObject *TKey::ReadObj(); 760{; 761 TClass *cl = TClass::GetClass(fClassName.Data());; 762 if (!cl) {; 763 Error(""ReadObj"", ""Unknown class %s"", fClassName.Data());; 764 return 0;; 765 }; 766 if (!cl->IsTObject()) {; 767 // in principle user should call TKey::ReadObjectAny!; 768 return (TObject*)ReadObjectAny(0);; 769 }; 770 ; 771 TBufferFile bufferRef(TBuffer::kRead, fObjlen+fKeylen);; 772 if (!bufferRef.Buffer()) {; 773 Error(""ReadObj"", ""Cannot allocate buffer: fObjlen = %d"", fObjlen);; 774 return 0;; 775 }; 776 if (GetFile()==0) return 0;; 777 bufferRef.SetParent(GetFile());; 778 bufferR",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
Safety,redund,redundant,"; 10 *************************************************************************/; 11 ; 12/**; 13\class TKey; 14\ingroup IO; 15 ; 16 Book space in a file, create I/O buffers, to fill them, (un)compress them.; 17 ; 18 The TKey class includes functions to book space in a file, to create I/O; 19 buffers, to fill these buffers, to compress/uncompress data buffers.; 20 Before saving (making persistent) an object in a file, a key must; 21 be created. The key structure contains all the information to; 22 uniquely identify a persistent object in a file.; 23 | Data Member | Explanation |; 24 |-------------|-------------|; 25 | fNbytes | Number of bytes for the compressed object and key. |; 26 | fObjlen | Length of uncompressed object. |; 27 | fDatime | Date/Time when the object was written. |; 28 | fKeylen | Number of bytes for the key structure. |; 29 | fCycle | Cycle number of the object. |; 30 | fSeekKey | Address of the object on file (points to fNbytes). This is a redundant information used to cross-check the data base integrity. |; 31 | fSeekPdir | Pointer to the directory supporting this object.|; 32 | fClassName | Object class name. |; 33 | fName | Name of the object. |; 34 | fTitle | Title of the object. |; 35 ; 36 In the 16 highest bits of fSeekPdir is encoded a pid offset. This; 37 offset is to be added to the pid index stored in the TRef object; 38 and the referenced TObject.; 39 ; 40 The TKey class is used by ROOT to:; 41 - Write an object in the current directory; 42 - Write a new ntuple buffer; 43 ; 44 The structure of a file is shown in TFile::TFile.; 45 The structure of a directory is shown in TDirectoryFile::TDirectoryFile.; 46 The TKey class is used by the TBasket class.; 47 See also TTree.; 48*/; 49 ; 50#include <atomic>; 51#include <iostream>; 52 ; 53#include ""TROOT.h""; 54#include ""TClass.h""; 55#include ""TDirectoryFile.h""; 56#include ""TFile.h""; 57#include ""TKey.h""; 58#include ""TBufferFile.h""; 59#include ""TFree.h""; 60#include ""TBrowser.h""; 61#include ""Bytes.",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
Security,integrity,integrity,"; 10 *************************************************************************/; 11 ; 12/**; 13\class TKey; 14\ingroup IO; 15 ; 16 Book space in a file, create I/O buffers, to fill them, (un)compress them.; 17 ; 18 The TKey class includes functions to book space in a file, to create I/O; 19 buffers, to fill these buffers, to compress/uncompress data buffers.; 20 Before saving (making persistent) an object in a file, a key must; 21 be created. The key structure contains all the information to; 22 uniquely identify a persistent object in a file.; 23 | Data Member | Explanation |; 24 |-------------|-------------|; 25 | fNbytes | Number of bytes for the compressed object and key. |; 26 | fObjlen | Length of uncompressed object. |; 27 | fDatime | Date/Time when the object was written. |; 28 | fKeylen | Number of bytes for the key structure. |; 29 | fCycle | Cycle number of the object. |; 30 | fSeekKey | Address of the object on file (points to fNbytes). This is a redundant information used to cross-check the data base integrity. |; 31 | fSeekPdir | Pointer to the directory supporting this object.|; 32 | fClassName | Object class name. |; 33 | fName | Name of the object. |; 34 | fTitle | Title of the object. |; 35 ; 36 In the 16 highest bits of fSeekPdir is encoded a pid offset. This; 37 offset is to be added to the pid index stored in the TRef object; 38 and the referenced TObject.; 39 ; 40 The TKey class is used by ROOT to:; 41 - Write an object in the current directory; 42 - Write a new ntuple buffer; 43 ; 44 The structure of a file is shown in TFile::TFile.; 45 The structure of a directory is shown in TDirectoryFile::TDirectoryFile.; 46 The TKey class is used by the TBasket class.; 47 See also TTree.; 48*/; 49 ; 50#include <atomic>; 51#include <iostream>; 52 ; 53#include ""TROOT.h""; 54#include ""TClass.h""; 55#include ""TDirectoryFile.h""; 56#include ""TFile.h""; 57#include ""TKey.h""; 58#include ""TBufferFile.h""; 59#include ""TFree.h""; 60#include ""TBrowser.h""; 61#include ""Bytes.",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
Testability,test,test,"rRef->SetBufferOffset(0);; 373 Streamer(*fBufferRef); //write key itself again; 374 memcpy(fBuffer,fBufferRef->Buffer(),fKeylen);; 375 delete fBufferRef; fBufferRef = 0;; 376 } else {; 377 fBuffer = fBufferRef->Buffer();; 378 Create(fObjlen);; 379 fBufferRef->SetBufferOffset(0);; 380 Streamer(*fBufferRef); //write key itself again; 381 }; 382}; 383 ; 384////////////////////////////////////////////////////////////////////////////////; 385/// Method used in all TKey constructor to initialize basic data fields.; 386///; 387/// The member filepos is used to calculate correct version number of key; 388/// if filepos==-1, end of file position is used.; 389 ; 390void TKey::Build(TDirectory* motherDir, const char* classname, Long64_t filepos); 391{; 392 fMotherDir = motherDir;; 393 ; 394 fPidOffset = 0;; 395 fNbytes = 0;; 396 fBuffer = 0;; 397 fKeylen = 0;; 398 fObjlen = 0;; 399 fBufferRef = 0;; 400 fCycle = 0;; 401 fSeekPdir = 0;; 402 fSeekKey = 0;; 403 fLeft = 0;; 404 ; 405 fClassName = classname;; 406 //the following test required for forward and backward compatibility; 407 if (fClassName == ""TDirectoryFile"") SetBit(kIsDirectoryFile);; 408 ; 409 fVersion = TKey::Class_Version();; 410 ; 411 if ((filepos==-1) && GetFile()) filepos = GetFile()->GetEND();; 412 if (filepos > TFile::kStartBigFile) fVersion += 1000;; 413 ; 414 if (fTitle.Length() > kTitleMax) fTitle.Resize(kTitleMax);; 415 ; 416 if (GetFile() && GetFile()->TestBit(TFile::kReproducible)); 417 SetBit(TKey::kReproducible);; 418}; 419 ; 420////////////////////////////////////////////////////////////////////////////////; 421/// Read object from disk and call its Browse() method.; 422///; 423/// If object with same name already exist in memory delete it (like; 424/// TDirectoryFile::Get() is doing), except when the key references a; 425/// folder in which case we don't want to re-read the folder object; 426/// since it might contain new objects not yet saved.; 427 ; 428void TKey::Browse(TBrowser *b); 429{; 430 if (fMo",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
Usability,simpl,simplified,"19 ; 720////////////////////////////////////////////////////////////////////////////////; 721/// To read a TObject* from the file.; 722///; 723/// The object associated to this key is read from the file into memory; 724/// Once the key structure is read (via Streamer) the class identifier; 725/// of the object is known.; 726/// Using the class identifier we find the TClass object for this class.; 727/// A TClass object contains a full description (i.e. dictionary) of the; 728/// associated class. In particular the TClass object can create a new; 729/// object of the class type it describes. This new object now calls its; 730/// Streamer function to rebuilt itself.; 731///; 732/// Use TKey::ReadObjectAny to read any object non-derived from TObject; 733///; 734/// ### Note; 735/// A C style cast can only be used in the case where the final class; 736/// of this object derives from TObject as a first inheritance, otherwise; 737/// one must use a dynamic_cast.; 738///; 739/// #### Example1: simplified case; 740/// ~~~{.cpp}; 741/// class MyClass : public TObject, public AnotherClass; 742/// ~~~; 743/// then on return, one get away with using:; 744/// ~~~{.cpp}; 745/// MyClass *obj = (MyClass*)key->ReadObj();; 746/// ~~~; 747///; 748/// #### Example2: Usual case (recommended unless performance is critical); 749/// ~~~{.cpp}; 750/// MyClass *obj = dynamic_cast<MyClass*>(key->ReadObj());; 751/// ~~~; 752/// which support also the more complex inheritance like:; 753/// ~~~{.cpp}; 754/// class MyClass : public AnotherClass, public TObject; 755/// ~~~; 756///; 757/// Of course, `dynamic_cast<>` can also be used in the example 1.; 758 ; 759TObject *TKey::ReadObj(); 760{; 761 TClass *cl = TClass::GetClass(fClassName.Data());; 762 if (!cl) {; 763 Error(""ReadObj"", ""Unknown class %s"", fClassName.Data());; 764 return 0;; 765 }; 766 if (!cl->IsTObject()) {; 767 // in principle user should call TKey::ReadObjectAny!; 768 return (TObject*)ReadObjectAny(0);; 769 }; 770 ; 771 TBufferFile ",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
Testability,log,logical,"{return fSeekKey;}; 90 virtual Long64_t GetSeekPdir() const {return fSeekPdir;}; 91 virtual void IncrementPidOffset(UShort_t offset);; 92 Bool_t IsFolder() const override;; 93 virtual void Keep();; 94 virtual void ls(Bool_t current) const;; 95 void ls(Option_t *option="""") const override;; 96 void Print(Option_t *option="""") const override;; 97 virtual Int_t Read(TObject *obj);; 98 virtual TObject *ReadObj();; 99 virtual TObject *ReadObjWithBuffer(char *bufferRead);; 100 /// To read an object (non deriving from TObject) from the file.; 101 /// This is more user friendly version of TKey::ReadObjectAny.; 102 /// See TKey::ReadObjectAny for more details.; 103 template <typename T> T *ReadObject() {; 104 return reinterpret_cast<T*>(ReadObjectAny(TClass::GetClass<T>()));; 105 }; 106 virtual void *ReadObjectAny(const TClass *expectedClass);; 107 virtual void ReadBuffer(char *&buffer);; 108 void ReadKeyBuffer(char *&buffer);; 109 virtual Bool_t ReadFile();; 110 virtual void SetBuffer() { DeleteBuffer(); fBuffer = new char[fNbytes];}; 111 virtual void SetParent(const TObject *parent);; 112 void SetMotherDir(TDirectory* dir) { fMotherDir = dir; }; 113 Int_t Sizeof() const override;; 114 virtual Int_t WriteFile(Int_t cycle = 1, TFile* f = nullptr);; 115 ; 116 ClassDefOverride(TKey,4); //Header description of a logical record on file.; 117};; 118 ; 119#endif; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; Bool_tbool Bool_tDefinition RtypesCore.h:63; UShort_tunsigned short UShort_tDefinition RtypesCore.h:40; Int_tint Int_tDefinition RtypesCore.h:45; Short_tshort Short_tDefinition RtypesCore.h:39; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Option_tconst char Option_tDefinition RtypesCore.h:66; BIT#define BIT(n)Definition Rtypes.h:90; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TBuffer.h; TClass.h; TDatime.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; offsetOption_t Option_t TPoi",MatchSource.WIKI,doc/master/TKey_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8h_source.html
Availability,avail,available,"ed with the commands in the following; 164table:; 165 ; 166Begin_Macro; 167mathsymbols.C; 168End_Macro; 169 ; 170 ; 171\anchor L6; 172## Delimiters; 173TLatex provides 4 kinds of proportional delimiters:; 174 ; 175 #[]{....} or ""a la"" Latex #left[.....#right] : big square brackets; 176 #{}{....} or #left{.....#right} : big curly brackets; 177 #||{....} or #left|.....#right| : big absolute value symbols; 178 #(){....} or #left(.....#right) : big parentheses; 179 ; 180\anchor L7; 181## Greek Letters; 182The command to produce a lowercase Greek letter is obtained by adding a; 183`#` to the name of the letter. For an uppercase Greek letter, just; 184capitalize the first letter of the command name. Some letters have two; 185representations. The name of the second one (the ""variation"") starts with ""var"".; 186The following table gives the complete list:; 187 ; 188Begin_Macro; 189greekletters.C; 190End_Macro; 191 ; 192 ; 193\anchor L8; 194## Accents; 195Several kind of accents are available:; 196 ; 197Begin_Macro; 198{; 199 TCanvas *cl = new TCanvas(""cl"",""cl"",10,10,700,300);; 200 TLatex Tl; Tl.SetTextFont(43); Tl.SetTextSize(20);; 201 Tl.DrawText(.1, .10, ""#hat : ""); Tl.DrawLatex(.3, .10, "" #hat{a} "");; 202 Tl.DrawText(.1, .23, ""#check : ""); Tl.DrawLatex(.3, .23, "" #check{a} "");; 203 Tl.DrawText(.1, .36, ""#acute : ""); Tl.DrawLatex(.3, .36, "" #acute{a} "");; 204 Tl.DrawText(.1, .50, ""#grave : ""); Tl.DrawLatex(.3, .50, "" #grave{a} "");; 205 Tl.DrawText(.1, .63, ""#dot : ""); Tl.DrawLatex(.3, .63, "" #dot{a} "");; 206 Tl.DrawText(.1, .76, ""#ddot : ""); Tl.DrawLatex(.3, .76, "" #ddot{a} "");; 207 Tl.DrawText(.1, .90, ""#tilde : ""); Tl.DrawLatex(.3, .90, "" #tilde{a} "");; 208}; 209End_Macro; 210 ; 211 ; 212The special sign: `#slash` draws a slash on top of the text between brackets:; 213 ; 214Begin_Macro; 215{; 216 TCanvas *cl = new TCanvas(""cl"",""cl"",10,10,700,100);; 217 TLatex Tl; Tl.SetTextFont(43); Tl.SetTextSize(20);; 218 Tl.DrawText(.1, .5, ""#slash{E}_{T} :""); Tl.DrawLatex(.5, .5, ""#sl",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
Energy Efficiency,power,power,,MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
Integrability,message,message,"sizeDouble_t GetXsize()Get X size.Definition TMathText.cxx:498; TMathText::PaintMathTextvirtual void PaintMathText(Double_t x, Double_t y, Double_t angle, Double_t size, const char *text)Paint text (used by Paint()).Definition TMathText.cxx:577; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ReplaceSpecialCppCharsTString & ReplaceSpecialCppChars()Find special characters which are typically used in printf() calls and replace them by appropriate es...Definition TString.cxx:1114; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TTextBase class for several text objects.Definition TText.h:22; TText::fYDouble_t fYY position of text (left,center,etc..)Definition TText.h:26; TText::Copyvoid Copy(TObjec",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
Modifiability,inherit,inherits,"thText.cxx:519; TMathText::GetBoundingBoxvoid GetBoundingBox(UInt_t &w, UInt_t &h, Bool_t angle=kFALSE) overrideGet the text width and height.Definition TMathText.cxx:477; TMathText::GetXsizeDouble_t GetXsize()Get X size.Definition TMathText.cxx:498; TMathText::PaintMathTextvirtual void PaintMathText(Double_t x, Double_t y, Double_t angle, Double_t size, const char *text)Paint text (used by Paint()).Definition TMathText.cxx:577; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ReplaceSpecialCppCharsTString & ReplaceSpecialCppChars()Find special characters which are typically used in printf() calls and replace them by appropriate es...Definition TString.cxx:1114; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
Safety,detect,detect,"_t buf[3];; 697 strncpy(buf,&text[i],2);; 698 if (strncmp(buf,""^{"",2)==0) {; 699 if (opPower==-1 && nBrackets==0 && nCroch==0) opPower=i;; 700 if (i>3) {; 701 Char_t buf1[5];; 702 strncpy(buf1,&text[i-4],4);; 703 if (strncmp(buf1,""#int"",4)==0) {; 704 abovePlace = 1;; 705 if (i>4 && opCloseCurly==-2) opCloseCurly=i-5;; 706 }; 707 if (strncmp(buf1,""#sum"",4)==0) {; 708 abovePlace = 2;; 709 if (i>4 && opCloseCurly==-2) opCloseCurly=i-5;; 710 }; 711 }; 712 }; 713 if (strncmp(buf,""_{"",2)==0) {; 714 if (opUnder==-1 && nBrackets==0 && nCroch==0) opUnder=i;; 715 if (i>3) {; 716 Char_t buf2[5];; 717 strncpy(buf2,&text[i-4],4);; 718 if (strncmp(buf2,""#int"",4)==0) {; 719 abovePlace = 1;; 720 if (i>4 && opCloseCurly==-2) opCloseCurly=i-5;; 721 }; 722 if (strncmp(buf2,""#sum"",4)==0) {; 723 abovePlace = 2;; 724 if (i>4 && opCloseCurly==-2) opCloseCurly=i-5;; 725 }; 726 }; 727 }; 728 if (strncmp(buf,""]{"",2)==0); 729 if (opSquareCurly==-1 && nBrackets==0 && nCroch==0) opSquareCurly=i;; 730 }; 731 // detect other operators; 732 if (text[i]=='\\' || (text[i]=='#' && !opFound && nBrackets==0 && nCroch==0)) {; 733 ; 734 if (length>i+10) {; 735 Char_t buf[11];; 736 strncpy(buf,&text[i+1],10);; 737 if (strncmp(buf,""splitline{"",10)==0) {; 738 opSplitLine=i; opFound = kTRUE;; 739 if (i>0 && opCloseCurly==-2) opCloseCurly=i-1;; 740 continue;; 741 }; 742 }; 743 if (length>i+9) {; 744 Char_t buf[10];; 745 strncpy(buf,&text[i+1],9);; 746 if (!opBackslash && strncmp(buf,""backslash"",9)==0) {; 747 opBackslash=1; opFound = kTRUE;; 748 if (i>0 && opCloseCurly==-2) opCloseCurly=i-1;; 749 continue;; 750 }; 751 }; 752 if (length>i+8) {; 753 Char_t buf[9];; 754 strncpy(buf,&text[i+1],8);; 755 if (!opParallel && strncmp(buf,""parallel"",8)==0) {; 756 opParallel=1; opFound = kTRUE;; 757 if (i>0 && opCloseCurly==-2) opCloseCurly=i-1;; 758 continue;; 759 }; 760 }; 761 if (length>i+6) {; 762 Char_t buf[7];; 763 strncpy(buf,&text[i+1],6);; 764 if (strncmp(buf,""lower["",6)==0 || strncmp(buf,""lower{"",6)==0) {; 765 o",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
Testability,log,logarithm,"tual void SetNDC(Bool_t isNDC=kTRUE)Set NDC mode on if isNDC = kTRUE, off otherwise.Definition TText.cxx:823; TText::GetControlBoxvirtual void GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t cBoxX[4], Int_t cBoxY[4])Return the text control box.Definition TText.cxx:424; TVirtualPSTVirtualPS is an abstract interface to Postscript, PDF, SVG.Definition TVirtualPS.h:30; TVirtualPS::Textvirtual void Text(Double_t x, Double_t y, const char *string)=0; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TLatex::TextSpec_tTLatex helper struct holding the attributes of a piece of text.Definition TLatex.h:24; TLatex::TextSpec_t::fFontInt_t fFontDefinition TLatex.h:26; TLatex::TextSpec_t::fSizeDouble_t fSizeDefinition TLatex.h:25; TLatex::TextSpec_t::fAngleDouble_t fAngleDefinition TLatex.h:25; TLatex::TextSpec_t::fColorInt_t fColorDefinition TLatex.h:26; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4. graf2dgrafsrcTLatex.cxx. ROOT master - Referenc",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
Usability,clear,clear,"neC);; 2314 fTabSize.clear();; 2315 fX = xsave;; 2316 fY = ysave;; 2317 if (fError) return 0;; 2318 return 1;; 2319}; 2320 ; 2321////////////////////////////////////////////////////////////////////////////////; 2322/// Check if the Latex syntax is correct; 2323 ; 2324Int_t TLatex::CheckLatexSyntax(TString &text); 2325{; 2326 const Char_t *kWord1[] = {""{}^{"",""{}_{"",""^{"",""_{"",""#scale{"",""#color{"",""#font{"",""#sqrt{"",""#[]{"",""#{}{"",""#||{"",; 2327 ""#bar{"",""#vec{"",""#dot{"",""#hat{"",""#ddot{"",""#acute{"",""#grave{"",""#check{"",""#tilde{"",""#slash{"",""#bf{"",""#it{"",""#mbox{"",; 2328 ""\\scale{"",""\\color{"",""\\font{"",""\\sqrt{"",""\\[]{"",""\\{}{"",""\\||{"",""#(){"",""\\(){"",; 2329 ""\\bar{"",""\\vec{"",""\\dot{"",""\\hat{"",""\\ddot{"",""\\acute{"",""\\grave{"",""\\check{"",""\\bf{"",""\\it{"",""\\mbox{""}; // check for }; 2330 const Char_t *kWord2[] = {""#scale["",""#color["",""#font["",""#sqrt["",""#kern["",""#lower["",""\\scale["",""\\color["",""\\font["",""\\sqrt["",""\\kern["",""\\lower[""}; // check for ]{ + }; 2331 const Char_t *kWord3[] = {""#frac{"",""\\frac{"",""#splitline{"",""\\splitline{""}; // check for }{ then }; 2332 const Char_t *kLeft1[] = {""#left["",""\\left["",""#left{"",""\\left{"",""#left|"",""\\left|"",""#left("",""\\left(""};; 2333 const Char_t *kLeft2[] = {""#[]{"",""#[]{"",""#{}{"",""#{}{"",""#||{"",""#||{"",""#(){"",""#(){""};; 2334 const Char_t *kRight[] = {""#right]"",""\\right]"",""#right}"",""\\right}"",""#right|"",""\\right|"",""#right)"",""\\right)""};; 2335 const Int_t lkWord1[] = {4,4,2,2,7,7,6,6,4,4,4,5,5,5,5,6,7,7,7,7,7,4,4,6,7,7,6,6,4,4,4,4,4,5,5,5,5,6,7,7,7,4,4,6};; 2336 const Int_t lkWord2[] = {7,7,6,6,6,7,7,7,6,6,6,7} ;; 2337 const Int_t lkWord3[] = {6,6,11,11} ;; 2338 Int_t nkWord1 = 44, nkWord2 = 12, nkWord3 = 4;; 2339 Int_t i,k ;; 2340 Int_t nLeft1 , nRight , nOfLeft, nOfRight;; 2341 Int_t lLeft1 = 6 ;; 2342 Int_t lLeft2 = 4 ;; 2343 Int_t lRight = 7 ;; 2344 nLeft1 = nRight = 8 ;; 2345 nOfLeft = nOfRight = 0 ;; 2346 ; 2347 Char_t buf[11] ; for (i=0;i<11;i++) buf[i]=0;; 2348 Bool_t opFound ;; 2349 Int_t opFrac = 0;; 2350 Int_t length = text.Length() ;; 2351 ; 23",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
Integrability,depend,dependency,". ROOT: graf2d/graf/inc/TLatex.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TLatex.h File Reference. #include ""TText.h""; #include ""TAttLine.h""; #include <vector>. Include dependency graph for TLatex.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  TLatex::TextSpec_t;  TLatex helper struct holding the attributes of a piece of text. More...;  ; class  TLatex;  To draw Mathematical Formula. More...;  ; class  TLatex::TLatexFormSize;  TLatex helper class used to compute the size of a portion of a formula. More...;  . graf2dgrafincTLatex.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:16 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TLatex_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8h.html
Availability,error,error,"LatexFormSize AddOver(TLatexFormSize f); 49 { return TLatexFormSize(f.Width()+fWidth,f.Height()+fOver,fUnder); }; 50 TLatexFormSize AddUnder(TLatexFormSize f); 51 { return TLatexFormSize(f.Width()+fWidth,fOver,f.Height()+fUnder); }; 52 TLatexFormSize AddOver(TLatexFormSize f1, TLatexFormSize f2); 53 { return TLatexFormSize(fWidth+TMath::Max(f1.Width(),f2.Width()),fOver+f1.Over(),fUnder+f2.Under()); }; 54 ; 55 // return members; 56 inline Double_t Width() const { return fWidth; }; 57 inline Double_t Over() const { return fOver; }; 58 inline Double_t Under() const { return fUnder; }; 59 inline Double_t Height() const { return fOver+fUnder; }; 60 };; 61 ; 62 Double_t fFactorSize; ///<! Relative size of subscripts and superscripts; 63 Double_t fFactorPos; ///<! Relative position of subscripts and superscripts; 64 Int_t fLimitFactorSize; ///< lower bound for subscripts/superscripts size; 65 const Char_t *fError{nullptr}; ///<! error code; 66 Bool_t fShow; ///<! is true during the second pass (Painting); 67 std::vector<TLatexFormSize> fTabSize; ///<! array of values for the different zones; 68 Double_t fOriginSize; ///< Font size of the starting font; 69 Bool_t fItalic; ///<! Currently inside italic operator; 70 ; 71 TLatex& operator=(const TLatex&);; 72 ; 73 //Text analysis and painting; 74 TLatexFormSize Analyse(Double_t x, Double_t y, const TextSpec_t &spec, const Char_t *t,Int_t length);; 75 TLatexFormSize Anal1(const TextSpec_t &spec, const Char_t *t,Int_t length);; 76 ; 77 void DrawPolyLine(Int_t npoints, Double_t *xx, Double_t *yy, const TextSpec_t &spec, Double_t scale_width = 0.);; 78 void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2, const TextSpec_t &spec);; 79 void DrawCircle(Double_t x1, Double_t y1, Double_t r, const TextSpec_t &spec);; 80 void DrawParenthesis(Double_t x1, Double_t y1, Double_t r1, Double_t r2, Double_t phimin, Double_t phimax, const TextSpec_t &spec);; 81 ; 82 TLatexFormSize FirstParse(Double_t angle, Double_t size, const Cha",MatchSource.WIKI,doc/master/TLatex_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8h_source.html
Availability,error,error,".; 156 ; 157void TLeaf::Browse(TBrowser* b); 158{; 159 if (strchr(GetName(), '.')) {; 160 fBranch->GetTree()->Draw(GetName(), """", b ? b->GetDrawOption() : """");; 161 } else {; 162 if ((fBranch->GetListOfLeaves()->GetEntries() > 1) ||; 163 (strcmp(fBranch->GetName(), GetName()) != 0)) {; 164 TString name(fBranch->GetName());; 165 if (!name.EndsWith(""."")) name += ""."";; 166 name += GetName();; 167 fBranch->GetTree()->Draw(name, """", b ? b->GetDrawOption() : """");; 168 } else {; 169 fBranch->GetTree()->Draw(GetName(), """", b ? b->GetDrawOption() : """");; 170 }; 171 }; 172 if (gPad) {; 173 gPad->Update();; 174 }; 175}; 176 ; 177////////////////////////////////////////////////////////////////////////////////; 178/// Pack leaf elements in Basket output buffer.; 179 ; 180void TLeaf::FillBasket(TBuffer &); 181{; 182}; 183 ; 184////////////////////////////////////////////////////////////////////////////////; 185/// If the class supports it, generate an offset array base.; 186///; 187/// This class only returns `nullptr` on error.; 188Int_t *TLeaf::GenerateOffsetArrayBase(Int_t base, Int_t events) const; 189{; 190 // In order to avoid a virtual call, we assume ROOT developers will override; 191 // the default GenerateOffsetArray for cases where this function does not apply.; 192 ; 193 Int_t *retval = new Int_t[events];; 194 if (R__unlikely(!retval || !fLeafCount)) {; 195 delete [] retval;; 196 return nullptr;; 197 }; 198 ; 199 Long64_t orig_entry = std::max(fBranch->GetReadEntry(), 0LL); // -1 indicates to start at the beginning; 200 const std::vector<Int_t> *countValues = fLeafCount->GetLeafCountValues(orig_entry, events);; 201 ; 202 if (!countValues || ((Int_t)countValues->size()) < events) {; 203 Error(""GenerateOffsetArrayBase"", ""The leaf %s could not retrieve enough entries from its branch count (%s), ask for %d and got %ld"",; 204 GetName(), fLeafCount->GetName(), events, (long)(countValues ? countValues->size() : -1));; 205 delete [] retval;; 206 return nullptr;; 207 }; 208 ; ",MatchSource.WIKI,doc/master/TLeaf_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8cxx_source.html
Integrability,rout,routine,"adEntry();; 392 for (Long64_t idx = 0; idx < len; ++idx) {; 393 branch->GetEntry(start + idx);; 394 auto size = static_cast<Int_t>(GetValue());; 395 fLeafCountValues->fValues.push_back( size );; 396 }; 397 branch->GetEntry(orig_leaf_entry);; 398 return &(fLeafCountValues->fValues);; 399}; 400 ; 401////////////////////////////////////////////////////////////////////////////////; 402/// Return the number of effective elements of this leaf, for the current entry.; 403 ; 404Int_t TLeaf::GetLen() const; 405{; 406 if (fLeafCount) {; 407 // -- We are a varying length array.; 408 Int_t len = Int_t(fLeafCount->GetValue());; 409 if (len > fLeafCount->GetMaximum()) {; 410 Error(""GetLen"", ""Leaf counter is greater than maximum! leaf: '%s' len: %d max: %d"", GetName(), len, fLeafCount->GetMaximum());; 411 len = fLeafCount->GetMaximum();; 412 }; 413 return len * fLen;; 414 } else {; 415 // -- We are a fixed size thing.; 416 return fLen;; 417 }; 418}; 419 ; 420////////////////////////////////////////////////////////////////////////////////; 421/// Helper routine for TLeafX::SetAddress.; 422///; 423/// The return value is non-zero if we owned the old; 424/// value buffer and must delete it now. The size; 425/// of the value buffer is recalculated and stored,; 426/// and a decision is made whether or not we own the; 427/// new value buffer.; 428 ; 429Int_t TLeaf::ResetAddress(void* addr, bool calledFromDestructor); 430{; 431 // The kNewValue bit records whether or not we own; 432 // the current value buffer or not. If we own it,; 433 // then we are responsible for deleting it.; 434 bool deleteValue = false;; 435 if (TestBit(kNewValue)) {; 436 deleteValue = true;; 437 }; 438 // If we are not being called from a destructor,; 439 // recalculate the value buffer size and decide; 440 // whether or not we own the new value buffer.; 441 if (!calledFromDestructor) {; 442 // -- Recalculate value buffer size and decide ownership of value.; 443 if (fLeafCount) {; 444 // -- Varying length array da",MatchSource.WIKI,doc/master/TLeaf_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8cxx_source.html
Modifiability,variab,variable,"t_t * GenerateOffsetArrayBase(Int_t base, Int_t events) constIf the class supports it, generate an offset array base.Definition TLeaf.cxx:188; TLeaf::SetAddressvirtual void SetAddress(void *add=nullptr)Definition TLeaf.h:185; TLeaf::Browsevoid Browse(TBrowser *b) overrideBrowse the content of this leaf.Definition TLeaf.cxx:157; TLeaf::FillBasketvirtual void FillBasket(TBuffer &b)Pack leaf elements in Basket output buffer.Definition TLeaf.cxx:180; TLeaf::TLeafTLeaf()Definition TLeaf.cxx:55; TLeaf::GetBranchTBranch * GetBranch() constDefinition TLeaf.h:116; TLeaf::fOffsetInt_t fOffsetOffset in ClonesArray object (if one)Definition TLeaf.h:74; TLeaf::GetOffsetHeaderSizevirtual Int_t GetOffsetHeaderSize() constDefinition TLeaf.h:61; TLeaf::fBranchTBranch * fBranch! Pointer to supporting branch (we do not own the branch)Definition TLeaf.h:78; TLeaf::fIsUnsignedbool fIsUnsigned(=true if unsigned, false otherwise)Definition TLeaf.h:76; TLeaf::fLeafCountTLeaf * fLeafCountPointer to Leaf count if variable length (we do not own the counter)Definition TLeaf.h:77; TLeaf::kNewValue@ kNewValueSet if we own the value buffer and so must delete it ourselves.Definition TLeaf.h:96; TLeaf::SetLeafCountvirtual void SetLeafCount(TLeaf *leaf)Set the leaf count of this leaf.Definition TLeaf.cxx:465; TLeaf::GetFullNamevirtual TString GetFullName() constReturn the full name (including the parent's branch names) of the leaf.Definition TLeaf.cxx:224; TLeaf::fLeafCountValuesLeafCountValues * fLeafCountValues! Cache of collection/array sizesDefinition TLeaf.h:79; TLeaf::SetRangevirtual void SetRange(bool range=true)Definition TLeaf.h:165; TLeaf::Counts_tstd::vector< Int_t > Counts_tDefinition TLeaf.h:65; TLeaf::Classstatic TClass * Class(); TLeaf::IsRangevirtual bool IsRange() constDefinition TLeaf.h:149; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TN",MatchSource.WIKI,doc/master/TLeaf_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8cxx_source.html
Safety,avoid,avoid," """");; 161 } else {; 162 if ((fBranch->GetListOfLeaves()->GetEntries() > 1) ||; 163 (strcmp(fBranch->GetName(), GetName()) != 0)) {; 164 TString name(fBranch->GetName());; 165 if (!name.EndsWith(""."")) name += ""."";; 166 name += GetName();; 167 fBranch->GetTree()->Draw(name, """", b ? b->GetDrawOption() : """");; 168 } else {; 169 fBranch->GetTree()->Draw(GetName(), """", b ? b->GetDrawOption() : """");; 170 }; 171 }; 172 if (gPad) {; 173 gPad->Update();; 174 }; 175}; 176 ; 177////////////////////////////////////////////////////////////////////////////////; 178/// Pack leaf elements in Basket output buffer.; 179 ; 180void TLeaf::FillBasket(TBuffer &); 181{; 182}; 183 ; 184////////////////////////////////////////////////////////////////////////////////; 185/// If the class supports it, generate an offset array base.; 186///; 187/// This class only returns `nullptr` on error.; 188Int_t *TLeaf::GenerateOffsetArrayBase(Int_t base, Int_t events) const; 189{; 190 // In order to avoid a virtual call, we assume ROOT developers will override; 191 // the default GenerateOffsetArray for cases where this function does not apply.; 192 ; 193 Int_t *retval = new Int_t[events];; 194 if (R__unlikely(!retval || !fLeafCount)) {; 195 delete [] retval;; 196 return nullptr;; 197 }; 198 ; 199 Long64_t orig_entry = std::max(fBranch->GetReadEntry(), 0LL); // -1 indicates to start at the beginning; 200 const std::vector<Int_t> *countValues = fLeafCount->GetLeafCountValues(orig_entry, events);; 201 ; 202 if (!countValues || ((Int_t)countValues->size()) < events) {; 203 Error(""GenerateOffsetArrayBase"", ""The leaf %s could not retrieve enough entries from its branch count (%s), ask for %d and got %ld"",; 204 GetName(), fLeafCount->GetName(), events, (long)(countValues ? countValues->size() : -1));; 205 delete [] retval;; 206 return nullptr;; 207 }; 208 ; 209 Int_t header = GetOffsetHeaderSize();; 210 Int_t len = 0;; 211 for (Int_t idx = 0, offset = base; idx < events; idx++) {; 212 retval[idx] = offset;; 2",MatchSource.WIKI,doc/master/TLeaf_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8cxx_source.html
Usability,clear,clear,"360/// If this branch is a branch count, return the set of collection size for; 361/// the entry range requested; 362/// start: first entry to read and return information about; 363/// len: number of entries to read.; 364const TLeaf::Counts_t *TLeaf::GetLeafCountValues(Long64_t start, Long64_t len); 365{; 366 if (len <= 0 || !IsRange()); 367 return nullptr;; 368 ; 369 if (fLeafCountValues) {; 370 if (fLeafCountValues->fStartEntry == start && len < (Long64_t)fLeafCountValues->fValues.size()); 371 {; 372 return &fLeafCountValues->fValues;; 373 }; 374 if (start >= fLeafCountValues->fStartEntry &&; 375 (start+len) <= (Long64_t)(fLeafCountValues->fStartEntry + fLeafCountValues->fValues.size())); 376 {; 377 auto &values(fLeafCountValues->fValues);; 378 values.erase(values.begin(), values.begin() + start-fLeafCountValues->fStartEntry);; 379 return &values;; 380 }; 381 } else {; 382 fLeafCountValues = new LeafCountValues();; 383 }; 384 ; 385 ; 386 fLeafCountValues->fValues.clear();; 387 fLeafCountValues->fValues.reserve(len);; 388 fLeafCountValues->fStartEntry = start;; 389 ; 390 auto branch = GetBranch();; 391 Long64_t orig_leaf_entry = branch->GetReadEntry();; 392 for (Long64_t idx = 0; idx < len; ++idx) {; 393 branch->GetEntry(start + idx);; 394 auto size = static_cast<Int_t>(GetValue());; 395 fLeafCountValues->fValues.push_back( size );; 396 }; 397 branch->GetEntry(orig_leaf_entry);; 398 return &(fLeafCountValues->fValues);; 399}; 400 ; 401////////////////////////////////////////////////////////////////////////////////; 402/// Return the number of effective elements of this leaf, for the current entry.; 403 ; 404Int_t TLeaf::GetLen() const; 405{; 406 if (fLeafCount) {; 407 // -- We are a varying length array.; 408 Int_t len = Int_t(fLeafCount->GetValue());; 409 if (len > fLeafCount->GetMaximum()) {; 410 Error(""GetLen"", ""Leaf counter is greater than maximum! leaf: '%s' len: %d max: %d"", GetName(), len, fLeafCount->GetMaximum());; 411 len = fLeafCount->GetMaximum();; 412 ",MatchSource.WIKI,doc/master/TLeaf_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8cxx_source.html
Availability,error,error,"af::GetLenStaticvirtual Int_t GetLenStatic() constReturn the fixed length of this leaf.Definition TLeaf.h:132; TLeaf::GetOffsetvirtual Int_t GetOffset() constDefinition TLeaf.h:137; TLeaf::ReadBasketvirtual void ReadBasket(TBuffer &)Definition TLeaf.h:152; TLeaf::fLeafCountValuesLeafCountValues * fLeafCountValues! Cache of collection/array sizesDefinition TLeaf.h:79; TLeaf::GenerateOffsetArrayvirtual Int_t * GenerateOffsetArray(Int_t base, Int_t events)Definition TLeaf.h:115; TLeaf::SetRangevirtual void SetRange(bool range=true)Definition TLeaf.h:165; TLeaf::Counts_tstd::vector< Int_t > Counts_tDefinition TLeaf.h:65; TLeaf::Importvirtual void Import(TClonesArray *, Int_t)Definition TLeaf.h:147; TLeaf::PrintValuevirtual void PrintValue(Int_t i=0) constDefinition TLeaf.h:184; TLeaf::IsRangevirtual bool IsRange() constDefinition TLeaf.h:149; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TStringBasic string class.Definition TString.h:139; double; int; TLeaf::GetValueHelper< Long64_t >::Execstatic Long64_t Exec(const TLeaf *leaf, Int_t i=0)Definition TLeaf.h:173; TLeaf::GetValueHelper< LongDouble_t >::Execstatic LongDouble_t Exec(const TLeaf *leaf, Int_t i=0)Definition TLeaf.h:179; TLeaf::GetValueHelper< ULong64_t >::Execstatic ULong64_t Exec(const TLeaf *leaf, Int_t i=0)Definition TLeaf.h:176; TLeaf::GetValueHelperDefinition TLeaf.h:84; TLeaf::GetValueHelper::Execstatic T Exec(const TLeaf *leaf, Int_t i=0)Definition TLeaf.h:85; TLeaf::LeafCountValuesDefinition TLeaf.h:66; TLeaf::LeafCountValues::fValuesCounts_t fValuesDefinition TLeaf.h:67; TLeaf::LeafCountValues::fStartEntryLong64_t fStartEntry! entry number of corresponding to element 0 of the vector.Definition TLeaf.h:68. treetreeincTLeaf.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:04 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TLeaf_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8h_source.html
Integrability,depend,depending," //; 18// TLeaf //; 19// //; 20// A TTree object is a list of TBranch. //; 21// A TBranch object is a list of TLeaf. In most cases, the TBranch //; 22// will have one TLeaf. //; 23// A TLeaf describes the branch data types and holds the data. //; 24// //; 25// A few notes about the data held by the leaf. It can contain: //; 26// 1 a single object or primitive (e.g., one float), //; 27// 2 a fixed-number of objects (e.g., each entry has two floats). //; 28// The number of elements per entry is saved in `fLen`. //; 29// 3 a dynamic number of primitives. The number of objects in each //; 30// entry is saved in the `fLeafCount` branch. //; 31// //; 32// Note options (2) and (3) can combined - if fLeafCount says an entry //; 33// has 3 elements and fLen is 2, then there will be 6 objects in that //; 34// entry. //; 35// //; 36// Additionally, `fNdata` is transient and generated on read to //; 37// determine the necessary size of a buffer to hold event data; //; 38// depending on the call-site, it may be sized larger than the number //; 39// of elements //; 40// //; 41//////////////////////////////////////////////////////////////////////////; 42 ; 43 ; 44#include ""TNamed.h""; 45 ; 46#include <vector>; 47 ; 48#ifdef R__LESS_INCLUDES; 49class TBranch;; 50#else; 51#include ""TBranch.h""; 52#endif; 53 ; 54class TClonesArray;; 55class TBrowser;; 56 ; 57class TLeaf : public TNamed {; 58 ; 59private:; 60 ; 61 virtual Int_t GetOffsetHeaderSize() const {return 0;}; 62 ; 63protected:; 64 ; 65 using Counts_t = std::vector<Int_t>;; 66 struct LeafCountValues {; 67 Counts_t fValues;; 68 Long64_t fStartEntry{-1}; ///<! entry number of corresponding to element 0 of the vector.; 69 };; 70 ; 71 Int_t fNdata; ///<! Number of elements in fAddress data buffer.; 72 Int_t fLen; ///< Number of fixed length elements in the leaf's data.; 73 Int_t fLenType; ///< Number of bytes for this data type; 74 Int_t fOffset; ///< Offset in ClonesArray object (if one); 75 bool fIsRange; ///< (=true if leaf has a ",MatchSource.WIKI,doc/master/TLeaf_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8h_source.html
Modifiability,variab,variable,"= std::vector<Int_t>;; 66 struct LeafCountValues {; 67 Counts_t fValues;; 68 Long64_t fStartEntry{-1}; ///<! entry number of corresponding to element 0 of the vector.; 69 };; 70 ; 71 Int_t fNdata; ///<! Number of elements in fAddress data buffer.; 72 Int_t fLen; ///< Number of fixed length elements in the leaf's data.; 73 Int_t fLenType; ///< Number of bytes for this data type; 74 Int_t fOffset; ///< Offset in ClonesArray object (if one); 75 bool fIsRange; ///< (=true if leaf has a range, false otherwise). This is equivalent to being a 'leafcount'. For a TLeafElement the range information is actually store in the TBranchElement.; 76 bool fIsUnsigned; ///< (=true if unsigned, false otherwise); 77 TLeaf *fLeafCount; ///< Pointer to Leaf count if variable length (we do not own the counter); 78 TBranch *fBranch; ///<! Pointer to supporting branch (we do not own the branch); 79 LeafCountValues *fLeafCountValues; ///<! Cache of collection/array sizes; 80 ; 81 TLeaf(const TLeaf&);; 82 TLeaf& operator=(const TLeaf&);; 83 ; 84 template <typename T> struct GetValueHelper {; 85 static T Exec(const TLeaf *leaf, Int_t i = 0) { return leaf->GetValue(i); }; 86 };; 87 ; 88 Int_t *GenerateOffsetArrayBase(Int_t base, Int_t events) const; // For leaves containing fixed-size objects (no; 89 // polymorphism!), this will generate an appropriate; 90 // offset array.; 91 ; 92 ; 93public:; 94 enum EStatusBits {; 95 kIndirectAddress = BIT(11), ///< Data member is a pointer to an array of basic types.; 96 kNewValue = BIT(12) ///< Set if we own the value buffer and so must delete it ourselves.; 97 };; 98 ; 99 enum class DeserializeType {; 100 kInvalid = 0, // Invalid deserialization information.; 101 kExternal, // Deserialization of this Leaf requires a separate output buffer, i.e. the on-disk and in-memory representation are likely to be different sizes.; 102 kDestructive = kExternal, // For backward compatibility; 103 kInPlace, // Deserialization can be done directly in the input buffer.; 104",MatchSource.WIKI,doc/master/TLeaf_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8h_source.html
Modifiability,inherit,inherits,"15#include ""TVirtualPad.h""; 16#include ""TROOT.h""; 17#include <iostream>; 18 ; 19ClassImp(TLegendEntry);; 20 ; 21/** \class TLegendEntry; 22\ingroup BasicGraphics; 23 ; 24Storage class for one entry of a TLegend.; 25*/; 26 ; 27////////////////////////////////////////////////////////////////////////////////; 28/// TLegendEntry do-nothing default constructor; 29 ; 30TLegendEntry::TLegendEntry(): TAttText(), TAttLine(), TAttFill(), TAttMarker(); 31{; 32 fObject = nullptr;; 33}; 34 ; 35////////////////////////////////////////////////////////////////////////////////; 36/// TLegendEntry normal constructor for one entry in a TLegend.; 37///; 38/// obj is the object this entry will represent. If obj has; 39/// line/fill/marker attributes, then the TLegendEntry will display; 40/// these attributes.; 41///; 42/// label is the text that will describe the entry, it is displayed using; 43/// TLatex, so may have a complex format.; 44///; 45/// option may have values; 46/// - L draw line associated w/ TAttLine if obj inherits from TAttLine; 47/// - P draw polymarker assoc. w/ TAttMarker if obj inherits from TAttMarker; 48/// - F draw a box with fill associated w/ TAttFill if obj inherits TAttFill; 49/// default is object = ""LPF""; 50 ; 51TLegendEntry::TLegendEntry(const TObject* obj, const char* label, Option_t* option ); 52 :TAttText(0,0,0,0,0), TAttLine(1,1,1), TAttFill(0,0), TAttMarker(1,21,1); 53{; 54 fObject = nullptr;; 55 if ( !label && obj ) fLabel = obj->GetTitle();; 56 else fLabel = label;; 57 fOption = option;; 58 if (obj) SetObject((TObject*)obj);; 59}; 60 ; 61////////////////////////////////////////////////////////////////////////////////; 62/// TLegendEntry copy constructor; 63 ; 64TLegendEntry::TLegendEntry(const TLegendEntry &entry) : TObject(entry), TAttText(entry), TAttLine(entry), TAttFill(entry), TAttMarker(entry); 65{; 66 entry.TLegendEntry::Copy(*this);; 67}; 68 ; 69////////////////////////////////////////////////////////////////////////////////; 70/// TLegendEnt",MatchSource.WIKI,doc/master/TLegendEntry_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegendEntry_8cxx_source.html
Availability,error,error,"H1F(""h1"",""TLegend Example"",200,-10,10);; 60 h1->FillRandom(""gaus"",30000);; 61 h1->SetFillColor(kGreen);; 62 h1->SetFillStyle(3003);; 63 h1->Draw();; 64 ; 65 auto f1=new TF1(""f1"",""1000*TMath::Abs(sin(x)/x)"",-10,10);; 66 f1->SetLineColor(kBlue);; 67 f1->SetLineWidth(4);; 68 f1->Draw(""same"");; 69 ; 70 const Int_t n = 20;; 71 Double_t x[n], y[n], ex[n], ey[n];; 72 for (Int_t i=0;i<n;i++) {; 73 x[i] = i*0.1;; 74 y[i] = 1000*sin(x[i]+0.2);; 75 x[i] = 17.8*x[i]-8.9;; 76 ex[i] = 1.0;; 77 ey[i] = 10.*i;; 78 }; 79 auto gr = new TGraphErrors(n,x,y,ex,ey);; 80 gr->SetName(""gr"");; 81 gr->SetLineColor(kRed);; 82 gr->SetLineWidth(2);; 83 gr->SetMarkerStyle(21);; 84 gr->SetMarkerSize(1.3);; 85 gr->SetMarkerColor(7);; 86 gr->Draw(""P"");; 87 ; 88 auto legend = new TLegend(0.1,0.7,0.48,0.9);; 89 legend->SetHeader(""The Legend Title"",""C""); // option ""C"" allows to center the header; 90 legend->AddEntry(h1,""Histogram filled with random numbers"",""f"");; 91 legend->AddEntry(""f1"",""Function abs(#frac{sin(x)}{x})"",""l"");; 92 legend->AddEntry(""gr"",""Graph with error bars"",""lep"");; 93 legend->Draw();; 94}; 95End_Macro; 96 ; 97 ; 98`TLegend` inherits from `TAttText` therefore changing any; 99text attributes (text alignment, font, color...) on a legend will changed the; 100text attributes on each line.; 101 ; 102In particular it can be interesting to change the text alignement that way. In; 103order to have a base-line vertical alignment instead of a centered one simply do:; 104~~~ {.cpp}; 105 legend->SetTextAlign(13);; 106~~~; 107or; 108~~~ {.cpp}; 109 legend->SetTextAlign(11);; 110~~~; 111The default value of some `TLegend` attributes can be changed using; 112`gStyle`. The default settings are:; 113~~~ {.cpp}; 114 SetLegendBorderSize(1);; 115 SetLegendFillColor(0);; 116 SetLegendFont(42);; 117 SetLegendTextSize(0.);; 118~~~; 119The global attributes change the default values for the next created legends.; 120 ; 121Text attributes can be also changed individually on each legend entry:; 122~~~ {.cpp};",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
Energy Efficiency,allocate,allocated,"ryTLegendEntry * AddEntry(const TObject *obj, const char *label="""", Option_t *option=""lpf"")Add a new entry to this legend.Definition TLegend.cxx:320; TLegend::SetNColumnsvoid SetNColumns(Int_t nColumns)Set the number of columns for the legend.Definition TLegend.cxx:606; TLegend::Drawvoid Draw(Option_t *option="""") overrideDraw this legend with its current attributes.Definition TLegend.cxx:425; TLegend::SetHeadervirtual void SetHeader(const char *header="""", Option_t *option="""")Sets the header, which is the ""title"" that appears at the top of the legend.Definition TLegend.cxx:1085; TLegend::DeleteEntryvirtual void DeleteEntry()Delete entry at the mouse position.Definition TLegend.cxx:413; TLegend::GetEntryTLegendEntry * GetEntry() constGet entry pointed to by the mouse.Definition TLegend.cxx:478; TLegend::Clearvoid Clear(Option_t *option="""") overrideClear all entries in this legend, including the header.Definition TLegend.cxx:379; TLegend::fEntrySeparationFloat_t fEntrySeparationSeparation between entries, as a fraction of The space allocated to one entry.Definition TLegend.h:74; TLegend::EditEntryAttMarkervirtual void EditEntryAttMarker()Edit the marker attributes for the entry pointed by the mouse.Definition TLegend.cxx:455; TLegend::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave this legend as C++ statements on output stream out to be used with the SaveAs ....Definition TLegend.cxx:1035; TLegend::EditEntryAttTextvirtual void EditEntryAttText()Edit the text attributes for the entry pointed by the mouse.Definition TLegend.cxx:466; TLegend::Paintvoid Paint(Option_t *option="""") overridePaint this legend with its current attributes.Definition TLegend.cxx:561; TLegend::GetNColumnsInt_t GetNColumns() constDefinition TLegend.h:52; TLegend::SetDefaultsvoid SetDefaults()Definition TLegend.h:61; TLegend::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideReset the legend entries pointing to ""obj"".Definition TLegend.cxx:1022; TLegend:",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
Integrability,depend,depending," ""centered"" is treated in a special way; 778 // to ensure a better spacing between lines.; 779 if (valign == 2) {; 780 Float_t tsizepad = textsize;; 781 if (tfont%10 == 3) tsizepad = (gPad->AbsPixeltoY(0) - gPad->AbsPixeltoY(textsize))/(gPad->GetY2() - gPad->GetY1());; 782 if (yspace2 < tsizepad) {; 783 entry->SetTextAlign(10*halign+1);; 784 y = ytext - (1. - fEntrySeparation)* yspace2/2.;; 785 } else {; 786 y = ytext;; 787 }; 788 }; 789 ; 790 TLatex entrytex( x, y, entry->GetLabel() );; 791 entrytex.SetNDC();; 792 entry->TAttText::Copy(entrytex);; 793 entrytex.Paint();; 794 ; 795 // reset attributes back to their original values; 796 entry->SetTextAlign(talign);; 797 entry->SetTextAngle(tangle);; 798 entry->SetTextColor(tcolor);; 799 entry->SetTextFont(tfont);; 800 entry->SetTextSize(tsize);; 801 ; 802 // define x,y as the center of the symbol for this entry; 803 Double_t xsym = x1 + margin/2.;; 804 Double_t ysym = ytext;; 805 ; 806 TObject *eobj = entry->GetObject();; 807 ; 808 // depending on the object drawing option, the endcaps for error; 809 // bar are drawn differently.; 810 Int_t endcaps = 0; // no endcaps.; 811 if (eobj) { // eobj == nullptr for the legend header; 812 TString eobjopt = eobj->GetDrawOption();; 813 eobjopt.ToLower();; 814 if (eobjopt.Contains(""e1"") && eobj->InheritsFrom(TH1::Class())) endcaps = 1; // a bar; 815 if (eobj->InheritsFrom(TGraph::Class())) {; 816 endcaps = 1; // a bar, default for TGraph; 817 if (eobjopt.Contains(""z"")) endcaps = 0; // no endcaps.; 818 if (eobjopt.Contains("">"")) endcaps = 2; // empty arrow.; 819 if (eobjopt.Contains(""|>"")) endcaps = 3; // filled arrow.; 820 }; 821 }; 822 float arrow_shift = 0.3;; 823 if (endcaps == 3) arrow_shift = 0.2;; 824 // Draw fill pattern (in a box); 825 ; 826 if ( opt.Contains(""f"")) {; 827 if (eobj && eobj->InheritsFrom(TAttFill::Class())) {; 828 dynamic_cast<TAttFill*>(eobj)->Copy(*entry);; 829 }; 830 ; 831 // Case of exclusion graphs; 832 Float_t wl = 1., wu = 1.;; 833 if (eobj && eobj->I",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
Modifiability,inherit,inherits,"H1F(""h1"",""TLegend Example"",200,-10,10);; 60 h1->FillRandom(""gaus"",30000);; 61 h1->SetFillColor(kGreen);; 62 h1->SetFillStyle(3003);; 63 h1->Draw();; 64 ; 65 auto f1=new TF1(""f1"",""1000*TMath::Abs(sin(x)/x)"",-10,10);; 66 f1->SetLineColor(kBlue);; 67 f1->SetLineWidth(4);; 68 f1->Draw(""same"");; 69 ; 70 const Int_t n = 20;; 71 Double_t x[n], y[n], ex[n], ey[n];; 72 for (Int_t i=0;i<n;i++) {; 73 x[i] = i*0.1;; 74 y[i] = 1000*sin(x[i]+0.2);; 75 x[i] = 17.8*x[i]-8.9;; 76 ex[i] = 1.0;; 77 ey[i] = 10.*i;; 78 }; 79 auto gr = new TGraphErrors(n,x,y,ex,ey);; 80 gr->SetName(""gr"");; 81 gr->SetLineColor(kRed);; 82 gr->SetLineWidth(2);; 83 gr->SetMarkerStyle(21);; 84 gr->SetMarkerSize(1.3);; 85 gr->SetMarkerColor(7);; 86 gr->Draw(""P"");; 87 ; 88 auto legend = new TLegend(0.1,0.7,0.48,0.9);; 89 legend->SetHeader(""The Legend Title"",""C""); // option ""C"" allows to center the header; 90 legend->AddEntry(h1,""Histogram filled with random numbers"",""f"");; 91 legend->AddEntry(""f1"",""Function abs(#frac{sin(x)}{x})"",""l"");; 92 legend->AddEntry(""gr"",""Graph with error bars"",""lep"");; 93 legend->Draw();; 94}; 95End_Macro; 96 ; 97 ; 98`TLegend` inherits from `TAttText` therefore changing any; 99text attributes (text alignment, font, color...) on a legend will changed the; 100text attributes on each line.; 101 ; 102In particular it can be interesting to change the text alignement that way. In; 103order to have a base-line vertical alignment instead of a centered one simply do:; 104~~~ {.cpp}; 105 legend->SetTextAlign(13);; 106~~~; 107or; 108~~~ {.cpp}; 109 legend->SetTextAlign(11);; 110~~~; 111The default value of some `TLegend` attributes can be changed using; 112`gStyle`. The default settings are:; 113~~~ {.cpp}; 114 SetLegendBorderSize(1);; 115 SetLegendFillColor(0);; 116 SetLegendFont(42);; 117 SetLegendTextSize(0.);; 118~~~; 119The global attributes change the default values for the next created legends.; 120 ; 121Text attributes can be also changed individually on each legend entry:; 122~~~ {.cpp};",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
Performance,perform,performed,"ROOT.h""; 25#include ""TLegendEntry.h""; 26#include ""TMultiGraph.h""; 27#include ""TGraph.h""; 28#include ""TH1.h""; 29#include ""THStack.h""; 30 ; 31ClassImp(TLegend);; 32 ; 33/** \class TLegend; 34\ingroup BasicGraphics; 35 ; 36This class displays a legend box (TPaveText) containing several legend entries.; 37 ; 38Each legend entry is made of a reference to a ROOT object, a text label and an; 39option specifying which graphical attributes (marker/line/fill) should be; 40displayed.; 41 ; 42The following example shows how to create a legend. In this example the legend; 43contains a histogram, a function and a graph. The histogram is put in the legend; 44using its reference pointer whereas the graph and the function are added; 45using their names. Note that, because `TGraph` constructors do not have the; 46`TGraph` name as parameter, the graph name should be specified using the; 47`SetName` method.; 48 ; 49When an object is added by name, a scan is performed on the list of objects; 50contained in the current pad (`gPad`) and also in the possible; 51`TMultiGraph` and `THStack` present in the pad. If a matching; 52name is found, the corresponding object is added in the legend using its pointer.; 53 ; 54Begin_Macro(source); 55{; 56 auto c1 = new TCanvas(""c1"",""c1"",600,500);; 57 gStyle->SetOptStat(0);; 58 ; 59 auto h1 = new TH1F(""h1"",""TLegend Example"",200,-10,10);; 60 h1->FillRandom(""gaus"",30000);; 61 h1->SetFillColor(kGreen);; 62 h1->SetFillStyle(3003);; 63 h1->Draw();; 64 ; 65 auto f1=new TF1(""f1"",""1000*TMath::Abs(sin(x)/x)"",-10,10);; 66 f1->SetLineColor(kBlue);; 67 f1->SetLineWidth(4);; 68 f1->Draw(""same"");; 69 ; 70 const Int_t n = 20;; 71 Double_t x[n], y[n], ex[n], ey[n];; 72 for (Int_t i=0;i<n;i++) {; 73 x[i] = i*0.1;; 74 y[i] = 1000*sin(x[i]+0.2);; 75 x[i] = 17.8*x[i]-8.9;; 76 ex[i] = 1.0;; 77 ey[i] = 10.*i;; 78 }; 79 auto gr = new TGraphErrors(n,x,y,ex,ey);; 80 gr->SetName(""gr"");; 81 gr->SetLineColor(kRed);; 82 gr->SetLineWidth(2);; 83 gr->SetMarkerStyle(21);; 84 gr->SetMark",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
Usability,simpl,simply,"sin(x[i]+0.2);; 75 x[i] = 17.8*x[i]-8.9;; 76 ex[i] = 1.0;; 77 ey[i] = 10.*i;; 78 }; 79 auto gr = new TGraphErrors(n,x,y,ex,ey);; 80 gr->SetName(""gr"");; 81 gr->SetLineColor(kRed);; 82 gr->SetLineWidth(2);; 83 gr->SetMarkerStyle(21);; 84 gr->SetMarkerSize(1.3);; 85 gr->SetMarkerColor(7);; 86 gr->Draw(""P"");; 87 ; 88 auto legend = new TLegend(0.1,0.7,0.48,0.9);; 89 legend->SetHeader(""The Legend Title"",""C""); // option ""C"" allows to center the header; 90 legend->AddEntry(h1,""Histogram filled with random numbers"",""f"");; 91 legend->AddEntry(""f1"",""Function abs(#frac{sin(x)}{x})"",""l"");; 92 legend->AddEntry(""gr"",""Graph with error bars"",""lep"");; 93 legend->Draw();; 94}; 95End_Macro; 96 ; 97 ; 98`TLegend` inherits from `TAttText` therefore changing any; 99text attributes (text alignment, font, color...) on a legend will changed the; 100text attributes on each line.; 101 ; 102In particular it can be interesting to change the text alignement that way. In; 103order to have a base-line vertical alignment instead of a centered one simply do:; 104~~~ {.cpp}; 105 legend->SetTextAlign(13);; 106~~~; 107or; 108~~~ {.cpp}; 109 legend->SetTextAlign(11);; 110~~~; 111The default value of some `TLegend` attributes can be changed using; 112`gStyle`. The default settings are:; 113~~~ {.cpp}; 114 SetLegendBorderSize(1);; 115 SetLegendFillColor(0);; 116 SetLegendFont(42);; 117 SetLegendTextSize(0.);; 118~~~; 119The global attributes change the default values for the next created legends.; 120 ; 121Text attributes can be also changed individually on each legend entry:; 122~~~ {.cpp}; 123 TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; 124 le->SetTextColor(kBlue);; 125~~~; 126 ; 127Note that the `TPad` class has a method to build automatically a legend; 128for all objects in the pad. It is called `TPad::BuildLegend()`.; 129 ; 130Each item in the legend is added using the `AddEntry` method. This; 131method defines the object to be added (by reference or name), the la",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
Integrability,depend,dependency,". ROOT: graf2d/graf/inc/TLegend.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TLegend.h File Reference. #include ""TPave.h""; #include ""TAttText.h"". Include dependency graph for TLegend.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TLegend;  This class displays a legend box (TPaveText) containing several legend entries. More...;  . graf2dgrafincTLegend.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:16 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TLegend_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8h.html
Energy Efficiency,allocate,allocated,"loat_t GetMargin() const { return fMargin; }; 52 Int_t GetNColumns() const { return fNColumns; }; 53 Int_t GetNRows() const;; 54 virtual void InsertEntry( const char* objectName = """",const char* label = """",; 55 Option_t* option = ""lpf"" ); // *MENU*; 56 void Paint( Option_t* option = """" ) override;; 57 virtual void PaintPrimitives();; 58 void Print( Option_t* option = """" ) const override;; 59 void RecursiveRemove(TObject *obj) override;; 60 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 61 void SetDefaults() { fEntrySeparation = 0.1f; fMargin = 0.25f; fNColumns = 1; fColumnSeparation = 0.0f; }; 62 void SetColumnSeparation( Float_t columnSeparation ); 63 { fColumnSeparation = columnSeparation; } // *MENU*; 64 virtual void SetEntryLabel( const char* label ); // *MENU*; 65 virtual void SetEntryOption( Option_t* option ); // *MENU*; 66 void SetEntrySeparation( Float_t entryseparation ); 67 { fEntrySeparation = entryseparation; } // *MENU*; 68 virtual void SetHeader( const char *header = """", Option_t *option = """" ); // *MENU*; 69 void SetMargin( Float_t margin ) { fMargin = margin; } // *MENU*; 70 void SetNColumns( Int_t nColumns ); // *MENU*; 71 ; 72protected:; 73 TList *fPrimitives{nullptr}; ///< List of TLegendEntries; 74 Float_t fEntrySeparation; ///< Separation between entries, as a fraction of; 75 ///< The space allocated to one entry.; 76 ///< Typical value is 0.1.; 77 Float_t fMargin; ///< Fraction of total width used for symbol; 78 Int_t fNColumns; ///< Number of columns in the legend; 79 Float_t fColumnSeparation; ///< Separation between columns, as a fraction of; 80 ///< The space allowed to one column; 81 ; 82 ClassDefOverride(TLegend,3) // Legend of markers/lines/boxes to represent obj's; 83};; 84 ; 85#endif; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(nam",MatchSource.WIKI,doc/master/TLegend_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8h_source.html
Deployability,release,released,"1,x2,y2);; 98}; 99 ; 100////////////////////////////////////////////////////////////////////////////////; 101/// Draw this line with new coordinates.; 102 ; 103TLine *TLine::DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); 104{; 105 TLine *newline = new TLine(x1, y1, x2, y2);; 106 TAttLine::Copy(*newline);; 107 newline->SetBit(kCanDelete);; 108 newline->AppendPad();; 109 return newline;; 110}; 111 ; 112////////////////////////////////////////////////////////////////////////////////; 113/// Draw this line with new coordinates in NDC.; 114 ; 115TLine *TLine::DrawLineNDC(Double_t x1, Double_t y1, Double_t x2, Double_t y2); 116{; 117 TLine *newline = DrawLine(x1, y1, x2, y2);; 118 newline->SetBit(kLineNDC);; 119 return newline;; 120}; 121 ; 122////////////////////////////////////////////////////////////////////////////////; 123/// Execute action corresponding to one event.; 124/// This member function is called when a line is clicked with the locator; 125///; 126/// If Left button clicked on one of the line end points, this point; 127/// follows the cursor until button is released.; 128///; 129/// if Middle button clicked, the line is moved parallel to itself; 130/// until the button is released.; 131 ; 132void TLine::ExecuteEvent(Int_t event, Int_t px, Int_t py); 133{; 134 if (!gPad) return;; 135 ; 136 Int_t kMaxDiff = 20;; 137 static Int_t d1,d2,px1,px2,py1,py2;; 138 static Int_t pxold, pyold, px1old, py1old, px2old, py2old;; 139 static Double_t oldX1, oldY1, oldX2, oldY2;; 140 static Bool_t p1, p2, pL, ndcsav;; 141 Double_t dpx,dpy,xp1,yp1;; 142 Int_t dx, dy;; 143 ; 144 Bool_t opaque = gPad->OpaqueMoving();; 145 ; 146 if (!gPad->IsEditable()) return;; 147 ; 148 switch (event) {; 149 ; 150 case kArrowKeyPress:; 151 case kButton1Down:; 152 oldX1 = GetX1();; 153 oldY1 = GetY1();; 154 oldX2 = GetX2();; 155 oldY2 = GetY2();; 156 ndcsav = TestBit(kLineNDC);; 157 if (!opaque) {; 158 gVirtualX->SetLineColor(-1);; 159 TAttLine::Modify(); //Change line attributes o",MatchSource.WIKI,doc/master/TLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLine_8cxx_source.html
Modifiability,inherit,inheritance,"45 out<<"" line->Draw();""<<std::endl;; 446}; 447 ; 448////////////////////////////////////////////////////////////////////////////////; 449/// Check whether this line is to be drawn horizontally.; 450 ; 451Bool_t TLine::IsHorizontal(); 452{; 453 return TestBit(kHorizontal);; 454}; 455 ; 456////////////////////////////////////////////////////////////////////////////////; 457/// Check whether this line is to be drawn vertically.; 458 ; 459Bool_t TLine::IsVertical(); 460{; 461 return TestBit(kVertical);; 462}; 463 ; 464////////////////////////////////////////////////////////////////////////////////; 465/// Set NDC mode on if isNDC = kTRUE, off otherwise; 466 ; 467void TLine::SetNDC(Bool_t isNDC); 468{; 469 ResetBit(kLineNDC);; 470 if (isNDC) SetBit(kLineNDC);; 471}; 472 ; 473////////////////////////////////////////////////////////////////////////////////; 474/// Force the line to be drawn horizontally.; 475/// Makes fY2 equal to fY1. The line length is kept.; 476/// TArrow and TGaxis also get this function by inheritance.; 477 ; 478void TLine::SetHorizontal(Bool_t set /*= kTRUE*/); 479{; 480 SetBit(kHorizontal, set);; 481 if (set && gPad) {; 482 SetVertical(kFALSE);; 483 Int_t px1 = gPad->XtoAbsPixel(fX1);; 484 Int_t px2 = gPad->XtoAbsPixel(fX2);; 485 Int_t py1 = gPad->YtoAbsPixel(fY1);; 486 Int_t py2 = gPad->YtoAbsPixel(fY2);; 487 Int_t l = Int_t(TMath::Sqrt((px2-px1)*(px2-px1)+(py2-py1)*(py2-py1)));; 488 if (fX2 >= fX1) fX2 = gPad->AbsPixeltoX(px1+l);; 489 else fX2 = gPad->AbsPixeltoX(px1-l);; 490 fY2 = fY1;; 491 }; 492}; 493 ; 494////////////////////////////////////////////////////////////////////////////////; 495/// Force the line to be drawn vertically.; 496/// Makes fX2 equal to fX1. The line length is kept.; 497/// TArrow and TGaxis also get this function by inheritance.; 498 ; 499void TLine::SetVertical(Bool_t set /*= kTRUE*/); 500{; 501 SetBit(kVertical, set);; 502 if (set && gPad) {; 503 SetHorizontal(kFALSE);; 504 Int_t px1 = gPad->XtoAbsPixel(fX1);; 505 Int_t",MatchSource.WIKI,doc/master/TLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLine_8cxx_source.html
Usability,simpl,simple,". ROOT: graf2d/graf/src/TLine.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TLine.cxx. Go to the documentation of this file. 1// @(#)root/graf:$Id$; 2// Author: Rene Brun 12/12/94; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include <cstdlib>; 13 ; 14#include <iostream>; 15#include ""TROOT.h""; 16#include ""TBuffer.h""; 17#include ""TLine.h""; 18#include ""TVirtualPad.h""; 19#include ""TClass.h""; 20#include ""TVirtualX.h""; 21#include ""TMath.h""; 22#include ""TPoint.h""; 23 ; 24ClassImp(TLine);; 25 ; 26/** \class TLine; 27\ingroup BasicGraphics; 28 ; 29Use the TLine constructor to create a simple line.; 30 ; 31~~~ {.cpp}; 32 TLine(Double_t x1,Double_t y1,Double_t x2,Double_t y2); 33~~~; 34 ; 35`x1`, `y1`, `x2`, `y2` are the coordinates of the first and the second point.; 36 ; 37_**Example**_:; 38 ; 39~~~ {.cpp}; 40 root[] l = new TLine(0.2,0.2,0.8,0.3); 41 root[] l->Draw(); 42~~~; 43*/; 44 ; 45 ; 46////////////////////////////////////////////////////////////////////////////////; 47/// Line normal constructor.; 48 ; 49TLine::TLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); 50 :TObject(), TAttLine(); 51{; 52 fX1=x1; fY1=y1; fX2=x2; fY2=y2;; 53}; 54 ; 55 ; 56////////////////////////////////////////////////////////////////////////////////; 57/// Line copy constructor.; 58 ; 59TLine::TLine(const TLine &line) : TObject(line), TAttLine(line), TAttBBox2D(line); 60{; 61 line.TLine::Copy(*this);; 62}; 63 ; 64////////////////////////////////////////////////////////////////////////////////; 65/// Assignment operator; 66 ; 67TLine &TLine::operator=(const TLine &src); 68{; 69 src.TLine::Copy(*this);;",MatchSource.WIKI,doc/master/TLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLine_8cxx_source.html
Integrability,depend,dependency,". ROOT: graf2d/graf/inc/TLine.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TLine.h File Reference. #include ""TObject.h""; #include ""TAttLine.h""; #include ""TAttBBox2D.h"". Include dependency graph for TLine.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TLine;  Use the TLine constructor to create a simple line. More...;  . graf2dgrafincTLine.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:16 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TLine_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLine_8h.html
Usability,simpl,simple,". ROOT: graf2d/graf/inc/TLine.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TLine.h File Reference. #include ""TObject.h""; #include ""TAttLine.h""; #include ""TAttBBox2D.h"". Include dependency graph for TLine.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TLine;  Use the TLine constructor to create a simple line. More...;  . graf2dgrafincTLine.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:16 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TLine_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLine_8h.html
Usability,simpl,simple,"ualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; y2Option_t Option_t TPoint TPoint const char y2Definition TGWin32VirtualXProxy.cxx:70; DrawLineOption_t Option_t TPoint TPoint const char DrawLineDefinition TGWin32VirtualXProxy.cxx:70; srcOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t srcDefinition TGWin32VirtualXProxy.cxx:164; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; TObject.h; TAttBBox2DAbstract base class for elements drawn in the editor.Definition TAttBBox2D.h:19; TAttLineLine Attributes class.Definition TAttLine.h:18; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::lsvoid ls(Option_t *option="""") const overrideList this line with its attributes.Definition TLine.cxx:380; TLine::SetY2virtual void SetY2(Double_t y2)Definition TLine.h:68; TLine::fY1Double_t fY1Y of 1st point.Definition TLine.h:26; TLine::fX1Double_t fX1X of 1st point.Definition TLine.h:25; TLine::SetX2virtual void SetX2(Double_t x2)Definition TLine.h:66; TLine::kLineNDC@ kLineNDCUse NDC coordinates.Definition TLine.h:33; TLine::kHorizontal@ kHorizontalLine is horizontal.Definition TLine.h:35; TLine::kVertical@ kVerticalLine is vertical.Definition TLine.h:34; TLine::IsVerticalBool_t IsVertical()Check whether this line is to be drawn vertically.Definition TLine.cxx:459; TLine::SetBBoxY1void SetBBoxY1(const Int_t y) overrideSet top of BoundingBox to a value (resize in y direction on top)Definition TLine.cxx:667; TLine::SetVerticalvoid SetVertical(Bool_t set=kTRUE)Force the line to be drawn vertically.Definition TLine.cxx:499; TL",MatchSource.WIKI,doc/master/TLine_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLine_8h_source.html
Availability,avail,available," case, for example TParallelCoord, a list (the pad's list of; 413 // primitives) will contain both the container and the containees; 414 // (the TParallelCoordVar) but if the Clear is being called from; 415 // the destructor of the container of this list, one of the first; 416 // thing done will be the remove the container (the pad) for the; 417 // list (of Primitives of the canvas) that was connecting it; 418 // (indirectly) to the list of cleanups.; 419 // Note: The Code in TParallelCoordVar was changed (circa June 2017),; 420 // to no longer have this behavior and thus rely on this code (by moving; 421 // from using Draw to Paint) but the structure might still exist elsewhere; 422 // so we keep this comment here.; 423 ; 424 // To preserve this connection (without introducing one when there was none),; 425 // we re-use fCache to inform RecursiveRemove of the node currently; 426 // being cleared/deleted.; 427 while (fFirst) {; 428 auto tlk = fFirst;; 429 fFirst = fFirst->fNext;; 430 fSize--;; 431 ; 432 ; 433 // Make node available to RecursiveRemove; 434 tlk->fNext.reset();; 435 tlk->fPrev.reset();; 436 fCache = tlk;; 437 ; 438 // delete only heap objects marked OK to clear; 439 auto obj = tlk->GetObject();; 440 if (!nodel && obj) {; 441 if (ROOT::Detail::HasBeenDeleted(obj)) {; 442 Error(""Clear"", ""A list is accessing an object (%p) already deleted (list name = %s)"",; 443 obj, GetName());; 444 } else if (obj->IsOnHeap()) {; 445 if (obj->TestBit(kCanDelete)) {; 446 if (!ROOT::Detail::HasBeenDeleted(obj)) {; 447 TCollection::GarbageCollect(obj);; 448 }; 449 }; 450 }; 451 }; 452 // delete tlk;; 453 }; 454 fFirst.reset();; 455 fLast.reset();; 456 fCache.reset();; 457 fSize = 0;; 458 Changed();; 459}; 460 ; 461////////////////////////////////////////////////////////////////////////////////; 462/// Remove all objects from the list AND delete all heap based objects.; 463/// If option=""slow"" then keep list consistent during delete. This allows; 464/// recursive list operati",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
Integrability,wrap,wrapped,". ROOT: core/cont/src/TList.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TList.cxx. Go to the documentation of this file. 1// @(#)root/cont:$Id$; 2// Author: Fons Rademakers 10/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TList; 13\ingroup Containers; 14A doubly linked list.; 15 ; 16All classes inheriting from TObject can be; 17inserted in a TList. Before being inserted into the list the object; 18pointer is wrapped in a TObjLink object which contains, besides; 19the object pointer also a previous and next pointer.; 20 ; 21There are several ways to iterate over a TList; in order of preference, if; 22not forced by other constraints:; 23 ; 24 1. (Preferred way) Using the C++ range-based `for` or `begin()` / `end()`:; 25~~~ {.cpp}; 26 for(TObject *obj: *GetListOfPrimitives()); 27 obj->Write();; 28~~~; 29 2. Using the R__FOR_EACH macro:; 30~~~ {.cpp}; 31 GetListOfPrimitives()->R__FOR_EACH(TObject,Paint)(option);; 32~~~; 33 3. Using the TList iterator TListIter (via the wrapper class TIter):; 34~~~ {.cpp}; 35 TIter next(GetListOfPrimitives());; 36 while (TObject *obj = next()); 37 obj->Draw(next.GetOption());; 38~~~; 39 4. Using the TList iterator TListIter and std::for_each algorithm:; 40~~~ {.cpp}; 41 // A function object, which will be applied to each element; 42 // of the given range.; 43 struct STestFunctor {; 44 bool operator()(TObject *aObj) {; 45 ...; 46 return true;; 47 }; 48 }; 49 ...; 50 ...; 51 TIter iter(mylist);; 52 for_each( iter.Begin(), TIter::End(), STestFunctor() );; 53~~~; 54 5. Using the TObjLink list entries (that wrap the TObject*):; 55~~~ {.cpp}; ",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
Modifiability,inherit,inheriting,". ROOT: core/cont/src/TList.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TList.cxx. Go to the documentation of this file. 1// @(#)root/cont:$Id$; 2// Author: Fons Rademakers 10/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TList; 13\ingroup Containers; 14A doubly linked list.; 15 ; 16All classes inheriting from TObject can be; 17inserted in a TList. Before being inserted into the list the object; 18pointer is wrapped in a TObjLink object which contains, besides; 19the object pointer also a previous and next pointer.; 20 ; 21There are several ways to iterate over a TList; in order of preference, if; 22not forced by other constraints:; 23 ; 24 1. (Preferred way) Using the C++ range-based `for` or `begin()` / `end()`:; 25~~~ {.cpp}; 26 for(TObject *obj: *GetListOfPrimitives()); 27 obj->Write();; 28~~~; 29 2. Using the R__FOR_EACH macro:; 30~~~ {.cpp}; 31 GetListOfPrimitives()->R__FOR_EACH(TObject,Paint)(option);; 32~~~; 33 3. Using the TList iterator TListIter (via the wrapper class TIter):; 34~~~ {.cpp}; 35 TIter next(GetListOfPrimitives());; 36 while (TObject *obj = next()); 37 obj->Draw(next.GetOption());; 38~~~; 39 4. Using the TList iterator TListIter and std::for_each algorithm:; 40~~~ {.cpp}; 41 // A function object, which will be applied to each element; 42 // of the given range.; 43 struct STestFunctor {; 44 bool operator()(TObject *aObj) {; 45 ...; 46 return true;; 47 }; 48 }; 49 ...; 50 ...; 51 TIter iter(mylist);; 52 for_each( iter.Begin(), TIter::End(), STestFunctor() );; 53~~~; 54 5. Using the TObjLink list entries (that wrap the TObject*):; 55~~~ {.cpp}; ",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
Performance,cache,cached,"ink(obj, after->shared_from_this());; 295 fSize++;; 296 Changed();; 297 }; 298 }; 299}; 300 ; 301////////////////////////////////////////////////////////////////////////////////; 302/// Insert object at position idx in the list.; 303 ; 304void TList::AddAt(TObject *obj, Int_t idx); 305{; 306 R__COLLECTION_WRITE_GUARD();; 307 ; 308 if (IsArgNull(""AddAt"", obj)) return;; 309 ; 310 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 311 ; 312 TObjLink *lnk = LinkAt(idx);; 313 if (!lnk); 314 TList::AddLast(obj);; 315 else if (lnk == fFirst.get()); 316 TList::AddFirst(obj);; 317 else {; 318 NewLink(obj, lnk->fPrev.lock());; 319 fSize++;; 320 Changed();; 321 }; 322}; 323 ; 324////////////////////////////////////////////////////////////////////////////////; 325/// Returns the object after object obj. Obj is found using the; 326/// object's IsEqual() method. Returns 0 if obj is last in list.; 327 ; 328TObject *TList::After(const TObject *obj) const; 329{; 330 R__COLLECTION_WRITE_GUARD();; 331 ; 332 TObjLink *t;; 333 ; 334 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 335 ; 336 auto cached = fCache.lock();; 337 if (cached.get() && cached->GetObject() && cached->GetObject()->IsEqual(obj)) {; 338 t = cached.get();; 339 ((TList*)this)->fCache = cached->fNext; //cast const away, fCache should be mutable; 340 } else {; 341 Int_t idx;; 342 t = FindLink(obj, idx);; 343 if (t) ((TList*)this)->fCache = t->fNext;; 344 }; 345 ; 346 if (t && t->Next()); 347 return t->Next()->GetObject();; 348 else; 349 return nullptr;; 350}; 351 ; 352////////////////////////////////////////////////////////////////////////////////; 353/// Returns the object at position idx. Returns 0 if idx is out of range.; 354 ; 355TObject *TList::At(Int_t idx) const; 356{; 357 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 358 R__COLLECTION_WRITE_GUARD();; 359 ; 360 TObjLink *lnk = LinkAt(idx);; 361 if (lnk) return lnk->GetObject();; 362 return nullptr;; 363}; 364 ; 365//////////////////////////////////////////////",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
Security,access,accessing," the canvas) that was connecting it; 418 // (indirectly) to the list of cleanups.; 419 // Note: The Code in TParallelCoordVar was changed (circa June 2017),; 420 // to no longer have this behavior and thus rely on this code (by moving; 421 // from using Draw to Paint) but the structure might still exist elsewhere; 422 // so we keep this comment here.; 423 ; 424 // To preserve this connection (without introducing one when there was none),; 425 // we re-use fCache to inform RecursiveRemove of the node currently; 426 // being cleared/deleted.; 427 while (fFirst) {; 428 auto tlk = fFirst;; 429 fFirst = fFirst->fNext;; 430 fSize--;; 431 ; 432 ; 433 // Make node available to RecursiveRemove; 434 tlk->fNext.reset();; 435 tlk->fPrev.reset();; 436 fCache = tlk;; 437 ; 438 // delete only heap objects marked OK to clear; 439 auto obj = tlk->GetObject();; 440 if (!nodel && obj) {; 441 if (ROOT::Detail::HasBeenDeleted(obj)) {; 442 Error(""Clear"", ""A list is accessing an object (%p) already deleted (list name = %s)"",; 443 obj, GetName());; 444 } else if (obj->IsOnHeap()) {; 445 if (obj->TestBit(kCanDelete)) {; 446 if (!ROOT::Detail::HasBeenDeleted(obj)) {; 447 TCollection::GarbageCollect(obj);; 448 }; 449 }; 450 }; 451 }; 452 // delete tlk;; 453 }; 454 fFirst.reset();; 455 fLast.reset();; 456 fCache.reset();; 457 fSize = 0;; 458 Changed();; 459}; 460 ; 461////////////////////////////////////////////////////////////////////////////////; 462/// Remove all objects from the list AND delete all heap based objects.; 463/// If option=""slow"" then keep list consistent during delete. This allows; 464/// recursive list operations during the delete (e.g. during the dtor; 465/// of an object in this list one can still access the list to search for; 466/// other not yet deleted objects).; 467 ; 468void TList::Delete(Option_t *option); 469{; 470 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 471 R__COLLECTION_WRITE_GUARD();; 472 ; 473 Bool_t slow = option ? (!strcmp(option, ""slow"") ? kTRUE : ",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
Usability,clear,cleared,"ol_t nodel = option ? (!strcmp(option, ""nodelete"") ? kTRUE : kFALSE) : kFALSE;; 406 ; 407 if (!nodel && IsOwner()) {; 408 Delete(option);; 409 return;; 410 }; 411 ; 412 // In some case, for example TParallelCoord, a list (the pad's list of; 413 // primitives) will contain both the container and the containees; 414 // (the TParallelCoordVar) but if the Clear is being called from; 415 // the destructor of the container of this list, one of the first; 416 // thing done will be the remove the container (the pad) for the; 417 // list (of Primitives of the canvas) that was connecting it; 418 // (indirectly) to the list of cleanups.; 419 // Note: The Code in TParallelCoordVar was changed (circa June 2017),; 420 // to no longer have this behavior and thus rely on this code (by moving; 421 // from using Draw to Paint) but the structure might still exist elsewhere; 422 // so we keep this comment here.; 423 ; 424 // To preserve this connection (without introducing one when there was none),; 425 // we re-use fCache to inform RecursiveRemove of the node currently; 426 // being cleared/deleted.; 427 while (fFirst) {; 428 auto tlk = fFirst;; 429 fFirst = fFirst->fNext;; 430 fSize--;; 431 ; 432 ; 433 // Make node available to RecursiveRemove; 434 tlk->fNext.reset();; 435 tlk->fPrev.reset();; 436 fCache = tlk;; 437 ; 438 // delete only heap objects marked OK to clear; 439 auto obj = tlk->GetObject();; 440 if (!nodel && obj) {; 441 if (ROOT::Detail::HasBeenDeleted(obj)) {; 442 Error(""Clear"", ""A list is accessing an object (%p) already deleted (list name = %s)"",; 443 obj, GetName());; 444 } else if (obj->IsOnHeap()) {; 445 if (obj->TestBit(kCanDelete)) {; 446 if (!ROOT::Detail::HasBeenDeleted(obj)) {; 447 TCollection::GarbageCollect(obj);; 448 }; 449 }; 450 }; 451 }; 452 // delete tlk;; 453 }; 454 fFirst.reset();; 455 fLast.reset();; 456 fCache.reset();; 457 fSize = 0;; 458 Changed();; 459}; 460 ; 461////////////////////////////////////////////////////////////////////////////////; 462/",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
Integrability,depend,dependency,". ROOT: core/cont/inc/TList.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Functions |; Variables ; TList.h File Reference. #include ""TSeqCollection.h""; #include ""TString.h""; #include <iterator>; #include <memory>. Include dependency graph for TList.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TList;  A doubly linked list. More...;  ; class  TListIter;  Iterator of linked list. More...;  ; class  TObjLink;  Wrapper around a TObject so it can be stored in a TList. More...;  ; class  TObjOptLink;  . Functions; bool operator== (const std::shared_ptr< TObjLink > &l, TObjOptLink *r);  ; bool operator== (TObjOptLink *l, const std::shared_ptr< TObjLink > &r);  . Variables; const Bool_t kSortAscending = kTRUE;  ; const Bool_t kSortDescending = !kSortAscending;  . Function Documentation. ◆ operator==() [1/2]. bool operator== ; (; const std::shared_ptr< TObjLink > & ; l, . TObjOptLink * ; r . ). inline . Definition at line 237 of file TList.h. ◆ operator==() [2/2]. bool operator== ; (; TObjOptLink * ; l, . const std::shared_ptr< TObjLink > & ; r . ). inline . Definition at line 233 of file TList.h. Variable Documentation. ◆ kSortAscending. const Bool_t kSortAscending = kTRUE. Definition at line 31 of file TList.h. ◆ kSortDescending. const Bool_t kSortDescending = !kSortAscending. Definition at line 32 of file TList.h. corecontincTList.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:13 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TList_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8h.html
Modifiability,inherit,inheriting,". ROOT: core/cont/inc/TList.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TList.h. Go to the documentation of this file. 1// @(#)root/cont:$Id$; 2// Author: Fons Rademakers 10/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TList; 13#define ROOT_TList; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TList //; 19// //; 20// A doubly linked list. All classes inheriting from TObject can be //; 21// inserted in a TList. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TSeqCollection.h""; 26#include ""TString.h""; 27 ; 28#include <iterator>; 29#include <memory>; 30 ; 31const Bool_t kSortAscending = kTRUE;; 32const Bool_t kSortDescending = !kSortAscending;; 33 ; 34class TObjLink;; 35class TListIter;; 36 ; 37 ; 38class TList : public TSeqCollection {; 39 ; 40friend class TListIter;; 41 ; 42protected:; 43 using TObjLinkPtr_t = std::shared_ptr<TObjLink>;; 44 using TObjLinkWeakPtr_t = std::weak_ptr<TObjLink>;; 45 ; 46 TObjLinkPtr_t fFirst; //! pointer to first entry in linked list; 47 TObjLinkPtr_t fLast; //! pointer to last entry in linked list; 48 TObjLinkWeakPtr_t fCache; //! cache to speedup sequential calling of Before() and After() functions; 49 Bool_t fAscending; //! sorting order (when calling Sort() or for TSortedList); 50 ; 51 TObjLink *LinkAt(Int_t idx) const;; 52 TObjLink *FindLink(const TObject *obj, Int_t &idx) const;; 53 ; 54 TObjLinkPtr_t *DoSort(TObjLinkPtr_t *head, Int_t n);; 55 ; 56 Bool_t LnkCompare(const TObjLinkPtr_t &l1, const TObjLinkPtr_t &l2);; 5",MatchSource.WIKI,doc/master/TList_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8h_source.html
Performance,cache,cache,"serted in a TList. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TSeqCollection.h""; 26#include ""TString.h""; 27 ; 28#include <iterator>; 29#include <memory>; 30 ; 31const Bool_t kSortAscending = kTRUE;; 32const Bool_t kSortDescending = !kSortAscending;; 33 ; 34class TObjLink;; 35class TListIter;; 36 ; 37 ; 38class TList : public TSeqCollection {; 39 ; 40friend class TListIter;; 41 ; 42protected:; 43 using TObjLinkPtr_t = std::shared_ptr<TObjLink>;; 44 using TObjLinkWeakPtr_t = std::weak_ptr<TObjLink>;; 45 ; 46 TObjLinkPtr_t fFirst; //! pointer to first entry in linked list; 47 TObjLinkPtr_t fLast; //! pointer to last entry in linked list; 48 TObjLinkWeakPtr_t fCache; //! cache to speedup sequential calling of Before() and After() functions; 49 Bool_t fAscending; //! sorting order (when calling Sort() or for TSortedList); 50 ; 51 TObjLink *LinkAt(Int_t idx) const;; 52 TObjLink *FindLink(const TObject *obj, Int_t &idx) const;; 53 ; 54 TObjLinkPtr_t *DoSort(TObjLinkPtr_t *head, Int_t n);; 55 ; 56 Bool_t LnkCompare(const TObjLinkPtr_t &l1, const TObjLinkPtr_t &l2);; 57 TObjLinkPtr_t NewLink(TObject *obj, const TObjLinkPtr_t &prev = nullptr);; 58 TObjLinkPtr_t NewOptLink(TObject *obj, Option_t *opt, const TObjLinkPtr_t &prev = nullptr);; 59 TObjLinkPtr_t NewLink(TObject *obj, TObjLink *prev);; 60 TObjLinkPtr_t NewOptLink(TObject *obj, Option_t *opt, TObjLink *prev);; 61 // virtual void DeleteLink(TObjLink *lnk);; 62 ; 63 void InsertAfter(const TObjLinkPtr_t &newlink, const TObjLinkPtr_t &prev);; 64 ; 65private:; 66 TList(const TList&) = delete;; 67 TList& operator=(const TList&) = delete;; 68 ; 69public:; 70 typedef TListIter Iterator_t;; 71 ; 72 TList() : fAscending(kTRUE) { }; 73 ; 74 TList(TObject *) R__DEPRECATED(6, 34, ""The argument is ignored. Use the default constructor TList::TList()."") : fAscending(kTRUE) { } // for backward compatibility, don't use; 75 ; 76 virtual ~TList();; 77 void Clear(Option_t *op",MatchSource.WIKI,doc/master/TList_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8h_source.html
Deployability,release,released,"t_t(4*fMarkerSize);; 191 if (dist <= markerRadius) return 0;; 192 if (dist > markerRadius+3) return 999;; 193 return dist;; 194}; 195 ; 196////////////////////////////////////////////////////////////////////////////////; 197/// Draw this marker with its current attributes.; 198 ; 199void TMarker::Draw(Option_t *option); 200{; 201 AppendPad(option);; 202 ; 203}; 204 ; 205////////////////////////////////////////////////////////////////////////////////; 206/// Draw this marker with new coordinates.; 207 ; 208TMarker *TMarker::DrawMarker(Double_t x, Double_t y); 209{; 210 TMarker *newmarker = new TMarker(x, y, 1);; 211 TAttMarker::Copy(*newmarker);; 212 newmarker->SetBit(kCanDelete);; 213 newmarker->AppendPad();; 214 return newmarker;; 215}; 216 ; 217////////////////////////////////////////////////////////////////////////////////; 218/// Execute action corresponding to one event.; 219///; 220/// This member function is called when a marker is clicked with the locator; 221///; 222/// If Left button is clicked on a marker, the marker is moved to; 223/// a new position when the mouse button is released.; 224 ; 225void TMarker::ExecuteEvent(Int_t event, Int_t px, Int_t py); 226{; 227 if (!gPad) return;; 228 ; 229 TPoint p;; 230 static Int_t pxold, pyold;; 231 static Bool_t ndcsav;; 232 Double_t dpx, dpy, xp1,yp1;; 233 Bool_t opaque = gPad->OpaqueMoving();; 234 ; 235 if (!gPad->IsEditable()) return;; 236 ; 237 switch (event) {; 238 ; 239 case kButton1Down:; 240 ndcsav = TestBit(kMarkerNDC);; 241 if (!opaque) {; 242 gVirtualX->SetTextColor(-1); // invalidate current text color (use xor mode); 243 TAttMarker::Modify(); //Change marker attributes only if necessary; 244 }; 245 // No break !!!; 246 ; 247 case kMouseMotion:; 248 pxold = px; pyold = py;; 249 gPad->SetCursor(kMove);; 250 break;; 251 ; 252 case kButton1Motion:; 253 p.fX = pxold; p.fY = pyold;; 254 if (!opaque) gVirtualX->DrawPolyMarker(1, &p);; 255 p.fX = px; p.fY = py;; 256 if (!opaque) gVirtualX->DrawPolyMarker(1, &",MatchSource.WIKI,doc/master/TMarker_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMarker_8cxx_source.html
Availability,avail,available,". ROOT: core/base/inc/TMathBase.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMathBase.h. Go to the documentation of this file. 1// @(#)root/base:; 2// Authors: Rene Brun, Fons Rademakers 29/07/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TMathBase; 13#define ROOT_TMathBase; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TMath Base functions //; 19// //; 20// Define the functions Min, Max, Abs, Sign, Range for all types. //; 21// NB: These functions are unfortunately not available in a portable //; 22// way in std::. //; 23// //; 24// More functions are defined in TMath.h. TMathBase.h is designed to be //; 25// a stable file and used in place of TMath.h in the ROOT miniCore. //; 26// //; 27//////////////////////////////////////////////////////////////////////////; 28 ; 29#include ""RtypesCore.h""; 30 ; 31#include <cstdlib>; 32#include <cmath>; 33#include <algorithm>; 34 ; 35namespace TMath {; 36 ; 37 // Abs; 38 inline Short_t Abs(Short_t d);; 39 inline Int_t Abs(Int_t d);; 40 inline Long_t Abs(Long_t d);; 41 inline Long64_t Abs(Long64_t d);; 42 inline Float_t Abs(Float_t d);; 43 inline Double_t Abs(Double_t d);; 44 inline LongDouble_t Abs(LongDouble_t d);; 45 ; 46 // Even/Odd; 47 inline Bool_t Even(Long_t a);; 48 inline Bool_t Odd(Long_t a);; 49 ; 50 // SignBit; 51 template<typename Integer>; 52 inline Bool_t SignBit(Integer a);; 53 inline Bool_t SignBit(Float_t a);; 54 inline Bool_t SignBit(Double_t a);; 55 inline Bool_t SignBit(LongDouble_t a);; 56 ; 57 // Sign; 58 template<typename T1, typename T2>; 59 inline T1 S",MatchSource.WIKI,doc/master/TMathBase_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMathBase_8h_source.html
Modifiability,portab,portable,". ROOT: core/base/inc/TMathBase.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMathBase.h. Go to the documentation of this file. 1// @(#)root/base:; 2// Authors: Rene Brun, Fons Rademakers 29/07/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TMathBase; 13#define ROOT_TMathBase; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TMath Base functions //; 19// //; 20// Define the functions Min, Max, Abs, Sign, Range for all types. //; 21// NB: These functions are unfortunately not available in a portable //; 22// way in std::. //; 23// //; 24// More functions are defined in TMath.h. TMathBase.h is designed to be //; 25// a stable file and used in place of TMath.h in the ROOT miniCore. //; 26// //; 27//////////////////////////////////////////////////////////////////////////; 28 ; 29#include ""RtypesCore.h""; 30 ; 31#include <cstdlib>; 32#include <cmath>; 33#include <algorithm>; 34 ; 35namespace TMath {; 36 ; 37 // Abs; 38 inline Short_t Abs(Short_t d);; 39 inline Int_t Abs(Int_t d);; 40 inline Long_t Abs(Long_t d);; 41 inline Long64_t Abs(Long64_t d);; 42 inline Float_t Abs(Float_t d);; 43 inline Double_t Abs(Double_t d);; 44 inline LongDouble_t Abs(LongDouble_t d);; 45 ; 46 // Even/Odd; 47 inline Bool_t Even(Long_t a);; 48 inline Bool_t Odd(Long_t a);; 49 ; 50 // SignBit; 51 template<typename Integer>; 52 inline Bool_t SignBit(Integer a);; 53 inline Bool_t SignBit(Float_t a);; 54 inline Bool_t SignBit(Double_t a);; 55 inline Bool_t SignBit(LongDouble_t a);; 56 ; 57 // Sign; 58 template<typename T1, typename T2>; 59 inline T1 S",MatchSource.WIKI,doc/master/TMathBase_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMathBase_8h_source.html
Availability,avail,available,"ee $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include <iostream>; 13#include ""TROOT.h""; 14#include <ft2build.h>; 15#include FT_FREETYPE_H; 16#include FT_GLYPH_H; 17#include ""TTF.h""; 18#include ""TMathText.h""; 19#include ""TMath.h""; 20#include ""TVirtualPad.h""; 21#include ""TVirtualPS.h""; 22#include ""TVirtualX.h""; 23#include ""TText.h""; 24 ; 25#include ""../../../graf2d/mathtext/inc/mathtext.h""; 26#include ""../../../graf2d/mathtext/inc/mathrender.h""; 27 ; 28/** \class TMathText; 29\ingroup BasicGraphics; 30 ; 31To draw TeX Mathematical Formula; 32 ; 33TMathText's purpose is to write mathematical equations, exactly as TeX would; 34do it. The syntax is the same as the TeX's one.; 35 ; 36The following example demonstrate how to use TMathText:; 37 ; 38Begin_Macro(source); 39../../../tutorials/graphics/tmathtext.C; 40End_Macro; 41 ; 42The list of all available symbols is given in the following example:; 43 ; 44Begin_Macro; 45../../../tutorials/graphics/tmathtext2.C; 46End_Macro; 47 ; 48#### Limitation:; 49TMathText rendering is not implemented for the PDF output.; 50PostScript output should be used instead.; 51*/; 52 ; 53const Double_t kPI = TMath::Pi();; 54 ; 55class TMathTextRenderer : public TText, public TAttFill,; 56 public mathtext::math_text_renderer_t {; 57private:; 58 TMathText *_parent;; 59 float _font_size;; 60 float _x0;; 61 float _y0;; 62 float _angle_degree;; 63 float _pad_pixel_transform[6];; 64 float _pad_scale;; 65 float _pad_scale_x;; 66 float _pad_scale_y;; 67 float _pad_scale_x_relative;; 68 float _pad_scale_y_relative;; 69 float _current_font_size[mathtext::math_text_renderer_t::NFAMILY];; 70 inline size_t root_face_number(; 71 const unsigned int family, const bool serif = false) const; 72 {; 73 static const int precision = 2;; 74 ; 75 if (family >= mathtext::math_text_renderer_t::; 76 FAMILY_REGULAR &&; 77 family <= mathtext::ma",MatchSource.WIKI,doc/master/TMathText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMathText_8cxx_source.html
Modifiability,inherit,inherits,"with the new parameters and copy object attributes.Definition TMathText.cxx:541; TMathText::TMathTextTMathText()Default constructor.Definition TMathText.cxx:345; TMathText::PaintMathTextvirtual void PaintMathText(Double_t x, Double_t y, Double_t angle, Double_t size, const char *text)Paint text (used by Paint()).Definition TMathText.cxx:577; TMathText::Copyvoid Copy(TObject &text) const overrideCopy.Definition TMathText.cxx:394; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TTF::fgFacestatic FT_Face fgFace[kTTMaxFonts]font faceDefinition TTF.h:82; TTF::SetTextFontstatic void SetTextFont(Font_t fontnumber)Set specified ",MatchSource.WIKI,doc/master/TMathText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMathText_8cxx_source.html
Availability,error,error,"0.00000000001244332, 0.00000000000182256,; 129 -0.00000000000027007, 0.00000000000004042,-0.00000000000000610,; 130 0.00000000000000093,-0.00000000000000014, 0.00000000000000002};; 131 ; 132 Double_t t,h,y,s,a,alfa,b1,b2,b0;; 133 t=h=y=s=a=alfa=b1=b2=b0=0.;; 134 ; 135 if (x == 1) {; 136 h = pi6;; 137 } else if (x == -1) {; 138 h = -pi12;; 139 } else {; 140 t = -x;; 141 if (t <= -2) {; 142 y = -1/(1+t);; 143 s = 1;; 144 b1= TMath::Log(-t);; 145 b2= TMath::Log(1+1/t);; 146 a = -pi3+hf*(b1*b1-b2*b2);; 147 } else if (t < -1) {; 148 y = -1-t;; 149 s = -1;; 150 a = TMath::Log(-t);; 151 a = -pi6+a*(a+TMath::Log(1+1/t));; 152 } else if (t <= -0.5) {; 153 y = -(1+t)/t;; 154 s = 1;; 155 a = TMath::Log(-t);; 156 a = -pi6+a*(-hf*a+TMath::Log(1+t));; 157 } else if (t < 0) {; 158 y = -t/(1+t);; 159 s = -1;; 160 b1= TMath::Log(1+t);; 161 a = hf*b1*b1;; 162 } else if (t <= 1) {; 163 y = t;; 164 s = 1;; 165 a = 0;; 166 } else {; 167 y = 1/t;; 168 s = -1;; 169 b1= TMath::Log(t);; 170 a = pi6+hf*b1*b1;; 171 }; 172 h = y+y-1;; 173 alfa = h+h;; 174 b1 = 0;; 175 b2 = 0;; 176 for (Int_t i=19;i>=0;i--){; 177 b0 = c[i] + alfa*b1-b2;; 178 b2 = b1;; 179 b1 = b0;; 180 }; 181 h = -(s*(b0-h*b2)+a);; 182 }; 183 return h;; 184}; 185 ; 186////////////////////////////////////////////////////////////////////////////////; 187/// Computation of the error function erf(x).; 188/// Erf(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between 0 and x; 189 ; 190Double_t TMath::Erf(Double_t x); 191{; 192 return ::ROOT::Math::erf(x);; 193}; 194 ; 195////////////////////////////////////////////////////////////////////////////////; 196/// Computes the complementary error function erfc(x).; 197/// Erfc(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between x and infinity; 198 ; 199Double_t TMath::Erfc(Double_t x); 200{; 201 return ::ROOT::Math::erfc(x);; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Returns the inverse error function.; 206/// x must be <-1<x<1; 207 ; 208D",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
Deployability,integrat,integrated,"ays of length na, nb, respectively.; 718/// The elements of a and b must be given in ascending order.; 719/// option is a character string to specify options; 720/// ""D"" Put out a line of ""Debug"" printout; 721/// ""M"" Return the Maximum Kolmogorov distance instead of prob; 722///; 723/// ### Output:; 724/// The returned value prob is a calculated confidence level which gives a; 725/// statistical test for compatibility of a and b.; 726/// Values of prob close to zero are taken as indicating a small probability; 727/// of compatibility. For two point sets drawn randomly from the same parent; 728/// distribution, the value of prob should be uniformly distributed between; 729/// zero and one.; 730/// in case of error the function return -1; 731/// If the 2 sets have a different number of points, the minimum of; 732/// the two sets is used.; 733///; 734/// ### Method:; 735/// The Kolmogorov test is used. The test statistic is the maximum deviation; 736/// between the two integrated distribution functions, multiplied by the; 737/// normalizing factor (rdmax*sqrt(na*nb/(na+nb)).; 738///; 739/// Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); 740/// (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; 741/// Statistical Methods in Experimental Physics, (North-Holland,; 742/// Amsterdam 1971) 269-271); 743///; 744/// ### Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov); 745///; 746/// The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; 747/// over the two sorted arrays a and b representing empirical distribution; 748/// functions. The for-loop handles 3 cases: when the next points to be; 749/// evaluated satisfy a>b, a<b, or a=b:; 750///; 751/// ~~~ {.cpp}; 752/// for (Int_t i=0;i<na+nb;i++) {; 753/// if (a[ia-1] < b[ib-1]) {; 754/// rdiff -= sa;; 755/// ia++;; 756/// if (ia > na) {ok = kTRUE; break;}; 757/// } else if (a[ia-1] > b[ib-1]) {; 758/// rdiff += sb;; 759/// ib++;; 760/// if (ib > nb) {ok = kTRUE; bre",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
Energy Efficiency,adapt,adapted," kFALSE) the result is divided; 469/// by sqrt(2*Pi)*sigma.; 470 ; 471Double_t TMath::Gaus(Double_t x, Double_t mean, Double_t sigma, Bool_t norm); 472{; 473 if (sigma == 0) return 1.e30;; 474 Double_t arg = (x-mean)/sigma;; 475 // for |arg| > 39 result is zero in double precision; 476 if (arg < -39.0 || arg > 39.0) return 0.0;; 477 Double_t res = TMath::Exp(-0.5*arg*arg);; 478 if (!norm) return res;; 479 return res/(2.50662827463100024*sigma); //sqrt(2*Pi)=2.50662827463100024; 480}; 481 ; 482////////////////////////////////////////////////////////////////////////////////; 483/// The LANDAU function.; 484///; 485/// mu is a location parameter and correspond approximately to the most probable value; 486/// and sigma is a scale parameter (not the sigma of the full distribution which is not defined); 487/// Note that for mu=0 and sigma=1 (default values) the exact location of the maximum of the distribution; 488/// (most proper value) is at x = -0.22278; 489/// This function has been adapted from the CERNLIB routine G110 denlan.; 490/// If norm=kTRUE (default is kFALSE) the result is divided by sigma; 491 ; 492Double_t TMath::Landau(Double_t x, Double_t mu, Double_t sigma, Bool_t norm); 493{; 494 if (sigma <= 0) return 0;; 495 Double_t den = ::ROOT::Math::landau_pdf( (x-mu)/sigma );; 496 if (!norm) return den;; 497 return den/sigma;; 498}; 499 ; 500////////////////////////////////////////////////////////////////////////////////; 501/// Computation of ln[gamma(z)] for all z.; 502///; 503/// C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86.; 504///; 505/// The accuracy of the result is better than 2e-10.; 506///; 507/// \author NvE 14-nov-1998 UU-SAP Utrecht; 508 ; 509Double_t TMath::LnGamma(Double_t z); 510{; 511 return ::ROOT::Math::lgamma(z);; 512}; 513 ; 514////////////////////////////////////////////////////////////////////////////////; 515/// Normalize a vector v in place.; 516/// Returns the norm of the original vector.; 517 ; 518Float_t TMath::Normaliz",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
Integrability,rout,routines,". ROOT: math/mathcore/src/TMath.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMath.cxx. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: Rene Brun, Anna Kreshuk, Eddy Offermann, Fons Rademakers 29/07/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12////////////////////////////////////////////////////////////////////////////////; 13// TMath; 14//; 15// Encapsulate math routines.; 16 ; 17#include ""TMath.h""; 18#include ""TError.h""; 19#include <cmath>; 20#include <cstring>; 21#include <algorithm>; 22#include <iostream>; 23#include ""TString.h""; 24 ; 25#include <Math/SpecFuncMathCore.h>; 26#include <Math/PdfFuncMathCore.h>; 27#include <Math/ProbFuncMathCore.h>; 28 ; 29//const Double_t; 30// TMath::Pi = 3.14159265358979323846,; 31// TMath::E = 2.7182818284590452354;; 32 ; 33 ; 34// Without this macro the THtml doc for TMath can not be generated; 35#if !defined(R__SOLARIS) && !defined(R__ACC) && !defined(R__FBSD); 36NamespaceImp(TMath); 37#endif; 38 ; 39namespace TMath {; 40 ; 41 Double_t GamCf(Double_t a,Double_t x);; 42 Double_t GamSer(Double_t a,Double_t x);; 43 Double_t VavilovDenEval(Double_t rlam, Double_t *AC, Double_t *HC, Int_t itype);; 44 void VavilovSet(Double_t rkappa, Double_t beta2, Bool_t mode, Double_t *WCM, Double_t *AC, Double_t *HC, Int_t &itype, Int_t &npt);; 45 ; 46}; 47 ; 48////////////////////////////////////////////////////////////////////////////////; 49/// Returns `sqrt(x*x + y*y)`; 50 ; 51Long_t TMath::Hypot(Long_t x, Long_t y); 52{; 53 return (Long_t) (hypot((Double_t)x, (Double_t)y) + 0.5);; 54}; 55 ; 56///////////////////////////////",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
Modifiability,adapt,adapted," kFALSE) the result is divided; 469/// by sqrt(2*Pi)*sigma.; 470 ; 471Double_t TMath::Gaus(Double_t x, Double_t mean, Double_t sigma, Bool_t norm); 472{; 473 if (sigma == 0) return 1.e30;; 474 Double_t arg = (x-mean)/sigma;; 475 // for |arg| > 39 result is zero in double precision; 476 if (arg < -39.0 || arg > 39.0) return 0.0;; 477 Double_t res = TMath::Exp(-0.5*arg*arg);; 478 if (!norm) return res;; 479 return res/(2.50662827463100024*sigma); //sqrt(2*Pi)=2.50662827463100024; 480}; 481 ; 482////////////////////////////////////////////////////////////////////////////////; 483/// The LANDAU function.; 484///; 485/// mu is a location parameter and correspond approximately to the most probable value; 486/// and sigma is a scale parameter (not the sigma of the full distribution which is not defined); 487/// Note that for mu=0 and sigma=1 (default values) the exact location of the maximum of the distribution; 488/// (most proper value) is at x = -0.22278; 489/// This function has been adapted from the CERNLIB routine G110 denlan.; 490/// If norm=kTRUE (default is kFALSE) the result is divided by sigma; 491 ; 492Double_t TMath::Landau(Double_t x, Double_t mu, Double_t sigma, Bool_t norm); 493{; 494 if (sigma <= 0) return 0;; 495 Double_t den = ::ROOT::Math::landau_pdf( (x-mu)/sigma );; 496 if (!norm) return den;; 497 return den/sigma;; 498}; 499 ; 500////////////////////////////////////////////////////////////////////////////////; 501/// Computation of ln[gamma(z)] for all z.; 502///; 503/// C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86.; 504///; 505/// The accuracy of the result is better than 2e-10.; 506///; 507/// \author NvE 14-nov-1998 UU-SAP Utrecht; 508 ; 509Double_t TMath::LnGamma(Double_t z); 510{; 511 return ::ROOT::Math::lgamma(z);; 512}; 513 ; 514////////////////////////////////////////////////////////////////////////////////; 515/// Normalize a vector v in place.; 516/// Returns the norm of the original vector.; 517 ; 518Float_t TMath::Normaliz",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
Performance,perform,perform,"sa;; 763/// ia++;; 764/// ib++;; 765/// if (ia > na) {ok = kTRUE; break;}; 766/// if (ib > nb) {ok = kTRUE; break;}; 767/// }; 768/// rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; 769/// }; 770/// ~~~; 771///; 772/// For the last case, a=b, the algorithm advances each array by one index in an; 773/// attempt to move through the equality. However, this is incorrect when one or; 774/// the other of a or b (or both) have a repeated value, call it x. For the KS; 775/// statistic to be computed properly, rdiff needs to be calculated after all of; 776/// the a and b at x have been tallied (this is due to the definition of the; 777/// empirical distribution function; another way to convince yourself that the; 778/// old CERNLIB method is wrong is that it implies that the function defined as the; 779/// difference between a and b is multi-valued at x -- besides being ugly, this; 780/// would invalidate Kolmogorov's theorem).; 781///; 782/// The solution is to just add while-loops into the equality-case handling to; 783/// perform the tally:; 784///; 785/// ~~~ {.cpp}; 786/// } else {; 787/// double x = a[ia-1];; 788/// while(a[ia-1] == x && ia <= na) {; 789/// rdiff -= sa;; 790/// ia++;; 791/// }; 792/// while(b[ib-1] == x && ib <= nb) {; 793/// rdiff += sb;; 794/// ib++;; 795/// }; 796/// if (ia > na) {ok = kTRUE; break;}; 797/// if (ib > nb) {ok = kTRUE; break;}; 798/// }; 799/// ~~~; 800///; 801/// ### Note:; 802/// A good description of the Kolmogorov test can be seen at:; 803/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; 804 ; 805Double_t TMath::KolmogorovTest(Int_t na, const Double_t *a, Int_t nb, const Double_t *b, Option_t *option); 806{; 807// LM: Nov 2010: clean up and returns now a zero distance when vectors are the same; 808 ; 809 TString opt = option;; 810 opt.ToUpper();; 811 ; 812 Double_t prob = -1;; 813// Require at least two points in each graph; 814 if (!a || !b || na <= 2 || nb <= 2) {; 815 Error(""KolmogorovTest"",""Sets must have more ",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
Safety,avoid,avoid,"42 Double_t xlim0, xlim1, xlim2, xlim3, xlim4; // --x-- on region boundaries; 943 Double_t a0=0, d0=0, d2=0, e0=0, e2=0, e4=0, h0=0, h2=0, h4=0, h6=0;// W4 temporary variables; 944 Double_t p0=0, p2=0, p4=0, p6=0, p8=0, z0=0, z2=0, z4=0, z6=0, z8=0;; 945 Double_t xp[6], xm[6], yp[6], ym[6]; // CPF12 temporary values; 946 Double_t mq[6], pq[6], mf[6], pf[6];; 947 Double_t d, yf, ypy0, ypy0q;; 948 ; 949 //***** Start of executable code *****************************************; 950 ; 951 rg1 = 1; // Set flags; 952 rg2 = 1;; 953 rg3 = 1;; 954 yq = y * y; // y^2; 955 yrrtpi = y * rrtpi; // y/SQRT(pi); 956 ; 957 // Region boundaries when both k and L are required or when R<>4; 958 ; 959 xlim0 = r0 - y;; 960 xlim1 = r1 - y;; 961 xlim3 = 3.097 * y - 0.45;; 962 xlim2 = 6.8 - y;; 963 xlim4 = 18.1 * y + 1.65;; 964 if ( y <= 1e-6 ) { // When y<10^-6 avoid W4 algorithm; 965 xlim1 = xlim0;; 966 xlim2 = xlim0;; 967 }; 968 ; 969 abx = fabs(x); // |x|; 970 xq = abx * abx; // x^2; 971 if ( abx > xlim0 ) { // Region 0 algorithm; 972 k = yrrtpi / (xq + yq);; 973 } else if ( abx > xlim1 ) { // Humlicek W4 Region 1; 974 if ( rg1 != 0 ) { // First point in Region 1; 975 rg1 = 0;; 976 a0 = yq + 0.5; // Region 1 y-dependents; 977 d0 = a0*a0;; 978 d2 = yq + yq - 1.0;; 979 }; 980 d = rrtpi / (d0 + xq*(d2 + xq));; 981 k = d * y * (a0 + xq);; 982 } else if ( abx > xlim2 ) { // Humlicek W4 Region 2; 983 if ( rg2 != 0 ) { // First point in Region 2; 984 rg2 = 0;; 985 h0 = 0.5625 + yq * (4.5 + yq * (10.5 + yq * (6.0 + yq)));; 986 // Region 2 y-dependents; 987 h2 = -4.5 + yq * (9.0 + yq * ( 6.0 + yq * 4.0));; 988 h4 = 10.5 - yq * (6.0 - yq * 6.0);; 989 h6 = -6.0 + yq * 4.0;; 990 e0 = 1.875 + yq * (8.25 + yq * (5.5 + yq));; 991 e2 = 5.25 + yq * (1.0 + yq * 3.0);; 992 e4 = 0.75 * h6;; 993 }; 994 d = rrtpi / (h0 + xq * (h2 + xq * (h4 + xq * (h6 + xq))));; 995 k = d * y * (e0 + xq * (e2 + xq * (e4 + xq)));; 996 } else if ( abx < xlim3 ) { // Humlicek W4 Region 3; 997 if ( rg3 != 0 ) { // First point i",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
Security,hash,hash,"l2-1];; 1335 localArr2[iEl2-1] = localArr2[iEl2];; 1336 localArr2[iEl2] = tmp2;; 1337 }; 1338 }; 1339 }; 1340 ; 1341 for (iEl = 0; iEl < Narr; iEl++) {; 1342 arr2[iEl] = localArr2[iEl];; 1343 }; 1344 delete [] localArr2;; 1345 delete [] localArr1;; 1346}; 1347 ; 1348////////////////////////////////////////////////////////////////////////////////; 1349/// Opposite ordering of the array arr2[] to that of BubbleHigh.; 1350///; 1351/// \author Adrian Bevan (bevan@slac.stanford.edu); 1352 ; 1353void TMath::BubbleLow(Int_t Narr, Double_t *arr1, Int_t *arr2); 1354{; 1355 if (Narr <= 0) return;; 1356 double *localArr1 = new double[Narr];; 1357 int *localArr2 = new int[Narr];; 1358 int iEl;; 1359 int iEl2;; 1360 ; 1361 for (iEl = 0; iEl < Narr; iEl++) {; 1362 localArr1[iEl] = arr1[iEl];; 1363 localArr2[iEl] = iEl;; 1364 }; 1365 ; 1366 for (iEl = 0; iEl < Narr; iEl++) {; 1367 for (iEl2 = Narr-1; iEl2 > iEl; --iEl2) {; 1368 if (localArr1[iEl2-1] > localArr1[iEl2]) {; 1369 double tmp = localArr1[iEl2-1];; 1370 localArr1[iEl2-1] = localArr1[iEl2];; 1371 localArr1[iEl2] = tmp;; 1372 ; 1373 int tmp2 = localArr2[iEl2-1];; 1374 localArr2[iEl2-1] = localArr2[iEl2];; 1375 localArr2[iEl2] = tmp2;; 1376 }; 1377 }; 1378 }; 1379 ; 1380 for (iEl = 0; iEl < Narr; iEl++) {; 1381 arr2[iEl] = localArr2[iEl];; 1382 }; 1383 delete [] localArr2;; 1384 delete [] localArr1;; 1385}; 1386 ; 1387 ; 1388////////////////////////////////////////////////////////////////////////////////; 1389/// Calculates hash index from any char string.; 1390/// Based on pre-calculated table of 256 specially selected numbers.; 1391/// These numbers are selected in such a way, that for string; 1392/// length == 4 (integer number) the hash is unambiguous, i.e.; 1393/// from hash value we can recalculate input (no degeneration).; 1394///; 1395/// The quality of hash method is good enough, that; 1396/// ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); 1397/// tested by `<R>`, `<R*R>`, `<Ri*Ri+1>` gives the same resu",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
Testability,log,log," a,Double_t x);; 42 Double_t GamSer(Double_t a,Double_t x);; 43 Double_t VavilovDenEval(Double_t rlam, Double_t *AC, Double_t *HC, Int_t itype);; 44 void VavilovSet(Double_t rkappa, Double_t beta2, Bool_t mode, Double_t *WCM, Double_t *AC, Double_t *HC, Int_t &itype, Int_t &npt);; 45 ; 46}; 47 ; 48////////////////////////////////////////////////////////////////////////////////; 49/// Returns `sqrt(x*x + y*y)`; 50 ; 51Long_t TMath::Hypot(Long_t x, Long_t y); 52{; 53 return (Long_t) (hypot((Double_t)x, (Double_t)y) + 0.5);; 54}; 55 ; 56////////////////////////////////////////////////////////////////////////////////; 57/// Returns `sqrt(x*x + y*y)`; 58 ; 59Double_t TMath::Hypot(Double_t x, Double_t y); 60{; 61 return hypot(x, y);; 62}; 63 ; 64////////////////////////////////////////////////////////////////////////////////; 65/// Returns the area hyperbolic sine of `x`.; 66 ; 67Double_t TMath::ASinH(Double_t x); 68{; 69#if defined(WIN32); 70 if(x==0.0) return 0.0;; 71 Double_t ax = Abs(x);; 72 return log(x+ax*sqrt(1.+1./(ax*ax)));; 73#else; 74 return asinh(x);; 75#endif; 76}; 77 ; 78////////////////////////////////////////////////////////////////////////////////; 79/// Returns the nonnegative area hyperbolic cosine of `x`.; 80 ; 81Double_t TMath::ACosH(Double_t x); 82{; 83#if defined(WIN32); 84 if(x==0.0) return 0.0;; 85 Double_t ax = Abs(x);; 86 return log(x+ax*sqrt(1.-1./(ax*ax)));; 87#else; 88 return acosh(x);; 89#endif; 90}; 91 ; 92////////////////////////////////////////////////////////////////////////////////; 93/// Returns the area hyperbolic tangent of `x`.; 94 ; 95Double_t TMath::ATanH(Double_t x); 96{; 97#if defined(WIN32); 98 return log((1+x)/(1-x))/2;; 99#else; 100 return atanh(x);; 101#endif; 102}; 103 ; 104////////////////////////////////////////////////////////////////////////////////; 105/// Returns the binary (base-2) logarithm of `x`.; 106 ; 107Double_t TMath::Log2(Double_t x); 108{; 109 return log(x)/log(2.0);; 110}; 111 ; 112/////////////////////////",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
Availability,error,error,"le_t x);  Rounds x upward, returning the smallest integral value that is not less than x. ;  ; Int_t TMath::CeilNint (Double_t x);  Returns the nearest integer of TMath::Ceil(x). ;  ; Double_t TMath::ChisquareQuantile (Double_t p, Double_t ndf);  Evaluate the quantiles of the chi-squared probability distribution function. ;  ; Double_t TMath::Cos (Double_t);  Returns the cosine of an angle of x radians. ;  ; Double_t TMath::CosH (Double_t);  Returns the hyperbolic cosine of x. ;  ; template<typename T > ; T * TMath::Cross (const T v1[3], const T v2[3], T out[3]);  Calculates the Cross Product of two vectors: out = [v1 x v2]. ;  ; constexpr Double_t TMath::CUncertainty ();  Speed of light uncertainty. ;  ; constexpr Double_t TMath::DegToRad ();  Conversion from degree to radian: \( \frac{\pi}{180} \). ;  ; Double_t TMath::DiLog (Double_t x);  Modified Struve functions of order 1. ;  ; constexpr Double_t TMath::E ();  Base of natural log: \( e \). ;  ; Double_t TMath::Erf (Double_t x);  Computation of the error function erf(x). ;  ; Double_t TMath::Erfc (Double_t x);  Computes the complementary error function erfc(x). ;  ; Double_t TMath::ErfcInverse (Double_t x);  Returns the inverse of the complementary error function. ;  ; Double_t TMath::ErfInverse (Double_t x);  Returns the inverse error function. ;  ; constexpr Double_t TMath::EulerGamma ();  Euler-Mascheroni Constant. ;  ; Double_t TMath::Exp (Double_t x);  Returns the base-e exponential function of x, which is e raised to the power x. ;  ; Double_t TMath::Factorial (Int_t i);  Computes factorial(n). ;  ; Double_t TMath::FDist (Double_t F, Double_t N, Double_t M);  Computes the density function of F-distribution (probability function, integral of density, is computed in FDistI). ;  ; Double_t TMath::FDistI (Double_t F, Double_t N, Double_t M);  Calculates the cumulative distribution function of F-distribution (see ROOT::Math::fdistribution_cdf). ;  ; Int_t TMath::Finite (Double_t x);  Check if it is finite with",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
Energy Efficiency,power,power,"he hyperbolic cosine of x. ;  ; template<typename T > ; T * TMath::Cross (const T v1[3], const T v2[3], T out[3]);  Calculates the Cross Product of two vectors: out = [v1 x v2]. ;  ; constexpr Double_t TMath::CUncertainty ();  Speed of light uncertainty. ;  ; constexpr Double_t TMath::DegToRad ();  Conversion from degree to radian: \( \frac{\pi}{180} \). ;  ; Double_t TMath::DiLog (Double_t x);  Modified Struve functions of order 1. ;  ; constexpr Double_t TMath::E ();  Base of natural log: \( e \). ;  ; Double_t TMath::Erf (Double_t x);  Computation of the error function erf(x). ;  ; Double_t TMath::Erfc (Double_t x);  Computes the complementary error function erfc(x). ;  ; Double_t TMath::ErfcInverse (Double_t x);  Returns the inverse of the complementary error function. ;  ; Double_t TMath::ErfInverse (Double_t x);  Returns the inverse error function. ;  ; constexpr Double_t TMath::EulerGamma ();  Euler-Mascheroni Constant. ;  ; Double_t TMath::Exp (Double_t x);  Returns the base-e exponential function of x, which is e raised to the power x. ;  ; Double_t TMath::Factorial (Int_t i);  Computes factorial(n). ;  ; Double_t TMath::FDist (Double_t F, Double_t N, Double_t M);  Computes the density function of F-distribution (probability function, integral of density, is computed in FDistI). ;  ; Double_t TMath::FDistI (Double_t F, Double_t N, Double_t M);  Calculates the cumulative distribution function of F-distribution (see ROOT::Math::fdistribution_cdf). ;  ; Int_t TMath::Finite (Double_t x);  Check if it is finite with a mask in order to be consistent in presence of fast math. ;  ; Int_t TMath::Finite (Float_t x);  Check if it is finite with a mask in order to be consistent in presence of fast math. ;  ; Double_t TMath::Floor (Double_t x);  Rounds x downward, returning the largest integral value that is not greater than x. ;  ; Int_t TMath::FloorNint (Double_t x);  Returns the nearest integer of TMath::Floor(x). ;  ; Double_t TMath::Freq (Double_t x);  Computation ",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
Integrability,depend,dependency,". ROOT: math/mathcore/inc/TMath.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Functions ; TMath.h File Reference. #include ""TMathBase.h""; #include ""TError.h""; #include <algorithm>; #include <limits>; #include <cmath>; #include <cfloat>. Include dependency graph for TMath.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  TMath::Limits< T >;  . Namespaces; namespace  TMath;  TMath. ;  . Functions; Double_t TMath::ACos (Double_t);  Returns the principal value of the arc cosine of x, expressed in radians. ;  ; Double_t TMath::ACosH (Double_t);  Returns the nonnegative area hyperbolic cosine of x. ;  ; Bool_t TMath::AreEqualAbs (Double_t af, Double_t bf, Double_t epsilon);  Comparing floating points. ;  ; Bool_t TMath::AreEqualRel (Double_t af, Double_t bf, Double_t relPrec);  Comparing floating points. ;  ; Double_t TMath::ASin (Double_t);  Returns the principal value of the arc sine of x, expressed in radians. ;  ; Double_t TMath::ASinH (Double_t);  Returns the area hyperbolic sine of x. ;  ; Double_t TMath::ATan (Double_t);  Returns the principal value of the arc tangent of x, expressed in radians. ;  ; Double_t TMath::ATan2 (Double_t y, Double_t x);  Returns the principal value of the arc tangent of y/x, expressed in radians. ;  ; Double_t TMath::ATanH (Double_t);  Returns the area hyperbolic tangent of x. ;  ; Double_t TMath::BesselI (Int_t n, Double_t x);  Computes the Integer Order Modified Bessel function I_n(x) for n=0,1,2,... and any real x. ;  ; Double_t TMath::BesselI0 (Double_t x);  Integer order modified Bessel function K_n(x) ;  ; Double_t TMath::BesselI1 (Double_t x);  Modified Bessel function K_0(x) ;  ; Double_t TMath::BesselJ0 (Double_t x);  Modified Bessel function K_1(x) ;  ; Double_t TMath::BesselJ1 (Double_t x);  Bessel function J0(x) for any real x. ;  ; Double_t TMath::BesselK (Int_t n, Double_t x);  Integer order m",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
Modifiability,adapt,adapted,"onstexpr Double_t TMath::Na ();  Avogadro constant (Avogadro's Number) in \( mol^{-1} \). ;  ; constexpr Double_t TMath::NaUncertainty ();  Avogadro constant (Avogadro's Number) uncertainty. ;  ; template<typename T > ; Int_t TMath::Nint (T x);  Round to nearest integer. Rounds half integers to the nearest even integer. ;  ; template<typename T > ; T * TMath::Normal2Plane (const T v1[3], const T v2[3], const T v3[3], T normal[3]);  Calculates a normal vector of a plane. ;  ; Double_t TMath::Normalize (Double_t v[3]);  Normalize a vector v in place. ;  ; Float_t TMath::Normalize (Float_t v[3]);  Normalize a vector v in place. ;  ; template<typename T > ; T TMath::NormCross (const T v1[3], const T v2[3], T out[3]);  Calculates the Normalized Cross Product of two vectors. ;  ; Double_t TMath::NormQuantile (Double_t p);  Computes quantiles for standard normal distribution N(0, 1) at probability p. ;  ; Bool_t TMath::Permute (Int_t n, Int_t *a);  Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinct adapted from CERNLIB routine PERMU. ;  ; constexpr Double_t TMath::Pi ();  \( \pi\) ;  ; constexpr Double_t TMath::PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t TMath::PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t TMath::Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t TMath::PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t TMath::Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Prob (Double_t",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
Security,hash,hash,"ian function with mean and sigma. ;  ; constexpr Double_t TMath::Gcgs ();  \( cm^{3} g^{-1} s^{-2} \) ;  ; template<typename Iterator > ; Double_t TMath::GeomMean (Iterator first, Iterator last);  Returns the geometric mean of an array defined by the iterators. ;  ; template<typename T > ; Double_t TMath::GeomMean (Long64_t n, const T *a);  Returns the geometric mean of an array a of size n. ;  ; constexpr Double_t TMath::GhbarC ();  \( \frac{G}{\hbar C} \) in \( (GeV/c^{2})^{-2} \) ;  ; constexpr Double_t TMath::GhbarCUncertainty ();  \( \frac{G}{\hbar C} \) uncertainty. ;  ; constexpr Double_t TMath::Gn ();  Standard acceleration of gravity in \( m s^{-2} \). ;  ; constexpr Double_t TMath::GnUncertainty ();  Standard acceleration of gravity uncertainty. ;  ; constexpr Double_t TMath::GUncertainty ();  Gravitational constant uncertainty. ;  ; constexpr Double_t TMath::H ();  Planck's constant in \( J s \): \( h \). ;  ; ULong_t TMath::Hash (const char *str);  ; ULong_t TMath::Hash (const void *txt, Int_t ntxt);  Calculates hash index from any char string. ;  ; constexpr Double_t TMath::Hbar ();  \( \hbar \) in \( J s \): \( \hbar = \frac{h}{2\pi} \) ;  ; constexpr Double_t TMath::Hbarcgs ();  \( erg s \) ;  ; constexpr Double_t TMath::HbarUncertainty ();  \( \hbar \) uncertainty. ;  ; constexpr Double_t TMath::HC ();  \( hc \) in \( J m \) ;  ; constexpr Double_t TMath::HCcgs ();  \( erg cm \) ;  ; constexpr Double_t TMath::Hcgs ();  \( erg s \) ;  ; constexpr Double_t TMath::HUncertainty ();  Planck's constant uncertainty. ;  ; Double_t TMath::Hypot (Double_t x, Double_t y);  Returns sqrt(x*x + y*y) ;  ; Long_t TMath::Hypot (Long_t x, Long_t y);  Returns sqrt(x*x + y*y) ;  ; Double_t TMath::Infinity ();  Returns an infinity as defined by the IEEE standard. ;  ; constexpr Double_t TMath::InvPi ();  \( \frac{1.}{\pi}\) ;  ; template<typename T > ; Bool_t TMath::IsInside (T xp, T yp, Int_t np, T *x, T *y);  Function which returns kTRUE if point xp,yp lies inside the p",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
Testability,log,log,"r Double_t TMath::Ccgs ();  \( cm s^{-1} \) ;  ; Double_t TMath::Ceil (Double_t x);  Rounds x upward, returning the smallest integral value that is not less than x. ;  ; Int_t TMath::CeilNint (Double_t x);  Returns the nearest integer of TMath::Ceil(x). ;  ; Double_t TMath::ChisquareQuantile (Double_t p, Double_t ndf);  Evaluate the quantiles of the chi-squared probability distribution function. ;  ; Double_t TMath::Cos (Double_t);  Returns the cosine of an angle of x radians. ;  ; Double_t TMath::CosH (Double_t);  Returns the hyperbolic cosine of x. ;  ; template<typename T > ; T * TMath::Cross (const T v1[3], const T v2[3], T out[3]);  Calculates the Cross Product of two vectors: out = [v1 x v2]. ;  ; constexpr Double_t TMath::CUncertainty ();  Speed of light uncertainty. ;  ; constexpr Double_t TMath::DegToRad ();  Conversion from degree to radian: \( \frac{\pi}{180} \). ;  ; Double_t TMath::DiLog (Double_t x);  Modified Struve functions of order 1. ;  ; constexpr Double_t TMath::E ();  Base of natural log: \( e \). ;  ; Double_t TMath::Erf (Double_t x);  Computation of the error function erf(x). ;  ; Double_t TMath::Erfc (Double_t x);  Computes the complementary error function erfc(x). ;  ; Double_t TMath::ErfcInverse (Double_t x);  Returns the inverse of the complementary error function. ;  ; Double_t TMath::ErfInverse (Double_t x);  Returns the inverse error function. ;  ; constexpr Double_t TMath::EulerGamma ();  Euler-Mascheroni Constant. ;  ; Double_t TMath::Exp (Double_t x);  Returns the base-e exponential function of x, which is e raised to the power x. ;  ; Double_t TMath::Factorial (Int_t i);  Computes factorial(n). ;  ; Double_t TMath::FDist (Double_t F, Double_t N, Double_t M);  Computes the density function of F-distribution (probability function, integral of density, is computed in FDistI). ;  ; Double_t TMath::FDistI (Double_t F, Double_t N, Double_t M);  Calculates the cumulative distribution function of F-distribution (see ROOT::Math::fdistributi",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
Availability,down,downward,"rn 0;; 649 if (y > 0) return Pi()/2;; 650 else return -Pi()/2;; 651 }; 652 ; 653////////////////////////////////////////////////////////////////////////////////; 654/// Returns `x*x`.; 655 ; 656inline Double_t TMath::Sq(Double_t x); 657 { return x*x; }; 658 ; 659////////////////////////////////////////////////////////////////////////////////; 660/// Returns the square root of x.; 661 ; 662inline Double_t TMath::Sqrt(Double_t x); 663 { return sqrt(x); }; 664 ; 665////////////////////////////////////////////////////////////////////////////////; 666/// Rounds `x` upward, returning the smallest integral value that is not less than `x`.; 667 ; 668inline Double_t TMath::Ceil(Double_t x); 669 { return ceil(x); }; 670 ; 671////////////////////////////////////////////////////////////////////////////////; 672/// Returns the nearest integer of `TMath::Ceil(x)`.; 673 ; 674inline Int_t TMath::CeilNint(Double_t x); 675 { return TMath::Nint(ceil(x)); }; 676 ; 677////////////////////////////////////////////////////////////////////////////////; 678/// Rounds `x` downward, returning the largest integral value that is not greater than `x`.; 679 ; 680inline Double_t TMath::Floor(Double_t x); 681 { return floor(x); }; 682 ; 683////////////////////////////////////////////////////////////////////////////////; 684/// Returns the nearest integer of `TMath::Floor(x)`.; 685 ; 686inline Int_t TMath::FloorNint(Double_t x); 687 { return TMath::Nint(floor(x)); }; 688 ; 689////////////////////////////////////////////////////////////////////////////////; 690/// Round to nearest integer. Rounds half integers to the nearest even integer.; 691 ; 692template<typename T>; 693inline Int_t TMath::Nint(T x); 694{; 695 int i;; 696 if (x >= 0) {; 697 i = int(x + 0.5);; 698 if ( i & 1 && x + 0.5 == T(i) ) i--;; 699 } else {; 700 i = int(x - 0.5);; 701 if ( i & 1 && x - 0.5 == T(i) ) i++;; 702 }; 703 return i;; 704}; 705 ; 706////////////////////////////////////////////////////////////////////////////////; 707",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
Energy Efficiency,charge,charge,11 return R() * ((KUncertainty() / K()) + (NaUncertainty() / Na()));; 312}; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// [Molecular weight of dry air 1976 US Standard Atmosphere](http://atmos.nmsu.edu/jsdap/encyclopediawork.html); 316/// in \f$ kg kmol^{-1} \f$ or \f$ gm mol^{-1} \f$; 317constexpr Double_t MWair(); 318{; 319 return 28.9644;; 320}; 321 ; 322////////////////////////////////////////////////////////////////////////////////; 323/// [Dry Air Gas Constant (R / MWair)](http://atmos.nmsu.edu/education_and_outreach/encyclopedia/gas_constant.htm); 324/// in \f$ J kg^{-1} K^{-1} \f$; 325constexpr Double_t Rgair(); 326{; 327 return (1000.0 * R()) / MWair();; 328}; 329 ; 330////////////////////////////////////////////////////////////////////////////////; 331/// Euler-Mascheroni Constant.; 332constexpr Double_t EulerGamma(); 333{; 334 return 0.577215664901532860606512090082402431042;; 335}; 336 ; 337////////////////////////////////////////////////////////////////////////////////; 338/// Elementary charge in \f$ C \f$ .; 339constexpr Double_t Qe(); 340{; 341 return 1.602176634e-19;; 342}; 343 ; 344////////////////////////////////////////////////////////////////////////////////; 345/// Elementary charge uncertainty.; 346constexpr Double_t QeUncertainty(); 347{; 348 // constant is exact according to 2019 redefinition; 349 // (https://en.wikipedia.org/wiki/2019_redefinition_of_the_SI_base_units); 350 return 0.0;; 351}; 352 ; 353////////////////////////////////////////////////////////////////////////////////; 354// Mathematical Functions; 355 ; 356////////////////////////////////////////////////////////////////////////////////; 357// Trigonometrical Functions; 358 ; 359inline Double_t Sin(Double_t);; 360inline Double_t Cos(Double_t);; 361inline Double_t Tan(Double_t);; 362inline Double_t SinH(Double_t);; 363inline Double_t CosH(Double_t);; 364inline Double_t TanH(Double_t);; 365inline Double_t ASin(Double_t);; 366inl,MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
Integrability,rout,routines,"0LL;; 775 union { unsigned long long l; double d;} v;; 776 v.d =x;; 777 return (v.l&mask)!=mask;; 778}; 779#else; 780# if defined(R__HPUX11); 781 { return isfinite(x); }; 782# elif defined(R__MACOSX); 783# ifdef isfinite; 784 // from math.h; 785 { return isfinite(x); }; 786# else; 787 // from cmath; 788 { return std::isfinite(x); }; 789# endif; 790# else; 791 { return finite(x); }; 792# endif; 793#endif; 794 ; 795////////////////////////////////////////////////////////////////////////////////; 796/// Check if it is finite with a mask in order to be consistent in presence of; 797/// fast math.; 798/// Inspired from the CMSSW FWCore/Utilities package; 799 ; 800inline Int_t TMath::Finite(Float_t x); 801#if defined(R__FAST_MATH); 802 ; 803{; 804 const unsigned int mask = 0x7f800000;; 805 union { unsigned int l; float d;} v;; 806 v.d =x;; 807 return (v.l&mask)!=mask;; 808}; 809#else; 810{ return std::isfinite(x); }; 811#endif; 812 ; 813// This namespace provides all the routines necessary for checking if a number; 814// is a NaN also in presence of optimisations affecting the behaviour of the; 815// floating point calculations.; 816// Inspired from the CMSSW FWCore/Utilities package; 817 ; 818#if defined (R__FAST_MATH); 819namespace ROOT {; 820namespace Internal {; 821namespace Math {; 822// abridged from GNU libc 2.6.1 - in detail from; 823// math/math_private.h; 824// sysdeps/ieee754/ldbl-96/math_ldbl.h; 825 ; 826// part of this file:; 827 /*; 828 * ====================================================; 829 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.; 830 *; 831 * Developed at SunPro, a Sun Microsystems, Inc. business.; 832 * Permission to use, copy, modify, and distribute this; 833 * software is freely granted, provided that this notice; 834 * is preserved.; 835 * ====================================================; 836 */; 837 ; 838 // A union which permits us to convert between a double and two 32 bit ints.; 839 typedef union {; 840 Double_t ",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
Performance,perform,performing,"ement(Long64_t n, const T *a) {; 961 return *std::min_element(a,a+n);; 962}; 963 ; 964////////////////////////////////////////////////////////////////////////////////; 965/// Returns maximum of array a of length n.; 966 ; 967template <typename T>; 968T TMath::MaxElement(Long64_t n, const T *a) {; 969 return *std::max_element(a,a+n);; 970}; 971 ; 972////////////////////////////////////////////////////////////////////////////////; 973/// Returns index of array with the minimum element.; 974/// If more than one element is minimum returns first found.; 975///; 976/// Implement here since this one is found to be faster (mainly on 64 bit machines); 977/// than stl generic implementation.; 978/// When performing the comparison, the STL implementation needs to de-reference both the array iterator; 979/// and the iterator pointing to the resulting minimum location; 980 ; 981template <typename T>; 982Long64_t TMath::LocMin(Long64_t n, const T *a) {; 983 if (n <= 0 || !a) return -1;; 984 T xmin = a[0];; 985 Long64_t loc = 0;; 986 for (Long64_t i = 1; i < n; i++) {; 987 if (xmin > a[i]) {; 988 xmin = a[i];; 989 loc = i;; 990 }; 991 }; 992 return loc;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Returns index of array with the minimum element.; 997/// If more than one element is minimum returns first found.; 998 ; 999template <typename Iterator>; 1000Iterator TMath::LocMin(Iterator first, Iterator last) {; 1001 ; 1002 return std::min_element(first, last);; 1003}; 1004 ; 1005////////////////////////////////////////////////////////////////////////////////; 1006/// Returns index of array with the maximum element.; 1007/// If more than one element is maximum returns first found.; 1008///; 1009/// Implement here since it is faster (see comment in LocMin function); 1010 ; 1011template <typename T>; 1012Long64_t TMath::LocMax(Long64_t n, const T *a) {; 1013 if (n <= 0 || !a) return -1;; 1014 T xmax = a[0];; 1015 Long64_t loc =",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
Safety,avoid,avoid,"; 904 return std::numeric_limits<Double_t>::quiet_NaN();; 905}; 906 ; 907////////////////////////////////////////////////////////////////////////////////; 908/// Returns a signaling NaN as defined by IEEE 754](http://en.wikipedia.org/wiki/NaN#Signaling_NaN).; 909 ; 910inline Double_t TMath::SignalingNaN() {; 911 return std::numeric_limits<Double_t>::signaling_NaN();; 912}; 913 ; 914////////////////////////////////////////////////////////////////////////////////; 915/// Returns an infinity as defined by the IEEE standard.; 916 ; 917inline Double_t TMath::Infinity() {; 918 return std::numeric_limits<Double_t>::infinity();; 919}; 920 ; 921////////////////////////////////////////////////////////////////////////////////; 922/// Returns maximum representation for type T.; 923 ; 924template<typename T>; 925inline T TMath::Limits<T>::Min() {; 926 return (std::numeric_limits<T>::min)(); //N.B. use this signature to avoid class with macro min() on Windows; 927}; 928 ; 929////////////////////////////////////////////////////////////////////////////////; 930/// Returns minimum double representation.; 931 ; 932template<typename T>; 933inline T TMath::Limits<T>::Max() {; 934 return (std::numeric_limits<T>::max)(); //N.B. use this signature to avoid class with macro max() on Windows; 935}; 936 ; 937////////////////////////////////////////////////////////////////////////////////; 938/// Returns minimum double representation.; 939 ; 940template<typename T>; 941inline T TMath::Limits<T>::Epsilon() {; 942 return std::numeric_limits<T>::epsilon();; 943}; 944 ; 945////////////////////////////////////////////////////////////////////////////////; 946// Advanced.; 947 ; 948////////////////////////////////////////////////////////////////////////////////; 949/// Calculates the Normalized Cross Product of two vectors.; 950 ; 951template <typename T> inline T TMath::NormCross(const T v1[3],const T v2[3],T out[3]); 952{; 953 return Normalize(Cross(v1,v2,out));; 954}; 955 ; 956///////////////////",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
Security,hash,hash,"uble_t par)Computes the Discrete Poisson distribution function for (x,par).Definition TMath.cxx:615; TMath::CauchyDistDouble_t CauchyDist(Double_t x, Double_t t=0, Double_t s=1)Computes the density of Cauchy distribution at point x by default, standard Cauchy distribution is us...Definition TMath.cxx:2175; TMath::ATanDouble_t ATan(Double_t)Returns the principal value of the arc tangent of x, expressed in radians.Definition TMath.h:640; TMath::StruveL1Double_t StruveL1(Double_t x)Modified Struve functions of order 0.Definition TMath.cxx:1970; TMath::Gnconstexpr Double_t Gn()Standard acceleration of gravity in .Definition TMath.h:174; TMath::ASinHDouble_t ASinH(Double_t)Returns the area hyperbolic sine of x.Definition TMath.cxx:67; TMath::LaplaceDistIDouble_t LaplaceDistI(Double_t x, Double_t alpha=0, Double_t beta=1)Computes the cumulative distribution function (lower tail integral) of Laplace distribution at point ...Definition TMath.cxx:2380; TMath::HashULong_t Hash(const void *txt, Int_t ntxt)Calculates hash index from any char string.Definition TMath.cxx:1408; TMath::QeUncertaintyconstexpr Double_t QeUncertainty()Elementary charge uncertainty.Definition TMath.h:346; TMath::Kconstexpr Double_t K()Boltzmann's constant in : .Definition TMath.h:247; TMath::BreitWignerDouble_t BreitWigner(Double_t x, Double_t mean=0, Double_t gamma=1)Calculates a Breit Wigner function with mean and gamma.Definition TMath.cxx:442; TMath::Sqrt2constexpr Double_t Sqrt2()Definition TMath.h:86; TMath::KUncertaintyconstexpr Double_t KUncertainty()Boltzmann's constant uncertainty.Definition TMath.h:261; TMath::Hbarcgsconstexpr Double_t Hbarcgs()Definition TMath.h:218; TMath::LandauDouble_t Landau(Double_t x, Double_t mpv=0, Double_t sigma=1, Bool_t norm=kFALSE)The LANDAU function.Definition TMath.cxx:492; TMath::VoigtDouble_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r=4)Computation of Voigt function (normalised).Definition TMath.cxx:898; TMath::StudentDouble_t Student(Double_t T, ",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
Testability,log,log,///////////////; 57/// \f$ \frac{\pi}{4} \f$; 58constexpr Double_t PiOver4(); 59{; 60 return Pi() / 4.0;; 61}; 62 ; 63////////////////////////////////////////////////////////////////////////////////; 64/// \f$ \frac{1.}{\pi}\f$; 65constexpr Double_t InvPi(); 66{; 67 return 1.0 / Pi();; 68}; 69 ; 70////////////////////////////////////////////////////////////////////////////////; 71/// Conversion from radian to degree: \f$ \frac{180}{\pi} \f$; 72constexpr Double_t RadToDeg(); 73{; 74 return 180.0 / Pi();; 75}; 76 ; 77////////////////////////////////////////////////////////////////////////////////; 78/// Conversion from degree to radian: \f$ \frac{\pi}{180} \f$; 79constexpr Double_t DegToRad(); 80{; 81 return Pi() / 180.0;; 82}; 83 ; 84////////////////////////////////////////////////////////////////////////////////; 85/// \f$ \sqrt{2} \f$; 86constexpr Double_t Sqrt2(); 87{; 88 return 1.4142135623730950488016887242097;; 89}; 90 ; 91////////////////////////////////////////////////////////////////////////////////; 92/// Base of natural log: \f$ e \f$; 93constexpr Double_t E(); 94{; 95 return 2.71828182845904523536;; 96}; 97 ; 98////////////////////////////////////////////////////////////////////////////////; 99/// Natural log of 10 (to convert log to ln); 100constexpr Double_t Ln10(); 101{; 102 return 2.30258509299404568402;; 103}; 104 ; 105////////////////////////////////////////////////////////////////////////////////; 106/// Base-10 log of e (to convert ln to log); 107constexpr Double_t LogE(); 108{; 109 return 0.43429448190325182765;; 110}; 111 ; 112////////////////////////////////////////////////////////////////////////////////; 113/// Velocity of light in \f$ m s^{-1} \f$; 114constexpr Double_t C(); 115{; 116 return 2.99792458e8;; 117}; 118 ; 119////////////////////////////////////////////////////////////////////////////////; 120/// \f$ cm s^{-1} \f$; 121constexpr Double_t Ccgs(); 122{; 123 return 100.0 * C();; 124}; 125 ; 126/////////////////////////////////////////,MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
Integrability,depend,dependency,". ROOT: math/matrix/inc/TMatrixDBasefwd.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Typedefs ; TMatrixDBasefwd.h File Reference. #include ""RtypesCore.h"". Include dependency graph for TMatrixDBasefwd.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Typedefs; typedef TMatrixTBase< Double_t > TMatrixDBase;  . Typedef Documentation. ◆ TMatrixDBase. typedef TMatrixTBase<Double_t> TMatrixDBase. Definition at line 26 of file TMatrixDBasefwd.h. mathmatrixincTMatrixDBasefwd.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMatrixDBasefwd_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixDBasefwd_8h.html
Integrability,depend,dependency,". ROOT: math/matrix/inc/TMatrixDSymfwd.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Typedefs ; TMatrixDSymfwd.h File Reference. #include ""RtypesCore.h"". Include dependency graph for TMatrixDSymfwd.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Typedefs; typedef TMatrixTSym< Double_t > TMatrixDSym;  . Typedef Documentation. ◆ TMatrixDSym. typedef TMatrixTSym<Double_t> TMatrixDSym. Definition at line 23 of file TMatrixDSymfwd.h. mathmatrixincTMatrixDSymfwd.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMatrixDSymfwd_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixDSymfwd_8h.html
Integrability,depend,dependency,". ROOT: math/matrix/inc/TMatrixFBasefwd.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Typedefs ; TMatrixFBasefwd.h File Reference. #include ""RtypesCore.h"". Include dependency graph for TMatrixFBasefwd.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Typedefs; typedef TMatrixTBase< Float_t > TMatrixFBase;  . Typedef Documentation. ◆ TMatrixFBase. typedef TMatrixTBase<Float_t> TMatrixFBase. Definition at line 26 of file TMatrixFBasefwd.h. mathmatrixincTMatrixFBasefwd.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMatrixFBasefwd_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixFBasefwd_8h.html
Availability,toler,tolerance,"osed, kInverted and kAtA.; 117 ; 118template <class Element>; 119TMatrixT<Element>::TMatrixT(EMatrixCreatorsOp1 op, const TMatrixT<Element> &prototype); 120{; 121 R__ASSERT(prototype.IsValid());; 122 ; 123 switch (op) {; 124 case kZero:; 125 Allocate(prototype.GetNrows(), prototype.GetNcols(), prototype.GetRowLwb(), prototype.GetColLwb(), 1);; 126 break;; 127 ; 128 case kUnit:; 129 Allocate(prototype.GetNrows(), prototype.GetNcols(), prototype.GetRowLwb(), prototype.GetColLwb(), 1);; 130 this->UnitMatrix();; 131 break;; 132 ; 133 case kTransposed:; 134 Allocate(prototype.GetNcols(), prototype.GetNrows(), prototype.GetColLwb(), prototype.GetRowLwb());; 135 Transpose(prototype);; 136 break;; 137 ; 138 case kInverted: {; 139 Allocate(prototype.GetNrows(), prototype.GetNcols(), prototype.GetRowLwb(), prototype.GetColLwb(), 1);; 140 *this = prototype;; 141 // Since the user can not control the tolerance of this newly created matrix; 142 // we put it to the smallest possible number; 143 const Element oldTol = this->SetTol(std::numeric_limits<Element>::min());; 144 this->Invert();; 145 this->SetTol(oldTol);; 146 break;; 147 }; 148 ; 149 case kAtA:; 150 Allocate(prototype.GetNcols(), prototype.GetNcols(), prototype.GetColLwb(), prototype.GetColLwb(), 1);; 151 TMult(prototype, prototype);; 152 break;; 153 ; 154 default: Error(""TMatrixT(EMatrixCreatorOp1)"", ""operation %d not yet implemented"", op);; 155 }; 156}; 157 ; 158////////////////////////////////////////////////////////////////////////////////; 159/// Constructor of matrix applying a specific operation to two prototypes.; 160/// Example: TMatrixT<Element> a(10,12), b(12,5); ...; TMatrixT<Element> c(a, TMatrixT::kMult, b);; 161/// Supported operations are: kMult (a*b), kTransposeMult (a'*b), kInvMult (a^(-1)*b);; 162/// Whenever kInvMult is invoked and b is not squared, additional memory is allocated for a^(-1); 163 ; 164template <class Element>; 165TMatrixT<Element>::TMatrixT(const TMatrixT<Element> &a, EMatrixCreatorsOp",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
Energy Efficiency,allocate,allocated,"ype;; 141 // Since the user can not control the tolerance of this newly created matrix; 142 // we put it to the smallest possible number; 143 const Element oldTol = this->SetTol(std::numeric_limits<Element>::min());; 144 this->Invert();; 145 this->SetTol(oldTol);; 146 break;; 147 }; 148 ; 149 case kAtA:; 150 Allocate(prototype.GetNcols(), prototype.GetNcols(), prototype.GetColLwb(), prototype.GetColLwb(), 1);; 151 TMult(prototype, prototype);; 152 break;; 153 ; 154 default: Error(""TMatrixT(EMatrixCreatorOp1)"", ""operation %d not yet implemented"", op);; 155 }; 156}; 157 ; 158////////////////////////////////////////////////////////////////////////////////; 159/// Constructor of matrix applying a specific operation to two prototypes.; 160/// Example: TMatrixT<Element> a(10,12), b(12,5); ...; TMatrixT<Element> c(a, TMatrixT::kMult, b);; 161/// Supported operations are: kMult (a*b), kTransposeMult (a'*b), kInvMult (a^(-1)*b);; 162/// Whenever kInvMult is invoked and b is not squared, additional memory is allocated for a^(-1); 163 ; 164template <class Element>; 165TMatrixT<Element>::TMatrixT(const TMatrixT<Element> &a, EMatrixCreatorsOp2 op, const TMatrixT<Element> &b); 166{; 167 R__ASSERT(a.IsValid());; 168 R__ASSERT(b.IsValid());; 169 ; 170 switch (op) {; 171 case kMult:; 172 Allocate(a.GetNrows(), b.GetNcols(), a.GetRowLwb(), b.GetColLwb(), 1);; 173 Mult(a, b);; 174 break;; 175 ; 176 case kTransposeMult:; 177 Allocate(a.GetNcols(), b.GetNcols(), a.GetColLwb(), b.GetColLwb(), 1);; 178 TMult(a, b);; 179 break;; 180 ; 181 case kMultTranspose:; 182 Allocate(a.GetNrows(), b.GetNrows(), a.GetRowLwb(), b.GetRowLwb(), 1);; 183 MultT(a, b);; 184 break;; 185 ; 186 case kInvMult: {; 187 Allocate(a.GetNrows(), b.GetNcols(), a.GetRowLwb(), b.GetColLwb(), 1);; 188 // if size(a) == size(b), perform in place computation; 189 if (a.GetNrows() == b.GetNcols()) {; 190 *this = a;; 191 const Element oldTol = this->SetTol(std::numeric_limits<Element>::min());; 192 this->Invert();; 193 this->S",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
Integrability,rout,routine,"m(CblasRowMajor, CblasRight, CblasUpper, fNrows, fNcols, 1.0, bp, b.GetNcols(), ap, a.GetNcols(), 0.0,; 772 cp, fNcols);; 773 else if (typeid(Element) != typeid(Float_t)); 774 cblas_ssymm(CblasRowMajor, CblasRight, CblasUpper, fNrows, fNcols, 1.0, bp, b.GetNcols(), ap, a.GetNcols(), 0.0,; 775 cp, fNcols);; 776 else; 777 Error(""Mult"", ""type %s not implemented in BLAS library"", typeid(Element));; 778#else; 779 const Int_t na = a.GetNoElements();; 780 const Int_t nb = b.GetNoElements();; 781 const Int_t ncolsa = a.GetNcols();; 782 const Int_t ncolsb = b.GetNcols();; 783 const Element *const ap = a.GetMatrixArray();; 784 const Element *const bp = b.GetMatrixArray();; 785 Element *cp = this->GetMatrixArray();; 786 ; 787 AMultB(ap, na, ncolsa, bp, nb, ncolsb, cp);; 788#endif; 789}; 790 ; 791////////////////////////////////////////////////////////////////////////////////; 792/// Matrix multiplication, with A symmetric and B symmetric.; 793/// (Actually copied for the moment routine for B general); 794/// Replace this matrix with C such that C = A * B.; 795 ; 796template <class Element>; 797void TMatrixT<Element>::Mult(const TMatrixTSym<Element> &a, const TMatrixTSym<Element> &b); 798{; 799 if (gMatrixCheck) {; 800 R__ASSERT(a.IsValid());; 801 R__ASSERT(b.IsValid());; 802 if (a.GetNcols() != b.GetNrows() || a.GetColLwb() != b.GetRowLwb()) {; 803 Error(""Mult"", ""A rows and B columns incompatible"");; 804 return;; 805 }; 806 ; 807 if (this->GetMatrixArray() == a.GetMatrixArray()) {; 808 Error(""Mult"", ""this->GetMatrixArray() == a.GetMatrixArray()"");; 809 return;; 810 }; 811 ; 812 if (this->GetMatrixArray() == b.GetMatrixArray()) {; 813 Error(""Mult"", ""this->GetMatrixArray() == b.GetMatrixArray()"");; 814 return;; 815 }; 816 }; 817 ; 818#ifdef CBLAS; 819 const Element *ap = a.GetMatrixArray();; 820 const Element *bp = b.GetMatrixArray();; 821 Element *cp = this->GetMatrixArray();; 822 if (typeid(Element) == typeid(Double_t)); 823 cblas_dsymm(CblasRowMajor, CblasLeft, CblasUpper, fNr",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
Performance,perform,perform,"TMatrixT<Element> c(a, TMatrixT::kMult, b);; 161/// Supported operations are: kMult (a*b), kTransposeMult (a'*b), kInvMult (a^(-1)*b);; 162/// Whenever kInvMult is invoked and b is not squared, additional memory is allocated for a^(-1); 163 ; 164template <class Element>; 165TMatrixT<Element>::TMatrixT(const TMatrixT<Element> &a, EMatrixCreatorsOp2 op, const TMatrixT<Element> &b); 166{; 167 R__ASSERT(a.IsValid());; 168 R__ASSERT(b.IsValid());; 169 ; 170 switch (op) {; 171 case kMult:; 172 Allocate(a.GetNrows(), b.GetNcols(), a.GetRowLwb(), b.GetColLwb(), 1);; 173 Mult(a, b);; 174 break;; 175 ; 176 case kTransposeMult:; 177 Allocate(a.GetNcols(), b.GetNcols(), a.GetColLwb(), b.GetColLwb(), 1);; 178 TMult(a, b);; 179 break;; 180 ; 181 case kMultTranspose:; 182 Allocate(a.GetNrows(), b.GetNrows(), a.GetRowLwb(), b.GetRowLwb(), 1);; 183 MultT(a, b);; 184 break;; 185 ; 186 case kInvMult: {; 187 Allocate(a.GetNrows(), b.GetNcols(), a.GetRowLwb(), b.GetColLwb(), 1);; 188 // if size(a) == size(b), perform in place computation; 189 if (a.GetNrows() == b.GetNcols()) {; 190 *this = a;; 191 const Element oldTol = this->SetTol(std::numeric_limits<Element>::min());; 192 this->Invert();; 193 this->SetTol(oldTol);; 194 *this *= b;; 195 } else {; 196 TMatrixT<Element> ainv = a;; 197 const Element oldTol = ainv.SetTol(std::numeric_limits<Element>::min());; 198 ainv.Invert();; 199 ainv.SetTol(oldTol);; 200 Mult(ainv, b);; 201 }; 202 break;; 203 }; 204 ; 205 case kPlus: {; 206 Allocate(a.GetNrows(), a.GetNcols(), a.GetRowLwb(), a.GetColLwb(), 1);; 207 Plus(a, b);; 208 break;; 209 }; 210 ; 211 case kMinus: {; 212 Allocate(a.GetNrows(), a.GetNcols(), a.GetRowLwb(), a.GetColLwb(), 1);; 213 Minus(a, b);; 214 break;; 215 }; 216 ; 217 default: Error(""TMatrixT(EMatrixCreatorOp2)"", ""operation %d not yet implemented"", op);; 218 }; 219}; 220 ; 221////////////////////////////////////////////////////////////////////////////////; 222/// Constructor of matrix applying a specific operation to two prot",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
Testability,log,logical,"rixT<Element> target;; 2553 ; 2554 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2555 Error(""operator||(const TMatrixT&,const TMatrixTSym&)"", ""matrices not compatible"");; 2556 return target;; 2557 }; 2558 ; 2559 target.ResizeTo(source1);; 2560 ; 2561 const Element *sp1 = source1.GetMatrixArray();; 2562 const Element *sp2 = source2.GetMatrixArray();; 2563 Element *tp = target.GetMatrixArray();; 2564 const Element *const tp_last = tp + target.GetNoElements();; 2565 while (tp < tp_last); 2566 *tp++ = (*sp1++ != 0.0 || *sp2++ != 0.0);; 2567 ; 2568 return target;; 2569}; 2570 ; 2571////////////////////////////////////////////////////////////////////////////////; 2572/// Logical OR; 2573 ; 2574template <class Element>; 2575TMatrixT<Element> TMatrixTAutoloadOps::operator||(const TMatrixTSym<Element> &source1, const TMatrixT<Element> &source2); 2576{; 2577 return operator||(source2, source1);; 2578}; 2579 ; 2580////////////////////////////////////////////////////////////////////////////////; 2581/// logical operation source1 > source2; 2582 ; 2583template <class Element>; 2584TMatrixT<Element> TMatrixTAutoloadOps::operator>(const TMatrixT<Element> &source1, const TMatrixT<Element> &source2); 2585{; 2586 TMatrixT<Element> target;; 2587 ; 2588 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2589 Error(""operator|(const TMatrixT&,const TMatrixT&)"", ""matrices not compatible"");; 2590 return target;; 2591 }; 2592 ; 2593 target.ResizeTo(source1);; 2594 ; 2595 const Element *sp1 = source1.GetMatrixArray();; 2596 const Element *sp2 = source2.GetMatrixArray();; 2597 Element *tp = target.GetMatrixArray();; 2598 const Element *const tp_last = tp + target.GetNoElements();; 2599 while (tp < tp_last) {; 2600 *tp++ = (*sp1) > (*sp2);; 2601 sp1++;; 2602 sp2++;; 2603 }; 2604 ; 2605 return target;; 2606}; 2607 ; 2608////////////////////////////////////////////////////////////////////////////////; 2609/// logical operation source1 > source2; 2610 ; 2611template <class Elemen",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
Availability,down,download,"; 29 number of parameters.; 30 ; 31 - The include file Minuit.h has been commented as much as possible; 32 using existing comments in the code or the printed documentation; 33 ; 34 - The original Minuit subroutines are now member functions.; 35 ; 36 - Constructors and destructor have been added.; 37 ; 38 - Instead of passing the FCN function in the argument; 39 list, the addresses of this function is stored as pointer; 40 in the data members of the class. This is by far more elegant; 41 and flexible in an interactive environment.; 42 The member function SetFCN can be used to define this pointer.; 43 ; 44 - The ROOT static function Printf is provided to replace all; 45 format statements and to print on currently defined output file.; 46 - The functions SetObjectFit(TObject * obj)/GetObjectFit() can be; 47 used inside the FCN function to set/get a referenced object; 48 instead of using global variables.; 49 ; 50 ; 51## Basic concepts of MINUIT; 52 ; 53The [MINUIT](https://root.cern/download/minuit.pdf); 54package acts on a multiparameter Fortran function to which one; 55must give the generic name <TT>FCN</TT>. In the ROOT implementation,; 56the function <TT>FCN</TT> is defined via the MINUIT SetFCN member function; 57when an Histogram.Fit command is invoked.; 58The value of <TT>FCN</TT> will in general depend on one; 59or more variable parameters.; 60 ; 61To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); 62the Fit function defines the Minuit fitting function as being H1FitChisquare; 63or H1FitLikelihood depending on the options selected.; 64H1FitChisquare; 65calculates the chisquare between the user fitting function (gaussian, polynomial,; 66user defined,etc) and the data for given values of the parameters.; 67It is the task of MINUIT to find those values of the parameters; 68which give the lowest value of chisquare.; 69 ; 70### Basic concepts - The transformation for parameters with limits.; 71 ; 72For variable parameters with limits,",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
Deployability,release,release,"ly fixed parameters; 854 ; 855Int_t TMinuit::GetNumFixedPars() const; 856{; 857 return fNpfix;; 858}; 859 ; 860////////////////////////////////////////////////////////////////////////////////; 861/// returns the number of currently free parameters; 862 ; 863Int_t TMinuit::GetNumFreePars() const; 864{; 865 return fNpar;; 866}; 867 ; 868////////////////////////////////////////////////////////////////////////////////; 869/// returns the total number of parameters that have been defined; 870/// as fixed or free. The constant parameters are not counted.; 871 ; 872Int_t TMinuit::GetNumPars() const; 873{; 874 return fNpar + fNpfix;; 875}; 876 ; 877////////////////////////////////////////////////////////////////////////////////; 878/// invokes the MIGRAD minimizer; 879 ; 880Int_t TMinuit::Migrad(); 881{; 882 Int_t err;; 883 Double_t tmp[1];; 884 tmp[0] = 0;; 885 ; 886 mnexcm( ""MIGRAD"", tmp, 0, err );; 887 ; 888 return err;; 889}; 890 ; 891////////////////////////////////////////////////////////////////////////////////; 892/// release a parameter; 893 ; 894Int_t TMinuit::Release( Int_t parNo); 895{; 896 Int_t err;; 897 Double_t tmp[1];; 898 tmp[0] = parNo+1; //set internal Minuit numbering; 899 ; 900 mnexcm( ""RELEASE"", tmp, 1, err );; 901 ; 902 return err;; 903}; 904 ; 905////////////////////////////////////////////////////////////////////////////////; 906/// To get the n-sigma contour the error def parameter ""up"" has to set to n^2.; 907 ; 908Int_t TMinuit::SetErrorDef( Double_t up ); 909{; 910 Int_t err;; 911 ; 912 mnexcm( ""SET ERRDEF"", &up, 1, err );; 913 ; 914 return err;; 915}; 916 ; 917////////////////////////////////////////////////////////////////////////////////; 918/// To set the address of the minimization function; 919 ; 920void TMinuit::SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); 921{; 922 fFCN = fcn;; 923}; 924 ; 925////////////////////////////////////////////////////////////////////////////////; 926/// Static function called when Se",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
Energy Efficiency,reduce,reduce,,MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
Integrability,depend,depending,"oot/minuit:$Id$; 2// Author: Rene Brun, Frederick James 12/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13/*! \class TMinuit; 14\see Minuit2 for a newer version of this package; 15\ingroup MinuitOld; 16 ; 17Implementation in C++ of the Minuit package written by Fred James.; 18This is a straightforward conversion of the original Fortran version.; 19 ; 20The main changes are:; 21 ; 22 - The variables in the various Minuit labelled common blocks; 23 have been changed to the TMinuit class data members.; 24 ; 25 - The internal arrays with a maximum dimension depending on the; 26 maximum number of parameters are now data members arrays with; 27 a dynamic dimension such that one can fit very large problems; 28 by simply initialising the TMinuit constructor with the maximum; 29 number of parameters.; 30 ; 31 - The include file Minuit.h has been commented as much as possible; 32 using existing comments in the code or the printed documentation; 33 ; 34 - The original Minuit subroutines are now member functions.; 35 ; 36 - Constructors and destructor have been added.; 37 ; 38 - Instead of passing the FCN function in the argument; 39 list, the addresses of this function is stored as pointer; 40 in the data members of the class. This is by far more elegant; 41 and flexible in an interactive environment.; 42 The member function SetFCN can be used to define this pointer.; 43 ; 44 - The ROOT static function Printf is provided to replace all; 45 format statements and to print on currently defined output file.; 46 - The functions SetObjectFit(TObject * obj)/GetObjectFit() can be; 47 used inside the FCN function to set/get a referenced object; ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
Modifiability,variab,variables,". ROOT: math/minuit/src/TMinuit.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMinuit.cxx. Go to the documentation of this file. 1// @(#)root/minuit:$Id$; 2// Author: Rene Brun, Frederick James 12/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13/*! \class TMinuit; 14\see Minuit2 for a newer version of this package; 15\ingroup MinuitOld; 16 ; 17Implementation in C++ of the Minuit package written by Fred James.; 18This is a straightforward conversion of the original Fortran version.; 19 ; 20The main changes are:; 21 ; 22 - The variables in the various Minuit labelled common blocks; 23 have been changed to the TMinuit class data members.; 24 ; 25 - The internal arrays with a maximum dimension depending on the; 26 maximum number of parameters are now data members arrays with; 27 a dynamic dimension such that one can fit very large problems; 28 by simply initialising the TMinuit constructor with the maximum; 29 number of parameters.; 30 ; 31 - The include file Minuit.h has been commented as much as possible; 32 using existing comments in the code or the printed documentation; 33 ; 34 - The original Minuit subroutines are now member functions.; 35 ; 36 - Constructors and destructor have been added.; 37 ; 38 - Instead of passing the FCN function in the argument; 39 list, the addresses of this function is stored as pointer; 40 in the data members of the class. This is by far more elegant; 41 and flexible in an interactive environment.; 42 The member function SetFCN can be used to define this pointer.; 43 ; 44 - The ROOT static function Printf is provided to replace all; 45 format sta",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
Performance,perform,perform,"e user must therefore be aware of the fact that, for example,; 96if he puts limits of \f$(0,10^{10})\f$ on a parameter, then the values \f$0.0\f$; 97and \f$1.0\f$ will be indistinguishable to the accuracy of most machines.; 98 ; 99The transformation also affects the parameter error matrix, of course,; 100so Minuit does a transformation of the error matrix (and the; 101``parabolic'' parameter errors) when there are parameter limits.; 102Users should however realize that the transformation is only a linear; 103approximation, and that it cannot give a meaningful result if one or more; 104parameters is very close to a limit, where; 105\f$\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0\f$.; 106Therefore, it is recommended that:; 107 ; 108 1. Limits on variable parameters should be used only when needed in order; 109to prevent the parameter from taking on unphysical values.; 110 ; 111 2. When a satisfactory minimum has been found using limits, the limits; 112should then be removed if possible, in order to perform or re-perform the; 113error analysis without limits.; 114 ; 115 ; 116### How to get the right answer from MINUIT.; 117 ; 118MINUIT offers the user a choice of several minimization algorithms. The; 119MIGRAD algorithm is in general the best minimizer for; 120nearly all functions. It is a variable-metric method with inexact line; 121search, a stable metric updating scheme, and checks for; 122positive-definiteness. Its main weakness is that it depends heavily on; 123knowledge of the first derivatives, and fails miserably if they are very; 124inaccurate.; 125 ; 126If parameter limits are needed, in spite of the side effects, then the; 127user should be aware of the following techniques to alleviate problems; 128caused by limits:; 129 ; 130#### Getting the right minimum with limits.; 131 ; 132If MIGRAD converges normally to a point where no parameter is near one of; 133its limits, then the existence of limits has probably not prevented MINUIT; 134from f",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
Safety,avoid,avoided,"ihood depending on the options selected.; 64H1FitChisquare; 65calculates the chisquare between the user fitting function (gaussian, polynomial,; 66user defined,etc) and the data for given values of the parameters.; 67It is the task of MINUIT to find those values of the parameters; 68which give the lowest value of chisquare.; 69 ; 70### Basic concepts - The transformation for parameters with limits.; 71 ; 72For variable parameters with limits, MINUIT uses the following; 73transformation:; 74 ; 75\f[; 76P_{\mathrm{int}} = \arcsin; 77 \left( 2\: \frac{P_{\mathrm{ext}}-a}{b-a} - 1 \right); 78P_{\mathrm{ext}} = a + \frac{b - a}{2} \left( \sin P_{\mathrm{int}} + 1 \right); 79\f]; 80 ; 81so that the internal value \f$P_{\mathrm{int}}\f$ can take on any value, while; 82the external value \f$P_{\mathrm{ext}}\f$ can take on values only between the lower; 83limit \f$a\f$ and the upper limit \f$b\f$.; 84Since the transformation is necessarily non-linear, it would transform a; 85nice linear problem into a nasty non-linear one, which is the reason why; 86limits should be avoided if not necessary.; 87In addition, the transformation; 88does require some computer time, so it slows down the computation a little; 89bit, and more importantly, it introduces additional numerical inaccuracy into; 90the problem in addition to what is introduced in the numerical calculation; 91of the FCN value.; 92The effects of non-linearity and numerical roundoff both; 93become more important as the external value gets closer to one of the limits; 94(expressed as the distance to nearest limit divided by distance between limits).; 95The user must therefore be aware of the fact that, for example,; 96if he puts limits of \f$(0,10^{10})\f$ on a parameter, then the values \f$0.0\f$; 97and \f$1.0\f$ will be indistinguishable to the accuracy of most machines.; 98 ; 99The transformation also affects the parameter error matrix, of course,; 100so Minuit does a transformation of the error matrix (and the; 101``parab",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
Testability,log,log,"86/// - fval: The calculated function value.; 787/// - grad: The (optional) vector of first derivatives).; 788///; 789/// The meaning of the parameters par is of course defined by the user,; 790/// who uses the values of those parameters to calculate their function value.; 791/// The starting values must be specified by the user.; 792/// Later values are determined by Minuit as it searches for the minimum; 793/// or performs whatever analysis is requested by the user.; 794///; 795/// Note that this virtual function may be redefined in a class derived from TMinuit.; 796/// The default function calls the function specified in SetFCN; 797///; 798/// Example of Minimisation function:; 799 ; 800Int_t TMinuit::Eval(Int_t npar, Double_t *grad, Double_t &fval, Double_t *par, Int_t flag); 801{; 802/*; 803 if (flag == 1) {; 804 read input data,; 805 calculate any necessary constants, etc.; 806 }; 807 if (flag == 2) {; 808 calculate GRAD, the first derivatives of FVAL; 809 (this is optional); 810 }; 811 Always calculate the value of the function, FVAL,; 812 which is usually a chisquare or log likelihood.; 813 if (iflag == 3) {; 814 will come here only after the fit is finished.; 815 Perform any final calculations, output fitted data, etc.; 816 }; 817*/; 818// See concrete examples in TH1::H1FitChisquare, H1FitLikelihood; 819 ; 820 if (fFCN) (*fFCN)(npar,grad,fval,par,flag);; 821 return 0;; 822}; 823 ; 824////////////////////////////////////////////////////////////////////////////////; 825/// fix a parameter; 826 ; 827Int_t TMinuit::FixParameter( Int_t parNo); 828{; 829 Int_t err;; 830 Double_t tmp[1];; 831 tmp[0] = parNo+1; //set internal Minuit numbering; 832 ; 833 mnexcm( ""FIX"", tmp, 1, err );; 834 ; 835 return err;; 836}; 837 ; 838////////////////////////////////////////////////////////////////////////////////; 839/// return parameter value and error; 840 ; 841Int_t TMinuit::GetParameter( Int_t parNo, Double_t &currentValue, Double_t &currentError ) const; 842{; 843 Int_t er",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
Usability,simpl,simply,"oot/minuit:$Id$; 2// Author: Rene Brun, Frederick James 12/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13/*! \class TMinuit; 14\see Minuit2 for a newer version of this package; 15\ingroup MinuitOld; 16 ; 17Implementation in C++ of the Minuit package written by Fred James.; 18This is a straightforward conversion of the original Fortran version.; 19 ; 20The main changes are:; 21 ; 22 - The variables in the various Minuit labelled common blocks; 23 have been changed to the TMinuit class data members.; 24 ; 25 - The internal arrays with a maximum dimension depending on the; 26 maximum number of parameters are now data members arrays with; 27 a dynamic dimension such that one can fit very large problems; 28 by simply initialising the TMinuit constructor with the maximum; 29 number of parameters.; 30 ; 31 - The include file Minuit.h has been commented as much as possible; 32 using existing comments in the code or the printed documentation; 33 ; 34 - The original Minuit subroutines are now member functions.; 35 ; 36 - Constructors and destructor have been added.; 37 ; 38 - Instead of passing the FCN function in the argument; 39 list, the addresses of this function is stored as pointer; 40 in the data members of the class. This is by far more elegant; 41 and flexible in an interactive environment.; 42 The member function SetFCN can be used to define this pointer.; 43 ; 44 - The ROOT static function Printf is provided to replace all; 45 format statements and to print on currently defined output file.; 46 - The functions SetObjectFit(TObject * obj)/GetObjectFit() can be; 47 used inside the FCN function to set/get a referenced object; ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
Integrability,depend,dependency,". ROOT: math/minuit/inc/TMinuit.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Variables ; TMinuit.h File Reference. #include ""TNamed.h""; #include ""TMethodCall.h"". Include dependency graph for TMinuit.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TMinuit;  . Variables; R__EXTERN TMinuit * gMinuit;  . Variable Documentation. ◆ gMinuit. R__EXTERN TMinuit* gMinuit. Definition at line 271 of file TMinuit.h. mathminuitincTMinuit.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMinuit_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h.html
Availability,error,errors,"Minuit; 21#define ROOT_TMinuit; 22 ; 23#include ""TNamed.h""; 24 ; 25#include ""TMethodCall.h""; 26 ; 27class TMinuit : public TNamed {; 28 ; 29private:; 30 TMinuit(const TMinuit &m);; 31 TMinuit& operator=(const TMinuit &m); // Not implemented; 32 ; 33// should become private....; 34public:; 35 enum{kMAXWARN=100};; 36 ; 37 Int_t fNpfix; //Number of fixed parameters; 38 Int_t fEmpty; //Initialization flag (1 = Minuit initialized); 39 Int_t fMaxpar; //Maximum number of parameters; 40 Int_t fMaxint; //Maximum number of internal parameters; 41 Int_t fNpar; //Number of free parameters (total number of pars = fNpar + fNfix); 42 Int_t fMaxext; //Maximum number of external parameters; 43 Int_t fMaxIterations; //Maximum number of iterations; 44 Int_t fMaxpar5; // fMaxpar*(fMaxpar+1)/2; 45 Int_t fMaxcpt;; 46 Int_t fMaxpar2; // fMaxpar*fMaxpar; 47 Int_t fMaxpar1; // fMaxpar*(fMaxpar+1); 48 ; 49 Double_t fAmin; //Minimum value found for FCN; 50 Double_t fUp; //FCN+-UP defines errors (for chisquare fits UP=1); 51 Double_t fEDM; //Estimated vertical distance to the minimum; 52 Double_t fFval3; //; 53 Double_t fEpsi; //; 54 Double_t fApsi; //; 55 Double_t fDcovar; //Relative change in covariance matrix; 56 Double_t fEpsmac; //machine precision for floating points:; 57 Double_t fEpsma2; //sqrt(fEpsmac); 58 Double_t fVlimlo; //; 59 Double_t fVlimhi; //; 60 Double_t fUndefi; //Undefined number = -54321; 61 Double_t fBigedm; //Big EDM = 123456; 62 Double_t fUpdflt; //; 63 Double_t fXmidcr; //; 64 Double_t fYmidcr; //; 65 Double_t fXdircr; //; 66 Double_t fYdircr; //; 67 ; 68 Double_t *fU; //[fMaxpar2] External (visible to user in FCN) value of parameters; 69 Double_t *fAlim; //[fMaxpar2] Lower limits for parameters. If zero no limits; 70 Double_t *fBlim; //[fMaxpar2] Upper limits for parameters; 71 Double_t *fErp; //[fMaxpar] Positive Minos errors if calculated; 72 Double_t *fErn; //[fMaxpar] Negative Minos errors if calculated; 73 Double_t *fWerr; //[fMaxpar] External parameters error (",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
Deployability,release,release,"a1, Double_t a2, Int_t naa, Double_t &bl, Double_t &bh, Int_t &nb, Double_t &bwid)Compute reasonable histogram intervals.Definition TMinuit.cxx:997; TMinuit::fMaxcptInt_t fMaxcptDefinition TMinuit.h:45; TMinuit::GetNumParsvirtual Int_t GetNumPars() constreturns the total number of parameters that have been defined as fixed or free.Definition TMinuit.cxx:872; TMinuit::fXtsDouble_t * fXtsDefinition TMinuit.h:79; TMinuit::mnpsdfvirtual void mnpsdf()Calculates the eigenvalues of v to see if positive-def.Definition TMinuit.cxx:6494; TMinuit::GetNumFixedParsvirtual Int_t GetNumFixedPars() constreturns the number of currently fixed parametersDefinition TMinuit.cxx:855; TMinuit::fUDouble_t * fUDefinition TMinuit.h:68; TMinuit::mnpfitvirtual void mnpfit(Double_t *parx2p, Double_t *pary2p, Int_t npar2p, Double_t *coef2p, Double_t &sdev2p)To fit a parabola to npar2p points.Definition TMinuit.cxx:5956; TMinuit::fGrdsDouble_t * fGrdsDefinition TMinuit.h:86; TMinuit::Releasevirtual Int_t Release(Int_t parNo)release a parameterDefinition TMinuit.cxx:894; TMinuit::mnparsvirtual void mnpars(TString &crdbuf, Int_t &icondn)Implements one parameter definition.Definition TMinuit.cxx:5867; TMinuit::fGstepsDouble_t * fGstepsDefinition TMinuit.h:88; TMinuit::mnimprvirtual void mnimpr()Attempts to improve on a good local minimum.Definition TMinuit.cxx:4295; TMinuit::fPstarDouble_t * fPstarDefinition TMinuit.h:92; TMinuit::fObjectFitTObject * fObjectFitDefinition TMinuit.h:175; TMinuit::BuildArraysvirtual void BuildArrays(Int_t maxpar=15)Create internal Minuit arrays for the maxpar parameters.Definition TMinuit.cxx:512; TMinuit::mnwerrvirtual void mnwerr()Calculates the WERR, external parameter errors.Definition TMinuit.cxx:7861; TMinuit::kMAXWARN@ kMAXWARNDefinition TMinuit.h:35; TMinuit::fNfcnfrInt_t fNfcnfrDefinition TMinuit.h:148; TMinuit::mnrsetvirtual void mnrset(Int_t iopt)Resets function value and errors to UNDEFINED.Definition TMinuit.cxx:6661; TMinuit::fIMPRyDouble_t * fIMPRyDefini",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
Integrability,message,messages,"ers; 129 Int_t *fIpfix; //[fMaxpar] List of fixed parameters; 130 Int_t fNu; //; 131 Int_t fIsysrd; //standardInput unit; 132 Int_t fIsyswr; //standard output unit; 133 Int_t fIsyssa; //; 134 Int_t fNpagwd; //Page width; 135 Int_t fNpagln; //Number of lines per page; 136 Int_t fNewpag; //; 137 Int_t fIstkrd[10]; //; 138 Int_t fNstkrd; //; 139 Int_t fIstkwr[10]; //; 140 Int_t fNstkwr; //; 141 Int_t fISW[7]; //Array of switches; 142 Int_t fIdbg[11]; //Array of internal debug switches; 143 Int_t fNblock; //Number of Minuit data blocks; 144 Int_t fIcomnd; //Number of commands; 145 Int_t fNfcn; //Number of calls to FCN; 146 Int_t fNfcnmx; //Maximum number of calls to FCN; 147 Int_t fNfcnlc; //; 148 Int_t fNfcnfr; //; 149 Int_t fItaur; //; 150 Int_t fIstrat; //; 151 Int_t fNwrmes[2]; //; 152 Int_t fNfcwar[20]; //; 153 Int_t fIcirc[2]; //; 154 Int_t fStatus; //Status flag for the last called Minuit function; 155 Int_t fKe1cr; //; 156 Int_t fKe2cr; //; 157 Bool_t fLwarn; //true if warning messages are to be put out (default=true); 158 Bool_t fLrepor; //true if exceptional conditions are put out (default=false); 159 Bool_t fLimset; //true if a parameter is up against limits (for MINOS); 160 Bool_t fLnolim; //true if there are no limits on any parameters (not yet used); 161 Bool_t fLnewmn; //true if the previous process has unexpectedly improved FCN; 162 Bool_t fLphead; //true if a heading should be put out for the next parameter definition; 163 Bool_t fGraphicsMode; //true if graphics mode on (default); 164 char *fChpt; //!Character to be plotted at the X,Y contour positions; 165 TString *fCpnam; //[fMaxpar2] Array of parameters names; 166 TString fCfrom; //; 167 TString fCstatu; //; 168 TString fCtitl; //; 169 TString fCword; //; 170 TString fCundef; //; 171 TString fCvrsn; //; 172 TString fCovmes[4]; //; 173 TString fOrigin[kMAXWARN]; //; 174 TString fWarmes[kMAXWARN]; //; 175 TObject *fObjectFit; //Pointer to object being fitted; 176 TObject *fPlot; //Pointer to TGraph obj",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
Modifiability,variab,variable,,MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
Performance,perform,performed,"f there are no limits on any parameters (not yet used); 161 Bool_t fLnewmn; //true if the previous process has unexpectedly improved FCN; 162 Bool_t fLphead; //true if a heading should be put out for the next parameter definition; 163 Bool_t fGraphicsMode; //true if graphics mode on (default); 164 char *fChpt; //!Character to be plotted at the X,Y contour positions; 165 TString *fCpnam; //[fMaxpar2] Array of parameters names; 166 TString fCfrom; //; 167 TString fCstatu; //; 168 TString fCtitl; //; 169 TString fCword; //; 170 TString fCundef; //; 171 TString fCvrsn; //; 172 TString fCovmes[4]; //; 173 TString fOrigin[kMAXWARN]; //; 174 TString fWarmes[kMAXWARN]; //; 175 TObject *fObjectFit; //Pointer to object being fitted; 176 TObject *fPlot; //Pointer to TGraph object created by mncont; 177 TMethodCall *fMethodCall; //Pointer to MethodCall in case of interpreted function; 178 void (*fFCN)(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); //!; 179 ; 180// methods performed on TMinuit class; 181public:; 182 TMinuit();; 183 TMinuit(Int_t maxpar);; 184 ~TMinuit() override;; 185 virtual void BuildArrays(Int_t maxpar=15);; 186 TObject *Clone(const char *newname="""") const override; //Clone-Method to copy the function-pointer fFCN; 187 virtual Int_t Command(const char *command);; 188 virtual TObject *Contour(Int_t npoints=10, Int_t pa1=0, Int_t pa2=1);; 189 virtual Int_t DefineParameter( Int_t parNo, const char *name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit );; 190 virtual void DeleteArrays();; 191 virtual Int_t Eval(Int_t npar, Double_t *grad, Double_t &fval, Double_t *par, Int_t flag);; 192 virtual Int_t FixParameter( Int_t parNo );; 193 TMethodCall *GetMethodCall() const {return fMethodCall;}; 194 TObject *GetObjectFit() const {return fObjectFit;}; 195 Int_t GetMaxIterations() const {return fMaxIterations;}; 196 virtual Int_t GetNumFixedPars() const;; 197 virtual Int_t GetNumFreePars() const;; 198 virtual Int_t GetNu",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
Usability,simpl,simplex,"on a good local minimum.Definition TMinuit.cxx:4295; TMinuit::fPstarDouble_t * fPstarDefinition TMinuit.h:92; TMinuit::fObjectFitTObject * fObjectFitDefinition TMinuit.h:175; TMinuit::BuildArraysvirtual void BuildArrays(Int_t maxpar=15)Create internal Minuit arrays for the maxpar parameters.Definition TMinuit.cxx:512; TMinuit::mnwerrvirtual void mnwerr()Calculates the WERR, external parameter errors.Definition TMinuit.cxx:7861; TMinuit::kMAXWARN@ kMAXWARNDefinition TMinuit.h:35; TMinuit::fNfcnfrInt_t fNfcnfrDefinition TMinuit.h:148; TMinuit::mnrsetvirtual void mnrset(Int_t iopt)Resets function value and errors to UNDEFINED.Definition TMinuit.cxx:6661; TMinuit::fIMPRyDouble_t * fIMPRyDefinition TMinuit.h:106; TMinuit::fVlimhiDouble_t fVlimhiDefinition TMinuit.h:59; TMinuit::mneigvirtual void mneig(Double_t *a, Int_t ndima, Int_t n, Int_t mits, Double_t *work, Double_t precis, Int_t &ifault)Compute matrix eigen values.Definition TMinuit.cxx:2305; TMinuit::mnsimpvirtual void mnsimp()Minimization using the simplex method of Nelder and Mead.Definition TMinuit.cxx:7431; TMinuit::fLwarnBool_t fLwarnDefinition TMinuit.h:157; TMinuit::fXptDouble_t * fXptDefinition TMinuit.h:97; TMinuit::fGinDouble_t * fGinDefinition TMinuit.h:84; TMinuit::GetMethodCallTMethodCall * GetMethodCall() constDefinition TMinuit.h:193; TMinuit::fNfcnmxInt_t fNfcnmxDefinition TMinuit.h:146; TMinuit::fItaurInt_t fItaurDefinition TMinuit.h:149; TMinuit::TMinuitTMinuit()Minuit normal constructor.Definition TMinuit.cxx:347; TMinuit::fUndefiDouble_t fUndefiDefinition TMinuit.h:60; TMinuit::fKe2crInt_t fKe2crDefinition TMinuit.h:156; TMinuit::mnaminvirtual void mnamin()Initialize AMIN.Definition TMinuit.cxx:972; TMinuit::operator=TMinuit & operator=(const TMinuit &m); TMinuit::SetErrorDefvirtual Int_t SetErrorDef(Double_t up)To get the n-sigma contour the error def parameter ""up"" has to set to n^2.Definition TMinuit.cxx:908; TMinuit::fNuInt_t fNuDefinition TMinuit.h:130; TMinuit::GetStatusInt_t GetStatus() ",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
Availability,avail,available,"ph. The following example demonstrate this.; 163 ; 164Begin_Macro(source); 165{; 166 auto c3 = new TCanvas(""c3"",""c3"",600, 400);; 167 ; 168 auto mg = new TMultiGraph(""mg"",""mg"");; 169 ; 170 const Int_t size = 10;; 171 ; 172 double px[size];; 173 double py1[size];; 174 double py2[size];; 175 double py3[size];; 176 ; 177 for ( int i = 0; i < size ; ++i ) {; 178 px[i] = i;; 179 py1[i] = size - i;; 180 py2[i] = size - 0.5 * i;; 181 py3[i] = size - 0.6 * i;; 182 }; 183 ; 184 auto gr1 = new TGraph( size, px, py1 );; 185 gr1->SetName(""gr1"");; 186 gr1->SetTitle(""graph 1"");; 187 gr1->SetMarkerStyle(21);; 188 gr1->SetDrawOption(""AP"");; 189 gr1->SetLineColor(2);; 190 gr1->SetLineWidth(4);; 191 gr1->SetFillStyle(0);; 192 ; 193 auto gr2 = new TGraph( size, px, py2 );; 194 gr2->SetName(""gr2"");; 195 gr2->SetTitle(""graph 2"");; 196 gr2->SetMarkerStyle(22);; 197 gr2->SetMarkerColor(2);; 198 gr2->SetDrawOption(""P"");; 199 gr2->SetLineColor(3);; 200 gr2->SetLineWidth(4);; 201 gr2->SetFillStyle(0);; 202 ; 203 auto gr3 = new TGraph( size, px, py3 );; 204 gr3->SetName(""gr3"");; 205 gr3->SetTitle(""graph 3"");; 206 gr3->SetMarkerStyle(23);; 207 gr3->SetLineColor(4);; 208 gr3->SetLineWidth(4);; 209 gr3->SetFillStyle(0);; 210 ; 211 mg->Add( gr1 );; 212 mg->Add( gr2 );; 213 ; 214 gr3->Draw(""ALP"");; 215 mg->Draw(""LP"");; 216 c3->BuildLegend();; 217}; 218End_Macro; 219 ; 220\anchor MG01e; 221#### Automatic coloring; 222 ; 223Automatic coloring according to the current palette is available as shown in the; 224following example:; 225 ; 226Begin_Macro(source); 227../../../tutorials/graphs/multigraphpalettecolor.C; 228End_Macro; 229 ; 230\anchor MG01f; 231#### Reverse axis; 232 ; 233\since **ROOT version 6.19/02**; 234 ; 235When a TMultiGraph is drawn, the X-axis is drawn with increasing values from left to; 236right and the Y-axis from bottom to top. The two options RX and RY allow to change; 237this order. The option RX allows to draw the X-axis with increasing values from; 238right to left and the RY o",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
Deployability,update,updated,"973 ifail = -1;; 974 if (det <= 0) {; 975 if (fn > 0) a0 = ybar/fn;; 976 else a0 = 0;; 977 a1 = 0;; 978 return;; 979 }; 980 ifail = 0;; 981 a0 = (x2bar*ybar - xbar*xybar) / det;; 982 a1 = (fn*xybar - xbar*ybar) / det;; 983}; 984 ; 985 ; 986////////////////////////////////////////////////////////////////////////////////; 987/// Return 1 if the point (x,y) is inside one of the graphs 0 otherwise.; 988 ; 989Int_t TMultiGraph::IsInside(Double_t x, Double_t y) const; 990{; 991 Int_t in = 0;; 992 if (!fGraphs) return in;; 993 TGraph *g;; 994 TIter next(fGraphs);; 995 while ((g = (TGraph*) next())) {; 996 in = g->IsInside(x, y);; 997 if (in) return in;; 998 }; 999 return in;; 1000}; 1001 ; 1002 ; 1003////////////////////////////////////////////////////////////////////////////////; 1004/// Returns a pointer to the histogram used to draw the axis.; 1005/// Takes into account following cases.; 1006///; 1007/// 1. if `fHistogram` exists it is returned; 1008/// 2. if `fHistogram` doesn't exists and `gPad` exists `gPad` is updated. That; 1009/// may trigger the creation of `fHistogram`. If `fHistogram` still does not; 1010/// exit but `hframe` does (if user called `TPad::DrawFrame`) the pointer to; 1011/// `hframe` histogram is returned; 1012/// 3. after the two previous steps, if `fHistogram` still doesn't exist, then; 1013/// it is created.; 1014 ; 1015TH1F *TMultiGraph::GetHistogram(); 1016{; 1017 if (fHistogram) return fHistogram;; 1018 ; 1019 if (gPad) {; 1020 gPad->Modified();; 1021 gPad->Update();; 1022 if (fHistogram) return fHistogram;; 1023 TH1F *h1 = (TH1F*)gPad->FindObject(""hframe"");; 1024 if (h1) return h1;; 1025 }; 1026 ; 1027 Bool_t initialrangeset = kFALSE;; 1028 Double_t rwxmin = 0.,rwxmax = 0.,rwymin = 0.,rwymax = 0.;; 1029 TGraph *g;; 1030 Int_t npt = 100 ;; 1031 TIter next(fGraphs);; 1032 while ((g = (TGraph*) next())) {; 1033 if (g->GetN() <= 0) continue;; 1034 if (initialrangeset) {; 1035 Double_t rx1,ry1,rx2,ry2;; 1036 g->ComputeRange(rx1, ry1, rx2, ry2);;",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
Energy Efficiency,power,power,"ar[i]);; 828}; 829 ; 830 ; 831////////////////////////////////////////////////////////////////////////////////; 832/// Least squares lpolynomial fitting without weights.; 833///; 834/// - m number of parameters; 835/// - a array of parameters; 836/// - first 1st point number to fit (default =0); 837/// - last last point number to fit (default=fNpoints-1); 838///; 839/// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun; 840 ; 841void TMultiGraph::LeastSquareFit(Int_t m, Double_t *a, Double_t xmin, Double_t xmax); 842{; 843 const Double_t zero = 0.;; 844 const Double_t one = 1.;; 845 const Int_t idim = 20;; 846 ; 847 Double_t b[400] /* was [20][20] */;; 848 Int_t i, k, l, ifail, bin;; 849 Double_t power;; 850 Double_t da[20], xk, yk;; 851 ; 852 ; 853 //count the total number of points to fit; 854 TGraph *g;; 855 TIter next(fGraphs);; 856 Double_t *px, *py;; 857 Int_t n=0;; 858 Int_t npp;; 859 while ((g = (TGraph*) next())) {; 860 px=g->GetX();; 861 npp=g->GetN();; 862 for (bin=0; bin<npp; bin++) {; 863 xk=px[bin];; 864 if (xk < xmin || xk > xmax) continue;; 865 n++;; 866 }; 867 }; 868 if (m <= 2) {; 869 LeastSquareLinearFit(n, a[0], a[1], ifail, xmin, xmax);; 870 return;; 871 }; 872 if (m > idim || m > n) return;; 873 da[0] = zero;; 874 for (l = 2; l <= m; ++l) {; 875 b[l-1] = zero;; 876 b[m + l*20 - 21] = zero;; 877 da[l-1] = zero;; 878 }; 879 Int_t np = 0;; 880 ; 881 next.Reset();; 882 while ((g = (TGraph*) next())) {; 883 px=g->GetX();; 884 py=g->GetY();; 885 npp=g->GetN();; 886 ; 887 for (k = 0; k <= npp; ++k) {; 888 xk = px[k];; 889 if (xk < xmin || xk > xmax) continue;; 890 np++;; 891 yk = py[k];; 892 power = one;; 893 da[0] += yk;; 894 for (l = 2; l <= m; ++l) {; 895 power *= xk;; 896 b[l-1] += power;; 897 da[l-1] += power*yk;; 898 }; 899 for (l = 2; l <= m; ++l) {; 900 power *= xk;; 901 b[m + l*20 - 21] += power;; 902 }; 903 }; 904 }; 905 b[0] = Double_t(np);; 906 for (i = 3; i <= m; ++i) {; 907 for (k = i; k <= m; ++k) {; 908 b[k - 1 + (i-1)*20 - 2",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
Integrability,interface,interface,"tigraph with its current attributes.; 496///; 497/// Options to draw a graph are described in TGraphPainter.; 498///; 499/// The drawing option for each TGraph may be specified as an optional; 500/// second argument of the Add function. You can use GetGraphDrawOption; 501/// to return this option.; 502///; 503/// If a draw option is specified, it will be used to draw the graph,; 504/// otherwise the graph will be drawn with the option specified in; 505/// TMultiGraph::Draw. Use GetDrawOption to return the option specified; 506/// when drawing the TMultiGraph.; 507 ; 508void TMultiGraph::Draw(Option_t *option); 509{; 510 TString opt = option;; 511 opt.ToLower();; 512 ; 513 if (gPad) {; 514 if (!gPad->IsEditable()) gROOT->MakeDefCanvas();; 515 if (opt.Contains(""a"")) gPad->Clear();; 516 }; 517 AppendPad(option);; 518}; 519 ; 520 ; 521////////////////////////////////////////////////////////////////////////////////; 522/// Fit this graph with function with name fname.; 523///; 524/// interface to TF1::Fit(TF1 *f1...; 525 ; 526TFitResultPtr TMultiGraph::Fit(const char *fname, Option_t *option, Option_t *, Axis_t xmin, Axis_t xmax); 527{; 528 char *linear = (char*)strstr(fname, ""++"");; 529 if (linear) {; 530 TF1 f1(fname, fname, xmin, xmax);; 531 return Fit(&f1,option,"""",xmin,xmax);; 532 }; 533 TF1 * f1 = (TF1*)gROOT->GetFunction(fname);; 534 if (!f1) { Printf(""Unknown function: %s"",fname); return -1; }; 535 ; 536 return Fit(f1,option,"""",xmin,xmax);; 537}; 538 ; 539 ; 540////////////////////////////////////////////////////////////////////////////////; 541/// Fit this multigraph with function f1.; 542///; 543/// In this function all graphs of the multigraph are fitted simultaneously; 544///; 545/// f1 is an already predefined function created by TF1.; 546/// Predefined functions such as gaus, expo and poln are automatically; 547/// created by ROOT.; 548///; 549/// The list of fit options is given in parameter `option`which may takes the; 550/// following values:; 551///; 552",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
Modifiability,plugin,plugin,"n_t *goption, Axis_t rxmin, Axis_t rxmax); 700{; 701 // internal multigraph fitting methods; 702 Foption_t fitOption;; 703 ROOT::Fit::FitOptionsMake(ROOT::Fit::EFitObjectType::kGraph,option,fitOption);; 704 ; 705 // create range and minimizer options with default values; 706 ROOT::Fit::DataRange range(rxmin,rxmax);; 707 ROOT::Math::MinimizerOptions minOption;; 708 return ROOT::Fit::FitObject(this, f1 , fitOption , minOption, goption, range);; 709 ; 710}; 711 ; 712////////////////////////////////////////////////////////////////////////////////; 713/// Display a panel with all histogram fit options.; 714/// See class TFitPanel for example; 715 ; 716void TMultiGraph::FitPanel(); 717{; 718 if (!gPad); 719 gROOT->MakeDefCanvas();; 720 ; 721 if (!gPad) {; 722 Error(""FitPanel"", ""Unable to create a default canvas"");; 723 return;; 724 }; 725 ; 726 // use plugin manager to create instance of TFitEditor; 727 TPluginHandler *handler = gROOT->GetPluginManager()->FindHandler(""TFitEditor"");; 728 if (handler && handler->LoadPlugin() != -1) {; 729 if (handler->ExecPlugin(2, gPad, this) == 0); 730 Error(""FitPanel"", ""Unable to crate the FitPanel"");; 731 }; 732 else; 733 Error(""FitPanel"", ""Unable to find the FitPanel plug-in"");; 734}; 735 ; 736////////////////////////////////////////////////////////////////////////////////; 737/// Return the draw option for the TGraph `gr` in this TMultiGraph.; 738/// The return option is the one specified when calling TMultiGraph::Add(gr,option).; 739 ; 740Option_t *TMultiGraph::GetGraphDrawOption(const TGraph *gr) const; 741{; 742 if (!fGraphs || !gr) return """";; 743 TListIter next(fGraphs);; 744 TObject *obj;; 745 while ((obj = next())) {; 746 if (obj == (TObject*)gr) return next.GetOption();; 747 }; 748 return """";; 749}; 750 ; 751 ; 752////////////////////////////////////////////////////////////////////////////////; 753/// Compute Initial values of parameters for a gaussian.; 754 ; 755void TMultiGraph::InitGaus(Double_t xmin, Double_t xmax); 756{; ",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
Performance,perform,performed,"ref MG01); 47 - [Setting drawing options](\ref MG01a); 48 - [Titles setting](\ref MG01b); 49 - [The option \""3D\""](\ref MG01c); 50 - [Legend drawing](\ref MG01d); 51 - [Automatic coloring](\ref MG01e); 52 - [Reverse axis](\ref MG01f); 53- [MultiGraphs' fitting](\ref MG02); 54 - [Fit box position](\ref MG02a); 55- [Axis' limits setting](\ref MG03); 56 ; 57 ; 58\anchor MG00; 59### Introduction; 60 ; 61A TMultiGraph allows to manipulate a set of graphs as a single entity. In particular,; 62when drawn, the X and Y axis ranges are automatically computed such as all the graphs; 63will be visible.; 64 ; 65`TMultiGraph::Add` should be used to add a new graph to the list.; 66 ; 67The TMultiGraph owns the objects in the list.; 68 ; 69The number of graphs in a multigraph can be retrieve with:; 70~~~ {.cpp}; 71mg->GetListOfGraphs()->GetEntries();; 72~~~; 73 ; 74\anchor MG01; 75### MultiGraphs' Drawing; 76 ; 77The drawing options are the same as for TGraph.; 78Like for TGraph, the painting is performed thanks to the TGraphPainter; 79class. All details about the various painting options are given in this class.; 80 ; 81Example:; 82~~~ {.cpp}; 83 TGraph *gr1 = new TGraph(...; 84 TGraphErrors *gr2 = new TGraphErrors(...; 85 TMultiGraph *mg = new TMultiGraph();; 86 mg->Add(gr1,""lp"");; 87 mg->Add(gr2,""cp"");; 88 mg->Draw(""a"");; 89~~~; 90 ; 91\anchor MG01a; 92#### Setting drawing options; 93 ; 94The drawing option for each TGraph may be specified as an optional; 95second argument of the `Add` function.; 96 ; 97If a draw option is specified, it will be used to draw the graph,; 98otherwise the graph will be drawn with the option specified in; 99`TMultiGraph::Draw`; 100 ; 101\anchor MG01b; 102#### Titles setting; 103 ; 104The global title and the axis titles can be modified the following way:; 105 ; 106~~~ {.cpp}; 107 [...]; 108 auto mg = new TMultiGraph;; 109 mg->SetTitle(""title;xaxis title; yaxis title"");; 110 mg->Add(g1);; 111 mg->Add(g2);; 112 mg->Draw(""apl"");; 113~~~; 114 ; 115\ancho",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
Security,access,access,"30/// ~~~ {.cpp}; 631/// TVirtualFitter::Fitter(mygraph)->SetFCN(MyFittingFunction); 632/// ~~~; 633/// where MyFittingFunction is of type:; 634/// ~~~ {.cpp}; 635/// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 636/// ~~~; 637///; 638/// ### Access to the fit result; 639///; 640/// The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; 641/// By default the TFitResultPtr contains only the status of the fit and it converts; 642/// automatically to an integer. If the option ""S"" is instead used, TFitResultPtr contains; 643/// the TFitResult and behaves as a smart pointer to it. For example one can do:; 644/// ~~~ {.cpp}; 645/// TFitResultPtr r = graph->Fit(""myFunc"",""S"");; 646/// TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; 647/// Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; 648/// Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; 649/// r->Print(""V""); // print full information of fit including covariance matrix; 650/// r->Write(); // store the result in a file; 651/// ~~~; 652///; 653/// The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; 654/// from the fitted function.; 655///; 656/// ### Associated functions; 657///; 658/// One or more object (typically a TF1*) can be added to the list; 659/// of functions (fFunctions) associated to each graph.; 660/// When TGraph::Fit is invoked, the fitted function is added to this list.; 661/// Given a graph gr, one can retrieve an associated function; 662/// with:; 663/// ~~~ {.cpp}; 664/// TF1 *myfunc = gr->GetFunction(""myfunc"");; 665/// ~~~; 666///; 667/// If the graph is made persistent, the list of; 668/// associated functions is also persistent. Given a pointer (see above); 669/// to an associated function myfunc, one can retrieve the function/fit; 670/// parameters with calls such as:; 671/// ~~~ {.cpp}; 672/// Doubl",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
Testability,log,logic,"tYaxis()->SetTitle(""Coefficients"");; 355 ; 356 // Change the axis limits; 357 gPad->Modified();; 358 mg->GetXaxis()->SetLimits(1.5,7.5);; 359 mg->SetMinimum(0.);; 360 mg->SetMaximum(10.);; 361}; 362End_Macro; 363*/; 364 ; 365 ; 366////////////////////////////////////////////////////////////////////////////////; 367/// TMultiGraph default constructor.; 368 ; 369TMultiGraph::TMultiGraph() {}; 370 ; 371 ; 372////////////////////////////////////////////////////////////////////////////////; 373/// Constructor with name and title.; 374 ; 375TMultiGraph::TMultiGraph(const char *name, const char *title); 376 : TNamed(name,title); 377{; 378}; 379 ; 380////////////////////////////////////////////////////////////////////////////////; 381/// TMultiGraph destructor.; 382 ; 383TMultiGraph::~TMultiGraph(); 384{; 385 if (!fGraphs) return;; 386 TObject *g;; 387 TIter next(fGraphs);; 388 while ((g = next())) {; 389 g->ResetBit(kMustCleanup);; 390 }; 391 fGraphs->Delete();; 392 delete fGraphs;; 393 fGraphs = nullptr;; 394 delete fHistogram;; 395 fHistogram = nullptr;; 396 if (fFunctions) {; 397 fFunctions->SetBit(kInvalidObject);; 398 //special logic to support the case where the same object is; 399 //added multiple times in fFunctions.; 400 //This case happens when the same object is added with different; 401 //drawing modes; 402 TObject *obj;; 403 while ((obj = fFunctions->First())) {; 404 while (fFunctions->Remove(obj)) { }; 405 delete obj;; 406 }; 407 delete fFunctions;; 408 fFunctions = nullptr;; 409 }; 410}; 411 ; 412 ; 413////////////////////////////////////////////////////////////////////////////////; 414/// Add a new graph to the list of graphs.; 415/// Note that the graph is now owned by the TMultigraph.; 416/// Deleting the TMultiGraph object will automatically delete the graphs.; 417/// You should not delete the graphs when the TMultigraph is still active.; 418 ; 419void TMultiGraph::Add(TGraph *graph, Option_t *chopt); 420{; 421 if (!fGraphs) fGraphs = new TList();; 422 g",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
Integrability,interface,interface,". ROOT: tutorials/tmva/tmva001_RTensor.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva001_RTensor.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates the basic features of the RTensor class, RTensor is a std::vector-like container with additional shape information. ; The class serves as an interface in C++ between multi-dimensional data and the algorithm such as in machine learning workflows. The interface is similar to Numpy arrays and provides a subset of the functionality.; ; using namespace TMVA::Experimental;; ; void tmva001_RTensor(); {; // Create RTensor from scratch; RTensor<float> x({2, 2});; cout << x << endl;; ; // Assign some data; x(0, 0) = 1;; x(0, 1) = 2;; x(1, 0) = 3;; x(1, 1) = 4;; ; // Apply transformations; auto x2 = x.Reshape({1, 4}).Squeeze();; cout << x2 << endl;; ; // Slice; auto x3 = x.Reshape({2, 2}).Slice({{0, 2}, {0, 1}});; cout << x3 << endl;; ; // Create tensor as view on data without ownership; float data[] = {5, 6, 7, 8};; RTensor<float> y(data, {2, 2});; cout << y << endl;; ; // Create tensor as view on data with ownership; auto data2 = std::make_shared<std::vector<float>>(4);; float c = 9;; for (auto &v : *data2) {; v = c;; c++;; }; ; RTensor<float> z(data2, {2, 2});; cout << z << endl;; }; c#define c(i)Definition RSha256.hxx:101; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; TMVA::Experimental::RTensorRTensor is a container with contiguous memory and shape information.Definition RTensor.hxx:162; TMVA::Experimental::RTensor::ReshapeRTensor< Value_t, Container_t > Reshape(const Shape_t &shape) constReshape tensor.Definition RTensor.hxx:480; RooFit::SliceRooCmdArg Slice(const RooArgSet &sliceSet)Defi",MatchSource.WIKI,doc/master/tmva001__RTensor_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva001__RTensor_8C.html
Usability,learn,learning,". ROOT: tutorials/tmva/tmva001_RTensor.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva001_RTensor.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates the basic features of the RTensor class, RTensor is a std::vector-like container with additional shape information. ; The class serves as an interface in C++ between multi-dimensional data and the algorithm such as in machine learning workflows. The interface is similar to Numpy arrays and provides a subset of the functionality.; ; using namespace TMVA::Experimental;; ; void tmva001_RTensor(); {; // Create RTensor from scratch; RTensor<float> x({2, 2});; cout << x << endl;; ; // Assign some data; x(0, 0) = 1;; x(0, 1) = 2;; x(1, 0) = 3;; x(1, 1) = 4;; ; // Apply transformations; auto x2 = x.Reshape({1, 4}).Squeeze();; cout << x2 << endl;; ; // Slice; auto x3 = x.Reshape({2, 2}).Slice({{0, 2}, {0, 1}});; cout << x3 << endl;; ; // Create tensor as view on data without ownership; float data[] = {5, 6, 7, 8};; RTensor<float> y(data, {2, 2});; cout << y << endl;; ; // Create tensor as view on data with ownership; auto data2 = std::make_shared<std::vector<float>>(4);; float c = 9;; for (auto &v : *data2) {; v = c;; c++;; }; ; RTensor<float> z(data2, {2, 2});; cout << z << endl;; }; c#define c(i)Definition RSha256.hxx:101; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; TMVA::Experimental::RTensorRTensor is a container with contiguous memory and shape information.Definition RTensor.hxx:162; TMVA::Experimental::RTensor::ReshapeRTensor< Value_t, Container_t > Reshape(const Shape_t &shape) constReshape tensor.Definition RTensor.hxx:480; RooFit::SliceRooCmdArg Slice(const RooArgSet &sliceSet)Defi",MatchSource.WIKI,doc/master/tmva001__RTensor_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva001__RTensor_8C.html
Integrability,interface,interface,". ROOT: tutorials/tmva/tmva002_RDataFrameAsTensor.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva002_RDataFrameAsTensor.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial shows how the content of an RDataFrame can be converted to an RTensor object. ; ; using namespace TMVA::Experimental;; ; void tmva002_RDataFrameAsTensor(); {; // Creation of an RDataFrame with five entries filled with ascending numbers; ROOT::RDataFrame df(5);; auto df2 = df.Define(""x"", ""1.f*rdfentry_"").Define(""y"", ""-1.f*rdfentry_"");; ; // Convert content of columns to an RTensor object; auto x = AsTensor<float>(df2);; ; std::cout << ""RTensor from an RDataFrame:\n"" << x << ""\n\n"";; ; // The utility also supports reading only a part of the RDataFrame and different; // memory layouts.; auto x2 = AsTensor<float>(df2, {""x""}, MemoryLayout::ColumnMajor);; ; std::cout << ""RTensor from a single column of the RDataFrame:\n"" << x2 << ""\n\n"";; }; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; xDouble_t x[n]Definition legend1.C:17; TMVA::ExperimentalDefinition RModelParser_Keras.h:40; ; RTensor from an RDataFrame:; { { 0, -0 } { 1, -1 } { 2, -2 } { 3, -3 } { 4, -4 } }; ; RTensor from a single column of the RDataFrame:; { { 0 } { 1 } { 2 } { 3 } { 4 } }; ; DateDecember 2018 ; AuthorStefan Wunsch ; Definition in file tmva002_RDataFrameAsTensor.C. tutorialstmvatmva002_RDataFrameAsTensor.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/tmva002__RDataFrameAsTensor_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva002__RDataFrameAsTensor_8C.html
Integrability,interface,interfaces,". ROOT: tutorials/tmva/tmva003_RReader.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva003_RReader.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial shows how to apply with the modern interfaces models saved in TMVA XML files. ; ; using namespace TMVA::Experimental;; ; void train(const std::string &filename); {; // Create factory; auto output = TFile::Open(""TMVARR.root"", ""RECREATE"");; auto factory = new TMVA::Factory(""tmva003"",; output, ""!V:!DrawProgressBar:AnalysisType=Classification"");; ; // Open trees with signal and background events; auto data = TFile::Open(filename.c_str());; auto signal = (TTree *)data->Get(""TreeS"");; auto background = (TTree *)data->Get(""TreeB"");; ; // Add variables and register the trees with the dataloader; auto dataloader = new TMVA::DataLoader(""tmva003_BDT"");; const std::vector<std::string> variables = {""var1"", ""var2"", ""var3"", ""var4""};; for (const auto &var : variables) {; dataloader->AddVariable(var);; }; dataloader->AddSignalTree(signal, 1.0);; dataloader->AddBackgroundTree(background, 1.0);; dataloader->PrepareTrainingAndTestTree("""", """");; ; // Train a TMVA method; factory->BookMethod(dataloader, TMVA::Types::kBDT, ""BDT"", ""!V:!H:NTrees=300:MaxDepth=2"");; factory->TrainAllMethods();; }; ; void tmva003_RReader(); {; // First, let's train a model with TMVA.; const std::string filename = ""http://root.cern/files/tmva_class_example.root"";; train(filename);; ; // Next, we load the model from the TMVA XML file.; RReader model(""tmva003_BDT/weights/tmva003_BDT.weights.xml"");; ; // In case you need a reminder of the names and order of the variables during; // training, you can ask the model for it.; auto variables = model.GetVariableNames();; ; // The model can now be applied in different scenarios:; // 1) Event-by-event inference; // 2) Batch inference on data of multiple events; // 3) Inference as part of an RDataFrame graph; ; // 1) Event-by-event inference; /",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
Modifiability,variab,variables,". ROOT: tutorials/tmva/tmva003_RReader.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva003_RReader.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial shows how to apply with the modern interfaces models saved in TMVA XML files. ; ; using namespace TMVA::Experimental;; ; void train(const std::string &filename); {; // Create factory; auto output = TFile::Open(""TMVARR.root"", ""RECREATE"");; auto factory = new TMVA::Factory(""tmva003"",; output, ""!V:!DrawProgressBar:AnalysisType=Classification"");; ; // Open trees with signal and background events; auto data = TFile::Open(filename.c_str());; auto signal = (TTree *)data->Get(""TreeS"");; auto background = (TTree *)data->Get(""TreeB"");; ; // Add variables and register the trees with the dataloader; auto dataloader = new TMVA::DataLoader(""tmva003_BDT"");; const std::vector<std::string> variables = {""var1"", ""var2"", ""var3"", ""var4""};; for (const auto &var : variables) {; dataloader->AddVariable(var);; }; dataloader->AddSignalTree(signal, 1.0);; dataloader->AddBackgroundTree(background, 1.0);; dataloader->PrepareTrainingAndTestTree("""", """");; ; // Train a TMVA method; factory->BookMethod(dataloader, TMVA::Types::kBDT, ""BDT"", ""!V:!H:NTrees=300:MaxDepth=2"");; factory->TrainAllMethods();; }; ; void tmva003_RReader(); {; // First, let's train a model with TMVA.; const std::string filename = ""http://root.cern/files/tmva_class_example.root"";; train(filename);; ; // Next, we load the model from the TMVA XML file.; RReader model(""tmva003_BDT/weights/tmva003_BDT.weights.xml"");; ; // In case you need a reminder of the names and order of the variables during; // training, you can ask the model for it.; auto variables = model.GetVariableNames();; ; // The model can now be applied in different scenarios:; // 1) Event-by-event inference; // 2) Batch inference on data of multiple events; // 3) Inference as part of an RDataFrame graph; ; // 1) Event-by-event inference; /",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
Performance,load,load,"y(""tmva003"",; output, ""!V:!DrawProgressBar:AnalysisType=Classification"");; ; // Open trees with signal and background events; auto data = TFile::Open(filename.c_str());; auto signal = (TTree *)data->Get(""TreeS"");; auto background = (TTree *)data->Get(""TreeB"");; ; // Add variables and register the trees with the dataloader; auto dataloader = new TMVA::DataLoader(""tmva003_BDT"");; const std::vector<std::string> variables = {""var1"", ""var2"", ""var3"", ""var4""};; for (const auto &var : variables) {; dataloader->AddVariable(var);; }; dataloader->AddSignalTree(signal, 1.0);; dataloader->AddBackgroundTree(background, 1.0);; dataloader->PrepareTrainingAndTestTree("""", """");; ; // Train a TMVA method; factory->BookMethod(dataloader, TMVA::Types::kBDT, ""BDT"", ""!V:!H:NTrees=300:MaxDepth=2"");; factory->TrainAllMethods();; }; ; void tmva003_RReader(); {; // First, let's train a model with TMVA.; const std::string filename = ""http://root.cern/files/tmva_class_example.root"";; train(filename);; ; // Next, we load the model from the TMVA XML file.; RReader model(""tmva003_BDT/weights/tmva003_BDT.weights.xml"");; ; // In case you need a reminder of the names and order of the variables during; // training, you can ask the model for it.; auto variables = model.GetVariableNames();; ; // The model can now be applied in different scenarios:; // 1) Event-by-event inference; // 2) Batch inference on data of multiple events; // 3) Inference as part of an RDataFrame graph; ; // 1) Event-by-event inference; // The event-by-event inference takes the values of the variables as a std::vector<float>.; // Note that the return value is as well a std::vector<float> since the reader; // is also capable to process models with multiple outputs.; auto prediction = model.Compute({0.5, 1.0, -0.2, 1.5});; std::cout << ""Single-event inference: "" << prediction[0] << ""\n\n"";; ; // 2) Batch inference on data of multiple events; // For batch inference, the data needs to be structured as a matrix. For this; // purpose, TM",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
Safety,predict,prediction,"kBDT, ""BDT"", ""!V:!H:NTrees=300:MaxDepth=2"");; factory->TrainAllMethods();; }; ; void tmva003_RReader(); {; // First, let's train a model with TMVA.; const std::string filename = ""http://root.cern/files/tmva_class_example.root"";; train(filename);; ; // Next, we load the model from the TMVA XML file.; RReader model(""tmva003_BDT/weights/tmva003_BDT.weights.xml"");; ; // In case you need a reminder of the names and order of the variables during; // training, you can ask the model for it.; auto variables = model.GetVariableNames();; ; // The model can now be applied in different scenarios:; // 1) Event-by-event inference; // 2) Batch inference on data of multiple events; // 3) Inference as part of an RDataFrame graph; ; // 1) Event-by-event inference; // The event-by-event inference takes the values of the variables as a std::vector<float>.; // Note that the return value is as well a std::vector<float> since the reader; // is also capable to process models with multiple outputs.; auto prediction = model.Compute({0.5, 1.0, -0.2, 1.5});; std::cout << ""Single-event inference: "" << prediction[0] << ""\n\n"";; ; // 2) Batch inference on data of multiple events; // For batch inference, the data needs to be structured as a matrix. For this; // purpose, TMVA makes use of the RTensor class. For convenience, we use RDataFrame; // and the AsTensor utility to make the read-out from the ROOT file.; ROOT::RDataFrame df(""TreeS"", filename);; auto df2 = df.Range(3); // Read only a small subset of the dataset; auto x = AsTensor<float>(df2, variables);; auto y = model.Compute(x);; ; std::cout << ""RTensor input for inference on data of multiple events:\n"" << x << ""\n\n"";; std::cout << ""Prediction performed on multiple events: "" << y << ""\n\n"";; ; // 3) Perform inference as part of an RDataFrame graph; // We write a small lambda function that performs for us the inference on; // a dataframe to omit code duplication.; auto make_histo = [&](const std::string &treename) {; ROOT::RDataFrame df(tree",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
Testability,test,testing," TreeS; : Building event vectors for type 2 Background; : Dataset[tmva003_BDT] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [tmva003_BDT] : Number of events in input trees; : ; : ; : Dataset[tmva003_BDT] : Weight renormalisation mode: ""EqualNumEvents"": renormalises all event classes ...; : Dataset[tmva003_BDT] : such that the effective (weighted) number of events in each class is the same ; : Dataset[tmva003_BDT] : (and equals the number of events (entries) given for class=0 ); : Dataset[tmva003_BDT] : ... i.e. such that Sum[i=1..N_j]{w_i} = N_classA, j=classA, classB, ...; : Dataset[tmva003_BDT] : ... (note that N_j is the sum of TRAINING events; : Dataset[tmva003_BDT] : ..... Testing events are not renormalised nor included in the renormalisation factor!); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 3000; : Signal -- testing events : 3000; : Signal -- training and testing events: 6000; : Background -- training events : 3000; : Background -- testing events : 3000; : Background -- training and testing events: 6000; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.390 +0.594 +0.819; : var2: +0.390 +1.000 +0.684 +0.724; : var3: +0.594 +0.684 +1.000 +0.848; : var4: +0.819 +0.724 +0.848 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.854 +0.917 +0.965; : var2: +0.854 +1.000 +0.926 +0.934; : var3: +0.917 +0.926 +1.000 +0.972; : var4: +0.965 +0.934 +0.972 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [tmva003_BDT] : ; : ; <HEADER> Factory : Train all methods; <HEADER> Factory : [tmva003_BDT] : Create Transformation ""I"" with events from all classes.; : ; <HEADER> : Transformation, V",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
Integrability,interface,interface,"at>(df);; ; // Create standard scaler and fit to data; RStandardScaler<float> scaler;; scaler.Fit(x);; ; // Compute transformation; auto y = scaler.Compute(x);; ; // Plot first variable scaled and unscaled; TH1F h1(""h1"", "";x_{4};N_{Events}"", 20, -4, 4);; TH1F h2(""h2"", "";x_{4};N_{Events}"", 20, -4, 4);; for (std::size_t i = 0; i < x.GetShape()[0]; i++) {; h1.Fill(x(i, 3));; h2.Fill(y(i, 3));; }; h1.SetLineWidth(2);; h1.SetLineColor(kRed);; h2.SetLineWidth(2);; h2.SetLineColor(kBlue);; ; gStyle->SetOptStat(0);; auto c = new TCanvas("""", """", 800, 800);; h2.Draw(""HIST"");; h1.Draw(""HIST SAME"");; ; TLegend legend(0.7, 0.7, 0.89, 0.89);; legend.SetBorderSize(0);; legend.AddEntry(""h1"", ""Unscaled"", ""l"");; legend.AddEntry(""h2"", ""Scaled"", ""l"");; legend.Draw();; ; c->DrawClone();; }; c#define c(i)Definition RSha256.hxx:101; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TMVA::Experimental::RStandardScalerDefinition RStandardScaler.hxx:16; TMVA::Experimental::RStandardScaler::Fitvoid Fit(const RTensor< T > &x)Definition RStandardScaler.hxx:52; TMVA::Experimental::RStandardScaler::Computestd::vector< T > Com",MatchSource.WIKI,doc/master/tmva004__RStandardScaler_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva004__RStandardScaler_8C.html
Modifiability,variab,variable,". ROOT: tutorials/tmva/tmva004_RStandardScaler.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva004_RStandardScaler.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates the usage of the standard scaler as preprocessing method. ; ; using namespace TMVA::Experimental;; ; void tmva004_RStandardScaler(); {; // Load data used to fit the parameters; ROOT::RDataFrame df(""TreeS"", ""http://root.cern/files/tmva_class_example.root"");; auto x = AsTensor<float>(df);; ; // Create standard scaler and fit to data; RStandardScaler<float> scaler;; scaler.Fit(x);; ; // Compute transformation; auto y = scaler.Compute(x);; ; // Plot first variable scaled and unscaled; TH1F h1(""h1"", "";x_{4};N_{Events}"", 20, -4, 4);; TH1F h2(""h2"", "";x_{4};N_{Events}"", 20, -4, 4);; for (std::size_t i = 0; i < x.GetShape()[0]; i++) {; h1.Fill(x(i, 3));; h2.Fill(y(i, 3));; }; h1.SetLineWidth(2);; h1.SetLineColor(kRed);; h2.SetLineWidth(2);; h2.SetLineColor(kBlue);; ; gStyle->SetOptStat(0);; auto c = new TCanvas("""", """", 800, 800);; h2.Draw(""HIST"");; h1.Draw(""HIST SAME"");; ; TLegend legend(0.7, 0.7, 0.89, 0.89);; legend.SetBorderSize(0);; legend.AddEntry(""h1"", ""Unscaled"", ""l"");; legend.AddEntry(""h2"", ""Scaled"", ""l"");; legend.Draw();; ; c->DrawClone();; }; c#define c(i)Definition RSha256.hxx:101; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::Fillvirtual",MatchSource.WIKI,doc/master/tmva004__RStandardScaler_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva004__RStandardScaler_8C.html
Integrability,interface,interface,"number for training and testing; columns = ROOT.std.vector[""string""](variables); df.Filter(""event % 2 == 0"", ""Select events with even event number for training"")\; .Snapshot(""Events"", ""train_"" + label + "".root"", columns); df.Filter(""event % 2 == 1"", ""Select events with odd event number for training"")\; .Snapshot(""Events"", ""test_"" + label + "".root"", columns); ; # Print cutflow report; report.Print(); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; At least two electrons and two muons: pass=45352 all=299973 -- eff=15.12 % cumulative eff=15.12 %; At least two electrons and two muons: pass=262776 all=1497445 -- eff=17.55 % cumulative eff=17.55 %; >>> Extract the training and testing events for signal from the SMHiggsToZZTo4L.root dataset.; >>> Extract the training and testing events for background from the ZZTo2e2mu.root dataset.; DateAugust 2019 ; AuthorStefan Wunsch ; Definition in file tmva100_DataPreparation.py. tutorialstmvatmva100_DataPreparation.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/tmva100__DataPreparation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva100__DataPreparation_8py.html
Modifiability,variab,variables,". ROOT: tutorials/tmva/tmva100_DataPreparation.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva100_DataPreparation.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates how to prepare ROOT datasets to be nicely readable by most machine learning methods. ; This requires filtering the initial complex datasets and writing the data in a flat format.; ; import ROOT; ; ; def filter_events(df):; """"""; Reduce initial dataset to only events which shall be used for training; """"""; return df.Filter(""nElectron>=2 && nMuon>=2"", ""At least two electrons and two muons""); ; ; def define_variables(df):; """"""; Define the variables which shall be used for training; """"""; return df.Define(""Muon_pt_1"", ""Muon_pt[0]"")\; .Define(""Muon_pt_2"", ""Muon_pt[1]"")\; .Define(""Electron_pt_1"", ""Electron_pt[0]"")\; .Define(""Electron_pt_2"", ""Electron_pt[1]""); ; ; variables = [""Muon_pt_1"", ""Muon_pt_2"", ""Electron_pt_1"", ""Electron_pt_2""]; ; ; if __name__ == ""__main__"":; for filename, label in [[""SMHiggsToZZTo4L.root"", ""signal""], [""ZZTo2e2mu.root"", ""background""]]:; print("">>> Extract the training and testing events for {} from the {} dataset."".format(; label, filename)); ; # Load dataset, filter the required events and define the training variables; filepath = ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/"" + filename; df = ROOT.RDataFrame(""Events"", filepath); df = filter_events(df); df = define_variables(df); ; # Book cutflow report; report = df.Report(); ; # Split dataset by event number for training and testing; columns = ROOT.std.vector[""string""](variables); df.Filter(""event % 2 == 0"", ""Select events with even event number for training"")\; .Snapshot(""Events"", ""train_"" + label + "".root"", columns); df.Filter(""event % 2 == 1"", ""Select events with odd event number for training"")\; .Snapshot(""Events"", ""test_"" + label + "".root"", columns); ; # Print cutflow report; report.Print(); formatOpti",MatchSource.WIKI,doc/master/tmva100__DataPreparation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva100__DataPreparation_8py.html
Testability,test,testing,"ataPreparation.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates how to prepare ROOT datasets to be nicely readable by most machine learning methods. ; This requires filtering the initial complex datasets and writing the data in a flat format.; ; import ROOT; ; ; def filter_events(df):; """"""; Reduce initial dataset to only events which shall be used for training; """"""; return df.Filter(""nElectron>=2 && nMuon>=2"", ""At least two electrons and two muons""); ; ; def define_variables(df):; """"""; Define the variables which shall be used for training; """"""; return df.Define(""Muon_pt_1"", ""Muon_pt[0]"")\; .Define(""Muon_pt_2"", ""Muon_pt[1]"")\; .Define(""Electron_pt_1"", ""Electron_pt[0]"")\; .Define(""Electron_pt_2"", ""Electron_pt[1]""); ; ; variables = [""Muon_pt_1"", ""Muon_pt_2"", ""Electron_pt_1"", ""Electron_pt_2""]; ; ; if __name__ == ""__main__"":; for filename, label in [[""SMHiggsToZZTo4L.root"", ""signal""], [""ZZTo2e2mu.root"", ""background""]]:; print("">>> Extract the training and testing events for {} from the {} dataset."".format(; label, filename)); ; # Load dataset, filter the required events and define the training variables; filepath = ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/"" + filename; df = ROOT.RDataFrame(""Events"", filepath); df = filter_events(df); df = define_variables(df); ; # Book cutflow report; report = df.Report(); ; # Split dataset by event number for training and testing; columns = ROOT.std.vector[""string""](variables); df.Filter(""event % 2 == 0"", ""Select events with even event number for training"")\; .Snapshot(""Events"", ""train_"" + label + "".root"", columns); df.Filter(""event % 2 == 1"", ""Select events with odd event number for training"")\; .Snapshot(""Events"", ""test_"" + label + "".root"", columns); ; # Print cutflow report; report.Print(); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Re",MatchSource.WIKI,doc/master/tmva100__DataPreparation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva100__DataPreparation_8py.html
Usability,learn,learning,". ROOT: tutorials/tmva/tmva100_DataPreparation.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva100_DataPreparation.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates how to prepare ROOT datasets to be nicely readable by most machine learning methods. ; This requires filtering the initial complex datasets and writing the data in a flat format.; ; import ROOT; ; ; def filter_events(df):; """"""; Reduce initial dataset to only events which shall be used for training; """"""; return df.Filter(""nElectron>=2 && nMuon>=2"", ""At least two electrons and two muons""); ; ; def define_variables(df):; """"""; Define the variables which shall be used for training; """"""; return df.Define(""Muon_pt_1"", ""Muon_pt[0]"")\; .Define(""Muon_pt_2"", ""Muon_pt[1]"")\; .Define(""Electron_pt_1"", ""Electron_pt[0]"")\; .Define(""Electron_pt_2"", ""Electron_pt[1]""); ; ; variables = [""Muon_pt_1"", ""Muon_pt_2"", ""Electron_pt_1"", ""Electron_pt_2""]; ; ; if __name__ == ""__main__"":; for filename, label in [[""SMHiggsToZZTo4L.root"", ""signal""], [""ZZTo2e2mu.root"", ""background""]]:; print("">>> Extract the training and testing events for {} from the {} dataset."".format(; label, filename)); ; # Load dataset, filter the required events and define the training variables; filepath = ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/"" + filename; df = ROOT.RDataFrame(""Events"", filepath); df = filter_events(df); df = define_variables(df); ; # Book cutflow report; report = df.Report(); ; # Split dataset by event number for training and testing; columns = ROOT.std.vector[""string""](variables); df.Filter(""event % 2 == 0"", ""Select events with even event number for training"")\; .Snapshot(""Events"", ""train_"" + label + "".root"", columns); df.Filter(""event % 2 == 1"", ""Select events with odd event number for training"")\; .Snapshot(""Events"", ""test_"" + label + "".root"", columns); ; # Print cutflow report; report.Print(); formatOpti",MatchSource.WIKI,doc/master/tmva100__DataPreparation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva100__DataPreparation_8py.html
Integrability,interface,interface,"es. ; Using XGBoost, we illustrate how you can convert an externally trained model in a format serializable and readable with the fast tree inference engine offered by TMVA.; ; # XGBoost has to be imported before ROOT to avoid crashes because of clashing; # std::regexp symbols that are exported by cppyy.; # See also: https://github.com/wlav/cppyy/issues/227; from xgboost import XGBClassifier; ; import ROOT; import numpy as np; ; from tmva100_DataPreparation import variables; ; ; def load_data(signal_filename, background_filename):; # Read data from ROOT files; data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); ; # Convert inputs to format readable by machine learning tools; x_sig = np.vstack([data_sig[var] for var in variables]).T; x_bkg = np.vstack([data_bkg[var] for var in variables]).T; x = np.vstack([x_sig, x_bkg]); ; # Create labels; num_sig = x_sig.shape[0]; num_bkg = x_bkg.shape[0]; y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); ; # Compute weights balancing both classes; num_all = num_sig + num_bkg; w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); ; return x, y, w; ; if __name__ == ""__main__"":; # Load data; x, y, w = load_data(""train_signal.root"", ""train_background.root""); ; # Fit xgboost model; bdt = XGBClassifier(max_depth=3, n_estimators=500); bdt.fit(x, y, sample_weight=w); ; # Save model in TMVA format; print(""Training done on "",x.shape[0],""events. Saving model in tmva101.root""); ROOT.TMVA.Experimental.SaveXGBoost(bdt, ""myBDT"", ""tmva101.root"", num_inputs=x.shape[1]); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; DateAugust 2019 ; AuthorStefan Wunsch ; Definition in file tmva101_Training.py. tutorialstmvatmva101_Training.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/tmva101__Training_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py.html
Modifiability,variab,variables,". ROOT: tutorials/tmva/tmva101_Training.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva101_Training.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ; Using XGBoost, we illustrate how you can convert an externally trained model in a format serializable and readable with the fast tree inference engine offered by TMVA.; ; # XGBoost has to be imported before ROOT to avoid crashes because of clashing; # std::regexp symbols that are exported by cppyy.; # See also: https://github.com/wlav/cppyy/issues/227; from xgboost import XGBClassifier; ; import ROOT; import numpy as np; ; from tmva100_DataPreparation import variables; ; ; def load_data(signal_filename, background_filename):; # Read data from ROOT files; data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); ; # Convert inputs to format readable by machine learning tools; x_sig = np.vstack([data_sig[var] for var in variables]).T; x_bkg = np.vstack([data_bkg[var] for var in variables]).T; x = np.vstack([x_sig, x_bkg]); ; # Create labels; num_sig = x_sig.shape[0]; num_bkg = x_bkg.shape[0]; y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); ; # Compute weights balancing both classes; num_all = num_sig + num_bkg; w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); ; return x, y, w; ; if __name__ == ""__main__"":; # Load data; x, y, w = load_data(""train_signal.root"", ""train_background.root""); ; # Fit xgboost model; bdt = XGBClassifier(max_depth=3, n_estimators=500); bdt.fit(x, y, sample_weight=w); ; # Save model in TMVA format; print(""Training done on "",x.shape[0],""events. Saving model in tmva101.root""); ROOT.TMVA.Experimental.SaveXGBoost(bdt, ""myBDT"", ""tmva101.root"", num_inputs=x.shape[1])",MatchSource.WIKI,doc/master/tmva101__Training_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py.html
Safety,avoid,avoid,". ROOT: tutorials/tmva/tmva101_Training.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva101_Training.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ; Using XGBoost, we illustrate how you can convert an externally trained model in a format serializable and readable with the fast tree inference engine offered by TMVA.; ; # XGBoost has to be imported before ROOT to avoid crashes because of clashing; # std::regexp symbols that are exported by cppyy.; # See also: https://github.com/wlav/cppyy/issues/227; from xgboost import XGBClassifier; ; import ROOT; import numpy as np; ; from tmva100_DataPreparation import variables; ; ; def load_data(signal_filename, background_filename):; # Read data from ROOT files; data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); ; # Convert inputs to format readable by machine learning tools; x_sig = np.vstack([data_sig[var] for var in variables]).T; x_bkg = np.vstack([data_bkg[var] for var in variables]).T; x = np.vstack([x_sig, x_bkg]); ; # Create labels; num_sig = x_sig.shape[0]; num_bkg = x_bkg.shape[0]; y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); ; # Compute weights balancing both classes; num_all = num_sig + num_bkg; w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); ; return x, y, w; ; if __name__ == ""__main__"":; # Load data; x, y, w = load_data(""train_signal.root"", ""train_background.root""); ; # Fit xgboost model; bdt = XGBClassifier(max_depth=3, n_estimators=500); bdt.fit(x, y, sample_weight=w); ; # Save model in TMVA format; print(""Training done on "",x.shape[0],""events. Saving model in tmva101.root""); ROOT.TMVA.Experimental.SaveXGBoost(bdt, ""myBDT"", ""tmva101.root"", num_inputs=x.shape[1])",MatchSource.WIKI,doc/master/tmva101__Training_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py.html
Usability,learn,learning,". ROOT: tutorials/tmva/tmva101_Training.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva101_Training.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ; Using XGBoost, we illustrate how you can convert an externally trained model in a format serializable and readable with the fast tree inference engine offered by TMVA.; ; # XGBoost has to be imported before ROOT to avoid crashes because of clashing; # std::regexp symbols that are exported by cppyy.; # See also: https://github.com/wlav/cppyy/issues/227; from xgboost import XGBClassifier; ; import ROOT; import numpy as np; ; from tmva100_DataPreparation import variables; ; ; def load_data(signal_filename, background_filename):; # Read data from ROOT files; data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); ; # Convert inputs to format readable by machine learning tools; x_sig = np.vstack([data_sig[var] for var in variables]).T; x_bkg = np.vstack([data_bkg[var] for var in variables]).T; x = np.vstack([x_sig, x_bkg]); ; # Create labels; num_sig = x_sig.shape[0]; num_bkg = x_bkg.shape[0]; y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); ; # Compute weights balancing both classes; num_all = num_sig + num_bkg; w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); ; return x, y, w; ; if __name__ == ""__main__"":; # Load data; x, y, w = load_data(""train_signal.root"", ""train_background.root""); ; # Fit xgboost model; bdt = XGBClassifier(max_depth=3, n_estimators=500); bdt.fit(x, y, sample_weight=w); ; # Save model in TMVA format; print(""Training done on "",x.shape[0],""events. Saving model in tmva101.root""); ROOT.TMVA.Experimental.SaveXGBoost(bdt, ""myBDT"", ""tmva101.root"", num_inputs=x.shape[1])",MatchSource.WIKI,doc/master/tmva101__Training_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py.html
Integrability,interface,interface,"erence engine offered by TMVA.; 8##; 9## \macro_code; 10## \macro_output; 11##; 12## \date August 2019; 13## \author Stefan Wunsch; 14 ; 15# XGBoost has to be imported before ROOT to avoid crashes because of clashing; 16# std::regexp symbols that are exported by cppyy.; 17# See also: https://github.com/wlav/cppyy/issues/227; 18from xgboost import XGBClassifier; 19 ; 20import ROOT; 21import numpy as np; 22 ; 23from tmva100_DataPreparation import variables; 24 ; 25 ; 26def load_data(signal_filename, background_filename):; 27 # Read data from ROOT files; 28 data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); 29 data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); 30 ; 31 # Convert inputs to format readable by machine learning tools; 32 x_sig = np.vstack([data_sig[var] for var in variables]).T; 33 x_bkg = np.vstack([data_bkg[var] for var in variables]).T; 34 x = np.vstack([x_sig, x_bkg]); 35 ; 36 # Create labels; 37 num_sig = x_sig.shape[0]; 38 num_bkg = x_bkg.shape[0]; 39 y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); 40 ; 41 # Compute weights balancing both classes; 42 num_all = num_sig + num_bkg; 43 w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); 44 ; 45 return x, y, w; 46 ; 47if __name__ == ""__main__"":; 48 # Load data; 49 x, y, w = load_data(""train_signal.root"", ""train_background.root""); 50 ; 51 # Fit xgboost model; 52 bdt = XGBClassifier(max_depth=3, n_estimators=500); 53 bdt.fit(x, y, sample_weight=w); 54 ; 55 # Save model in TMVA format; 56 print(""Training done on "",x.shape[0],""events. Saving model in tmva101.root""); 57 ROOT.TMVA.Experimental.SaveXGBoost(bdt, ""myBDT"", ""tmva101.root"", num_inputs=x.shape[1]); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41. tutorialstmvatmva101_Training.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/tmva101__Training_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py_source.html
Modifiability,variab,variables,". ROOT: tutorials/tmva/tmva101_Training.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva101_Training.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_tmva; 3## \notebook -nodraw; 4## This tutorial show how you can train a machine learning model with any package; 5## reading the training data directly from ROOT files. Using XGBoost, we illustrate; 6## how you can convert an externally trained model in a format serializable and readable; 7## with the fast tree inference engine offered by TMVA.; 8##; 9## \macro_code; 10## \macro_output; 11##; 12## \date August 2019; 13## \author Stefan Wunsch; 14 ; 15# XGBoost has to be imported before ROOT to avoid crashes because of clashing; 16# std::regexp symbols that are exported by cppyy.; 17# See also: https://github.com/wlav/cppyy/issues/227; 18from xgboost import XGBClassifier; 19 ; 20import ROOT; 21import numpy as np; 22 ; 23from tmva100_DataPreparation import variables; 24 ; 25 ; 26def load_data(signal_filename, background_filename):; 27 # Read data from ROOT files; 28 data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); 29 data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); 30 ; 31 # Convert inputs to format readable by machine learning tools; 32 x_sig = np.vstack([data_sig[var] for var in variables]).T; 33 x_bkg = np.vstack([data_bkg[var] for var in variables]).T; 34 x = np.vstack([x_sig, x_bkg]); 35 ; 36 # Create labels; 37 num_sig = x_sig.shape[0]; 38 num_bkg = x_bkg.shape[0]; 39 y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); 40 ; 41 # Compute weights balancing both classes; 42 num_all = num_sig + num_bkg; 43 w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); 44 ; 45 return x, y, w; 46 ; 47if __name__ == ""__main__"":; 48 # Load data; 49 x, y, w = load_data(""train_signal.root"", ""train_background.root""); 50 ; 51 # Fit xgboost model; 52 bdt = XGBClassifier(max_depth=3, n",MatchSource.WIKI,doc/master/tmva101__Training_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py_source.html
Safety,avoid,avoid,". ROOT: tutorials/tmva/tmva101_Training.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva101_Training.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_tmva; 3## \notebook -nodraw; 4## This tutorial show how you can train a machine learning model with any package; 5## reading the training data directly from ROOT files. Using XGBoost, we illustrate; 6## how you can convert an externally trained model in a format serializable and readable; 7## with the fast tree inference engine offered by TMVA.; 8##; 9## \macro_code; 10## \macro_output; 11##; 12## \date August 2019; 13## \author Stefan Wunsch; 14 ; 15# XGBoost has to be imported before ROOT to avoid crashes because of clashing; 16# std::regexp symbols that are exported by cppyy.; 17# See also: https://github.com/wlav/cppyy/issues/227; 18from xgboost import XGBClassifier; 19 ; 20import ROOT; 21import numpy as np; 22 ; 23from tmva100_DataPreparation import variables; 24 ; 25 ; 26def load_data(signal_filename, background_filename):; 27 # Read data from ROOT files; 28 data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); 29 data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); 30 ; 31 # Convert inputs to format readable by machine learning tools; 32 x_sig = np.vstack([data_sig[var] for var in variables]).T; 33 x_bkg = np.vstack([data_bkg[var] for var in variables]).T; 34 x = np.vstack([x_sig, x_bkg]); 35 ; 36 # Create labels; 37 num_sig = x_sig.shape[0]; 38 num_bkg = x_bkg.shape[0]; 39 y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); 40 ; 41 # Compute weights balancing both classes; 42 num_all = num_sig + num_bkg; 43 w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); 44 ; 45 return x, y, w; 46 ; 47if __name__ == ""__main__"":; 48 # Load data; 49 x, y, w = load_data(""train_signal.root"", ""train_background.root""); 50 ; 51 # Fit xgboost model; 52 bdt = XGBClassifier(max_depth=3, n",MatchSource.WIKI,doc/master/tmva101__Training_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py_source.html
Usability,learn,learning,". ROOT: tutorials/tmva/tmva101_Training.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva101_Training.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_tmva; 3## \notebook -nodraw; 4## This tutorial show how you can train a machine learning model with any package; 5## reading the training data directly from ROOT files. Using XGBoost, we illustrate; 6## how you can convert an externally trained model in a format serializable and readable; 7## with the fast tree inference engine offered by TMVA.; 8##; 9## \macro_code; 10## \macro_output; 11##; 12## \date August 2019; 13## \author Stefan Wunsch; 14 ; 15# XGBoost has to be imported before ROOT to avoid crashes because of clashing; 16# std::regexp symbols that are exported by cppyy.; 17# See also: https://github.com/wlav/cppyy/issues/227; 18from xgboost import XGBClassifier; 19 ; 20import ROOT; 21import numpy as np; 22 ; 23from tmva100_DataPreparation import variables; 24 ; 25 ; 26def load_data(signal_filename, background_filename):; 27 # Read data from ROOT files; 28 data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); 29 data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); 30 ; 31 # Convert inputs to format readable by machine learning tools; 32 x_sig = np.vstack([data_sig[var] for var in variables]).T; 33 x_bkg = np.vstack([data_bkg[var] for var in variables]).T; 34 x = np.vstack([x_sig, x_bkg]); 35 ; 36 # Create labels; 37 num_sig = x_sig.shape[0]; 38 num_bkg = x_bkg.shape[0]; 39 y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); 40 ; 41 # Compute weights balancing both classes; 42 num_all = num_sig + num_bkg; 43 w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); 44 ; 45 return x, y, w; 46 ; 47if __name__ == ""__main__"":; 48 # Load data; 49 x, y, w = load_data(""train_signal.root"", ""train_background.root""); 50 ; 51 # Fit xgboost model; 52 bdt = XGBClassifier(max_depth=3, n",MatchSource.WIKI,doc/master/tmva101__Training_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py_source.html
Modifiability,variab,variables,". ROOT: tutorials/tmva/tmva102_Testing.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva102_Testing.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ; ; import ROOT; import pickle; ; from tmva100_DataPreparation import variables; from tmva101_Training import load_data; ; ; # Load data; x, y_true, w = load_data(""test_signal.root"", ""test_background.root""); ; # Load trained model; File = ""tmva101.root""; if (ROOT.gSystem.AccessPathName(File)) :; ROOT.Info(""tmva102_Testing.py"", File+""does not exist""); exit(); ; bdt = ROOT.TMVA.Experimental.RBDT(""myBDT"", File); ; # Make prediction; y_pred = bdt.Compute(x); ; # Compute ROC using sklearn; from sklearn.metrics import roc_curve, auc; false_positive_rate, true_positive_rate, _ = roc_curve(y_true, y_pred, sample_weight=w); score = auc(false_positive_rate, true_positive_rate); ; # Plot ROC; c = ROOT.TCanvas(""roc"", """", 600, 600); g = ROOT.TGraph(len(false_positive_rate), false_positive_rate, true_positive_rate); g.SetTitle(""AUC = {:.2f}"".format(score)); g.SetLineWidth(3); g.SetLineColor(ROOT.kRed); g.Draw(""AC""); g.GetXaxis().SetRangeUser(0, 1); g.GetYaxis().SetRangeUser(0, 1); g.GetXaxis().SetTitle(""False-positive rate""); g.GetYaxis().SetTitle(""True-positive rate""); c.Draw(); lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text con",MatchSource.WIKI,doc/master/tmva102__Testing_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva102__Testing_8py.html
Safety,predict,prediction,". ROOT: tutorials/tmva/tmva102_Testing.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva102_Testing.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ; ; import ROOT; import pickle; ; from tmva100_DataPreparation import variables; from tmva101_Training import load_data; ; ; # Load data; x, y_true, w = load_data(""test_signal.root"", ""test_background.root""); ; # Load trained model; File = ""tmva101.root""; if (ROOT.gSystem.AccessPathName(File)) :; ROOT.Info(""tmva102_Testing.py"", File+""does not exist""); exit(); ; bdt = ROOT.TMVA.Experimental.RBDT(""myBDT"", File); ; # Make prediction; y_pred = bdt.Compute(x); ; # Compute ROC using sklearn; from sklearn.metrics import roc_curve, auc; false_positive_rate, true_positive_rate, _ = roc_curve(y_true, y_pred, sample_weight=w); score = auc(false_positive_rate, true_positive_rate); ; # Plot ROC; c = ROOT.TCanvas(""roc"", """", 600, 600); g = ROOT.TGraph(len(false_positive_rate), false_positive_rate, true_positive_rate); g.SetTitle(""AUC = {:.2f}"".format(score)); g.SetLineWidth(3); g.SetLineColor(ROOT.kRed); g.Draw(""AC""); g.GetXaxis().SetRangeUser(0, 1); g.GetYaxis().SetRangeUser(0, 1); g.GetXaxis().SetTitle(""False-positive rate""); g.GetYaxis().SetTitle(""True-positive rate""); c.Draw(); lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text con",MatchSource.WIKI,doc/master/tmva102__Testing_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva102__Testing_8py.html
Testability,test,test,". ROOT: tutorials/tmva/tmva102_Testing.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva102_Testing.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ; ; import ROOT; import pickle; ; from tmva100_DataPreparation import variables; from tmva101_Training import load_data; ; ; # Load data; x, y_true, w = load_data(""test_signal.root"", ""test_background.root""); ; # Load trained model; File = ""tmva101.root""; if (ROOT.gSystem.AccessPathName(File)) :; ROOT.Info(""tmva102_Testing.py"", File+""does not exist""); exit(); ; bdt = ROOT.TMVA.Experimental.RBDT(""myBDT"", File); ; # Make prediction; y_pred = bdt.Compute(x); ; # Compute ROC using sklearn; from sklearn.metrics import roc_curve, auc; false_positive_rate, true_positive_rate, _ = roc_curve(y_true, y_pred, sample_weight=w); score = auc(false_positive_rate, true_positive_rate); ; # Plot ROC; c = ROOT.TCanvas(""roc"", """", 600, 600); g = ROOT.TGraph(len(false_positive_rate), false_positive_rate, true_positive_rate); g.SetTitle(""AUC = {:.2f}"".format(score)); g.SetLineWidth(3); g.SetLineColor(ROOT.kRed); g.Draw(""AC""); g.GetXaxis().SetRangeUser(0, 1); g.GetYaxis().SetRangeUser(0, 1); g.GetXaxis().SetTitle(""False-positive rate""); g.GetYaxis().SetTitle(""True-positive rate""); c.Draw(); lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text con",MatchSource.WIKI,doc/master/tmva102__Testing_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva102__Testing_8py.html
Usability,learn,learn,". ROOT: tutorials/tmva/tmva102_Testing.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva102_Testing.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ; ; import ROOT; import pickle; ; from tmva100_DataPreparation import variables; from tmva101_Training import load_data; ; ; # Load data; x, y_true, w = load_data(""test_signal.root"", ""test_background.root""); ; # Load trained model; File = ""tmva101.root""; if (ROOT.gSystem.AccessPathName(File)) :; ROOT.Info(""tmva102_Testing.py"", File+""does not exist""); exit(); ; bdt = ROOT.TMVA.Experimental.RBDT(""myBDT"", File); ; # Make prediction; y_pred = bdt.Compute(x); ; # Compute ROC using sklearn; from sklearn.metrics import roc_curve, auc; false_positive_rate, true_positive_rate, _ = roc_curve(y_true, y_pred, sample_weight=w); score = auc(false_positive_rate, true_positive_rate); ; # Plot ROC; c = ROOT.TCanvas(""roc"", """", 600, 600); g = ROOT.TGraph(len(false_positive_rate), false_positive_rate, true_positive_rate); g.SetTitle(""AUC = {:.2f}"".format(score)); g.SetLineWidth(3); g.SetLineColor(ROOT.kRed); g.Draw(""AC""); g.GetXaxis().SetRangeUser(0, 1); g.GetYaxis().SetRangeUser(0, 1); g.GetXaxis().SetTitle(""False-positive rate""); g.GetYaxis().SetTitle(""True-positive rate""); c.Draw(); lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text con",MatchSource.WIKI,doc/master/tmva102__Testing_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva102__Testing_8py.html
Deployability,pipeline,pipelines,". ROOT: tutorials/tmva/tmva103_Application.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva103_Application.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates how you can conveniently apply BDTs in C++ using the fast tree inference engine offered by TMVA. ; Supported workflows are event-by-event inference, batch inference and pipelines with RDataFrame.; ; using namespace TMVA::Experimental;; ; void tmva103_Application(); {; const char* model_filename = ""tmva101.root"";; ; if (gSystem->AccessPathName(model_filename)) {; Info(""tmva103_Application.C"", ""%s does not exist"", model_filename);; return;; }; ; // Load BDT model; RBDT bdt(""myBDT"", model_filename);; ; // Apply model on a single input; auto y1 = bdt.Compute({1.0, 2.0, 3.0, 4.0});; ; std::cout << ""Apply model on a single input vector: "" << y1[0] << std::endl;; ; // Apply model on a batch of inputs; float data[8] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0};; RTensor<float> x(data, {2, 4});; auto y2 = bdt.Compute(x);; ; std::cout << ""Apply model on an input tensor: "" << y2 << std::endl;; ; // Apply model as part of an RDataFrame workflow; ROOT::RDataFrame df(""Events"", ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/SMHiggsToZZTo4L.root"");; auto df2 = df.Filter(""nMuon >= 2""); .Filter(""nElectron >= 2""); .Define(""Muon_pt_1"", ""Muon_pt[0]""); .Define(""Muon_pt_2"", ""Muon_pt[1]""); .Define(""Electron_pt_1"", ""Electron_pt[0]""); .Define(""Electron_pt_2"", ""Electron_pt[1]""); .Define(""y"",; Compute<4, float>(bdt),; {""Muon_pt_1"", ""Muon_pt_2"", ""Electron_pt_1"", ""Electron_pt_2""});; ; std::cout << ""Mean response on the signal sample: "" << *df2.Mean(""y"") << std::endl;; }; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign Ge",MatchSource.WIKI,doc/master/tmva103__Application_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva103__Application_8C.html
Integrability,message,messages,"0, 2.0, 3.0, 4.0});; ; std::cout << ""Apply model on a single input vector: "" << y1[0] << std::endl;; ; // Apply model on a batch of inputs; float data[8] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0};; RTensor<float> x(data, {2, 4});; auto y2 = bdt.Compute(x);; ; std::cout << ""Apply model on an input tensor: "" << y2 << std::endl;; ; // Apply model as part of an RDataFrame workflow; ROOT::RDataFrame df(""Events"", ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/SMHiggsToZZTo4L.root"");; auto df2 = df.Filter(""nMuon >= 2""); .Filter(""nElectron >= 2""); .Define(""Muon_pt_1"", ""Muon_pt[0]""); .Define(""Muon_pt_2"", ""Muon_pt[1]""); .Define(""Electron_pt_1"", ""Electron_pt[0]""); .Define(""Electron_pt_2"", ""Electron_pt[1]""); .Define(""y"",; Compute<4, float>(bdt),; {""Muon_pt_1"", ""Muon_pt_2"", ""Electron_pt_1"", ""Electron_pt_2""});; ; std::cout << ""Mean response on the signal sample: "" << *df2.Mean(""y"") << std::endl;; }; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; y2Option_t Option_t TPoint TPoint const char y2Definition TGWin32VirtualXProxy.cxx:70; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TMVA::Experimental::RBDTDefinition RBDT.hxx:37; TMVA::Experimental::RTensorRTensor is a container with contiguous memory and shape information.Definition RTensor.hxx:162; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:12",MatchSource.WIKI,doc/master/tmva103__Application_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva103__Application_8C.html
Security,access,access,"endl;; ; // Apply model as part of an RDataFrame workflow; ROOT::RDataFrame df(""Events"", ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/SMHiggsToZZTo4L.root"");; auto df2 = df.Filter(""nMuon >= 2""); .Filter(""nElectron >= 2""); .Define(""Muon_pt_1"", ""Muon_pt[0]""); .Define(""Muon_pt_2"", ""Muon_pt[1]""); .Define(""Electron_pt_1"", ""Electron_pt[0]""); .Define(""Electron_pt_2"", ""Electron_pt[1]""); .Define(""y"",; Compute<4, float>(bdt),; {""Muon_pt_1"", ""Muon_pt_2"", ""Electron_pt_1"", ""Electron_pt_2""});; ; std::cout << ""Mean response on the signal sample: "" << *df2.Mean(""y"") << std::endl;; }; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; y2Option_t Option_t TPoint TPoint const char y2Definition TGWin32VirtualXProxy.cxx:70; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TMVA::Experimental::RBDTDefinition RBDT.hxx:37; TMVA::Experimental::RTensorRTensor is a container with contiguous memory and shape information.Definition RTensor.hxx:162; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; xDouble_t x[n]Definition legend1.C:17; TMVA::ExperimentalDefinition RModelParser_Keras.h:40; ; DateDecember 2018 ; AuthorStefan Wunsch ; Definition in file tmva103_Application.C. tutorialstmvatmva103_Application.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/tmva103__Application_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva103__Application_8C.html
Availability,error,error,""", nbin, 0.0, 1.0 );; if (Use[""SVM_Poly""]) histSVMP = new TH1F( ""MVA_SVM_Poly"", ""MVA_SVM_Poly"", nbin, 0.0, 1.0 );; if (Use[""SVM_Lin""]) histSVML = new TH1F( ""MVA_SVM_Lin"", ""MVA_SVM_Lin"", nbin, 0.0, 1.0 );; if (Use[""FDA_MT""]) histFDAMT = new TH1F( ""MVA_FDA_MT"", ""MVA_FDA_MT"", nbin, -2.0, 3.0 );; if (Use[""FDA_GA""]) histFDAGA = new TH1F( ""MVA_FDA_GA"", ""MVA_FDA_GA"", nbin, -2.0, 3.0 );; if (Use[""Category""]) histCat = new TH1F( ""MVA_Category"", ""MVA_Category"", nbin, -2., 2. );; if (Use[""Plugin""]) histPBdt = new TH1F( ""MVA_PBDT"", ""MVA_BDT"", nbin, -0.8, 0.8 );; ; // PDEFoam also returns per-event error, fill in histogram, and also fill significance; if (Use[""PDEFoam""]) {; histPDEFoam = new TH1F( ""MVA_PDEFoam"", ""MVA_PDEFoam"", nbin, 0, 1 );; histPDEFoamErr = new TH1F( ""MVA_PDEFoamErr"", ""MVA_PDEFoam error"", nbin, 0, 1 );; histPDEFoamSig = new TH1F( ""MVA_PDEFoamSig"", ""MVA_PDEFoam significance"", nbin, 0, 10 );; }; ; // Book example histogram for probability (the other methods are done similarly); TH1F *probHistFi(0), *rarityHistFi(0);; if (Use[""Fisher""]) {; probHistFi = new TH1F( ""MVA_Fisher_Proba"", ""MVA_Fisher_Proba"", nbin, 0, 1 );; rarityHistFi = new TH1F( ""MVA_Fisher_Rarity"", ""MVA_Fisher_Rarity"", nbin, 0, 1 );; }; ; // Prepare input tree (this must be replaced by your data source); // in this example, there is a toy tree with signal and one with background events; // we'll later on use only the ""signal"" events for the test in this example.; //; TFile *input(0);; TString fname = ""./tmva_class_example.root"";; if (!gSystem->AccessPathName( fname )) {; input = TFile::Open( fname ); // check if file in local directory exists; }; else {; TFile::SetCacheFileDir(""."");; input = TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD""); // if not: download from ROOT server; }; if (!input) {; std::cout << ""ERROR: could not open data file"" << std::endl;; exit(1);; }; std::cout << ""--- TMVAClassificationApp : Using input file: "" << input->GetName() << std::endl;; ; // Event l",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
Deployability,integrat,integrated,". ROOT: tutorials/tmva/TMVAClassificationApplication.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationApplication.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example on how to use the trained classifiers within an analysis module . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Executable: TMVAClassificationApplication. ; ; ==> Start TMVAClassificationApplication; : Booking ""BDT method"" of type ""BDT"" from dataset/weights/TMVAClassification_BDT.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_BDT.weights.xml; <HEADER> DataSetInfo : [Default] : Added class ""Signal""; <HEADER> DataSetInfo : [Default] : Added class ""Background""; : Booked classifier ""BDT"" of type: ""BDT""; : Booking ""Cuts method"" of type ""Cuts"" from dataset/weights/TMVAClassification_Cuts.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_Cuts.weights.xml; : Read cuts optimised using sample of MC events; : Reading 100 signal efficiency bins for 4 variables; : Booked classifier ""Cuts"" of type: ""Cuts""; : Booking ""CutsD method"" of type ""Cuts"" from dataset/weights/TMVAClassification_CutsD.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_CutsD.weights.xml; : Read cuts optimised using sample of MC events; : Reading 100 signal efficiency bins for 4 variables; : Booked classifier ""CutsD"" of type: ""Cuts""; : Booking ""FDA_GA method"" of type ""FDA"" from dataset/weights/TMVAClassification_FDA_GA.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_FDA_GA.weights.xml; : User-defined formula string : ""(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3""; : TFormula-compatible formula string: ""[0]+[1]*[5]+[2]*[6]+[3]*[7]+[4]*[8]""; : Booked classifier ""FDA_GA"" of type: ""FDA""; : Booking ""KNN method"" of type ""KNN"" from dataset/weights/TMVAClassification_KNN.weights.xml.; : Reading weight file: dataset/w",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
Integrability,integrat,integrated,". ROOT: tutorials/tmva/TMVAClassificationApplication.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationApplication.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example on how to use the trained classifiers within an analysis module . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Executable: TMVAClassificationApplication. ; ; ==> Start TMVAClassificationApplication; : Booking ""BDT method"" of type ""BDT"" from dataset/weights/TMVAClassification_BDT.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_BDT.weights.xml; <HEADER> DataSetInfo : [Default] : Added class ""Signal""; <HEADER> DataSetInfo : [Default] : Added class ""Background""; : Booked classifier ""BDT"" of type: ""BDT""; : Booking ""Cuts method"" of type ""Cuts"" from dataset/weights/TMVAClassification_Cuts.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_Cuts.weights.xml; : Read cuts optimised using sample of MC events; : Reading 100 signal efficiency bins for 4 variables; : Booked classifier ""Cuts"" of type: ""Cuts""; : Booking ""CutsD method"" of type ""Cuts"" from dataset/weights/TMVAClassification_CutsD.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_CutsD.weights.xml; : Read cuts optimised using sample of MC events; : Reading 100 signal efficiency bins for 4 variables; : Booked classifier ""CutsD"" of type: ""Cuts""; : Booking ""FDA_GA method"" of type ""FDA"" from dataset/weights/TMVAClassification_FDA_GA.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_FDA_GA.weights.xml; : User-defined formula string : ""(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3""; : TFormula-compatible formula string: ""[0]+[1]*[5]+[2]*[6]+[3]*[7]+[4]*[8]""; : Booked classifier ""FDA_GA"" of type: ""FDA""; : Booking ""KNN method"" of type ""KNN"" from dataset/weights/TMVAClassification_KNN.weights.xml.; : Reading weight file: dataset/w",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
Modifiability,variab,variables,"es. TMVAClassificationApplication.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example on how to use the trained classifiers within an analysis module . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Executable: TMVAClassificationApplication. ; ; ==> Start TMVAClassificationApplication; : Booking ""BDT method"" of type ""BDT"" from dataset/weights/TMVAClassification_BDT.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_BDT.weights.xml; <HEADER> DataSetInfo : [Default] : Added class ""Signal""; <HEADER> DataSetInfo : [Default] : Added class ""Background""; : Booked classifier ""BDT"" of type: ""BDT""; : Booking ""Cuts method"" of type ""Cuts"" from dataset/weights/TMVAClassification_Cuts.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_Cuts.weights.xml; : Read cuts optimised using sample of MC events; : Reading 100 signal efficiency bins for 4 variables; : Booked classifier ""Cuts"" of type: ""Cuts""; : Booking ""CutsD method"" of type ""Cuts"" from dataset/weights/TMVAClassification_CutsD.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_CutsD.weights.xml; : Read cuts optimised using sample of MC events; : Reading 100 signal efficiency bins for 4 variables; : Booked classifier ""CutsD"" of type: ""Cuts""; : Booking ""FDA_GA method"" of type ""FDA"" from dataset/weights/TMVAClassification_FDA_GA.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_FDA_GA.weights.xml; : User-defined formula string : ""(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3""; : TFormula-compatible formula string: ""[0]+[1]*[5]+[2]*[6]+[3]*[7]+[4]*[8]""; : Booked classifier ""FDA_GA"" of type: ""FDA""; : Booking ""KNN method"" of type ""KNN"" from dataset/weights/TMVAClassification_KNN.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_KNN.weights.xml; : Creating kd-tree with 2000 events; : Computing scale factor for 1d distributions: (ifrac, bottom, top)",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
Performance,load,loads,"nclude ""TMVA/Reader.h""; #include ""TMVA/MethodCuts.h""; ; using namespace TMVA;; ; void TMVAClassificationApplication( TString myMethodList = """" ); {; ; //---------------------------------------------------------------; // This loads the library; TMVA::Tools::Instance();; ; // Default MVA methods to be trained + tested; std::map<std::string,int> Use;; ; // Cut optimisation; Use[""Cuts""] = 1;; Use[""CutsD""] = 1;; Use[""CutsPCA""] = 0;; Use[""CutsGA""] = 0;; Use[""CutsSA""] = 0;; //; // 1-dimensional likelihood (""naive Bayes estimator""); Use[""Likelihood""] = 1;; Use[""LikelihoodD""] = 0; // the ""D"" extension indicates decorrelated input variables (see option strings); Use[""LikelihoodPCA""] = 1; // the ""PCA"" extension indicates PCA-transformed input variables (see option strings); Use[""LikelihoodKDE""] = 0;; Use[""LikelihoodMIX""] = 0;; //; // Mutidimensional likelihood and Nearest-Neighbour methods; Use[""PDERS""] = 1;; Use[""PDERSD""] = 0;; Use[""PDERSPCA""] = 0;; Use[""PDEFoam""] = 1;; Use[""PDEFoamBoost""] = 0; // uses generalised MVA method boosting; Use[""KNN""] = 1; // k-nearest neighbour method; //; // Linear Discriminant Analysis; Use[""LD""] = 1; // Linear Discriminant identical to Fisher; Use[""Fisher""] = 0;; Use[""FisherG""] = 0;; Use[""BoostedFisher""] = 0; // uses generalised MVA method boosting; Use[""HMatrix""] = 0;; //; // Function Discriminant analysis; Use[""FDA_GA""] = 1; // minimisation of user-defined function using Genetics Algorithm; Use[""FDA_SA""] = 0;; Use[""FDA_MC""] = 0;; Use[""FDA_MT""] = 0;; Use[""FDA_GAMT""] = 0;; Use[""FDA_MCMT""] = 0;; //; // Neural Networks (all are feed-forward Multilayer Perceptrons); Use[""MLP""] = 0; // Recommended ANN; Use[""MLPBFGS""] = 0; // Recommended ANN with optional training method; Use[""MLPBNN""] = 1; // Recommended ANN with BFGS training method and bayesian regulator; Use[""CFMlpANN""] = 0; // Depreciated ANN from ALEPH; Use[""TMlpANN""] = 0; // ROOT's own ANN; Use[""DNN_CPU""] = 0; // CUDA-accelerated DNN training.; Use[""DNN_GPU""] = 0; // Multi-core accelerated DN",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
Security,access,access,"Variable(const TString &expression, Float_t *)Add a float variable or expression to the reader.Definition Reader.cxx:303; TMVA::Reader::GetMVAErrorDouble_t GetMVAError() constDefinition Reader.h:94; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TStopwatch::Printvoid Print(Option_t *option="""") const overridePrint the real and cpu time passed between the start and stop events.Definition TStopwatch.cxx:219; TStringBasic string class.Definition TString.h:139; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; double; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; AuthorAndreas Hoecker ; Definition in file TMVAClassificationApplication.C. tutorialstmvaTMVAClassificationApplication.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
Testability,test,tested,"nclude ""TMVA/Reader.h""; #include ""TMVA/MethodCuts.h""; ; using namespace TMVA;; ; void TMVAClassificationApplication( TString myMethodList = """" ); {; ; //---------------------------------------------------------------; // This loads the library; TMVA::Tools::Instance();; ; // Default MVA methods to be trained + tested; std::map<std::string,int> Use;; ; // Cut optimisation; Use[""Cuts""] = 1;; Use[""CutsD""] = 1;; Use[""CutsPCA""] = 0;; Use[""CutsGA""] = 0;; Use[""CutsSA""] = 0;; //; // 1-dimensional likelihood (""naive Bayes estimator""); Use[""Likelihood""] = 1;; Use[""LikelihoodD""] = 0; // the ""D"" extension indicates decorrelated input variables (see option strings); Use[""LikelihoodPCA""] = 1; // the ""PCA"" extension indicates PCA-transformed input variables (see option strings); Use[""LikelihoodKDE""] = 0;; Use[""LikelihoodMIX""] = 0;; //; // Mutidimensional likelihood and Nearest-Neighbour methods; Use[""PDERS""] = 1;; Use[""PDERSD""] = 0;; Use[""PDERSPCA""] = 0;; Use[""PDEFoam""] = 1;; Use[""PDEFoamBoost""] = 0; // uses generalised MVA method boosting; Use[""KNN""] = 1; // k-nearest neighbour method; //; // Linear Discriminant Analysis; Use[""LD""] = 1; // Linear Discriminant identical to Fisher; Use[""Fisher""] = 0;; Use[""FisherG""] = 0;; Use[""BoostedFisher""] = 0; // uses generalised MVA method boosting; Use[""HMatrix""] = 0;; //; // Function Discriminant analysis; Use[""FDA_GA""] = 1; // minimisation of user-defined function using Genetics Algorithm; Use[""FDA_SA""] = 0;; Use[""FDA_MC""] = 0;; Use[""FDA_MT""] = 0;; Use[""FDA_GAMT""] = 0;; Use[""FDA_MCMT""] = 0;; //; // Neural Networks (all are feed-forward Multilayer Perceptrons); Use[""MLP""] = 0; // Recommended ANN; Use[""MLPBFGS""] = 0; // Recommended ANN with optional training method; Use[""MLPBNN""] = 1; // Recommended ANN with BFGS training method and bayesian regulator; Use[""CFMlpANN""] = 0; // Depreciated ANN from ALEPH; Use[""TMlpANN""] = 0; // ROOT's own ANN; Use[""DNN_CPU""] = 0; // CUDA-accelerated DNN training.; Use[""DNN_GPU""] = 0; // Multi-core accelerated DN",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
Usability,simpl,simple,". ROOT: tutorials/tmva/TMVAClassificationApplication.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationApplication.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example on how to use the trained classifiers within an analysis module . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Executable: TMVAClassificationApplication. ; ; ==> Start TMVAClassificationApplication; : Booking ""BDT method"" of type ""BDT"" from dataset/weights/TMVAClassification_BDT.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_BDT.weights.xml; <HEADER> DataSetInfo : [Default] : Added class ""Signal""; <HEADER> DataSetInfo : [Default] : Added class ""Background""; : Booked classifier ""BDT"" of type: ""BDT""; : Booking ""Cuts method"" of type ""Cuts"" from dataset/weights/TMVAClassification_Cuts.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_Cuts.weights.xml; : Read cuts optimised using sample of MC events; : Reading 100 signal efficiency bins for 4 variables; : Booked classifier ""Cuts"" of type: ""Cuts""; : Booking ""CutsD method"" of type ""Cuts"" from dataset/weights/TMVAClassification_CutsD.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_CutsD.weights.xml; : Read cuts optimised using sample of MC events; : Reading 100 signal efficiency bins for 4 variables; : Booked classifier ""CutsD"" of type: ""Cuts""; : Booking ""FDA_GA method"" of type ""FDA"" from dataset/weights/TMVAClassification_FDA_GA.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_FDA_GA.weights.xml; : User-defined formula string : ""(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3""; : TFormula-compatible formula string: ""[0]+[1]*[5]+[2]*[6]+[3]*[7]+[4]*[8]""; : Booked classifier ""FDA_GA"" of type: ""FDA""; : Booking ""KNN method"" of type ""KNN"" from dataset/weights/TMVAClassification_KNN.weights.xml.; : Reading weight file: dataset/w",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
Availability,error,error,"w TH1F( ""MVA_SVM_Poly"", ""MVA_SVM_Poly"", nbin, 0.0, 1.0 );; 243 if (Use[""SVM_Lin""]) histSVML = new TH1F( ""MVA_SVM_Lin"", ""MVA_SVM_Lin"", nbin, 0.0, 1.0 );; 244 if (Use[""FDA_MT""]) histFDAMT = new TH1F( ""MVA_FDA_MT"", ""MVA_FDA_MT"", nbin, -2.0, 3.0 );; 245 if (Use[""FDA_GA""]) histFDAGA = new TH1F( ""MVA_FDA_GA"", ""MVA_FDA_GA"", nbin, -2.0, 3.0 );; 246 if (Use[""Category""]) histCat = new TH1F( ""MVA_Category"", ""MVA_Category"", nbin, -2., 2. );; 247 if (Use[""Plugin""]) histPBdt = new TH1F( ""MVA_PBDT"", ""MVA_BDT"", nbin, -0.8, 0.8 );; 248 ; 249 // PDEFoam also returns per-event error, fill in histogram, and also fill significance; 250 if (Use[""PDEFoam""]) {; 251 histPDEFoam = new TH1F( ""MVA_PDEFoam"", ""MVA_PDEFoam"", nbin, 0, 1 );; 252 histPDEFoamErr = new TH1F( ""MVA_PDEFoamErr"", ""MVA_PDEFoam error"", nbin, 0, 1 );; 253 histPDEFoamSig = new TH1F( ""MVA_PDEFoamSig"", ""MVA_PDEFoam significance"", nbin, 0, 10 );; 254 }; 255 ; 256 // Book example histogram for probability (the other methods are done similarly); 257 TH1F *probHistFi(0), *rarityHistFi(0);; 258 if (Use[""Fisher""]) {; 259 probHistFi = new TH1F( ""MVA_Fisher_Proba"", ""MVA_Fisher_Proba"", nbin, 0, 1 );; 260 rarityHistFi = new TH1F( ""MVA_Fisher_Rarity"", ""MVA_Fisher_Rarity"", nbin, 0, 1 );; 261 }; 262 ; 263 // Prepare input tree (this must be replaced by your data source); 264 // in this example, there is a toy tree with signal and one with background events; 265 // we'll later on use only the ""signal"" events for the test in this example.; 266 //; 267 TFile *input(0);; 268 TString fname = ""./tmva_class_example.root"";; 269 if (!gSystem->AccessPathName( fname )) {; 270 input = TFile::Open( fname ); // check if file in local directory exists; 271 }; 272 else {; 273 TFile::SetCacheFileDir(""."");; 274 input = TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD""); // if not: download from ROOT server; 275 }; 276 if (!input) {; 277 std::cout << ""ERROR: could not open data file"" << std::endl;; 278 exit(1);; 279 }; 280 std::cout << ",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
Deployability,integrat,integrated,". ROOT: tutorials/tmva/TMVAClassificationApplication.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationApplication.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_tmva; 3/// \notebook -nodraw; 4/// This macro provides a simple example on how to use the trained classifiers; 5/// within an analysis module; 6/// - Project : TMVA - a Root-integrated toolkit for multivariate data analysis; 7/// - Package : TMVA; 8/// - Executable: TMVAClassificationApplication; 9///; 10/// \macro_output; 11/// \macro_code; 12/// \author Andreas Hoecker; 13 ; 14#include <cstdlib>; 15#include <vector>; 16#include <iostream>; 17#include <map>; 18#include <string>; 19 ; 20#include ""TFile.h""; 21#include ""TTree.h""; 22#include ""TString.h""; 23#include ""TSystem.h""; 24#include ""TROOT.h""; 25#include ""TStopwatch.h""; 26 ; 27#include ""TMVA/Tools.h""; 28#include ""TMVA/Reader.h""; 29#include ""TMVA/MethodCuts.h""; 30 ; 31using namespace TMVA;; 32 ; 33void TMVAClassificationApplication( TString myMethodList = """" ); 34{; 35 ; 36 //---------------------------------------------------------------; 37 // This loads the library; 38 TMVA::Tools::Instance();; 39 ; 40 // Default MVA methods to be trained + tested; 41 std::map<std::string,int> Use;; 42 ; 43 // Cut optimisation; 44 Use[""Cuts""] = 1;; 45 Use[""CutsD""] = 1;; 46 Use[""CutsPCA""] = 0;; 47 Use[""CutsGA""] = 0;; 48 Use[""CutsSA""] = 0;; 49 //; 50 // 1-dimensional likelihood (""naive Bayes estimator""); 51 Use[""Likelihood""] = 1;; 52 Use[""LikelihoodD""] = 0; // the ""D"" extension indicates decorrelated input variables (see option strings); 53 Use[""LikelihoodPCA""] = 1; // the ""PCA"" extension indicates PCA-transformed input variables (see option strings); 54 Use[""LikelihoodKDE""] = 0;; 55 Use[""LikelihoodMIX""] = 0;; 56 //; 57 // Mutidimensional likelihood and Nearest-Neighbour methods; 58 Use[""PDERS""] = 1;; 59 Use[""PDERSD""] = 0;; 60 Use[""PDERSPCA""] = 0;; 61 Use[""PDEFoam""] = 1;; 62 Use[""",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
Integrability,integrat,integrated,". ROOT: tutorials/tmva/TMVAClassificationApplication.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationApplication.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_tmva; 3/// \notebook -nodraw; 4/// This macro provides a simple example on how to use the trained classifiers; 5/// within an analysis module; 6/// - Project : TMVA - a Root-integrated toolkit for multivariate data analysis; 7/// - Package : TMVA; 8/// - Executable: TMVAClassificationApplication; 9///; 10/// \macro_output; 11/// \macro_code; 12/// \author Andreas Hoecker; 13 ; 14#include <cstdlib>; 15#include <vector>; 16#include <iostream>; 17#include <map>; 18#include <string>; 19 ; 20#include ""TFile.h""; 21#include ""TTree.h""; 22#include ""TString.h""; 23#include ""TSystem.h""; 24#include ""TROOT.h""; 25#include ""TStopwatch.h""; 26 ; 27#include ""TMVA/Tools.h""; 28#include ""TMVA/Reader.h""; 29#include ""TMVA/MethodCuts.h""; 30 ; 31using namespace TMVA;; 32 ; 33void TMVAClassificationApplication( TString myMethodList = """" ); 34{; 35 ; 36 //---------------------------------------------------------------; 37 // This loads the library; 38 TMVA::Tools::Instance();; 39 ; 40 // Default MVA methods to be trained + tested; 41 std::map<std::string,int> Use;; 42 ; 43 // Cut optimisation; 44 Use[""Cuts""] = 1;; 45 Use[""CutsD""] = 1;; 46 Use[""CutsPCA""] = 0;; 47 Use[""CutsGA""] = 0;; 48 Use[""CutsSA""] = 0;; 49 //; 50 // 1-dimensional likelihood (""naive Bayes estimator""); 51 Use[""Likelihood""] = 1;; 52 Use[""LikelihoodD""] = 0; // the ""D"" extension indicates decorrelated input variables (see option strings); 53 Use[""LikelihoodPCA""] = 1; // the ""PCA"" extension indicates PCA-transformed input variables (see option strings); 54 Use[""LikelihoodKDE""] = 0;; 55 Use[""LikelihoodMIX""] = 0;; 56 //; 57 // Mutidimensional likelihood and Nearest-Neighbour methods; 58 Use[""PDERS""] = 1;; 59 Use[""PDERSD""] = 0;; 60 Use[""PDERSPCA""] = 0;; 61 Use[""PDEFoam""] = 1;; 62 Use[""",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
Modifiability,variab,variables,"h""; 30 ; 31using namespace TMVA;; 32 ; 33void TMVAClassificationApplication( TString myMethodList = """" ); 34{; 35 ; 36 //---------------------------------------------------------------; 37 // This loads the library; 38 TMVA::Tools::Instance();; 39 ; 40 // Default MVA methods to be trained + tested; 41 std::map<std::string,int> Use;; 42 ; 43 // Cut optimisation; 44 Use[""Cuts""] = 1;; 45 Use[""CutsD""] = 1;; 46 Use[""CutsPCA""] = 0;; 47 Use[""CutsGA""] = 0;; 48 Use[""CutsSA""] = 0;; 49 //; 50 // 1-dimensional likelihood (""naive Bayes estimator""); 51 Use[""Likelihood""] = 1;; 52 Use[""LikelihoodD""] = 0; // the ""D"" extension indicates decorrelated input variables (see option strings); 53 Use[""LikelihoodPCA""] = 1; // the ""PCA"" extension indicates PCA-transformed input variables (see option strings); 54 Use[""LikelihoodKDE""] = 0;; 55 Use[""LikelihoodMIX""] = 0;; 56 //; 57 // Mutidimensional likelihood and Nearest-Neighbour methods; 58 Use[""PDERS""] = 1;; 59 Use[""PDERSD""] = 0;; 60 Use[""PDERSPCA""] = 0;; 61 Use[""PDEFoam""] = 1;; 62 Use[""",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
Performance,load,loads,"h""; 30 ; 31using namespace TMVA;; 32 ; 33void TMVAClassificationApplication( TString myMethodList = """" ); 34{; 35 ; 36 //---------------------------------------------------------------; 37 // This loads the library; 38 TMVA::Tools::Instance();; 39 ; 40 // Default MVA methods to be trained + tested; 41 std::map<std::string,int> Use;; 42 ; 43 // Cut optimisation; 44 Use[""Cuts""] = 1;; 45 Use[""CutsD""] = 1;; 46 Use[""CutsPCA""] = 0;; 47 Use[""CutsGA""] = 0;; 48 Use[""CutsSA""] = 0;; 49 //; 50 // 1-dimensional likelihood (""naive Bayes estimator""); 51 Use[""Likelihood""] = 1;; 52 Use[""LikelihoodD""] = 0; // the ""D"" extension indicates decorrelated input variables (see option strings); 53 Use[""LikelihoodPCA""] = 1; // the ""PCA"" extension indicates PCA-transformed input variables (see option strings); 54 Use[""LikelihoodKDE""] = 0;; 55 Use[""LikelihoodMIX""] = 0;; 56 //; 57 // Mutidimensional likelihood and Nearest-Neighbour methods; 58 Use[""PDERS""] = 1;; 59 Use[""PDERSD""] = 0;; 60 Use[""PDERSPCA""] = 0;; 61 Use[""PDEFoam""] = 1;; 62 Use[""",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
Security,access,access,"der.cxx:321; TMVA::Reader::AddVariablevoid AddVariable(const TString &expression, Float_t *)Add a float variable or expression to the reader.Definition Reader.cxx:303; TMVA::Reader::GetMVAErrorDouble_t GetMVAError() constDefinition Reader.h:94; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TStopwatch::Printvoid Print(Option_t *option="""") const overridePrint the real and cpu time passed between the start and stop events.Definition TStopwatch.cxx:219; TStringBasic string class.Definition TString.h:139; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; double; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; TMVA::gToolsTools & gTools(). tutorialstmvaTMVAClassificationApplication.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
Testability,test,tested,"h""; 30 ; 31using namespace TMVA;; 32 ; 33void TMVAClassificationApplication( TString myMethodList = """" ); 34{; 35 ; 36 //---------------------------------------------------------------; 37 // This loads the library; 38 TMVA::Tools::Instance();; 39 ; 40 // Default MVA methods to be trained + tested; 41 std::map<std::string,int> Use;; 42 ; 43 // Cut optimisation; 44 Use[""Cuts""] = 1;; 45 Use[""CutsD""] = 1;; 46 Use[""CutsPCA""] = 0;; 47 Use[""CutsGA""] = 0;; 48 Use[""CutsSA""] = 0;; 49 //; 50 // 1-dimensional likelihood (""naive Bayes estimator""); 51 Use[""Likelihood""] = 1;; 52 Use[""LikelihoodD""] = 0; // the ""D"" extension indicates decorrelated input variables (see option strings); 53 Use[""LikelihoodPCA""] = 1; // the ""PCA"" extension indicates PCA-transformed input variables (see option strings); 54 Use[""LikelihoodKDE""] = 0;; 55 Use[""LikelihoodMIX""] = 0;; 56 //; 57 // Mutidimensional likelihood and Nearest-Neighbour methods; 58 Use[""PDERS""] = 1;; 59 Use[""PDERSD""] = 0;; 60 Use[""PDERSPCA""] = 0;; 61 Use[""PDEFoam""] = 1;; 62 Use[""",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
Usability,simpl,simple,". ROOT: tutorials/tmva/TMVAClassificationApplication.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationApplication.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_tmva; 3/// \notebook -nodraw; 4/// This macro provides a simple example on how to use the trained classifiers; 5/// within an analysis module; 6/// - Project : TMVA - a Root-integrated toolkit for multivariate data analysis; 7/// - Package : TMVA; 8/// - Executable: TMVAClassificationApplication; 9///; 10/// \macro_output; 11/// \macro_code; 12/// \author Andreas Hoecker; 13 ; 14#include <cstdlib>; 15#include <vector>; 16#include <iostream>; 17#include <map>; 18#include <string>; 19 ; 20#include ""TFile.h""; 21#include ""TTree.h""; 22#include ""TString.h""; 23#include ""TSystem.h""; 24#include ""TROOT.h""; 25#include ""TStopwatch.h""; 26 ; 27#include ""TMVA/Tools.h""; 28#include ""TMVA/Reader.h""; 29#include ""TMVA/MethodCuts.h""; 30 ; 31using namespace TMVA;; 32 ; 33void TMVAClassificationApplication( TString myMethodList = """" ); 34{; 35 ; 36 //---------------------------------------------------------------; 37 // This loads the library; 38 TMVA::Tools::Instance();; 39 ; 40 // Default MVA methods to be trained + tested; 41 std::map<std::string,int> Use;; 42 ; 43 // Cut optimisation; 44 Use[""Cuts""] = 1;; 45 Use[""CutsD""] = 1;; 46 Use[""CutsPCA""] = 0;; 47 Use[""CutsGA""] = 0;; 48 Use[""CutsSA""] = 0;; 49 //; 50 // 1-dimensional likelihood (""naive Bayes estimator""); 51 Use[""Likelihood""] = 1;; 52 Use[""LikelihoodD""] = 0; // the ""D"" extension indicates decorrelated input variables (see option strings); 53 Use[""LikelihoodPCA""] = 1; // the ""PCA"" extension indicates PCA-transformed input variables (see option strings); 54 Use[""LikelihoodKDE""] = 0;; 55 Use[""LikelihoodMIX""] = 0;; 56 //; 57 // Mutidimensional likelihood and Nearest-Neighbour methods; 58 Use[""PDERS""] = 1;; 59 Use[""PDERSD""] = 0;; 60 Use[""PDERSPCA""] = 0;; 61 Use[""PDEFoam""] = 1;; 62 Use[""",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
Deployability,integrat,integrated,". ROOT: tutorials/tmva/TMVAClassificationCategoryApplication.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationCategoryApplication.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Executable: TMVAClassificationCategoryApplication. ; ; ==> Start TMVAClassificationCategoryApplication; : Booking ""FisherCat method"" of type ""Category"" from dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml.; : Reading weight file: dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml; <HEADER> DataSetInfo : [Default] : Added class ""Signal""; <HEADER> DataSetInfo : [Default] : Added class ""Background""; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; : Booked classifier ""FisherCat"" of type: ""Category""; : Booking ""LikelihoodCat method"" of type ""Category"" from dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml.; : Reading weight file: dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Background""; : Booked classifier ""LikelihoodCat"" of type: ""Category""; --- TMVAClassificationApp : Accessing /home/sftnight/build/workspace/root",MatchSource.WIKI,doc/master/TMVAClassificationCategoryApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html
Integrability,integrat,integrated,". ROOT: tutorials/tmva/TMVAClassificationCategoryApplication.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationCategoryApplication.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Executable: TMVAClassificationCategoryApplication. ; ; ==> Start TMVAClassificationCategoryApplication; : Booking ""FisherCat method"" of type ""Category"" from dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml.; : Reading weight file: dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml; <HEADER> DataSetInfo : [Default] : Added class ""Signal""; <HEADER> DataSetInfo : [Default] : Added class ""Background""; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; : Booked classifier ""FisherCat"" of type: ""Category""; : Booking ""LikelihoodCat method"" of type ""Category"" from dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml.; : Reading weight file: dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Background""; : Booked classifier ""LikelihoodCat"" of type: ""Category""; --- TMVAClassificationApp : Accessing /home/sftnight/build/workspace/root",MatchSource.WIKI,doc/master/TMVAClassificationCategoryApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html
Modifiability,variab,variables,".070; --- Created root file: ""TMVApp.root"" containing the MVA output histograms; ==> TMVAClassificationApplication is done!; ; ; ; #include <cstdlib>; #include <vector>; #include <iostream>; #include <map>; #include <string>; ; #include ""TFile.h""; #include ""TTree.h""; #include ""TString.h""; #include ""TSystem.h""; #include ""TROOT.h""; #include ""TH1F.h""; #include ""TStopwatch.h""; ; #include ""TMVA/Tools.h""; #include ""TMVA/Reader.h""; #include ""TMVA/MethodCuts.h""; ; // two types of category methods are implemented; Bool_t UseOffsetMethod = kTRUE;; ; void TMVAClassificationCategoryApplication(); {; // ---------------------------------------------------------------; // default MVA methods to be trained + tested; std::map<std::string,int> Use;; //; Use[""LikelihoodCat""] = 1;; Use[""FisherCat""] = 1;; // ---------------------------------------------------------------; ; std::cout << std::endl; << ""==> Start TMVAClassificationCategoryApplication"" << std::endl;; ; // Create the Reader object; ; TMVA::Reader *reader = new TMVA::Reader( ""!Color:!Silent"" );; ; // Create a set of variables and spectators and declare them to the reader; // - the variable names MUST corresponds in name and type to those given in the weight file(s) used; Float_t var1, var2, var3, var4, eta;; reader->AddVariable( ""var1"", &var1 );; reader->AddVariable( ""var2"", &var2 );; reader->AddVariable( ""var3"", &var3 );; reader->AddVariable( ""var4"", &var4 );; ; reader->AddSpectator( ""eta"", &eta );; ; // Book the MVA methods; ; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) {; if (it->second) {; TString methodName = it->first + "" method"";; TString weightfile = ""dataset/weights/TMVAClassificationCategory_"" + TString(it->first) + "".weights.xml"";; reader->BookMVA( methodName, weightfile );; }; }; ; // Book output histograms; UInt_t nbin = 100;; std::map<std::string,TH1*> hist;; hist[""LikelihoodCat""] = new TH1F( ""MVA_LikelihoodCat"", ""MVA_LikelihoodCat"", nbin, -1, 0.9999 );; hist[""FisherCat""] =",MatchSource.WIKI,doc/master/TMVAClassificationCategoryApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html
Security,access,access,"finition Reader.cxx:468; TMVA::Reader::BookMVAIMethod * BookMVA(const TString &methodTag, const TString &weightfile)read method name from weight fileDefinition Reader.cxx:368; TMVA::Reader::AddSpectatorvoid AddSpectator(const TString &expression, Float_t *)Add a float spectator or expression to the reader.Definition Reader.cxx:321; TMVA::Reader::AddVariablevoid AddVariable(const TString &expression, Float_t *)Add a float variable or expression to the reader.Definition Reader.cxx:303; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TStopwatch::Printvoid Print(Option_t *option="""") const overridePrint the real and cpu time passed between the start and stop events.Definition TStopwatch.cxx:219; TStringBasic string class.Definition TString.h:139; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; AuthorAndreas Hoecker ; Definition in file TMVAClassificationCategoryApplication.C. tutorialstmvaTMVAClassificationCategoryApplication.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMVAClassificationCategoryApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html
Testability,test,tested,".070; --- Created root file: ""TMVApp.root"" containing the MVA output histograms; ==> TMVAClassificationApplication is done!; ; ; ; #include <cstdlib>; #include <vector>; #include <iostream>; #include <map>; #include <string>; ; #include ""TFile.h""; #include ""TTree.h""; #include ""TString.h""; #include ""TSystem.h""; #include ""TROOT.h""; #include ""TH1F.h""; #include ""TStopwatch.h""; ; #include ""TMVA/Tools.h""; #include ""TMVA/Reader.h""; #include ""TMVA/MethodCuts.h""; ; // two types of category methods are implemented; Bool_t UseOffsetMethod = kTRUE;; ; void TMVAClassificationCategoryApplication(); {; // ---------------------------------------------------------------; // default MVA methods to be trained + tested; std::map<std::string,int> Use;; //; Use[""LikelihoodCat""] = 1;; Use[""FisherCat""] = 1;; // ---------------------------------------------------------------; ; std::cout << std::endl; << ""==> Start TMVAClassificationCategoryApplication"" << std::endl;; ; // Create the Reader object; ; TMVA::Reader *reader = new TMVA::Reader( ""!Color:!Silent"" );; ; // Create a set of variables and spectators and declare them to the reader; // - the variable names MUST corresponds in name and type to those given in the weight file(s) used; Float_t var1, var2, var3, var4, eta;; reader->AddVariable( ""var1"", &var1 );; reader->AddVariable( ""var2"", &var2 );; reader->AddVariable( ""var3"", &var3 );; reader->AddVariable( ""var4"", &var4 );; ; reader->AddSpectator( ""eta"", &eta );; ; // Book the MVA methods; ; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) {; if (it->second) {; TString methodName = it->first + "" method"";; TString weightfile = ""dataset/weights/TMVAClassificationCategory_"" + TString(it->first) + "".weights.xml"";; reader->BookMVA( methodName, weightfile );; }; }; ; // Book output histograms; UInt_t nbin = 100;; std::map<std::string,TH1*> hist;; hist[""LikelihoodCat""] = new TH1F( ""MVA_LikelihoodCat"", ""MVA_LikelihoodCat"", nbin, -1, 0.9999 );; hist[""FisherCat""] =",MatchSource.WIKI,doc/master/TMVAClassificationCategoryApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html
