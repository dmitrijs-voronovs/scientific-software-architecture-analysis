quality_attribute,keyword,matched_word,sentence,source,filename,author,repo,version,wiki,url
Testability,log,logical,"ciates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; std::cout << ""Error opening file"" << std::endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile.Recover: 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of th",MatchSource.WIKI,root/html602/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFile.html
Usability,usab,usable," via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument ",MatchSource.WIKI,root/html602/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFile.html
Availability,error,error,"SE); virtual voidAddNoCacheBytesRead(Long64_t len); virtual voidAddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetBufferSize() const; virtual Long64_tGetBytesRead() const; virtual Long64_tGetBytesReadExtra() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFile*GetFile() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Long64_tGetNoCacheBytesRead() const; virtual Int_tGetNoCacheReadCalls() const; Int_tGetNseek() const; Int_tGetNtot() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long64_tGetPrefetchedBlocks() const; virtu",MatchSource.WIKI,root/html602/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileCacheRead.html
Modifiability,variab,variable,", Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. void SecondSort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary.; Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFilePrefetch* GetPrefetchObj(). void WaitFinishPrefetch(). void SetEnablePrefetching(Bool_t setPrefetching = kFALSE); Set the prefetching mode of this file.; if 'setPrefetching', enable the asynchronous prefetching; (using TFilePrefetch) and if the gEnv and rootrc; variable Cache.Directory is set, also enable the local; caching of the prefetched blocks.; if 'setPrefetching', the old prefetcher is enabled is; the gEnv and rootrc variable is TFile.AsyncReading. void SetEnablePrefetchingImpl(Bool_t setPrefetching = kFALSE); TFileCacheRead implementation of SetEnablePrefetching. This function is called from the constructor and should not be virtual. TFileCacheRead(const TFileCacheRead& ). TFileCacheRead& operator=(const TFileCacheRead& ). void AddBranch(TBranch* , Bool_t = kFALSE); {}. void AddBranch(const char* , Bool_t = kFALSE); {}. void AddNoCacheBytesRead(Long64_t len); { fNoCacheBytesRead += len; }. void AddNoCacheReadCalls(Int_t reads); { fNoCacheReadCalls += reads; }. Int_t GetBufferSize() const; { return fBufferSize; }. Long64_t GetBytesRead() const; { return fBytesRead; }. Long64_t GetNoCacheBytesRead() const; { return fNoCacheBytesRead; }. Long64_t GetBytesReadExtra() const; { return fBytesRea",MatchSource.WIKI,root/html602/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileCacheRead.html
Performance,cache,cache,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidAddNoCacheBytesRead(Long64_t len); virtual voidAddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual v",MatchSource.WIKI,root/html602/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileCacheRead.html
Safety,avoid,avoiding,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidAddNoCacheBytesRead(Long64_t len); virtual voidAddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual v",MatchSource.WIKI,root/html602/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileCacheRead.html
Availability,error,error," virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::",MatchSource.WIKI,root/html602/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileCacheWrite.html
Performance,cache,cache,". TFileCacheWrite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheWrite. class TFileCacheWrite: public TObject. TFileCacheWrite : a cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()). Function Members (Methods); public:. virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::",MatchSource.WIKI,root/html602/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileCacheWrite.html
Safety,avoid,avoiding,". TFileCacheWrite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheWrite. class TFileCacheWrite: public TObject. TFileCacheWrite : a cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()). Function Members (Methods); public:. virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::",MatchSource.WIKI,root/html602/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileCacheWrite.html
Availability,error,error,"Int_tAdd(const char* path); Int_tAddFromFile(const char* file, Int_t nfiles = -1, Int_t firstfile = 1); Bool_tAddMetaData(TObject* meta); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); TObjString*ExportInfo(const char* name = 0, Int_t popt = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Float_tGetCorruptedPercentage() const; const char*GetDefaultTreeName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFileCollection*GetFilesOnServer(const char* server); TMap*GetFilesPerServer(const char* exclude = 0, Bool_t curronly = kFALSE); virtual const char*TObject::GetIconName() const; THashList*GetList(); TFileInfoMeta*GetMetaData(const char* meta = 0) const; virtual const char*TNamed::GetName() const; Long64_tGetNCorruptFiles() const; Long64_tGetNFiles() const; Long64_tGe",MatchSource.WIKI,root/html602/TFileCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileCollection.html
Deployability,update,updates,"iles matching the specified pattern to the collection.; 'dir' can include wildcards after the last slash, which causes all; matching files in that directory to be added.; If dir is the full path of a file, only one element is added.; Return value is the number of added files. Int_t RemoveDuplicates(); Remove duplicates based on the UUID, typically after a verification.; Return the number of entries removed. TFileCollection * GetStagedSubset(); Creates a subset of the files that have the kStaged & !kCorrupted bit set. Long64_t Merge(TCollection* list); Merge all TFileCollection objects in li into this TFileCollection object.; Updates counters at the end.; Returns the number of merged collections or -1 in case of error. Int_t Update(Long64_t avgsize = -1); Update accumulated information about the elements of the collection; (e.g. fTotalSize). If 'avgsize' > 0, use an average file size of 'avgsize'; bytes when the size info is not available.; Also updates the meta data information by summarizing; the meta data of the contained objects.; Return -1 in case of any failure, 0 if the total size is exact, 1 if; incomplete, 2 if complete but (at least partially) estimated. void Print(Option_t* option = """") const; Prints the contents of the TFileCollection.; If option contains:; 'M' print global meta information; 'F' print all the files in the collection in compact form; (current url, default tree name|class|entries, md5); 'L' together with 'F', print all the files in the collection; in long form (uuid, md5, all URLs, all meta objects; on; many lines); ""filter:[SsCc]"" invokes PrintDetailed() which prints out dataset; content in a formatted fashion by filtering on files; which are (S)taged or not (s), (C)orrupted or not (c). void PrintDetailed(TString& showOnly) const. void FormatSize(Long64_t bytes, TString& um, Double_t& size) const. void SetAnchor(const char* anchor); Calls TUrl::SetAnchor() for all URLs contained in all TFileInfos. void SetBitAll(UInt_t f); Set the bit for ",MatchSource.WIKI,root/html602/TFileCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileCollection.html
Availability,error,error,"(const char* method) const; virtual voidAnimateTree(const char* branches = """")MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawObject()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidDumpObject()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html602/TFileDrawMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileDrawMap.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); intGetFd() const; virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObje",MatchSource.WIKI,root/html602/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileHandler.html
Energy Efficiency,monitor,monitor,"us)TObject::kOverwrite; static TFileHandler::(anonymous)kRead; static TObject::(anonymous)TObject::kSingleKey; static TFileHandler::(anonymous)kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. TFileHandler(int fd, int mask). virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1",MatchSource.WIKI,root/html602/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileHandler.html
Availability,error,error," voidTObject::AbstractMethod(const char* method) const; Bool_tAddMetaData(TObject* meta); Bool_tAddUrl(const char* url, Bool_t infront = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TUrl*FindByUrl(const char* url, Bool_t withDeflt = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TUrl*GetCurrentUrl() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TUrl*GetFirstUrl() const; virtual const char*TObject::GetIconName() const; Int_tGetIndex() const; TMD5*GetMD5() const; TFileInfoMeta*GetMetaData(const char* meta = 0) const; TList*GetMetaDataList() const; virtual const char*TNamed::GetName() const; Int_tGetNUrls() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; L",MatchSource.WIKI,root/html602/TFileInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileInfo.html
Security,access,access,"t::EStatusBitsTObject::kCannotPick; static TFileInfo::EStatusBitskCorrupted; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TFileInfo::EStatusBitskSortWithIndex; static TFileInfo::EStatusBitskStaged; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TUrl*fCurrentUrl! current URL to access the file, points to URL; Int_tfIndexIndex to be used when sorting with index; TMD5*fMD5-> md5 digest of the file; TList*fMetaDataListgeneric list of file meta data object(s); Long64_tfSizefile size; TUUID*fUUID-> uuid of the referenced file; TList*fUrlListlist of file URLs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileInfo(const char* url = 0, Long64_t size = -1, const char* uuid = 0, const char* md5 = 0, TObject* meta = 0); Constructor. TFileInfo(const TFileInfo& ); Copy constructor. ~TFileInfo(); Destructor. void ParseInput(const char* in); Parse the input line to extract init information from 'in'; the input; string is tokenized on ' '; the tokens can be prefixed by the following; keys:. url:<url1>,<url2>,... URLs for the file; stored in the order given; sz:<size> size of the file in bytes; md5:<md5_ascii> MD5 sum of the file in ASCII form; uuid:<uuid> UUID of the file. tree:<name>,<entries>,<first>,<last>; meta-information about a tree in the file; the; should be in the form <subdir>/tree-name;'entries' is; the number of entries in the tree; 'fir",MatchSource.WIKI,root/html602/TFileInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileInfo.html
Availability,error,error," virtual~TFileInfoMeta(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetClass() const; const char*GetDirectory() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntries() const; Long64_tGetFirst() const; virtual const char*TObject::GetIconName() co",MatchSource.WIKI,root/html602/TFileInfoMeta.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileInfoMeta.html
Availability,avail,available," members; data members; class charts. ROOT; » MISC; » TABLE; » TFileIter. class TFileIter: public TListIter. Class to iterate (read / write ) the events written to TFile.; The event is supposed to assign an unique ID in form of. TKey <event Id> ::= eventName ""."" run_number ""."" event_number. and stored as the TKey name of the object written. void TesTFileIter(){; // This macros tests the various methods of TFileIter class.; gSystem->Load(""libTable"");. //First create simple ROOT file; TDataSet *ds = new TDataSet(""event"");; TObject *nextObject = 0;; TRandom run;; TRandom event;; {; TFileIter outSet(""test.root"",""RECREATE"");; UInt_t totalEvent = 10;; UInt_t runNumber = 20010301;; Int_t i=0;; Int_t j=0;; for (;j < 10;j++) {; for (i = 1;i<totalEvent;i++) {; outSet.NextEventPut(ds,UInt_t(i),UInt_t(runNumber+j+10*run.Rndm()-5));; }; }; }; printf("" ----------------------> TFile has been created <--------------------\n"");; TFile *f = new TFile(""test.root"");; TFileIter readObj(f);; // the number of the object available directly from ""MyDataSet.root""; Int_t size = readObj.TotalKeys();; printf("" The total number of the objects: %d\n"",size);. //-----------------------------------------------------------------------; // Loop over all objects, read them in to memory one by one. printf("" -- > Loop over all objects, read them in to memory one by one < -- \n"");; for( readObj = 0; int(readObj) < size; ++readObj){; nextObject = *readObj;; printf("" %d bytes of the object \""%s\"" of class \""%s\"" written with TKey \""%s\"" has been read from file\n""; ,readObj.GetObjlen(); ,nextObject->GetName(); ,nextObject->IsA()->GetName(); ,(const char *)readObj; );; delete nextObject;; }; //-----------------------------------------------------------------------; // Now loop over all objects in inverse order; printf("" -- > Now loop over all objects in inverse order < -- \n"");; for( readObj = size-1; (int)readObj >= 0; --readObj); {; nextObject = *readObj;; if (nextObject) {; printf("" Object \""%s\"" of class \",MatchSource.WIKI,root/html602/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileIter.html
Modifiability,config,config,"e that matches; the ""name"" .""runNumber"" ."" eventNumber"" schema; Attention: This method does create a new TObject and it is the user; code responsibility to take care (delete) this object to avoid; memory leak. TObject * ReadObj(const TKey* key) const; Read the next TObject from for the TDirectory by TKey provided. Int_t NextEventPut(TObject* obj, UInt_t eventNum, UInt_t runNumber, const char* name = 0); Create a special TKey name with obj provided and write it out. TString MapName(const char* name, const char* localSystemKey = 0, const char* mountedFileSystemKey = 0). MapName(const char *name, const char *localSystemKey,const char *mountedFileSystemKey). Substitute the logical name with the real one if any; 1. add a line into system.rootrc or ~/.rootrc or ./.rootrc. TFileIter.ForeignFileMap mapFile // the name of the file; to map the local name; to the global file service. If this line is omitted then TFileIter class seeks for; the default mapping file in the current directory ""io.config"". const char * GetResourceName(). {return ""ForeignFileMap"";}. const char * GetDefaultMapFileName(). {return ""io.config"";}. const char * GetLocalFileNameKey(). {return ""LocalFileSystem"";}. const char * GetForeignFileSystemKey(). {return ""MountedFileSystem"";}. Int_t CurrentCursorPosition() const. const TFile * GetTFile() const. { return GetTDirectory()->GetFile(); }. const TDirectory * GetTDirectory() const. { return fNestedIterator ? fNestedIterator->GetTDirectory() : fRootFile; }. TObject * Next(). void Rewind(). void SetCursorPosition(Int_t cursorPosition). TFileIter & operator=(const char* keyNameToFind). TFileIter & operator=(Int_t cursorPosition). inline operator const TDirectory *() const. { return GetTDirectory(); }. inline operator const TFile *() const. { return GetTFile (); }. TFileIter & operator+=(Int_t shift). { SkipObjects(shift); return *this;}. TFileIter & operator-=(Int_t shift). { return operator+=(-shift);}. TFileIter & operator++(). { SkipObjects( 1); return *this",MatchSource.WIKI,root/html602/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileIter.html
Safety,avoid,avoid,", Int_t netopt = 0); Open ROOT TFile by the name provided;; This TFile is to be deleted by the TFileIter alone. TFileIter(const TFileIter& ); Copy ctor can be used with the ""read only"" files only.; the next statement is illegal, spotted by coverity ""Dereferencing pointer ""this->fRootFile"". (Deref happens because this is a virtual function call.); assert(!fRootFile->IsWritable());. ~TFileIter(); TFileIter dtor. void Initialize(); to be documented. Bool_t IsOpen() const; Check whether the associated ROOT TFile was open; and TFile object is healthy. TKey * GetCurrentKey() const; return the pointer to the current TKey. Int_t GetDepth() const; return the current number of the nested subdirectroies;; = 0 - means there is no subdirectories. const char * GetKeyName() const; return the name of the current TKey. TObject * GetObject() const; read the object from TFile defined by the current TKey. ATTENTION: memory leak danger !!!. This method does create a new object and it is the end-user; code responsibility to take care about this object; to avoid memory leak. Int_t GetObjlen() const; Returns the uncompressed length of the current object. Int_t TotalKeys() const; The total number of the TKey keys in the current TDirectory only; Usually this means the total number of different objects; those can be read one by one.; It does NOT count the nested sub-TDirectory.; It is too costly and it can be abused. TObject * Next(Int_t nSkip); return the pointer to the object defined by next TKey; This method is not recommended. It was done for the sake; of the compatibility with TListIter. void PurgeKeys(TList* listOfKeys); Remove the TKey duplication,; leave the keys with highest cycle number only; Sort if first. void Reset(); Reset the status of the iterator. void SetCursorPosition(const char* keyNameToFind); Find the key by the name provided. TKey * SkipObjects(Int_t nSkip = 1). Returns the TKey pointer to the nSkip TKey object from the current one; nSkip = 0; the state of the iterator i",MatchSource.WIKI,root/html602/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileIter.html
Testability,test,tests,". TFileIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TFileIter. class TFileIter: public TListIter. Class to iterate (read / write ) the events written to TFile.; The event is supposed to assign an unique ID in form of. TKey <event Id> ::= eventName ""."" run_number ""."" event_number. and stored as the TKey name of the object written. void TesTFileIter(){; // This macros tests the various methods of TFileIter class.; gSystem->Load(""libTable"");. //First create simple ROOT file; TDataSet *ds = new TDataSet(""event"");; TObject *nextObject = 0;; TRandom run;; TRandom event;; {; TFileIter outSet(""test.root"",""RECREATE"");; UInt_t totalEvent = 10;; UInt_t runNumber = 20010301;; Int_t i=0;; Int_t j=0;; for (;j < 10;j++) {; for (i = 1;i<totalEvent;i++) {; outSet.NextEventPut(ds,UInt_t(i),UInt_t(runNumber+j+10*run.Rndm()-5));; }; }; }; printf("" ----------------------> TFile has been created <--------------------\n"");; TFile *f = new TFile(""test.root"");; TFileIter readObj(f);; // the number of the object available directly from ""MyDataSet.root""; Int_t size = readObj.TotalKeys();; printf("" The total number of the objects: %d\n"",size);. //-----------------------------------------------------------------------; // Loop over all objects, read them in to memory one by one. printf("" -- > Loop over all objects, read them in to memory one by one < -- \n"");; for( readObj = 0; int(readObj) < size; ++readObj){; nextObject = *readObj;; printf("" %d bytes of the object \""%s\"" of class \""%s\"" written with TKey \""%s\"" has been read from file\n""; ,readObj.GetObjlen(); ,nextObject->GetName(); ,nextObject->IsA()->GetName(); ,(const char *)readObj; );; delete nextObject;; }; //-----------------------------------------------------------------------; // Now loop over all objects in inverse order; printf("" -- > Now lo",MatchSource.WIKI,root/html602/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileIter.html
Usability,simpl,simple,". TFileIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TFileIter. class TFileIter: public TListIter. Class to iterate (read / write ) the events written to TFile.; The event is supposed to assign an unique ID in form of. TKey <event Id> ::= eventName ""."" run_number ""."" event_number. and stored as the TKey name of the object written. void TesTFileIter(){; // This macros tests the various methods of TFileIter class.; gSystem->Load(""libTable"");. //First create simple ROOT file; TDataSet *ds = new TDataSet(""event"");; TObject *nextObject = 0;; TRandom run;; TRandom event;; {; TFileIter outSet(""test.root"",""RECREATE"");; UInt_t totalEvent = 10;; UInt_t runNumber = 20010301;; Int_t i=0;; Int_t j=0;; for (;j < 10;j++) {; for (i = 1;i<totalEvent;i++) {; outSet.NextEventPut(ds,UInt_t(i),UInt_t(runNumber+j+10*run.Rndm()-5));; }; }; }; printf("" ----------------------> TFile has been created <--------------------\n"");; TFile *f = new TFile(""test.root"");; TFileIter readObj(f);; // the number of the object available directly from ""MyDataSet.root""; Int_t size = readObj.TotalKeys();; printf("" The total number of the objects: %d\n"",size);. //-----------------------------------------------------------------------; // Loop over all objects, read them in to memory one by one. printf("" -- > Loop over all objects, read them in to memory one by one < -- \n"");; for( readObj = 0; int(readObj) < size; ++readObj){; nextObject = *readObj;; printf("" %d bytes of the object \""%s\"" of class \""%s\"" written with TKey \""%s\"" has been read from file\n""; ,readObj.GetObjlen(); ,nextObject->GetName(); ,nextObject->IsA()->GetName(); ,(const char *)readObj; );; delete nextObject;; }; //-----------------------------------------------------------------------; // Now loop over all objects in inverse order; printf("" -- > Now lo",MatchSource.WIKI,root/html602/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileIter.html
Availability,down,down,"eing merged. It provides access to the output directory pointer (fOutputDirectory); to whether or not this is the first time Merge is being called in the; serie (for example for TTree, the first time we also need to Clone; the object on which Merge is called), and provides for a User Data; object to be passed along to each of the calls to Merge.; The fUserData object is owned by the TFileMergeInfo and will be; deleted when the TFileMerger moves on to the next set of objects. Function Members (Methods); public:. virtual~TFileMergeInfo(); static TClass*Class(); virtual TClass*IsA() const; voidReset(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TFileMergeInfo(TDirectory* outputfile). private:. TFileMergeInfo&operator=(const TFileMergeInfo&); TFileMergeInfo(); TFileMergeInfo(const TFileMergeInfo&). Data Members; public:. Bool_tfIsFirstTrue if this is the first call to Merge for this series of object.; TStringfOptionsAdditional text based option being passed down to customize the merge.; TDirectory*fOutputDirectoryTarget directory where the merged object will be written.; TObject*fUserDataPlace holder to pass extra information. This object will be deleted at the end of each series of objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileMergeInfo(). TFileMergeInfo(const TFileMergeInfo& ). TFileMergeInfo& operator=(const TFileMergeInfo& ). TFileMergeInfo(TDirectory* outputfile); {}. virtual ~TFileMergeInfo(); { delete fUserData; }. void Reset(); { fIsFirst = kTRUE; delete fUserData; fUserData = 0; }. » Author: Philippe Canal May, 2011 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-30 14:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TFileMergeInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileMergeInfo.html
Security,access,access,". TFileMergeInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TFileMergeInfo. class TFileMergeInfo. TFileMergeInfo. This class helps passing information from the TFileMerger to; the objects being merged. It provides access to the output directory pointer (fOutputDirectory); to whether or not this is the first time Merge is being called in the; serie (for example for TTree, the first time we also need to Clone; the object on which Merge is called), and provides for a User Data; object to be passed along to each of the calls to Merge.; The fUserData object is owned by the TFileMergeInfo and will be; deleted when the TFileMerger moves on to the next set of objects. Function Members (Methods); public:. virtual~TFileMergeInfo(); static TClass*Class(); virtual TClass*IsA() const; voidReset(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TFileMergeInfo(TDirectory* outputfile). private:. TFileMergeInfo&operator=(const TFileMergeInfo&); TFileMergeInfo(); TFileMergeInfo(const TFileMergeInfo&). Data Members; public:. Bool_tfIsFirstTrue if this is the first call to Merge for this series of object.; TStringfOptionsAdditional text based option being passed down to customize the merge.; TDirectory*fOutputDirectoryTarget directory where the merged object will be written.; TObject*fUserDataPlace holder to pass extra information. This object will be deleted at the end of each series of objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileMergeInfo(). TFileMergeInfo(const TFileMergeInfo& ). TFileMergeInfo& operator=(const TFileMergeInfo& ). TFileMergeInfo(TDirectory* outputfile); {}. virtual ~TFileMergeInfo(); { delete fUserData; }. void Reset(); { fIsFirst = kTRUE; delete f",MatchSource.WIKI,root/html602/TFileMergeInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileMergeInfo.html
Availability,error,error,"ss = kTRUE); virtual Bool_tAddFile(TFile* source, Bool_t cpProgress = kTRUE); voidAddObjectNames(const char* name); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearObjectNames(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetCWD(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetMaxOpenedFies() const; TList*GetMergeList() const; const char*GetMsgPrefix() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; const char*GetObjectNames() const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFile*GetOutputFile() const; const char*GetOutputFileName() const; Int_tGetPrintLevel() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTOb",MatchSource.WIKI,root/html602/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileMerger.html
Integrability,interface,interface,". TFileMerger. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileMerger. class TFileMerger: public TObject. TFileMerger. This class provides file copy and merging services. It can be used to copy files (not only ROOT files), using TFile or; any of its remote file access plugins. It is therefore usefull in; a Grid environment where the files might be accessable via Castor,; rfio, dcap, etc.; The merging interface allows files containing histograms and trees; to be merged, like the standalone hadd program. Function Members (Methods); public:. virtual~TFileMerger(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAddAdoptFile(TFile* source, Bool_t cpProgress = kTRUE); virtual Bool_tAddFile(const char* url, Bool_t cpProgress = kTRUE); virtual Bool_tAddFile(TFile* source, Bool_t cpProgress = kTRUE); voidAddObjectNames(const char* name); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearObjectNames(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* para",MatchSource.WIKI,root/html602/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileMerger.html
Modifiability,plugin,plugins,". TFileMerger. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileMerger. class TFileMerger: public TObject. TFileMerger. This class provides file copy and merging services. It can be used to copy files (not only ROOT files), using TFile or; any of its remote file access plugins. It is therefore usefull in; a Grid environment where the files might be accessable via Castor,; rfio, dcap, etc.; The merging interface allows files containing histograms and trees; to be merged, like the standalone hadd program. Function Members (Methods); public:. virtual~TFileMerger(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAddAdoptFile(TFile* source, Bool_t cpProgress = kTRUE); virtual Bool_tAddFile(const char* url, Bool_t cpProgress = kTRUE); virtual Bool_tAddFile(TFile* source, Bool_t cpProgress = kTRUE); voidAddObjectNames(const char* name); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearObjectNames(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* para",MatchSource.WIKI,root/html602/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileMerger.html
Security,access,access,". TFileMerger. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileMerger. class TFileMerger: public TObject. TFileMerger. This class provides file copy and merging services. It can be used to copy files (not only ROOT files), using TFile or; any of its remote file access plugins. It is therefore usefull in; a Grid environment where the files might be accessable via Castor,; rfio, dcap, etc.; The merging interface allows files containing histograms and trees; to be merged, like the standalone hadd program. Function Members (Methods); public:. virtual~TFileMerger(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAddAdoptFile(TFile* source, Bool_t cpProgress = kTRUE); virtual Bool_tAddFile(const char* url, Bool_t cpProgress = kTRUE); virtual Bool_tAddFile(TFile* source, Bool_t cpProgress = kTRUE); voidAddObjectNames(const char* name); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearObjectNames(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* para",MatchSource.WIKI,root/html602/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileMerger.html
Availability,error,error,"::AppendPad(Option_t* option = """"); Bool_tBinarySearchReadList(TFPBlock*, Long64_t, Int_t, Int_t*); virtual voidTObject::Browse(TBrowser* b); Bool_tCheckBlockInCache(char*&, TFPBlock*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; TFPBlock*CreateBlockObj(Long64_t*, Int_t*, Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; char*GetBlockFromCache(const char*, Int_t); TCondition*GetCondNewBlock() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFPBlock*GetPendingBlock(); TThread*GetThread() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Long64_tGetWaitTime(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_t",MatchSource.WIKI,root/html602/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFilePrefetch.html
Performance,cache,cache,"tPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TThread*fConsumerconsumer thread; TFile*fFilereference to the file; TMutex*fMutexPendingListmutex for the pending list; TMutex*fMutexReadListmutex for the list of read blocks; TCondition*fNewBlockAddedsignal the addition of a new pending block; TStringfPathCachepath to the cache directory; TList*fPendingBlockslist of pending blocks to be read; TCondition*fReadBlockAddedsignal the addition of a new red block; TList*fReadBlockslist of blocks read; TSemaphore*fSemChangeFilesemaphore used when changin a file in TChain; TSemaphore*fSemMasterWorkersemaphore used to kill the consumer thread; TSemaphore*fSemWorkerMastersemaphore used to notify the master that worker is killed; Bool_tfThreadJoinedmark if async thread was joined; TStopwatchfWaitTimetime wating to prefetch a buffer (in usec). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFilePrefetch(TFile* ); Constructor. ~TFilePrefetch(); Destructor. void WaitFinishPrefetch(); Killing the async prefetching thread. void ReadAsync(TFPBlock* , Bool_t& ); Read one block and insert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds",MatchSource.WIKI,root/html602/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFilePrefetch.html
Usability,clear,clear,". void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. void SetFile(TFile* ); Change the file; When prefetching is enabled we also need to:; - make sure the async thread is not doing any work; - clear all blocks from prefetching and read list; - reset the file pointer. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ). TCondition* GetCondNewBlock() const; { return fNewBlockAdded; }. » Author: Elvin Sindrilaru 19/05/2011 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-06-30 14:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please se",MatchSource.WIKI,root/html602/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFilePrefetch.html
Availability,error,error," virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual voidTObject::AppendPad(Option_t* option = """"); TDataSet*TDataSet::At(Int_t idx) const; virtual voidTDataSet::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TDataSet::GetList() c",MatchSource.WIKI,root/html602/TFileSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileSet.html
Availability,error,error," virtual~TFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(co",MatchSource.WIKI,root/html602/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileStager.html
Integrability,interface,interface,". TFileStager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TFileStager. class TFileStager: public TNamed. TFileStager. Abstract base class defining an interface to a stager. To open a connection to a stager use the static method; Open(""<stager>""), where <stager> contains a keyword allowing to load; the relevant plug-in, e.g.; TFileStager::Open(""root://lxb6064.cern.ch""); will load TXNetFileStager and initialize it for the redirector at; lxb6046.cern.ch . Function Members (Methods); public:. virtual~TFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(co",MatchSource.WIKI,root/html602/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileStager.html
Modifiability,plug-in,plug-in,". TFileStager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TFileStager. class TFileStager: public TNamed. TFileStager. Abstract base class defining an interface to a stager. To open a connection to a stager use the static method; Open(""<stager>""), where <stager> contains a keyword allowing to load; the relevant plug-in, e.g.; TFileStager::Open(""root://lxb6064.cern.ch""); will load TXNetFileStager and initialize it for the redirector at; lxb6046.cern.ch . Function Members (Methods); public:. virtual~TFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(co",MatchSource.WIKI,root/html602/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileStager.html
Performance,load,load,". TFileStager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TFileStager. class TFileStager: public TNamed. TFileStager. Abstract base class defining an interface to a stager. To open a connection to a stager use the static method; Open(""<stager>""), where <stager> contains a keyword allowing to load; the relevant plug-in, e.g.; TFileStager::Open(""root://lxb6064.cern.ch""); will load TXNetFileStager and initialize it for the redirector at; lxb6046.cern.ch . Function Members (Methods); public:. virtual~TFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(co",MatchSource.WIKI,root/html602/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFileStager.html
Availability,error,error,"pop up the context menu and then select the menu; entry 'Fit Panel'. ""General"" Tab. The first set of GUI elements is related to the function choice; and settings. The status bar on the bottom provides information; about the current minimization settings using the following; abbreviations:; LIB - shows the current choice between Minuit/Minuit2/Fumili; MIGRAD or FUMILI points to the current minimization method in use.; Itr: - shows the maximum number of iterations nnnn set for the fit.; Prn: - can be DEF/VER/QT and shows the current print option in use. ""Predefined"" combo box - contains a list of predefined functions; in ROOT. The default one is Gaussian. ""Operation"" radio button group defines selected operational mode; between functions: NOP - no operation (default); ADD - addition; CONV - convolution (will be implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Chi-square"" check button sets ON/OFF option 'C' - do not; calculate Chi-square (for Linear fitter). Fit options:; ""Integral"" check button switch ON/OFF option 'I' - use integral; of function instead of value in bin center.; ""Best Errors"" sets ON/OFF option 'E' - better errors estimation; using Minos technique.; ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1,; excluding empty bins and ignoring error bars.; ""Empty bins, weight",MatchSource.WIKI,root/html602/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFitEditor.html
Integrability,interface,interface,". TFitEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » FITPANEL; » TFitEditor. class TFitEditor: public TGMainFrame. TFitEditor. Allows to perform, explore and compare various fits. To display the new Fit panel interface right click on a histogram; or a graph to pop up the context menu and then select the menu; entry 'Fit Panel'. ""General"" Tab. The first set of GUI elements is related to the function choice; and settings. The status bar on the bottom provides information; about the current minimization settings using the following; abbreviations:; LIB - shows the current choice between Minuit/Minuit2/Fumili; MIGRAD or FUMILI points to the current minimization method in use.; Itr: - shows the maximum number of iterations nnnn set for the fit.; Prn: - can be DEF/VER/QT and shows the current print option in use. ""Predefined"" combo box - contains a list of predefined functions; in ROOT. The default one is Gaussian. ""Operation"" radio button group defines selected operational mode; between functions: NOP - no operation (default); ADD - addition; CONV - convolution (will be implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Ch",MatchSource.WIKI,root/html602/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFitEditor.html
Modifiability,variab,variables,"); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGComboBox*BuildMethodList(TGFrame* parent, Int_t id); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tCheckFunctionString(const char* str); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); voidCreateFunctionGroup(); voidCreateGeneralTab(); voidCreateMinimizationTab(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); voidDrawSelection(bool restore = false); voidFillDataSetList(); TF1*FindFunction(); TF1*GetFitFunction(); TList*GetFitObjectListOfFunctions(); voidGetFunctionsFromSystem(); static Time_tTGFrame::GetLastClick(); TStringTGMainFrame::GetMWMfuncString() const; TStringTGMainFrame::GetMWMinpString() const; TStringTGMainFrame::GetMWMvalueString() const; TStringTGFrame::GetOptionString() const; voidGetRanges(ROOT::Fit::DataRange&); const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; TF1*HasFitFunction(); voidMakeTitle(TGCompositeFrame* parent, const char* title); voidTObject::MakeZombie(); voidProcessTreeInput(TObject* objSelected, Int_t selected, TString variables, TString cuts); virtual voidSetCanvas(TCanvas* c); virtual voidSetEditable(Bool_t); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TFitEditor&operator=(const TFitEditor&); voidRetrieveOptions(Foption_t&, TString&, ROOT::Math::Mi",MatchSource.WIKI,root/html602/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFitEditor.html
Performance,perform,perform,". TFitEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » FITPANEL; » TFitEditor. class TFitEditor: public TGMainFrame. TFitEditor. Allows to perform, explore and compare various fits. To display the new Fit panel interface right click on a histogram; or a graph to pop up the context menu and then select the menu; entry 'Fit Panel'. ""General"" Tab. The first set of GUI elements is related to the function choice; and settings. The status bar on the bottom provides information; about the current minimization settings using the following; abbreviations:; LIB - shows the current choice between Minuit/Minuit2/Fumili; MIGRAD or FUMILI points to the current minimization method in use.; Itr: - shows the maximum number of iterations nnnn set for the fit.; Prn: - can be DEF/VER/QT and shows the current print option in use. ""Predefined"" combo box - contains a list of predefined functions; in ROOT. The default one is Gaussian. ""Operation"" radio button group defines selected operational mode; between functions: NOP - no operation (default); ADD - addition; CONV - convolution (will be implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Ch",MatchSource.WIKI,root/html602/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFitEditor.html
Usability,clear,clear,"ion about the; function. void CreateGeneralTab(); Create 'General' tab. void CreateMinimizationTab(); Create 'Minimization' tab. void ConnectSlots(); Connect GUI signals to fit panel slots. void DisconnectSlots(); Disconnect GUI signals from fit panel slots. void SetCanvas(TCanvas* c); Connect to another canvas. void Hide(); Hide the fit panel and set it to non-active state. void Show(TVirtualPad* pad, TObject* obj); Show the fit panel (possible only via context menu). void CloseWindow(); Close fit panel window. void Terminate(); Called to delete the fit panel. void UpdateGUI(); Set the fit panel GUI according to the selected object. void SetFitObject(TVirtualPad* pad, TObject* obj, Int_t event); Slot called when the user clicks on an object inside a canvas.; Updates pointers to the parent pad and the selected object; for fitting (if suitable). void DoNoSelection(); Slot called when users close a TCanvas or when the user select; no object. void RecursiveRemove(TObject* obj); When obj is deleted, clear fFitObject if fFitObject = obj. void FillFunctionList(Int_t selected = -1); Fills the list of functions depending on the type of fit; selected. void FillMinMethodList(Int_t selected = -1); Fills the list of methods depending on the minimization library; selected. void FillDataSetList(); Create a combo box with all the possible objects to be fitted. TGComboBox* BuildMethodList(TGFrame* parent, Int_t id); Create method list in a combo box. void DoAdvancedOptions(); Slot connected to advanced option button (opens a dialog). void DoEmptyBinsAllWeights1(); Slot connected to 'include emtry bins and forse all weights to 1' setting. void DoUseFuncRange(). void DoAllWeights1(); Slot connected to 'set all weights to 1' setting. void DoClose(); Close the fit panel. void DoUpdate(); Easy here!. void DoFit(); Perform a fit with current parameters' settings. Int_t CheckFunctionString(const char* str); Check entered function string. void DoAddition(Bool_t on); Slot connected to additi",MatchSource.WIKI,root/html602/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFitEditor.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html602/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFitParametersDialog.html
Deployability,update,update,"nt_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual UInt_tTGFrame::GetOptions() const; const TGWindow*TGWindow::GetParent() const; static const TGGC&TGFrame::GetShadowGC(); TGDimensionTGFrame::GetSize() const; Int_tTGCompositeFrame::GetState(TGFrame* f) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; static const TGGC&TGFrame::GetWhiteGC(); static Pixel_tTGFrame::GetWhitePixel(); UInt_tTGFrame::GetWidth() const; const char*TGMainFrame::GetWindowName() const; voidTGMainFrame::GetWMPosition(Int_t& x, Int_t& y) const; voidTGMainFrame::GetWMSize(UInt_t& w, UInt_t& h) const; voidTGMainFrame::GetWMSizeHints(UInt_t& wmin, UInt_t& hmin, UInt_t& wmax, UInt_t& hmax, UInt_t& winc, UInt_t& hinc) const; EInitialStateTGMainFrame::GetWMState() const; Int_tTGFrame::GetX() const; Int_tTGFrame::GetY() const; virtual Bool_tTGMainFrame::HandleButton(Event_t* event); virtual voidHandleButtons(Bool_t update); virtual Bool_tTGMainFrame::HandleClientMessage(Event_t* event); virtual Bool_tTGFrame::HandleColormapChange(Event_t*); virtual Bool_tTGFrame::HandleConfigureNotify(Event_t* event); virtual Bool_tTGCompositeFrame::HandleCrossing(Event_t*); virtual Bool_tTGFrame::HandleDNDDrop(TDNDData*); virtual Atom_tTGFrame::HandleDNDEnter(Atom_t*); virtual Bool_tTGFrame::HandleDNDFinished(); virtual Bool_tTGFrame::HandleDNDLeave(); virtual Atom_tTGFrame::HandleDNDPosition(Int_t, Int_t, Atom_t, Int_t, Int_t); virtual Bool_tTGCompositeFrame::HandleDoubleClick(Event_t*); virtual Bool_tTGCompositeFrame::HandleDragDrop(TGFrame* frame, Int_t x, Int_t y, TGLayoutHints* lo); virtual Bool_tTGCompositeFrame::HandleDragEnter(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragLeave(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(",MatchSource.WIKI,root/html602/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFitParametersDialog.html
Integrability,depend,dependent,"ndowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitParametersDialog(const TGWindow* p, const TGWindow* main, TF1* func, TVirtualPad* pad, Int_t* ret_code = 0); Create a dialog for fit function parameters' settings. ~TFitParametersDialog(); Destructor. void CloseWindow(); Close parameters' dialog. void DoCancel(); Slot related to the Cancel button. void DoParBound(Bool_t on); Slot related to the Bound check button. void DoParStep(); Slot related to parameter step setting. void DoParFix(Bool_t on); Slot related to the Fix check button. void SetParameters(); Set the parameter values inside the function. void DoOK(); Slot related to the OK button. void DoApply(); Slot related to the Preview button. void DoReset(); Slot related to the Reset button. void DoSlider(); Slot related to the parameters' value settings. void DoParValue(); Slot related to the parameter value settings. void DoParMinLimit(); Slot related to the minumum parameter limit settings. void DoParMaxLimit(); Slot related to the maximum parameter limit settings. void DrawFunction(); Redraw function graphics. void HandleButtons(Bool_t update); Handle the button dependent states in this dialog. void DisconnectSlots(); Disconnect signals from slot methods. void HandleShiftTab(); Handle Shift+Tab key event (set focus to the previous number entry field). void HandleTab(); Handle Tab key event (set focus to the next number entry field). TFitParametersDialog(const TGWindow* p, const TGWindow* main, TF1* func, TVirtualPad* pad, Int_t* ret_code = 0). » Author: Ilka Antcheva, Lorenzo Moneta, David Gonzalez Maline 03/10/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/fitpanel:$Id$ » Last generated: 2015-06-30 14:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFitParametersDialog.html
Availability,error,error,"onst char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; doubleROOT::Fit::FitResult::Correlation(unsigned int i, unsigned int j) const; doubleROOT::Fit::FitResult::CovMatrix(unsigned int i, unsigned int j) const; intROOT::Fit::FitResult::CovMatrixStatus() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; doubleROOT::Fit::FitResult::Edm() const; doubleError(unsigned int i) const; const vector<double>&ROOT::Fit::FitResult::Errors() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(); ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(const ROOT::Fit::FitConfig& fconfig); ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(const ROOT::Fit::FitResult&); ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0); const ROOT::Fit::FitResult::IModelFunction*ROOT::Fit::FitResult",MatchSource.WIKI,root/html602/TFitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFitResult.html
Testability,assert,assert,"IST; » HIST; » TFitResultPtr. class TFitResultPtr. Function Members (Methods); public:. virtual~TFitResultPtr(); static TClass*Class(); TFitResult*Get() const; virtual TClass*IsA() const; intoperator int() const; TFitResult&operator*() const; TFitResult*operator->() const; TFitResultPtr&operator=(const TFitResultPtr& rhs); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TFitResultPtr(int status = -1); TFitResultPtr(TFitResult* p); TFitResultPtr(const TFitResultPtr& rhs). Data Members; private:. TFitResult*fPointerSmart Pointer to TFitResult class; intfStatusfit status code. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitResultPtr(TFitResult* p); constructor from a TFitResult pointer. TFitResultPtr(const TFitResultPtr& rhs); copy constructor - create a new TFitResult if needed. ~TFitResultPtr(); destructor - delete the contained TFitResult pointer if needed. TFitResult& operator*() const; implement the de-reference operator to make the class acts as a pointer to a TFitResult; assert in case the class does not contain a pointer to TFitResult. TFitResult* operator->() const; implement the -> operator to make the class acts as a pointer to a TFitResult; assert in case the class does not contain a pointer to TFitResult. TFitResultPtr & operator=(const TFitResultPtr& rhs); assignment operator; if needed copy the TFitResult object and delete previous one if existing. TFitResultPtr(int status = -1); {}. operator int() const; { return fStatus; }. TFitResult* Get() const; { return fPointer; }. » Author: David Gonzalez Maline Tue Nov 10 15:01:24 2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-02 13:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TFitResultPtr.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFitResultPtr.html
Availability,error,error," virtual~TFITSHDU(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Bool_tChange(const char* filter); Bool_tChange(Int_t extension_number); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVectorD*GetArrayColumn(UInt_t col); TVectorD*GetArrayRow(UInt_t row); const TString&GetColumnName(Int_t colnum); Int_tGetCol",MatchSource.WIKI,root/html602/TFITSHDU.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFITSHDU.html
Integrability,interface,interface,". TFITSHDU. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » FITSIO; » TFITSHDU. class TFITSHDU: public TNamed. FITS file interface class; TFITS is a class that allows extracting images and data from FITS files and contains; several methods to manage them.; . Function Members (Methods); public:. virtual~TFITSHDU(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Bool_tChange(const char* filter); Bool_tChange(Int_t extension_number); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVectorD*GetArrayColumn(UInt_t col); TVectorD*GetArrayRow(UInt_t row); const TString&GetColumnName(Int_t colnum); Int_tGetCol",MatchSource.WIKI,root/html602/TFITSHDU.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFITSHDU.html
Security,access,access,"a table HDU given its name. TVectorD* GetTabRealVectorColumn(Int_t colnum); Get a real number-typed column from a table HDU given its column index (>=0). TVectorD* GetTabRealVectorColumn(const char* colname); Get a real number-typed column from a table HDU given its name. Bool_t Change(const char* filter); Change to another HDU given by ""filter"".; The parameter ""filter"" will be appended to the; FITS file's base path. For example:; hduObject.Change(""[EVENTS][TIME > 5]"");; Please, see documentation of TFITSHDU(const char *filepath_with_filter) constructor; for further information. Bool_t Change(Int_t extension_number); Change to another HDU given by extension_number. TObjArray * GetTabRealVectorCells(Int_t colnum); Get a collection of real vectors embedded in cells along a given column from a table HDU. colnum >= 0. TObjArray * GetTabRealVectorCells(const char* colname); Get a collection of real vectors embedded in cells along a given column from a table HDU by name. TVectorD * GetTabRealVectorCell(Int_t rownum, Int_t colnum); Get a real vector embedded in a cell given by (row>=0, column>=0). TVectorD * GetTabRealVectorCell(Int_t rownum, const char* colname); Get a real vector embedded in a cell given by (row>=0, column name). const TString& GetColumnName(Int_t colnum); Get the name of a column given its index (column>=0).; In case of error the column name is """". TFITSHDU(const char* filepath_with_filter). Int_t GetRecordNumber() const; Metadata access methods. { return fNRecords; }. struct HDURecord * GetRecord(const char* keyword). Int_t GetTabNColumns() const; Table readers. { return fNColumns; }. Int_t GetTabNRows() const; { return fNRows; }. » Author: Claudi Martinez, July 19th 2010 » Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *; » Last changed: root/graf2d:$Id$ » Last generated: 2015-06-30 14:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TFITSHDU.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFITSHDU.html
Availability,error,error," virtual~TFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual void",MatchSource.WIKI,root/html602/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFitter.html
Modifiability,variab,variable,"globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t i); return Sum(log(i) i=0,n; used by log likelihood fits. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void(*)(Int_t&,Double_t*,Double_t&,Double_t*,Int_t) fcn); Specify the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this pa",MatchSource.WIKI,root/html602/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFitter.html
Performance,cache,cache,"eted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; void(*)(Int_t&,Double_t*,Double_t&,Double_t*,Int_t)TVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. Double_t*fCovarCovariance matrix; TMinuit*fMinuitpointer to the TMinuit object; Int_tfNlogNumber of elements in fSunLog; Double_t*fSumLogSum of logs (array of fNlog elements). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Func",MatchSource.WIKI,root/html602/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFitter.html
Safety,predict,predict,"rameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x ",MatchSource.WIKI,root/html602/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFitter.html
Testability,log,logs,"eNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. Double_t*fCovarCovariance matrix; TMinuit*fMinuitpointer to the TMinuit object; Int_tfNlogNumber of elements in fSunLog; Double_t*fSumLogSum of logs (array of fNlog elements). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitter(Int_t maxpar = 25); default constructor*-*-; *-* ===================. ~TFitter(); default destructor*-*-*-; *-* ==================. Double_t Chisquare(Int_t npar, Double_t* params) const; return a chisquare equivalent. void Clear(Option_t* option = """"); reset the fitter environment. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); Execute a fitter command;; command : command string; args : list of nargs command arguments. void FixParameter(Int_t ipar); Fix parameter ipar. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.94999999999999996); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1;",MatchSource.WIKI,root/html602/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFitter.html
Availability,error,error," = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCarver(Int_t&, Double_t&, Double_t&); virtual Int_tCellFill(Int_t, TFoamCell*); virtual voidCheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDivide(TFoamCell*); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t*); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExplore(TFoamCell* Cell); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFinalize(Double_t&, Double_t&); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidGenerCel2(TFoamCell*&); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetIntegMC(Double_t&, Double_t&); virtual voidGetIntNorm(Double_t&, Double_t&); virtual voidGetMCvect(Double_t*); virtual Double_tGetMCwt(); virtual voidGetMCwt(Double_t&); virtual const char*TObject::GetName() const; virtual Long_tGetnCalls() const; virtual Long_tGetnEffev() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObje",MatchSource.WIKI,root/html602/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFoam.html
Deployability,integrat,integrate,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html602/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFoam.html
Energy Efficiency,efficient,efficient,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html602/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFoam.html
Integrability,integrat,integrate,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html602/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFoam.html
Modifiability,variab,variable,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html602/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFoam.html
Performance,optimiz,optimization,"tMonitor of the MC weight for measuring MC efficiency; Double_tfMCerrorand its error; Double_tfMCresultTrue Integral R from MC series; Double_t*fMCvect[fDim] Generated MC vector for the outside user; Double_tfMCwtMC weight; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; Double_tfMaxWtRejMaximum weight in rejection for getting wt=1 events; TMethodCall*fMethodCall! ROOT's pointer to user-defined global distribution function; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Long_tfNCallsTotal number of the function calls; Int_tfNCellsMaximum number of cells; Long_tfNEffevTotal number of effective events (wt=1) in the foam buildup; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; Double_tfNevGenTotal number of the generated MC events; Int_tfNoActNumber of active cells; Int_tfOptDriveOptimization switch =1,2 for variance or maximum weight optimization; Int_tfOptPRDOption switch for predefined division, for quick check; Int_tfOptRejSwitch =0 for weighted events; =1 for unweighted events in MC; Double_t*fPrimAcu[fNoAct] Array of cumulative probability of all active cells; Double_tfPrimePrimary integral R' (R=R'<wt>); TRandom*fPseRanPointer to user-defined generator of pseudorandom numbers; Int_tfRNmaxMaximum No. of the rand. numb. requested at once; TFoamIntegrand*fRho! Pointer to the user-defined integrand function/distribution; Double_t*fRvec[fRNmax] random number vector from r.n. generator fDim+1 maximum elements; Double_tfSumOveTotal Sum of overveighted events; Double_tfSumWtTotal sum of wt and wt^2; Double_tfSumWt2Total sum of wt and wt^2; TStringfVersionActual version of the FOAM like (1.01m); Double_tfWtMaxMaximum/Minimum MC weight; Double_tfWtMinMaximum/Minimum MC weight; TFoamVect**fXdivPRD! Lists of division values encoded in one vector per direction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoam(); Default constructo",MatchSource.WIKI,root/html602/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFoam.html
Security,access,access,"ializes memory storage for cells and begins exploration process; from the root cell. The empty cells are allocated/filled using CellFill.; The procedure Grow which loops over cells, picks up the cell with the biggest; ``driver integral'', see Comp. Phys. Commun. 152 152 (2003) 55 for explanations,; with the help of PeekMax procedure. The chosen cell is split using Divide.; Subsequently, the procedure Explore called by the Divide; (and by InitCells for the root cell) does the most important; job in the FOAM object build-up: it performs a small MC run for each; newly allocated daughter cell.; Explore calculates how profitable the future split of the cell will be; and defines the optimal cell division geometry with the help of Carver or Varedu; procedures, for maximum weight or variance optimization respectively.; All essential results of the exploration are written into; the explored cell object. At the very end of the foam build-up,; Finally, MakeActiveList is invoked to create a list of pointers to; all active cells, for the purpose of the quick access during the MC generation.; The procedure Explore employs MakeAlpha to generate random coordinates; inside a given cell with the uniform distribution.; The above sequence of the procedure calls is depicted in the following figure:. . void Initialize(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. void InitCells(); Internal subprogram used by Initialize.; It initializes ""root part"" of the FOAM of the tree of cells. Int_t CellFill(Int_t , TFoamCell* ); Internal subprogram used by Initialize.; It initializes content of the newly allocated active cell. void Explore(TFoamCell* Cell); Internal subprogram used by Initialize.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of true and drive volume is defined/determined; Average ",MatchSource.WIKI,root/html602/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFoam.html
Usability,simpl,simplified,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html602/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFoam.html
Availability,error,error," virtual~TFoamCell(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalcVolume(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Int_t, TFoamCell*, TFoamCell*, TFoamCell*); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBest() const; TFoamCell*GetDau0() const; TFoamCell*Get",MatchSource.WIKI,root/html602/TFoamCell.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFoamCell.html
Energy Efficiency,allocate,allocated,"mous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfBestBest Edge for division; TReffDaught0Pointer to daughter 1; TReffDaught1Pointer to daughter 2; Short_tfDimDimension of the vector space; Double_tfDriveDriver integral, only for cell build-up; Double_tfIntegralIntegral over cell (estimate from exploration); TReffParentPointer to parent cell; Double_tfPrimaryPrimary integral, only for MC generation; Int_tfSerialSerial number; Int_tfStatusStatus (active, inactive); Double_tfVolumeCartesian Volume of cell; Double_tfXdivFactor for division. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamCell(); Default constructor for streamer. TFoamCell(Int_t ); User constructor allocating single empty Cell. TFoamCell(TFoamCell& ); Copy constructor (not tested!). ~TFoamCell(); Destructor. TFoamCell& operator=(const TFoamCell& ); Substitution operator = (never used). void Fill(Int_t , TFoamCell* , TFoamCell* , TFoamCell* ); Fills in certain data into newly allocated cell. void GetHcub(TFoamVect& , TFoamVect& ) const; Provides size and position of the cell; These parameter are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void GetHSize(TFoamVect& ) const; Provides size of the cell; Size parameters are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void CalcVolume(void); Calculates volume of the cell using size params which are calculated. void Print(Option_t* option) const; Printout of the cell geometry parameters for the debug purpose. Double_t GetXdiv() const; Geometry. { return fXdiv;}. Int_t GetBest() const; { return fBest;}. void SetBest(Int_t Best); { fBest =Best;}. void SetXdiv(Double_t Xdiv); { fXdiv =Xdiv;}. Double_t GetVolume() const; { return fVolume;}. Double_t GetIntg() const; { return fIntegral;}. Double_t GetDriv() const; { return fDrive;}. Double_t GetPrim() ",MatchSource.WIKI,root/html602/TFoamCell.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFoamCell.html
Testability,test,tested,"ect::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfBestBest Edge for division; TReffDaught0Pointer to daughter 1; TReffDaught1Pointer to daughter 2; Short_tfDimDimension of the vector space; Double_tfDriveDriver integral, only for cell build-up; Double_tfIntegralIntegral over cell (estimate from exploration); TReffParentPointer to parent cell; Double_tfPrimaryPrimary integral, only for MC generation; Int_tfSerialSerial number; Int_tfStatusStatus (active, inactive); Double_tfVolumeCartesian Volume of cell; Double_tfXdivFactor for division. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamCell(); Default constructor for streamer. TFoamCell(Int_t ); User constructor allocating single empty Cell. TFoamCell(TFoamCell& ); Copy constructor (not tested!). ~TFoamCell(); Destructor. TFoamCell& operator=(const TFoamCell& ); Substitution operator = (never used). void Fill(Int_t , TFoamCell* , TFoamCell* , TFoamCell* ); Fills in certain data into newly allocated cell. void GetHcub(TFoamVect& , TFoamVect& ) const; Provides size and position of the cell; These parameter are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void GetHSize(TFoamVect& ) const; Provides size of the cell; Size parameters are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void CalcVolume(void); Calculates volume of the cell using size params which are calculated. void Print(Option_t* option) const; Printout of the cell geometry parameters for the debug purpose. Double_t GetXdiv() const; Geometry. { return fXdiv;}. Int_t GetBest() const; { return fBest;}. void SetBest(Int_t Best); { fBest =Best;}. void SetXdiv(Double",MatchSource.WIKI,root/html602/TFoamCell.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFoamCell.html
Availability,avail,available,". TFoamIntegrand. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoamIntegrand. class TFoamIntegrand: public TObject. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TFoamIntegrand(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; vi",MatchSource.WIKI,root/html602/TFoamIntegrand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFoamIntegrand.html
Availability,error,error," virtual~TFoamMaxwt(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*",MatchSource.WIKI,root/html602/TFoamMaxwt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFoamMaxwt.html
Integrability,depend,depending,". TFoamMaxwt. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoamMaxwt. class TFoamMaxwt: public TObject. Class TFoamMaxwt. Small auxiliary class for controlling MC weight.; It provides certain measure of the ""maximum weight""; depending on small user-parameter ""epsilon"".; It creates and uses 2 histograms of the TH1D class.; User defines no. of bins nBin, nBin=1000 is recommended; wmax defines weight range (1,wmax), it is adjusted ""manually"". Function Members (Methods); public:. virtual~TFoamMaxwt(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*",MatchSource.WIKI,root/html602/TFoamMaxwt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFoamMaxwt.html
Availability,error,error,"ce using FOAM; for sampling arbitrary distributions. Function Members (Methods); public:. virtual~TFoamSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(const ROOT::Math::DistSampler&); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; TFoamSampler&operator=(const TFoamSampler&); const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleROOT::Math::DistSampler::Sample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidROOT::Math::DistSampler::SetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); voidROOT::Math::DistSampler::SetFunction<const ROOT::Math::IBaseFunctionOneDim>(ROOT::Math::const IBaseFunctionOneDim& func, unsigned int dim); virtual voidROOT::Math::DistSampler::SetMode(double); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed); TFoamSampler(); TFoamSampler(const TFoamSampler&). protected:. virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiG",MatchSource.WIKI,root/html602/TFoamSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFoamSampler.html
Integrability,interface,interface,". TFoamSampler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoamSampler. class TFoamSampler: public ROOT::Math::DistSampler. TFoamSampler class; class implementing the ROOT::Math::DistSampler interface using FOAM; for sampling arbitrary distributions. Function Members (Methods); public:. virtual~TFoamSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(const ROOT::Math::DistSampler&); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; TFoamSampler&operator=(const TFoamSampler&); const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleROOT::Math::DistSampler::Sample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidROOT::Math::DistSampler::SetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); voidROOT::Math::DistSampler::SetFunction<const ROOT::Math::IBaseFunctionOneDim>(ROOT::Math::const IBaseFunctionOneDim& func, unsigned int dim); virtual voidROOT::Math::DistSampler::SetMode(double); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler",MatchSource.WIKI,root/html602/TFoamSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFoamSampler.html
Modifiability,extend,extend,"ce using FOAM; for sampling arbitrary distributions. Function Members (Methods); public:. virtual~TFoamSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(const ROOT::Math::DistSampler&); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; TFoamSampler&operator=(const TFoamSampler&); const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleROOT::Math::DistSampler::Sample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidROOT::Math::DistSampler::SetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); voidROOT::Math::DistSampler::SetFunction<const ROOT::Math::IBaseFunctionOneDim>(ROOT::Math::const IBaseFunctionOneDim& func, unsigned int dim); virtual voidROOT::Math::DistSampler::SetMode(double); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed); TFoamSampler(); TFoamSampler(const TFoamSampler&). protected:. virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiG",MatchSource.WIKI,root/html602/TFoamSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFoamSampler.html
Availability,error,error," virtual~TFoamVect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetCoord(Int_t i) const; Int_tGetDim() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObjec",MatchSource.WIKI,root/html602/TFoamVect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFoamVect.html
Security,access,access,"ect::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Double_t*fCoords[fDim] Coordinates; Int_tfDimDimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamVect(); Default constructor for streamer. TFoamVect(Int_t ); User constructor creating n-dimensional vector; and allocating dynamically array of components. TFoamVect(const TFoamVect& ); Copy constructor. ~TFoamVect(); Destructor. Double_t & operator[](Int_t ); [] is for access to elements as in ordinary matrix like a[j]=b[j]; (Perhaps against some strict rules but rather practical.); Range protection is built in, consequently for substitution; one should use rather use a=b than explicit loop!. TFoamVect& operator*=(const Double_t& ); unary multiplication operator *=. TFoamVect& operator+=(const TFoamVect& ); unary addition operator +=; adding vector c*=x,. TFoamVect& operator-=(const TFoamVect& ); unary subtraction operator -=. TFoamVect operator+(const TFoamVect& ); addition operator +; sum of 2 vectors: c=a+b, a=a+b,; NEVER USE IT, VERY SLOW!!!. TFoamVect operator-(const TFoamVect& ); subtraction operator -; difference of 2 vectors; c=a-b, a=a-b,; NEVER USE IT, VERY SLOW!!!. void Print(Option_t* option) const; Printout of all vector components on ""std::cout"". Int_t GetDim() const; { return fDim; }. Double_t GetCoord(Int_t i) const; {return fCoords[i];}. » Last changed: root/foam:$Id$ » Last generated: 2015-06-30 14:49; This page has been automatically generated. For comments or sugges",MatchSource.WIKI,root/html602/TFoamVect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFoamVect.html
Availability,error,error,"idTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); TFolder*AddFolder(const char* name, const char* title, TCollection* collection = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject&) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*FindFullPathName(const char* name) const; virtual const char*FindFullPathName(const TObject* obj) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TCollection*GetListOfFolders() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::G",MatchSource.WIKI,root/html602/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFolder.html
Energy Efficiency,efficient,efficient,". TFolder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TFolder. class TFolder: public TNamed. A TFolder object is a collection of objects and folders.; Folders have a name and a title and are identified in the folder hierarchy; by a ""Unix-like"" naming mechanism. The root of all folders is //root.; New folders can be dynamically added or removed to/from a folder.; The folder hierarchy can be visualized via the TBrowser. The Root folders hierarchy can be seen as a whiteboard where objects; are posted. Other classes/tasks can access these objects by specifying; only a string pathname. This whiteboard facility greatly improves the; modularity of an application, minimizing the class relationship problem; that penalizes large applications. Pointers are efficient to communicate between classes.; However, one has interest to minimize direct coupling between classes; in the form of direct pointers. One better uses the naming and search; service provided by the Root folders hierarchy. This makes the classes; loosely coupled and also greatly facilitates I/O operations.; In a client/server environment, this mechanism facilitates the access; to any kind of object in //root stores running on different processes. A TFolder is created by invoking the TFolder constructor. It is placed; inside an existing folder via the TFolder::AddFolder method.; One can search for a folder or an object in a folder using the FindObject; method. FindObject analyzes the string passed as its argument and searches; in the hierarchy until it finds an object or folder matching the name. When a folder is deleted, its reference from the parent folder and; possible other folders is deleted. If a folder has been declared the owner of its objects/folders via; TFolder::SetOwner, then the contained objects are deleted when the; f",MatchSource.WIKI,root/html602/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFolder.html
Modifiability,coupling,coupling,"e; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TFolder. class TFolder: public TNamed. A TFolder object is a collection of objects and folders.; Folders have a name and a title and are identified in the folder hierarchy; by a ""Unix-like"" naming mechanism. The root of all folders is //root.; New folders can be dynamically added or removed to/from a folder.; The folder hierarchy can be visualized via the TBrowser. The Root folders hierarchy can be seen as a whiteboard where objects; are posted. Other classes/tasks can access these objects by specifying; only a string pathname. This whiteboard facility greatly improves the; modularity of an application, minimizing the class relationship problem; that penalizes large applications. Pointers are efficient to communicate between classes.; However, one has interest to minimize direct coupling between classes; in the form of direct pointers. One better uses the naming and search; service provided by the Root folders hierarchy. This makes the classes; loosely coupled and also greatly facilitates I/O operations.; In a client/server environment, this mechanism facilitates the access; to any kind of object in //root stores running on different processes. A TFolder is created by invoking the TFolder constructor. It is placed; inside an existing folder via the TFolder::AddFolder method.; One can search for a folder or an object in a folder using the FindObject; method. FindObject analyzes the string passed as its argument and searches; in the hierarchy until it finds an object or folder matching the name. When a folder is deleted, its reference from the parent folder and; possible other folders is deleted. If a folder has been declared the owner of its objects/folders via; TFolder::SetOwner, then the contained objects are deleted when the; folder is deleted. By default, a fold",MatchSource.WIKI,root/html602/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFolder.html
Security,access,access,". TFolder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TFolder. class TFolder: public TNamed. A TFolder object is a collection of objects and folders.; Folders have a name and a title and are identified in the folder hierarchy; by a ""Unix-like"" naming mechanism. The root of all folders is //root.; New folders can be dynamically added or removed to/from a folder.; The folder hierarchy can be visualized via the TBrowser. The Root folders hierarchy can be seen as a whiteboard where objects; are posted. Other classes/tasks can access these objects by specifying; only a string pathname. This whiteboard facility greatly improves the; modularity of an application, minimizing the class relationship problem; that penalizes large applications. Pointers are efficient to communicate between classes.; However, one has interest to minimize direct coupling between classes; in the form of direct pointers. One better uses the naming and search; service provided by the Root folders hierarchy. This makes the classes; loosely coupled and also greatly facilitates I/O operations.; In a client/server environment, this mechanism facilitates the access; to any kind of object in //root stores running on different processes. A TFolder is created by invoking the TFolder constructor. It is placed; inside an existing folder via the TFolder::AddFolder method.; One can search for a folder or an object in a folder using the FindObject; method. FindObject analyzes the string passed as its argument and searches; in the hierarchy until it finds an object or folder matching the name. When a folder is deleted, its reference from the parent folder and; possible other folders is deleted. If a folder has been declared the owner of its objects/folders via; TFolder::SetOwner, then the contained objects are deleted when the; f",MatchSource.WIKI,root/html602/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFolder.html
Availability,error,error,"Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tCompile(const char* expression = """"); virtual voidCopy(TObject& formula) const; virtual char*DefinedString(Int_t code); virtual Double_tDefinedValue(Int_t code); virtual Int_tDefinedVariable(TString& variable, Int_t& action); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; virtual Double_tEvalPar(const Double_t* x, const Double_t* params = 0); virtual Double_tEvalParOld(const Double_t* x, const Double_t* params = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringGetExpFormula(Option_t* option = """") const; virtual const char*TObject::GetIconName() const; virtual const TObject*GetLinearPart(Int_t i); static voidGetMaxima(Int_t& maxop, Int_t& maxpar, Int_t& maxconst); virtual const char*TNamed::GetName() const; virtual Int_tGetNdim() const; virtual Int_tGetNpar() const; virtual Int_tGetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Dou",MatchSource.WIKI,root/html602/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFormula.html
Deployability,update,updated,"then, old can be reused in a new expression.; TFormula new(""x*old"") is equivalent to:; TFormula new(""x*sin(x*(x<0.5 || x>1))""). Up to 4 dimensions are supported (indicated by x, y, z, t); An expression may have 0 parameters or a list of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShit) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user defined data types.; This also apply to the case of a static class function.; Because TMath is a special and frequent case, TFormula is aware; of all TMath functions. Function Members (Methods); public:. virtual~TFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidAnal",MatchSource.WIKI,root/html602/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFormula.html
Integrability,depend,depend," formula. The current value of variables x,y,z,t is passed through x, y, z and t.; The parameters used will be the ones in the array params if params is given; otherwise parameters will be taken from the stored data members fParams. Double_t EvalParOld(const Double_t* x, const Double_t* params = 0); Evaluate this formula. The current value of variables x,y,z,t is passed through the pointer x.; The parameters used will be the ones in the array params if params is given; otherwise parameters will be taken from the stored data members fParams. /*; ; */. TString GetExpFormula(Option_t* option = """") const; Reconstruct the formula expression from the internal TFormula member variables. This function uses the internal member variables of TFormula to; construct the mathematical expression associated with the TFormula; instance. This function can be used to get an expanded version of the; expression originally assigned to the TFormula instance, i.e. that; the string returned by GetExpFormula() doesn't depend on other; TFormula object names. if option contains ""p"" the returned string will contain the formula; expression with symbolic parameters, eg [0] replaced by the actual value; of the parameter. Example:; if expression in formula is: ""[0]*(x>-[1])+[2]*exp(-[3]*x)""; and parameters are 3.25,-4.01,4.44,-0.04, GetExpFormula(""p"") will return:; ""(3.25*(x>+4.01))+(4.44*exp(+0.04*x))"". const TObject* GetLinearPart(Int_t i); Return linear part. Double_t GetParameter(Int_t ipar) const; Return value of parameter number ipar. Double_t GetParameter(const char* name) const; Return value of parameter named parName. const char * GetParName(Int_t ipar) const; Return name of one parameter. Int_t GetParNumber(const char* name) const; Return parameter number by name. Bool_t IsString(Int_t oper) const; Return true if the expression at the index 'oper' has to be treated as a string. void Print(Option_t* option = """") const; Dump this formula with its attributes. void ProcessLinear(TString& repla",MatchSource.WIKI,root/html602/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFormula.html
Modifiability,inherit,inheriting,"then, old can be reused in a new expression.; TFormula new(""x*old"") is equivalent to:; TFormula new(""x*sin(x*(x<0.5 || x>1))""). Up to 4 dimensions are supported (indicated by x, y, z, t); An expression may have 0 parameters or a list of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShit) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user defined data types.; This also apply to the case of a static class function.; Because TMath is a special and frequent case, TFormula is aware; of all TMath functions. Function Members (Methods); public:. virtual~TFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidAnal",MatchSource.WIKI,root/html602/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFormula.html
Performance,perform,performance,"esult of a comparison is TRUE, the result is 1, otherwise 0. Already predefined names can be given. For example, if the formula; TFormula old(sin(x*(x<0.5 || x>1))) one can assign a name to the formula. By default; the name of the object = title = formula itself.; old.SetName(""old"").; then, old can be reused in a new expression.; TFormula new(""x*old"") is equivalent to:; TFormula new(""x*sin(x*(x<0.5 || x>1))""). Up to 4 dimensions are supported (indicated by x, y, z, t); An expression may have 0 parameters or a list of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShit) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user defined ",MatchSource.WIKI,root/html602/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFormula.html
Security,access,access,"ist of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShit) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user defined data types.; This also apply to the case of a static class function.; Because TMath is a special and frequent case, TFormula is aware; of all TMath functions. Function Members (Methods); public:. virtual~TFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidAnalyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tAnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); ",MatchSource.WIKI,root/html602/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFormula.html
Testability,log,logic,"at 0; expo(3) is a substitute for exp([3]+[4]*x); pol3(5) is a substitute for par[5]+par[6]*x+par[7]*x**2+par[8]*x**3; (here Pol3 stands for Polynomial of degree 3). TMath functions can be part of the expression, eg:; - TMath::Landau(x)*sin(x); - TMath::Erf(x). Comparisons operators are also supported (&&, ||, ==, <=, >=, !); Examples:; sin(x*(x<0.5 || x>1)); If the result of a comparison is TRUE, the result is 1, otherwise 0. Already predefined names can be given. For example, if the formula; TFormula old(sin(x*(x<0.5 || x>1))) one can assign a name to the formula. By default; the name of the object = title = formula itself.; old.SetName(""old"").; then, old can be reused in a new expression.; TFormula new(""x*old"") is equivalent to:; TFormula new(""x*sin(x*(x<0.5 || x>1))""). Up to 4 dimensions are supported (indicated by x, y, z, t); An expression may have 0 parameters or a list of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShit) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. CHANGING DEFAULT S",MatchSource.WIKI,root/html602/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFormula.html
Usability,simpl,simple,"example, if the formula; TFormula old(sin(x*(x<0.5 || x>1))) one can assign a name to the formula. By default; the name of the object = title = formula itself.; old.SetName(""old"").; then, old can be reused in a new expression.; TFormula new(""x*old"") is equivalent to:; TFormula new(""x*sin(x*(x<0.5 || x>1))""). Up to 4 dimensions are supported (indicated by x, y, z, t); An expression may have 0 parameters or a list of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShit) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user defined data types.; This also apply to the case of a static class function.; Because TMath is a special and fre",MatchSource.WIKI,root/html602/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFormula.html
Availability,error,error,"FormulaPrimitive* formula); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEval(Double_t* x); Double_tEval(TObject* o, Double_t* x); Double_tEval(Double_t* x, Double_t* param); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static TFormulaPrimitive*FindFormula(const char* name); static TFormulaPrimitive*FindFormula(const char* name, const char* args); static TFormulaPrimitive*FindFormula(const char* name, UInt_t nargs); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::",MatchSource.WIKI,root/html602/TFormulaPrimitive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFormulaPrimitive.html
Availability,error,error," virtual~TFPBlock(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; char*GetBuffer() const; Long64_tGetCapacity() const; Long64_tGetDataSize() const; virtual Option_t*TObject::GetDrawOption() const; static",MatchSource.WIKI,root/html602/TFPBlock.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFPBlock.html
Availability,error,errors,"stricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weights histograms. Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through; fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. Obtaining fit results. The fit is carried out through; Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through; fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by; TH1* result = fit->GetPlot();. Using different histograms. It is possible to change the histogram being fitted through; fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through; fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). Errors. Any serious inconsistency results in an error. Function Members (Methods); public:. virtual~TFractionFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); s",MatchSource.WIKI,root/html602/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFractionFitter.html
Integrability,message,message,"ension; TObjArrayfMCsarray of pointers to template histograms; Int_tfNDFNumber of degrees of freedom in the fit; Int_tfNparnumber of fit parameters; Int_tfNpfitsNumber of points used in the fit; TH1*fPlotpointer to histogram containing summed template predictions; TObjArrayfWeightsarray of pointers to corresponding weight factors (may be null). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFractionFitter(); TFractionFitter default constructor. TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); TFractionFitter constructor. Does a complete initialisation (including; consistency checks, default fit range as the whole histogram but without; under- and overflows, and declaration of the fit parameters). Note that; the histograms are not copied, only references are used.; Arguments:; data: histogram to be fitted; MCs: array of TH1* corresponding template distributions; Option: can be used to control the print level of the minimization algorithm; option = ""Q"" : quite - no message is printed; option = ""V"" : verbose - max print out; option = """" : default: print initial fraction values and result. ~TFractionFitter(); TFractionFitter default destructor. void SetData(TH1* data); Change the histogram to be fitted to. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetMC(Int_t parm, TH1* MC); Change the histogram for template number <parm>. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetWeight(Int_t parm, TH1* weight); Set bin by bin weights for template number <parm> (the parameter numbering; follows that of the input template vector).; Weights can be ""unset"" by passing a ",MatchSource.WIKI,root/html602/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFractionFitter.html
Performance,perform,perform,"(one per bin per; template), but the minimisation with respect to these additional parameters is; done analytically rather than introducing them as formal fit parameters. Some; special care needs to be taken in the case of bins with zero content. For more; details please see the original publication cited above. An example application of this fit is given below. For a TH1* histogram; (""data"") fitted as the sum of three Monte Carlo sources (""mc""):. {; TH1F *data; //data histogram; TH1F *mc0; // first MC histogram; TH1F *mc1; // second MC histogram; TH1F *mc2; // third MC histogram; .... // retrieve histograms; TObjArray *mc = new TObjArray(3); // MC histograms are put in this array; mc->Add(mc0);; mc->Add(mc1);; mc->Add(mc2);; TFractionFitter* fit = new TFractionFitter(data, mc); // initialise; fit->Constrain(1,0.0,1.0); // constrain fraction 1 to be between 0 and 1; fit->SetRangeX(1,15); // use only the first 15 bins in the fit; Int_t status = fit->Fit(); // perform the fit; std::cout << ""fit status: "" << status << std::endl;; if (status == 0) { // check on fit status; TH1F* result = (TH1F*) fit->GetPlot();; data->Draw(""Ep"");; result->Draw(""same"");; }; }. Assumptions. A few assumptions need to be made for the fit procedure to be carried out:. (1) The total number of events in each template is not too small; (so that its Poisson uncertainty can be neglected).; (2) The number of events in each bin is much smaller than the total; number of events in each template (so that multinomial; uncertainties can be replaced with Poisson uncertainties). Biased fit uncertainties may result if these conditions are not fulfilled; (see e.g. arXiv:0803.2711). Instantiation. A fit object is instantiated through; TFractionFitter* fit = new TFractionFitter(data, mc);; A number of basic checks (intended to ensure that the template histograms; represent the same ""kind"" of distribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters (the;",MatchSource.WIKI,root/html602/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFractionFitter.html
Safety,predict,predictions,". TFractionFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TFractionFitter. class TFractionFitter: public TObject. Fits MC fractions to data histogram (a la HMCMLL, see R. Barlow and C. Beeston,; Comp. Phys. Comm. 77 (1993) 219-228, and http://www.hep.man.ac.uk/~roger/hfrac.f). The virtue of this fit is that it takes into account both data and Monte Carlo; statistical uncertainties. The way in which this is done is through a standard; likelihood fit using Poisson statistics; however, the template (MC) predictions; are also varied within statistics, leading to additional contributions to the; overall likelihood. This leads to many more fit parameters (one per bin per; template), but the minimisation with respect to these additional parameters is; done analytically rather than introducing them as formal fit parameters. Some; special care needs to be taken in the case of bins with zero content. For more; details please see the original publication cited above. An example application of this fit is given below. For a TH1* histogram; (""data"") fitted as the sum of three Monte Carlo sources (""mc""):. {; TH1F *data; //data histogram; TH1F *mc0; // first MC histogram; TH1F *mc1; // second MC histogram; TH1F *mc2; // third MC histogram; .... // retrieve histograms; TObjArray *mc = new TObjArray(3); // MC histograms are put in this array; mc->Add(mc0);; mc->Add(mc1);; mc->Add(mc2);; TFractionFitter* fit = new TFractionFitter(data, mc); // initialise; fit->Constrain(1,0.0,1.0); // constrain fraction 1 to be between 0 and 1; fit->SetRangeX(1,15); // use only the first 15 bins in the fit; Int_t status = fit->Fit(); // perform the fit; std::cout << ""fit status: "" << status << std::endl;; if (status == 0) { // check on fit status; TH1F* result = (TH1F*) fit->GetPlot();; data->Draw(""Ep"");; result-",MatchSource.WIKI,root/html602/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFractionFitter.html
Security,access,access,"much smaller than the total; number of events in each template (so that multinomial; uncertainties can be replaced with Poisson uncertainties). Biased fit uncertainties may result if these conditions are not fulfilled; (see e.g. arXiv:0803.2711). Instantiation. A fit object is instantiated through; TFractionFitter* fit = new TFractionFitter(data, mc);; A number of basic checks (intended to ensure that the template histograms; represent the same ""kind"" of distribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters (the; template fractions) declared (initially unbounded). Applying constraints. Fit parameters can be constrained through; fit->Constrain(parameter #, lower bound, upper bound);; Setting lower bound = upper bound = 0 removes the constraint (a la Minuit);; however, a function; fit->Unconstrain(parameter #); is also provided to simplify this. Setting parameter values. The function; TVirtualFitter* vFit = fit->GetFitter();; is provided for direct access to the TVirtualFitter object. This allows to; set and fix parameter values, and set step sizes directly. Restricting the fit range. The fit range can be restricted through; fit->SetRangeX(first bin #, last bin #);; and freed using; fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weights histograms. Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through; fit->SetWeight(parameter #, pointer to weights histogram);; and unset by speci",MatchSource.WIKI,root/html602/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFractionFitter.html
Usability,simpl,simplify,"eed to be made for the fit procedure to be carried out:. (1) The total number of events in each template is not too small; (so that its Poisson uncertainty can be neglected).; (2) The number of events in each bin is much smaller than the total; number of events in each template (so that multinomial; uncertainties can be replaced with Poisson uncertainties). Biased fit uncertainties may result if these conditions are not fulfilled; (see e.g. arXiv:0803.2711). Instantiation. A fit object is instantiated through; TFractionFitter* fit = new TFractionFitter(data, mc);; A number of basic checks (intended to ensure that the template histograms; represent the same ""kind"" of distribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters (the; template fractions) declared (initially unbounded). Applying constraints. Fit parameters can be constrained through; fit->Constrain(parameter #, lower bound, upper bound);; Setting lower bound = upper bound = 0 removes the constraint (a la Minuit);; however, a function; fit->Unconstrain(parameter #); is also provided to simplify this. Setting parameter values. The function; TVirtualFitter* vFit = fit->GetFitter();; is provided for direct access to the TVirtualFitter object. This allows to; set and fix parameter values, and set step sizes directly. Restricting the fit range. The fit range can be restricted through; fit->SetRangeX(first bin #, last bin #);; and freed using; fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weig",MatchSource.WIKI,root/html602/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFractionFitter.html
Availability,error,error,"voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& frame) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBox::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTWbox::DrawWbox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Color_t color = 33, Short_t bordersize = 5, Short_t bordermode = -1); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTBox::GetBBox(); virtual TPointTBox::GetBBoxCenter(); Short_tTWbox::GetBorderMode() const; Short_tTWbox::GetBorderSize() const; Int_tTWbox::GetDarkColor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; Int_tTWbox::GetLightColor() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObjec",MatchSource.WIKI,root/html602/TFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFrame.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TFrameEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFrameEditor.html
Availability,error,error," virtual~TFree(); voidTObject::AbstractMethod(const char* method) const; TFree*AddFree(TList* lfree, Long64_t first, Long64_t last); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* param",MatchSource.WIKI,root/html602/TFree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFree.html
Availability,error,error," virtual~TFriendElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TTree*Connect(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual TTree*DisConnect(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObj",MatchSource.WIKI,root/html602/TFriendElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFriendElement.html
Modifiability,variab,variable,". TFriendElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TFriendElement. class TFriendElement: public TNamed. TFriendElement. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. To add a TFriendElement to an existing TTree T, do:; T.AddFriend(""friendTreename"",""friendTreeFile"");. See TTree::AddFriend for more information. Function Members (Methods); public:. virtual~TFriendElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TTree*Connect(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual TTree*DisConnect(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObj",MatchSource.WIKI,root/html602/TFriendElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFriendElement.html
Availability,error,error,"ectory(const char* dir) const; Int_tChangePermission(const char* file, Int_t mode) const; voidchmod(const char* file, Int_t mode) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Int_tClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeleteDirectory(const char* dir) const; Int_tDeleteFile(const char* file) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFreeDirectory(Bool_t print = kFALSE); voidget(const char* file, const char* localName = 0); Int_tGetBlockSize() const; const char*GetDirEntry(Bool_t print = kFALSE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetFile(const char* file, const char* localName = 0); virtual const char*TObject::GetIconName() const; Int_tGetMode() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPathInfo(const char* path, FileStat_t& buf, Bool_t p",MatchSource.WIKI,root/html602/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFTP.html
Energy Efficiency,power,power,"el = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() i",MatchSource.WIKI,root/html602/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFTP.html
Integrability,protocol,protocol,". TFTP. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TFTP. class TFTP: public TObject. TFTP. This class provides all infrastructure for a performant file; transfer protocol. It works in conjuction with the rootd daemon; and can use parallel sockets to improve performance over fat pipes. Function Members (Methods); public:. virtual~TFTP(); voidTObject::AbstractMethod(const char* method) const; Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); voidAscii(); voidascii(); voidbin(); voidBinary(); virtual voidTObject::Browse(TBrowser* b); voidbye(); voidcd(const char* dir) const; Int_tChangeDirectory(const char* dir) const; Int_tChangePermission(const char* file, Int_t mode) const; voidchmod(const char* file, Int_t mode) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Int_tClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeleteDirectory(const char* dir) const; Int_tDeleteFile(const char* file) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteE",MatchSource.WIKI,root/html602/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFTP.html
Performance,perform,performant,". TFTP. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TFTP. class TFTP: public TObject. TFTP. This class provides all infrastructure for a performant file; transfer protocol. It works in conjuction with the rootd daemon; and can use parallel sockets to improve performance over fat pipes. Function Members (Methods); public:. virtual~TFTP(); voidTObject::AbstractMethod(const char* method) const; Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); voidAscii(); voidascii(); voidbin(); voidBinary(); virtual voidTObject::Browse(TBrowser* b); voidbye(); voidcd(const char* dir) const; Int_tChangeDirectory(const char* dir) const; Int_tChangePermission(const char* file, Int_t mode) const; voidchmod(const char* file, Int_t mode) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Int_tClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeleteDirectory(const char* dir) const; Int_tDeleteFile(const char* file) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteE",MatchSource.WIKI,root/html602/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFTP.html
Security,access,access,"rmission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. TFTP(); { }. TFTP(const TFTP& ). void operator=(const TFTP& ). void SetMode(Int_t mode); { fMode = mode; }. Int_t GetBlockSize() const; { return fBlockSize; }. void SetRestartAt(Long64_t at); { fRestartAt = at; }. Long64_t GetRestartAt() const; { return fRestartAt; }. Int_t GetMode() const; { return fMode; }. Bool_t IsOpen() const; { return fSocket ? kTRUE : kFALSE; }. void Binary(); { SetMode(kBinary); }. void Ascii(); { SetMode(kAscii); }. TSocket * GetSocket() const; { return fSocket; }. void put(const char* file, const char* remoteName = 0); standard ftp equivalents... { PutFile(file, remoteName); }. void get(const char* file, const char* localName = 0); { GetFile(file, localName); }. void cd(const char* dir) const; { ChangeDirectory(dir); }. void mkdir(const char* dir) const; { MakeDirectory(dir",MatchSource.WIKI,root/html602/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFTP.html
Availability,error,errors,". TFumili. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FUMILI; » TFumili. class TFumili: public TVirtualFitter. FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. ; FUMILI minimization package; FUMILI is used to minimize Chi-square function or to search maximum of; likelihood function.; Experimentally measured values $F_i$ are fitted with theoretical; functions $f_i({\vec x}_i,\vec\theta\,\,)$, where ${\vec x}_i$ are; coordinates, and $\vec\theta$ -- vector of parameters.; For better convergence Chi-square function has to be the following form; $$; {\chi^2\over2}={1\over2}\sum^n_{i=1}\left(f_i(\vec; x_i,\vec\theta\,\,)-F_i\over\sigma_i\right)^2 \eqno(1); $$; where $\sigma_i$ are errors of measured function.; The minimum condition is; $$; {\partial\chi^2\over\partial\theta_i}=\sum^n_{j=1}{1\over\sigma^2_j}\cdot; {\partial f_j\over\partial\theta_i}\left[f_j(\vec; x_j,\vec\theta\,\,)-F_j\right]=0,\qquad i=1\ldots m\eqno(2); $$; where m is the quantity of parameters.; Expanding left part of (2) over parameter increments and; retaining only linear terms one gets; $$; \left(\partial\chi^2\over\theta_i\right)_{\vec\theta={\vec\theta}^0}; +\sum_k\left(\partial^2\chi^2\over\partial\theta_i\partial\theta_k\right)_{; \vec\theta={\vec\theta}^0}\cdot(\theta_k-\theta_k^0); = 0\eqno(3); $$; Here ${\vec\theta}_0$ is some initial value of parameters. In general; case:; $$; {\partial^2\chi^2\over\partial\theta_i\partial\theta_k}=; \sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; {\partial f_j\over\theta_k} +; \sum^n_{j=1}{(f_j - F_j)\over\sigma^2_j}\cdot; {\partial^2f_j\over\partial\theta_i\partial\theta_k}\eqno(4); $$; In FUMILI algorithm for second derivatives of Chi-square approximate; expressi",MatchSource.WIKI,root/html602/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFumili.html
Deployability,release,released,"; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Li",MatchSource.WIKI,root/html602/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFumili.html
Integrability,wrap,wrapper,"in content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}. » Last changed: root/fumili:$Id$ » Last generated: 2015-06-30 14:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFumili.html
Modifiability,variab,variable,"ance; Inherited Members; Includes; Libraries. Function documentation; TFumili(Int_t maxpar = 25); maxpar is the maximum number of parameters used with TFumili object. void BuildArrays(). Allocates memory for internal arrays. Called by TFumili::TFumili. ~TFumili(). TFumili destructor. Double_t Chisquare(Int_t npar, Double_t* params) const; return a chisquare equivalent. void Clear(Option_t* opt = """"). Resets all parameter names, values and errors to zero. Argument opt is ignored. NB: this procedure doesn't reset parameter limits. void DeleteArrays(). Deallocates memory. Called from destructor TFumili::~TFumili. void Derivatives(Double_t* , Double_t* ). Calculates partial derivatives of theoretical function. Input:; fX - vector of data point; Output:; DF - array of derivatives. ARITHM.F; Converted from CERNLIB. Int_t Eval(Int_t& npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated; grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The vector of first derivatives. The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate their function value.; The starting values must be specified by the user. Inside FCN user has to define Z-matrix by means TFumili::GetZ; and TFumili::Derivatives,; set theoretical function by means of TFumili::SetUserFunc,; but first - pass number of parameters by TFumili::SetParNumber. Later values are determined by Fumili as it searches for the minimum; or performs whatever analysis is requested by the user. The default function calls the function specified in SetFCN. Double_t EvalTFN(Double_t* , Double_t* ); Evaluate theoretical function; df: array of partial derivatives; X: vector of theoretical function argument. Int_t ExecuteCommand(const char",MatchSource.WIKI,root/html602/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFumili.html
Performance,cache,cache,"eted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; void(*)(Int_t&,Double_t*,Double_t&,Double_t*,Int_t)TVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. Double_t*fA[fMaxParam] Fit parameter array; Double_tfAKAPPA; Double_t*fAMN[fMaxParam] Minimum param value; Double_t*fAMX[fMaxParam] Maximum param value; TString*fANames[fMaxParam] Parameter names; Double_t*fCmPar[fMaxParam] parameters of commands;",MatchSource.WIKI,root/html602/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFumili.html
Safety,predict,predict,"arded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin ",MatchSource.WIKI,root/html602/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFumili.html
Testability,log,logarithm,"sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; {\partial f_j\over\theta_k}\eqno(5); $$; Then the equations for parameter increments are; $$\left(\partial\chi^2\over\partial\theta_i\right)_{\vec\theta={\vec\theta}^0}; +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) = 0,; \qquad i=1\ldots m\eqno(6); $$; Remarkable feature of algorithm is the technique for step; restriction. For an initial value of parameter ${\vec\theta}^0$ a; parallelepiped $P_0$ is built with the center at ${\vec\theta}^0$ and; axes parallel to coordinate axes $\theta_i$. The lengths of; parallelepiped sides along i-th axis is $2b_i$, where $b_i$ is such a; value that the functions $f_j(\vec\theta)$ are quasi-linear all over; the parallelepiped.; FUMILI takes into account simple linear inequalities in the form:; $$; \theta_i^{\rm min}\le\theta_i\le\theta^{\rm max}_i\eqno(7); $$; They form parallelepiped $P$ ($P_0$ may be deformed by $P$).; Very similar step formulae are used in FUMILI for negative logarithm; of the likelihood function with the same idea - linearization of; function argument. Function Members (Methods); public:. virtual~TFumili(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildArrays(); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* opt = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArrays(); voidDerivatives(Double_t*, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voi",MatchSource.WIKI,root/html602/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFumili.html
Usability,simpl,simple,"ne tries; minimize $\chi^2 = g^2(\vec\theta)$ where g is arbitrary function.; Approximate value is:; $${\partial^2\chi^2\over\partial\theta_i\partial\theta_k}\approx; Z_{ik}=; \sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; {\partial f_j\over\theta_k}\eqno(5); $$; Then the equations for parameter increments are; $$\left(\partial\chi^2\over\partial\theta_i\right)_{\vec\theta={\vec\theta}^0}; +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) = 0,; \qquad i=1\ldots m\eqno(6); $$; Remarkable feature of algorithm is the technique for step; restriction. For an initial value of parameter ${\vec\theta}^0$ a; parallelepiped $P_0$ is built with the center at ${\vec\theta}^0$ and; axes parallel to coordinate axes $\theta_i$. The lengths of; parallelepiped sides along i-th axis is $2b_i$, where $b_i$ is such a; value that the functions $f_j(\vec\theta)$ are quasi-linear all over; the parallelepiped.; FUMILI takes into account simple linear inequalities in the form:; $$; \theta_i^{\rm min}\le\theta_i\le\theta^{\rm max}_i\eqno(7); $$; They form parallelepiped $P$ ($P_0$ may be deformed by $P$).; Very similar step formulae are used in FUMILI for negative logarithm; of the likelihood function with the same idea - linearization of; function argument. Function Members (Methods); public:. virtual~TFumili(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildArrays(); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* opt = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArrays(); voidDerivatives(Double_t*, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); ",MatchSource.WIKI,root/html602/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFumili.html
Availability,error,errors,"tVariableValue(unsigned int ivar, double val); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); virtual voidShowMembers(TMemberInspector& insp) const; intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TFumiliMinimizer(int dummy = 0); doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int ivar) const; virtual const double*X() const. protected:. static doubleEvaluateFCN(const double* x, double* g); static voidFcn(int&, double*, double& f, double*, int). private:. TFumiliMinimizer&operator=(const TFumiliMinimizer& rhs); TFumiliMinimizer(const TFumiliMinimizer&). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; doublefEdm; vector<double>fErrors; TFumili*fFumili; doublefMinVal; unsigned intfNFree; vector<double>fParams; static TFumili*fgFumilistatic instance (used by fcn function); static ROOT::Math::FitMethodFunction*fgFunc; static ROOT::Math::FitMethodGradFunction*fgGradFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumiliMinimizer(int dummy = 0); Constructor for TFumiliMinimier class. ~TFumiliMinimizer(); Destructor implementation. TFumiliMinimizer(const TFumiliMinimizer& ); Implementation of copy constructor (it is private). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Fumil",MatchSource.WIKI,root/html602/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFumiliMinimizer.html
Deployability,update,update," there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. dou",MatchSource.WIKI,root/html602/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFumiliMinimizer.html
Integrability,interface,interface,". TFumiliMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FUMILI; » TFumiliMinimizer. class TFumiliMinimizer: public ROOT::Math::Minimizer. TFumiliMinimizer class implementing the ROOT::Math::Minimizer interface using; TFumili.; This class is normally instantiates using the plug-in manager; (plug-in with name Fumili or TFumili); In addition the user can choose the minimizer algorithm: Migrad (the default one), Simplex, or Minimize (combined Migrad + Simplex). Function Members (Methods); public:. virtual~TFumiliMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::Minimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& pars) const; virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int ivar) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; virtual boolROOT::Math::Minimizer::IsFixedVariable(unsigned int ivar) const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::",MatchSource.WIKI,root/html602/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFumiliMinimizer.html
Modifiability,plug-in,plug-in,". TFumiliMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FUMILI; » TFumiliMinimizer. class TFumiliMinimizer: public ROOT::Math::Minimizer. TFumiliMinimizer class implementing the ROOT::Math::Minimizer interface using; TFumili.; This class is normally instantiates using the plug-in manager; (plug-in with name Fumili or TFumili); In addition the user can choose the minimizer algorithm: Migrad (the default one), Simplex, or Minimize (combined Migrad + Simplex). Function Members (Methods); public:. virtual~TFumiliMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::Minimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& pars) const; virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int ivar) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; virtual boolROOT::Math::Minimizer::IsFixedVariable(unsigned int ivar) const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::",MatchSource.WIKI,root/html602/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFumiliMinimizer.html
Performance,perform,perform,"ulti-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and er",MatchSource.WIKI,root/html602/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFumiliMinimizer.html
Security,validat,validated,"tVariableValue(unsigned int ivar, double val); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); virtual voidShowMembers(TMemberInspector& insp) const; intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TFumiliMinimizer(int dummy = 0); doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int ivar) const; virtual const double*X() const. protected:. static doubleEvaluateFCN(const double* x, double* g); static voidFcn(int&, double*, double& f, double*, int). private:. TFumiliMinimizer&operator=(const TFumiliMinimizer& rhs); TFumiliMinimizer(const TFumiliMinimizer&). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; doublefEdm; vector<double>fErrors; TFumili*fFumili; doublefMinVal; unsigned intfNFree; vector<double>fParams; static TFumili*fgFumilistatic instance (used by fcn function); static ROOT::Math::FitMethodFunction*fgFunc; static ROOT::Math::FitMethodGradFunction*fgGradFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumiliMinimizer(int dummy = 0); Constructor for TFumiliMinimier class. ~TFumiliMinimizer(); Destructor implementation. TFumiliMinimizer(const TFumiliMinimizer& ); Implementation of copy constructor (it is private). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Fumil",MatchSource.WIKI,root/html602/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFumiliMinimizer.html
Availability,error,error," virtual~TFunction(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); Long_tExtraProperty() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictAttributeMap*TDictio",MatchSource.WIKI,root/html602/TFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFunction.html
Integrability,interface,interface,"complete signature string. const char * GetSignature(); Return signature of function. TList * GetListOfMethodArgs(); Return list containing the TMethodArgs of a TFunction. const char * GetReturnTypeName() const; Get full type description of function return type, e,g.: ""class TDirectory*"". std::string GetReturnTypeNormalizedName() const; Get the normalized name of the return type. A normalized name is fully; qualified and has all typedef desugared except for the 'special' typedef; which include Double32_t, Float16_t, [U]Long64_t and std::string. It; also has std:: removed [This is subject to change]. Int_t GetNargs() const; Number of function arguments. Int_t GetNargsOpt() const; Number of function optional (default) arguments. Long_t Property() const; Get property description word. For meaning of bits see EProperty. Long_t ExtraProperty() const; Get property description word. For meaning of bits see EProperty. TDictionary::DeclId_t GetDeclId() const. void * InterfaceMethod() const; Return pointer to the interface method. Using this pointer we; can find which TFunction belongs to a CINT MethodInfo object.; Both need to have the same InterfaceMethod pointer. Bool_t IsValid(); Return true if this function object is pointing to a currently; loaded function. If a function is unloaded after the TFunction; is created, the TFunction will be set to be invalid. const char * GetMangledName() const; Returns the mangled name as defined by CINT, or 0 in case of error. const char * GetPrototype() const; Returns the prototype of a function as defined by CINT, or 0 in; case of error. void ls(Option_t* option = """") const; List TFunction name and title. void Print(Option_t* option = """") const; Print TFunction name and title. Bool_t Update(MethodInfo_t* info); Update the TFunction to reflect the new info. This can be used to implement unloading (info == 0) and then reloading; (info being the 'new' decl address). » Author: Fons Rademakers 07/02/97 » Copyright (C) 1995-2000, Rene Brun an",MatchSource.WIKI,root/html602/TFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFunction.html
Performance,load,loaded,"pe description of function return type, e,g.: ""class TDirectory*"". std::string GetReturnTypeNormalizedName() const; Get the normalized name of the return type. A normalized name is fully; qualified and has all typedef desugared except for the 'special' typedef; which include Double32_t, Float16_t, [U]Long64_t and std::string. It; also has std:: removed [This is subject to change]. Int_t GetNargs() const; Number of function arguments. Int_t GetNargsOpt() const; Number of function optional (default) arguments. Long_t Property() const; Get property description word. For meaning of bits see EProperty. Long_t ExtraProperty() const; Get property description word. For meaning of bits see EProperty. TDictionary::DeclId_t GetDeclId() const. void * InterfaceMethod() const; Return pointer to the interface method. Using this pointer we; can find which TFunction belongs to a CINT MethodInfo object.; Both need to have the same InterfaceMethod pointer. Bool_t IsValid(); Return true if this function object is pointing to a currently; loaded function. If a function is unloaded after the TFunction; is created, the TFunction will be set to be invalid. const char * GetMangledName() const; Returns the mangled name as defined by CINT, or 0 in case of error. const char * GetPrototype() const; Returns the prototype of a function as defined by CINT, or 0 in; case of error. void ls(Option_t* option = """") const; List TFunction name and title. void Print(Option_t* option = """") const; Print TFunction name and title. Bool_t Update(MethodInfo_t* info); Update the TFunction to reflect the new info. This can be used to implement unloading (info == 0) and then reloading; (info being the 'new' decl address). » Author: Fons Rademakers 07/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-30 14:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a ma",MatchSource.WIKI,root/html602/TFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFunction.html
Security,access,accessible,". TFunction. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TFunction. class TFunction: public TDictionary. Global functions class (global functions are obtaine from CINT).; This class describes one single global function.; The TROOT class contains a list of all currently defined global; functions (accessible via TROOT::GetListOfGlobalFunctions()). Function Members (Methods); public:. virtual~TFunction(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); Long_tExtraProperty() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictAttributeMap*TDictio",MatchSource.WIKI,root/html602/TFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFunction.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html602/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFunctionParametersDialog.html
Deployability,update,update,"nt_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual UInt_tTGFrame::GetOptions() const; const TGWindow*TGWindow::GetParent() const; static const TGGC&TGFrame::GetShadowGC(); TGDimensionTGFrame::GetSize() const; Int_tTGCompositeFrame::GetState(TGFrame* f) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; static const TGGC&TGFrame::GetWhiteGC(); static Pixel_tTGFrame::GetWhitePixel(); UInt_tTGFrame::GetWidth() const; const char*TGMainFrame::GetWindowName() const; voidTGMainFrame::GetWMPosition(Int_t& x, Int_t& y) const; voidTGMainFrame::GetWMSize(UInt_t& w, UInt_t& h) const; voidTGMainFrame::GetWMSizeHints(UInt_t& wmin, UInt_t& hmin, UInt_t& wmax, UInt_t& hmax, UInt_t& winc, UInt_t& hinc) const; EInitialStateTGMainFrame::GetWMState() const; Int_tTGFrame::GetX() const; Int_tTGFrame::GetY() const; virtual Bool_tTGMainFrame::HandleButton(Event_t* event); virtual voidHandleButtons(Bool_t update); virtual Bool_tTGMainFrame::HandleClientMessage(Event_t* event); virtual Bool_tTGFrame::HandleColormapChange(Event_t*); virtual Bool_tTGFrame::HandleConfigureNotify(Event_t* event); virtual Bool_tTGCompositeFrame::HandleCrossing(Event_t*); virtual Bool_tTGFrame::HandleDNDDrop(TDNDData*); virtual Atom_tTGFrame::HandleDNDEnter(Atom_t*); virtual Bool_tTGFrame::HandleDNDFinished(); virtual Bool_tTGFrame::HandleDNDLeave(); virtual Atom_tTGFrame::HandleDNDPosition(Int_t, Int_t, Atom_t, Int_t, Int_t); virtual Bool_tTGCompositeFrame::HandleDoubleClick(Event_t*); virtual Bool_tTGCompositeFrame::HandleDragDrop(TGFrame* frame, Int_t x, Int_t y, TGLayoutHints* lo); virtual Bool_tTGCompositeFrame::HandleDragEnter(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragLeave(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(",MatchSource.WIKI,root/html602/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFunctionParametersDialog.html
Integrability,depend,dependent,"fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFunctionParametersDialog(const TGWindow* p, const TGWindow* main, TF1* func, TVirtualPad* pad, Double_t rmin, Double_t rmax); Create the parameters' dialog of currently selected function 'func'. ~TFunctionParametersDialog(); Destructor. void CloseWindow(); Close parameters' dialog. void DoCancel(); Slot related to the Cancel button. void DoFix(Bool_t on); Slot related to the Fix check button. void DoOK(); Slot related to the OK button. void DoApply(); Slot related to the Preview button. void DoReset(); Slot related to the Reset button. void DoSlider(); Slot related to the parameters' value settings. void DoParValue(); Slot related to the parameter value settings. void DoParMinLimit(); Slot related to the minumum parameter limit settings. void DoParMaxLimit(); Slot related to the maximum parameter limit settings. void RedrawFunction(); Redraw function graphics. void HandleButtons(Bool_t update); Handle the button dependent states in this dialog. TFunctionParametersDialog(const TGWindow* p, const TGWindow* main, TF1* func, TVirtualPad* pad, Double_t rmin, Double_t rmax). » Author: Ilka Antcheva 08/05/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id$ » Last generated: 2015-06-30 14:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFunctionParametersDialog.html
Availability,error,error," virtual~TFunctionTemplate(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TDictionary::DeclId_tGetDeclId() const; static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*",MatchSource.WIKI,root/html602/TFunctionTemplate.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFunctionTemplate.html
Performance,load,loaded,"ject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TDictionary::ESTLTypeTDictionary::kSet; static TObject::(anonymous)TObject::kSingleKey; static TDictionary::ESTLTypeTDictionary::kVector; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TClass*fClasspointer to the class (if any).; FuncTempInfo_t*fInfopointer to Interpreter function template info; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFunctionTemplate(FuncTempInfo_t* info, TClass* cl); Default TFunctionTemplate ctor. TFunctionTemplate(const TFunctionTemplate& orig); Copy operator. TFunctionTemplate& operator=(const TFunctionTemplate& rhs); Assignment operator. ~TFunctionTemplate(); TFunctionTemplate dtor deletes adopted CINT FuncTempInfo. TObject * Clone(const char* newname = """") const; Clone method. Bool_t IsValid(); Return true if this function template object is pointing to a currently; loaded function. If a function is unloaded after the TFunction; is created, the TFunction will be set to be invalid. UInt_t GetTemplateNargs() const; Number of function arguments. UInt_t GetTemplateMinReqArgs() const; Number of function optional (default) arguments. Long_t Property() const; Get property description word. For meaning of bits see EProperty. TDictionary::DeclId_t GetDeclId() const. Bool_t Update(FuncTempInfo_t* info); Update the TFunctionTemplate to reflect the new info. This can be used to implement unloading (info == 0) and then reloading; (info being the 'new' decl address). » Author: Philippe Canal November 2013. » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta: » Last generated: 2015-06-30 14:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TFunctionTemplate.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TFunctionTemplate.html
Availability,down,down,". TG16ColorSelector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TG16ColorSelector. class TG16ColorSelector: public TGCompositeFrame. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. virtual~TG16ColorSelector(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newnam",MatchSource.WIKI,root/html602/TG16ColorSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TG16ColorSelector.html
Integrability,message,messages,"ame*fCe[16]matrix of color cells; TGClient*TGObject::fClientConnection to display server; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*fMsgWindowwindow handling container messages; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedB",MatchSource.WIKI,root/html602/TG16ColorSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TG16ColorSelector.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const char*TApplication::GetIdleCommand() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*T",MatchSource.WIKI,root/html602/TGApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGApplication.html
Availability,error,error,"nst TObject* obj) const; virtual voidTLine::Copy(TObject& line) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTLine::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawAxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, Double_t wmin, Double_t wmax, Int_t ndiv = 510, Option_t* chopt = """", Double_t gridlength = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TLine*TLine::DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual TLine*TLine::DrawLineNDC(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTLine::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTLine::GetBBox(); virtual TPointTLine::GetBBoxCenter(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TF1*GetFunction() const; Float_tGetGridLength() const; virtual const char*TObject::GetIconName() const; Int_tGetLabelColor() const; Int_tGetLabelFont() const; Float_tGetLabelOffset() const; Float_tGetLabelSize() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; static Int_tGetMaxDigits(); virtual const char*GetName() const; Int_tGetNdiv() const; virtual char*TObject::GetObjectInfo(",MatchSource.WIKI,root/html602/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGaxis.html
Modifiability,inherit,inherited,"tripped, and then the; label is correctly aligned. The dot, if last character of the string,; is also stripped, unless this option is specified.; One can disable the option by calling axis.SetDecimals(kTRUE).; Note the bit is set in fBits (as opposed to fBits2 in TAxis!). void SetFunction(const char* funcname = """"); Specify a function to map the axis values. void SetMaxDigits(Int_t maxd = 5); Static function to set fgMaxDigits for axis.; fgMaxDigits is the maximum number of digits permitted for the axis; labels above which the notation with 10^N is used.; For example, to accept 6 digits number like 900000 on an axis; call TGaxis::SetMaxDigits(6). The default value is 5.; fgMaxDigits must be greater than 0. void SetName(const char* name); Change the name of the axis. void SetMoreLogLabels(Bool_t more = kTRUE); Set the kMoreLogLabels bit flag.; When this option is selected more labels are drawn when in log scale; and there is a small number of decades (<3).; Note that this option is automatically inherited from TAxis. void SetNoExponent(Bool_t noExponent = kTRUE); Set the NoExponent flag.; By default, an exponent of the form 10^N is used when the label values; are either all very small or very large.; One can disable the exponent by calling axis.SetNoExponent(kTRUE). void SetOption(Option_t* option = """"); To set axis options. void SetTitle(const char* title = """"); Change the title of the axis. void SetTimeFormat(const char* tformat); Change the format used for time plotting.; The format string for date and time use the same options as the one used; in the standard strftime C function, i.e. :; for date :; %a abbreviated weekday name; %b abbreviated month name; %d day of the month (01-31); %m month (01-12); %y year without century. for time :; %H hour (24-hour clock); %I hour (12-hour clock); %p local equivalent of AM or PM; %M minute (00-59); %S seconds (00-61); %% %. void SetTimeOffset(Double_t toffset, Option_t* option = ""local""); Change the time offset.; If option =",MatchSource.WIKI,root/html602/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGaxis.html
Performance,optimiz,optimization,"k mark.; chopt='C': labels are Centered on tick mark.; chopt='M': In the Middle of the divisions. Format of labels. Blank characters are stripped, and then the; label is correctly aligned. the dot, if last; character of the string, is also stripped,; unless the option ""."" (a dot, or period) is specified.; if SetDecimals(kTRUE) has been called (bit TAxis::kDecimals set).; all labels have the same number of decimals after the "".""; The same is true if gStyle->SetStripDecimals(kFALSE) has been called. In the following, we have some parameters, like; tick marks length and characters height (in percentage; of the length of the axis (WC)); The default values are as follows:. Primary tick marks: 3.0 %; Secondary tick marks: 1.5 %; Third order tick marks: .75 %; Characters height for labels: 4%. Labels offset: 1.0 %. optional grid. chopt='W': cross-Wire; In case of a log axis, the grid is only drawn for the primary tick marks; if the number of secondary and tertiary divisions is 0. Axis bining optimization. By default the axis bining is optimized . chopt='N': No bining optimization; chopt='I': Integer labelling. Maximum Number of Digits for the axis labels. See the static function TGaxis::SetMaxDigits. Time representation. Axis labels may be considered as times, plotted in a defined time format.; The format is set with SetTimeFormat().; wmin and wmax are considered as two time values in seconds.; The time axis will be spread around the time offset value (set with; SetTimeOffset() ). Actually it will go from TimeOffset+wmin to; TimeOffset+wmax.; see examples in tutorials timeonaxis.C and timeonaxis2.C. chopt='t': Plot times with a defined format instead of values. void AdjustBinSize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BinWidth); Axis labels optimisation. This method adjusts the bining of the axis; in order to have integer values for the labels. Input parameters:. A1,A2 : Old WMIN,WMAX .; binLow,binHigh : New WMIN,",MatchSource.WIKI,root/html602/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGaxis.html
Testability,log,logarithmic,"axis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, const char* funcname, Int_t ndiv = 510, Option_t* chopt = """", Double_t gridlength = 0); TGaxis constructor with a TF1 to map axis values. See explanation of parameters in PaintAxis; Instead of the wmin,wmax arguments of the normal constructor, the; name of a TF1 function can be specified. This function will be used; by TGaxis::PaintAxis to map the user coordinates to the axis values; and ticks.; Examples:; void gaxis3a(); {; gStyle->SetOptStat(0);. TH2F *h2 = new TH2F(""h"",""Axes"",100,0,10,100,-2,2);; h2->Draw();. TF1 *f1=new TF1(""f1"",""-x"",-10,10);; TGaxis *A1 = new TGaxis(0,2,10,2,""f1"",510,""-"");; A1->SetTitle(""axis with decreasing values"");; A1->Draw();. TF1 *f2=new TF1(""f2"",""exp(x)"",0,2);; TGaxis *A2 = new TGaxis(1,1,9,1,""f2"");; A2->SetTitle(""exponential axis"");; A2->SetLabelSize(0.03);; A2->SetTitleSize(0.03);; A2->SetTitleOffset(1.2);; A2->Draw();. TF1 *f3=new TF1(""f3"",""log10(x)"",1,1000);; TGaxis *A3 = new TGaxis(2,-2,2,0,""f3"",505,""G"");; A3->SetTitle(""logarithmic axis"");; A3->SetLabelSize(0.03);; A3->SetTitleSize(0.03);; A3->SetTitleOffset(1.2);; A3->Draw();; }. /*; ; */. TGaxis(const TGaxis& ); Copy constructor. TGaxis& operator=(const TGaxis& ); Assignement operator. ~TGaxis(); TGaxis default destructor. void CenterLabels(Bool_t center = kTRUE); If center = kTRUE axis labels are centered in the center of the bin.; The default is to center on the primary tick marks.; This option does not make sense if there are more bins than tick marks. void CenterTitle(Bool_t center = kTRUE); If center = kTRUE axis title will be centered.; The default is right adjusted. void DrawAxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, Double_t wmin, Double_t wmax, Int_t ndiv = 510, Option_t* chopt = """", Double_t gridlength = 0); Draw this axis with new attributes. Int_t GetMaxDigits(); Static function returning fgMaxDigits (See SetMaxDigits). void ImportAxisAttributes(TAxis* axis); Copy TAxis attributes to",MatchSource.WIKI,root/html602/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGaxis.html
Availability,avail,available,"_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Methods); public:. virtual~TGButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidAllowStayDown(Bool_t a); virtual voidTObject:",MatchSource.WIKI,root/html602/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGButton.html
Deployability,release,released,e height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tfNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStatefStatebutton state; Bool_tfStayDowntrue if button has to stay down; UInt_tfStylebutton style (modern or classic); UInt_tfTHeightbutton height; UInt_tfTWidthbutton width; TGToolTip*fTiptool tip associated with button; void*fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tfgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled.,MatchSource.WIKI,root/html602/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGButton.html
Integrability,message,message,"""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Method",MatchSource.WIKI,root/html602/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGButton.html
Performance,perform,perform,". TGButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGButton. class TGButton: public TGFrame, public TGWidget. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button ",MatchSource.WIKI,root/html602/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGButton.html
Security,access,access,". TGButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGButton. class TGButton: public TGFrame, public TGWidget. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button ",MatchSource.WIKI,root/html602/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGButton.html
Testability,log,logical," widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked",MatchSource.WIKI,root/html602/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGButton.html
Availability,down,down," ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widget organizes TGButton widgets in a group; with one horizontal row. TGHButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. The TGVButtonGroup widget organizes TGButton widgets in a group; with one vertical column. TGVButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. Function Members (Methods); public:. virtual~TGButtonGroup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInpu",MatchSource.WIKI,root/html602/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGButtonGroup.html
Deployability,toggle,toggle,". TGButtonGroup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGButtonGroup. class TGButtonGroup: public TGGroupFrame. The TGButtonGroup widget organizes TGButton widgets in a group. A button group widget makes it easier to deal with groups of buttons.; A button in a button group is associated with a unique identifier.; The button group emits a Clicked() signal with this identifier when; the button is clicked. Thus, a button group is an ideal solution; when you have several similar buttons and want to connect all their; Clicked() signals, for example, to one slot. An exclusive button group switches off all toggle buttons except; the one that was clicked. A button group is by default non-exclusive.; All radio buttons that are inserted, will be mutually exclusive even; if the button group is non-exclusive. There are two ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is e",MatchSource.WIKI,root/html602/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGButtonGroup.html
Modifiability,inherit,inherits,"roup. A button group widget makes it easier to deal with groups of buttons.; A button in a button group is associated with a unique identifier.; The button group emits a Clicked() signal with this identifier when; the button is clicked. Thus, a button group is an ideal solution; when you have several similar buttons and want to connect all their; Clicked() signals, for example, to one slot. An exclusive button group switches off all toggle buttons except; the one that was clicked. A button group is by default non-exclusive.; All radio buttons that are inserted, will be mutually exclusive even; if the button group is non-exclusive. There are two ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widg",MatchSource.WIKI,root/html602/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGButtonGroup.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; TGFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() ",MatchSource.WIKI,root/html602/TGCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGCanvas.html
Integrability,message,message,"GFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGCanvas(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kSunkenFrame | kDoubleBorder, Pixel_t back = GetDefaultFrameBackground()); Create a canvas object. ~TGCanvas(); Delete canvas. void MapSubwindows(); Map all canvas sub windows. void AddFrame(TGFrame* f, TGLayoutHints* l = 0); Adding a frame to a canvas is actually adding the frame to the; viewport container. The viewport container must be at least a; TGCompositeFrame for this method to succeed. void DrawBorder(); Draw canvas border. void Layout(); Create layout for canvas. Depending on the size of the container; we need to add the scrollbars. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle message generated by the canvas scrollbars. Int_t GetHsbPosition() const; Get position of horizontal scrollbar. Int_t GetVsbPosition() const; Get position of vertical scrollbar. void SetHsbPosition(Int_t newPos); Set position of horizontal scrollbar. void SetVsbPosition(Int_t newPos); Set position of vertical scrollbar. void SetScrolling(Int_t scrolling); Set scrolling policy. Use values defined by the enum: kCanvasNoScroll,; kCanvasScrollHorizontal, kCanvasScrollVertical, kCanvasScrollBoth. void ClearViewPort(); Clear view port and redraw content. void SavePrimitive(ostream& out, Option_t* option = """"); Save a canvas widget as a C++ statement(s) on output stream out. TGContainer& operator=(const TGCanvas& ). TGHScrollBar * GetHScrollbar() const. TGVScrollBar * GetVScrollbar() const. TGFrame * GetContainer() const; { return fContainer; }. void SetContainer(TGFrame* f). TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fHeight); }. TGCanvas(const TGCanvas& )",MatchSource.WIKI,root/html602/TGCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGCanvas.html
Availability,avail,available,"_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Methods); public:. virtual~TGCheckButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtu",MatchSource.WIKI,root/html602/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGCheckButton.html
Deployability,release,released,e; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled.,MatchSource.WIKI,root/html602/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGCheckButton.html
Integrability,message,message,"""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Method",MatchSource.WIKI,root/html602/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGCheckButton.html
Performance,perform,perform,". TGCheckButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGCheckButton. class TGCheckButton: public TGTextButton. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- butt",MatchSource.WIKI,root/html602/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGCheckButton.html
Security,access,access,". TGCheckButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGCheckButton. class TGCheckButton: public TGTextButton. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- butt",MatchSource.WIKI,root/html602/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGCheckButton.html
Testability,log,logical," widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked",MatchSource.WIKI,root/html602/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGCheckButton.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidForceRedraw(); voidFreeColor(Pixel_t color) const; voidFreeFont(const TGFont* font); voidFreeGC(const TGGC* gc); voidFreeGC(GContext_t gc); voidFreePicture(const TGPicture* pic); Bool_tGetColorByName(const char* name, Pixel_t& pixel) const; Colormap_tGetDefaultColormap() const; const TGWindow*GetDefaultRoot() const; UInt_tGetDisplayHeight() const; UInt_tGetDisplayWidth() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGFont*GetFont(const TGFont* font); TGFont*GetFont(const char* font, Bool_t fixedDefault = kTRUE); FontStruct_tGetFontByName(const char* name, Bool_t fixedDefault = kTRUE",MatchSource.WIKI,root/html602/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGClient.html
Integrability,message,message,"ForEventevent to wait for; Window_tfWaitForWindowwindow in which to wait for event; Pixel_tfWhitewhite color index; THashList*fWlistlist of frames; Int_tfXfdfile descriptor of connection to server; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGClient * Instance(); Returns global gClient (initialize graphics first, if not already done). TGClient(const char* dpyName = 0); Create a connection with the display sever on host dpyName and setup; the complete GUI system, i.e., graphics contexts, fonts, etc. for all; widgets. const TGWindow * GetRoot() const; Returns current root (i.e. base) window. By changing the root; window one can change the window hierarchy, e.g. a top level; frame (TGMainFrame) can be embedded in another window. const TGWindow * GetDefaultRoot() const; Returns the root (i.e. desktop) window. Should only be used as parent; for frames that will never be embedded, like popups, message boxes,; etc. (like TGToolTips, TGMessageBox, etc.). void SetRoot(TGWindow* root = 0); Sets the current root (i.e. base) window. By changing the root; window one can change the window hierarchy, e.g. a top level; frame (TGMainFrame) can be embedded in another window. void SetStyle(const char* style); Set the button style (modern or classic). UInt_t GetDisplayWidth() const; Get display width. UInt_t GetDisplayHeight() const; Get display height. const TGPicture * GetPicture(const char* name); Get picture from the picture pool. Picture must be freed using; TGClient::FreePicture(). If picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, UInt_t new_width, UInt_t new_height); Get picture with specified size from pool (picture will be scaled if; necessary). Picture must be freed using TGClient::FreePicture(). If; picture is not found 0 is returned. void FreePicture(const TGPicture* pic); Free picture resource. TGGC * GetGC(G",MatchSource.WIKI,root/html602/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGClient.html
Performance,load,loaded,"raphics context. TGFont * GetFont(const char* font, Bool_t fixedDefault = kTRUE); Get a font from the font pool. Fonts must be freed via; TGClient::FreeFont(). Returns 0 in case of error or if font; does not exist. If fixedDefault is false the ""fixed"" font; will not be substituted as fallback when the asked for font; does not exist. TGFont * GetFont(const TGFont* font); Get again specified font. Will increase its usage count. void FreeFont(const TGFont* font); Free a font. void NeedRedraw(TGWindow* w, Bool_t force = kFALSE); Set redraw flags. void CancelRedraw(TGWindow* w). Bool_t GetColorByName(const char* name, Pixel_t& pixel) const; Get a color by name. If color is found return kTRUE and pixel is; set to the color's pixel value, kFALSE otherwise. FontStruct_t GetFontByName(const char* name, Bool_t fixedDefault = kTRUE) const; Get a font by name. If font is not found, fixed font is returned,; if fixed font also does not exist return 0 and print error.; The loaded font needs to be freed using TVirtualX::DeleteFont().; If fixedDefault is false the ""fixed"" font will not be substituted; as fallback when the asked for font does not exist. Pixel_t GetHilite(Pixel_t base_color) const; Return pixel value of hilite color based on base_color. Pixel_t GetShadow(Pixel_t base_color) const; Return pixel value of shadow color based on base_color.; Shadow is 60% of base_color intensity. void FreeColor(Pixel_t color) const; Free color. void RegisterWindow(TGWindow* w); Add a TGWindow to the clients list of windows. void UnregisterWindow(TGWindow* w); Remove a TGWindow from the list of windows. void RegisterPopup(TGWindow* w); Add a popup menu to the list of popups. This list is used to pass; events to popup menus that are popped up over a transient window which; is waited for (see WaitFor()). void UnregisterPopup(TGWindow* w); Remove a popup menu from the list of popups. void AddUnknownWindowHandler(TGUnknownWindowHandler* h); Add handler for unknown (i.e. unregistered) windows. v",MatchSource.WIKI,root/html602/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGClient.html
Security,expose,expose," has been processed; kTRUE is returned. If processing of a specific event type for a specific; window was requested kFALSE is returned when specific event has been; processed, kTRUE otherwise. If no more pending events return kFALSE. Bool_t ProcessIdleEvent(); Process one idle event. Bool_t HandleInput(); Handles input from the display server. Returns kTRUE if one or more; events have been processed, kFALSE otherwise. void WaitFor(TGWindow* w); Wait for window to be destroyed. void WaitForUnmap(TGWindow* w); Wait for window to be unmapped. void ResetWaitFor(TGWindow* w); reset waiting. Bool_t ProcessEventsFor(TGWindow* w); Like gSystem->ProcessEvents() but then only allow events for w to; be processed. For example to interrupt the processing and destroy; the window, call gROOT->SetInterrupt() before destroying the window. Bool_t DoRedraw(); Redraw all windows that need redrawing. Returns kFALSE if no redraw; was needed, kTRUE otherwise.; Only redraw the application's windows when the event queue; does not contain expose event anymore. Bool_t HandleEvent(Event_t* event); Handle a GUI event. Bool_t HandleMaskEvent(Event_t* event, Window_t wid); Handle masked events only if window wid is the window for which the; event was reported or if wid is a parent of the event window. The not; masked event are handled directly. The masked events are:; kButtonPress, kButtonRelease, kKeyPress, kKeyRelease, kEnterNotify,; kLeaveNotify, kMotionNotify. void ProcessLine(TString cmd, Long_t msg, Long_t parm1, Long_t parm2); Execute string ""cmd"" via the interpreter. Before executing replace; in the command string the token $MSG, $PARM1 and $PARM2 by msg,; parm1 and parm2, respectively. The function in cmd string must accept; these as longs. Bool_t IsEditDisabled() const; Returns kTRUE if edit/guibuilding is forbidden. void SetEditDisabled(Bool_t on = kTRUE); If on is kTRUE editting/guibuilding is forbidden. void ProcessedEvent(Event_t* event, Window_t wid); Emits a signal when an event h",MatchSource.WIKI,root/html602/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGClient.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); TGColorPalette*GetCustomPalette() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; st",MatchSource.WIKI,root/html602/TGColorDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGColorDialog.html
Integrability,message,messages,"GFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorDialog(const TGWindow* p = 0, const TGWindow* m = 0, Int_t* retc = 0, Pixel_t* color = 0, Bool_t wait = kTRUE); Color selection dialog constructor.; The TGColorDialog presents a full featured color selection dialog.; It uses 2 TGColorPalette's and the TGColorPick widgets. ~TGColorDialog(); TGColorDialog destructor. void SetCurrentColor(Pixel_t col); Change current color. void ColorSelected(Pixel_t ); Emit signal about selected color. void AlphaColorSelected(ULong_t ); Emit signal about selected alpha and color. void CloseWindow(); Called when window is closed via window manager. void UpdateAlpha(Pixel_t* c); Upadate Opacity text entry with alpha value of color c. void UpdateRGBentries(Pixel_t* c); Update RGB text entries with RGB values of color c. void UpdateHLSentries(Pixel_t* c); Update HLS text entries with HLS values of color c. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for the color selection dialog. void SetColorInfo(Int_t event, Int_t px, Int_t py, TObject* selected); Set the color info in RGB and HLS parts. void DoPreview(); Slot method called when Preview button is clicked. TGColorPalette& operator=(const TGColorDialog& ). TGColorDialog(const TGColorDialog& ). TGColorPalette * GetPalette() const; { return fPalette; }. TGColorPalette * GetCustomPalette() const; { return fCpalette; }. » Author: Bertrand Bellenot + Fons Rademakers 22/08/02 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGColorDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGColorDialog.html
Availability,down,down,". TGColorFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGColorFrame. class TGColorFrame: public TGFrame. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. virtual~TGColorFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver,",MatchSource.WIKI,root/html602/TGColorFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGColorFrame.html
Integrability,message,messages,,MatchSource.WIKI,root/html602/TGColorFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGColorFrame.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; Pixel_tGetColorByIndex(Int_t ix) const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); Pixel_tGetCurrentColor() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGColorPalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGColorPalette.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); Pixel_tGetCurrentColor() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetD",MatchSource.WIKI,root/html602/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGColorPick.html
Energy Efficiency,allocate,allocate,"*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. private:. Int_tfColormap[64][3]colormap; Pixel_tfPixel[64]pixel values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorPick(const TGWindow* p = 0, Int_t w = 1, Int_t h = 1, Int_t id = -1); TGColorPick constructor.; TGColorPick is a widget which allows a color to be picked from HLS space.; It consists of two elements: a color map window from where the user can; select the hue and saturation level of a color, and a slider to select; color's lightness. ~TGColorPick(); TGColorPick destructor. Bool_t HandleButton(Event_t* event); Handle mouse button events in color pick widget. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in color pick widget. void CreateImages(); Create colormap and color slider images. void AllocColors(); Try to allocate first a palette of 64 colors. Used by the dithered; version of the color maps. void FreeColors(); Free allocated colors. void CreateDitheredImage(Pixmap_t image, Int_t which); Create a dithered version of the color map and lightness images for; display modes with reduced number of colors. The Floyd-Steinberg error; diffusion dithering algorithm is used.; This routine is called in PseudoColor modes only. void InitImages(); Initialize color palette and slider images. void SetSliderColor(); Set slider colors. void SetColor(Pixel_t color); Position the slider cursor on right color position. void UpdateCurrentColor(); Assign the current cursor position as currently selected color. void DoRedraw(); Redraw the color pick widget. void SetHScursor(Int_t x, Int_t y); Set hue / saturation cursor position. void SetLcursor(Int_t z); Set lightness slider cursor position. void DrawHScursor(Int_t onoff); Draw hue / saturation cursor. void DrawLcursor(Int_t onoff); Draw lightness slider cursor. TGC",MatchSource.WIKI,root/html602/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGColorPick.html
Integrability,rout,routine,"0, Int_t w = 1, Int_t h = 1, Int_t id = -1); TGColorPick constructor.; TGColorPick is a widget which allows a color to be picked from HLS space.; It consists of two elements: a color map window from where the user can; select the hue and saturation level of a color, and a slider to select; color's lightness. ~TGColorPick(); TGColorPick destructor. Bool_t HandleButton(Event_t* event); Handle mouse button events in color pick widget. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in color pick widget. void CreateImages(); Create colormap and color slider images. void AllocColors(); Try to allocate first a palette of 64 colors. Used by the dithered; version of the color maps. void FreeColors(); Free allocated colors. void CreateDitheredImage(Pixmap_t image, Int_t which); Create a dithered version of the color map and lightness images for; display modes with reduced number of colors. The Floyd-Steinberg error; diffusion dithering algorithm is used.; This routine is called in PseudoColor modes only. void InitImages(); Initialize color palette and slider images. void SetSliderColor(); Set slider colors. void SetColor(Pixel_t color); Position the slider cursor on right color position. void UpdateCurrentColor(); Assign the current cursor position as currently selected color. void DoRedraw(); Redraw the color pick widget. void SetHScursor(Int_t x, Int_t y); Set hue / saturation cursor position. void SetLcursor(Int_t z); Set lightness slider cursor position. void DrawHScursor(Int_t onoff); Draw hue / saturation cursor. void DrawLcursor(Int_t onoff); Draw lightness slider cursor. TGColorPalette& operator=(const TGColorPick& ). Pixel_t GetCurrentColor() const. void ColorSelected(Pixel_t col = 0); { Emit(""ColorSelected(Pixel_t)"", col ? col : GetCurrentColor()); }. TGColorPick(const TGWindow* p = 0, Int_t w = 1, Int_t h = 1, Int_t id = -1). » Author: Bertrand Bellenot + Fons Rademakers 22/08/02 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last ch",MatchSource.WIKI,root/html602/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGColorPick.html
Availability,down,down,". TGColorPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGColorPopup. class TGColorPopup: public TGCompositeFrame. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. virtual~TGColorPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidT",MatchSource.WIKI,root/html602/TGColorPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGColorPopup.html
Integrability,message,messages,"orcurrently selected color value; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Int_tfLaunchDialogflag used for launching color dialog; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*fMsgWindowwindow handling container messages; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedB",MatchSource.WIKI,root/html602/TGColorPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGColorPopup.html
Availability,down,down,". TGColorSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGColorSelect. class TGColorSelect: public TGCheckButton. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. virtual~TGColorSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidAlphaColorSelected(ULong_t colptr = 0)SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; virtual TOb",MatchSource.WIKI,root/html602/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGColorSelect.html
Deployability,release,released,ateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled.,MatchSource.WIKI,root/html602/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGColorSelect.html
Integrability,message,messages,"c const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorSelect(const TGWindow* p = 0, Pixel_t color = 0, Int_t id = -1); TGColorSelect constructor.; The TGColorSelect widget is like a checkbutton but instead of the check; mark there is color area with a little down arrow.; When clicked on the arrow the TGColorPopup pops up. ~TGColorSelect(); TGColorSelect destructor. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for TGColorSelect. Bool_t HandleButton(Event_t* event); Handle button events for TGColorSelect. void Enable(Bool_t on = kTRUE); Set state of widget as enabled. void Disable(); Set state of widget as disabled. void DoRedraw(); Redraw TGColorSelect widget. void DrawTriangle(GContext_t gc, Int_t x, Int_t y); Draw triangle (arrow) on which user can click to open TGColorPopup. void SetColor(Pixel_t color, Bool_t emit = kTRUE); Set color. void SetAlphaColor(ULong_t color, Bool_t emit = kTRUE); Set color. void SavePrimitive(ostream& out, Option_t* = """"); Save a color select widget as a C++ statement(s) on output stream out. TGColorFrame& operator=(const TGColorSelect& ). Pixel_t GetColor() const; { return fColor; }. TGColorSelect(const TGColorSelect& ). void SetDown(Bool_t on = kTRUE, Bool_t emit = kFALSE); dummy methods just to remove from context menu. { TGButton::SetDown(on, emit); }. void Rename(const char* title); { TGTextButton::SetTitle(title); }. void Se",MatchSource.WIKI,root/html602/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGColorSelect.html
Availability,down,downward,". TGColumnLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGColumnLayout. class TGColumnLayout: public TGRowLayout. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. virtual~TGColumnLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*T",MatchSource.WIKI,root/html602/TGColumnLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGColumnLayout.html
Availability,down,down,". TGComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGComboBox. class TGComboBox: public TGCompositeFrame, public TGWidget. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. virtual~TGComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddEntry(TGString* s, Int_t id); virtual voidAddEntry(const char* s, Int_t id); virtual voidAddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::",MatchSource.WIKI,root/html602/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGComboBox.html
Deployability,update,update,"serColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame | kSunkenFrame | kDoubleBorder, Pixel_t back = GetWhitePixel()); Create a combo box widget. TGComboBox(const TGWindow* p, const char* text, Int_t id = -1, UInt_t options = kHorizontalFrame | kSunkenFrame | kDoubleBorder, Pixel_t back = GetWhitePixel()); Create an editable combo box widget. ~TGComboBox(); Delete a combo box widget. void Init(); Initiate the internal classes of a combo box. void DrawBorder(); Draw border of combo box widget. void EnableTextInput(Bool_t on); Switch text input or readonly mode of combobox (not perfect yet). TGLBEntry * FindEntry(const char* s) const; Find entry by name. void SetTopEntry(TGLBEntry* e, TGLayoutHints* lh); Set a new combo box value (normally update of text string in; fSelEntry is done via fSelEntry::Update()). void Select(Int_t id, Bool_t emit = kTRUE); Make the selected item visible in the combo box window; and emit signals according to the second parameter. Bool_t HandleButton(Event_t* event); Handle mouse button events in the combo box. void RemoveEntry(Int_t id = -1); Remove entry. If id == -1, the currently selected entry is removed. void Layout(); layout combobox. Bool_t HandleDoubleClick(Event_t* event); Handle double click in text entry. Bool_t HandleMotion(Event_t* event); Handle pointer motion in text entry. Bool_t HandleSelection(Event_t* event); Handle selection in text entry. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request in text entry. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the listbox and forward; messages to the combobox message handling window. Parm2 contains; the id of the selected listbox entry. void Selected(Int_t wi",MatchSource.WIKI,root/html602/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGComboBox.html
Integrability,message,messages,"(not perfect yet). TGLBEntry * FindEntry(const char* s) const; Find entry by name. void SetTopEntry(TGLBEntry* e, TGLayoutHints* lh); Set a new combo box value (normally update of text string in; fSelEntry is done via fSelEntry::Update()). void Select(Int_t id, Bool_t emit = kTRUE); Make the selected item visible in the combo box window; and emit signals according to the second parameter. Bool_t HandleButton(Event_t* event); Handle mouse button events in the combo box. void RemoveEntry(Int_t id = -1); Remove entry. If id == -1, the currently selected entry is removed. void Layout(); layout combobox. Bool_t HandleDoubleClick(Event_t* event); Handle double click in text entry. Bool_t HandleMotion(Event_t* event); Handle pointer motion in text entry. Bool_t HandleSelection(Event_t* event); Handle selection in text entry. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request in text entry. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the listbox and forward; messages to the combobox message handling window. Parm2 contains; the id of the selected listbox entry. void Selected(Int_t widgetId, Int_t id); Emit signal. void SetEnabled(Bool_t on = kTRUE); Set state of combo box. If kTRUE=enabled, kFALSE=disabled. void ReturnPressed(); Add new entry to combo box when return key pressed inside text entry; ReturnPressed signal is emitted. void RemoveAll(); Remove all entries from combo box. void SavePrimitive(ostream& out, Option_t* option = """"); Save a combo box widget as a C++ statement(s) on output stream out. TGComboBoxPopup& operator=(const TGComboBox& ). TGComboBox(const TGComboBox& ). TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fHeight); }. void AddEntry(TGString* s, Int_t id); { fListBox->AddEntry(s, id); Resize(); }. void AddEntry(const char* s, Int_t id); { fListBox->AddEntry(s, id); Resize(); }. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); { fListBox->AddEntry(lbe, lhints); ",MatchSource.WIKI,root/html602/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGComboBox.html
Availability,down,down,". TGComboBoxPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGComboBoxPopup. class TGComboBoxPopup: public TGCompositeFrame. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. virtual~TGComboBoxPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLi",MatchSource.WIKI,root/html602/TGComboBoxPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGComboBoxPopup.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html602/TGCommandPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGCommandPlugin.html
Deployability,update,update,tions! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGMainFrame::fMWMFuncsMWM functions; UInt_tTGMainFrame::fMWMInputMWM input modes; UInt_tTGMainFrame::fMWMValueMWM decoration hints; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Int_tfPidcurrent process id; TStringTGMainFrame::fResourceNameWM resource name; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGTextView*fStatusoutput capture view; TTimer*fTimerfor local/remote update; UInt_tTGMainFrame::fWMHeightWM height; UInt_tTGMainFrame::fWMHeightIncWM height increments; EInitialStateTGMainFrame::fWMInitStateWM initial state; UInt_tTGMainFrame::fWMMaxHeightWM max height; UInt_tTGMainFrame::fWMMaxWidthWM max width; UInt_tTGMainFrame::fWMMinHeightWM min height; UInt_tTGMainFrame::fWMMinWidthWM min width; UInt_tTGMainFrame::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby;,MatchSource.WIKI,root/html602/TGCommandPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGCommandPlugin.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tGetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tGetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::Get",MatchSource.WIKI,root/html602/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGCompositeFrame.html
Performance,load,load,"lass Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGCompositeFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); Create a composite frame. A composite frame has in addition to a TGFrame; also a layout manager and a list of child frames. TGCompositeFrame(TGClient* c, Window_t id, const TGWindow* parent = 0); Create a frame using an externally created window. For example; to register the root window (called by TGClient), or a window; created via TVirtualX::InitWindow() (id is obtained with TVirtualX::GetWindowID()). ~TGCompositeFrame(); Delete a composite frame. Bool_t IsEditable() const; Return kTRUE if frame is being edited. void SetEditable(Bool_t on = kTRUE); Switch ON/OFF edit mode.; If edit mode is ON it is possible:. 1. embed other ROOT GUI application (a la ActiveX). For example:; TGMainFrame *m = new TGMainFrame(gClient->GetRoot(), 500, 500);; m->SetEditable();; gSystem->Load(""$ROOTSYS/test/Aclock""); // load Aclock demo; Aclock a;; gROOT->Macro(""$ROOTSYS/tutorials/gui/guitest.C"");; m->SetEditable(0);; m->MapWindow();. void Cleanup(); Cleanup and delete all objects contained in this composite frame.; This will delete all objects added via AddFrame().; CAUTION: all objects (frames and layout hints) must be unique, i.e.; cannot be shared. void SetLayoutManager(TGLayoutManager* l); Set the layout manager for the composite frame.; The layout manager is adopted by the frame and will be deleted; by the frame. void SetLayoutBroken(Bool_t on = kTRUE); Set broken layout. No Layout method is called. void SetEditDisabled(UInt_t on = 1); Set edit disable flag for this frame and subframes. - if (on & kEditDisable) - disable edit for this frame and all subframes. void ChangeOptions(UInt_t options); Change composite frame options. Options is an OR of the EFrameTypes. void SetCleanup(Int_t mode = kLocalCleanup); Turn on automatic cleanup of child frames in dtor. if mod",MatchSource.WIKI,root/html602/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGCompositeFrame.html
Testability,log,logically,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. virtual~TGCompositeFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidChangeOptions(UInt_t options); virtual voidChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidCleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQOb",MatchSource.WIKI,root/html602/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGCompositeFrame.html
Usability,simpl,simple,". TGCompositeFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGCompositeFrame. class TGCompositeFrame: public TGFrame. TGFrame, TGCompositeFrame, TGVerticalFrame, TGHorizontalFrame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. virtual~TGCompositeFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); v",MatchSource.WIKI,root/html602/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGCompositeFrame.html
Availability,error,error,"signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidEnd(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGCanvas*GetCanvas() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); ",MatchSource.WIKI,root/html602/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGContainer.html
Integrability,message,messages,; TStringfKeyInputkeyboard input (buffer); TTimer*fKeyTimerkeyboard timer; Bool_tfKeyTimerActivekTRUE - keyboard timer is active; TGFrameElement*fLastActiveEllast active item; Bool_tfLastCasecase sensetivity of last search; Bool_tfLastDirdirection of last search; TStringfLastNamethe name of object of last search; Bool_tfLastSubstringsubstring search option of last search; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*fMsgWindowwindow handling container messages; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; Bool_tfOnMouseOverkTRUE when mouse pointer is over entry; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TTimer*fScrollTimerautoscroll timer; Bool_tfScrollingkTRUE - when scrolling is ON; Int_tfSelectednumber of selected items; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfTotaltotal items; TGViewPort*fViewPortcontainer viewport; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tfX0corner of rubber band box; Int_tfXDND; Int_tfXfother corner of rubber band box; Int_tfXpprevious pointer position; Int_tTGFrame::fYframe y position; Int_tfY0corner of rubber band box; Int_tfYDND; Int_tfYfother corner of rubber band box; Int_tfYpprevious pointer position; static Bool_tTQObject::fgAllSignalsBlockedflag ,MatchSource.WIKI,root/html602/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGContainer.html
Security,expose,expose,"emove all items from the container. void RemoveItem(TGFrame* item); Remove item from container. const TGFrame * GetNextSelected(void** current); Return next selected item. void ActivateItem(TGFrameElement* el); Activate item. void DeActivateItem(TGFrameElement* el); DeActivate item. TGPosition GetPagePosition() const; Returns page position. TGDimension GetPageDimension() const; Returns page dimension. void SetPagePosition(const TGPosition& pos); Set page position. void SetPagePosition(Int_t x, Int_t y); Set page position. void SetPageDimension(const TGDimension& dim); Set page dimension. void SetPageDimension(UInt_t w, UInt_t h); Set page dimension. void DoRedraw(); Redraw content of container in the viewport region. void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw a region of container in viewport.; x, y, w, h are position and dimension of area to be; redrawn in viewport coordinates. void ClearViewPort(); Clear view port and redraw full content. Bool_t HandleExpose(Event_t* event); Handle expose events. Do not use double buffer. Bool_t HandleButton(Event_t* event); Handle mouse button event in container. const TGPicture * GetObjPicture(TGFrame* f); Retrieve icons associated with class ""name"". Association is made; via the user's ~/.root.mimes file or via $ROOTSYS/etc/root.mimes. void SetDragPixmap(const TGPicture* pic); Set drag window pixmaps and hotpoint. Bool_t HandleDoubleClick(Event_t* event); Handle double click mouse event. Bool_t HandleMotion(Event_t* event); Handle mouse motion events. Bool_t HandleKey(Event_t* event); The key press event handler converts a key press to some line editor; action. TGFrame * FindFrameByName(const char* name); Find frame by name. void Search(Bool_t close = kTRUE); Invokes search dialog. Looks for item with the entered name. void OnAutoScroll(); Autoscroll while close to & beyond The Wall. void SearchPattern(); Search for entry which name begins with pattern. void RepeatSearch(); Repeats search. TGFrameElement * FindFr",MatchSource.WIKI,root/html602/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGContainer.html
Availability,error,error,"TGDMLParse. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GDML; » TGDMLParse. class TGDMLParse: public TObject. Function Members (Methods); public:. virtual~TGDMLParse(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGeoVolume*GDMLReadFile(const char* filename = ""test.gdml""); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption",MatchSource.WIKI,root/html602/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDMLParse.html
Integrability,depend,depending,"ng rotation names and the TGeoRotation for it; TGDMLParse::SclMapfsclmap!Map containing scale names and the TGeoScale for it; TGDMLParse::SolMapfsolmap!Map containing solid names and the TGeoShape for it; TGDMLParse::VolMapfvolmap!Map containing volume names and the TGeoVolume for it. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoVolume* GDMLReadFile(const char* filename = ""test.gdml""); creates the new instance of the XMLEngine called 'gdml', using the filename >>; then parses the file and creates the DOM tree. Then passes the DOM to the; next function to translate it. const char* ParseGDML(TXMLEngine* gdml, XMLNodePointer_t node); this function recursively moves thru the DOM tree of the GDML file. It checks for; key words along the way and if a key word is found it calls the corresponding; function to interpret the node. double Evaluate(const char* evalline). Int_t SetAxis(const char* axisString); When using the 'divide' process in the geometry this function; sets the variable 'axis' depending on what is specified. const char* NameShort(const char* name); this function looks thru a string for the chars '0x' next to; each other, when it finds this, it calls another function to strip; the hex address. It does this recursively until the end of the; string is reached, returning a string without any hex addresses. XMLNodePointer_t ConProcess(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the define section of the GDML file, constants can be declared.; when the constant keyword is found, this function is called, and the; name and value of the constant is stored in the ""fformvec"" vector as; a TFormula class, representing a constant function. TString GetScale(const char* unit); Throughout the GDML file, a unit can de specified. Whether it be; angular or linear, values can be used as well as abbreviations such as; 'mm' or 'deg'. This function is passed the specified unit and if it is; found, replaces it wi",MatchSource.WIKI,root/html602/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDMLParse.html
Modifiability,variab,variable,"ng rotation names and the TGeoRotation for it; TGDMLParse::SclMapfsclmap!Map containing scale names and the TGeoScale for it; TGDMLParse::SolMapfsolmap!Map containing solid names and the TGeoShape for it; TGDMLParse::VolMapfvolmap!Map containing volume names and the TGeoVolume for it. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoVolume* GDMLReadFile(const char* filename = ""test.gdml""); creates the new instance of the XMLEngine called 'gdml', using the filename >>; then parses the file and creates the DOM tree. Then passes the DOM to the; next function to translate it. const char* ParseGDML(TXMLEngine* gdml, XMLNodePointer_t node); this function recursively moves thru the DOM tree of the GDML file. It checks for; key words along the way and if a key word is found it calls the corresponding; function to interpret the node. double Evaluate(const char* evalline). Int_t SetAxis(const char* axisString); When using the 'divide' process in the geometry this function; sets the variable 'axis' depending on what is specified. const char* NameShort(const char* name); this function looks thru a string for the chars '0x' next to; each other, when it finds this, it calls another function to strip; the hex address. It does this recursively until the end of the; string is reached, returning a string without any hex addresses. XMLNodePointer_t ConProcess(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the define section of the GDML file, constants can be declared.; when the constant keyword is found, this function is called, and the; name and value of the constant is stored in the ""fformvec"" vector as; a TFormula class, representing a constant function. TString GetScale(const char* unit); Throughout the GDML file, a unit can de specified. Whether it be; angular or linear, values can be used as well as abbreviations such as; 'mm' or 'deg'. This function is passed the specified unit and if it is; found, replaces it wi",MatchSource.WIKI,root/html602/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDMLParse.html
Testability,test,test,"TGDMLParse. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GDML; » TGDMLParse. class TGDMLParse: public TObject. Function Members (Methods); public:. virtual~TGDMLParse(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGeoVolume*GDMLReadFile(const char* filename = ""test.gdml""); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption",MatchSource.WIKI,root/html602/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDMLParse.html
Usability,simpl,simple,"the original assembly using TGeoVolume->AddNode. XMLNodePointer_t TopProcess(TXMLEngine* gdml, XMLNodePointer_t node); In the setup section of the GDML file, the top volume need to be; declared. when the setup keyword is found, this function is called,; and the top volume ref is taken and 'world' is set. XMLNodePointer_t Box(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, a box may be declared.; when the box keyword is found, this function is called, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoBBox and stored in fsolmap map using the name; as its key. XMLNodePointer_t Ellipsoid(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, an ellipsoid may be declared.; Unfortunately, the ellipsoid is not supported under ROOT so,; when the ellipsoid keyword is found, this function is called; to convert it to a simple box with similar dimensions, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoBBox and stored in fsolmap map using the name; as its key. XMLNodePointer_t ElCone(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, an elliptical cone may be declared.; Unfortunately, the elliptical cone is not supported under ROOT so,; when the elcone keyword is found, this function is called; to convert it to a simple box with similar dimensions, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoBBox and stored in fsolmap map using the name; as its key. XMLNodePointer_t Paraboloid(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, a Paraboloid may be declared.; when the paraboloid keyword is found, this function is called, and the; dimensions required are taken and stored, these are then bound and; converted to type TG",MatchSource.WIKI,root/html602/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDMLParse.html
Availability,error,error," virtual~TGDMLRefl(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*GetMatrix(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int",MatchSource.WIKI,root/html602/TGDMLRefl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDMLRefl.html
Security,access,accessor," const char* solid, TGeoMatrix* matrix); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TGeoMatrix*fMatrix!matrix of reflected solid; const char*fNameS!reflected solid name; const char*fSolid!solid name being reflected. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDMLRefl(const char* name, const char* solid, TGeoMatrix* matrix); this constructor method stores the values brought in as params. TGeoMatrix* GetMatrix(); this accessor method returns the matrix. TGDMLRefl(). virtual ~TGDMLRefl(); {}. TGDMLRefl(const char* name, const char* solid, TGeoMatrix* matrix). » Last changed: Tue Jun 30 14:50:28 2015 » Last generated: 2015-06-30 14:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGDMLRefl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDMLRefl.html
Availability,error,error,,MatchSource.WIKI,root/html602/TGDMLWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDMLWrite.html
Deployability,update,updated,"e; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GDML; » TGDMLWrite. class TGDMLWrite: public TObject. TGDMLWrite Class. This class contains implementation of converting ROOT's gGeoManager; geometry to GDML file. gGeoManager is the instance of TGeoManager class; containing tree of geometries creating resulting geometry. GDML is xml; based format of file mirroring the tree of geometries according to GDML; schema rules. For more information about GDML see http://gdml.web.cern.ch.; Each object in ROOT is represented by xml tag (=xml node/element) in GDML. This class is not needed to be instanciated. It should always be called; by gGeoManager->Export(""xyz.gdml"") method. Export is driven by extenstion; that is why "".gdml"" is important in resulting name. Whenever a new ROOT geometry object is implemented or there is a change; in GDML schema this class is needed to be updated to ensure proper mapping; between ROOT objects and GDML elements. Current status of mapping ROOT -> GDML is implemented in method called; TGDMLWrite::ChooseObject and it contains following ""map"":. Solids:; TGeoBBox -> <box ... >; TGeoParaboloid -> <paraboloid ...>; TGeoSphere -> <sphere ...>; TGeoArb8 -> <arb8 ...>; TGeoConeSeg -> <cone ...>; TGeoCone -> <cone ...>; TGeoPara -> <para ...>; TGeoTrap -> <trap ...> or; - -> <arb8 ...>; TGeoGtra -> <twistedtrap ...> or; - -> <trap ...> or; - -> <arb8 ...>; TGeoTrd1 -> <trd ...>; TGeoTrd2 -> <trd ...>; TGeoTubeSeg -> <tube ...>; TGeoCtub -> <cutTube ...>; TGeoTube -> <tube ...>; TGeoPcon -> <polycone ...>; TGeoTorus -> <torus ...>; TGeoPgon -> <polyhedra ...>; TGeoEltu -> <eltube ...>; TGeoHype -> <hype ...>; TGeoXtru -> <xtru ...>; TGeoCompositeShape -> <union ...> or; - -> <subtraction ...> or; - -> <intersection ...>. Special cases of solids:; TGeoScaledShape -> <elcone ...> if scaled TGeoCone or; - -> elemen",MatchSource.WIKI,root/html602/TGDMLWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDMLWrite.html
Security,secur,secured,"; - -> <intersection ...>. Special cases of solids:; TGeoScaledShape -> <elcone ...> if scaled TGeoCone or; - -> element without scale; TGeoCompositeShape -> <ellipsoid ...>; - intersection of:; - scaled TGeoSphere and TGeoBBox. Materials:; TGeoIsotope -> <isotope ...>; TGeoElement -> <element ...>; TGeoMaterial -> <material ...>; TGeoMixture -> <material ...>. Structure; TGeoVolume -> <volume ...> or; - -> <assembly ...>; TGeoNode -> <physvol ...>; TGeoPatternFinder -> <divisionvol ...>. There are options that can be set to change resulting document; Options:; g - is set by default in gGeoManager, this option ensures compatibility; - with Geant4. It means:; - -> atomic number of material will be changed if <1 to 1; - -> if polycone is set badly it will try to export it correctly; - -> if widht * ndiv + offset is more then width of object being divided; - (in divisions) then it will be rounded so it will not exceed or; - if kPhi divsion then it will keep range of offset in -360 -> 0; f - if this option is set then names of volumes and solids will have; - pointer as a suffix to ensure uniqness of names; n - if this option is set then names will not have suffix, but uniqness is; - of names is not secured; - - if none of this two options (f,n) is set then default behaviour is so; - that incremental suffix is added to the names.; - (eg. TGeoBBox_0x1, TGeoBBox_0x2 ...). USAGE:; gGeoManager->Export(""output.gdml"");; gGeoManager->Export(""output.gdml"","""",""vg""); //the same as previous just; options are set explicitly; gGeoManager->Export(""output.gdml"","""",""vgf"");; gGeoManager->Export(""output.gdml"","""",""gn"");; gGeoManager->Export(""output.gdml"","""",""f"");. NB:; Options discussed above are used only for TGDMLWrite class. There are; other options in the TGeoManager::Export(...) method that can be used.; See that function for details. Function Members (Methods); public:. virtual~TGDMLWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t",MatchSource.WIKI,root/html602/TGDMLWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDMLWrite.html
Testability,test,test,"delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGDMLWrite&operator=(const TGDMLWrite&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetG4Compatibility(Bool_t G4Compatible); voidSetNamingSpeed(TGDMLWrite::ENamingType naming); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; static voidStartGDMLWriting(TGeoManager* geomanager, const char* filename, TString option); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TGDMLWrite(); TGDMLWrite(const TGDMLWrite&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidWriteGDMLfile(TGeoManager* geomanager, const char* filename = ""test.",MatchSource.WIKI,root/html602/TGDMLWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDMLWrite.html
Availability,error,error,"ctMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tDrag(Int_t x_root, Int_t y_root, Atom_t action, Time_t timestamp); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Bool_tDrop(); virtual voidTObject::Dump() constMENU ; Bool_tEndDrag(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static Atom_tGetDNDActionAsk(); static Atom_tGetDNDActionCopy(); static Atom_tGetDNDActionDescrip(); static Atom_tGetDNDActionLink(); static Atom_tGetDNDActionList(); static Atom_tGetDNDActionMove(); static Atom_tGetDNDActionPrivate(); static Atom_tGetDNDAware(); static Atom_tGetDNDDrop(); static Atom_tGetDNDEnter(); static Atom_tGetDNDFinished(); static Atom_tGetDNDLeave(); static Atom_tGetDNDPosition(); static Atom_tGetDNDProxy(); static Atom_tGetDNDSelection(); static Atom_tGetDNDStatus(); static Atom_tGetDNDTypeList(); static Atom_tGetDNDVersion(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly",MatchSource.WIKI,root/html602/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDNDManager.html
Integrability,message,messages,"gDNDStatus; }. Atom_t GetDNDDrop(); { return fgDNDDrop; }. Atom_t GetDNDFinished(); { return fgDNDFinished; }. Atom_t GetDNDVersion(); { return fgDNDVersion; }. Atom_t GetDNDActionCopy(); { return fgDNDActionCopy; }. Atom_t GetDNDActionMove(); { return fgDNDActionMove; }. Atom_t GetDNDActionLink(); { return fgDNDActionLink; }. Atom_t GetDNDActionAsk(); { return fgDNDActionAsk; }. Atom_t GetDNDActionPrivate(); { return fgDNDActionPrivate; }. Atom_t GetDNDTypeList(); { return fgDNDTypeList; }. Atom_t GetDNDActionList(); { return fgDNDActionList; }. Atom_t GetDNDActionDescrip(); { return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t[3] dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND",MatchSource.WIKI,root/html602/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDNDManager.html
Safety,timeout,timeout,"ect::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Atom_tfAcceptedActionaccepted and local actions; Cursor_tfDNDNoDropCursorno drop cursor type; TGDragWindow*fDragWindrag window; Atom_t*fDraggerTypeslists of DND types; Bool_tfDraggingkTRUE while dragging; Bool_tfDropAcceptedkTRUE if drop accepted; TTimer*fDropTimeoutdrop timeout; Atom_tfDropTypedrop type; UInt_tfGrabEventMaskpointer grab event mask; Int_tfHotxhot point coordinates; Int_tfHotyhot point coordinates; Atom_tfLocalActionaccepted and local actions; TGFrame*fLocalSourcelocal source and target; TGFrame*fLocalTargetlocal source and target; TGFrame*fMainpointer on TGMainFrame; Pixmap_tfMaskpixmap used for the drag window; Pixmap_tfPicpixmap used for the drag window; Bool_tfProxyOurskTRUE if root proxy is ours; Window_tfSourcesource and target windows; Bool_tfStatusPendingkTRUE if status is pending; Window_tfTargetsource and target windows; Bool_tfTargetIsDNDAwarekTRUE if target is DND aware; Atom_t*fTypelistlists of DND types; Bool_tfUseVersionkTRUE if DND version is used; Atom_tfVersionnot really an Atom, but a long; static Atom_tfgDNDActionAsk; static Atom_tfgDNDActionCopy; static Atom_tfgDNDActionDescrip; static Atom_tfgDNDActionLink; static Atom_tfgDNDActionList; static Atom_tfgDNDActionMove; static Atom_tfgDNDActionPrivate; static Atom_tfgDNDAware; static Atom_tfgDNDDrop; static Atom_tfgDNDEnter; static Atom_tfgDNDFinished; static Atom_tfgDNDLeave; static Atom_tfgDNDPosition; static Atom_tfgDNDProxy; static Atom_tfgDNDSelection; static Atom_tfgDNDStatus; static Atom_tfgDNDTypeList; static Atom_tfgDNDVersion; static Bool_tfgInit; static Atom_tfgXAWMState; static Atom_tfgXCDNDData. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDNDManager(TGFrame* toplevel, Atom_t* typelist); TGDNDManager constructor. ~TGDNDManager(); TGDND",MatchSource.WIKI,root/html602/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDNDManager.html
Availability,error,error,"m); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); Bool_tEnableHide() const; voidEnableHide(Bool_t onoff); Bool_tEnableUndock() const; voidEnableUndock(Bool_t onoff); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; TGCompositeFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::",MatchSource.WIKI,root/html602/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDockableFrame.html
Integrability,message,messages,"gDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }. » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-20",MatchSource.WIKI,root/html602/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDockableFrame.html
Usability,undo,undocked,". TGDockableFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGDockableFrame. class TGDockableFrame: public TGCompositeFrame, public TGWidget. A TGDockableFrame is a frame with handles that allow it to be; undocked (i.e. put in a transient frame of its own) and to be docked; again or hidden and shown again. It uses the TGDockButton, which is; a button with two vertical bars (||) and TGDockHideButton, which is; a button with a small triangle. The TGUndockedFrame is a transient; frame that on closure will put the frame back in the dock. Function Members (Methods); public:. virtual~TGDockableFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddFrame(TGFrame* f, TGLayoutHints* hints); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); ",MatchSource.WIKI,root/html602/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDockableFrame.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*T",MatchSource.WIKI,root/html602/TGDockButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDockButton.html
Deployability,release,released,nst TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; ULong_tfNormBgnormal background color; GContext_tTGButton::fNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled.,MatchSource.WIKI,root/html602/TGDockButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDockButton.html
Usability,undo,undocked,". TGDockButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGDockButton. class TGDockButton: public TGButton. A TGDockableFrame is a frame with handles that allow it to be; undocked (i.e. put in a transient frame of its own) and to be docked; again or hidden and shown again. It uses the TGDockButton, which is; a button with two vertical bars (||) and TGDockHideButton, which is; a button with a small triangle. The TGUndockedFrame is a transient; frame that on closure will put the frame back in the dock. Function Members (Methods); public:. virtual~TGDockButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* sl",MatchSource.WIKI,root/html602/TGDockButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDockButton.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*T",MatchSource.WIKI,root/html602/TGDockHideButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDockHideButton.html
Deployability,release,released,GWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; ULong_tTGDockButton::fNormBgnormal background color; GContext_tTGButton::fNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled.,MatchSource.WIKI,root/html602/TGDockHideButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDockHideButton.html
Usability,undo,undocked,". TGDockHideButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGDockHideButton. class TGDockHideButton: public TGDockButton. A TGDockableFrame is a frame with handles that allow it to be; undocked (i.e. put in a transient frame of its own) and to be docked; again or hidden and shown again. It uses the TGDockButton, which is; a button with two vertical bars (||) and TGDockHideButton, which is; a button with a small triangle. The TGUndockedFrame is a transient; frame that on closure will put the frame back in the dock. Function Members (Methods); public:. virtual~TGDockHideButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* rece",MatchSource.WIKI,root/html602/TGDockHideButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDockHideButton.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::Get",MatchSource.WIKI,root/html602/TGDoubleHSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDoubleHSlider.html
Availability,avail,available,"nge the max value press the mouse near to the right / top; edge of the slider.; To change both values simultaneously press the mouse near to the; center of the slider. TGDoubleSlider is an abstract base class. Use the concrete; TGDoubleVSlider and TGDoubleHSlider. Dragging the slider will generate the event:; kC_VSLIDER, kSL_POS, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_POS, slider id, 0 (for horizontal slider). Pressing the mouse will generate the event:; kC_VSLIDER, kSL_PRESS, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_PRESS, slider id, 0 (for horizontal slider). Releasing the mouse will generate the event:; kC_VSLIDER, kSL_RELEASE, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_RELEASE, slider id, 0 (for horizontal slider). Use the functions GetMinPosition(), GetMaxPosition() and; GetPosition() to retrieve the position of the slider. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGDoubleSlider(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQ",MatchSource.WIKI,root/html602/TGDoubleSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDoubleSlider.html
Integrability,depend,depending,"fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDoubleSlider(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t type = 1, Int_t id = -1, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground(), Bool_t reversed = kFALSE, Bool_t mark_ends = kFALSE); Slider constructor. void FixBounds(Float_t& min, Float_t& max); Avoid boundaries to be equal. TString GetSString() const; Returns the slider type as a string - used in SavePrimitive(). void ChangeCursor(Event_t* event); Change the cursor shape depending on the slider area. TGDoubleSlider(const TGDoubleSlider& ). TGDoubleSlider& operator=(const TGDoubleSlider& ). virtual ~TGDoubleSlider(); { }. Bool_t HandleButton(Event_t* event). Bool_t HandleMotion(Event_t* event). void SetScale(Int_t scale); { fScale = scale; }. void SetRange(Float_t min, Float_t max). void SetPosition(Float_t min, Float_t max). Float_t GetMinPosition() const. Float_t GetMaxPosition() const. void GetPosition(Float_t& min, Float_t& max) const. void GetPosition(Float_t* min, Float_t* max) const. void MapSubwindows(); { TGWindow::MapSubwindows(); }. void PositionChanged(); { Emit(""PositionChanged()""); }. void Pressed(); { Emit(""Pressed()""); }. void Released(); { Emit(""Released()""); }. » Author: Reiner Rohlfs 30/09/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:50; This page has been automatically generated. For comments or suggestions regarding the documentation or R",MatchSource.WIKI,root/html602/TGDoubleSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDoubleSlider.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::Get",MatchSource.WIKI,root/html602/TGDoubleVSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDoubleVSlider.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObjec",MatchSource.WIKI,root/html602/TGDragWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGDragWindow.html
Availability,error,error,"am); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidExcludeClassEditor(TClass* cl, Bool_t recurse = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTVirtualPadEditor::FillAttributes(Int_t, Int_t); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TCanvas*GetCanvas() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtu",MatchSource.WIKI,root/html602/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGedEditor.html
Integrability,interface,interface,"ts editors according to the selected object in the canvas; (an object became selected after the user click on it using the; left-mouse button). Every object editor provides an object specific GUI and follows a; simple naming convention: it has as a name the object class name; concatinated with 'Editor' (e.g. for TGraph objects the object; editor is TGraphEditor). The ROOT graphics editor can be activated by selecting 'Editor'; from the View canvas menu, or SetLine/Fill/Text/MarkerAttributes; from the context menu. The algorithm in use is simple: according to; the selected object <obj> in the canvas it looks for a class name; <obj>Editor. If a class with this name exists, the editor verifies; that this class derives from the base editor class TGedFrame.; It makes an instance of the object editor, scans all object base; classes searching the corresponding object editors and makes an; instance of the base class editor too. Once the object editor is in; place, it sets the user interface elements according to the object; state and is ready for interactions. When a new object of a; different class is selected, a new object editor is loaded in the; editor frame. The old one is cached in memory for potential reuse. Any created canvas will be shown with the editor if you have a; .rootrc file in your working directory containing the the line:; Canvas.ShowEditor: true. An created object can be set as selected in a macro by:; canvas->Selected(parent_pad_of_object, object, 1);; The first parameter can be the canvas itself or the pad containing; 'object'. //; /*. */. Function Members (Methods); public:. virtual~TGedEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidActivateEditor(TClass* cl, Bool_t recurse); voidActivateEditors(TList* bcl, Bool_t recurse); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); stati",MatchSource.WIKI,root/html602/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGedEditor.html
Performance,load,loaded,"he; left-mouse button). Every object editor provides an object specific GUI and follows a; simple naming convention: it has as a name the object class name; concatinated with 'Editor' (e.g. for TGraph objects the object; editor is TGraphEditor). The ROOT graphics editor can be activated by selecting 'Editor'; from the View canvas menu, or SetLine/Fill/Text/MarkerAttributes; from the context menu. The algorithm in use is simple: according to; the selected object <obj> in the canvas it looks for a class name; <obj>Editor. If a class with this name exists, the editor verifies; that this class derives from the base editor class TGedFrame.; It makes an instance of the object editor, scans all object base; classes searching the corresponding object editors and makes an; instance of the base class editor too. Once the object editor is in; place, it sets the user interface elements according to the object; state and is ready for interactions. When a new object of a; different class is selected, a new object editor is loaded in the; editor frame. The old one is cached in memory for potential reuse. Any created canvas will be shown with the editor if you have a; .rootrc file in your working directory containing the the line:; Canvas.ShowEditor: true. An created object can be set as selected in a macro by:; canvas->Selected(parent_pad_of_object, object, 1);; The first parameter can be the canvas itself or the pad containing; 'object'. //; /*. */. Function Members (Methods); public:. virtual~TGedEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidActivateEditor(TClass* cl, Bool_t recurse); voidActivateEditors(TList* bcl, Bool_t recurse); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(",MatchSource.WIKI,root/html602/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGedEditor.html
Usability,simpl,simple,". TGedEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedEditor. class TGedEditor: public TVirtualPadEditor, public TGMainFrame. TGedEditor. The main class of ROOT graphics editor. It manages the appearance; of objects editors according to the selected object in the canvas; (an object became selected after the user click on it using the; left-mouse button). Every object editor provides an object specific GUI and follows a; simple naming convention: it has as a name the object class name; concatinated with 'Editor' (e.g. for TGraph objects the object; editor is TGraphEditor). The ROOT graphics editor can be activated by selecting 'Editor'; from the View canvas menu, or SetLine/Fill/Text/MarkerAttributes; from the context menu. The algorithm in use is simple: according to; the selected object <obj> in the canvas it looks for a class name; <obj>Editor. If a class with this name exists, the editor verifies; that this class derives from the base editor class TGedFrame.; It makes an instance of the object editor, scans all object base; classes searching the corresponding object editors and makes an; instance of the base class editor too. Once the object editor is in; place, it sets the user interface elements according to the object; state and is ready for interactions. When a new object of a; different class is selected, a new object editor is loaded in the; editor frame. The old one is cached in memory for potential reuse. Any created canvas will be shown with the editor if you have a; .rootrc file in your working directory containing the the line:; Canvas.ShowEditor: true. An created object can be set as selected in a macro by:; canvas->Selected(parent_pad_of_object, object, 1);; The first parameter can be the canvas itself or the pad containing; 'object'. //; /*. */. Function Member",MatchSource.WIKI,root/html602/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGedEditor.html
Availability,avail,available,". TGedFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedFrame. class TGedFrame: public TGCompositeFrame. TGedFrame. Base frame for implementing GUI - a service class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGedFrame(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidActivateBaseClassEditors(TClass* cl); virtual voidAddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static ",MatchSource.WIKI,root/html602/TGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGedFrame.html
Availability,down,down,". TGedMarkerPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedMarkerPopup. class TGedMarkerPopup: public TGedPopup. TGedMarkerSelect, TGedMarkerPopup. The TGedMarkerPopup is a popup containing buttons to; select marker style. The TGedMarkerSelect widget is a button showing selected marker; and a little down arrow. When clicked on the arrow the; TGedMarkerPopup pops up. Selecting a marker in this widget will generate the event:; kC_MARKERSEL, kMAR_SELCHANGED, widget id, style. and the signal:; MarkerSelected(Style_t marker). Function Members (Methods); public:. virtual~TGedMarkerPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* s",MatchSource.WIKI,root/html602/TGedMarkerPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGedMarkerPopup.html
Integrability,message,messages,"window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedMarkerPopup(const TGWindow* p, const TGWindow* m, Style_t markerStyle); Create marker popup window. ~TGedMarkerPopup(); Destructor. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the marker popup window. TGedMarkerPopup(const TGWindow* p, const TGWindow* m, Style_t markerStyle). » Author: Marek Biskup, Ilka Antcheva 24/07/03 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id$ » Last generated: 2015-06-30 14:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGedMarkerPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGedMarkerPopup.html
Availability,down,down,". TGedMarkerSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedMarkerSelect. class TGedMarkerSelect: public TGedSelect. TGedMarkerSelect, TGedMarkerPopup. The TGedMarkerPopup is a popup containing buttons to; select marker style. The TGedMarkerSelect widget is a button showing selected marker; and a little down arrow. When clicked on the arrow the; TGedMarkerPopup pops up. Selecting a marker in this widget will generate the event:; kC_MARKERSEL, kMAR_SELCHANGED, widget id, style. and the signal:; MarkerSelected(Style_t marker). Function Members (Methods); public:. virtual~TGedMarkerSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject",MatchSource.WIKI,root/html602/TGedMarkerSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGedMarkerSelect.html
Deployability,release,released,ateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled.,MatchSource.WIKI,root/html602/TGedMarkerSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGedMarkerSelect.html
Integrability,message,messages,"ame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedMarkerSelect(const TGWindow* p, Style_t markerStyle, Int_t id); Create and show marker popup window. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages according to the user input. void DoRedraw(); Draw selected marker type as current one. void SetMarkerStyle(Style_t pattern); Set marker. void SavePrimitive(ostream& out, Option_t* = """"); Save the pattern select widget as a C++ statement(s) on output stream out. TGedMarkerSelect(const TGWindow* p, Style_t markerStyle, Int_t id). virtual ~TGedMarkerSelect(); { if(fPicture) gClient->FreePicture(fPicture);}. Style_t GetMarkerStyle() const; { return fMarkerStyle; }. void MarkerSelected(Style_t marker = 0); { Emit(""MarkerSelected(Style_t)"", marker ? marker : GetMarkerStyle()); }. TGDimension GetDefaultSize() const; { return TGDimension(38, 21); }. » Author: Marek Biskup, Ilka Antcheva 24/07/03 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id$ » Last generated: 2015-06-30 14:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT sup",MatchSource.WIKI,root/html602/TGedMarkerSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGedMarkerSelect.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGedNameFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGedNameFrame.html
Availability,down,down,". TGedPatternFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPatternFrame. class TGedPatternFrame: public TGFrame. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. virtual~TGedPatternFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const cha",MatchSource.WIKI,root/html602/TGedPatternFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGedPatternFrame.html
Availability,down,down,". TGedPatternPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPatternPopup. class TGedPatternPopup: public TGedPopup. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. virtual~TGedPatternPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObjec",MatchSource.WIKI,root/html602/TGedPatternPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGedPatternPopup.html
Integrability,message,messages,"SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedPatternPopup(const TGWindow* p, const TGWindow* m, Style_t pattern); Pattern popup constructor. ~TGedPatternPopup(); Destructor of pattern popup window. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by pattern popup window. TGedPatternPopup(const TGWindow* p, const TGWindow* m, Style_t pattern). » Author: Marek Biskup, Ilka Antcheva 24/07/03 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGedPatternPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGedPatternPopup.html
Availability,down,down,". TGedPatternSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPatternSelect. class TGedPatternSelect: public TGedSelect. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. virtual~TGedPatternSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; virtual TObject*TOb",MatchSource.WIKI,root/html602/TGedPatternSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGedPatternSelect.html
Deployability,release,released,ateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled.,MatchSource.WIKI,root/html602/TGedPatternSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGedPatternSelect.html
Integrability,message,message,"tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedPatternSelect(const TGWindow* p, Style_t pattern, Int_t id); Create and pop up pattern select window. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process message according to the user input. void DoRedraw(); Draw selected pattern as current one. void SetPattern(Style_t pattern, Bool_t emit = kTRUE); Set pattern. void SavePrimitive(ostream& out, Option_t* = """"); Save the pattern select widget as a C++ statement(s) on output stream out. Style_t GetPattern() const; { return fPattern; }. TGedPatternSelect(const TGWindow* p, Style_t pattern, Int_t id). virtual ~TGedPatternSelect(); {}. TGDimension GetDefaultSize() const; { return TGDimension(55, 21); }. void PatternSelected(Style_t pattern = 0); { Emit(""PatternSelected(Style_t)"", pattern ? pattern : GetPattern()); }. » Author: Marek Biskup, Ilka Antcheva 24/07/03 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGedPatternSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGedPatternSelect.html
Availability,down,down,". TGedPatternSelector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPatternSelector. class TGedPatternSelector: public TGCompositeFrame. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. virtual~TGedPatternSelector(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); vir",MatchSource.WIKI,root/html602/TGedPatternSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGedPatternSelector.html
Integrability,message,message,"RedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedPatternSelector(const TGWindow* p); Create pattern popup window. ~TGedPatternSelector(); Delete pattern popup window. void SetActive(Int_t newat); Set selected the current style. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process message generated by pattern popup window. TGedPatternSelector(const TGWindow* p). Int_t GetActive() const; { return fActive; }. » Author: Marek Biskup, Ilka Antcheva 24/07/03 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGedPatternSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGedPatternSelector.html
Availability,down,down,". TGedPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPopup. class TGedPopup: public TGCompositeFrame. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. virtual~TGedPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* ",MatchSource.WIKI,root/html602/TGedPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGedPopup.html
Integrability,message,messages,"ame x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedPopup(const TGWindow* p, const TGWindow* m, UInt_t w, UInt_t h, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); Create a popup frame. void EndPopup(); Ungrab pointer and unmap popup window. void PlacePopup(Int_t x, Int_t y, UInt_t w, UInt_t h); Place popup window at the specified place. Bool_t HandleButton(Event_t* event); Handle mouse button event in popup window. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by popup window. TGedPopup(const TGWindow* p, const TGWindow* m, UInt_t w, UInt_t h, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); { }. » Author: Marek Biskup, Ilka Antcheva 24/07/03 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGedPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGedPopup.html
Availability,down,down,". TGedSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedSelect. class TGedSelect: public TGCheckButton. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. virtual~TGedSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; virtual TObject*TObject::Clone(const char* n",MatchSource.WIKI,root/html602/TGedSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGedSelect.html
Deployability,release,released,ateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled.,MatchSource.WIKI,root/html602/TGedSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGedSelect.html
Energy Efficiency,allocate,allocate,"s; public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t); static TGenCollectionProxy::(anonymous)kBIT_ISSTRING; static TGenCollectionProxy::(anonymous)kBIT_ISTSTRING; static TGenCollectionProxy::(anonymous)kBOOL_t; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsAssociative; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsEmulated; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kNeedDelete. protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::Collectfunc_tfCollectMethod to collect objects from container; TGenCollectionProxy::ArrIterfunc_tfConstructContainer accessors: block construct; map<string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; TGenCollectionProxy::Sizing_tfDestructContainer accessors: block destruct; TGenCollectionProxy::EnvironBase_t*fEnvAddress of the currently proxied object; TGenCollectionProxy::Feedfunc_tfFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; TVirtualCollectionProxy::CopyIterator_tfFunctionCopyIterator; TVirtualCollectionProxy::CreateIterators_tfFunctionCreateIterators; TVirtualCollectionProxy::DeleteIterator_tfFunctionDeleteIterator; TVirtualCollectionProxy::DeleteTwoIterators_tfFunctionDeleteTwoIterators; TVirtualCollectionProxy::Next_tfFunctionNextIterator; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperti",MatchSource.WIKI,root/html602/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGenCollectionProxy.html
Performance,cache,cache,"itialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent); virtual voidUpdateValueClass(const TClass* oldcl, TClass* newcl). private:. TGenCollectionProxy&operator=(const TGenCollectionProxy&); TGenCollectionProxy(). Data Members; public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t); static TGenCollectionProxy::(anonymous)kBIT_ISSTRING; static TGenCollectionProxy::(anonymous)kBIT_ISTSTRING; static TGenCollectionProxy::(anonymous)kBOOL_t; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsAssociative; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsEmulated; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kNeedDelete. protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::Collectfunc_tfCollectMethod to collect objects from container; TGenCollectionProxy::ArrIterfunc_tfConstructContainer accessors: block construct; map<string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; TGenCollectionProxy::Sizing_tfDestructContainer accessors: block destruct; TGenCollectionProxy::EnvironBase_t*fEnvAddress of the currently proxied object; TGenCollectionProxy::Feedfunc_tfFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; TVirtualCollectionProxy::CopyIterator_tfFunctionCopyIterator; TVirtualCollectionProxy::CreateIterators_tfFunctionCreateIterators; TVirtualCollectionProxy::DeleteIterator_tfFunctionDeleteIterator; TVirtualCollectionProxy::DeleteTwoIterators_tfFunctionDeleteTwoIterators; TVirtualCollectionProxy::Next_tfFunctionNextIterator; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameNam",MatchSource.WIKI,root/html602/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGenCollectionProxy.html
Security,access,access,". TGenCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy. class TGenCollectionProxy: public TVirtualCollectionProxy. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. virtual~TGenCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void* env); virtual voidTVirtualCollectionProxy::DeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; virtual voidTVirtualCollectionProxy::Destructor(void* p, Bool_t dtorOnly = kFALSE) const; virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass() const; virtual Int_tGetCollectionType() const; virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncrement() const; virtual TClass*GetOnFileClass() const; virtual Int_tTVirtualCollectionProxy::GetProperties() const; virtual TStreamerInfoActions::TActio",MatchSource.WIKI,root/html602/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGenCollectionProxy.html
Usability,clear,clear,". TGenCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy. class TGenCollectionProxy: public TVirtualCollectionProxy. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. virtual~TGenCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void* env); virtual voidTVirtualCollectionProxy::DeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; virtual voidTVirtualCollectionProxy::Destructor(void* p, Bool_t dtorOnly = kFALSE) const; virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass() const; virtual Int_tGetCollectionType() const; virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncrement() const; virtual TClass*GetOnFileClass() const; virtual Int_tTVirtualCollectionProxy::GetProperties() const; virtual TStreamerInfoActions::TActio",MatchSource.WIKI,root/html602/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGenCollectionProxy.html
Security,access,access,". TGenCollectionProxy::Method. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy::Method. class TGenCollectionProxy::Method. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Method(); void*invoke(void* obj) const; TGenCollectionProxy::MethodMethod(); TGenCollectionProxy::MethodMethod(TGenCollectionProxy::Method::Call_t c); TGenCollectionProxy::MethodMethod(const TGenCollectionProxy::Method& m); TGenCollectionProxy::Method&operator=(const TGenCollectionProxy::Method& m). Data Members; public:. TGenCollectionProxy::Method::Call_tcall. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Method(); { }. Method(Call_t c); { }. Method(const Method& m); { }. Method & operator=(const TGenCollectionProxy::Method& m); { call = m.call; return *this; }. void* invoke(void* obj) const; { return (*call)(obj); }. » Author: Markus Frank 28/10/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-06-30 14:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGenCollectionProxy__Method.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGenCollectionProxy__Method.html
Usability,clear,clear,". TGenCollectionProxy::Method. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy::Method. class TGenCollectionProxy::Method. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Method(); void*invoke(void* obj) const; TGenCollectionProxy::MethodMethod(); TGenCollectionProxy::MethodMethod(TGenCollectionProxy::Method::Call_t c); TGenCollectionProxy::MethodMethod(const TGenCollectionProxy::Method& m); TGenCollectionProxy::Method&operator=(const TGenCollectionProxy::Method& m). Data Members; public:. TGenCollectionProxy::Method::Call_tcall. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Method(); { }. Method(Call_t c); { }. Method(const Method& m); { }. Method & operator=(const TGenCollectionProxy::Method& m); { call = m.call; return *this; }. void* invoke(void* obj) const; { return (*call)(obj); }. » Author: Markus Frank 28/10/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-06-30 14:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGenCollectionProxy__Method.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGenCollectionProxy__Method.html
Performance,cache,cache," container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Value(); voidDeleteItem(void* ptr); Bool_tIsValid(); TGenCollectionProxy::Value&operator=(const TGenCollectionProxy::Value&); TGenCollectionProxy::Value&operator=(TGenCollectionProxy::Value&&); TGenCollectionProxy::ValueValue(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(TGenCollectionProxy::Value&&); TGenCollectionProxy::ValueValue(const string& info, Bool_t silent). Data Members; public:. UInt_tfCasetype of data of Value_type; ROOT::NewFunc_tfCtorMethod cache for containee constructor; ROOT::DelFunc_tfDeleteMethod cache for containee delete; ROOT::DesFunc_tfDtorMethod cache for containee destructor; EDataTypefKindkind of ROOT-fundamental type; UInt_tfPropertiesAdditional properties of the value type (kNeedDelete); size_tfSizefSize of the contained object; TClassReffTypeTClass reference of Value_type in collection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Value(const string& info, Bool_t silent); Constructor. Bool_t IsValid(); Return true if the Value has been properly initialized. void DeleteItem(void* ptr); Delete an item. Value(const string& info, Bool_t silent); Default copy constructor has the correct implementation.; Initializing constructor. Method & operator=(const Method& m); { call = m.call; return *this; }. Method0 & operator=(const Method0& m); { call = m.call; return *this; }. » Author: Markus Frank 28/10/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-06-30 14:59; This page has been automatically generated. For comments or suggestions regarding the docu",MatchSource.WIKI,root/html602/TGenCollectionProxy__Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGenCollectionProxy__Value.html
Security,access,access,". TGenCollectionProxy::Value. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy::Value. class TGenCollectionProxy::Value. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Value(); voidDeleteItem(void* ptr); Bool_tIsValid(); TGenCollectionProxy::Value&operator=(const TGenCollectionProxy::Value&); TGenCollectionProxy::Value&operator=(TGenCollectionProxy::Value&&); TGenCollectionProxy::ValueValue(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(TGenCollectionProxy::Value&&); TGenCollectionProxy::ValueValue(const string& info, Bool_t silent). Data Members; public:. UInt_tfCasetype of data of Value_type; ROOT::NewFunc_tfCtorMethod cache for containee constructor; ROOT::DelFunc_tfDeleteMethod cache for containee delete; ROOT::DesFunc_tfDtorMethod cache for containee destructor; EDataTypefKindkind of ROOT-fundamental type; UInt_tfPropertiesAdditional properties of the value type (kNeedDelete); size_tfSizefSize of the contained object; TClassReffTypeTClass reference of Value_type in collection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Value(const string& info, Bool_t silent); Constructor. Bool_t IsValid(); Return true if the Value has been properly initialized. void DeleteItem(void* ptr); Delete an item. Value(const string& info, Bool_t silent); Default copy constructor has the correct implementation.; Initializing constructor. Method & operator=(const Met",MatchSource.WIKI,root/html602/TGenCollectionProxy__Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGenCollectionProxy__Value.html
Usability,clear,clear,". TGenCollectionProxy::Value. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy::Value. class TGenCollectionProxy::Value. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Value(); voidDeleteItem(void* ptr); Bool_tIsValid(); TGenCollectionProxy::Value&operator=(const TGenCollectionProxy::Value&); TGenCollectionProxy::Value&operator=(TGenCollectionProxy::Value&&); TGenCollectionProxy::ValueValue(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(TGenCollectionProxy::Value&&); TGenCollectionProxy::ValueValue(const string& info, Bool_t silent). Data Members; public:. UInt_tfCasetype of data of Value_type; ROOT::NewFunc_tfCtorMethod cache for containee constructor; ROOT::DelFunc_tfDeleteMethod cache for containee delete; ROOT::DesFunc_tfDtorMethod cache for containee destructor; EDataTypefKindkind of ROOT-fundamental type; UInt_tfPropertiesAdditional properties of the value type (kNeedDelete); size_tfSizefSize of the contained object; TClassReffTypeTClass reference of Value_type in collection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Value(const string& info, Bool_t silent); Constructor. Bool_t IsValid(); Return true if the Value has been properly initialized. void DeleteItem(void* ptr); Delete an item. Value(const string& info, Bool_t silent); Default copy constructor has the correct implementation.; Initializing constructor. Method & operator=(const Met",MatchSource.WIKI,root/html602/TGenCollectionProxy__Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGenCollectionProxy__Value.html
Availability,error,error,,MatchSource.WIKI,root/html602/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGenerator.html
Integrability,interface,interface,". TGenerator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » EG; » TGenerator. class TGenerator: public TNamed. TGenerator. Is an base class, that defines the interface of ROOT to various; event generators. Every event generator should inherit from; TGenerator or its subclasses. Derived class can overload the member function GenerateEvent; to do the actual event generation (e.g., call PYEVNT or similar). The derived class should overload the member function; ImportParticles (both types) to read the internal storage of the; generated event into either the internal TObjArray or the passed; TClonesArray of TParticles. If the generator code stores event data in the /HEPEVT/ common block; Then the default implementation of ImportParticles should suffice.; The common block /HEPEVT/ is structed like. C; typedef struct {; Int_t nevhep; // Event number; Int_t nhep; // # of particles; Int_t isthep[4000]; // Status flag of i'th particle; Int_t idhep[4000]; // PDG # of particle; Int_t jmohep[4000][2]; // 1st & 2nd mother particle #; Int_t jdahep[4000][2]; // 1st & 2nd daughter particle #; Double_t phep[4000][5]; // 4-momentum and 1 word; Double_t vhep[4000][4]; // 4-position of production; } HEPEVT_DEF;. C Fortran; COMMON/HEPEVT/NEVHEP,NHEP,ISTHEP(4000),IDHEP(4000),; + JMOHEP(2,4000),JDAHEP(2,4000),PHEP(5,4000),VHEP(4,4000); INTEGER NEVHEP,NHEP,ISTHEP,IDHEP,JMOHEP,JDAHEP; DOUBLE PRECISION PHEP,VHEP. The generic member functions SetParameter and GetParameter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance) fgI",MatchSource.WIKI,root/html602/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGenerator.html
Modifiability,inherit,inherit,". TGenerator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » EG; » TGenerator. class TGenerator: public TNamed. TGenerator. Is an base class, that defines the interface of ROOT to various; event generators. Every event generator should inherit from; TGenerator or its subclasses. Derived class can overload the member function GenerateEvent; to do the actual event generation (e.g., call PYEVNT or similar). The derived class should overload the member function; ImportParticles (both types) to read the internal storage of the; generated event into either the internal TObjArray or the passed; TClonesArray of TParticles. If the generator code stores event data in the /HEPEVT/ common block; Then the default implementation of ImportParticles should suffice.; The common block /HEPEVT/ is structed like. C; typedef struct {; Int_t nevhep; // Event number; Int_t nhep; // # of particles; Int_t isthep[4000]; // Status flag of i'th particle; Int_t idhep[4000]; // PDG # of particle; Int_t jmohep[4000][2]; // 1st & 2nd mother particle #; Int_t jdahep[4000][2]; // 1st & 2nd daughter particle #; Double_t phep[4000][5]; // 4-momentum and 1 word; Double_t vhep[4000][4]; // 4-position of production; } HEPEVT_DEF;. C Fortran; COMMON/HEPEVT/NEVHEP,NHEP,ISTHEP(4000),IDHEP(4000),; + JMOHEP(2,4000),JDAHEP(2,4000),PHEP(5,4000),VHEP(4,4000); INTEGER NEVHEP,NHEP,ISTHEP,IDHEP,JMOHEP,JDAHEP; DOUBLE PRECISION PHEP,VHEP. The generic member functions SetParameter and GetParameter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance) fgI",MatchSource.WIKI,root/html602/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGenerator.html
Performance,load,loaded,"meter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance) fgInstance = new MyGenerator;; return fgInstance;; }; void GenerateEvent() { ... }; void ImportParticles(TClonesArray* a, Option_t opt="""") {...}; Int_t ImportParticles(Option_t opt="""") { ... }; Int_t SetParameter(const char* name, Double_t val) { ... }; Double_t GetParameter(const char* name) { ... }; virtual ~MyGenerator() { ... }; protected:; MyGenerator() { ... }; MyGenerator(const MyGenerator& o) { ... }; MyGenerator& operator=(const MyGenerator& o) { ... }; static MyGenerator* fgInstance;; ClassDef(MyGenerator,0);; };. Having multiple objects accessing the same common blocks is not; safe. concrete TGenerator classes can be loaded in scripts and subseqent-; ly used in compiled code:. MyRun.h; class MyRun : public TObject; {; public:; static MyRun* Instance() { ... }; void SetGenerator(TGenerator* g) { fGenerator = g; }; void Run(Int_t n, Option_t* option=""""); {; TFile* file = TFile::Open(""file.root"",""RECREATE"");; TTree* tree = new TTree(""T"",""T"");; TClonesArray* p = new TClonesArray(""TParticles"");; tree->Branch(""particles"", &p);; for (Int_t event = 0; event < n; event++) {; fGenerator->GenerateEvent();; fGenerator->ImportParticles(p,option);; tree->Fill();; }; file->Write();; file->Close();; }. protected:; TGenerator* fGenerator;; ClassDef(MyRun,0);; };. Config.C; void Config(); {; MyRun* run = MyRun::Instance();; run->SetGenerator(MyGenerator::Instance());; }. main.cxx; int; main(int argc, char** argv); {; TApplication app("""", 0, 0);; gSystem->ProcessLine("".x Config.C"");; MyRun::Instance()->Run(10);; return 0;; }. This is especially useful for example with TVirtualMC or similar. Function Members (Methods); public:. v",MatchSource.WIKI,root/html602/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGenerator.html
Safety,safe,safe,"P; DOUBLE PRECISION PHEP,VHEP. The generic member functions SetParameter and GetParameter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance) fgInstance = new MyGenerator;; return fgInstance;; }; void GenerateEvent() { ... }; void ImportParticles(TClonesArray* a, Option_t opt="""") {...}; Int_t ImportParticles(Option_t opt="""") { ... }; Int_t SetParameter(const char* name, Double_t val) { ... }; Double_t GetParameter(const char* name) { ... }; virtual ~MyGenerator() { ... }; protected:; MyGenerator() { ... }; MyGenerator(const MyGenerator& o) { ... }; MyGenerator& operator=(const MyGenerator& o) { ... }; static MyGenerator* fgInstance;; ClassDef(MyGenerator,0);; };. Having multiple objects accessing the same common blocks is not; safe. concrete TGenerator classes can be loaded in scripts and subseqent-; ly used in compiled code:. MyRun.h; class MyRun : public TObject; {; public:; static MyRun* Instance() { ... }; void SetGenerator(TGenerator* g) { fGenerator = g; }; void Run(Int_t n, Option_t* option=""""); {; TFile* file = TFile::Open(""file.root"",""RECREATE"");; TTree* tree = new TTree(""T"",""T"");; TClonesArray* p = new TClonesArray(""TParticles"");; tree->Branch(""particles"", &p);; for (Int_t event = 0; event < n; event++) {; fGenerator->GenerateEvent();; fGenerator->ImportParticles(p,option);; tree->Fill();; }; file->Write();; file->Close();; }. protected:; TGenerator* fGenerator;; ClassDef(MyRun,0);; };. Config.C; void Config(); {; MyRun* run = MyRun::Instance();; run->SetGenerator(MyGenerator::Instance());; }. main.cxx; int; main(int argc, char** argv); {; TApplication app("""", 0, 0);; gSystem->ProcessLine("".x Config.C"");; MyRun::Instance()->Run(10);; return 0;; }. This is especially us",MatchSource.WIKI,root/html602/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGenerator.html
Security,access,accessing,"P; DOUBLE PRECISION PHEP,VHEP. The generic member functions SetParameter and GetParameter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance) fgInstance = new MyGenerator;; return fgInstance;; }; void GenerateEvent() { ... }; void ImportParticles(TClonesArray* a, Option_t opt="""") {...}; Int_t ImportParticles(Option_t opt="""") { ... }; Int_t SetParameter(const char* name, Double_t val) { ... }; Double_t GetParameter(const char* name) { ... }; virtual ~MyGenerator() { ... }; protected:; MyGenerator() { ... }; MyGenerator(const MyGenerator& o) { ... }; MyGenerator& operator=(const MyGenerator& o) { ... }; static MyGenerator* fgInstance;; ClassDef(MyGenerator,0);; };. Having multiple objects accessing the same common blocks is not; safe. concrete TGenerator classes can be loaded in scripts and subseqent-; ly used in compiled code:. MyRun.h; class MyRun : public TObject; {; public:; static MyRun* Instance() { ... }; void SetGenerator(TGenerator* g) { fGenerator = g; }; void Run(Int_t n, Option_t* option=""""); {; TFile* file = TFile::Open(""file.root"",""RECREATE"");; TTree* tree = new TTree(""T"",""T"");; TClonesArray* p = new TClonesArray(""TParticles"");; tree->Branch(""particles"", &p);; for (Int_t event = 0; event < n; event++) {; fGenerator->GenerateEvent();; fGenerator->ImportParticles(p,option);; tree->Fill();; }; file->Write();; file->Close();; }. protected:; TGenerator* fGenerator;; ClassDef(MyRun,0);; };. Config.C; void Config(); {; MyRun* run = MyRun::Instance();; run->SetGenerator(MyGenerator::Instance());; }. main.cxx; int; main(int argc, char** argv); {; TApplication app("""", 0, 0);; gSystem->ProcessLine("".x Config.C"");; MyRun::Instance()->Run(10);; return 0;; }. This is especially us",MatchSource.WIKI,root/html602/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGenerator.html
Availability,error,error,"ed) const; Int_tTTable::CopyRows(const TTable* srcTable, Long_t srcRow = 0, Long_t dstRow = 0, Long_t nRows = 0, Bool_t expand = kFALSE); virtual voidTTable::CopySet(TTable& array); virtual voidTTable::DeleteRows(Long_t indx, UInt_t nRows = 1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTable::Draw(Option_t* opt); virtual TH1*TTable::Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*TTable::Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TGenericTable::iteratorend(); TGenericTable::iteratorend() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidTTable::Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; void*TTable::GetArray",MatchSource.WIKI,root/html602/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGenericTable.html
Energy Efficiency,allocate,allocated,"t::(anonymous)TObject::kZombie. protected:. TTableDescriptor*fColDescriptors; TSeqCollection*TDataSet::fListList of the the the objects included into this dataset; Long_tTTable::fMaxIndexThe used capacity of this array; Int_tTTable::fNNumber of array elements; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; Long_tTTable::fSizeSize of the one element (row) of the table; Char_t*TTable::fTableArray of (fN*fSize) longs; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenericTable(const TTableDescriptor& dsc, const char* name). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object. TGenericTable(const TTableDescriptor& dsc, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - ""TGenericTable""; n - The initial number of allocated rows. TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor",MatchSource.WIKI,root/html602/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGenericTable.html
Modifiability,variab,variable,"the generic table for 1000 rows (it may grow then); ! TGenericTable *allStaff = new TGenericTable(""staff_t"",""Staff-data"",1000);; !; ! // Fill the memory resident table; ! while (fgets(&line,80,fp)) {; ! sscanf(&line[0] ,""%d%d%d%d"", &staff.cat,&staff.division,&staff.flag,&staff.age);; ! sscanf(&line[13],""%d%d%d%d"", &staff.service,&staff.children,&staff.grade,&staff.step);; ! sscanf(&line[24],""%d%d%d"", &staff.nation,&staff.hrweek,&staff.cost);; ! allStaff->AddAt(&staff);; ! }; ! fclose(fp);; ! // Delete unused space;; ! allStaff->Purge();; !; ! allStaff->Print(0,10);; !; !// Create ROOT file; ! TFile *f = new TFile(""aptuple.root"",""RECREATE"");; ! allStaff->Write();; ! f->Write();; !; ! // We should close TFile otherwise all histograms we create below; ! // may be written to the file too occasionaly; ! f->Close();; !; !// Create ROOT Browser; ! new TBrowser(""staff"",allStaff);; !; !// Create couple of the histograms; ! TCanvas *canva = new TCanvas(""Staff"",""CERN Population"",600,600);; ! canva->Divide(1,2);; !; !; !// one can use 2 meta variable:; !// n$ - the total number of the rows in the table; !// i$ - stands for the current row index i = [0 -> (n$-1)]; !; ! gStyle->SetHistFillColor(10);; ! gStyle->SetHistFillStyle(3013);; ! canva->cd(1);; ! allStaff->Draw(""age"");; ! canva->Update();; ! canva->cd(2);; ! allStaff->Draw(""cost"");; ! canva->Update();; !}. Function Members (Methods); public:. virtual~TGenericTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDataSet::Add(TDataSet* dataset); virtual Int_tTTable::AddAt(const void* c); virtual voidTTable::AddAt(const void* c, Int_t i); virtual voidTTable::AddAt(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddAtAndExpand(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual voidTTable::Adopt(Int_t n, void* array); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long_tTTable::AppendRows(c",MatchSource.WIKI,root/html602/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGenericTable.html
Testability,assert,assert,"ber of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. iterator & operator=(const TGenericTable& ); { fRowSize = iter.fRowSize; fCurrentRow = iter.fCurrentRow; return *this;}. TGenericTable(); {SetType(""generic"");}. TGenericTable(const char* structName, const char* name); Create TGenericTable by C structure name provided. char * GetTable(Int_t i = 0) const; { return ((char *)GetArray())+i*GetRowSize();}. TTableDescriptor * GetTableDescriptors() const; { return GetDescriptorPointer();}. TTableDescriptor * GetRowDescriptors() const; { return GetDescriptorPointer();}. char & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const char & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const char *)(GetTable(i))); }. iterator begin(); { return ((const TGenericTable *)this)->begin();}. iterator begin() const; { return GetNRows() ? iterator(*this, *GetTable(0)):end();}. iterator end(); { return ((const TGenericTable *)this)->end(); }. iterator end() const; {Long_t i = GetNRows(); return i? iterator(*this, *GetTable(i)):iterator(*this);}. » Last changed: root/table:$Id$ » Last generated: 2015-06-30 15:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGenericTable.html
Modifiability,variab,variable,"the generic table for 1000 rows (it may grow then); ! TGenericTable *allStaff = new TGenericTable(""staff_t"",""Staff-data"",1000);; !; ! // Fill the memory resident table; ! while (fgets(&line,80,fp)) {; ! sscanf(&line[0] ,""%d%d%d%d"", &staff.cat,&staff.division,&staff.flag,&staff.age);; ! sscanf(&line[13],""%d%d%d%d"", &staff.service,&staff.children,&staff.grade,&staff.step);; ! sscanf(&line[24],""%d%d%d"", &staff.nation,&staff.hrweek,&staff.cost);; ! allStaff->AddAt(&staff);; ! }; ! fclose(fp);; ! // Delete unused space;; ! allStaff->Purge();; !; ! allStaff->Print(0,10);; !; !// Create ROOT file; ! TFile *f = new TFile(""aptuple.root"",""RECREATE"");; ! allStaff->Write();; ! f->Write();; !; ! // We should close TFile otherwise all histograms we create below; ! // may be written to the file too occasionaly; ! f->Close();; !; !// Create ROOT Browser; ! new TBrowser(""staff"",allStaff);; !; !// Create couple of the histograms; ! TCanvas *canva = new TCanvas(""Staff"",""CERN Population"",600,600);; ! canva->Divide(1,2);; !; !; !// one can use 2 meta variable:; !// n$ - the total number of the rows in the table; !// i$ - stands for the current row index i = [0 -> (n$-1)]; !; ! gStyle->SetHistFillColor(10);; ! gStyle->SetHistFillStyle(3013);; ! canva->cd(1);; ! allStaff->Draw(""age"");; ! canva->Update();; ! canva->cd(2);; ! allStaff->Draw(""cost"");; ! canva->Update();; !}. Function Members (Methods); public:. ~iterator(); TGenericTable::iteratoriterator(const TTable& t); TGenericTable::iteratoriterator(const TGenericTable::iterator& iter); TGenericTable::iteratoriterator(UInt_t size, char& rowPtr); TGenericTable::iteratoriterator(const TTable& t, char& rowPtr); Bool_toperator!=(const TGenericTable::iterator& t) const; char*operator*(); TGenericTable::iterator&operator+(Int_t idx); TGenericTable::iterator&operator++(); voidoperator++(int); TGenericTable::iterator&operator-(Int_t idx); Int_toperator-(const TGenericTable::iterator& it) const; TGenericTable::iterator&operator--(); voidoperator-",MatchSource.WIKI,root/html602/TGenericTable__iterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGenericTable__iterator.html
Availability,error,error," virtual~TGenPhaseSpace(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fata",MatchSource.WIKI,root/html602/TGenPhaseSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGenPhaseSpace.html
Energy Efficiency,energy,energy,". TGenPhaseSpace. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TGenPhaseSpace. class TGenPhaseSpace: public TObject. Utility class to generate n-body event,; with constant cross-section (default); or with Fermi energy dependence (opt=""Fermi"").; The event is generated in the center-of-mass frame,; but the decay products are finally boosted; using the betas of the original particle. The code is based on the GENBOD function (W515 from CERNLIB); using the Raubold and Lynch method; F. James, Monte Carlo Phase Space, CERN 68-15 (1968). see example of use in $ROOTSYS/tutorials/physics/PhaseSpace.C. Note that Momentum, Energy units are Gev/C, GeV. Function Members (Methods); public:. virtual~TGenPhaseSpace(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fata",MatchSource.WIKI,root/html602/TGenPhaseSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGenPhaseSpace.html
Integrability,depend,dependence,". TGenPhaseSpace. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TGenPhaseSpace. class TGenPhaseSpace: public TObject. Utility class to generate n-body event,; with constant cross-section (default); or with Fermi energy dependence (opt=""Fermi"").; The event is generated in the center-of-mass frame,; but the decay products are finally boosted; using the betas of the original particle. The code is based on the GENBOD function (W515 from CERNLIB); using the Raubold and Lynch method; F. James, Monte Carlo Phase Space, CERN 68-15 (1968). see example of use in $ROOTSYS/tutorials/physics/PhaseSpace.C. Note that Momentum, Energy units are Gev/C, GeV. Function Members (Methods); public:. virtual~TGenPhaseSpace(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fata",MatchSource.WIKI,root/html602/TGenPhaseSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGenPhaseSpace.html
Availability,error,error,"act = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tGetClosestEdge(const Double_t* point, Double_t* vert, Int_t& isegment) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDz() ",MatchSource.WIKI,root/html602/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoArb8.html
Safety,safe,safe,"dData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); voidComputeTwist(); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; vi",MatchSource.WIKI,root/html602/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoArb8.html
Testability,test,testNo," virtual~TGeoArb8(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TO",MatchSource.WIKI,root/html602/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoArb8.html
Performance,optimiz,optimization,"bilityAttkVisStreamed; static TGeoAtt::EGeoVisibilityAttkVisThis; static TGeoAtt::EGeoVisibilityAttkVisTouched. protected:. UInt_tfGeoAttoption flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoAtt(); Default constructor. TGeoAtt(Option_t* vis_opt, Option_t* activity_opt = """", Option_t* optimization_opt = """"); Constructor. ~TGeoAtt(); Destructor. void SetVisBranch(); Set branch type visibility. void SetVisContainers(Bool_t flag = kTRUE); Set branch type visibility. void SetVisLeaves(Bool_t flag = kTRUE); Set branch type visibility. void SetVisOnly(Bool_t flag = kTRUE); Set branch type visibility. void SetVisibility(Bool_t vis = kTRUE); Set visibility for this object. void SetVisDaughters(Bool_t vis = kTRUE); Set visibility for the daughters. void SetVisStreamed(Bool_t vis = kTRUE); Mark attributes as ""streamed to file"". void SetVisTouched(Bool_t vis = kTRUE); Mark visualization attributes as ""modified"". void SetOptimization(Option_t* option); Set optimization flags. TGeoAtt(); constructors. void SetAttBit(UInt_t f); methods. {fGeoAtt |= f & kBitMask;}. void SetAttBit(UInt_t f, Bool_t set); {(set)?SetAttBit(f):ResetAttBit(f);}. void ResetAttBit(UInt_t f); {fGeoAtt &= ~(f & kBitMask);}. Bool_t TestAttBit(UInt_t f) const; {return (Bool_t)((fGeoAtt & f) != 0);}. void SetVisRaytrace(Bool_t flag = kTRUE); {SetAttBit(kVisRaytrace, flag);}. void SetActivity(Bool_t flag = kTRUE); {SetAttBit(kActThis, flag);}. void SetActiveDaughters(Bool_t flag = kTRUE); {SetAttBit(kActDaughters,flag);}. Bool_t IsActive() const; {return TestAttBit(kActThis);}. Bool_t IsActiveDaughters() const; {return TestAttBit(kActDaughters);}. Bool_t IsVisRaytrace() const; {return TestAttBit(kVisRaytrace);}. Bool_t IsVisible() const; {return TestAttBit(kVisThis);}. Bool_t IsVisDaughters() const; {return TestAttBit(kVisDaughters);}. Bool_t IsVisBranch() const; {return TestAttBit(kVisBranch);}. Bool_t IsVisContainers() const; {return TestAttBit(kVisContain",MatchSource.WIKI,root/html602/TGeoAtt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoAtt.html
Availability,error,error,"rtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tConcentration(Double_t time) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindSolution(const TObjArray* array); voidGetCoeff(Int_t i, Double_t& cn, Double_t& lambda) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoElementRN*GetElement() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMark",MatchSource.WIKI,root/html602/TGeoBatemanSol.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoBatemanSol.html
Availability,error,error,"_tDistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tGetDX() const; virtual Double_tGetDY() const; virtual Double_tGetDZ() const; virtual Double_tGetFacetArea(Int_t index = 0) const; virtual Int_tGetFittingBox(const TGeoBBox* parambox, TGeoM",MatchSource.WIKI,root/html602/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoBBox.html
Modifiability,inherit,inherit,". TGeoBBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoBBox. class TGeoBBox: public TGeoShape. TGeoBBox - box class. All shape primitives inherit from this, their; constructor filling automatically the parameters of the box that bounds; the given shape. Defined by 6 parameters :; fDX, fDY, fDZ - half lengths on X, Y and Z axis; fOrigin[3] - position of box origin. --- Building boxes. Normally a box has to be build only with 3 parameters : dx, dy, dz; representing the half lengths on X, Y and Z axis. In this case, the origin; of the box will match the one of its reference frame. The translation of the; origin is used only by the constructors of all other shapes in order to; define their own bounding boxes. Users should be aware that building a; translated box that will represent a physical shape by itself will affect any; further positioning of other shapes inside. Therefore in order to build a; positioned box one should follow the recipe described in class TGeoNode. Creation of boxes; 1. TGeoBBox *box = new TGeoBBox(""BOX"", 20, 30, 40);. /*. */. 2. A volume having a box shape can be built in one step:; TGeoVolume *vbox = gGeoManager->MakeBox(""vbox"", ptrMed, 20,30,40);. Divisions of boxes. Volumes having box shape can be divided with equal-length slices on; X, Y or Z axis. The following options are supported:; a) Dividing the full range of one axis in N slices; TGeoVolume *divx = vbox->Divide(""SLICEX"", 1, N);; - here 1 stands for the division axis (1-X, 2-Y, 3-Z). /*. */. b) Dividing in a limited range - general case.; TGeoVolume *divy = vbox->Divide(""SLICEY"",2,N,start,step);; - start = starting offset within (-fDY, fDY); - step = slicing step. /*. */. Both cases are supported by all shapes.; See also class TGeoShape for utility methods provided by any particular; shape. Function ",MatchSource.WIKI,root/html602/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoBBox.html
Safety,safe,safe,") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; static Bool_tContains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* vo",MatchSource.WIKI,root/html602/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoBBox.html
Testability,test,testNo,,MatchSource.WIKI,root/html602/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoBBox.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoBBoxEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoBBoxEditor.html
Usability,undo,undoing,"dows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBBoxEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoBBoxEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Update editor for a new selected box. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifying current parameters. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for Dx modification. void DoDy(); Slot for Dy modification. void DoDz(); Slot for Dz modification. void DoOx(); Slot for Ox modification. void DoOy(); Slot for Oy modification. void DoOz(); Slot for Oz modification. TGeoBBoxEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoBBoxEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoBBoxEditor.html
Availability,avail,available,"n operations between two shapes. A Boolean node describes a Boolean operation between 'left' and 'right'; shapes positioned with respect to an ARBITRARY reference frame. The boolean; node is referenced by a mother composite shape and its shape components may; be primitive but also composite shapes. The later situation leads to a binary; tree hierarchy. When the parent composite shape is used to create a volume,; the reference frame of the volume is chosen to match the frame in which; node shape components were defined. The positioned shape components may or may not be disjoint. The specific; implementations for Boolean nodes are:. TGeoUnion - representing the Boolean union of two positioned shapes. TGeoSubtraction - representing the Boolean subtraction of two positioned; shapes. TGeoIntersection - representing the Boolean intersection of two positioned; shapes. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoBoolNode(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; voidCreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(c",MatchSource.WIKI,root/html602/TGeoBoolNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoBoolNode.html
Safety,safe,safe,"od(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; voidCreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject",MatchSource.WIKI,root/html602/TGeoBoolNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoBoolNode.html
Availability,error,error,"onst; voidAddLevel(Int_t dindex); virtual voidTObject::AppendPad(Option_t* option = """"); static Long64_tBinarySearch(Long64_t n, const TGeoBranchArray** array, TGeoBranchArray* value); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanMatrix(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGeoNode**GetArray() const; TObject*GetClient() const; TGeoNode*GetCurrentNode() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLevel() const; TGeoHMatrix*GetMatrix() const; virtual const char*TObject::GetName() const; TGeoNode*GetNode(Int_t level) const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidGetPath(TString& path) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Boo",MatchSource.WIKI,root/html602/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoBranchArray.html
Deployability,update,updated,". TGeoBranchArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoBranchArray. class TGeoBranchArray: public TObject. TGeoBranchArray - An array of daughter indices making a geometry path.; Can be used to backup/restore a state. To setup an object of this type,; one should use:; TGeoBranchArray *array = new TGeoBranchArray(level);; array->InitFromNavigator(nav); (To initialize from current navigator state); The navigator can be updated to reflect this path array:; array->UpdateNavigator();. Function Members (Methods); public:. virtual~TGeoBranchArray(); voidTObject::AbstractMethod(const char* method) const; voidAddLevel(Int_t dindex); virtual voidTObject::AppendPad(Option_t* option = """"); static Long64_tBinarySearch(Long64_t n, const TGeoBranchArray** array, TGeoBranchArray* value); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanMatrix(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* meth",MatchSource.WIKI,root/html602/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoBranchArray.html
Performance,perform,performed,":EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TGeoNode**fArray![fMaxLevel] Array of nodes; TObject*fClientClient object to notify; Int_tfLevelBranch depth; TGeoHMatrix*fMatrixGlobal matrix (owned); Int_tfMaxLevelArray length. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBranchArray(Int_t level); Constructor. Alocates the array with a size given by level. ~TGeoBranchArray(); Destructor. TGeoBranchArray(const TGeoBranchArray& ); Copy constructor. TGeoBranchArray& operator=(const TGeoBranchArray& ); Assignment. void AddLevel(Int_t dindex); Add and extra daughter to the current path array. No validity check performed !. Long64_t BinarySearch(Long64_t n, const TGeoBranchArray** array, TGeoBranchArray* value); Binary search in an array of n pointers to branch arrays, to locate value.; Returns element index or index of nearest element smaller than value. Int_t Compare(const TObject* obj) const; Compare with other object of same type. Returns -1 if this is smaller (first; smaller array value prevails), 0 if equal (size and values) and 1 if this is; larger. void CleanMatrix(); Garbage collect the stored matrix. void Init(TGeoNode** branch, TGeoMatrix* global, Int_t level); Init the branch array from an array of nodes, the global matrix for the path and; the level. void InitFromNavigator(TGeoNavigator* nav); Init the branch array from current navigator state. void GetPath(TString& path) const; Fill path pointed by the array. void Print(Option_t* option = """") const; Print branch information. void Sort(Int_t n, TGeoBranchArray** array, Int_t* index, Bool_t down = kTRUE); Sorting of an array of",MatchSource.WIKI,root/html602/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoBranchArray.html
Availability,error,error,"ject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); TGeoVolume*Division(const char* name, const char* mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html602/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoBuilder.html
Deployability,continuous,continuous,"Double_t dens, Int_t nelem, Float_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY fl",MatchSource.WIKI,root/html602/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoBuilder.html
Energy Efficiency,energy,energy,"erial * Mixture(const char* name, Float_t* a, Float_t* z, Double_t dens, Int_t nelem, Float_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation ",MatchSource.WIKI,root/html602/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoBuilder.html
Integrability,rout,rout,"TGeoMedium* medium, Double_t dx, Double_t dy, Double_t dz); TGeoVolume*MakeCone(const char* name, TGeoMedium* medium, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); TGeoVolume*MakeCons(const char* name, TGeoMedium* medium, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); TGeoVolume*MakeCtub(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); TGeoVolume*MakeEltu(const char* name, TGeoMedium* medium, Double_t a, Double_t b, Double_t dz); TGeoVolume*MakeGtra(const char* name, TGeoMedium* medium, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoVolume*MakeHype(const char* name, TGeoMedium* medium, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoVolume*MakePara(const char* name, TGeoMedium* medium, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); TGeoVolume*MakeParaboloid(const char* name, TGeoMedium* medium, Double_t rlo, Double_t rhi, Double_t dz); TGeoVolume*MakePcon(const char* name, TGeoMedium* medium, Double_t phi, Double_t dphi, Int_t nz); TGeoVolume*MakePgon(const char* name, TGeoMedium* medium, Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); TGeoVolume*MakeSphere(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t themin = 0, Double_t themax = 180, Double_t phimin = 0, Double_t phimax = 360); TGeoVolume*MakeTorus(const char* name, TGeoMedium* medium, Double_t r, Double_t rmin, Double_t rmax, Double_t phi1 = 0, Double_t dphi = 360); TGeoVolume*MakeTrap(const char* name, TGeoMedium* medium, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, ",MatchSource.WIKI,root/html602/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoBuilder.html
Performance,perform,performed," defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY flag. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Do",MatchSource.WIKI,root/html602/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoBuilder.html
Availability,error,error," virtual~TGeoCacheState(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const;",MatchSource.WIKI,root/html602/TGeoCacheState.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoCacheState.html
Availability,error,error," = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Double_tCheckVoxels(TGeoVolume* vol, TGeoVoxelFinder* voxels, Double_t* xyz, Int_t npoints); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html602/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoChecker.html
Deployability,update,updated,"ate to boundary. Compute normal and safety at crossing point, plot; the point and generate a random direction so that (dir) dot (norm) <0. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RandomPoints(TGeoVolume* vol, Int_t npoints, Option_t* option); Draw random points in the bounding box of a volume. void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz, const char* target_vol = 0, Bool_t check_norm = kFALSE); Randomly shoot nrays from point (startx,starty,startz) and plot intersections; with surfaces for current top node. TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path); shoot npoints randomly in a box of 1E-5 arround current point.; return minimum distance to points outside; make sure that path to current node is updated; get the response of tgeo. Double_t * ShootRay(Double_t* start, Double_t dirx, Double_t diry, Double_t dirz, Double_t* array, Int_t& nelem, Int_t& dim, Double_t* enpoint = 0) const; Shoot one ray from start point with direction (dirx,diry,dirz). Fills input array; with points just after boundary crossings.; Int_t array_dimension = 3*dim;. void Test(Int_t npoints, Option_t* option); Check time of finding ""Where am I"" for n points. void TestOverlaps(const char* path); --- Geometry overlap checker based on sampling. Double_t Weight(Double_t precision = 0.01, Option_t* option = ""v""); Estimate weight of top level volume with a precision SIGMA(W)/W; better than PRECISION. Option can be ""v"" - verbose (default). Double_t CheckVoxels(TGeoVolume* vol, TGeoVoxelFinder* voxels, Double_t* xyz, Int_t npoints); count voxel timing. Bool_t TestVoxels(TGeoVolume* vol, Int_t npoints = 1000000); Returns optimal voxelization type for volume vol.; kFALSE - cartesian; kTRUE -",MatchSource.WIKI,root/html602/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoChecker.html
Performance,perform,performed,". TGeoChecker. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMPAINTER; » TGeoChecker. class TGeoChecker: public TObject. TGeoChecker - Geometry checking package. TGeoChecker class provides several geometry checking methods. There are two; types of tests that can be performed. One is based on random sampling or; ray-tracing and provides a visual check on how navigation methods work for; a given geometry. The second actually checks the validity of the geometry; definition in terms of overlapping/extruding objects. Both types of checks; can be done for a given branch (starting with a given volume) as well as for; the geometry as a whole. 1. TGeoChecker::CheckPoint(Double_t x, Double_t y, Double_t z). This method can be called direcly from the TGeoManager class and print a; report on how a given point is classified by the modeller: which is the; full path to the deepest node containing it, and the (under)estimation; of the distance to the closest boundary (safety). 2. TGeoChecker::RandomPoints(Int_t npoints). Can be called from TGeoVolume class. It first draws the volume and its; content with the current visualization settings. Then randomly samples points; in its bounding box, plotting in the geometry display only the points; classified as belonging to visible volumes. 3. TGeoChecker::RandomRays(Int_t nrays, Double_t startx, starty, startz). Can be called and acts in the same way as the previous, but instead of points,; rays having random isotropic directions are generated from the given point.; A raytracing algorithm propagates all rays untill they exit geometry, plotting; all segments crossing visible nodes in the same color as these. 4. TGeoChecker::Test(Int_t npoints). Implementation of TGeoManager::Test(). Computes the time for the modeller; to find out ""Where am I?"" for a given number of",MatchSource.WIKI,root/html602/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoChecker.html
Safety,safe,safety," Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMPAINTER; » TGeoChecker. class TGeoChecker: public TObject. TGeoChecker - Geometry checking package. TGeoChecker class provides several geometry checking methods. There are two; types of tests that can be performed. One is based on random sampling or; ray-tracing and provides a visual check on how navigation methods work for; a given geometry. The second actually checks the validity of the geometry; definition in terms of overlapping/extruding objects. Both types of checks; can be done for a given branch (starting with a given volume) as well as for; the geometry as a whole. 1. TGeoChecker::CheckPoint(Double_t x, Double_t y, Double_t z). This method can be called direcly from the TGeoManager class and print a; report on how a given point is classified by the modeller: which is the; full path to the deepest node containing it, and the (under)estimation; of the distance to the closest boundary (safety). 2. TGeoChecker::RandomPoints(Int_t npoints). Can be called from TGeoVolume class. It first draws the volume and its; content with the current visualization settings. Then randomly samples points; in its bounding box, plotting in the geometry display only the points; classified as belonging to visible volumes. 3. TGeoChecker::RandomRays(Int_t nrays, Double_t startx, starty, startz). Can be called and acts in the same way as the previous, but instead of points,; rays having random isotropic directions are generated from the given point.; A raytracing algorithm propagates all rays untill they exit geometry, plotting; all segments crossing visible nodes in the same color as these. 4. TGeoChecker::Test(Int_t npoints). Implementation of TGeoManager::Test(). Computes the time for the modeller; to find out ""Where am I?"" for a given number of random points. 5. T",MatchSource.WIKI,root/html602/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoChecker.html
Testability,test,tests,". TGeoChecker. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMPAINTER; » TGeoChecker. class TGeoChecker: public TObject. TGeoChecker - Geometry checking package. TGeoChecker class provides several geometry checking methods. There are two; types of tests that can be performed. One is based on random sampling or; ray-tracing and provides a visual check on how navigation methods work for; a given geometry. The second actually checks the validity of the geometry; definition in terms of overlapping/extruding objects. Both types of checks; can be done for a given branch (starting with a given volume) as well as for; the geometry as a whole. 1. TGeoChecker::CheckPoint(Double_t x, Double_t y, Double_t z). This method can be called direcly from the TGeoManager class and print a; report on how a given point is classified by the modeller: which is the; full path to the deepest node containing it, and the (under)estimation; of the distance to the closest boundary (safety). 2. TGeoChecker::RandomPoints(Int_t npoints). Can be called from TGeoVolume class. It first draws the volume and its; content with the current visualization settings. Then randomly samples points; in its bounding box, plotting in the geometry display only the points; classified as belonging to visible volumes. 3. TGeoChecker::RandomRays(Int_t nrays, Double_t startx, starty, startz). Can be called and acts in the same way as the previous, but instead of points,; rays having random isotropic directions are generated from the given point.; A raytracing algorithm propagates all rays untill they exit geometry, plotting; all segments crossing visible nodes in the same color as these. 4. TGeoChecker::Test(Int_t npoints). Implementation of TGeoManager::Test(). Computes the time for the modeller; to find out ""Where am I?"" for a given number of",MatchSource.WIKI,root/html602/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoChecker.html
Availability,error,error,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. virtual~TGeoCombiTrans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Cl",MatchSource.WIKI,root/html602/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoCombiTrans.html
Integrability,interface,interface," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html602/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoCombiTrans.html
Modifiability,variab,variable,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. virtual~TGeoCombiTrans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const cha",MatchSource.WIKI,root/html602/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoCombiTrans.html
Performance,optimiz,optimize,". TGeoCombiTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoCombiTrans. class TGeoCombiTrans: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Sc",MatchSource.WIKI,root/html602/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoCombiTrans.html
Usability,simpl,simple,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html602/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoCombiTrans.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoCombiTransEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoCombiTransEditor.html
Usability,undo,undoing,"ame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoCombiTransEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for combi matrix editor. ~TGeoCombiTransEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected combi matrix. void DoName(); Slot for name. void DoRotPhi(); Slot for phi (Euler X convention). void DoRotTheta(); Slot for theta (Euler X convention). void DoRotPsi(); Slot for psi (Euler X convention). void DoRotAngle(); Slot for additional rotation about one axis. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying modifications. void DoCancel(); Slot for cancelling last un-applied operations. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last changes. void DoDx(); Slot for X. void DoDy(); Slot for Y. void DoDz(); Slot for Z. TGeoCombiTransEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoCombiTransEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoCombiTransEditor.html
Availability,down,down,"eader file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoCompositeShape. class TGeoCompositeShape: public TGeoBBox. TGeoCompositeShape - class handling Boolean composition of shapes. Composite shapes are Boolean combination of two or more shape; components. The supported boolean operations are union (+), intersection (*); and subtraction. Composite shapes derive from the base TGeoShape class,; therefore providing all shape features : computation of bounding box, finding; if a given point is inside or outside the combination, as well as computing the; distance to entering/exiting. It can be directly used for creating volumes or; used in the definition of other composite shapes.; Composite shapes are provided in order to complement and extend the set of; basic shape primitives. They have a binary tree internal structure, therefore; all shape-related geometry queries are signals propagated from top level down; to the final leaves, while the provided answers are assembled and interpreted; back at top. This CSG hierarchy is effective for small number of components,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are no; longer composite shapes, but basic primitives. /*. */. Suppose that A, B, C and D represent bas",MatchSource.WIKI,root/html602/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoCompositeShape.html
Integrability,interface,interface,"mponents,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are no; longer composite shapes, but basic primitives. /*. */. Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do this; only for the sake of understanding how to create them in a proper way, since; the user interface for this purpose is in fact very simple. We will ignore; for the time being the positioning of components. The definition of a composite; shape takes an expression where the identifiers are shape names. The; expression is parsed and decomposed in 2 sub-expressions and the top-level; Boolean operator. 1. A+B+C; This represent the union of A, B and C. Both union operators are at the; same level. Since:; A+B+C = (A+B)+C = A+(B+C); the first (+) is taken as separator, hence the expression split:; A and B+C; A Boolean node of type TGeoUnion(""A"", ""B+C"") is created. This tries to replace; the 2 expressions by actual pointers to corresponding shapes.; The first expression (A) contains no operators therefore is interpreted as; representing a shape. The shape named ""A"" is searched into the list of shapes; handled by the manager class and stored as the ""left"" shape in the Boolean; union node. Since the second expression is not yet fully decomposed, the ""right""; ",MatchSource.WIKI,root/html602/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoCompositeShape.html
Modifiability,extend,extend,". TGeoCompositeShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoCompositeShape. class TGeoCompositeShape: public TGeoBBox. TGeoCompositeShape - class handling Boolean composition of shapes. Composite shapes are Boolean combination of two or more shape; components. The supported boolean operations are union (+), intersection (*); and subtraction. Composite shapes derive from the base TGeoShape class,; therefore providing all shape features : computation of bounding box, finding; if a given point is inside or outside the combination, as well as computing the; distance to entering/exiting. It can be directly used for creating volumes or; used in the definition of other composite shapes.; Composite shapes are provided in order to complement and extend the set of; basic shape primitives. They have a binary tree internal structure, therefore; all shape-related geometry queries are signals propagated from top level down; to the final leaves, while the provided answers are assembled and interpreted; back at top. This CSG hierarchy is effective for small number of components,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are n",MatchSource.WIKI,root/html602/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoCompositeShape.html
Performance,perform,performance,"lass TGeoCompositeShape: public TGeoBBox. TGeoCompositeShape - class handling Boolean composition of shapes. Composite shapes are Boolean combination of two or more shape; components. The supported boolean operations are union (+), intersection (*); and subtraction. Composite shapes derive from the base TGeoShape class,; therefore providing all shape features : computation of bounding box, finding; if a given point is inside or outside the combination, as well as computing the; distance to entering/exiting. It can be directly used for creating volumes or; used in the definition of other composite shapes.; Composite shapes are provided in order to complement and extend the set of; basic shape primitives. They have a binary tree internal structure, therefore; all shape-related geometry queries are signals propagated from top level down; to the final leaves, while the provided answers are assembled and interpreted; back at top. This CSG hierarchy is effective for small number of components,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are no; longer composite shapes, but basic primitives. /*. */. Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do this; only for the sake of understanding how to create them in a proper way",MatchSource.WIKI,root/html602/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoCompositeShape.html
Safety,safe,safe,"on = """"); virtual voidClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidCreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject",MatchSource.WIKI,root/html602/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoCompositeShape.html
Testability,test,testNo,,MatchSource.WIKI,root/html602/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoCompositeShape.html
Usability,simpl,simple,"mponents,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are no; longer composite shapes, but basic primitives. /*. */. Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do this; only for the sake of understanding how to create them in a proper way, since; the user interface for this purpose is in fact very simple. We will ignore; for the time being the positioning of components. The definition of a composite; shape takes an expression where the identifiers are shape names. The; expression is parsed and decomposed in 2 sub-expressions and the top-level; Boolean operator. 1. A+B+C; This represent the union of A, B and C. Both union operators are at the; same level. Since:; A+B+C = (A+B)+C = A+(B+C); the first (+) is taken as separator, hence the expression split:; A and B+C; A Boolean node of type TGeoUnion(""A"", ""B+C"") is created. This tries to replace; the 2 expressions by actual pointers to corresponding shapes.; The first expression (A) contains no operators therefore is interpreted as; representing a shape. The shape named ""A"" is searched into the list of shapes; handled by the manager class and stored as the ""left"" shape in the Boolean; union node. Since the second expression is not yet fully decomposed, the ""right""; ",MatchSource.WIKI,root/html602/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoCompositeShape.html
Availability,error,error,"st; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); static voidDistToCone(const Double_t* point, const Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index",MatchSource.WIKI,root/html602/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoCone.html
Safety,safe,safe,"virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); static voidDistToCone(const Double_t* point, const Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_",MatchSource.WIKI,root/html602/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoCone.html
Testability,test,testNo," virtual~TGeoCone(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::",MatchSource.WIKI,root/html602/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoCone.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoConeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoConeEditor.html
Usability,undo,undoing," Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoConeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoConeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifing current parameters. void DoUndo(); Slot for undoing current operation. void DoRmin1(); Slot for Rmin1. void DoRmax1(); Slot for Rmax1. void DoRmin2(); Slot for Rmin2. void DoRmax2(); Slot for Rmax2. void DoDz(); Slot for Dz. TGeoConeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoConeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoConeEditor.html
Availability,error,error,"c voidTGeoCone::DistToCone(const Double_t* point, const Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tDistToCons(const Double_t* point, const Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoCone::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoCone::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetF",MatchSource.WIKI,root/html602/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoConeSeg.html
Safety,safe,safe,":ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static voidTGeoCone::DistToCone(const Double_t* point, const Double_t* dir, Dou",MatchSource.WIKI,root/html602/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoConeSeg.html
Testability,test,testNo," virtual~TGeoConeSeg(); voidTObject::AbstractMethod(const char* method) const; virtual voidAfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v",MatchSource.WIKI,root/html602/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoConeSeg.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoConeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoConeSegEditor.html
Usability,undo,undoing," Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoConeSegEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for cone segment editor. ~TGeoConeSegEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoPhi1(); Slot for Phi1. void DoPhi2(); Slot for Phi2. void DoPhi(); Slot for Phi. void DoApply(); Slot for applying current parameters. void DoUndo(); Slot for undoing last operation. TGeoConeSegEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoConeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoConeSegEditor.html
Availability,error,error,"e_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoTubeSeg::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tT",MatchSource.WIKI,root/html602/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoCtub.html
Safety,safe,safe,"eoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidTGeoTubeSeg::ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoTubeSeg::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTubeSeg::DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTubeSeg::DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2,",MatchSource.WIKI,root/html602/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoCtub.html
Testability,test,testNo," virtual~TGeoCtub(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoTubeSeg::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNorma",MatchSource.WIKI,root/html602/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoCtub.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoCtubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoCtubEditor.html
Usability,undo,undoing," width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoCtubEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for cut tube editor. ~TGeoCtubEditor(); Destructor. void SetModel(TObject* obj); Connect to the selected object. void DoThlo(); Slot for phi1. void DoPhlo(); Slot for phi1. void DoThhi(); Slot for phi1. void DoPhhi(); Slot for phi1. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. TGeoCtubEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoCtubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoCtubEditor.html
Availability,error,error,"nst; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; TGeoElementRN*Daughter() const; UInt_tDecay() const; static voidDecayName(UInt_t decay, TString& name); virtual voidDecayShift(Int_t& dA, Int_t& dZ, Int_t& dI) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeltaIso() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetIndex() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* ",MatchSource.WIKI,root/html602/TGeoDecayChannel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoDecayChannel.html
Availability,error,error,"bstractMethod(const char* method) const; voidAddIsotope(TGeoIsotope* isotope, Double_t relativeAbundance); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Int_tENDFCode() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static TGeoElementTable*GetElementTable(); virtual const char*TObject::GetIconName() const; TGeoIsotope*GetIsotope(Int_t i) const; virtual const char*TNamed::GetName() const; Int_tGetNisotopes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetRelativeAbundance(Int_t i) const; virtual Double_tGetSpecificActivity() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::G",MatchSource.WIKI,root/html602/TGeoElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoElement.html
Availability,error,error,"cayChannel - a decay channel for a radionuclide; TGeoElementTable - table of elements. Function Members (Methods); public:. virtual~TGeoElementRN(); Double_tTGeoElement::A() const; voidTObject::AbstractMethod(const char* method) const; voidAddDecay(TGeoDecayChannel* dc); voidAddDecay(Int_t decay, Int_t diso, Double_t branchingRatio, Double_t qValue); voidTGeoElement::AddIsotope(TGeoIsotope* isotope, Double_t relativeAbundance); voidAddRatio(TGeoBatemanSol& ratio); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tAtomicNo() const; virtual voidTObject::Browse(TBrowser* b); Bool_tCheckDecays() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tDecayResult(TGeoDecayChannel* dc) const; TObjArray*Decays() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Int_tENDF(Int_t a, Int_t z, Int_t iso); virtual Int_tENDFCode() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); voidFillPopulation(TObjArray* population, Double_t precision = 0.001, Double_t factor = 1.); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObjec",MatchSource.WIKI,root/html602/TGeoElementRN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoElementRN.html
Availability,error,error,"le_t a); voidAddElementRN(TGeoElementRN* elem); voidAddIsotope(TGeoIsotope* isotope); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildDefaultElements(); Bool_tCheckTable() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExportElementsRN(const char* filename = """"); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGeoElement*FindElement(const char* name) const; TGeoIsotope*FindIsotope(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoElement*GetElement(Int_t z); TGeoElementRN*GetElementRN(Int_t ENDFcode) const; TGeoElementRN*GetElementRN(Int_t a, Int_t z, Int_t iso = 0) const; TObjArray*GetElementsRN() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNelements() const; Int_tGetNelementsRN() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_",MatchSource.WIKI,root/html602/TGeoElementTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoElementTable.html
Performance,optimiz,optimized," TGeoElementTable& ); assignment operator. ~TGeoElementTable(); destructor. void AddElement(const char* name, const char* title, Int_t z, Double_t a); Add an element to the table. Obsolete. void AddElement(const char* name, const char* title, Int_t z, Int_t n, Double_t a); Add an element to the table. void AddElement(TGeoElement* elem); Add a custom element to the table. void AddElementRN(TGeoElementRN* elem); Add a radionuclide to the table and map it. void AddIsotope(TGeoIsotope* isotope); Add isotope to the table. void BuildDefaultElements(); Creates the default element table. void ImportElementsRN(); Creates the list of radionuclides. Bool_t CheckTable() const; Checks status of element table. void ExportElementsRN(const char* filename = """"); Export radionuclides in a file. TGeoElement * FindElement(const char* name) const; Search an element by symbol or full name; Exact matching. TGeoIsotope * FindIsotope(const char* name) const; Find existing isotope by name. Not optimized for a big number of isotopes. TGeoElementRN * GetElementRN(Int_t ENDFcode) const; Retreive a radionuclide by ENDF code. TGeoElementRN * GetElementRN(Int_t a, Int_t z, Int_t iso = 0) const; Retreive a radionuclide by a, z, and isomeric state. void Print(Option_t* option = """") const; Print table of elements. The accepted options are:; """" - prints everything by default; ""D"" - prints default elements only; ""I"" - prints isotopes; ""R"" - prints radio-nuclides only if imported; ""U"" - prints user-defined elements only. TGeoElementRN * GetElement(); {return fElem;}. TObjArray * GetElementsRN() const; {return fListRN;}. Bool_t HasDefaultElements() const; {return TObject::TestBit(kETDefaultElements);}. Bool_t HasRNElements() const; {return TObject::TestBit(kETRNElements);}. Int_t GetNelements() const; {return fNelements;}. Int_t GetNelementsRN() const; {return fNelementsRN;}. » Author: Andrei Gheata 17/06/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Las",MatchSource.WIKI,root/html602/TGeoElementTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoElementTable.html
Availability,down,down,"o(Double_t limit); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGeoElemIter(const TGeoElemIter& iter); TGeoElemIter(TGeoElementRN* top, Double_t limit = 1.0E-4). protected:. TGeoElementRN*Down(Int_t ibranch); TGeoElemIter(); TGeoElementRN*Up(). Data Members; private:. TObjArray*fBranchCurrent branch; const TGeoElementRN*fElemCurrent element; Int_tfLevelCurrent level; Double_tfLimitRatioMinimum cumulative branching ratio; Double_tfRatioCurrent ratio; const TGeoElementRN*fTopTop element of the iteration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoElemIter(TGeoElementRN* top, Double_t limit = 1.0E-4); Default constructor. TGeoElemIter(const TGeoElemIter& iter); Copy ctor. ~TGeoElemIter(); Destructor. TGeoElemIter & operator=(const TGeoElemIter& iter); Assignment. TGeoElementRN * operator()(); () operator. TGeoElementRN * Up(); Go upwards from the current location until the next branching, then down. TGeoElementRN * Down(Int_t ibranch); Go downwards from current level via ibranch as low in the tree as possible.; Return value flags if the operation was successful. TGeoElementRN * Next(); Return next element. void Print(Option_t* option = """") const; Print info about the current decay branch. TGeoElementRN * GetElement() const; {return fElem;}. TGeoElemIter(); {}. TObjArray * GetBranch() const; {return fBranch;}. const TGeoElementRN * GetTop() const; {return fTop;}. Int_t GetLevel() const; {return fLevel;}. Double_t GetRatio() const; {return fRatio;}. void SetLimitRatio(Double_t limit); {fLimitRatio = limit;}. » Author: Andrei Gheata 17/06/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-06-30 15:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoElemIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoElemIter.html
Availability,error,error,", Int_t vecsize, Double_t* step) const; static Double_tTGeoTube::DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGetA() const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoTube::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual Double_tGetB() const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoTube::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz(",MatchSource.WIKI,root/html602/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoEltu.html
Safety,safe,safe,"st TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidTGeoTube::ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTube::DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTube::DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual ",MatchSource.WIKI,root/html602/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoEltu.html
Testability,test,testNo," virtual~TGeoEltu(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidTGeoTube::ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual vo",MatchSource.WIKI,root/html602/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoEltu.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoEltuEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoEltuEditor.html
Usability,undo,undoing,"signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoEltuEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoEltuEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoName(); Slot for name. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoA(); Slot for A. void DoB(); Slot for B. void DoDz(); Slot for Z. TGeoEltuEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoEltuEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoEltuEditor.html
Availability,avail,available,". TGeoExtension. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoExtension. class TGeoExtension: public TObject. TGeoExtension - ABC for user objects attached to TGeoVolume or TGeoNode.; Provides interface for getting a reference (grab) and; releasing the extension object (release), allowing for; derived classes to implement reference counted sharing.; The user who should attach extensions to logical volumes; or nodes BEFORE applying misalignment information so that; these will be available to all copies. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* ",MatchSource.WIKI,root/html602/TGeoExtension.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoExtension.html
Deployability,release,release,". TGeoExtension. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoExtension. class TGeoExtension: public TObject. TGeoExtension - ABC for user objects attached to TGeoVolume or TGeoNode.; Provides interface for getting a reference (grab) and; releasing the extension object (release), allowing for; derived classes to implement reference counted sharing.; The user who should attach extensions to logical volumes; or nodes BEFORE applying misalignment information so that; these will be available to all copies. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* ",MatchSource.WIKI,root/html602/TGeoExtension.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoExtension.html
Integrability,interface,interface,". TGeoExtension. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoExtension. class TGeoExtension: public TObject. TGeoExtension - ABC for user objects attached to TGeoVolume or TGeoNode.; Provides interface for getting a reference (grab) and; releasing the extension object (release), allowing for; derived classes to implement reference counted sharing.; The user who should attach extensions to logical volumes; or nodes BEFORE applying misalignment information so that; these will be available to all copies. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* ",MatchSource.WIKI,root/html602/TGeoExtension.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoExtension.html
Testability,log,logical,". TGeoExtension. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoExtension. class TGeoExtension: public TObject. TGeoExtension - ABC for user objects attached to TGeoVolume or TGeoNode.; Provides interface for getting a reference (grab) and; releasing the extension object (release), allowing for; derived classes to implement reference counted sharing.; The user who should attach extensions to logical volumes; or nodes BEFORE applying misalignment information so that; these will be available to all copies. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* ",MatchSource.WIKI,root/html602/TGeoExtension.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoExtension.html
Availability,avail,available,". TGeoGedFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMBUILDER; » TGeoGedFrame. class TGeoGedFrame: public TGedFrame. TGeoGedFrame. Common base class for geombuilder editors. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoGedFrame(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, ",MatchSource.WIKI,root/html602/TGeoGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoGedFrame.html
Availability,error,error,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. virtual~TGeoGenTrans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Clas",MatchSource.WIKI,root/html602/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoGenTrans.html
Integrability,interface,interface," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html602/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoGenTrans.html
Modifiability,variab,variable,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. virtual~TGeoGenTrans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char*",MatchSource.WIKI,root/html602/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoGenTrans.html
Performance,optimiz,optimize,". TGeoGenTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoGenTrans. class TGeoGenTrans: public TGeoCombiTrans. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scal",MatchSource.WIKI,root/html602/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoGenTrans.html
Usability,simpl,simple,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html602/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoGenTrans.html
Availability,error,error," virtual~TGeoGlobalMagField(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::Exe",MatchSource.WIKI,root/html602/TGeoGlobalMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoGlobalMagField.html
Security,access,access,". TGeoGlobalMagField. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoGlobalMagField. class TGeoGlobalMagField: public TObject. TGeoGlobalMagField - Global magnetic field manager. Provides access to; and owns the actual magnetic field set via SetField(). The field is deleted; upon destruction of the field manager at the end of ROOT session or; by calling: TGeoGlobalMagField::Instance()->SetField(0). The previous; global field is deleted upon replacement with notification. The global field manager provides access to the global field via:; TGeoGlobalMagField::Instance()->GetField(); One can directly call the Field() method of a field via the global field manager:. TGeoGlobalMagField::Instance()->Field(x,B). Function Members (Methods); public:. virtual~TGeoGlobalMagField(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::Exe",MatchSource.WIKI,root/html602/TGeoGlobalMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoGlobalMagField.html
Availability,error,error,"ep = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tTGeoTrap::GetAlpha1() const; Double_tTGeoTrap::GetAlpha2() const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoArb8::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Double_tTGeoTrap::GetBl1() const; Double_tTGeoTrap::GetBl2() const; virtual voidTGeoArb8::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoArb8::GetByteCount() const; Double_tTGeoArb8::GetClosestEdge(const Double_t* point, Double_t* vert, Int_t& isegment) const; vi",MatchSource.WIKI,root/html602/TGeoGtra.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoGtra.html
Safety,safe,safe,"name = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidTGeoArb8::ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(const Double_t* point) const; virtual voidTGeoArb8::Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option ",MatchSource.WIKI,root/html602/TGeoGtra.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoGtra.html
Testability,test,testNo," virtual~TGeoGtra(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tTGeoArb8::Capacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compar",MatchSource.WIKI,root/html602/TGeoGtra.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoGtra.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoGtraEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoGtraEditor.html
Usability,undo,undoing,"; TGTextButton*TGeoTrapEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGtraEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for gtra editor. ~TGeoGtraEditor(); Destructor. void SetModel(TObject* obj); Connect to a given twisted trapezoid. void DoApply(); Slot for applying current settings. void DoUndo(); Slot for undoing last operation. void DoTwist(); Change the twist angle. TGeoGtraEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoGtraEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoGtraEditor.html
Availability,error,error,"p) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t*) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t in",MatchSource.WIKI,root/html602/TGeoHalfSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoHalfSpace.html
Safety,safe,safe,"tual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject",MatchSource.WIKI,root/html602/TGeoHalfSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoHalfSpace.html
Testability,test,testNo," virtual~TGeoHalfSpace(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; vi",MatchSource.WIKI,root/html602/TGeoHalfSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoHalfSpace.html
Availability,error,error,"9999999999999995E-7) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::Distance",MatchSource.WIKI,root/html602/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoHelix.html
Deployability,update,update,"RUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape boundary. Double_t StepToPlane(Double_t* point, Double_t* norm); Propagate initial point up to a given Z position in MARS. void UpdateHelix(); Update the local helix matrix. TGeoHelix(const TGeoHelix& ). TGeoHelix & operator=(const TGeoHelix& ). const Double_t * GetCurrentPoint() const; {return fPoint;}. const Double_t * GetCurrentDirection() const; {return fDir;}. Double_t GetXYcurvature() const; {return fC;}. Double_t GetStep() const; {return fStep;}. Bool_t IsRightHanded() const; {return (fQ>0)?kFALSE:kTRUE;}. » Author: Andrei Gheata 28/04/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » La",MatchSource.WIKI,root/html602/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoHelix.html
Energy Efficiency,charge,charged,". TGeoHelix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoHelix. class TGeoHelix: public TObject. TGeoHelix - class representing a helix curve. A helix is a curve defined by the following equations:; x = (1/c) * COS(q*phi); y = (1/c) * SIN(q*phi); z = s * alfa; where:; c = 1/Rxy - curvature in XY plane; phi - phi angle; S = 2*PI*s - vertical separation between helix loops; q = +/- 1 - (+)=left-handed, (-)=right-handed. In particular, a helix describes the trajectory of a charged particle in magnetic; field. In such case, the helix is right-handed for negative particle charge.; To define a helix, one must define:; - the curvature - positive defined; - the Z step made after one full turn of the helix; - the particle charge sign; - the initial particle position and direction (force normalization to unit); - the magnetic field direction. A helix provides:; - propagation to a given Z position (in global frame); Double_t *point = TGeoHelix::PropagateToZ(Double_t z);; - propagation to an arbitrary plane, returning also the new point; - propagation in a geometry until the next crossed surface; - computation of the total track length along a helix. Function Members (Methods); public:. virtual~TGeoHelix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tComputeSafeStep(Double_t epsil = 9.9999999999999995E-7) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::Distance",MatchSource.WIKI,root/html602/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoHelix.html
Safety,safe,safe,"vas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Double_tfB[3]normalized direction for magnetic field; Double_tfCcurvature in XY plane; Double_tfDir[3]direction after a step; Double_tfDirInit[3]normalized initial direction; TGeoHMatrix*fMatrixtransformation of local helix frame to MARS; Double_tfPhiphi angle; Double_tfPoint[3]point after a step; Double_tfPointInit[3]initial point; Int_tfQright/left-handed (+/- 1) - ""charge""; Double_tfSZ step of the helix / 2*PI; Double_tfStepcurrent step. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHelix(); Dummy constructor. TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); Normal constructor. ~TGeoHelix(); Destructor. Double_t ComputeSafeStep(Double_t epsil = 9.9999999999999995E-7) const; Compute safe linear step that can be made such that the error; between linear-helix extrapolation is less than EPSIL. void InitPoint(Double_t x0, Double_t y0, Double_t z0); Initialize coordinates of a point on the helix. void InitPoint(Double_t* point); Set initial point on the helix. void InitDirection(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or nul",MatchSource.WIKI,root/html602/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoHelix.html
Availability,error,error,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. virtual~TGeoHMatrix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class",MatchSource.WIKI,root/html602/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoHMatrix.html
Integrability,interface,interface," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html602/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoHMatrix.html
Modifiability,variab,variable,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. virtual~TGeoHMatrix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidCopyFrom(const TGeoMatrix* other); virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeterminant() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, ",MatchSource.WIKI,root/html602/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoHMatrix.html
Performance,optimiz,optimize,". TGeoHMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoHMatrix. class TGeoHMatrix: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inve",MatchSource.WIKI,root/html602/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoHMatrix.html
Usability,simpl,simple,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html602/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoHMatrix.html
Availability,error,error,"const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Int_tDistToHype(const Double_t* point, const Double_t* dir, Double_t* s, Bool_t inner, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetF",MatchSource.WIKI,root/html602/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoHype.html
Integrability,rout,rout,". TGeoHype. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoHype. class TGeoHype: public TGeoTube. TGeoHype - Hyperboloid class defined by 5 parameters. Bounded by:; - Two z planes at z=+/-dz; - Inner and outer lateral surfaces. These represent the surfaces; described by the revolution of 2 hyperbolas about the Z axis:; r^2 - (t*z)^2 = a^2. r = distance between hyperbola and Z axis at coordinate z; t = tangent of the stereo angle (angle made by hyperbola; asimptotic lines and Z axis). t=0 means cylindrical surface.; a = distance between hyperbola and Z axis at z=0. The inner hyperbolic surface is described by:; r^2 - (tin*z)^2 = rin^2; - absence of the inner surface (filled hyperboloid can be forced; by rin=0 and sin=0; The outer hyperbolic surface is described by:; r^2 - (tout*z)^2 = rout^2; TGeoHype parameters: dz[cm], rin[cm], sin[deg], rout[cm], sout[deg].; MANDATORY conditions:; - rin < rout; - rout > 0; - rin^2 + (tin*dz)^2 > rout^2 + (tout*dz)^2; SUPPORTED CASES:; - rin = 0, tin != 0 => inner surface conical; - tin=0 AND/OR tout=0 => corresponding surface(s) cyllindrical; e.g. tin=0 AND tout=0 => shape becomes a tube with: rmin,rmax,dz. Function Members (Methods); public:. virtual~TGeoHype(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"",MatchSource.WIKI,root/html602/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoHype.html
Safety,safe,safe,"st TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidTGeoTube::ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTube::DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTube::DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Int_tDistToHype(const Double_t* point, const Double_t* dir, Double_t* s, Bool_t inner, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistTo",MatchSource.WIKI,root/html602/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoHype.html
Testability,test,testNo," virtual~TGeoHype(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"",MatchSource.WIKI,root/html602/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoHype.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoHypeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoHypeEditor.html
Usability,undo,undoing,"e::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHypeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for Hype editor. ~TGeoHypeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoRin(); Slot for Rin. void DoRout(); Slot for Rout. void DoDz(); Slot for Z. void DoStIn(); Slot for StIn. void DoStOut(); Slot for StOut. TGeoHypeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoHypeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoHypeEditor.html
Availability,error,error,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. virtual~TGeoIdentity(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Clas",MatchSource.WIKI,root/html602/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoIdentity.html
Integrability,interface,interface," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html602/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoIdentity.html
Modifiability,variab,variable,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. virtual~TGeoIdentity(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(con",MatchSource.WIKI,root/html602/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoIdentity.html
Performance,optimiz,optimize,". TGeoIdentity. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoIdentity. class TGeoIdentity: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: I",MatchSource.WIKI,root/html602/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoIdentity.html
Usability,simpl,simple,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html602/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoIdentity.html
Availability,error,error,"const Double_t* dir, Double_t* norm); virtual Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; voidTGeoBoolNode::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*TGeoBoolNode::GetRightMatrix() const; TGeoShape*TGeoBoolNode::GetRightShape() const; TGeoBoolNode::ThreadData_t&TGeoBool",MatchSource.WIKI,root/html602/TGeoIntersection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoIntersection.html
Safety,safe,safe,"; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoBoolNode::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; voidTGeoBoolNode::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject",MatchSource.WIKI,root/html602/TGeoIntersection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoIntersection.html
Availability,error,error," virtual~TGeoIsotope(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static TGeoIsotope*FindIsotope(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetA() const; virtual Option_t*",MatchSource.WIKI,root/html602/TGeoIsotope.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoIsotope.html
Modifiability,plugin,plugin,"t_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::AddNodeOverlap(same arguments);. When closing the geometry, overlapping nodes perform a check of possible; overlaps with their neighbours. These are stored and checked all the time; during navigation, therefore navigation is slower when embedding such nodes; into geometry. Node have visualization attributes as volume have. When undefined by users,; painting a node on a pad will take the corresponding volume attributes. /*. */. Function Members (Methods); public:. virtual~TGeoIterator(); static TClass*Class(); const TGeoMatrix*GetCurrentMatrix() const; Int_tGetIndex(Int_t i) const; Int_tGetLevel() const; TGeoNode*GetNode(Int_t level) const; voidGetPath(TString& path) const; TGeoVolume*GetTopVolume() const; Int_tGetType() const; TGeoIteratorPlugin*GetUserPlugin() const; virtual TClass*IsA() const; TGeoNode*Next(); TGeoNode*operator()(); TGeoIterator&operator=(const TGeoIterator& iter); voidReset(TGeoVolume* top = 0); voidSetPluginAutoexec(Bool_t mode); voidSetTopName(const char* name); voidSetType(Int_t type); voidSetUserPlugin(TGeoIteratorPlugin* plugin); virtual voidShowMembers(TMemberInspector& insp) const; voidSkip(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGeoIterator(TGeoVolume* top); TGeoIterator(const TGeoIterator& iter). protected:. TGeoIterator(). private:. voidIncreaseArray(). Data Members; private:. Int_t*fArrayArray of node indices for the current path; Int_tfLevelCurrent level in the tree; TGeoHMatrix*fMatrixCurrent global matrix; Bool_tfMustResumePrivate flag to resume from current node.; Bool_tfMustStopPrivate flag to signal that the iterator has finished.; TGeoIteratorPlugin*fPluginUser iterator plugin; Bool_tfPluginAutoexecPlugin automatically executed during next(); TGeoVolume*fTopTop volume of the iterated branch; TStringfTopNameUser name for top; Int_tfTypeType of iteration. Class ",MatchSource.WIKI,root/html602/TGeoIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoIterator.html
Performance,perform,perform,"vel in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::AddNodeOverlap(same arguments);. When closing the geometry, overlapping nodes perform a check of possible; overlaps with their neighbours. These are stored and checked all the time; during navigation, therefore navigation is slower when embedding such nodes; into geometry. Node have visualization attributes as volume have. When undefined by users,; painting a node on a pad will take the corresponding volume attributes. /*. */. Function Members (Methods); public:. virtual~TGeoIterator(); static TClass*Class(); const TGeoMatrix*GetCurrentMatrix() const; Int_tGetIndex(Int_t i) const; Int_tGetLevel() const; TGeoNode*GetNode(Int_t level) const; voidGetPath(TString& path) const; TGeoVolume*GetTopVolume() const; Int_tGetType() const; TGeoIteratorPlugin*GetUserPlugin() const; virtual TClass*IsA() const; TGeoNode*Next(); TGeoNode*operator()(); TGeoIterator&operator=(const TGeoIterator& iter); voidReset(TGeoVolume* top = 0); voidSetPluginAutoexec(Bool_t mode); voidSetTopName(const char* name); voidSetType(Int_t type); voidSetUserPlugin(TGeoIteratorPlugin* plugin); virtual voidSh",MatchSource.WIKI,root/html602/TGeoIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoIterator.html
Testability,log,logical," TGeoNode. A node represent a volume positioned inside another.They store links to both; volumes and to the TGeoMatrix representing the relative positioning. Node are; never instanciated directly by users, but created as a result of volume operations.; Adding a volume named A with a given user ID inside a volume B will create a node; node named A_ID. This will be added to the list of nodes stored by B. Also,; when applying a division operation in N slices to a volume A, a list of nodes; B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from",MatchSource.WIKI,root/html602/TGeoIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoIterator.html
Usability,resume,resume,Iterator(); static TClass*Class(); const TGeoMatrix*GetCurrentMatrix() const; Int_tGetIndex(Int_t i) const; Int_tGetLevel() const; TGeoNode*GetNode(Int_t level) const; voidGetPath(TString& path) const; TGeoVolume*GetTopVolume() const; Int_tGetType() const; TGeoIteratorPlugin*GetUserPlugin() const; virtual TClass*IsA() const; TGeoNode*Next(); TGeoNode*operator()(); TGeoIterator&operator=(const TGeoIterator& iter); voidReset(TGeoVolume* top = 0); voidSetPluginAutoexec(Bool_t mode); voidSetTopName(const char* name); voidSetType(Int_t type); voidSetUserPlugin(TGeoIteratorPlugin* plugin); virtual voidShowMembers(TMemberInspector& insp) const; voidSkip(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGeoIterator(TGeoVolume* top); TGeoIterator(const TGeoIterator& iter). protected:. TGeoIterator(). private:. voidIncreaseArray(). Data Members; private:. Int_t*fArrayArray of node indices for the current path; Int_tfLevelCurrent level in the tree; TGeoHMatrix*fMatrixCurrent global matrix; Bool_tfMustResumePrivate flag to resume from current node.; Bool_tfMustStopPrivate flag to signal that the iterator has finished.; TGeoIteratorPlugin*fPluginUser iterator plugin; Bool_tfPluginAutoexecPlugin automatically executed during next(); TGeoVolume*fTopTop volume of the iterated branch; TStringfTopNameUser name for top; Int_tfTypeType of iteration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoIterator(TGeoVolume* top); Geometry iterator for a branch starting with a TOP node. TGeoIterator(const TGeoIterator& iter); Copy ctor. ~TGeoIterator(); Destructor. TGeoIterator & operator=(const TGeoIterator& iter); Assignment. TGeoNode * Next(); Returns next node. TGeoNode * operator()(); Returns next node. const TGeoMatrix * GetCurrentMatrix() const; Returns global matrix for current node. TGeoNode * GetNode(Int_t level) const; Returns current node at a given level. void GetPath(TString& path) const; ,MatchSource.WIKI,root/html602/TGeoIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoIterator.html
Availability,avail,available,"A1_1 and the iteration type was 0, one can do:. next.SetType(1);; The next iterated nodes will be the rest of A daughters: A2,A3,... The iterator; will return 0 after finishing all daughters of A. During iteration, the following can be retreived:; - Top volume where iteration started: TGeoIterator::GetTopVolume(); - Node at level I in the current branch: TGeoIterator::GetNode(Int_t i); - Iteration type: TGeoIterator::GetType(); - Global matrix of the current node with respect to the top volume:; TGeoIterator::GetCurrentMatrix(). The iterator can be reset by changing (or not) the top volume:. TGeoIterator::Reset(TGeoVolume *top);. Example:. We want to find out a volume named ""MyVol"" in the hierarchy of TOP volume. TIter next(TOP);; TGeoNode *node;; TString name(""MyVol"");; while ((node=next())); if (name == node->GetVolume()->GetName()) return node->GetVolume();. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoIteratorPlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtu",MatchSource.WIKI,root/html602/TGeoIteratorPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoIteratorPlugin.html
Performance,perform,perform,". TGeoIteratorPlugin. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoIteratorPlugin. class TGeoIteratorPlugin: public TObject. TGeoIterator. A geometry iterator that sequentially follows all nodes of the geometrical; hierarchy of a volume. The iterator has to be initiated with a top volume; pointer:. TGeoIterator next(myVolume);. One can use the iterator as any other in ROOT:. TGeoNode *node;; while ((node=next())) {. }. The iterator can perform 2 types of iterations that can be selected via:. next.SetType(Int_t type);. Here TYPE can be:; 0 (default) - 'first daughter next' behavior; 1 - iteration at the current level only. Supposing the tree structure looks like:. TOP ___ A_1 ___ A1_1 ___ A11_1; | | |___ A12_1; | |_____A2_1 ___ A21_1; | |___ A21_2; |___ B_1 ... The order of iteration for TYPE=0 is: A_1, A1_1, A11_1, A12_1, A2_1, A21_1,; A21_2, B_1, ...; The order of iteration for TYPE=1 is: A_1, B_1, ...; At any moment during iteration, TYPE can be changed. If the last iterated node; is for instance A1_1 and the iteration type was 0, one can do:. next.SetType(1);; The next iterated nodes will be the rest of A daughters: A2,A3,... The iterator; will return 0 after finishing all daughters of A. During iteration, the following can be retreived:; - Top volume where iteration started: TGeoIterator::GetTopVolume(); - Node at level I in the current branch: TGeoIterator::GetNode(Int_t i); - Iteration type: TGeoIterator::GetType(); - Global matrix of the current node with respect to the top volume:; TGeoIterator::GetCurrentMatrix(). The iterator can be reset by changing (or not) the top volume:. TGeoIterator::Reset(TGeoVolume *top);. Example:. We want to find out a volume named ""MyVol"" in the hierarchy of TOP volume. TIter next(TOP);; TGeoNode *node;; TString name(""MyVol"");; while ((node=ne",MatchSource.WIKI,root/html602/TGeoIteratorPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoIteratorPlugin.html
Availability,down,down,"*. */. An interactive session. Provided that a geometry was successfully built and closed (for instance the; previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; itself to ROOT and the logical/physical structures will become immediately browsable.; The ROOT browser will display starting from the geometry folder : the list of; transformations and media, the top volume and the top logical node. These last; two can be fully expanded, any intermediate volume/node in the browser being subject; of direct access context menu operations (right mouse button click). All user; utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; context menu. /*. */. --- Drawing the geometry. Any logical volume can be drawn via TGeoVolume::Draw() member function.; This can be direcly accessed from the context menu of the volume object; directly from the browser.; There are several drawing options that can be set with; TGeoManager::SetVisOption(Int_t opt) method :; opt=0 - only the content of the volume is drawn, N levels down (default N=3).; This is the default behavior. The number of levels to be drawn can be changed; via TGeoManager::SetVisLevel(Int_t level) method. /*. */. opt=1 - the final leaves (e.g. daughters with no containment) of the branch; starting from volume are drawn down to the current number of levels.; WARNING : This mode is memory consuming; depending of the size of geometry, so drawing from top level within this mode; should be handled with care for expensive geometries. In future there will be; a limitation on the maximum number of nodes to be visualized. /*. */. opt=2 - only the clicked volume is visualized. This is automatically set by; TGeoVolume::DrawOnly() method; opt=3 - only a given path is visualized. This is automatically set by; TGeoVolume::DrawPath(const char *path) method. The current view can be exploded in cartesian, cylindrical or spherical; coordinates :; TGeoManager::SetExplodedView(Int_t opt).",MatchSource.WIKI,root/html602/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoManager.html
Deployability,update,updates,"e will be; a limitation on the maximum number of nodes to be visualized. /*. */. opt=2 - only the clicked volume is visualized. This is automatically set by; TGeoVolume::DrawOnly() method; opt=3 - only a given path is visualized. This is automatically set by; TGeoVolume::DrawPath(const char *path) method. The current view can be exploded in cartesian, cylindrical or spherical; coordinates :; TGeoManager::SetExplodedView(Int_t opt). Options may be :; - 0 - default (no bombing); - 1 - cartesian coordinates. The bomb factor on each axis can be set with; TGeoManager::SetBombX(Double_t bomb) and corresponding Y and Z.; - 2 - bomb in cylindrical coordinates. Only the bomb factors on Z and R; are considered. /*. */. - 3 - bomb in radial spherical coordinate : TGeoManager::SetBombR(). Volumes themselves support different visualization settings :; - TGeoVolume::SetVisibility() : set volume visibility.; - TGeoVolume::VisibleDaughters() : set daughters visibility.; All these actions automatically updates the current view if any. --- Checking the geometry. Several checking methods are accessible from the volume context menu. They; generally apply only to the visible parts of the drawn geometry in order to; ease geometry checking, and their implementation is in the TGeoChecker class; from the painting package. 1. Checking a given point.; Can be called from TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z).; This method is drawing the daughters of the volume containing the point one; level down, printing the path to the deepest physical node holding this point.; It also computes the closest distance to any boundary. The point will be drawn; in red. /*. */. 2. Shooting random points.; Can be called from TGeoVolume::RandomPoints() (context menu function) and; it will draw this volume with current visualization settings. Random points; are generated in the bounding box of the top drawn volume. The points are; classified and drawn with the color of their deepest container. ",MatchSource.WIKI,root/html602/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoManager.html
Energy Efficiency,energy,energy,"erial * Mixture(const char* name, Float_t* a, Float_t* z, Double_t dens, Int_t nelem, Float_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation ",MatchSource.WIKI,root/html602/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoManager.html
Integrability,depend,depending,"panded, any intermediate volume/node in the browser being subject; of direct access context menu operations (right mouse button click). All user; utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; context menu. /*. */. --- Drawing the geometry. Any logical volume can be drawn via TGeoVolume::Draw() member function.; This can be direcly accessed from the context menu of the volume object; directly from the browser.; There are several drawing options that can be set with; TGeoManager::SetVisOption(Int_t opt) method :; opt=0 - only the content of the volume is drawn, N levels down (default N=3).; This is the default behavior. The number of levels to be drawn can be changed; via TGeoManager::SetVisLevel(Int_t level) method. /*. */. opt=1 - the final leaves (e.g. daughters with no containment) of the branch; starting from volume are drawn down to the current number of levels.; WARNING : This mode is memory consuming; depending of the size of geometry, so drawing from top level within this mode; should be handled with care for expensive geometries. In future there will be; a limitation on the maximum number of nodes to be visualized. /*. */. opt=2 - only the clicked volume is visualized. This is automatically set by; TGeoVolume::DrawOnly() method; opt=3 - only a given path is visualized. This is automatically set by; TGeoVolume::DrawPath(const char *path) method. The current view can be exploded in cartesian, cylindrical or spherical; coordinates :; TGeoManager::SetExplodedView(Int_t opt). Options may be :; - 0 - default (no bombing); - 1 - cartesian coordinates. The bomb factor on each axis can be set with; TGeoManager::SetBombX(Double_t bomb) and corresponding Y and Z.; - 2 - bomb in cylindrical coordinates. Only the bomb factors on Z and R; are considered. /*. */. - 3 - bomb in radial spherical coordinate : TGeoManager::SetBombR(). Volumes themselves support different visualization settings :; - TGeoVolume::SetVisibility() : set volume visi",MatchSource.WIKI,root/html602/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoManager.html
Modifiability,inherit,inherits," several other volumes),; every volume becoming a branch in this graph. Any volume in the logical graph; can become the actual top volume at run time (see TGeoManager::SetTopVolume()).; All functionalities of the modeler will behave in this case as if only the; corresponding branch starting from this volume is the registered geometry. /*. */. A given volume can be positioned several times in the geometry. A volume; can be divided according default or user-defined patterns, creating automatically; the list of division nodes inside. The elementary volumes created during the; dividing process follow the same scheme as usual volumes, therefore it is possible; to position further geometrical structures inside or to divide them further more; (see TGeoVolume::Divide()). The primitive shapes supported by the package are basically the GEANT3; shapes (see class TGeoShape), arbitrary wedges with eight vertices on two parallel; planes. All basic primitives inherits from class TGeoBBox since the bounding box; of a solid is essential for the tracking algorithms. They also implement the; virtual methods defined in the virtual class TGeoShape (point and segment; classification). User-defined primitives can be direcly plugged into the modeler; provided that they override these methods. Composite shapes will be soon supported; by the modeler. In order to build a TGeoCompositeShape, one will have to define; first the primitive components. The object that handle boolean; operations among components is called TGeoBoolCombinator and it has to be; constructed providing a string boolean expression between the components names. Example for building a simple geometry :. rootgeom.C //; ; //. /*. */. TGeoManager - the manager class for the geometry package. TGeoManager class is embedding all the API needed for building and tracking; a geometry. It defines a global pointer (gGeoManager) in order to be fully; accessible from external code. The mechanism of handling multiple geometries; at the sam",MatchSource.WIKI,root/html602/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoManager.html
Performance,cache,cache," providing a string boolean expression between the components names. Example for building a simple geometry :. rootgeom.C //; ; //. /*. */. TGeoManager - the manager class for the geometry package. TGeoManager class is embedding all the API needed for building and tracking; a geometry. It defines a global pointer (gGeoManager) in order to be fully; accessible from external code. The mechanism of handling multiple geometries; at the same time will be soon implemented. TGeoManager is the owner of all geometry objects defined in a session,; therefore users must not try to control their deletion. It contains lists of; media, materials, transformations, shapes and volumes. Logical nodes (positioned; volumes) are created and destroyed by the TGeoVolume class. Physical; nodes and their global transformations are subjected to a caching mechanism; due to the sometimes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class; also controls the painter client. This is linked with ROOT graphical libraries; loaded on demand in order to control visualization actions. Rules for building a valid geometry. A given geometry can be built in various ways, but there are mandatory steps; that have to be followed in order to be validated by the modeler. There are; general rules : volumes needs media and shapes in order to be created,; both container an containee volumes must be created before linking them together,; and the relative transformation matrix must be provided. All branches must; have an upper link point otherwise they will not be considered as part of the; geometry. Visibility or tracking properties of volumes can be provided both; at build time or after geometry is closed, but global visualization settings; (see TGeoPainter class) should not be provided at build time, otherwise the; drawing package will be loaded. Ther",MatchSource.WIKI,root/html602/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoManager.html
Safety,detect,detector,". TGeoManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoManager. class TGeoManager: public TNamed. General architecture. The new ROOT geometry package is a tool designed for building, browsing,; tracking and visualizing a detector geometry. The code is independent from; other external MC for simulation, therefore it does not contain any; constraints related to physics. However, the package defines a number of; hooks for tracking, such as media, materials, magnetic field or track state flags,; in order to allow interfacing to tracking MC's. The final goal is to be; able to use the same geometry for several purposes, such as tracking,; reconstruction or visualization, taking advantage of the ROOT features; related to bookkeeping, I/O, histograming, browsing and GUI's. The geometrical modeler is the most important component of the package and; it provides answers to the basic questions like ""Where am I ?"" or ""How far; from the next boundary ?"", but also to more complex ones like ""How far from; the closest surface ?"" or ""Which is the next crossing along a helix ?"". The architecture of the modeler is a combination between a GEANT-like; containment scheme and a normal CSG binary tree at the level of shapes. An; important common feature of all detector geometry descriptions is the; mother-daughter concept. This is the most natural approach when tracking; is concerned and imposes a set of constraints to the way geometry is defined.; Constructive solid geometry composition is used only in order to create more; complex shapes from an existing set of primitives through boolean operations.; This feature is not implemented yet but in future full definition of boolean; expressions will be supported. Practically every geometry defined in GEANT style can be mapped by the modeler.; The basic c",MatchSource.WIKI,root/html602/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoManager.html
Security,access,accessible,"th eight vertices on two parallel; planes. All basic primitives inherits from class TGeoBBox since the bounding box; of a solid is essential for the tracking algorithms. They also implement the; virtual methods defined in the virtual class TGeoShape (point and segment; classification). User-defined primitives can be direcly plugged into the modeler; provided that they override these methods. Composite shapes will be soon supported; by the modeler. In order to build a TGeoCompositeShape, one will have to define; first the primitive components. The object that handle boolean; operations among components is called TGeoBoolCombinator and it has to be; constructed providing a string boolean expression between the components names. Example for building a simple geometry :. rootgeom.C //; ; //. /*. */. TGeoManager - the manager class for the geometry package. TGeoManager class is embedding all the API needed for building and tracking; a geometry. It defines a global pointer (gGeoManager) in order to be fully; accessible from external code. The mechanism of handling multiple geometries; at the same time will be soon implemented. TGeoManager is the owner of all geometry objects defined in a session,; therefore users must not try to control their deletion. It contains lists of; media, materials, transformations, shapes and volumes. Logical nodes (positioned; volumes) are created and destroyed by the TGeoVolume class. Physical; nodes and their global transformations are subjected to a caching mechanism; due to the sometimes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class; also controls the painter client. This is linked with ROOT graphical libraries; loaded on demand in order to control visualization actions. Rules for building a valid geometry. A given geometry can be built in various ways, but there are mandat",MatchSource.WIKI,root/html602/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoManager.html
Testability,log,logical,"d; it provides answers to the basic questions like ""Where am I ?"" or ""How far; from the next boundary ?"", but also to more complex ones like ""How far from; the closest surface ?"" or ""Which is the next crossing along a helix ?"". The architecture of the modeler is a combination between a GEANT-like; containment scheme and a normal CSG binary tree at the level of shapes. An; important common feature of all detector geometry descriptions is the; mother-daughter concept. This is the most natural approach when tracking; is concerned and imposes a set of constraints to the way geometry is defined.; Constructive solid geometry composition is used only in order to create more; complex shapes from an existing set of primitives through boolean operations.; This feature is not implemented yet but in future full definition of boolean; expressions will be supported. Practically every geometry defined in GEANT style can be mapped by the modeler.; The basic components used for building the logical hierarchy of the geometry; are called ""volumes"" and ""nodes"". Volumes (sometimes called ""solids"") are fully; defined geometrical objects having a given shape and medium and possibly; containing a list of nodes. Nodes represent just positioned instances of volumes; inside a container volume and they are not directly defined by user. They are; automatically created as a result of adding one volume inside other or dividing; a volume. The geometrical transformation hold by nodes is always defined with; respect to their mother (relative positioning). Reflection matrices are allowed.; All volumes have to be fully aware of their containees when the geometry is; closed. They will build aditional structures (voxels) in order to fasten-up; the search algorithms. Finally, nodes can be regarded as bidirectional links; between containers and containees objects. The structure defined in this way is a graph structure since volumes are; replicable (same volume can become daughter node of several other volu",MatchSource.WIKI,root/html602/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoManager.html
Usability,simpl,simple,"is possible; to position further geometrical structures inside or to divide them further more; (see TGeoVolume::Divide()). The primitive shapes supported by the package are basically the GEANT3; shapes (see class TGeoShape), arbitrary wedges with eight vertices on two parallel; planes. All basic primitives inherits from class TGeoBBox since the bounding box; of a solid is essential for the tracking algorithms. They also implement the; virtual methods defined in the virtual class TGeoShape (point and segment; classification). User-defined primitives can be direcly plugged into the modeler; provided that they override these methods. Composite shapes will be soon supported; by the modeler. In order to build a TGeoCompositeShape, one will have to define; first the primitive components. The object that handle boolean; operations among components is called TGeoBoolCombinator and it has to be; constructed providing a string boolean expression between the components names. Example for building a simple geometry :. rootgeom.C //; ; //. /*. */. TGeoManager - the manager class for the geometry package. TGeoManager class is embedding all the API needed for building and tracking; a geometry. It defines a global pointer (gGeoManager) in order to be fully; accessible from external code. The mechanism of handling multiple geometries; at the same time will be soon implemented. TGeoManager is the owner of all geometry objects defined in a session,; therefore users must not try to control their deletion. It contains lists of; media, materials, transformations, shapes and volumes. Logical nodes (positioned; volumes) are created and destroyed by the TGeoVolume class. Physical; nodes and their global transformations are subjected to a caching mechanism; due to the sometimes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class;",MatchSource.WIKI,root/html602/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoManager.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoManagerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoManagerEditor.html
Integrability,depend,depending,"GedFrame. TGeoManagerEditor. Editor for TGeoManager class. Provides also builder functionality for the; main TGeo objects: TGeoVolume, TGeoShape - derived classes, TGeoMaterial,; TGeoMatrix - derived transformations and TGeoMedium.; The GUI represents the main entry point for editing geometry classes. It; can be started either by:; 1. TGeoManager::Edit(). The method must be used when starting from a new; geometry.; 2. Left-click on the 40x40 pixels top-right corner of a pad containing a; drawn volume. The region is always accesible when drawing geometry elements; and allows also restoring the manager editor in the ""Style"" tab of the GED; editor anytime. The TGeoManager editor is vertically split by a TGShutter widget into the; following categories:. - General. This allows changing the name/title of the geometry, setting the; top volume, closing the geometry and saving the geometry in a file. The name; of the geometry file is formed by geometry_name.C/.root depending if the geometry; need to be saved as a C macro or a .root file.; - Shapes. The category provide buttons for creation of all supported shapes. The; new shape name is chosen by the interface, but can be changed from the shape; editor GUI. Existing shapes can be browsed and edited from the same category.; - Volumes. The category allows the creation of a new volume having a given name,; shape and medium. For creating a volume assembly only the name is relevant.; Existing volumes can be browsed or edited from this category.; - Materials. Allows creation of new materials/mixtures or editing existing ones.; - Media. The same for creation/editing of tracking media (materials having a set; of properties related to tracking); - Matrices. Allows creation of translations, rotations or combined transformations.; Existing matrices can also be browser/edited. Function Members (Methods); public:. virtual~TGeoManagerEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObj",MatchSource.WIKI,root/html602/TGeoManagerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoManagerEditor.html
Availability,error,error,"ic:. virtual~TGeoMaterial(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static Double_tCoulomb(Double_t z); virtual TGeoMaterial*DecayMaterial(Double_t time, Double_t precision = 0.001); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillMaterialEvolution(TObjArray* population, Double_t precision = 0.001); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGetA() const; TGeoElement*GetBaseElement() const; virtual Int_tGetByteCount() const; virtual TObject*GetCerenkovProperties() const; virtual Int_tGetDefaultColor() const; virtual Double_tGetDensity() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TGeoElement*GetElement(Int_t i = 0) const; virtual voidGetElementProp(Double_t& a, Double_t& z, Double_t& w, Int_t i = 0); virtual ",MatchSource.WIKI,root/html602/TGeoMaterial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMaterial.html
Deployability,release,released,"tle; TGeoExtension*fUserExtension! Transient user-defined extension to materials; Double_tfZZ of material. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMaterial(); Default constructor. TGeoMaterial(const char* name); constructor. TGeoMaterial(const char* name, Double_t a, Double_t z, Double_t rho, Double_t radlen = 0, Double_t intlen = 0); constructor. TGeoMaterial(const char* name, Double_t a, Double_t z, Double_t rho, TGeoMaterial::EGeoMaterialState state, Double_t temperature = STP_temperature, Double_t pressure = STP_pressure); Constructor with state, temperature and pressure. TGeoMaterial(const char* name, TGeoElement* elem, Double_t rho); constructor. TGeoMaterial(const TGeoMaterial& ); copy constructor. TGeoMaterial& operator=(const TGeoMaterial& ); assignment operator. ~TGeoMaterial(); Destructor. void SetUserExtension(TGeoExtension* ext); Connect user-defined extension to the material. The material ""grabs"" a copy, so; the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for user extensions and is guaranteed not; to be used by TGeo. void SetFWExtension(TGeoExtension* ext); Connect framework defined extension to the material. The material ""grabs"" a copy,; so the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for the use by TGeo and the users should; NOT connect extensions using this method. TGeoExtension * GrabUserExtension() const; Get a copy of the user extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). TGeoExtension * GrabFWExtension() const; Get a copy of the framework extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). char * GetPo",MatchSource.WIKI,root/html602/TGeoMaterial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMaterial.html
Integrability,interface,interface," Members; Includes; Libraries. Function documentation; TGeoMaterial(); Default constructor. TGeoMaterial(const char* name); constructor. TGeoMaterial(const char* name, Double_t a, Double_t z, Double_t rho, Double_t radlen = 0, Double_t intlen = 0); constructor. TGeoMaterial(const char* name, Double_t a, Double_t z, Double_t rho, TGeoMaterial::EGeoMaterialState state, Double_t temperature = STP_temperature, Double_t pressure = STP_pressure); Constructor with state, temperature and pressure. TGeoMaterial(const char* name, TGeoElement* elem, Double_t rho); constructor. TGeoMaterial(const TGeoMaterial& ); copy constructor. TGeoMaterial& operator=(const TGeoMaterial& ); assignment operator. ~TGeoMaterial(); Destructor. void SetUserExtension(TGeoExtension* ext); Connect user-defined extension to the material. The material ""grabs"" a copy, so; the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for user extensions and is guaranteed not; to be used by TGeo. void SetFWExtension(TGeoExtension* ext); Connect framework defined extension to the material. The material ""grabs"" a copy,; so the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for the use by TGeo and the users should; NOT connect extensions using this method. TGeoExtension * GrabUserExtension() const; Get a copy of the user extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). TGeoExtension * GrabFWExtension() const; Get a copy of the framework extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). char * GetPointerName() const; Provide a pointer name containing uid. void SetRadLen(Double_t radlen, Double_t intlen = 0.); Set radiation/absorbtion lengt",MatchSource.WIKI,root/html602/TGeoMaterial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMaterial.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html602/TGeoMaterialDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMaterialDialog.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoMaterialEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMaterialEditor.html
Energy Efficiency,charge,charge,"_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMaterialEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for material editor. ~TGeoMaterialEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected material. void DoName(); Perform name change. void DoA(); Slot for atomic mass. void DoZ(); Slot for charge. void DoState(Int_t state); Slot for material state. void DoTemperature(); Slot for material temperature. void DoPressure(); Slot for material pressure. void DoDensity(); Slot for density.; fMatDensity->SetNumber(fDensityi);. void DoRadAbs(); Slot for radiation/absorbtion length. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for cancelling current modifications. void DoModified(); Slot for signaling modifications. TGeoMaterialEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoMaterialEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMaterialEditor.html
Availability,error,error,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoMatrix(); voidTObject::AbstractMethod(const char* m",MatchSource.WIKI,root/html602/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMatrix.html
Integrability,interface,interface," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html602/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMatrix.html
Modifiability,variab,variable,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoMatrix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObje",MatchSource.WIKI,root/html602/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMatrix.html
Performance,optimiz,optimize,". TGeoMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoMatrix. class TGeoMatrix: public TNamed. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse sca",MatchSource.WIKI,root/html602/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMatrix.html
Usability,simpl,simple,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html602/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMatrix.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html602/TGeoMatrixDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMatrixDialog.html
Availability,error,error," virtual~TGeoMCGeometry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tGetMaterial(const TString& volumeName, TString& name, Int_t& imat, ",MatchSource.WIKI,root/html602/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMCGeometry.html
Deployability,continuous,continuous,"le_t* a, Double_t* z, Double_t dens, Int_t nlmat, Double_t* wmat). Defines mixture OR COMPOUND IMAT as composed by; THE BASIC NLMAT materials defined by arrays A,Z and WMAT. If NLMAT > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then WMAT contains the number of atoms; of a given kind into the molecule of the COMPOUND; In this case, WMAT in output is changed to relative; weigths. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 i",MatchSource.WIKI,root/html602/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMCGeometry.html
Energy Efficiency,energy,energy," weigths. void Mixture(Int_t& kmat, const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nlmat, Double_t* wmat). Defines mixture OR COMPOUND IMAT as composed by; THE BASIC NLMAT materials defined by arrays A,Z and WMAT. If NLMAT > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then WMAT contains the number of atoms; of a given kind into the molecule of the COMPOUND; In this case, WMAT in output is changed to relative; weigths. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; if",MatchSource.WIKI,root/html602/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMCGeometry.html
Integrability,interface,interface,". TGeoMCGeometry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TGeoMCGeometry. class TGeoMCGeometry: public TVirtualMCGeometry. Implementation of the TVirtualMCGeometry interface; for building TGeo geometry. Function Members (Methods); public:. virtual~TGeoMCGeometry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tGetMaterial(const TString& volumeName, TString& name, Int_t& imat, ",MatchSource.WIKI,root/html602/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMCGeometry.html
Performance,perform,performed,"MAT materials defined by arrays A,Z and WMAT. If NLMAT > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then WMAT contains the number of atoms; of a given kind into the molecule of the COMPOUND; In this case, WMAT in output is changed to relative; weigths. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Dou",MatchSource.WIKI,root/html602/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMCGeometry.html
Testability,test,tests,"eate a new volume by dividing an existing one. NAME Volume name; MOTHER Mother volume name; NDIV Number of divisions; IAXIS Axis value. X,Y,Z of CAXIS will be translated to 1,2,3 for IAXIS.; It divides a previously defined volume. void Gsdvn2(const char* name, const char* mother, Int_t ndiv, Int_t iaxis, Double_t c0i, Int_t numed). Create a new volume by dividing an existing one. Divides mother into ndiv divisions called name; along axis iaxis starting at coordinate value c0.; the new volume created will be medium number numed. void Gsdvt(const char* name, const char* mother, Double_t step, Int_t iaxis, Int_t numed, Int_t ndvmx). Create a new volume by dividing an existing one. Divides MOTHER into divisions called NAME along; axis IAXIS in steps of STEP. If not exactly divisible; will make as many as possible and will centre them; with respect to the mother. Divisions will have medium; number NUMED. If NUMED is 0, NUMED of MOTHER is taken.; NDVMX is the expected maximum number of divisions; (If 0, no protection tests are performed). void Gsdvt2(const char* name, const char* mother, Double_t step, Int_t iaxis, Double_t c0, Int_t numed, Int_t ndvmx). Create a new volume by dividing an existing one. Divides MOTHER into divisions called NAME along; axis IAXIS starting at coordinate value C0 with step; size STEP.; The new volume created will have medium number NUMED.; If NUMED is 0, NUMED of mother is taken.; NDVMX is the expected maximum number of divisions; (If 0, no protection tests are performed). void Gsord(const char* name, Int_t iax). Flags volume CHNAME whose contents will have to be ordered; along axis IAX, by setting the search flag to -IAX; IAX = 1 X axis; IAX = 2 Y axis; IAX = 3 Z axis; IAX = 4 Rxy (static ordering only -> GTMEDI); IAX = 14 Rxy (also dynamic ordering -> GTNEXT); IAX = 5 Rxyz (static ordering only -> GTMEDI); IAX = 15 Rxyz (also dynamic ordering -> GTNEXT); IAX = 6 PHI (PHI=0 => X axis); IAX = 7 THETA (THETA=0 => Z axis). void Gspos(const char*",MatchSource.WIKI,root/html602/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMCGeometry.html
Availability,error,error," virtual~TGeoMedium(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, In",MatchSource.WIKI,root/html602/TGeoMedium.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMedium.html
Integrability,interface,interfaces,". TGeoMedium. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoMedium. class TGeoMedium: public TNamed. Media are used to store properties related to tracking and which are useful; only when using geometry with a particle transport MC package (via VMC). One; may define several tracking media for a given material. The media ID are user; defined values that are not used by the geometry package. In case geometry; is used via VMC (in GEANT) these numbers are overwritten, so one can only; rely on these values after gMC->FinishGeometry() is called.; The media parameters are inspired from GEANT3 and the values defined make sense; in context of GEANT (3 but also 4) or FLUKA interfaces. Function Members (Methods); public:. virtual~TGeoMedium(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, In",MatchSource.WIKI,root/html602/TGeoMedium.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMedium.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html602/TGeoMediumDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMediumDialog.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoMediumEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMediumEditor.html
Usability,undo,undoing,"Background; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMediumEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for medium editor. ~TGeoMediumEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoEditMaterial(); Edit selected material. void DoMedName(); Slot for medium name. void DoMedId(); Slot for medium id. void DoSelectMaterial(); Select the material component. void DoToggleSensitive(); Slot for sensitivity. void DoMagfldSelect(Int_t ientry); Slot for mag. field. void DoFieldm(); Slot for max field. void DoTmaxfd(); Slot for tmaxfd. void DoStemax(); Slot for the max allowed step. void DoDeemax(); Slot for the maximum allowed dedx. void DoEpsil(); Slot for tracking precision. void DoStmin(); Slot for min. step. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. TGeoMediumEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoMediumEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMediumEditor.html
Availability,error,error,,MatchSource.WIKI,root/html602/TGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeometry.html
Safety,detect,detector,". TGeometry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TGeometry. class TGeometry: public TNamed. T G E O M E T R Y description. The Geometry class describes the geometry of a detector.; The current implementation supports the GEANT3 style description.; A special program provided in the ROOT utilities (toroot) can be used; to automatically translate a GEANT detector geometry into a ROOT geometry. a Geometry object is entered into the list of geometries into the; ROOT main object (see TROOT description) when the TGeometry; constructor is invoked.; Several geometries may coexist in memory. A Geometry object consist of the following linked lists:; - the TMaterial list (material definition only).; - the TRotmatrix list (Rotation matrices definition only).; - the TShape list (volume definition only).; - the TNode list assembling all detector elements. Only the Build and Draw functions for a geometry are currently supported. The conversion program from Geant to Root has been added in the list; of utilities in utils directory.(see g2root); The executable module of g2root can be found in $ROOTSYS/bin/g2root. To use this conversion program, type the shell command:; g2root geant_rzfile macro_name. for example; g2root na49.geom na49.C; will convert the GEANT RZ file na49.geom into a ROOT macro na49.C. To generate the Geometry structure within Root, do:; Root > .x na49.C; Root > na49.Draw(); Root > wh.x3d() (this invokes the 3-d Root viewver); Root > TFile gna49(""na49.root"",""NEW"") //open a new root file; Root > na49.Write() //Write the na49 geometry structure; Root > gna49.Write() //Write all keys (in this case only one); Note: all keys are also written on closing of the file, gna49.Close or; when the program exits, Root closes all open files correctly.; Once this file has been written, in a ",MatchSource.WIKI,root/html602/TGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeometry.html
Usability,simpl,simply," list assembling all detector elements. Only the Build and Draw functions for a geometry are currently supported. The conversion program from Geant to Root has been added in the list; of utilities in utils directory.(see g2root); The executable module of g2root can be found in $ROOTSYS/bin/g2root. To use this conversion program, type the shell command:; g2root geant_rzfile macro_name. for example; g2root na49.geom na49.C; will convert the GEANT RZ file na49.geom into a ROOT macro na49.C. To generate the Geometry structure within Root, do:; Root > .x na49.C; Root > na49.Draw(); Root > wh.x3d() (this invokes the 3-d Root viewver); Root > TFile gna49(""na49.root"",""NEW"") //open a new root file; Root > na49.Write() //Write the na49 geometry structure; Root > gna49.Write() //Write all keys (in this case only one); Note: all keys are also written on closing of the file, gna49.Close or; when the program exits, Root closes all open files correctly.; Once this file has been written, in a subsequent session, simply do:; Root > TFile gna49(""na49.root""); Root > na49.Draw(). The figure below shows the geometry above using the x3d viewer.; This x3d viewver is invoked by selecting ""View x3d"" in the View menu; of a canvas (See example of this tool bar in TCanvas). /*. */. Function Members (Methods); public:. virtual~TGeometry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual voidcd(const char* path = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constM",MatchSource.WIKI,root/html602/TGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeometry.html
Availability,error,error,"ndPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static Double_tTGeoMaterial::Coulomb(Double_t z); virtual TGeoMaterial*DecayMaterial(Double_t time, Double_t precision = 0.001); voidDefineElement(Int_t iel, TGeoElement* elem, Double_t weight); voidDefineElement(Int_t iel, Int_t z, Int_t natoms); voidDefineElement(Int_t iel, Double_t a, Double_t z, Double_t weight); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillMaterialEvolution(TObjArray* population, Double_t precision = 0.001); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tTGeoMaterial::GetA() const; Double_t*GetAmixt() const; TGeoElement*TGeoMaterial::GetBaseElement() const; virtual Int_tGetByteCount() const; virtual TObject*TGeoMaterial::GetCerenkovProperties() const; virtual Int_tTGeoMaterial::GetDefaultColor() const; virtual Double_tTGeoMaterial::GetDensity() const; virtual Option_t*TObject::GetDraw",MatchSource.WIKI,root/html602/TGeoMixture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMixture.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoMixtureEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMixtureEditor.html
Usability,undo,undo,"ow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMixtureEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for mixture editor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected mixture. void DoChkFraction(); Check button state changed for fraction. void DoChkNatoms(); Check button state changed for natoms. void DoFraction(); Fraction changed. void DoNatoms(); Natoms changed. void DoSelectElement(Int_t iel); Slot for selecting an element. void DoAddElem(); Slot for adding an element. No undo. void DoApply1(); Slot for applying modifications. void DoUndo1(); Slot for undoing all changes. void UpdateElements(); Update the list of elements in the TGCanvas. TGeoMixtureEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); {}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoMixtureEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoMixtureEditor.html
Availability,down,downwards," virtual~TGeoNavigator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Bool_tcd(const char* path = """"); voidCdDown(Int_t index); voidCdDown(TGeoNode* node); voidCdNext(); voidCdNode(Int_t nodeid); voidCdTop(); voidCdUp(); Bool_tCheckPath(const char* path) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; TGeoNode*CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidDoBackupState(); voidDoRestoreState(); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* meth",MatchSource.WIKI,root/html602/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoNavigator.html
Performance,cache,cache,,MatchSource.WIKI,root/html602/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoNavigator.html
Safety,safe,safe,"tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidResetAll(); voidTObject::ResetBit(UInt_t f); voidResetState(); Double_tSafety(Bool_t inside = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TGeoNode*SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCheckingOverlaps(Bool_t flag = kTRUE); voidSetCldirChecked(Double_t* dir); voidSetCurrentDirection(const Double_t* dir); voidSetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); voidSetCurrentPoint(const Double_t* point); voidSetCurrentPoint(Double_t x, Double_t y, Double_t z); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetLastPoint(Double_t x, Double_t y, Double_t z); voidSetLastSafetyForPoint(Double_t safe, const Double_t* point); voidSetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); static voidTObject::SetObjectStat(Bool_t stat); voidSetOutside(Bool_t flag = kTRUE); voidSetStartSafe(Bool_t flag = kTRUE); voidSetStep(Double_t step); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; TGeoNode*Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TGeoNavigator(); TGeoNavigator(TGeoManager* geom); voidTopToMaster(const Double_t* top, Double_t* master) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTO",MatchSource.WIKI,root/html602/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoNavigator.html
Availability,error,error,"ic TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObjArray::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidTObjArray::Compress(); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObjArray::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObjArray::Expand(Int_t newSize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObjArray::FindObject(const char* name) const; virtual TObject*TObjArray::FindObject(const TObject* obj) const; virtual TObject*TObjArray::First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); TGeoNavigator*GetCurrentNavigator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTObjArray::GetEntries() const; Int_tTObjArray::GetEntriesFast() const; virtual const char*TObject::GetIconName() const; virtual Int_tTObjArray::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TObject**TObjArray::GetO",MatchSource.WIKI,root/html602/TGeoNavigatorArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoNavigatorArray.html
Availability,avail,available,"efore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::AddNodeOverlap(same arguments);. When closing the geometry, overlapping nodes perform a check of possible; overlaps with their neighbours. These are stored and checked all the time; during navigation, therefore navigation is slower when embedding such nodes; into geometry. Node have visualization attributes as volume have. When undefined by users,; painting a node on a pad will take the corresponding volume attributes. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoNode(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual voidcd() const; voidCheckOverlaps(Double_t ovlp = 0.10000000000000001, Option_t* option = """")MENU ; voidCheckShapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tCountDaughters(Bool_t unique_volumes = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawOnly(Option_t* option = """"); voidDrawOverlaps(); virtu",MatchSource.WIKI,root/html602/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoNode.html
Deployability,release,released,"ent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this volume. char * GetObjectInfo(Int_t px, Int_t py) const; Get node info for the browser. Bool_t IsOnScreen() const; check if this node is drawn. Assumes that this node is current. void InspectNode() const; Inspect this node. void CheckShapes(); check for wrong parameters in shapes. void DrawOnly(Option_t* option = """"); draw only this node independently of its vis options. void Draw(Option_t* option = """"); draw current node according to option. void DrawOverlaps(); Method drawing the overlap candidates with this node. void FillIdArray(Int_t& ifree, Int_t& nodeid, Int_t* array) const; Fill array with node id. Recursive on node branch. Int_t FindNode(const TGeoNode* node, Int_t level); Search for a node within the branch of this one. void SaveAttributes(ostream& out); save attributes for this node. void SetUserExtension(TGeoExtension* ext); Connect user-defined extension to the node. The node ""grabs"" a copy, so; the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for user extensions and is guaranteed not; to be used by TGeo. void SetFWExtension(TGeoExtension* ext); Connect framework defined extension to the node. The node ""grabs"" a copy,; so the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for the use by TGeo and the users should; NOT connect extensions using this method. TGeoExtension * GrabUserExtension() const; Get a copy of the user extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). TGeoExtension * GrabFWExtension() const; Get a copy of the framework extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). Bool_t MayOverlap(Int_",MatchSource.WIKI,root/html602/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoNode.html
Integrability,interface,interface," the browser. Bool_t IsOnScreen() const; check if this node is drawn. Assumes that this node is current. void InspectNode() const; Inspect this node. void CheckShapes(); check for wrong parameters in shapes. void DrawOnly(Option_t* option = """"); draw only this node independently of its vis options. void Draw(Option_t* option = """"); draw current node according to option. void DrawOverlaps(); Method drawing the overlap candidates with this node. void FillIdArray(Int_t& ifree, Int_t& nodeid, Int_t* array) const; Fill array with node id. Recursive on node branch. Int_t FindNode(const TGeoNode* node, Int_t level); Search for a node within the branch of this one. void SaveAttributes(ostream& out); save attributes for this node. void SetUserExtension(TGeoExtension* ext); Connect user-defined extension to the node. The node ""grabs"" a copy, so; the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for user extensions and is guaranteed not; to be used by TGeo. void SetFWExtension(TGeoExtension* ext); Connect framework defined extension to the node. The node ""grabs"" a copy,; so the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for the use by TGeo and the users should; NOT connect extensions using this method. TGeoExtension * GrabUserExtension() const; Get a copy of the user extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). TGeoExtension * GrabFWExtension() const; Get a copy of the framework extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). Bool_t MayOverlap(Int_t iother) const; Check the overlab between the bounding box of the node overlaps with the one; the brother with index IOTHER. void MasterToLo",MatchSource.WIKI,root/html602/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoNode.html
Performance,perform,perform,"vel in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::AddNodeOverlap(same arguments);. When closing the geometry, overlapping nodes perform a check of possible; overlaps with their neighbours. These are stored and checked all the time; during navigation, therefore navigation is slower when embedding such nodes; into geometry. Node have visualization attributes as volume have. When undefined by users,; painting a node on a pad will take the corresponding volume attributes. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoNode(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual voidcd() const; voidCheckOverlaps(Double_t ovlp = 0.10000000000000001, Option_t* option = """")MENU ; voidCheckShapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_t",MatchSource.WIKI,root/html602/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoNode.html
Testability,log,logical," TGeoNode. A node represent a volume positioned inside another.They store links to both; volumes and to the TGeoMatrix representing the relative positioning. Node are; never instanciated directly by users, but created as a result of volume operations.; Adding a volume named A with a given user ID inside a volume B will create a node; node named A_ID. This will be added to the list of nodes stored by B. Also,; when applying a division operation in N slices to a volume A, a list of nodes; B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from",MatchSource.WIKI,root/html602/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoNode.html
Availability,error,error,"dTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildIdArray(); voidBuildInfoBranch(); Bool_tCdDown(Int_t index); Bool_tCdDown(TGeoNode* node); voidCdNode(Int_t nodeid); voidCdTop(); voidCdUp(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillIdBranch(const Int_t* br, Int_t startlevel = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*GetBranch() const; voidGetBranchNames(Int_t* names) const; voidGetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; voidGetBranchOnlys(Int_t* isonly) const; TGeoHMatrix*GetCurrentMatrix() const; Int_tGetCurrentNodeId() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const Int_t*GetIdBranch() const; TGeoStateInfo*GetInfo(); Int_tGetLevel() const; void*GetMatrices() const; TGeoNode*GetMother(Int_t up = 1) const; TGeoHMatrix*GetMotherMatrix(Int_t up = 1) const; virtual c",MatchSource.WIKI,root/html602/TGeoNodeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoNodeCache.html
Integrability,interface,interface,"s Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNodeCache(); Dummy constructor. TGeoNodeCache(TGeoNode* top, Bool_t nodeid = kFALSE, Int_t capacity = 30); Default constructor. ~TGeoNodeCache(); Destructor. void BuildIdArray(); Builds node id array. void BuildInfoBranch(); Bulds info branch. Navigation is possible only after this step. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Bool_t CdDown(Int_t index); Make daughter INDEX of current node the active state. Compute global matrix. Bool_t CdDown(TGeoNode* node); Make daughter INDEX of current node the active state. Compute global matrix. void CdUp(); Make mother of current node the active state. Int_t GetCurrentNodeId() const; Returns a fixed ID for current physical node. Int_t GetNodeId() const; Get unique node id. void GetBranchNames(Int_t* names) const; Fill names with current branch volume names (4 char - used by GEANT3 interface). void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill copy numbers of current branch nodes. void GetBranchOnlys(Int_t* isonly) const; Fill copy numbers of current branch nodes. TGeoStateInfo * GetInfo(); Get next state info pointer. void ReleaseInfo(); Release last used state info pointer. const char * GetPath(); Returns the current geometry path. Int_t PushState(Bool_t ovlp, Int_t ntmany = 0, Int_t startlevel = 0, Double_t* point = 0); Push current state into heap. Bool_t PopState(Int_t& nmany, Double_t* point = 0); Pop next state/point from heap. Bool_t PopState(Int_t& nmany, Int_t level, Double_t* point = 0); Pop next state/point from heap and restore matrices starting from LEVEL. Bool_t RestoreState(Int_t& nmany, TGeoCacheState* state, Double_t* point = 0); Pop next state/point from a backed-up state. void LocalToMaster(const Double_t* local, Double_t* master) const; Local point converted to master ",MatchSource.WIKI,root/html602/TGeoNodeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoNodeCache.html
Performance,cache,cache,"bject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCurrentIDunique ID of current node; Int_tfGeoCacheMaxLevelsmaximum supported number of levels; Int_tfGeoCacheStackSizemaximum size of the stack; Int_tfGeoInfoStackSizemaximum size of the stack of info states; Int_tfIdBranch[100]current branch of indices; Int_tfIndexindex in array of ID's; TGeoStateInfo**fInfoBranchcurrent branch of nodes; Int_tfInfoLevelcurrent level in the stack; Int_tfLevellevel in the current branch; TGeoHMatrix**fMPBpre-built matrices; TGeoHMatrix*fMatrix! current matrix; TGeoHMatrix**fMatrixBranchcurrent branch of global matrices; TGeoNode*fNode! current node; TGeoNode**fNodeBranchcurrent branch of nodes; Int_t*fNodeIdArray! array of node id's; TStringfPathpath for current branch; TObjArray*fStackstack of cache states; Int_tfStackLevelcurrent level in the stack; TGeoNode*fToptop node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNodeCache(); Dummy constructor. TGeoNodeCache(TGeoNode* top, Bool_t nodeid = kFALSE, Int_t capacity = 30); Default constructor. ~TGeoNodeCache(); Destructor. void BuildIdArray(); Builds node id array. void BuildInfoBranch(); Bulds info branch. Navigation is possible only after this step. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Bool_t CdDown(Int_t index); Make daugh",MatchSource.WIKI,root/html602/TGeoNodeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoNodeCache.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoNodeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoNodeEditor.html
Usability,undo,undoing,"ic Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNodeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for node editor. ~TGeoNodeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a editable object. void DoSelectMother(); Select the mother volume. void DoSelectVolume(); Select the volume. void DoSelectMatrix(); Select the matrix. void DoEditMother(); Edit the mother volume. void DoEditVolume(); Edit selected volume. void DoEditMatrix(); Edit selected material. void DoNodeName(); Change node name. void DoNodeNumber(); Change node copy number. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. TGeoNodeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoNodeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoNodeEditor.html
Availability,error,error,"10000000000000001, Option_t* option = """")MENU ; voidTGeoNode::CheckShapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tTGeoNode::CountDaughters(Bool_t unique_volumes = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoNode::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTGeoNode::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidTGeoNode::DrawOnly(Option_t* option = """"); voidTGeoNode::DrawOverlaps(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoNode::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); voidTGeoNode::FillIdArray(Int_t& ifree, Int_t& nodeid, Int_t* array) ",MatchSource.WIKI,root/html602/TGeoNodeMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoNodeMatrix.html
Availability,error,error,,MatchSource.WIKI,root/html602/TGeoNodeOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoNodeOffset.html
Performance,perform,perform,"vel in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::AddNodeOverlap(same arguments);. When closing the geometry, overlapping nodes perform a check of possible; overlaps with their neighbours. These are stored and checked all the time; during navigation, therefore navigation is slower when embedding such nodes; into geometry. Node have visualization attributes as volume have. When undefined by users,; painting a node on a pad will take the corresponding volume attributes. /*. */. Function Members (Methods); public:. virtual~TGeoNodeOffset(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGeoNode::Browse(TBrowser* b); virtual voidcd() const; voidTGeoNode::CheckOverlaps(Double_t ovlp = 0.10000000000000001, Option_t* option = """")MENU ; voidTGeoNode::CheckShapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_",MatchSource.WIKI,root/html602/TGeoNodeOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoNodeOffset.html
Testability,log,logical," TGeoNode. A node represent a volume positioned inside another.They store links to both; volumes and to the TGeoMatrix representing the relative positioning. Node are; never instanciated directly by users, but created as a result of volume operations.; Adding a volume named A with a given user ID inside a volume B will create a node; node named A_ID. This will be added to the list of nodes stored by B. Also,; when applying a division operation in N slices to a volume A, a list of nodes; B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from",MatchSource.WIKI,root/html602/TGeoNodeOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoNodeOffset.html
Availability,error,error,"ap(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TGeoHMatrix*GetFirstMatrix() const; TGeoVolume*GetFirstVolume() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t",MatchSource.WIKI,root/html602/TGeoOverlap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoOverlap.html
Energy Efficiency,green,green,"me; TGeoHMatrix*fMatrix2positioning matrix for second volume; TStringTNamed::fNameobject identifier; Double_tfOverlapoverlap distance; TStringTNamed::fTitleobject title; TGeoVolume*fVolume1first volume; TGeoVolume*fVolume2second volume. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoOverlap(); Default ctor. TGeoOverlap(const char* name, TGeoVolume* vol1, TGeoVolume* vol2, const TGeoMatrix* matrix1, const TGeoMatrix* matrix2, Bool_t isovlp = kTRUE, Double_t ovlp = 0.01); Creates a named overlap belonging to volume VOL and having the size OVLP. ~TGeoOverlap(); Destructor. void Browse(TBrowser* b); Define double-click action. Int_t Compare(const TObject* obj) const; Method to compare this overlap with another. Returns :; -1 - this is smaller than OBJ; 0 - equal; 1 - greater. Int_t DistancetoPrimitive(Int_t px, Int_t py); Distance to primitive for an overlap. void Draw(Option_t* option = """"); Draw the overlap. One daughter will be blue, the other green,; extruding points red. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Event interception. void Paint(Option_t* option = """"); Paint the overlap. void Print(Option_t* option = """") const; Print detailed info. void PrintInfo() const; Print some info. void SetNextPoint(Double_t x, Double_t y, Double_t z); Set next overlapping point. void SampleOverlap(Int_t npoints = 1000000); Draw overlap and sample with random points the overlapping region. void Sizeof3D() const; Get 3D size of this. void Validate() const; Validate this overlap. TGeoOverlap(const TGeoOverlap& ). TGeoOverlap& operator=(const TGeoOverlap& ). TPolyMarker3D * GetPolyMarker() const; {return fMarker;}. TGeoVolume * GetFirstVolume() const; {return fVolume1;}. TGeoVolume * GetSecondVolume() const; {return fVolume2;}. TGeoHMatrix * GetFirstMatrix() const; {return fMatrix1;}. TGeoHMatrix * GetSecondMatrix() const; {return fMatrix2;}. Double_t GetOverlap() const; {return fOverlap;}. Bool_t IsExtrusion() const; {retur",MatchSource.WIKI,root/html602/TGeoOverlap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoOverlap.html
Availability,error,error," Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidDrawBatemanSol(TGeoBatemanSol* sol, Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawCurrentPoint(Int_t color); virtual voidDrawOnly(Option_t* option = """"); virtual voidDrawOverlap(void* ovlp, Option_t* option = """"); virtual voidDrawPanel(); virtual voidDrawPath(const char* path, Option_t* option = """"); virtual voidDrawPolygon(const TGeoPolygon* poly); virtual voidDrawShape(TGeoShape* shape, Option_t* option = """"); virtual voidDrawVolume(TGeoVolume* vol, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidEditGeometry(Option_t* option = """"); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidEstimateCameraMove(Double_t tmin, Double_t tmax, Double_t* start, Double_t* end); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteManagerEvent(TGeoManager* geom, Int_t event, Int_t px, Int_t py); virtual voidExecuteShapeEvent(TGeoShape* shape, Int_t event, Int_t px, Int_t py); virtual voidExecuteVolumeEvent(TGeoVolume* volume, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualGeoPainter*TVirtualGeoPainter::GeoPainter(); virtual voidGetBombFactors(Double_t& bombx, Double_t& bomby, Double_t& bombz, Double_t& bombr) const; virtual Int_tGetBombMode() const; virtual TGeoNode*GetCheckedNode(); TGeoChecker*GetChecker(); virtual Int_tGetColor(Int_t base, Float_t light) const; virtual TGeoVolume*GetDrawnVolume() const; virtual Option_t*TObject::GetDraw",MatchSource.WIKI,root/html602/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPainter.html
Deployability,update,update,,MatchSource.WIKI,root/html602/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPainter.html
Integrability,interface,interfaces,". TGeoPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMPAINTER; » TGeoPainter. class TGeoPainter: public TVirtualGeoPainter. TGeoPainter - class implementing all draw interfaces for a generic 3D viewer; using TBuffer3D mechanism. Function Members (Methods); public:. virtual~TGeoPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys); virtual TVirtualGeoTrack*AddTrack(Int_t id, Int_t pdgcode, TObject* part); virtual voidAddTrackPoint(Double_t* point, Double_t* box, Bool_t reset = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBombTranslation(const Double_t* tr, Double_t* bombtr); virtual voidTObject::Browse(TBrowser* b); virtual voidCheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); virtual voidCheckBoundaryReference(Int_t icheck = -1); voidCheckEdit(); virtual voidCheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; virtual voidCheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = __null); virtual voidCheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.10000000000000001, Option_t* option = """") const; virtual voidCheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); virtual voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Int_tCountNodes(TGeoVolume* vol, Int_t level) const; virtual Int_tCountVisibleNodes(); virtual ",MatchSource.WIKI,root/html602/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPainter.html
Modifiability,plugin,plugin,"_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); virtual voidSetCheckedNode(TGeoNode* node); virtual voidSetClippingShape(TGeoShape* shape); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExplodedView(Int_t iopt = 0); virtual voidSetGeoManager(TGeoManager* geom); virtual voidSetIteratorPlugin(TGeoIteratorPlugin* plugin); virtual voidSetNmeshPoints(Int_t npoints); virtual voidSetNsegments(Int_t nseg = 20); static voidTObject::SetObjectStat(Bool_t stat); static voidTVirtualGeoPainter::SetPainter(const TVirtualGeoPainter* painter); virtual voidSetRaytracing(Bool_t flag = kTRUE); virtual voidSetTopVisible(Bool_t vis = kTRUE); virtual voidSetTopVolume(TGeoVolume* vol); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetVisLevel(Int_t level = 3); virtual voidSetVisOption(Int_t option = 0); virtual Int_tShapeDistancetoPrimitive(const TGeoShape* shape, Int_t numpoints, Int_t px, Int_t py) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTest(Int_t npoints, Option_t* option); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTestOverlaps(const char* path); virtual Bool_tTestVoxels(TGeoVolume* vol); TGeoPainter(TGeoManager* manager); TGeoPainter(const TGeoPainter&); virtual voidUnbombTranslation(const Double_t* tr, Double_t* bombtr); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Double_tWeight(Double_t precision, Option_t* option = ""v""); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidClearVisibleVolumes(); virtual v",MatchSource.WIKI,root/html602/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPainter.html
Performance,load,loaded,"tFromOutside back from new point.; Plot d-(d1+d2). void ClearVisibleVolumes(); Clear the list of visible volumes; reset the kVisOnScreen bit for volumes previously in the list. void DefineColors() const; Define 100 colors with increasing light intensities for each basic color (1-7); Register these colors at indexes starting with 1000. Int_t GetColor(Int_t base, Float_t light) const; Get index of a base color with given light intensity (0,1). TGeoVolume * GetDrawnVolume() const; Get currently drawn volume. Int_t DistanceToPrimitiveVol(TGeoVolume* vol, Int_t px, Int_t py); compute the closest distance of approach from point px,py to a volume. void DefaultAngles(); Set default angles for the current view. void DefaultColors(); Set default volume colors according to tracking media. Int_t CountNodes(TGeoVolume* vol, Int_t level) const; Count number of visible nodes down to a given level. Int_t CountVisibleNodes(); Count total number of visible nodes. void CheckEdit(); Check if Ged library is loaded and load geometry editor classe. void EditGeometry(Option_t* option = """"); Start the geometry editor. void Draw(Option_t* option = """"); Draw method. void DrawBatemanSol(TGeoBatemanSol* sol, Option_t* option = """"); Draw the time evolution of a radionuclide. void DrawPolygon(const TGeoPolygon* poly); Draw a polygon in 3D. void DrawVolume(TGeoVolume* vol, Option_t* option = """"); Draw method. void DrawShape(TGeoShape* shape, Option_t* option = """"); Draw a shape. void DrawOverlap(void* ovlp, Option_t* option = """"); Draw an overlap. void DrawOnly(Option_t* option = """"); Draw only one volume. void DrawCurrentPoint(Int_t color); Draw current point in the same view. void DrawPanel(). void DrawPath(const char* path, Option_t* option = """"); Draw all volumes for a given path. void EstimateCameraMove(Double_t tmin, Double_t tmax, Double_t* start, Double_t* end); Estimate camera movement between tmin and tmax for best track display. void ExecuteManagerEvent(TGeoManager* geom, Int_t event, I",MatchSource.WIKI,root/html602/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPainter.html
Testability,test,testNo,"10000000000000001, Option_t* option = """") const; virtual voidCheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); virtual voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Int_tCountNodes(TGeoVolume* vol, Int_t level) const; virtual Int_tCountVisibleNodes(); virtual ",MatchSource.WIKI,root/html602/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPainter.html
Usability,progress bar,progress bar,"view are present and send signal ""Modified"" to pad. void Paint(Option_t* option = """"); Paint current geometry according to option. void PaintOverlap(void* ovlp, Option_t* option = """"); Paint an overlap. void PaintNode(TGeoNode* node, Option_t* option = """", TGeoMatrix* global = 0); Paint recursively a node and its content accordind to visualization options. void PaintVolume(TGeoVolume* vol, Option_t* option = """", TGeoMatrix* global = 0); Paint recursively a node and its content accordind to visualization options. Bool_t PaintShape(const TGeoShape& shape, Option_t* option) const; Paint the supplied shape into the current 3D viewer. void PaintShape(TGeoShape* shape, Option_t* option = """"); Paint an overlap. void PaintPhysicalNode(TGeoPhysicalNode* node, Option_t* option = """"); Paints a physical node associated with a path. void PrintOverlaps() const; Print overlaps (see TGeoChecker::PrintOverlaps()). void OpProgress(const char* opname, Long64_t current, Long64_t size, TStopwatch* watch = 0, Bool_t last = kFALSE, Bool_t refresh = kFALSE, const char* msg = """"); Text progress bar. void RandomPoints(const TGeoVolume* vol, Int_t npoints, Option_t* option = """"); Draw random points in the bounding box of a volume. void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz, const char* target_vol = 0, Bool_t check_norm = kFALSE); Shoot nrays in the current drawn geometry. void Raytrace(Option_t* option = """"); Raytrace current drawn geometry. TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path); shoot npoints randomly in a box of 1E-5 arround current point.; return minimum distance to points outside. void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); --- Set cartesian and radial bomb factors for translations. void SetExplodedView(Int_t iopt = 0); set type of exploding view. void SetNsegments(Int_t nseg = 20); Set number of segments to approximate circles. void SetN",MatchSource.WIKI,root/html602/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPainter.html
Availability,error,error,"p) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetAlpha() const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetA",MatchSource.WIKI,root/html602/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPara.html
Safety,safe,safe,"GeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject",MatchSource.WIKI,root/html602/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPara.html
Testability,test,testNo," virtual~TGeoPara(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(In",MatchSource.WIKI,root/html602/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPara.html
Availability,error,error,"nt_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Double_tDistToParaboloid(const Double_t* point, const Double_t* dir, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::Ge",MatchSource.WIKI,root/html602/TGeoParaboloid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoParaboloid.html
Safety,safe,safe,"tual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Double_tDistToParaboloid(const Double_t* point, const Double_t* dir, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual ",MatchSource.WIKI,root/html602/TGeoParaboloid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoParaboloid.html
Testability,test,testNo," virtual~TGeoParaboloid(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(",MatchSource.WIKI,root/html602/TGeoParaboloid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoParaboloid.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoParaEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoParaEditor.html
Usability,undo,undoing,"c Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoParaEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoParaEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoX(); Slot for X. void DoY(); Slot for Y. void DoZ(); Slot for Z. void DoAlpha(); Slot for alpha. void DoTheta(); Slot for theta. void DoPhi(); Slot for phi. TGeoParaEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoParaEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoParaEditor.html
Availability,error,error,"arallel; world. The parallel world has to be closed before calling any navigation; method. Function Members (Methods); public:. virtual~TGeoParallelWorld(); voidTObject::AbstractMethod(const char* method) const; voidAddNode(TGeoPhysicalNode* pnode); voidAddOverlap(TGeoVolume* vol); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCheckOverlaps(Double_t ovlp = 0.001); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; Bool_tCloseGeometry(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TGeoPhysicalNode*FindNextBoundary(Double_t[3] point, Double_t[3] dir, Double_t& step, Double_t stepmax = 1.0E+30); TGeoPhysicalNode*FindNode(Double_t[3] point); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoManager*GetGeometry() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetO",MatchSource.WIKI,root/html602/TGeoParallelWorld.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoParallelWorld.html
Integrability,interface,interface,". TGeoParallelWorld. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoParallelWorld. class TGeoParallelWorld: public TNamed. TGeoParallelWorld - base class for a flat parallel geometry.; The parallel geometry can be composed by both normal volumes added; using the AddNode interface (not implemented yet) or by physical nodes; which will use as position their actual global matrix with respect to the top; volume of the main geometry.; All these nodes are added as daughters to the ""top"" volume of; the parallel world which acts as a navigation helper in this parallel; world. The parallel world has to be closed before calling any navigation; method. Function Members (Methods); public:. virtual~TGeoParallelWorld(); voidTObject::AbstractMethod(const char* method) const; voidAddNode(TGeoPhysicalNode* pnode); voidAddOverlap(TGeoVolume* vol); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCheckOverlaps(Double_t ovlp = 0.001); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; Bool_tCloseGeometry(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TOb",MatchSource.WIKI,root/html602/TGeoParallelWorld.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoParallelWorld.html
Performance,optimiz,optimization,"NoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TGeoManager*fGeoManager! base geometry; Bool_tfIsClosedClosed flag; TStringTNamed::fNameobject identifier; TObjArray*fPhysicalarray of physical nodes; TStringTNamed::fTitleobject title; Bool_tfUseOverlapsActivated if user defined overlapping candidates; TGeoVolume*fVolumehelper volume. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoParallelWorld(const char* name, TGeoManager* mgr); Default constructor. ~TGeoParallelWorld(); Destructor. void AddNode(TGeoPhysicalNode* pnode); Add a node normally to this world. Overlapping nodes not allowed. void AddOverlap(TGeoVolume* vol); To use this optimization, the user should declare the full list of volumes; which may overlap with any of the physical nodes of the parallel world. Better; be done before misalignment. Bool_t CloseGeometry(); The main geometry must be closed. void RefreshPhysicalNodes(); Refresh the node pointers and re-voxelize. To be called mandatory in case; re-alignment happened. TGeoPhysicalNode * FindNode(Double_t[3] point); Finds physical node containing the point. TGeoPhysicalNode * FindNextBoundary(Double_t[3] point, Double_t[3] dir, Double_t& step, Double_t stepmax = 1.0E+30); Same functionality as TGeoNavigator::FindNextDaughterBoundary for the; parallel world. Double_t Safety(Double_t[3] point, Double_t safmax = 1.0E+30); Compute safety for the parallel world. void CheckOverlaps(Double_t ovlp = 0.001); Check overlaps within a tolerance value. void Draw(Option_t* option); Draw the parallel world. TGeoParallelWorld(const TGeoParallelWorld& ). TGeoParallelWorld& operator=(const TGeoParallelWorld& ). TGeoParallelWorld(); constructors. {}. TGeoManage",MatchSource.WIKI,root/html602/TGeoParallelWorld.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoParallelWorld.html
Safety,safe,safety,"d::fTitleobject title; Bool_tfUseOverlapsActivated if user defined overlapping candidates; TGeoVolume*fVolumehelper volume. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoParallelWorld(const char* name, TGeoManager* mgr); Default constructor. ~TGeoParallelWorld(); Destructor. void AddNode(TGeoPhysicalNode* pnode); Add a node normally to this world. Overlapping nodes not allowed. void AddOverlap(TGeoVolume* vol); To use this optimization, the user should declare the full list of volumes; which may overlap with any of the physical nodes of the parallel world. Better; be done before misalignment. Bool_t CloseGeometry(); The main geometry must be closed. void RefreshPhysicalNodes(); Refresh the node pointers and re-voxelize. To be called mandatory in case; re-alignment happened. TGeoPhysicalNode * FindNode(Double_t[3] point); Finds physical node containing the point. TGeoPhysicalNode * FindNextBoundary(Double_t[3] point, Double_t[3] dir, Double_t& step, Double_t stepmax = 1.0E+30); Same functionality as TGeoNavigator::FindNextDaughterBoundary for the; parallel world. Double_t Safety(Double_t[3] point, Double_t safmax = 1.0E+30); Compute safety for the parallel world. void CheckOverlaps(Double_t ovlp = 0.001); Check overlaps within a tolerance value. void Draw(Option_t* option); Draw the parallel world. TGeoParallelWorld(const TGeoParallelWorld& ). TGeoParallelWorld& operator=(const TGeoParallelWorld& ). TGeoParallelWorld(); constructors. {}. TGeoManager * GetGeometry() const; Getters. {return fGeoManager;}. Bool_t IsClosed() const; {return fIsClosed;}. TGeoVolume * GetVolume() const; {return fVolume;}. » Author: Andrei Gheata 30/06/14 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: Tue Jun 30 15:02:28 2015 » Last generated: 2015-06-30 15:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoParallelWorld.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoParallelWorld.html
Availability,error,error,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html602/TGeoPatternCylPhi.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPatternCylPhi.html
Availability,error,error,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html602/TGeoPatternCylR.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPatternCylR.html
Availability,avail,available," division type which applies only to a given; shape type. The implemented patterns are for the moment equidistant slices; on different axis. Implemented patterns are:. TGeoPatternX - a X axis divison pattern; TGeoPatternY - a Y axis divison pattern; TGeoPatternZ - a Z axis divison pattern; TGeoPatternParaX - a X axis divison pattern for PARA shape; TGeoPatternParaY - a Y axis divison pattern for PARA shape; TGeoPatternParaZ - a Z axis divison pattern for PARA shape; TGeoPatternTrapZ - a Z axis divison pattern for TRAP or GTRA shapes; TGeoPatternCylR - a cylindrical R divison pattern; TGeoPatternCylPhi - a cylindrical phi divison pattern; TGeoPatternSphR - a spherical R divison pattern; TGeoPatternSphTheta - a spherical theta divison pattern; TGeoPatternSphPhi - a spherical phi divison pattern; TGeoPatternHoneycomb - a divison pattern specialized for honeycombs. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoPatternFinder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t); virtual TGeoNode*CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidCreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual vo",MatchSource.WIKI,root/html602/TGeoPatternFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPatternFinder.html
Availability,error,error,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tTGeoPatternFinder::GetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffs",MatchSource.WIKI,root/html602/TGeoPatternHoneycomb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPatternHoneycomb.html
Availability,error,error,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html602/TGeoPatternParaX.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPatternParaX.html
Availability,error,error,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html602/TGeoPatternParaY.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPatternParaY.html
Availability,error,error,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html602/TGeoPatternParaZ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPatternParaZ.html
Availability,error,error,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html602/TGeoPatternSphPhi.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPatternSphPhi.html
Availability,error,error,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html602/TGeoPatternSphR.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPatternSphR.html
Availability,error,error,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html602/TGeoPatternSphTheta.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPatternSphTheta.html
Availability,error,error,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html602/TGeoPatternTrapZ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPatternTrapZ.html
Availability,error,error,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tFindNextBoundary(Double_t* point, Double_t* dir, Int_t& indnext); virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternF",MatchSource.WIKI,root/html602/TGeoPatternX.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPatternX.html
Availability,error,error,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tFindNextBoundary(Double_t* point, Double_t* dir, Int_t& indnext); virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternF",MatchSource.WIKI,root/html602/TGeoPatternY.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPatternY.html
Availability,error,error,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tFindNextBoundary(Double_t* point, Double_t* dir, Int_t& indnext); virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternF",MatchSource.WIKI,root/html602/TGeoPatternZ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPatternZ.html
Availability,error,error," 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSegZ(const Double_t* point, const Double_t* dir, Int_t& iz) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tGetDphi() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) ",MatchSource.WIKI,root/html602/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPcon.html
Performance,perform,performed,"le_t* dir, Int_t& iz) const; compute distance to a pcon Z slice. Segment iz must be valid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube. void DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); Defines z position of a section plane, rmin and rmax at this z. Sections; should be defined in increasing or decreasing Z order and the last section; HAS to be snum = fNz-1. Int_t GetNsegments() const; Returns number of segments on each mesh circle segment. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this polycone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. Z divisions can be; performed if the divided range is in between two consecutive Z planes.; In case a wrong division axis is supplied, returns pointer to; volume that was divided. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetRmin(Int_t ipl) const; Returns Rmin for Z segment IPL. Double_t GetRmax(Int_t ipl) const; Returns Rmax for Z segment IPL. Double_t GetZ(Int_t ipl) const; Returns Z for segment IPL. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t SafetyToSegment(const Double_t* point, Int_t ",MatchSource.WIKI,root/html602/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPcon.html
Safety,safe,safe,"char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidDefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSegZ(const Double_t* point, const Double_t* dir, Int_t& iz) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU",MatchSource.WIKI,root/html602/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPcon.html
Testability,test,testNo," virtual~TGeoPcon(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidDefineSection(Int_t snum, Double_t z, Double",MatchSource.WIKI,root/html602/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPcon.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoPconEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPconEditor.html
Usability,undo,undoing,"tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPconEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for polycone editor. ~TGeoPconEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a given pcon. void CreateSections(Int_t inew); Change dynamically the number of sections. Bool_t CheckSections(Bool_t change = kFALSE); Check validity of sections. void UpdateSections(); Update sections according fShape. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoSectionChange(Int_t i); Change parameters of section isect;. void DoNz(); Change number of sections. void DoPhi(); Change phi range. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void CreateEdges(); {;}. TGeoPconEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoPconEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPconEditor.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tT",MatchSource.WIKI,root/html602/TGeoPconSection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPconSection.html
Availability,error,error,"TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoPcon::DistToSegZ(const Double_t* point, const Double_t* dir, Int_t& iz) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&TGeoPcon::Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoPcon::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoPcon::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tTGeoPcon::GetDphi() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::",MatchSource.WIKI,root/html602/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPgon.html
Performance,perform,performed,"lice(const Double_t* point, const Double_t* dir, Int_t iphi, Double_t sstart, Int_t& ipl, Double_t& snext, Double_t stepmax) const; Check crossing of a given pgon slice, from a starting point inside the slice. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the polygone. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this polygone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. Phi divisions are; allowed only if nedges%ndiv=0 and create polygone ""segments"" with nedges/ndiv edges.; Z divisions can be performed if the divided range is in between two consecutive Z planes.; In case a wrong division axis is supplied, returns pointer to volume that was divided. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. void InspectShape() const; Inspect the PGON parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Rpg(Double_t z, Int_t ipl, Bool_t inner, Double_t& a, Double_t& b) const; Computes projected pgon radius (inner or outer) corresponding to a given Z; value. Fills corresponding coefficients of:; Rpg(z) = a + b*z; Note: ipl must be in range [0,fNz-2]. Double_t Rproj(Double_t z, const Double_t* point, const Double_t* dir, Double_t cphi, Double_t sphi, Double_t& a, Double_t& b) const; Computes projected distance at ",MatchSource.WIKI,root/html602/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPgon.html
Safety,safe,safe,"wname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidCreateThreadData(Int_t nthreads); virtual voidTGeoPcon::DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoPcon::DistToSegZ(const Double_t* point, const Double_t* dir, Int_t& iz) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&TGeoPcon::Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* op",MatchSource.WIKI,root/html602/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPgon.html
Testability,test,testNo," virtual~TGeoPgon(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; vir",MatchSource.WIKI,root/html602/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPgon.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoPgonEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPgonEditor.html
Usability,undo,undoing,"Frame::fXframe x position; Int_tTGFrame::fYframe y position; Double_t*TGeoPconEditor::fZiInitial Z positions; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPgonEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for polycone editor. ~TGeoPgonEditor(); Destructor. void SetModel(TObject* obj); Connect to a given pcon. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. void CreateEdges(); Create number entry for Nedges. void DoNedges(); Change number of edges. TGeoPgonEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoPgonEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPgonEditor.html
Availability,error,error,,MatchSource.WIKI,root/html602/TGeoPhysicalNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPhysicalNode.html
Performance,perform,perform,"lor_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArray*fMatricesglobal transformation matrices; TGeoHMatrix*fMatrixOrigoriginal local matrix of the last node in the path; TStringTNamed::fNameobject identifier; TObjArray*fNodesbranch of nodes; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPhysicalNode(); Default constructor. TGeoPhysicalNode(const char* path); Constructor. TGeoPhysicalNode(const TGeoPhysicalNode& ); copy constructor. TGeoPhysicalNode& operator=(const TGeoPhysicalNode& ); assignment operator. ~TGeoPhysicalNode(); Destructor. Bool_t Align(TGeoMatrix* newmat = 0, TGeoShape* newshape = 0, Bool_t check = kFALSE, Double_t ovlp = 0.001); Align a physical node with a new relative matrix/shape.; Example: /TOP_1/A_1/B_1/C_1; node->Align(transl_1, box) will perform:; - change RELATIVE translation of C_1 node (with respect to its; container volume B) to transl_1; - change the shape of the C volume; *NOTE* The operations will affect ONLY the LAST node in the branch. All; volumes/nodes in the branch represented by this physical node are; CLONED so the operation does not affect other possible replicas. void cd() const. void Draw(Option_t* option = """"); Draw this node. TGeoNode * GetMother(Int_t levup = 1) const; Return parent at LEVUP generation. TGeoHMatrix * GetMatrix(Int_t level = -1) const; Return global matrix for node at LEVEL. TGeoNode * GetNode(Int_t level = -1) const; Return node in branch at LEVEL. If not specified, return last leaf. TGeoVolume * GetVolume(Int_t level = -1) const; Return volume associated with node at LEVEL in the branch. TGeoShape * GetShape(Int_t level = -1) const; Return shape associated with volume. void Paint(Option_t* option = """"); Paint this node and its content according to visualization settings. void Print(Option_t* option = """") const; Print info about this node. void Refresh();",MatchSource.WIKI,root/html602/TGeoPhysicalNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPhysicalNode.html
Safety,detect,detector,". TGeoPhysicalNode. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoPhysicalNode. class TGeoPhysicalNode: public TNamed, public TAttLine. TGeoPhysicalNode, TGeoPNEntry. Physical nodes are the actual 'touchable' objects in the geometry, representing; a path of positioned volumes starting with the top node:; path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes.; The number of physical nodes is given by the total number of possible of; branches in the geometry hierarchy. In case of detector geometries and; specially for calorimeters this number can be of the order 1e6-1e9, therefore; it is impossible to create all physical nodes as objects in memory. In TGeo,; physical nodes are represented by the class TGeoPhysicalNode and can be created; on demand for alignment purposes:. TGeoPhysicalNode *pn = new TGeoPhysicalNode(""path_to_object""). Once created, a physical node can be misaligned, meaning that its position; or even shape can be changed:. pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE). The knowledge of the path to the objects that need to be misaligned is; essential since there is no other way of identifying them. One can however; create 'symbolic links' to any complex path to make it more representable; for the object it designates:. TGeoPNEntry *pne = new TGeoPNEntry(""TPC_SECTOR_2"", ""path_to_tpc_sect2"");; pne->SetPhysicalNode(pn). Such a symbolic link hides the complexity of the path to the align object and; replaces it with a more meaningful name. In addition, TGeoPNEntry objects are; faster to search by name and they may optionally store an additional user; matrix. For more details please read the misalignment section in the Users Guide. Function Members (Methods); public:. virtual~TGeoPhysicalNode(); voidTObject::AbstractMethod(const char* met",MatchSource.WIKI,root/html602/TGeoPhysicalNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPhysicalNode.html
Availability,error,error, virtual~TGeoPNEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::Appe,MatchSource.WIKI,root/html602/TGeoPNEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPNEntry.html
Safety,detect,detector,". TGeoPNEntry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoPNEntry. class TGeoPNEntry: public TNamed. TGeoPhysicalNode, TGeoPNEntry. Physical nodes are the actual 'touchable' objects in the geometry, representing; a path of positioned volumes starting with the top node:; path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes.; The number of physical nodes is given by the total number of possible of; branches in the geometry hierarchy. In case of detector geometries and; specially for calorimeters this number can be of the order 1e6-1e9, therefore; it is impossible to create all physical nodes as objects in memory. In TGeo,; physical nodes are represented by the class TGeoPhysicalNode and can be created; on demand for alignment purposes:. TGeoPhysicalNode *pn = new TGeoPhysicalNode(""path_to_object""). Once created, a physical node can be misaligned, meaning that its position; or even shape can be changed:. pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE). The knowledge of the path to the objects that need to be misaligned is; essential since there is no other way of identifying them. One can however; create 'symbolic links' to any complex path to make it more representable; for the object it designates:. TGeoPNEntry *pne = new TGeoPNEntry(""TPC_SECTOR_2"", ""path_to_tpc_sect2"");; pne->SetPhysicalNode(pn). Such a symbolic link hides the complexity of the path to the align object and; replaces it with a more meaningful name. In addition, TGeoPNEntry objects are; faster to search by name and they may optionally store an additional user; matrix. For more details please read the misalignment section in the Users Guide. Function Members (Methods); public:. virtual~TGeoPNEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::Appe",MatchSource.WIKI,root/html602/TGeoPNEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPNEntry.html
Availability,error,error," virtual~TGeoPolygon(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_tArea() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() con",MatchSource.WIKI,root/html602/TGeoPolygon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoPolygon.html
Availability,avail,available,". TGeoRCExtension. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoRCExtension. class TGeoRCExtension: public TGeoExtension. TGeoExtension - ABC for user objects attached to TGeoVolume or TGeoNode.; Provides interface for getting a reference (grab) and; releasing the extension object (release), allowing for; derived classes to implement reference counted sharing.; The user who should attach extensions to logical volumes; or nodes BEFORE applying misalignment information so that; these will be available to all copies. Function Members (Methods); public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const T",MatchSource.WIKI,root/html602/TGeoRCExtension.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoRCExtension.html
Deployability,release,release,". TGeoRCExtension. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoRCExtension. class TGeoRCExtension: public TGeoExtension. TGeoExtension - ABC for user objects attached to TGeoVolume or TGeoNode.; Provides interface for getting a reference (grab) and; releasing the extension object (release), allowing for; derived classes to implement reference counted sharing.; The user who should attach extensions to logical volumes; or nodes BEFORE applying misalignment information so that; these will be available to all copies. Function Members (Methods); public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const T",MatchSource.WIKI,root/html602/TGeoRCExtension.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoRCExtension.html
Integrability,interface,interface,". TGeoRCExtension. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoRCExtension. class TGeoRCExtension: public TGeoExtension. TGeoExtension - ABC for user objects attached to TGeoVolume or TGeoNode.; Provides interface for getting a reference (grab) and; releasing the extension object (release), allowing for; derived classes to implement reference counted sharing.; The user who should attach extensions to logical volumes; or nodes BEFORE applying misalignment information so that; these will be available to all copies. Function Members (Methods); public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const T",MatchSource.WIKI,root/html602/TGeoRCExtension.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoRCExtension.html
Testability,log,logical,". TGeoRCExtension. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoRCExtension. class TGeoRCExtension: public TGeoExtension. TGeoExtension - ABC for user objects attached to TGeoVolume or TGeoNode.; Provides interface for getting a reference (grab) and; releasing the extension object (release), allowing for; derived classes to implement reference counted sharing.; The user who should attach extensions to logical volumes; or nodes BEFORE applying misalignment information so that; these will be available to all copies. Function Members (Methods); public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const T",MatchSource.WIKI,root/html602/TGeoRCExtension.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoRCExtension.html
Availability,error,error,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. virtual~TGeoRotation(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Clas",MatchSource.WIKI,root/html602/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoRotation.html
Integrability,interface,interface," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html602/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoRotation.html
Modifiability,variab,variable,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. virtual~TGeoRotation(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeterminant() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voi",MatchSource.WIKI,root/html602/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoRotation.html
Performance,optimiz,optimize,". TGeoRotation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoRotation. class TGeoRotation: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: I",MatchSource.WIKI,root/html602/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoRotation.html
Testability,test,test,"& other); Copy ctor. TGeoRotation(const TGeoMatrix& other); Copy ctor. TGeoRotation(const char* name); Named rotation constructor. TGeoRotation(const char* name, Double_t phi, Double_t theta, Double_t psi); Default rotation constructor with Euler angles. Phi is the rotation angle about; Z axis and is done first, theta is the rotation about new Y and is done; second, psi is the rotation angle about new Z and is done third. All angles are in; degrees. TGeoRotation(const char* name, Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3); Rotation constructor a la GEANT3. Angles theta(i), phi(i) are the polar and azimuthal; angles of the (i) axis of the rotated system with respect to the initial non-rotated; system.; Example : the identity matrix (no rotation) is composed by; theta1=90, phi1=0, theta2=90, phi2=90, theta3=0, phi3=0; SetBit(kGeoRotation);. TGeoMatrix& Inverse() const; Return a temporary inverse of this. Bool_t IsValid() const; Perform orthogonality test for rotation. void Clear(Option_t* option = """"); reset data members. void FastRotZ(const Double_t* sincos); Perform a rotation about Z having the sine/cosine of the rotation angle. Double_t GetPhiRotation(Bool_t fixX = kFALSE) const; --- Returns rotation angle about Z axis in degrees. If the rotation is a pure; rotation about Z, fixX parameter does not matter, otherwise its meaning is:; - fixX = true : result is the phi angle of the projection of the rotated X axis in the un-rotated XY; - fixX = false : result is the phi angle of the projection of the rotated Y axis - 90 degrees. void LocalToMaster(const Double_t* local, Double_t* master) const; convert a point by multiplying its column vector (x, y, z, 1) to matrix inverse. void MasterToLocal(const Double_t* master, Double_t* local) const; convert a point by multiplying its column vector (x, y, z, 1) to matrix. TGeoMatrix * MakeClone() const; Make a clone of this matrix. void RotateX(Double_t angle); Rotate about X ",MatchSource.WIKI,root/html602/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoRotation.html
Usability,simpl,simple,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html602/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoRotation.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoRotationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoRotationEditor.html
Usability,undo,undoing,"GFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoRotationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for rotation editor. ~TGeoRotationEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected rotation. void DoName(); Slot for name. void DoRotPhi(); Slot for phi (Euler X convention). void DoRotTheta(); Slot for theta (Euler X convention). void DoRotPsi(); Slot for psi (Euler X convention). void DoRotAngle(); Slot for additional rotation about one axis. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying modifications. void DoCancel(); Slot for cancelling last un-applied operations. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last changes. TGeoRotationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoRotationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoRotationEditor.html
Availability,error,error,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. virtual~TGeoScale(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class()",MatchSource.WIKI,root/html602/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoScale.html
Integrability,interface,interface," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html602/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoScale.html
Modifiability,variab,variable,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. virtual~TGeoScale(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const ",MatchSource.WIKI,root/html602/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoScale.html
Performance,optimiz,optimize,". TGeoScale. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoScale. class TGeoScale: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse sc",MatchSource.WIKI,root/html602/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoScale.html
Usability,simpl,simple,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html602/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoScale.html
Availability,error,error,"p) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoBBox::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(In",MatchSource.WIKI,root/html602/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoScaledShape.html
Safety,safe,safe,"tual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject",MatchSource.WIKI,root/html602/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoScaledShape.html
Testability,test,testNo," virtual~TGeoScaledShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Dou",MatchSource.WIKI,root/html602/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoScaledShape.html
Availability,avail,available,"outwards or inwards; shape respectively. Normal components are statically stored by shape class,; so it has to be copied after retreival in a different array. Dividing shapes. Shapes can generally be divided along a given axis. Supported axis are; X, Y, Z, Rxy, Phi, Rxyz. A given shape cannot be divided however on any axis.; The general rule is that that divisions are possible on whatever axis that; produces still known shapes as slices. The division of shapes should not be; performed by TGeoShape::Divide() calls, but rather by TGeoVolume::Divide().; The algorithm for dividing a specific shape is known by the shape object, but; is always invoked in a generic way from the volume level. Details on how to; do that can be found in TGeoVolume class. One can see how all division options; are interpreted and which is their result inside specific shape classes. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidAfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Double_tBig(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidCheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t*, const Double_t*, Double_t*, Int_t); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t*, Bool_t*, Int_t) const; virtu",MatchSource.WIKI,root/html602/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoShape.html
Performance,perform,performed,"uble_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E) Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside). - returns director cosines of normal to the crossed shape surface from a; given point towards a direction. One has to specify if the point is inside; or outside shape. According to this, the normal will be outwards or inwards; shape respectively. Normal components are statically stored by shape class,; so it has to be copied after retreival in a different array. Dividing shapes. Shapes can generally be divided along a given axis. Supported axis are; X, Y, Z, Rxy, Phi, Rxyz. A given shape cannot be divided however on any axis.; The general rule is that that divisions are possible on whatever axis that; produces still known shapes as slices. The division of shapes should not be; performed by TGeoShape::Divide() calls, but rather by TGeoVolume::Divide().; The algorithm for dividing a specific shape is known by the shape object, but; is always invoked in a generic way from the volume level. Details on how to; do that can be found in TGeoVolume class. One can see how all division options; are interpreted and which is their result inside specific shape classes. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidAfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Double_tBig(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidCheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); v",MatchSource.WIKI,root/html602/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoShape.html
Safety,safe,safe,". TGeoShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoShape. class TGeoShape: public TNamed. TGeoShape - Base abstract class for all shapes. Shapes are geometrical objects that provide the basic modelling; functionality. They provide the definition of the LOCAL frame of coordinates,; with respect to which they are defined. Any implementation of a shape deriving; from the base TGeoShape class has to provide methods for :; - finding out if a point defined in their local frame is or not contained; inside;; - computing the distance from a local point to getting outside/entering the; shape, given a known direction;; - computing the maximum distance in any direction from a local point that; does NOT result in a boundary crossing of the shape (safe distance);; - computing the cosines of the normal vector to the crossed shape surface,; given a starting local point and an ongoing direction.; All the features above are globally managed by the modeller in order to; provide navigation functionality. In addition to those, shapes have also to; implement additional specific abstract methods :; - computation of the minimal box bounding the shape, given that this box have; to be aligned with the local coordinates;; - algorithms for dividing the shape along a given axis and producing resulting; divisions volumes. The modeler currently provides a set of 16 basic shapes, which we will call; primitives. It also provides a special class allowing the creation of shapes; made as a result of boolean operations between primitives. These are called; composite shapes and the composition operation can be recursive (composition; of composites). This allows the creation of a quite large number of different; shape topologies and combinations. Shapes are named objects and register themselves to the manager cl",MatchSource.WIKI,root/html602/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoShape.html
Security,access,accessible,"; - computation of the minimal box bounding the shape, given that this box have; to be aligned with the local coordinates;; - algorithms for dividing the shape along a given axis and producing resulting; divisions volumes. The modeler currently provides a set of 16 basic shapes, which we will call; primitives. It also provides a special class allowing the creation of shapes; made as a result of boolean operations between primitives. These are called; composite shapes and the composition operation can be recursive (composition; of composites). This allows the creation of a quite large number of different; shape topologies and combinations. Shapes are named objects and register themselves to the manager class at; creation time. This is responsible for their final deletion. Shapes; can be created without name if their retreival by name is no needed. Generally; shapes are objects that are usefull only at geometry creation stage. The pointer; to a shape is in fact needed only when referring to a given volume and it is; always accessible at that level. A shape may be referenced by several volumes,; therefore its deletion is not possible once volumes were defined based on it. Creating shapes. Shape objects embeed only the minimum set of parameters that are fully; describing a valid physical shape. For instance, a tube is represented by; its half length, the minimum radius and the maximum radius. Shapes are used; togeather with media in order to create volumes, which in their turn; are the main components of the geometrical tree. A specific shape can be created; stand-alone :. TGeoBBox *box = new TGeoBBox(""s_box"", halfX, halfY, halfZ); // named; TGeoTube *tub = new TGeoTube(rmin, rmax, halfZ); // no name; ... (see each specific shape constructors). Sometimes it is much easier to create a volume having a given shape in one; step, since shapes are not direcly linked in the geometrical tree but volumes; are :. TGeoVolume *vol_box = gGeoManager->MakeBox(""BOX_VOL"", ""mat1"", halfX",MatchSource.WIKI,root/html602/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoShape.html
Testability,test,testNo,,MatchSource.WIKI,root/html602/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoShape.html
Availability,error,error,"p) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoBBox::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFa",MatchSource.WIKI,root/html602/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoShapeAssembly.html
Safety,safe,safe,"tual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject",MatchSource.WIKI,root/html602/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoShapeAssembly.html
Testability,test,testNo," virtual~TGeoShapeAssembly(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tTGeoBBox::Capacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* di",MatchSource.WIKI,root/html602/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoShapeAssembly.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html602/TGeoShapeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoShapeDialog.html
Availability,error,error,"Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSphere(const Double_t* point, const Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoB",MatchSource.WIKI,root/html602/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoSphere.html
Safety,safe,safe,"tual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSphere(const Double_t* point, const Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::Draw",MatchSource.WIKI,root/html602/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoSphere.html
Testability,test,testNo," virtual~TGeoSphere(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")ME",MatchSource.WIKI,root/html602/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoSphere.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoSphereEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoSphereEditor.html
Usability,undo,undoing,"rimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoSphereEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for sphere editor. ~TGeoSphereEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a given sphere. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoRmin(); Slot for Rmin. void DoRmax(); Slot for Rmax. void DoPhi1(); Slot for phi1. void DoPhi2(); Slot for phi2. void DoPhi(); Slot for phi slider. void DoTheta1(); Slot for theta1. void DoTheta2(); Slot for theta2. void DoTheta(); Slot for theta slider. TGeoSphereEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoSphereEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoSphereEditor.html
Availability,error,error,"const Double_t* dir, Double_t* norm); virtual Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; voidTGeoBoolNode::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*TGeoBoolNode::GetRightMatrix() const; TGeoShape*TGeoBoolNode::GetRightShape() const; TGeoBoolNode::ThreadData_t&TGeoBool",MatchSource.WIKI,root/html602/TGeoSubtraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoSubtraction.html
Safety,safe,safe,"; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoBoolNode::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; voidTGeoBoolNode::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject",MatchSource.WIKI,root/html602/TGeoSubtraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoSubtraction.html
Availability,error,error," virtual~TGeoTabManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidCleanup(TGCompositeFrame* frame); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error =",MatchSource.WIKI,root/html602/TGeoTabManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTabManager.html
Availability,error,error,"p) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tGetDphi() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) ",MatchSource.WIKI,root/html602/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTorus.html
Safety,safe,safe,"psMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); Double_tDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Double_tDDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Double_tDDDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject",MatchSource.WIKI,root/html602/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTorus.html
Testability,test,testNo," virtual~TGeoTorus(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); Double_tDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Double_tDDaxis(const Double_t* pt, const Double_t* dir, Double_t t",MatchSource.WIKI,root/html602/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTorus.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoTorusEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTorusEditor.html
Usability,undo,undoing,":fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTorusEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for torus editor. ~TGeoTorusEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoR(); Slot for R. void DoRmin(); Slot for Rmin. void DoRmax(); Slot for Rmax. void DoPhi1(); Slot for phi. void DoDphi(); Slot for Dphi. TGeoTorusEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoTorusEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTorusEditor.html
Availability,error,error,"Double_t nframes = 200, Option_t* option = ""/*"")MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TVirtualGeoTrack*TVirtualGeoTrack::FindTrackWithId(Int_t id) const; TVirtualGeoTrack*TVirtualGeoTrack::GetDaughter(Int_t index) const; virtual Int_tTVirtualGeoTrack::GetDaughterId(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const Double_t*TVirtualGeoTrack::GetFirstPoint() const; virtual const char*TObject::GetIconName() const; Int_tTVirtualGeoTrack::GetId() const; const Double_t*TVirtualGeoTrack::GetLastPoint() const; Int_tTVirtualGeoTrack::GetLastPoint(Double_t& x, Double_t& y, Double_t& z, Double_t& t) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tT",MatchSource.WIKI,root/html602/TGeoTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTrack.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html602/TGeoTransientPanel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTransientPanel.html
Availability,error,error,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. virtual~TGeoTranslation(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TGeoTranslation* other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObjec",MatchSource.WIKI,root/html602/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTranslation.html
Integrability,interface,interface," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html602/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTranslation.html
Modifiability,variab,variable,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. virtual~TGeoTranslation(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TGeoTranslation* other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfm",MatchSource.WIKI,root/html602/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTranslation.html
Performance,optimiz,optimize,". TGeoTranslation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoTranslation. class TGeoTranslation: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1.",MatchSource.WIKI,root/html602/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTranslation.html
Usability,simpl,simple,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html602/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTranslation.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoTranslationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTranslationEditor.html
Usability,undo,undoing,":fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTranslationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for translation editor. ~TGeoTranslationEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the new matrix. void DoName(); Slot for name. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying changes. void DoCancel(); Slot for cancelling last modifications non-applied. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for dx. void DoDy(); Slot for dx. void DoDz(); Slot for dx. TGeoTranslationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoTranslationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTranslationEditor.html
Availability,error,error,"ouble_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetAlpha1() const; Double_tGetAlpha2() const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoArb8::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Double_tGetBl1() const; Double_tGetBl2() const; virtual voidTGeoArb8::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoArb8::GetByteCount() const; Double_tTGeoArb8::GetClosestEdge(const Double_t* point, Double_t* vert, Int_t& isegment) const; virtual Option_t*TObject::GetDrawOption() ",MatchSource.WIKI,root/html602/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTrap.html
Safety,safe,safe,"name = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidTGeoArb8::ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(const Double_t* point) const; virtual voidTGeoArb8::Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") cons",MatchSource.WIKI,root/html602/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTrap.html
Testability,test,testNo," virtual~TGeoTrap(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tTGeoArb8::Capacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compar",MatchSource.WIKI,root/html602/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTrap.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoTrapEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTrapEditor.html
Usability,undo,undoing,"n SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrapEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoTrapEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoH1(); Slot for H1. void DoBl1(); Slot for Bl1. void DoTl1(); Slot for Tl1. void DoDz(); Slot for Z. void DoSc1(); Slot for H2. void DoSc2(); Slot for H2. void DoAlpha1(); Slot for alpha1. void DoTheta(); Slot for theta. void DoPhi(); Slot for phi. TGeoTrapEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoTrapEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTrapEditor.html
Availability,error,error,"p) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; Double_tGetDx1() const; Double_tGetDx2() const; Double_tGetDy() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDz() const; virtual ",MatchSource.WIKI,root/html602/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTrd1.html
Safety,safe,safe,"GeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject",MatchSource.WIKI,root/html602/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTrd1.html
Testability,test,testNo," virtual~TGeoTrd1(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int",MatchSource.WIKI,root/html602/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTrd1.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoTrd1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTrd1Editor.html
Usability,undo,undoing,"BckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd1 editor. ~TGeoTrd1Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy(); Slot for dy. void DoDz(); Slot for dz. TGeoTrd1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoTrd1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTrd1Editor.html
Availability,error,error,"p) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; Double_tGetDx1() const; Double_tGetDx2() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDy1() const; Double_tGetDy2() const; Double",MatchSource.WIKI,root/html602/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTrd2.html
Safety,safe,safe,"GeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject",MatchSource.WIKI,root/html602/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTrd2.html
Testability,test,testNo," virtual~TGeoTrd2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(In",MatchSource.WIKI,root/html602/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTrd2.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoTrd2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTrd2Editor.html
Usability,undo,undoing,"Frame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd2 editor. ~TGeoTrd2Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy1(); Slot for dy1. void DoDy2(); Slot for dy2. void DoDz(); Slot for dz. TGeoTrd2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoTrd2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTrd2Editor.html
Availability,avail,available,"inks:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMBUILDER; » TGeoTreeDialog. class TGeoTreeDialog: public TGTransientFrame. TGeoTabManager - manager for all editor tabs. TGeoTreeDialog - Base class for dialog frames for selecting objects; with a tree hierarchy. Specific implementations are:; TGeoVolumeDialog - Special tree dialog class for selecting volumes.; TGeoShapeDialog - Special tree dialog class for selecting shapes.; TGeoMediumDialog - Special tree dialog class for selecting media.; TGeoMaterialDialog - Special tree dialog class for selecting materials.; TGeoMatrixDialog - Special tree dialog class for selecting matrices.; TGeoTransientPanel - Special transient tab holding TGeo editors. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoTreeDialog(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); st",MatchSource.WIKI,root/html602/TGeoTreeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTreeDialog.html
Availability,error,error,"irs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidDistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index",MatchSource.WIKI,root/html602/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTube.html
Safety,safe,safe,"ompare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidDistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* ",MatchSource.WIKI,root/html602/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTube.html
Testability,test,testNo," virtual~TGeoTube(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t rmin, Double_t rmax, Double_t dz); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point,",MatchSource.WIKI,root/html602/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTube.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoTubeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTubeEditor.html
Usability,undo,undoing,"const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube editor. ~TGeoTubeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoRmin(); Slot for rmin. void DoRmax(); Slot for rmax. void DoDz(); Slot for dz. TGeoTubeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoTubeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTubeEditor.html
Availability,error,error,"e_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetF",MatchSource.WIKI,root/html602/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTubeSeg.html
Safety,safe,safe,"eBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm,",MatchSource.WIKI,root/html602/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTubeSeg.html
Testability,test,testNo," virtual~TGeoTubeSeg(); voidTObject::AbstractMethod(const char* method) const; virtual voidAfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidCompu",MatchSource.WIKI,root/html602/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTubeSeg.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGeoTubeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTubeSegEditor.html
Usability,undo,undoing,"nt_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeSegEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube segment editor. ~TGeoTubeSegEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoPhi1(); Slot for phi1. void DoPhi2(); Slot for phi2. void DoPhi(); Slot for phi slider. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. TGeoTubeSegEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGeoTubeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoTubeSegEditor.html
Availability,error,error," virtual~TGeoUniformMagField(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidField(const Double_t*, Double_t* B); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const Double_t*GetFieldValue() const; virtual const char*TObject::GetIconName() con",MatchSource.WIKI,root/html602/TGeoUniformMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoUniformMagField.html
Availability,error,error,"const Double_t* dir, Double_t* norm); virtual Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; voidTGeoBoolNode::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*TGeoBoolNode::GetRightMatrix() const; TGeoShape*TGeoBoolNode::GetRightShape() const; TGeoBoolNode::ThreadData_t&TGeoBool",MatchSource.WIKI,root/html602/TGeoUnion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoUnion.html
Safety,safe,safe,"; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoBoolNode::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; voidTGeoBoolNode::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject",MatchSource.WIKI,root/html602/TGeoUnion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoUnion.html
Availability,error,error,"ke box, trd1, trd2, trap, gtra or para - 1,2,3 means X,Y,Z; for; tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and; pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi.; In fact, the division operation has the same effect as positioning volumes; in a given order inside the divided container - the advantage being that the; navigation in such a structure is much faster. When a volume is divided, a; volume family corresponding to the slices is created. In case all slices can; be represented by a single shape, only one volume is added to the family and; positioned N times inside the divided volume, otherwise, each slice will be; represented by a distinct volume in the family.; Divisions can be also performed in a given range of one axis. For that, one; have to specify also the starting coordinate value and the step:. TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N, start, step);. A check is always done on the resulting division range : if not fitting into; the container limits, an error message is posted. If we will browse the divided; volume we will notice that it will contain N nodes starting with index 1 upto; N. The first one has the lower X limit at START position, while the last one; will have the upper X limit at START+N*STEP. The resulting slices cannot; be positioned inside an other volume (they are by default positioned inside the; divided one) but can be further divided and may contain other volumes:. TGeoVolume *slicey = slicex->Divide(""SLICEY"", 2, N1);; slicey->AddNode(other_vol, index, some_matrix);. When doing that, we have to remember that SLICEY represents a family, therefore; all members of the family will be divided on Y and the other volume will be; added as node inside all.; In the example above all the resulting slices had the same shape as the; divided volume (box). This is not always the case. For instance, dividing a; volume with TUBE shape on PHI axis will create equal slices having TUBESEG; shape",MatchSource.WIKI,root/html602/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolume.html
Deployability,release,released,"e_t themax = 180., Int_t nphi = 60, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RegisterYourself(Option_t* option = """"); Register the volume and all materials/media/matrices/shapes to the manager. void RandomPoints(Int_t npoints = 1000000, Option_t* option = """"); Draw random points in the bounding box of this volume. void RandomRays(Int_t nrays = 10000, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0, const char* target_vol = 0, Bool_t check_norm = kFALSE); Random raytracing method. void Raytrace(Bool_t flag = kTRUE); Draw this volume with current settings and perform raytracing in the pad. void SaveAs(const char* filename, Option_t* option = """") const; Save geometry having this as top volume as a C++ macro. void SetUserExtension(TGeoExtension* ext); Connect user-defined extension to the volume. The volume ""grabs"" a copy, so; the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for user extensions and is guaranteed not; to be used by TGeo. void SetFWExtension(TGeoExtension* ext); Connect framework defined extension to the volume. The volume ""grabs"" a copy,; so the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for the use by TGeo and the users should; NOT connect extensions using this method. TGeoExtension * GrabUserExtension() const; Get a copy of the user extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). TGeoExtension * GrabFWExtension() const; Get a copy of the framework extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). void SavePrimitiv",MatchSource.WIKI,root/html602/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolume.html
Energy Efficiency,efficient,efficient,"GeoTranslation(-0.2,0,0));; chamber->AddNode(wire_co, 2, new TGeoTranslation(0.2,0,0));. The 2 nodes that we have created inside chamber will both point to a wire_co; object, but will be completely distinct : WIRE_CO_1 and WIRE_CO_2. We will; want now to place symetrically 1000 chambers on a pad, following a pattern; of 20 rows and 50 columns. One way to do this will be to replicate our chamber; by positioning it 1000 times in different positions of the pad. Unfortunatelly,; this is far from being the optimal way of doing what we want.; Imagine that we would like to find out which of the 1000 chambers is containing; a (x,y,z) point defined in the pad reference. You will never have to do that,; since the modeller will take care of it for you, but let's guess what it has; to do. The most simple algorithm will just loop over all daughters, convert; the point from mother to local reference and check if the current chamber; contains the point or not. This might be efficient for pads with few chambers,; but definitely not for 1000. Fortunately the modeler is smarter than that and; create for each volume some optimization structures called voxels (see Voxelization); to minimize the penalty having too many daughters, but if you have 100 pads like; this in your geometry you will anyway loose a lot in your tracking performance. The way out when volumes can be arranged according to simple patterns is the; usage of divisions. We will describe them in detail later on. Let's think now; at a different situation : instead of 1000 chambers of the same type, we may; have several types of chambers. Let's say all chambers are cylindrical and have; a wire inside, but their dimensions are different. However, we would like all; to be represented by a single volume family, since they have the same properties. Volume families (TGeoVolumeMulti). A volume family is represented by the class TGeoVolumeMulti. It represents; a class of volumes having the same shape type and each member will be; i",MatchSource.WIKI,root/html602/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolume.html
Integrability,message,message,"ke box, trd1, trd2, trap, gtra or para - 1,2,3 means X,Y,Z; for; tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and; pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi.; In fact, the division operation has the same effect as positioning volumes; in a given order inside the divided container - the advantage being that the; navigation in such a structure is much faster. When a volume is divided, a; volume family corresponding to the slices is created. In case all slices can; be represented by a single shape, only one volume is added to the family and; positioned N times inside the divided volume, otherwise, each slice will be; represented by a distinct volume in the family.; Divisions can be also performed in a given range of one axis. For that, one; have to specify also the starting coordinate value and the step:. TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N, start, step);. A check is always done on the resulting division range : if not fitting into; the container limits, an error message is posted. If we will browse the divided; volume we will notice that it will contain N nodes starting with index 1 upto; N. The first one has the lower X limit at START position, while the last one; will have the upper X limit at START+N*STEP. The resulting slices cannot; be positioned inside an other volume (they are by default positioned inside the; divided one) but can be further divided and may contain other volumes:. TGeoVolume *slicey = slicex->Divide(""SLICEY"", 2, N1);; slicey->AddNode(other_vol, index, some_matrix);. When doing that, we have to remember that SLICEY represents a family, therefore; all members of the family will be divided on Y and the other volume will be; added as node inside all.; In the example above all the resulting slices had the same shape as the; divided volume (box). This is not always the case. For instance, dividing a; volume with TUBE shape on PHI axis will create equal slices having TUBESEG; shape",MatchSource.WIKI,root/html602/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolume.html
Modifiability,inherit,inherits,"rent name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the volume itself, one of its positioned daughter volumes or none if; the point is actually outside. On the other hand, volumes have to provide also; other navigation methods such as finding the distances to its shape boundaries; or which daughter will be crossed first. The implementation of these features; is done at shape level, but the local mother-daughters management is handled; by volumes that builds additional optimisation structures upon geometry closure.; In order to have navigation features properly working one has to follow the; general rules for building a valid geometry (see TGeoManager class). Now let's make a simple volume representing a copper wire. We suppose that; a medium is already created (see TGeoMedium cla",MatchSource.WIKI,root/html602/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolume.html
Performance,optimiz,optimization,"pletely distinct : WIRE_CO_1 and WIRE_CO_2. We will; want now to place symetrically 1000 chambers on a pad, following a pattern; of 20 rows and 50 columns. One way to do this will be to replicate our chamber; by positioning it 1000 times in different positions of the pad. Unfortunatelly,; this is far from being the optimal way of doing what we want.; Imagine that we would like to find out which of the 1000 chambers is containing; a (x,y,z) point defined in the pad reference. You will never have to do that,; since the modeller will take care of it for you, but let's guess what it has; to do. The most simple algorithm will just loop over all daughters, convert; the point from mother to local reference and check if the current chamber; contains the point or not. This might be efficient for pads with few chambers,; but definitely not for 1000. Fortunately the modeler is smarter than that and; create for each volume some optimization structures called voxels (see Voxelization); to minimize the penalty having too many daughters, but if you have 100 pads like; this in your geometry you will anyway loose a lot in your tracking performance. The way out when volumes can be arranged according to simple patterns is the; usage of divisions. We will describe them in detail later on. Let's think now; at a different situation : instead of 1000 chambers of the same type, we may; have several types of chambers. Let's say all chambers are cylindrical and have; a wire inside, but their dimensions are different. However, we would like all; to be represented by a single volume family, since they have the same properties. Volume families (TGeoVolumeMulti). A volume family is represented by the class TGeoVolumeMulti. It represents; a class of volumes having the same shape type and each member will be; identified by the same name and volume ID. Any operation applied to a; TGeoVolume equally affects all volumes in that family. The creation of a; family is generally not a user task, but can b",MatchSource.WIKI,root/html602/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolume.html
Safety,avoid,avoid,"ader viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoVolume. class TGeoVolume: public TNamed, public TGeoAtt, public TAttLine, public TAttFill, public TAtt3D. TGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly - the volume classes. Volumes are the basic objects used in building the geometrical hierarchy.; They represent unpositioned objects but store all information about the; placement of the other volumes they may contain. Therefore a volume can; be replicated several times in the geometry. In order to create a volume, one; has to put together a shape and a medium which are already defined. Volumes; have to be named by users at creation time. Every different name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the vo",MatchSource.WIKI,root/html602/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolume.html
Testability,test,testNo,,MatchSource.WIKI,root/html602/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolume.html
Usability,simpl,simple,"advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the volume itself, one of its positioned daughter volumes or none if; the point is actually outside. On the other hand, volumes have to provide also; other navigation methods such as finding the distances to its shape boundaries; or which daughter will be crossed first. The implementation of these features; is done at shape level, but the local mother-daughters management is handled; by volumes that builds additional optimisation structures upon geometry closure.; In order to have navigation features properly working one has to follow the; general rules for building a valid geometry (see TGeoManager class). Now let's make a simple volume representing a copper wire. We suppose that; a medium is already created (see TGeoMedium class on how to create media).; We will create a TUBE shape for our wire, having Rmin=0cm, Rmax=0.01cm; and a half-length dZ=1cm :. TGeoTube *tube = new TGeoTube(""wire_tube"", 0, 0.01, 1);. One may ommit the name for the shape if no retreiving by name is further needed; during geometry building. The same shape can be shared by different volumes; having different names and materials. Now let's make the volume for our wire.; The prototype for volumes constructor looks like :. TGeoVolume::TGeoVolume(const char *name, TGeoShape *shape, TGeoMedium *med). Since TGeoTube derives from the base shape class, we can provide it to the volume; constructor :. TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);. Do not bother to delete neither the media, shapes or volumes that you have; created since all will be automatically cleaned on exit by the manager class.; If we would have taken a look insi",MatchSource.WIKI,root/html602/TGeoVolume.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolume.html
Availability,error,error,"ke box, trd1, trd2, trap, gtra or para - 1,2,3 means X,Y,Z; for; tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and; pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi.; In fact, the division operation has the same effect as positioning volumes; in a given order inside the divided container - the advantage being that the; navigation in such a structure is much faster. When a volume is divided, a; volume family corresponding to the slices is created. In case all slices can; be represented by a single shape, only one volume is added to the family and; positioned N times inside the divided volume, otherwise, each slice will be; represented by a distinct volume in the family.; Divisions can be also performed in a given range of one axis. For that, one; have to specify also the starting coordinate value and the step:. TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N, start, step);. A check is always done on the resulting division range : if not fitting into; the container limits, an error message is posted. If we will browse the divided; volume we will notice that it will contain N nodes starting with index 1 upto; N. The first one has the lower X limit at START position, while the last one; will have the upper X limit at START+N*STEP. The resulting slices cannot; be positioned inside an other volume (they are by default positioned inside the; divided one) but can be further divided and may contain other volumes:. TGeoVolume *slicey = slicex->Divide(""SLICEY"", 2, N1);; slicey->AddNode(other_vol, index, some_matrix);. When doing that, we have to remember that SLICEY represents a family, therefore; all members of the family will be divided on Y and the other volume will be; added as node inside all.; In the example above all the resulting slices had the same shape as the; divided volume (box). This is not always the case. For instance, dividing a; volume with TUBE shape on PHI axis will create equal slices having TUBESEG; shape",MatchSource.WIKI,root/html602/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolumeAssembly.html
Energy Efficiency,efficient,efficient,"GeoTranslation(-0.2,0,0));; chamber->AddNode(wire_co, 2, new TGeoTranslation(0.2,0,0));. The 2 nodes that we have created inside chamber will both point to a wire_co; object, but will be completely distinct : WIRE_CO_1 and WIRE_CO_2. We will; want now to place symetrically 1000 chambers on a pad, following a pattern; of 20 rows and 50 columns. One way to do this will be to replicate our chamber; by positioning it 1000 times in different positions of the pad. Unfortunatelly,; this is far from being the optimal way of doing what we want.; Imagine that we would like to find out which of the 1000 chambers is containing; a (x,y,z) point defined in the pad reference. You will never have to do that,; since the modeller will take care of it for you, but let's guess what it has; to do. The most simple algorithm will just loop over all daughters, convert; the point from mother to local reference and check if the current chamber; contains the point or not. This might be efficient for pads with few chambers,; but definitely not for 1000. Fortunately the modeler is smarter than that and; create for each volume some optimization structures called voxels (see Voxelization); to minimize the penalty having too many daughters, but if you have 100 pads like; this in your geometry you will anyway loose a lot in your tracking performance. The way out when volumes can be arranged according to simple patterns is the; usage of divisions. We will describe them in detail later on. Let's think now; at a different situation : instead of 1000 chambers of the same type, we may; have several types of chambers. Let's say all chambers are cylindrical and have; a wire inside, but their dimensions are different. However, we would like all; to be represented by a single volume family, since they have the same properties. Volume families (TGeoVolumeMulti). A volume family is represented by the class TGeoVolumeMulti. It represents; a class of volumes having the same shape type and each member will be; i",MatchSource.WIKI,root/html602/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolumeAssembly.html
Integrability,message,message,"ke box, trd1, trd2, trap, gtra or para - 1,2,3 means X,Y,Z; for; tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and; pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi.; In fact, the division operation has the same effect as positioning volumes; in a given order inside the divided container - the advantage being that the; navigation in such a structure is much faster. When a volume is divided, a; volume family corresponding to the slices is created. In case all slices can; be represented by a single shape, only one volume is added to the family and; positioned N times inside the divided volume, otherwise, each slice will be; represented by a distinct volume in the family.; Divisions can be also performed in a given range of one axis. For that, one; have to specify also the starting coordinate value and the step:. TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N, start, step);. A check is always done on the resulting division range : if not fitting into; the container limits, an error message is posted. If we will browse the divided; volume we will notice that it will contain N nodes starting with index 1 upto; N. The first one has the lower X limit at START position, while the last one; will have the upper X limit at START+N*STEP. The resulting slices cannot; be positioned inside an other volume (they are by default positioned inside the; divided one) but can be further divided and may contain other volumes:. TGeoVolume *slicey = slicex->Divide(""SLICEY"", 2, N1);; slicey->AddNode(other_vol, index, some_matrix);. When doing that, we have to remember that SLICEY represents a family, therefore; all members of the family will be divided on Y and the other volume will be; added as node inside all.; In the example above all the resulting slices had the same shape as the; divided volume (box). This is not always the case. For instance, dividing a; volume with TUBE shape on PHI axis will create equal slices having TUBESEG; shape",MatchSource.WIKI,root/html602/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolumeAssembly.html
Modifiability,inherit,inherits,"rent name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the volume itself, one of its positioned daughter volumes or none if; the point is actually outside. On the other hand, volumes have to provide also; other navigation methods such as finding the distances to its shape boundaries; or which daughter will be crossed first. The implementation of these features; is done at shape level, but the local mother-daughters management is handled; by volumes that builds additional optimisation structures upon geometry closure.; In order to have navigation features properly working one has to follow the; general rules for building a valid geometry (see TGeoManager class). Now let's make a simple volume representing a copper wire. We suppose that; a medium is already created (see TGeoMedium cla",MatchSource.WIKI,root/html602/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolumeAssembly.html
Performance,optimiz,optimization,"pletely distinct : WIRE_CO_1 and WIRE_CO_2. We will; want now to place symetrically 1000 chambers on a pad, following a pattern; of 20 rows and 50 columns. One way to do this will be to replicate our chamber; by positioning it 1000 times in different positions of the pad. Unfortunatelly,; this is far from being the optimal way of doing what we want.; Imagine that we would like to find out which of the 1000 chambers is containing; a (x,y,z) point defined in the pad reference. You will never have to do that,; since the modeller will take care of it for you, but let's guess what it has; to do. The most simple algorithm will just loop over all daughters, convert; the point from mother to local reference and check if the current chamber; contains the point or not. This might be efficient for pads with few chambers,; but definitely not for 1000. Fortunately the modeler is smarter than that and; create for each volume some optimization structures called voxels (see Voxelization); to minimize the penalty having too many daughters, but if you have 100 pads like; this in your geometry you will anyway loose a lot in your tracking performance. The way out when volumes can be arranged according to simple patterns is the; usage of divisions. We will describe them in detail later on. Let's think now; at a different situation : instead of 1000 chambers of the same type, we may; have several types of chambers. Let's say all chambers are cylindrical and have; a wire inside, but their dimensions are different. However, we would like all; to be represented by a single volume family, since they have the same properties. Volume families (TGeoVolumeMulti). A volume family is represented by the class TGeoVolumeMulti. It represents; a class of volumes having the same shape type and each member will be; identified by the same name and volume ID. Any operation applied to a; TGeoVolume equally affects all volumes in that family. The creation of a; family is generally not a user task, but can b",MatchSource.WIKI,root/html602/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolumeAssembly.html
Safety,avoid,avoid," Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoVolumeAssembly. class TGeoVolumeAssembly: public TGeoVolume. TGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly - the volume classes. Volumes are the basic objects used in building the geometrical hierarchy.; They represent unpositioned objects but store all information about the; placement of the other volumes they may contain. Therefore a volume can; be replicated several times in the geometry. In order to create a volume, one; has to put together a shape and a medium which are already defined. Volumes; have to be named by users at creation time. Every different name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the vo",MatchSource.WIKI,root/html602/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolumeAssembly.html
Testability,test,testNo,,MatchSource.WIKI,root/html602/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolumeAssembly.html
Usability,simpl,simple,"advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the volume itself, one of its positioned daughter volumes or none if; the point is actually outside. On the other hand, volumes have to provide also; other navigation methods such as finding the distances to its shape boundaries; or which daughter will be crossed first. The implementation of these features; is done at shape level, but the local mother-daughters management is handled; by volumes that builds additional optimisation structures upon geometry closure.; In order to have navigation features properly working one has to follow the; general rules for building a valid geometry (see TGeoManager class). Now let's make a simple volume representing a copper wire. We suppose that; a medium is already created (see TGeoMedium class on how to create media).; We will create a TUBE shape for our wire, having Rmin=0cm, Rmax=0.01cm; and a half-length dZ=1cm :. TGeoTube *tube = new TGeoTube(""wire_tube"", 0, 0.01, 1);. One may ommit the name for the shape if no retreiving by name is further needed; during geometry building. The same shape can be shared by different volumes; having different names and materials. Now let's make the volume for our wire.; The prototype for volumes constructor looks like :. TGeoVolume::TGeoVolume(const char *name, TGeoShape *shape, TGeoMedium *med). Since TGeoTube derives from the base shape class, we can provide it to the volume; constructor :. TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);. Do not bother to delete neither the media, shapes or volumes that you have; created since all will be automatically cleaned on exit by the manager class.; If we would have taken a look insi",MatchSource.WIKI,root/html602/TGeoVolumeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolumeAssembly.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html602/TGeoVolumeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolumeDialog.html
Availability,down,down,"meEditor. Editor for geometry volumes and assemblies of volumes. Besides the volume; name and line attributes, a TGeoVolume has the following editable categories; split vertically by a shutter:; - Properties: one can edit the shape and medium components from here. It is; also possible to change the existing ones.; - Daughters: the main category allowing defining, editing, removing or; positioning daughter volumes inside the current edited volume. To add a; daughter, one needs to select first a volume and a matrix. Currently no check; is performed if the daughter volume creates an extrusion (illegal for tracking).; To remove or change the position of an existing daughter, one should simply; select the desired daughter from the combo box with the existing ones, then; simply click the appropriate button.; - Visualization: One can set the visibility of the volume and of its daughters,; set the visibility depth and the view type. Selecting ""All"" will draw the; volume and all visible daughters down to the selected level starting from the; edited volume. Selecting ""Leaves"" will draw just the deepest daughters within; the selected visibility level, without displaying the containers, while ""Only""; will just draw the edited volume.; - Division: The category becomes active only if there are no daughters of the; edited volume added by normal positioning (e.g. from <Daughters> category). The; minimum allowed starting value for the selected division axis is automatically; selected, while the dslicing step is set to 0 - meaning that only the number; of slices matter. Function Members (Methods); public:. virtual~TGeoVolumeEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt",MatchSource.WIKI,root/html602/TGeoVolumeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolumeEditor.html
Performance,perform,performed,". TGeoVolumeEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMBUILDER; » TGeoVolumeEditor. class TGeoVolumeEditor: public TGeoGedFrame. TGeoVolumeEditor. Editor for geometry volumes and assemblies of volumes. Besides the volume; name and line attributes, a TGeoVolume has the following editable categories; split vertically by a shutter:; - Properties: one can edit the shape and medium components from here. It is; also possible to change the existing ones.; - Daughters: the main category allowing defining, editing, removing or; positioning daughter volumes inside the current edited volume. To add a; daughter, one needs to select first a volume and a matrix. Currently no check; is performed if the daughter volume creates an extrusion (illegal for tracking).; To remove or change the position of an existing daughter, one should simply; select the desired daughter from the combo box with the existing ones, then; simply click the appropriate button.; - Visualization: One can set the visibility of the volume and of its daughters,; set the visibility depth and the view type. Selecting ""All"" will draw the; volume and all visible daughters down to the selected level starting from the; edited volume. Selecting ""Leaves"" will draw just the deepest daughters within; the selected visibility level, without displaying the containers, while ""Only""; will just draw the edited volume.; - Division: The category becomes active only if there are no daughters of the; edited volume added by normal positioning (e.g. from <Daughters> category). The; minimum allowed starting value for the selected division axis is automatically; selected, while the dslicing step is set to 0 - meaning that only the number; of slices matter. Function Members (Methods); public:. virtual~TGeoVolumeEditor(); voidTObject::AbstractMethod(",MatchSource.WIKI,root/html602/TGeoVolumeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolumeEditor.html
Usability,simpl,simply,"ge; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMBUILDER; » TGeoVolumeEditor. class TGeoVolumeEditor: public TGeoGedFrame. TGeoVolumeEditor. Editor for geometry volumes and assemblies of volumes. Besides the volume; name and line attributes, a TGeoVolume has the following editable categories; split vertically by a shutter:; - Properties: one can edit the shape and medium components from here. It is; also possible to change the existing ones.; - Daughters: the main category allowing defining, editing, removing or; positioning daughter volumes inside the current edited volume. To add a; daughter, one needs to select first a volume and a matrix. Currently no check; is performed if the daughter volume creates an extrusion (illegal for tracking).; To remove or change the position of an existing daughter, one should simply; select the desired daughter from the combo box with the existing ones, then; simply click the appropriate button.; - Visualization: One can set the visibility of the volume and of its daughters,; set the visibility depth and the view type. Selecting ""All"" will draw the; volume and all visible daughters down to the selected level starting from the; edited volume. Selecting ""Leaves"" will draw just the deepest daughters within; the selected visibility level, without displaying the containers, while ""Only""; will just draw the edited volume.; - Division: The category becomes active only if there are no daughters of the; edited volume added by normal positioning (e.g. from <Daughters> category). The; minimum allowed starting value for the selected division axis is automatically; selected, while the dslicing step is set to 0 - meaning that only the number; of slices matter. Function Members (Methods); public:. virtual~TGeoVolumeEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGe",MatchSource.WIKI,root/html602/TGeoVolumeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolumeEditor.html
Availability,error,error,"ke box, trd1, trd2, trap, gtra or para - 1,2,3 means X,Y,Z; for; tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and; pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi.; In fact, the division operation has the same effect as positioning volumes; in a given order inside the divided container - the advantage being that the; navigation in such a structure is much faster. When a volume is divided, a; volume family corresponding to the slices is created. In case all slices can; be represented by a single shape, only one volume is added to the family and; positioned N times inside the divided volume, otherwise, each slice will be; represented by a distinct volume in the family.; Divisions can be also performed in a given range of one axis. For that, one; have to specify also the starting coordinate value and the step:. TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N, start, step);. A check is always done on the resulting division range : if not fitting into; the container limits, an error message is posted. If we will browse the divided; volume we will notice that it will contain N nodes starting with index 1 upto; N. The first one has the lower X limit at START position, while the last one; will have the upper X limit at START+N*STEP. The resulting slices cannot; be positioned inside an other volume (they are by default positioned inside the; divided one) but can be further divided and may contain other volumes:. TGeoVolume *slicey = slicex->Divide(""SLICEY"", 2, N1);; slicey->AddNode(other_vol, index, some_matrix);. When doing that, we have to remember that SLICEY represents a family, therefore; all members of the family will be divided on Y and the other volume will be; added as node inside all.; In the example above all the resulting slices had the same shape as the; divided volume (box). This is not always the case. For instance, dividing a; volume with TUBE shape on PHI axis will create equal slices having TUBESEG; shape",MatchSource.WIKI,root/html602/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolumeMulti.html
Energy Efficiency,efficient,efficient,"GeoTranslation(-0.2,0,0));; chamber->AddNode(wire_co, 2, new TGeoTranslation(0.2,0,0));. The 2 nodes that we have created inside chamber will both point to a wire_co; object, but will be completely distinct : WIRE_CO_1 and WIRE_CO_2. We will; want now to place symetrically 1000 chambers on a pad, following a pattern; of 20 rows and 50 columns. One way to do this will be to replicate our chamber; by positioning it 1000 times in different positions of the pad. Unfortunatelly,; this is far from being the optimal way of doing what we want.; Imagine that we would like to find out which of the 1000 chambers is containing; a (x,y,z) point defined in the pad reference. You will never have to do that,; since the modeller will take care of it for you, but let's guess what it has; to do. The most simple algorithm will just loop over all daughters, convert; the point from mother to local reference and check if the current chamber; contains the point or not. This might be efficient for pads with few chambers,; but definitely not for 1000. Fortunately the modeler is smarter than that and; create for each volume some optimization structures called voxels (see Voxelization); to minimize the penalty having too many daughters, but if you have 100 pads like; this in your geometry you will anyway loose a lot in your tracking performance. The way out when volumes can be arranged according to simple patterns is the; usage of divisions. We will describe them in detail later on. Let's think now; at a different situation : instead of 1000 chambers of the same type, we may; have several types of chambers. Let's say all chambers are cylindrical and have; a wire inside, but their dimensions are different. However, we would like all; to be represented by a single volume family, since they have the same properties. Volume families (TGeoVolumeMulti). A volume family is represented by the class TGeoVolumeMulti. It represents; a class of volumes having the same shape type and each member will be; i",MatchSource.WIKI,root/html602/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolumeMulti.html
Integrability,message,message,"ke box, trd1, trd2, trap, gtra or para - 1,2,3 means X,Y,Z; for; tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and; pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi.; In fact, the division operation has the same effect as positioning volumes; in a given order inside the divided container - the advantage being that the; navigation in such a structure is much faster. When a volume is divided, a; volume family corresponding to the slices is created. In case all slices can; be represented by a single shape, only one volume is added to the family and; positioned N times inside the divided volume, otherwise, each slice will be; represented by a distinct volume in the family.; Divisions can be also performed in a given range of one axis. For that, one; have to specify also the starting coordinate value and the step:. TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N, start, step);. A check is always done on the resulting division range : if not fitting into; the container limits, an error message is posted. If we will browse the divided; volume we will notice that it will contain N nodes starting with index 1 upto; N. The first one has the lower X limit at START position, while the last one; will have the upper X limit at START+N*STEP. The resulting slices cannot; be positioned inside an other volume (they are by default positioned inside the; divided one) but can be further divided and may contain other volumes:. TGeoVolume *slicey = slicex->Divide(""SLICEY"", 2, N1);; slicey->AddNode(other_vol, index, some_matrix);. When doing that, we have to remember that SLICEY represents a family, therefore; all members of the family will be divided on Y and the other volume will be; added as node inside all.; In the example above all the resulting slices had the same shape as the; divided volume (box). This is not always the case. For instance, dividing a; volume with TUBE shape on PHI axis will create equal slices having TUBESEG; shape",MatchSource.WIKI,root/html602/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolumeMulti.html
Modifiability,inherit,inherits,"rent name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the volume itself, one of its positioned daughter volumes or none if; the point is actually outside. On the other hand, volumes have to provide also; other navigation methods such as finding the distances to its shape boundaries; or which daughter will be crossed first. The implementation of these features; is done at shape level, but the local mother-daughters management is handled; by volumes that builds additional optimisation structures upon geometry closure.; In order to have navigation features properly working one has to follow the; general rules for building a valid geometry (see TGeoManager class). Now let's make a simple volume representing a copper wire. We suppose that; a medium is already created (see TGeoMedium cla",MatchSource.WIKI,root/html602/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolumeMulti.html
Performance,optimiz,optimization,"pletely distinct : WIRE_CO_1 and WIRE_CO_2. We will; want now to place symetrically 1000 chambers on a pad, following a pattern; of 20 rows and 50 columns. One way to do this will be to replicate our chamber; by positioning it 1000 times in different positions of the pad. Unfortunatelly,; this is far from being the optimal way of doing what we want.; Imagine that we would like to find out which of the 1000 chambers is containing; a (x,y,z) point defined in the pad reference. You will never have to do that,; since the modeller will take care of it for you, but let's guess what it has; to do. The most simple algorithm will just loop over all daughters, convert; the point from mother to local reference and check if the current chamber; contains the point or not. This might be efficient for pads with few chambers,; but definitely not for 1000. Fortunately the modeler is smarter than that and; create for each volume some optimization structures called voxels (see Voxelization); to minimize the penalty having too many daughters, but if you have 100 pads like; this in your geometry you will anyway loose a lot in your tracking performance. The way out when volumes can be arranged according to simple patterns is the; usage of divisions. We will describe them in detail later on. Let's think now; at a different situation : instead of 1000 chambers of the same type, we may; have several types of chambers. Let's say all chambers are cylindrical and have; a wire inside, but their dimensions are different. However, we would like all; to be represented by a single volume family, since they have the same properties. Volume families (TGeoVolumeMulti). A volume family is represented by the class TGeoVolumeMulti. It represents; a class of volumes having the same shape type and each member will be; identified by the same name and volume ID. Any operation applied to a; TGeoVolume equally affects all volumes in that family. The creation of a; family is generally not a user task, but can b",MatchSource.WIKI,root/html602/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolumeMulti.html
Safety,avoid,avoid,"earch. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoVolumeMulti. class TGeoVolumeMulti: public TGeoVolume. TGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly - the volume classes. Volumes are the basic objects used in building the geometrical hierarchy.; They represent unpositioned objects but store all information about the; placement of the other volumes they may contain. Therefore a volume can; be replicated several times in the geometry. In order to create a volume, one; has to put together a shape and a medium which are already defined. Volumes; have to be named by users at creation time. Every different name may represent a; an unique volume object, but may also represent more general a family (class); of volume objects having the same shape type and medium, but possibly; different shape parameters. It is the user's task to provide different names; for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases :; when a generic shape is provided to the volume constructor or when a division; operation is applied. Each volume in the geometry stores an unique; ID corresponding to its family. In order to ease-up their creation, the manager; class is providing an API that allows making a shape and a volume in a single step. Volumes are objects that can be visualized, therefore having visibility,; colour, line and fill attributes that can be defined or modified any time after; the volume creation. It is advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the vo",MatchSource.WIKI,root/html602/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolumeMulti.html
Testability,test,testNo,,MatchSource.WIKI,root/html602/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolumeMulti.html
Usability,simpl,simple,"advisable however to define these properties just; after the first creation of a volume namespace, since in case of volume families; any new member created by the modeler inherits these properties. In order to provide navigation features, volumes have to be able to find; the proper container of any point defined in the local reference frame. This; can be the volume itself, one of its positioned daughter volumes or none if; the point is actually outside. On the other hand, volumes have to provide also; other navigation methods such as finding the distances to its shape boundaries; or which daughter will be crossed first. The implementation of these features; is done at shape level, but the local mother-daughters management is handled; by volumes that builds additional optimisation structures upon geometry closure.; In order to have navigation features properly working one has to follow the; general rules for building a valid geometry (see TGeoManager class). Now let's make a simple volume representing a copper wire. We suppose that; a medium is already created (see TGeoMedium class on how to create media).; We will create a TUBE shape for our wire, having Rmin=0cm, Rmax=0.01cm; and a half-length dZ=1cm :. TGeoTube *tube = new TGeoTube(""wire_tube"", 0, 0.01, 1);. One may ommit the name for the shape if no retreiving by name is further needed; during geometry building. The same shape can be shared by different volumes; having different names and materials. Now let's make the volume for our wire.; The prototype for volumes constructor looks like :. TGeoVolume::TGeoVolume(const char *name, TGeoShape *shape, TGeoMedium *med). Since TGeoTube derives from the base shape class, we can provide it to the volume; constructor :. TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);. Do not bother to delete neither the media, shapes or volumes that you have; created since all will be automatically cleaned on exit by the manager class.; If we would have taken a look insi",MatchSource.WIKI,root/html602/TGeoVolumeMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVolumeMulti.html
Availability,error,error,"hod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidDaughterToMother(Int_t id, const Double_t* local, Double_t* master) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Double_tEfficiency(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindOverlaps(Int_t inode) const; Double_t*GetBoxes() const; Int_t*GetCheckList(Int_t& nelem, TGeoStateInfo& td) const; virtual Int_t*GetCheckList(const Double_t* point, Int_t& nelem, TGeoStateInfo& td); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_t*GetNextCandidates(const Double_t* point, Int_t& ncheck, TGeoStateInfo& td); virtual Int_t*GetNextVoxel(const Double_t* point, const Double_t* dir, Int_t& ncheck, TGeoStateInfo& td); virtual char*TObject::GetObjectInfo(Int_t px, Int_",MatchSource.WIKI,root/html602/TGeoVoxelFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoVoxelFinder.html
Availability,error,error,"uble_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*TGeoBBox::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawPolygon(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoBBox::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(In",MatchSource.WIKI,root/html602/TGeoXtru.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoXtru.html
Safety,safe,safe,,MatchSource.WIKI,root/html602/TGeoXtru.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoXtru.html
Testability,test,testNo,"st section. *NOTES*; Currently navigation functionality not fully implemented (only Contains()).; Decomposition in concave polygons not implemented - drawing in solid mode; within x3d produces incorrect end-faces. Function Members (Methods); public:. virtual~TGeoXtru(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidCreateThreadData(Int_t nthreads); Bool_tDefinePolygon(Int_t nvert, const Double_t* xv, const Double_t* yv); virtual voidDefineSection(Int_t snum, Double_t z, Double_t x0 = 0., Double_t y0 = 0., Double_t scale = 1.); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double",MatchSource.WIKI,root/html602/TGeoXtru.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGeoXtru.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tHandleButton(Event_t*); virtua",MatchSource.WIKI,root/html602/TGEventHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGEventHandler.html
Integrability,message,message,"bject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TStringTNamed::fNameobject identifier; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TStringTNamed::fTitleobject title; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. Bool_tfIsActivekTRUE if handler is active, kFALSE if not active; TObject*fObject; TGWindow*fWindow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t HandleEvent(Event_t* ev); Handle the event. Returns true if the event has been handled,; false otherwise. void SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); Send message (i.e. event) to window w. Message is encoded in one long; as message type and up to two long parameters. TGEventHandler(const TGEventHandler& ). TGEventHandler& operator=(const TGEventHandler& ). void * GetSender(); { return this; }. TGEventHandler(const char* name, TGWindow* w, TObject* obj, const char* title = """"); { }. virtual ~TGEventHandler(); { }. void Activate(); { fIsActive = kTRUE; }. void DeActivate(); { fIsActive = kFALSE; }. Bool_t IsActive() const; { return fIsActive; }. Bool_t HandleConfigureNotify(Event_t* ); { return kFALSE; }. Bool_t HandleButton(Event_t* ); { return kFALSE; }. Bool_t HandleDoubleClick(Event_t* ); { return kFALSE; }. Bool_t HandleCrossing(Event_t* ); { return kFALSE; }. Bool_t HandleMotion(Event_t* ); { return kFALSE; }. Bool_t HandleKey(Event_t* ); { return kFALSE; }. Bool_t HandleFocusChange(Event_t* ); { return kFALSE; }. Bool_t HandleSelection(Event_t* ); { return kFALSE; }. Bool_t HandleSelectionRequest(",MatchSource.WIKI,root/html602/TGEventHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGEventHandler.html
Availability,error,error,"har* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Long_tTBrowserImp::ExecPlugin(const char*, const char*, const char*, Int_t, Int_t); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTBrowserImp::ExecuteDefaultAction(TObject*); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; char*FormatFileInfo(const char* fname, Long64_t size, Long_t modtime); TStringFullPathName(TGListTreeItem* item); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TBrowser*TBrowserImp::GetBrowser() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClie",MatchSource.WIKI,root/html602/TGFileBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFileBrowser.html
Modifiability,plug-in,plug-in,". TGFileBrowser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGFileBrowser. class TGFileBrowser: public TGMainFrame, public TBrowserImp. TGFileBrowser. System file browser, used as TRootBrowser plug-in.; This class is the real core of the ROOT browser. Function Members (Methods); public:. virtual~TGFileBrowser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAdd(TObject* obj, const char* name = 0, Int_t check = -1); virtual voidTBrowserImp::AddCheckBox(TObject*, Bool_t = kFALSE); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidAddFSDirectory(const char* entry, const char* path = 0, Option_t* opt = """"); voidTGFrame::AddInput(UInt_t emask); voidAddKey(TGListTreeItem* itm, TObject* obj, const char* name = 0); voidAddRemoteFile(TObject* obj); virtual voidTObject::AppendPad(Option_t* option = """"); voidApplyFilter(Int_t id); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidBrowseObj(TObject* obj); TBrowser*TBrowserImp::Browser() const; virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); voidChdir(TGListTreeItem* item); voidChecked(TObject* obj, Bool_t check); Bool_tCheckFiltered(TGListTreeItem* item, Bool_t but = kFALSE); virtual voidTBrowserImp::CheckObjectItem(TObject*, Bool_t = kFALSE); voidCheckRemote(TGListTreeItem* item); Bool_tCheckSor",MatchSource.WIKI,root/html602/TGFileBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFileBrowser.html
Availability,error,error,"e_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTGContainer::End(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGContainer::FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*TGContainer::FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*TGContainer::FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGCanvas*TGContainer::GetCanvas() const; TGClient*TGObject::Get",MatchSource.WIKI,root/html602/TGFileContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFileContainer.html
Integrability,message,messages,ner::fLastActiveEllast active item; Bool_tTGContainer::fLastCasecase sensetivity of last search; Bool_tTGContainer::fLastDirdirection of last search; TStringTGContainer::fLastNamethe name of object of last search; Bool_tTGContainer::fLastSubstringsubstring search option of last search; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGListView*TGLVContainer::fListViewlistview which contains this container; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGContainer::fMsgWindowwindow handling container messages; ULong_tfMtimedirectory modification time; Bool_tTGLVContainer::fMultiSelecttrue = multiple file selection; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; Bool_tTGContainer::fOnMouseOverkTRUE when mouse pointer is over entry; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TViewUpdateTimer*fRefreshrefresh timer; TTimer*TGContainer::fScrollTimerautoscroll timer; Bool_tTGContainer::fScrollingkTRUE - when scrolling is ON; Int_tTGContainer::fSelectednumber of selected items; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; const TGPicture*fSlink_sbig symbolic link icon; const TGPicture*fSlink_tsmall symbolic link icon; EFSSortModefSortTypesorting mode of contents; Int_tTGContainer::fTotaltotal items; EListViewModeTGLVContainer::fViewModelist view viewing mode; TGViewPort*TGConta,MatchSource.WIKI,root/html602/TGFileContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFileContainer.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html602/TGFileDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFileDialog.html
Integrability,message,messages,"GC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGFileDialog(const TGWindow* p = 0, const TGWindow* main = 0, EFileDialogMode dlg_type = kFDOpen, TGFileInfo* file_info = 0); Create a file selection dialog. Depending on the dlg_type it can be; used for opening or saving a file.; About the first two arguments, p is the parent Window, usually the; desktop (root) window, and main is the main (TGMainFrame) application; window (the one opening the dialog), onto which the dialog is; usually centered, and which is waiting for it to close. ~TGFileDialog(); Delete file dialog. void CloseWindow(); Close file dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the user input in the file dialog. TGFileInfo& operator=(const TGFileDialog& ). TGFileDialog(const TGFileDialog& ). » Author: Fons Rademakers 20/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGFileDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFileDialog.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGLVEntry::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*GetDNDdata(Atom_t); virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFra",MatchSource.WIKI,root/html602/TGFileItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFileItem.html
Availability,error,error,"ject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; TGTextLayout*ComputeTextLayout(const char* string, Int_t numChars, Int_t wrapLength, Int_t justify, Int_t flags, UInt_t* width, UInt_t* height) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); voidDrawChars(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; voidDrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); FontAttributes_tGetFontAttributes() const; FontH_tGetFontHandle() const; voidGetFontMetrics(FontMetrics_t* m) const; FontStruct_tGetFontStruct() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::Hand",MatchSource.WIKI,root/html602/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFont.html
Integrability,wrap,wrapLength," virtual~TGFont(); voidTObject::AbstractMethod(const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; TGTextLayout*ComputeTextLayout(const char* string, Int_t numChars, Int_t wrapLength, Int_t justify, Int_t flags, UInt_t* width, UInt_t* height) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); voidDrawChars(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; voidDrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t*",MatchSource.WIKI,root/html602/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFont.html
Modifiability,extend,extends,"If the font does not exist on the printer, the print job will fail at; print time. Given a ""reasonable"" Postscript printer, the following; TGFont font families should print correctly:. Avant Garde, Arial, Bookman, Courier, Courier New, Geneva,; Helvetica, Monaco, New Century Schoolbook, New York,; Palatino, Symbol, Times, Times New Roman, Zapf Chancery,; and Zapf Dingbats. Any other TGFont font families may not print correctly because the; computed Postscript font name may be incorrect. dst -- Pointer to an initialized TString object to which the name of the; Postscript font that corresponds to the font will be appended. Int_t MeasureChars(const char* source, Int_t numChars, Int_t maxLength, Int_t flags, Int_t* length) const; Determine the number of characters from the string that will fit in the; given horizontal span. The measurement is done under the assumption that; DrawChars() will be used to actually display the characters. The return value is the number of characters from source that fit into; the span that extends from 0 to maxLength. *length is filled with the; x-coordinate of the right edge of the last character that did fit. source -- Characters to be displayed. Need not be '\0' terminated.; numChars -- Maximum number of characters to consider from source string.; maxLength -- If > 0, maxLength specifies the longest permissible line; length; don't consider any character that would cross this; x-position. If <= 0, then line length is unbounded and the; flags argument is ignored.; flags -- Various flag bits OR-ed together:; TEXT_PARTIAL_OK means include the last char which only; partially fit on this line.; TEXT_WHOLE_WORDS means stop on a word boundary, if possible.; TEXT_AT_LEAST_ONE means return at least one character even; if no characters fit.; *length -- Filled with x-location just after the terminating character. Int_t TextWidth(const char* string, Int_t numChars = -1) const; A wrapper function for the more complicated interface of MeasureChars.; Comp",MatchSource.WIKI,root/html602/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFont.html
Safety,sanity check,sanity check,"uteTextLayout() stores contiguous ranges of ""normal""; characters in a chunk, along with individual tab and newline chars in; their own chunks. All characters in the text layout are accounted for. void DrawCharsExp(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Draw a string of characters on the screen. DrawCharsExp() expands; control characters that occur in the string to \X or \xXX sequences.; DrawChars() just draws the strings. dst -- Window or pixmap in which to draw.; gc -- Graphics context for drawing characters.; source -- Characters to be displayed. Need not be'\0' terminated.; For DrawChars(), all meta-characters (tabs, control; characters, and newlines) should be stripped out of the; string that is passed to this function. If they are not; stripped out, they will be displayed as regular printing; characters.; numChars -- Number of characters in string.; x, y -- Coordinates at which to place origin of string when drawing. void DrawChars(Drawable_t dst, GContext_t gc, const char* source, Int_t numChars, Int_t x, Int_t y) const; Perform a quick sanity check to ensure we won't overflow the X; coordinate space. void SavePrimitive(ostream& out, Option_t* = """"); Save the used font as a C++ statement(s) on output stream out. FontAttributes_t& operator=(const TGFont& font). TGFont(const char* name); (used for simulating a native underlined or strikeout font). TGFont(const TGFont& font). FontH_t GetFontHandle() const; { return fFontH; }. FontStruct_t GetFontStruct() const; { return fFontStruct; }. FontAttributes_t GetFontAttributes() const; { return fFA; }. Int_t TextHeight() const; { return fFM.fLinespace; }. » Author: Fons Rademakers 20/5/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:51; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFont.html
Usability,simpl,simple,"n that extends from 0 to maxLength. *length is filled with the; x-coordinate of the right edge of the last character that did fit. source -- Characters to be displayed. Need not be '\0' terminated.; numChars -- Maximum number of characters to consider from source string.; maxLength -- If > 0, maxLength specifies the longest permissible line; length; don't consider any character that would cross this; x-position. If <= 0, then line length is unbounded and the; flags argument is ignored.; flags -- Various flag bits OR-ed together:; TEXT_PARTIAL_OK means include the last char which only; partially fit on this line.; TEXT_WHOLE_WORDS means stop on a word boundary, if possible.; TEXT_AT_LEAST_ONE means return at least one character even; if no characters fit.; *length -- Filled with x-location just after the terminating character. Int_t TextWidth(const char* string, Int_t numChars = -1) const; A wrapper function for the more complicated interface of MeasureChars.; Computes how much space the given simple string needs. The return value is the width (in pixels) of the given string. string -- String whose width will be computed.; numChars -- Number of characters to consider from string, or < 0 for; strlen(). Int_t XTextWidth(const char* string, Int_t numChars = -1) const; Return text widht in pixels. void UnderlineChars(Drawable_t dst, GContext_t gc, const char* string, Int_t x, Int_t y, Int_t firstChar, Int_t lastChar) const; This procedure draws an underline for a given range of characters in a; given string. It doesn't draw the characters (which are assumed to have; been displayed previously); it just draws the underline. This procedure; would mainly be used to quickly underline a few characters without having; to construct an underlined font. To produce properly underlined text, the; appropriate underlined font should be constructed and used. dst -- Window or pixmap in which to draw.; gc -- Graphics context for actually drawing line.; string -- String containing charact",MatchSource.WIKI,root/html602/TGFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFont.html
Availability,avail,available,". TGFontDialog. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGFontDialog. class TGFontDialog: public TGTransientFrame. TGFontDialog. Font selection dialog, allowing to select one in the list of available fonts; in the system. Function Members (Methods); public:. virtual~TGFontDialog(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidAlignSelected(Int_t a)SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidColorSelected(Pixel_t c)SIGNAL ; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* s",MatchSource.WIKI,root/html602/TGFontDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFontDialog.html
Availability,avail,available,". TGFontDialog::FontProp_t. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGFontDialog::FontProp_t. class TGFontDialog::FontProp_t. TGFontDialog. Font selection dialog, allowing to select one in the list of available fonts; in the system. Function Members (Methods); public:. ~FontProp_t(); TGFontDialog::FontProp_tFontProp_t(); TGFontDialog::FontProp_tFontProp_t(TGFontDialog::FontProp_t&&); TGFontDialog::FontProp_tFontProp_t(const TGFontDialog::FontProp_t&); TGFontDialog::FontProp_t&operator=(TGFontDialog::FontProp_t&&); TGFontDialog::FontProp_t&operator=(const TGFontDialog::FontProp_t&). Data Members; public:. UInt_tfAligntext alignment; Bool_tfBoldbold flag; Pixel_tfColortext color; Bool_tfItalicitalic flag; TStringfNamefont name; Int_tfSizefont size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: Bertrand Bellenot + Fons Rademakers 23/04/03 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:51; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGFontDialog__FontProp_t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFontDialog__FontProp_t.html
Availability,error,error," virtual~TGFontPool(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGFont*FindFont(FontStruct_t font) const; TGFont*FindFontByHandle(FontH_t font) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFreeAttributeInfo(char** ",MatchSource.WIKI,root/html602/TGFontPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFontPool.html
Deployability,release,released,"erminated with a NULL pointer. void FreeFontFamilies(char** f); Delete an array of families allocated GetFontFamilies() method. TGFont * GetFontFromAttributes(FontAttributes_t* fa, TGFont* fontPtr); Given a desired set of attributes for a font, find a font with the; closest matching attributes and create a new TGFont object.; The return value is a pointer to a TGFont object that represents the; font with the desired attributes. If a font with the desired attributes; could not be constructed, some other font will be substituted; automatically. Every call to this procedure returns a new TGFont object, even if the; specified attributes have already been seen before. TGFont * GetNativeFont(const char* name, Bool_t fixedDefault = kTRUE); The return value is a pointer to an TGFont object that represents the; native font. If a native font by the given name could not be found,; the return value is NULL. Every call to this procedure returns a new TGFont object, even if the; name has already been seen before. The caller should call FreeFont; when the font is no longer needed. TGFont * MakeFont(TGFont* font, FontStruct_t fontStruct, const char* fontName); Helper for GetNativeFont() and GetFontFromAttributes(). Creates and; intializes a new TGFont object. font -- If non-NULL, store the information in this existing TGFont; object, rather than creating a new one; the existing; contents of the font will be released. If NULL, a new; TGFont object is created.; fontStruct -- information about font.; fontName -- The string passed to TVirtualX::LoadQueryFont() to construct the; fontStruct. FontAttributes_t& operator=(const TGFontPool& fp). TGFontPool(const TGFontPool& fp). » Author: Fons Rademakers 20/5/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:51; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGFontPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFontPool.html
Energy Efficiency,allocate,allocated,"eric key of one of the elements in the; table, returns the string key of that element. Returns NULL if numKey; was not equal to any of the numeric keys in the table. Bool_t FieldSpecified(const char* field); Helper function for ParseXLFD(). Determines if a field in the XLFD was; set to a non-null, non-don't-care value. The return value is kFALSE if the field in the XLFD was not set and; should be ignored, kTRUE otherwise. field -- The field of the XLFD to check. Strictly speaking, only when; the string is ""*"" does it mean don't-care. However, an; unspecified or question mark is also interpreted as don't-care. const char * NameOfFont(TGFont* font); Given a font, return a textual string identifying it. char ** GetFontFamilies(); Return information about the font families that are available on the; current display. An array of strings is returned holding a list of all the available font; families. The array is terminated with a NULL pointer. void FreeFontFamilies(char** f); Delete an array of families allocated GetFontFamilies() method. TGFont * GetFontFromAttributes(FontAttributes_t* fa, TGFont* fontPtr); Given a desired set of attributes for a font, find a font with the; closest matching attributes and create a new TGFont object.; The return value is a pointer to a TGFont object that represents the; font with the desired attributes. If a font with the desired attributes; could not be constructed, some other font will be substituted; automatically. Every call to this procedure returns a new TGFont object, even if the; specified attributes have already been seen before. TGFont * GetNativeFont(const char* name, Bool_t fixedDefault = kTRUE); The return value is a pointer to an TGFont object that represents the; native font. If a native font by the given name could not be found,; the return value is NULL. Every call to this procedure returns a new TGFont object, even if the; name has already been seen before. The caller should call FreeFont; when the font is no longer need",MatchSource.WIKI,root/html602/TGFontPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFontPool.html
Availability,down,down,". TGFontTypeComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGFontTypeComboBox. class TGFontTypeComboBox: public TGComboBox. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. virtual~TGFontTypeComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGComboBox::AddEntry(TGString* s, Int_t id); virtual voidTGComboBox::AddEntry(const char* s, Int_t id); virtual voidTGComboBox::AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static",MatchSource.WIKI,root/html602/TGFontTypeComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFontTypeComboBox.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tGetBackground() const; static const TGGC&GetBckgndGC(); static const TGGC&GetBlackGC(); static Pixel_tGetBlackPixel(); Int_tGetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tGetDefaultFrameBackground(); virtual UInt_tGetDefaultHeight() const; static Pixel_tGetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tGetDefaultWidth() const; virtual TDNDData*GetDNDData(Atom_t); virtual Int_tGetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tGetDropType() const; static Long_tTObject::GetDtorOnly(); vi",MatchSource.WIKI,root/html602/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFrame.html
Deployability,update,update,"Bool_t = kTRUE); {}. Bool_t IsLayoutBroken() const; { return kFALSE; }. void SetCleanup(Int_t = kLocalCleanup); { /* backward compatebility */ }. UInt_t GetWidth() const; { return fWidth; }. UInt_t GetHeight() const; { return fHeight; }. UInt_t GetMinWidth() const; { return fMinWidth; }. UInt_t GetMinHeight() const; { return fMinHeight; }. UInt_t GetMaxWidth() const; { return fMaxWidth; }. UInt_t GetMaxHeight() const; { return fMaxHeight; }. TGDimension GetSize() const; { return TGDimension(fWidth, fHeight); }. Int_t GetX() const; { return fX; }. Int_t GetY() const; { return fY; }. Int_t GetBorderWidth() const; { return fBorderWidth; }. TGFrameElement * GetFrameElement() const; { return fFE; }. void SetFrameElement(TGFrameElement* fe); { fFE = fe; }. Bool_t Contains(Int_t x, Int_t y) const; { return ((x >= 0) && (x < (Int_t)fWidth) && (y >= 0) && (y < (Int_t)fHeight)); }. TGFrame * GetFrameFromPoint(Int_t x, Int_t y); { return (Contains(x, y) ? this : 0); }. void SetX(Int_t x); Modifiers (without graphic update). { fX = x; }. void SetY(Int_t y); { fY = y; }. void SetWidth(UInt_t w); { fWidth = w; }. void SetHeight(UInt_t h); { fHeight = h; }. void SetMinWidth(UInt_t w); { fMinWidth = w; }. void SetMinHeight(UInt_t h); { fMinHeight = h; }. void SetMaxWidth(UInt_t w); { fMaxWidth = w; }. void SetMaxHeight(UInt_t h); { fMaxHeight = h; }. void SetSize(const TGDimension& s); { fWidth = s.fWidth; fHeight = s.fHeight; }. void Delete(Option_t* = """"); dummy to remove from context menu. { }. TObject * DrawClone(Option_t* = """") const; { return 0; }. void DrawClass() const; { }. void Dump() const; { }. void Inspect() const; { }. void SetDrawOption(Option_t* = """"); { }. void SetDNDSource(Bool_t onoff); drag and drop... { if (onoff) fDNDState |= kIsDNDSource; else fDNDState &= ~kIsDNDSource; }. void SetDNDTarget(Bool_t onoff); { if (onoff) fDNDState |= kIsDNDTarget; else fDNDState &= ~kIsDNDTarget; }. Bool_t IsDNDSource() const; { return fDNDState & kIsDNDSource; }. Bool_t IsDNDT",MatchSource.WIKI,root/html602/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFrame.html
Integrability,message,message," the events the frame should handle. void RemoveInput(UInt_t emask); Remove events specified in emask from the events the frame should handle. void Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); Draw 3D rectangle on the frame border. void DrawBorder(); Draw frame border. void DoRedraw(); Redraw the frame. Bool_t HandleConfigureNotify(Event_t* event); This event is generated when the frame is resized. Bool_t HandleEvent(Event_t* event); Handle all frame events. Events are dispatched to the specific; event handlers. TGDimension GetDefaultSize() const; std::cout << fWidth << ""x"" << fHeight << std::endl;. void Move(Int_t x, Int_t y); Move frame. void Resize(UInt_t w = 0, UInt_t h = 0); Resize the frame.; If w=0 && h=0 - Resize to default size. void Resize(TGDimension size); Resize the frame. void MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); Move and/or resize the frame.; If w=0 && h=0 - Resize to default size. void SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); Send message (i.e. event) to window w. Message is encoded in one long; as message type and up to two long parameters. Bool_t HandleClientMessage(Event_t* event); Handle a client message. Client messages are the ones sent via; TGFrame::SendMessage (typically by widgets). ULong_t GetDefaultFrameBackground(); Get default frame background. ULong_t GetDefaultSelectedBackground(); Get default selected frame background. ULong_t GetWhitePixel(); Get white pixel value. ULong_t GetBlackPixel(); Get black pixel value. const TGGC & GetBlackGC(); Get black graphics context. const TGGC & GetWhiteGC(); Get white graphics context. const TGGC & GetHilightGC(); Get highlight color graphics context. const TGGC & GetShadowGC(); Get shadow color graphics context. const TGGC & GetBckgndGC(); Get background color graphics context. Time_t GetLastClick(); Get time of last mouse click. void Print(Option_t* option = """") const; Print window id. void SetDragType(Int_t type); SetDragT",MatchSource.WIKI,root/html602/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFrame.html
Testability,log,logically,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. virtual~TGFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivate(Bool_t); voidAddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char",MatchSource.WIKI,root/html602/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFrame.html
Usability,simpl,simple,". TGFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGFrame. class TGFrame: public TGWindow, public TQObject. TGFrame, TGCompositeFrame, TGVerticalFrame, TGHorizontalFrame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. virtual~TGFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivate(Bool_t); voidAddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidChangeOptions(UInt_t options);",MatchSource.WIKI,root/html602/TGFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFrame.html
Availability,down,downward,". TGFrameElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGFrameElement. class TGFrameElement: public TObject. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. virtual~TGFrameElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObje",MatchSource.WIKI,root/html602/TGFrameElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFrameElement.html
Availability,error,error," virtual~TGFrameElementPack(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const;",MatchSource.WIKI,root/html602/TGFrameElementPack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFrameElementPack.html
Performance,cache,cached,"r(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TGFrameElementPack(TGFrame* frame, TGLayoutHints* lh = 0, Float_t weight = 1); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TGFrameElementPack&operator=(const TGFrameElementPack&); TGFrameElementPack(const TGFrameElementPack&). Data Members; public:. TGFrame*TGFrameElement::fFrameframe used in layout; TGLayoutHints*TGFrameElement::fLayoutlayout hints used in layout; TGFrameElementPack*fSplitFE! cached varaible for optimisation; Int_tTGFrameElement::fStateEFrameState defined in TGFrame.h; Float_tfWeightrelative weight; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGFrameElementPack(const",MatchSource.WIKI,root/html602/TGFrameElementPack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFrameElementPack.html
Availability,error,error,"voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTGComboBox::EnableTextInput(Bool_t on)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*TGComboBox::FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDime",MatchSource.WIKI,root/html602/TGFSComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGFSComboBox.html
Availability,error,error," virtual~TGGC(); voidTObject::AbstractMethod(const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetArcMode() const; const GCValues_t*GetAttributes() const; Pixel_tGetBackground() const; Int_tGetCapStyle() const; Pixmap_tGetClipMask() const; Int_tGetClipXOrigin() const; Int_tGetClipYOrigin() const; const char*GetDashes",MatchSource.WIKI,root/html602/TGGC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGGC.html
Availability,error,error," virtual~TGGCPool(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGGC*FindGC(const TGGC* gc); TGGC*FindGC(GContext_t gc); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFreeGC(const TGGC* gc); voidFreeGC(GContext_t gc); TGClient*TGObject::GetClient() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGGC*GetGC(GContext_",MatchSource.WIKI,root/html602/TGGCPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGGCPool.html
Integrability,depend,depending,"kZombie. protected:. TGClient*TGObject::fClientConnection to display server; Handle_tTGObject::fIdX11/Win32 Window identifier. private:. THashTable*fListhash table of graphics contexts in pool. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGGCPool(TGClient* client); Create graphics context pool. ~TGGCPool(); Delete graphics context pool. void ForceFreeGC(const TGGC* gc); Force remove graphics context from list. Is only called via ~TGGC(). void FreeGC(const TGGC* gc); Delete graphics context if it is not used anymore. void FreeGC(GContext_t gc); Delete graphics context if it is not used anymore. TGGC * FindGC(const TGGC* gc); Find graphics context. Returns 0 in case gc is not found. TGGC * FindGC(GContext_t gc); Find graphics context based on its GContext_t handle. Returns 0; in case gc is not found. TGGC * GetGC(GContext_t gct); returns graphics context based on its GContext_t handle. TGGC * GetGC(GCValues_t* values, Bool_t rw = kFALSE); Get the best matching graphics context depending on values.; If rw is false only a readonly, not modifiable graphics context; is returned. If rw is true a new modifiable graphics context is; returned. Int_t MatchGC(const TGGC* gc, GCValues_t* values); Try to find matching graphics context. On success returns the amount; of matching bits (which may be zero if masks have no common bits),; -1 on failure (when there are common bits but not a single match). void UpdateGC(TGGC* gc, GCValues_t* values); Update graphics context with the values spcified in values->fMask. void Print(Option_t* option = """") const; List all graphics contexts in the pool. TGGC & operator=(const TGGCPool& gp). TGGCPool(const TGGCPool& gp); { }. » Author: Fons Rademakers 20/9/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:51; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in gener",MatchSource.WIKI,root/html602/TGGCPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGGCPool.html
Availability,avail,available,". TGGotoDialog. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGGotoDialog. class TGGotoDialog: public TGTransientFrame. TGTextEditDialogs. This file defines several dialogs that are used by the TGTextEdit; widget via its associated context popup menu.; The following dialogs are available: TGSearchDialog, TGGotoDialog; and TGPrintDialog. Function Members (Methods); public:. virtual~TGGotoDialog(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool",MatchSource.WIKI,root/html602/TGGotoDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGGotoDialog.html
Integrability,message,messages,"ckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGGotoDialog(const TGWindow* p = 0, const TGWindow* main = 0, UInt_t w = 1, UInt_t h = 1, Long_t* ret_code = 0, UInt_t options = kVerticalFrame); Create a dialog to GoTo a specific line number. Returns -1 in; ret_code in case no valid line number was given or in case; cancel was pressed. If on input *ret_code is > 0 then this value; will be used as default value. ~TGGotoDialog(); Clean up goto dialog. void CloseWindow(); Close the dialog. On close the dialog will be deleted and cannot be; re-used. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process goto dialog widget messages. TGGotoDialog(const TGWindow* p = 0, const TGWindow* main = 0, UInt_t w = 1, UInt_t h = 1, Long_t* ret_code = 0, UInt_t options = kVerticalFrame). » Author: Fons Rademakers 10/7/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:51; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGGotoDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGGotoDialog.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() cons",MatchSource.WIKI,root/html602/TGGroupFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGGroupFrame.html
Testability,log,logically,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. virtual~TGGroupFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virt",MatchSource.WIKI,root/html602/TGGroupFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGGroupFrame.html
Usability,simpl,simple,". TGGroupFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGGroupFrame. class TGGroupFrame: public TGCompositeFrame. TGFrame, TGCompositeFrame, TGVerticalFrame, TGHorizontalFrame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. virtual~TGGroupFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel",MatchSource.WIKI,root/html602/TGGroupFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGGroupFrame.html
Availability,down,down," ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widget organizes TGButton widgets in a group; with one horizontal row. TGHButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. The TGVButtonGroup widget organizes TGButton widgets in a group; with one vertical column. TGVButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. Function Members (Methods); public:. virtual~TGHButtonGroup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInp",MatchSource.WIKI,root/html602/TGHButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHButtonGroup.html
Deployability,toggle,toggle,". TGHButtonGroup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHButtonGroup. class TGHButtonGroup: public TGButtonGroup. The TGButtonGroup widget organizes TGButton widgets in a group. A button group widget makes it easier to deal with groups of buttons.; A button in a button group is associated with a unique identifier.; The button group emits a Clicked() signal with this identifier when; the button is clicked. Thus, a button group is an ideal solution; when you have several similar buttons and want to connect all their; Clicked() signals, for example, to one slot. An exclusive button group switches off all toggle buttons except; the one that was clicked. A button group is by default non-exclusive.; All radio buttons that are inserted, will be mutually exclusive even; if the button group is non-exclusive. There are two ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> ",MatchSource.WIKI,root/html602/TGHButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHButtonGroup.html
Modifiability,inherit,inherits,"roup. A button group widget makes it easier to deal with groups of buttons.; A button in a button group is associated with a unique identifier.; The button group emits a Clicked() signal with this identifier when; the button is clicked. Thus, a button group is an ideal solution; when you have several similar buttons and want to connect all their; Clicked() signals, for example, to one slot. An exclusive button group switches off all toggle buttons except; the one that was clicked. A button group is by default non-exclusive.; All radio buttons that are inserted, will be mutually exclusive even; if the button group is non-exclusive. There are two ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widg",MatchSource.WIKI,root/html602/TGHButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHButtonGroup.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGHeaderFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHeaderFrame.html
Testability,log,logically,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. virtual~TGHeaderFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); vir",MatchSource.WIKI,root/html602/TGHeaderFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHeaderFrame.html
Usability,simpl,simple,". TGHeaderFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHeaderFrame. class TGHeaderFrame: public TGHorizontalFrame. TGFrame, TGCompositeFrame, TGVerticalFrame, TGHorizontalFrame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. virtual~TGHeaderFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(",MatchSource.WIKI,root/html602/TGHeaderFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHeaderFrame.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option",MatchSource.WIKI,root/html602/TGHorizontal3DLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHorizontal3DLine.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGHorizontalFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHorizontalFrame.html
Testability,log,logically,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. virtual~TGHorizontalFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """");",MatchSource.WIKI,root/html602/TGHorizontalFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHorizontalFrame.html
Usability,simpl,simple,". TGHorizontalFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHorizontalFrame. class TGHorizontalFrame: public TGCompositeFrame. TGFrame, TGCompositeFrame, TGVerticalFrame, TGHorizontalFrame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. virtual~TGHorizontalFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::Ch",MatchSource.WIKI,root/html602/TGHorizontalFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHorizontalFrame.html
Availability,down,downward,". TGHorizontalLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHorizontalLayout. class TGHorizontalLayout: public TGVerticalLayout. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. virtual~TGHorizontalLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMEN",MatchSource.WIKI,root/html602/TGHorizontalLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHorizontalLayout.html
Integrability,wrap,wraps,". TGHotString. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHotString. class TGHotString: public TGString. TGString and TGHotString. TGString wraps a TString and adds some graphics routines like; drawing, size of string on screen depending on font, etc.; TGHotString is a string with a ""hot"" character unerlined. Function Members (Methods); public:. virtual~TGHotString(); TString&TString::Append(const char* cs); TString&TString::Append(const TString& s); TString&TString::Append(const char* cs, Ssiz_t n); TString&TString::Append(const TString& s, Ssiz_t n); TString&TString::Append(char c, Ssiz_t rep = 1); Double_tTString::Atof() const; Int_tTString::Atoi() const; Long64_tTString::Atoll() const; static TStringTString::BaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); Bool_tTString::BeginsWith(const char* s, TString::ECaseCompare cmp = kExact) const; Bool_tTString::BeginsWith(const TString& pat, TString::ECaseCompare cmp = kExact) const; Ssiz_tTString::Capacity() const; Ssiz_tTString::Capacity(Ssiz_t n); TString&TString::Chop(); static TClass*Class(); voidTString::Clear(); intTString::CompareTo(const char* cs, TString::ECaseCompare cmp = kExact) const; intTString::CompareTo(const TString& st, TString::ECaseCompare cmp = kExact) const; Bool_tTString::Contains(const TRegexp& pat) const; Bool_tTString::Contains(TPRegexp& pat) const; Bool_tTString::Contains(const char* pat, TString::ECaseCompare cmp = kExact) const; Bool_tTString::Contains(const TString& pat, TString::ECaseCompare cmp = kExact) const; TStringTString::Copy() const; Int_tTString::CountChar(Int_t c) const; const char*TString::Data() const; virtual voidDraw(Drawable_t id, GContext_t gc, Int_t x, Int_t y); virtual voidDrawWrapped(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, FontStruct_t font); Bool_tTStr",MatchSource.WIKI,root/html602/TGHotString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHotString.html
Performance,cache,cache,"::ToLower(); voidTString::ToUpper(); static TStringTString::UItoa(UInt_t value, Int_t base); static TStringTString::ULLtoa(ULong64_t value, Int_t base); static voidTString::WriteString(TBuffer& b, const TString* a). protected:. static Ssiz_tTString::AdjustCapacity(Ssiz_t oldCap, Ssiz_t newCap); static Ssiz_tTString::Align(Ssiz_t s); voidTString::AssertElement(Ssiz_t nc) const; voidTString::Clobber(Ssiz_t nc); voidDrawHotChar(Drawable_t id, GContext_t gc, Int_t x, Int_t y); voidTString::InitChar(char c); static Ssiz_tTString::Recommend(Ssiz_t s). Data Members; public:. static TString::EStripTypeTString::kBoth; static TString::ECaseCompareTString::kExact; static TString::ECaseCompareTString::kIgnoreCase; static TString::EStripTypeTString::kLeading; static const Ssiz_tTString::kNPOS; static TString::EStripTypeTString::kTrailing. protected:. charfHotCharhot character; Int_tfHotPosposition of hot character; GContext_tfLastGCcontext used during last drawing; Int_tfOff1variable used during drawing (cache); Int_tfOff2variable used during drawing (cache); TString::Rep_tTString::fRep! String data; static TString::(anonymous)TString::kAlignment. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHotString(const char* s); Create a hot string. void Draw(Drawable_t id, GContext_t gc, Int_t x, Int_t y); Draw a hot string and underline the hot character. void DrawWrapped(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, FontStruct_t font); Draw a hot string in a column with width w. If string is longer than; w wrap it to next line. void DrawHotChar(Drawable_t id, GContext_t gc, Int_t x, Int_t y); Draw the underline under the hot character. TGHotString(const char* s). Int_t GetHotChar() const; { return fHotChar; }. Int_t GetHotPos() const; { return fHotPos; }. » Author: Fons Rademakers 05/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:51; This page has b",MatchSource.WIKI,root/html602/TGHotString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHotString.html
Availability,error,error,"signal, void* receiver = 0, const char* slot = 0); virtual voidTQObject::Disconnected(const char*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTGFrame::DrawBorder(); virtual voidTGFrame::DrawClass() const; virtual TObject*TGFrame::DrawClone(Option_t* = """") const; virtual voidTGFrame::DrawCopy(Handle_t, Int_t, Int_t); virtual voidTGFrame::Dump() const; voidTQObject::Emit(const char* signal); voidTQObject::Emit(const char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTGProgressBar::Format(const char* format = ""%.",MatchSource.WIKI,root/html602/TGHProgressBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHProgressBar.html
Usability,progress bar,progress bars,". TGHProgressBar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHProgressBar. class TGHProgressBar: public TGProgressBar. TGProgressBar, TGHProgressBar and TGVProgressBar. The classes in this file implement progress bars. Progress bars can; be used to show progress of tasks taking more then a few seconds.; TGProgressBar is an abstract base class, use either TGHProgressBar; or TGVProgressBar. TGHProgressBar can in addition show the position; as text in the bar. Function Members (Methods); public:. virtual~TGHProgressBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(cons",MatchSource.WIKI,root/html602/TGHProgressBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHProgressBar.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static Pixmap_tTGScrollBar::GetBckgndPixmap(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame",MatchSource.WIKI,root/html602/TGHScrollBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHScrollBar.html
Integrability,message,messages,". TGHScrollBar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHScrollBar. class TGHScrollBar: public TGScrollBar. TGScrollBar and TGScrollBarElement. The classes in this file implement scrollbars. Scrollbars can be; either placed horizontal or vertical. A scrollbar contains three; TGScrollBarElements: The ""head"", ""tail"" and ""slider"". The head and; tail are fixed at either end and have the typical arrows in them. The TGHScrollBar will generate the following event messages:; kC_HSCROLL, kSB_SLIDERPOS, position, 0; kC_HSCROLL, kSB_SLIDERTRACK, position, 0. The TGVScrollBar will generate the following event messages:; kC_VSCROLL, kSB_SLIDERPOS, position, 0; kC_VSCROLL, kSB_SLIDERTRACK, position, 0. Function Members (Methods); public:. virtual~TGHScrollBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGScrollBar::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQ",MatchSource.WIKI,root/html602/TGHScrollBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHScrollBar.html
Testability,log,logical,"e; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Int_tTGScrollBar::fgScrollBarWidth; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHScrollBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = 2, UInt_t options = kHorizontalFrame, Pixel_t back = GetDefaultFrameBackground()); Create a horizontal scrollbar widget. void Layout(); Layout and move horizontal scrollbar components. Bool_t HandleButton(Event_t* event); Handle a mouse button event in a horizontal scrolbar. Bool_t HandleMotion(Event_t* event); Handle mouse motion event in a horizontal scrollbar. void SetRange(Int_t range, Int_t page_size); Set range of horizontal scrollbar. void SetPosition(Int_t pos); Set logical slider position of horizontal scrollbar. void SavePrimitive(ostream& out, Option_t* option = """"); Save an horizontal scrollbar as a C++ statement(s) on output stream out. TGScrollBarElement& operator=(const TGHScrollBar& ). TGHScrollBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = 2, UInt_t options = kHorizontalFrame, Pixel_t back = GetDefaultFrameBackground()); { }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, GetScrollBarWidth()); }. » Author: Fons Rademakers 10/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:51; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGHScrollBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHScrollBar.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::Get",MatchSource.WIKI,root/html602/TGHSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHSlider.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAbove() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType",MatchSource.WIKI,root/html602/TGHSplitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHSplitter.html
Availability,error,error,"l, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEncodeText(TGString* str, const char* z); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGHtmlElement*FindEndNest(TGHtmlElement* sp, int en, TGHtmlElement* lp); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual intFormAction(TGHtmlForm*, int); virtual intFormCreate(TGHtmlForm*, const char*, const char*); virtual Pixel_tTGFrame::GetBackground() const; const char*GetBaseUri() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGViewFrame*TGView::GetCanvas() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounte",MatchSource.WIKI,root/html602/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHtml.html
Deployability,update,update,">, <textarea> or <select>; TGHtmlInput*fFormElemStartMost recent <textarea> or <select>; intfFormPaddingAmount to pad form elements by; TGHtmlForm*fFormStartMost recent <form>; intfGcNextToFree; intfHasFramesTRUE if we can do frames for this page; intfHasScriptTRUE if we can do scripts for this page; UInt_tTGFrame::fHeightframe height; ColorStruct_t*fHighlightBgColorPtrColor for drawing traversal highlight; ColorStruct_t*fHighlightColorPtrColor for drawing traversal highlight.; intfHighlightWidthWidth in pixels of highlight to draw; TGHScrollBar*TGView::fHsbhorizontal scrollbar; intfIColThe column in which zText[nComplete]; intfIDark[32]Dark 3D shadow of color K is iDark[K]; intfILight[32]Light 3D shadow of color K is iLight[K]; intfIPlaintextIf not zero, this is the token type that; Handle_tTGObject::fIdX11/Win32 Window identifier; intfIdind; TGIdleHandler*fIdle; TGHtmlImage*fImageListA list of all images; intfInDtStyle flags associated with <DT>...</DT>; intfInParsePrevent update if parsing; intfInTdTrue if within <td>..</td> or <th>..</th>; intfInTrTrue if within <tr>..</tr>; TGHtmlListStart*fInnerListThe inner most <OL> or <UL>; intfInputIdxUnique input index; SHtmlIndex_tfInsThe insertion cursor position; intfInsIndexIndex in pInsBlock of the cursor; intfInsOffTimeHow long it is off (milliseconds); intfInsOnTimeHow long the cursor states one (millisec); intfInsStatusIs it visible?; TTimer*fInsTimerTimer used to flash the insertion cursor; TGHtmlBlock*fLastBlockLast TGHtmlBlock in the list; intfLastGCIndex of recently used GC; TGHtmlInput*fLastInputLast <INPUT> element; TGHtmlElement*fLastSizedLast HTML element that has been sized; const char*fLastUriUsed in HandleMotion; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGHtmlLayoutContextfLayoutContext; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TLi",MatchSource.WIKI,root/html602/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHtml.html
Energy Efficiency,allocate,allocated,"<th>..</th>; intfInTrTrue if within <tr>..</tr>; TGHtmlListStart*fInnerListThe inner most <OL> or <UL>; intfInputIdxUnique input index; SHtmlIndex_tfInsThe insertion cursor position; intfInsIndexIndex in pInsBlock of the cursor; intfInsOffTimeHow long it is off (milliseconds); intfInsOnTimeHow long the cursor states one (millisec); intfInsStatusIs it visible?; TTimer*fInsTimerTimer used to flash the insertion cursor; TGHtmlBlock*fLastBlockLast TGHtmlBlock in the list; intfLastGCIndex of recently used GC; TGHtmlInput*fLastInputLast <INPUT> element; TGHtmlElement*fLastSizedLast HTML element that has been sized; const char*fLastUriUsed in HandleMotion; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGHtmlLayoutContextfLayoutContext; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGHtmlElement*fLoEndPtrHow far AddStyle has gone to; TGHtmlForm*fLoFormStartFor AddStyle; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; TGInsetsfMarginsdocument margins (separation between the; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; intfMaxXMaximum extent of any ""paint"" that appears; intfMaxYMaximum extent of any ""paint"" that appears; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TGLongPositionTGView::fMousePosposition of mouse; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); intfNAllocSpace allocated for zText; intfNCompleteHow much of zText has actually been; intfNFormThe number of <FORM> elements; intfNInputThe number of <INPUT> elements; intfNTextNumber of characters in zText; intfNTokenNumber of HTML tokens on the list.; TStringTGWindow::fNamename of the window",MatchSource.WIKI,root/html602/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHtml.html
Integrability,rout,routine,"html rule. void UnderlineLinks(int onoff); Set/reset html links underline. void SetBaseUri(const char* uri); Sets base URI. int GotoAnchor(const char* name); Go to anchor position. const char * GetUid(const char* string); Given a string, this procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other calls to this; procedure with a string equal to ""string"" will return exactly the same; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in the main widget. This happens; before we redo the layout, or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this rout",MatchSource.WIKI,root/html602/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHtml.html
Performance,cache,cache,"TGWindow::EEditModeTGWindow::kEditDisableResize; static TGWindow::EEditModeTGWindow::kEditDisableWidth; static TGWindow::EEditModeTGWindow::kEditEnable; static TObject::EStatusBitsTObject::kHasUUID; static TGView::(anonymous)TGView::kHorizontal; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TGView::(anonymous)TGView::kNoHSB; static TGView::(anonymous)TGView::kNoVSB; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TGView::(anonymous)TGView::kVertical; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TGFont*fAFont[71]Information about all screen fonts; GcCache_tfAGcCache[32]A cache of GCs for general use; intfAddEndTagsTRUE if we add /LI etc.; intfAnchorFlagsStyle flags associated with <A>...</A>; TGHtmlAnchor*fAnchorStartMost recent <a href=...>; ColorStruct_t*fApColor[32]Information about all colors; Pixel_tTGFrame::fBackgroundframe background color; ColorStruct_t*fBgColorBackground color of the HTML document; TImage*fBgImageBackground image; Int_tTGFrame::fBorderWidthframe border width; TGViewFrame*TGView::fCanvasframe containing the text; TGClient*TGObject::fClientConnection to display server; Atom_tTGView::fClipboardclipboard property; Long_tfColorUsedbit N is 1 if color N is in use. Only; TStringTGWidget::fCommandcommand to be executed; Cursor_tfCursorCurrent cursor for window, or None.; Int_tTGFrame::fDNDStateEDNDFlags; intfDirtyBottomBottom right corner of region to redraw; intfDirtyLeftTop left corner of region to redraw. These; intfDirtyRightBottom right corner of region to redraw; intfDirtyTopTop left corner of region to redraw. These; UInt_",MatchSource.WIKI,root/html602/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHtml.html
Security,expose,expose,"i(const char* uri); Sets base URI. int GotoAnchor(const char* name); Go to anchor position. const char * GetUid(const char* string); Given a string, this procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other calls to this; procedure with a string equal to ""string"" will return exactly the same; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in the main widget. This happens; before we redo the layout, or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond t",MatchSource.WIKI,root/html602/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHtml.html
Usability,clear,clear,"LayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHtml(const TGWindow* p, int w, int h, int id = -1); HTML Widget constructor. ~TGHtml(); HTML widget destructor. void UpdateBackgroundStart(); Start background update. void FreeColor(ColorStruct_t* color); Free system color. ColorStruct_t * AllocColor(const char* name); Allocate system color by name. ColorStruct_t * AllocColorByValue(ColorStruct_t* color); Allocate system color by value. void Clear(Option_t* = """"); Erase all HTML from this widget and clear the screen. This is; typically done before loading a new document. int ParseText(char* text, const char* index = 0); Appends (or insert at the specified position) the given HTML text to the; end of any HTML text that may have been inserted by prior calls to this; command. Then it runs the tokenizer, parser and layout engine as far as; possible with the text that is available. The display is updated; appropriately. void SetTableRelief(int relief); Sets relief mode of html table. void SetRuleRelief(int relief); Sets relief mode of html rule. void UnderlineLinks(int onoff); Set/reset html links underline. void SetBaseUri(const char* uri); Sets base URI. int GotoAnchor(const char* name); Go to anchor position. const char * GetUid(const char* string); Given a string, this procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to st",MatchSource.WIKI,root/html602/TGHtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHtml.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidForward(); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDe",MatchSource.WIKI,root/html602/TGHtmlBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHtmlBrowser.html
Usability,simpl,simple,". TGHtmlBrowser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUIHTML; » TGHtmlBrowser. class TGHtmlBrowser: public TGMainFrame. TGHtmlBrowser. A very simple HTML browser. Function Members (Methods); public:. virtual~TGHtmlBrowser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; voidBack(); virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); Bool_tCheckAnchors(const char*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClicked(char* uri)SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTGMainFrame::CloseWindow()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char*",MatchSource.WIKI,root/html602/TGHtmlBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGHtmlBrowser.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObjec",MatchSource.WIKI,root/html602/TGIcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGIcon.html
Availability,error,error,"t char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); Int_tTGLBEntry::EntryId() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGTextLBEntry::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGTextLBEntry::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtu",MatchSource.WIKI,root/html602/TGIconLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGIconLBEntry.html
Usability,simpl,simple,". TGIconLBEntry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGIconLBEntry. class TGIconLBEntry: public TGTextLBEntry. TGListBox, TGLBContainer, TGLBEntry and TGTextLBEntry. A listbox is a box, possibly with scrollbar, containing entries.; Currently entries are simple text strings (TGTextLBEntry).; A TGListBox looks a lot like a TGCanvas. It has a TGViewPort; containing a TGLBContainer which contains the entries and it also; has a vertical scrollbar which becomes visible if there are more; items than fit in the visible part of the container. The TGListBox is user callable. The other classes are service; classes of the listbox. Selecting an item in the listbox will generate the event:; kC_COMMAND, kCM_LISTBOX, listbox id, item id. Function Members (Methods); public:. virtual~TGIconLBEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGLBEntry::Activate(Bool_t a); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect",MatchSource.WIKI,root/html602/TGIconLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGIconLBEntry.html
Availability,error,error," virtual~TGIdleHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject:",MatchSource.WIKI,root/html602/TGIdleHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGIdleHandler.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; const TGPicture*TG",MatchSource.WIKI,root/html602/TGImageMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGImageMap.html
Deployability,release,released,sed for drawing button; UInt_tTGFrame::fOptionsframe options; Bool_tTGPictureButton::fOwnDisabledPickTRUE if disabled picture was autogenerated; const TGWindow*TGWindow::fParentParent window; const TGPicture*TGPictureButton::fPicpicture to be put in button; const TGPicture*TGPictureButton::fPicDpicture shown when button disabled; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; TList*fTrashcollect all objects that need to be cleaned up; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled.,MatchSource.WIKI,root/html602/TGImageMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGImageMap.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html602/TGInputDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGInputDialog.html
Energy Efficiency,allocate,allocated,"e::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGTextButton*fCancelcancel button; TGLabel*fLabeltext entry label; TGTextButton*fOkok button; char*fRetStraddress to store return string; TGTextEntry*fTEtext entry widget. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGInputDialog(const TGWindow* p = 0, const TGWindow* main = 0, const char* prompt = 0, const char* defval = 0, char* retstr = 0, UInt_t options = kVerticalFrame); Create simple input dialog. It is important to know that the case where the constructor in; which all the variables are initialized to their default values is; only used for the TBrowser to inspect on the classes. For normal; use the only variable that should be free is options. Variables prompt, defval are the content of the input dialog while; retstr has to be initialized to a char[256]. In case these are not; initialized, they will show default values while retstr will be; automatically allocated by the dialog. However this will make; impossible to retrieve the value entered by the dialog. To see TGInputDialog in use see:; $ROOTSYS/tutorials/testInputDialog.cxx. ~TGInputDialog(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TGInputDialog(const TGInputDialog& ). TGInputDialog & operator=(const TGInputDialog& ). » Author: David Gonzalez Maline 19/07/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:51; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGInputDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGInputDialog.html
Modifiability,variab,variables,"GFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGTextButton*fCancelcancel button; TGLabel*fLabeltext entry label; TGTextButton*fOkok button; char*fRetStraddress to store return string; TGTextEntry*fTEtext entry widget. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGInputDialog(const TGWindow* p = 0, const TGWindow* main = 0, const char* prompt = 0, const char* defval = 0, char* retstr = 0, UInt_t options = kVerticalFrame); Create simple input dialog. It is important to know that the case where the constructor in; which all the variables are initialized to their default values is; only used for the TBrowser to inspect on the classes. For normal; use the only variable that should be free is options. Variables prompt, defval are the content of the input dialog while; retstr has to be initialized to a char[256]. In case these are not; initialized, they will show default values while retstr will be; automatically allocated by the dialog. However this will make; impossible to retrieve the value entered by the dialog. To see TGInputDialog in use see:; $ROOTSYS/tutorials/testInputDialog.cxx. ~TGInputDialog(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TGInputDialog(const TGInputDialog& ). TGInputDialog & operator=(const TGInputDialog& ). » Author: David Gonzalez Maline 19/07/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:51; This page has been automatically generated. For comments or",MatchSource.WIKI,root/html602/TGInputDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGInputDialog.html
Testability,test,testInputDialog,"e::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGTextButton*fCancelcancel button; TGLabel*fLabeltext entry label; TGTextButton*fOkok button; char*fRetStraddress to store return string; TGTextEntry*fTEtext entry widget. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGInputDialog(const TGWindow* p = 0, const TGWindow* main = 0, const char* prompt = 0, const char* defval = 0, char* retstr = 0, UInt_t options = kVerticalFrame); Create simple input dialog. It is important to know that the case where the constructor in; which all the variables are initialized to their default values is; only used for the TBrowser to inspect on the classes. For normal; use the only variable that should be free is options. Variables prompt, defval are the content of the input dialog while; retstr has to be initialized to a char[256]. In case these are not; initialized, they will show default values while retstr will be; automatically allocated by the dialog. However this will make; impossible to retrieve the value entered by the dialog. To see TGInputDialog in use see:; $ROOTSYS/tutorials/testInputDialog.cxx. ~TGInputDialog(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TGInputDialog(const TGInputDialog& ). TGInputDialog & operator=(const TGInputDialog& ). » Author: David Gonzalez Maline 19/07/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:51; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGInputDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGInputDialog.html
Usability,simpl,simple," Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGTextButton*fCancelcancel button; TGLabel*fLabeltext entry label; TGTextButton*fOkok button; char*fRetStraddress to store return string; TGTextEntry*fTEtext entry widget. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGInputDialog(const TGWindow* p = 0, const TGWindow* main = 0, const char* prompt = 0, const char* defval = 0, char* retstr = 0, UInt_t options = kVerticalFrame); Create simple input dialog. It is important to know that the case where the constructor in; which all the variables are initialized to their default values is; only used for the TBrowser to inspect on the classes. For normal; use the only variable that should be free is options. Variables prompt, defval are the content of the input dialog while; retstr has to be initialized to a char[256]. In case these are not; initialized, they will show default values while retstr will be; automatically allocated by the dialog. However this will make; impossible to retrieve the value entered by the dialog. To see TGInputDialog in use see:; $ROOTSYS/tutorials/testInputDialog.cxx. ~TGInputDialog(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TGInputDialog(const TGInputDialog& ). TGInputDialog & operator=(const TGInputDialog& ). » Author: David Gonzalez Mali",MatchSource.WIKI,root/html602/TGInputDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGInputDialog.html
Availability,error,error," virtual~TGItemContext(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidAssociate(TTVLVEntry* item); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t*)MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidEditExpression()MENU ; voidEmpty()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, ",MatchSource.WIKI,root/html602/TGItemContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGItemContext.html
Availability,error,error," virtual~TGL5DDataSet(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGL5DPainter*GetRealPa",MatchSource.WIKI,root/html602/TGL5DDataSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGL5DDataSet.html
Security,access,access,"PNumber of entries.; auto_ptr<TGLHistPainter>fPainter; const Double_t*fV1V1.; Rgl::Range_tfV1MinMaxV1 range.; Double_tfV1Rangemax - min.; const Double_t*fV2V2.; Rgl::Range_tfV2MinMaxV2 range.; Double_tfV2Rangemax - min.; const Double_t*fV3V3.; Rgl::Range_tfV3MinMaxV3 range.; Double_tfV3Rangemax - min.; const Double_t*fV4V4.; Bool_tfV4IsString; Rgl::Range_tfV4MinMaxV4 range.; const Double_t*fV5V5.; Rgl::Range_tfV5MinMaxV5 range.; TAxisfXAxis; TAxisfYAxis; TAxisfZAxis; static TGL5DDataSet::EdefaultskDefaultNB. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGL5DDataSet(TTree* inputData); Constructor. Reads data from TTree,; estimates ranges, creates a painter. Int_t DistancetoPrimitive(Int_t px, Int_t py); Check, if the object is under cursor. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Action. char * GetObjectInfo(Int_t px, Int_t py) const; Info for status bar. void Paint(Option_t* option); Paint. TGL5DPainter * GetRealPainter() const; Get access to painter (for GUI-editor). void SelectPoints(Double_t v4Level, Double_t range); ""Select"" sub-range from source data; - remember indices of ""good"" points. UInt_t SelectedSize() const; Size of selected sub-range. Double_t V1(UInt_t ind) const; V1 from sub-range, converted to unit cube. Double_t V2(UInt_t ind) const; V2 from sub-range, converted to unit cube. Double_t V3(UInt_t ind) const; V3 from sub-range, converted to unit cube. TAxis * GetXAxis() const; X axis for plot. TAxis * GetYAxis() const; Y axis for plot. TAxis * GetZAxis() const; Z axis for plot. const Rgl::Range_t & GetXRange() const; V1 range (X). const Rgl::Range_t & GetYRange() const; V2 range (Y). const Rgl::Range_t & GetZRange() const; V3 range (Z). const Rgl::Range_t & GetV4Range() const; V4 range. Double_t V1ToUnitCube(Double_t v1) const; V1 to unit cube. Double_t V2ToUnitCube(Double_t v2) const; V2 to unit cube. Double_t V3ToUnitCube(Double_t v3) const; V3 to unit cube. TGL5DDataSet(TTree* inputData). » A",MatchSource.WIKI,root/html602/TGL5DDataSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGL5DDataSet.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGL5DDataSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGL5DDataSetEditor.html
Energy Efficiency,adapt,adapter,"TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. private:. TGTextButton*fAddNewIsoBtnButton to add new iso.; TGNumberEntry*fAlpha; TGTextButton*fApplyAlpha; TGTextButton*fApplyPlanes; TGTextButton*fCancelGridBtn""Cancel"" button.; TGL5DDataSet*fDataSetData adapter for TTree.; TGL5DDataSetEditor::TGL5DEditorPrivate*fHidden; TGCheckButton*fHighlightCheckHighlight selected surface.; TGListBox*fIsoListList box to select surface.; TGCheckButton*fLogScale; TGNumberEntry*fNCellsXEntryNumber of cells along X.; TGNumberEntry*fNCellsYEntryNumber of cells along Y.; TGNumberEntry*fNCellsZEntryNumber of cells along Z.; TGNumberEntry*fNewIsoEntrySet the iso-level for new surface.; TGNumberEntry*fNumberOfPlanes; TGTextButton*fOkGridBtn""Apply"" button.; TGL5DPainter*fPainterPainter.; Int_tfSelectedSurface; TGCheckButton*fShowBoxCut; TGCheckButton*fShowCloudShow/hide points for surface.; TGDoubleHSlider*fSlideRange; TGHSlider*fSurfAlphaSliderSlider to control transparency.; TGColorSelect*fSurfColorSelectOpen color dialog.; TGTextButton*fSurfRemoveBtnRemove selected surface.; TGNumberEntryField*fV4MaxEntryRead only widget.; TGNumberEntryField*fV4MinEntryRead only widget.; TGCheckButton*fVisibleCheckShow/hide surface.; TGDoubleHSlider*fXRangeSliderSlid",MatchSource.WIKI,root/html602/TGL5DDataSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGL5DDataSetEditor.html
Integrability,adapter,adapter,"TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. private:. TGTextButton*fAddNewIsoBtnButton to add new iso.; TGNumberEntry*fAlpha; TGTextButton*fApplyAlpha; TGTextButton*fApplyPlanes; TGTextButton*fCancelGridBtn""Cancel"" button.; TGL5DDataSet*fDataSetData adapter for TTree.; TGL5DDataSetEditor::TGL5DEditorPrivate*fHidden; TGCheckButton*fHighlightCheckHighlight selected surface.; TGListBox*fIsoListList box to select surface.; TGCheckButton*fLogScale; TGNumberEntry*fNCellsXEntryNumber of cells along X.; TGNumberEntry*fNCellsYEntryNumber of cells along Y.; TGNumberEntry*fNCellsZEntryNumber of cells along Z.; TGNumberEntry*fNewIsoEntrySet the iso-level for new surface.; TGNumberEntry*fNumberOfPlanes; TGTextButton*fOkGridBtn""Apply"" button.; TGL5DPainter*fPainterPainter.; Int_tfSelectedSurface; TGCheckButton*fShowBoxCut; TGCheckButton*fShowCloudShow/hide points for surface.; TGDoubleHSlider*fSlideRange; TGHSlider*fSurfAlphaSliderSlider to control transparency.; TGColorSelect*fSurfColorSelectOpen color dialog.; TGTextButton*fSurfRemoveBtnRemove selected surface.; TGNumberEntryField*fV4MaxEntryRead only widget.; TGNumberEntryField*fV4MinEntryRead only widget.; TGCheckButton*fVisibleCheckShow/hide surface.; TGDoubleHSlider*fXRangeSliderSlid",MatchSource.WIKI,root/html602/TGL5DDataSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGL5DDataSetEditor.html
Modifiability,adapt,adapter,"TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. private:. TGTextButton*fAddNewIsoBtnButton to add new iso.; TGNumberEntry*fAlpha; TGTextButton*fApplyAlpha; TGTextButton*fApplyPlanes; TGTextButton*fCancelGridBtn""Cancel"" button.; TGL5DDataSet*fDataSetData adapter for TTree.; TGL5DDataSetEditor::TGL5DEditorPrivate*fHidden; TGCheckButton*fHighlightCheckHighlight selected surface.; TGListBox*fIsoListList box to select surface.; TGCheckButton*fLogScale; TGNumberEntry*fNCellsXEntryNumber of cells along X.; TGNumberEntry*fNCellsYEntryNumber of cells along Y.; TGNumberEntry*fNCellsZEntryNumber of cells along Z.; TGNumberEntry*fNewIsoEntrySet the iso-level for new surface.; TGNumberEntry*fNumberOfPlanes; TGTextButton*fOkGridBtn""Apply"" button.; TGL5DPainter*fPainterPainter.; Int_tfSelectedSurface; TGCheckButton*fShowBoxCut; TGCheckButton*fShowCloudShow/hide points for surface.; TGDoubleHSlider*fSlideRange; TGHSlider*fSurfAlphaSliderSlider to control transparency.; TGColorSelect*fSurfColorSelectOpen color dialog.; TGTextButton*fSurfRemoveBtnRemove selected surface.; TGNumberEntryField*fV4MaxEntryRead only widget.; TGNumberEntryField*fV4MinEntryRead only widget.; TGCheckButton*fVisibleCheckShow/hide surface.; TGDoubleHSlider*fXRangeSliderSlid",MatchSource.WIKI,root/html602/TGL5DDataSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGL5DDataSetEditor.html
Safety,safe,safety,". TGL5DDataSetEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGL5DDataSetEditor. class TGL5DDataSetEditor: public TGedFrame. GUI editor for OpenGL 5D Painter.; Exception safety and ROOT's GUI are two; mutually exclusive things. So,; only ROOT's GUI here. Function Members (Methods); public:. virtual~TGL5DDataSetEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); voidAddNewSurface(); voidAlphaChanged(); voidAlphaChanged(Int_t alpha); virtual voidTObject::AppendPad(Option_t* option = """"); voidApplyAlpha(); voidApplyGridParameters(); voidApplyPlanes(); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); voidBoxCutToggled(); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); voidColorChanged(Pixel_t pixelColor); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const ",MatchSource.WIKI,root/html602/TGL5DDataSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGL5DDataSetEditor.html
Availability,error,error,"::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidEnable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGet3DStyle() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tGetBottomMargin() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDe",MatchSource.WIKI,root/html602/TGLabel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLabel.html
Availability,error,error," virtual~TGLAutoRotator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetADolly() const; Double_tGetATheta() const; TGLCamera*GetCamera() const; Double_tGetDeltaPhi() const; virtual Option_t*TObject::GetDrawOption() const; ",MatchSource.WIKI,root/html602/TGLAutoRotator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLAutoRotator.html
Safety,timeout,timeout,"ect::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_tfADolly; Double_tfATheta; TGLCamera*fCamera; Double_tfDeltaPhi; Double_tfDollyA0; Double_tfDt; Bool_tfImageAutoSave; Int_tfImageCount; TStringfImageGUIBaseName; Int_tfImageGUIOutMode; TStringfImageName; Bool_tfRotateScene; Double_tfThetaA0; TTimer*fTimer; Bool_tfTimerRunning; TGLViewer*fViewer; Double_tfWDolly; Double_tfWPhi; Double_tfWTheta; TStopwatch*fWatch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLAutoRotator(TGLViewer* v); Constructor. ~TGLAutoRotator(); Destructor. void SetDt(Double_t dt); Set time between two redraws in seconds.; Range: 0.001 -> 1. void SetATheta(Double_t a); Set relative amplitude of theta oscilation.; Value range: 0.01 -> 1. void SetADolly(Double_t a); Set relative amplitude of forward/backward oscilation.; Value range: 0.01 -> 1. void Start(); Start the auto-rotator. void Stop(); Stop the auto-rotator. void Timeout(); Called on every timer timeout. Moves / rotates the camera and optionally; produces a screenshot. void StartImageAutoSaveAnimatedGif(const TString& filename); Start saving into animated gif. The provided name will be used as it is,; so make sure to end it with '.gif+'.; Use convert tool from ImageMagic if you want to set a different delay or; enable looping. void StartImageAutoSave(const TString& filename); Start saving into a set of images. The provided name will be used as a; format to insert additional image sequence number so it should include; an '%' character. A good name would be something like:; ""image-%04d.png""; On GNU/Linux use mencoder and/or ffmpeg to bundle images into a movie. void StopImageAutoSave(); Stops automatic saving of images. void SetImageGUIOutMode(Int_t m); Set output mode for GUI operation:; 1 - animated gif;; 2 - a series of pngs. void StartImageAutoSaveWithGUISettings(); Start auto-saving images as set-up via GUI. void RotateScene(); ""Scene rotation"": either find a",MatchSource.WIKI,root/html602/TGLAutoRotator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLAutoRotator.html
Performance,optimiz,optimized,"_tfAxisLength; Double_tfGridLength; TString*fLabels; Double_tfLabelsOffset; Double_tfLabelsSize; Int_tfNDiv; Int_tfNDiv1; Int_tfNDiv2; Int_tfNDiv3; Int_tfNTicks1; Int_tfNTicks2; TGLText*fText; Double_tfTickMarksLength; Int_tfTickMarksOrientation; Double_t*fTicks1; Double_t*fTicks2; Double_tfWmax; Double_tfWmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLAxis(); Constructor. void Init(); Default initialization. ~TGLAxis(); Destructor. void PaintGLAxis(const Double_t[3] p1, const Double_t[3] p2, Double_t wmin, Double_t wmax, Int_t ndiv, Option_t* opt = """"); Paint GL Axis. p1, p2 : Axis position in the 3D space.; wmin, wmax : Minimum and maximum values along the axis. wmin < wmax.; ndiv : Number of axis divisions. It is an integer in the form; ""ttsspp"" where ""tt"" is the number of tertiary divisions,; ""ss"" is the number of secondary divisions and ""pp"" the; number of primary divisions.; opt : Options.; ""N"" - By default the number of divisions is optimized to; get a nice labeling. When option ""N"" is given, the; number of divisions is not optimized. void PaintGLAxisBody(); Paint horizontal axis body at position (0,0,0). void PaintGLAxisTickMarks(); Paint axis tick marks. void PaintGLAxisLabels(); Paint axis labels on the main tick marks. void TicksPositions(Option_t* opt = """"); Compute ticks positions. void TicksPositionsNoOpt(); Compute ticks positions. Linear and not optimized. void TicksPositionsOpt(); Compute ticks positions. Linear and optimized. void DoLabels(); Do labels. void SetLabelsAngles(Double_t a1, Double_t a2, Double_t a3); Set labels' angles. TGLAxis(const TGLAxis& ). TGLAxis& operator=(const TGLAxis& ). void SetTickMarksLength(Double_t length); {fTickMarksLength = length;}. void SetTickMarksOrientation(Int_t tmo); {fTickMarksOrientation = tmo;}. void SetLabelsOffset(Double_t offset); {fLabelsOffset = offset;}. void SetLabelsSize(Double_t size); {fLabelsSize = size;}. void SetGridLength(Double_t grid); {fGr",MatchSource.WIKI,root/html602/TGLAxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLAxis.html
Integrability,depend,depends,"tfTitle3DFontSize; Int_tfTitlePixelFontSize; TGLVector3fTitlePos; Bool_tfUseAxisColorsUse colors from axes or from GL-rnr-ctx. private:. Int_tfDecimals; Int_tfExp; TStringfFormat; TGLFontfLabelFont; Int_tfMaxDigits; TGLFontfTitleFont. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLAxisPainter(); Constructor. ~TGLAxisPainter(); Destructor. void SetLabelAlign(TGLFont::ETextAlignH_e , TGLFont::ETextAlignV_e ); Set label align. void LabelsLimits(const char* label, Int_t& first, Int_t& last) const; Find first and last character of a label. void FormAxisValue(Double_t x, TString& s) const; Returns formatted text suitable for display of value. void SetTextFormat(Double_t min, Double_t max, Double_t binWidth); Construct print format from given primary bin width. void RnrText(const TString& txt, const TGLVector3& pos, TGLFont::ETextAlignH_e aH, TGLFont::ETextAlignV_e aV, const TGLFont& font) const; Render text at the given position. Offset depends of text aligment. void SetLabelFont(TGLRnrCtx& rnrCtx, const char* fontName, Int_t pixelSize = 64, Double_t font3DSize = -1); Set label font derived from TAttAxis. void RnrLabels() const; Render label reading prepared list ov value-pos pairs. void SetTitleFont(TGLRnrCtx& rnrCtx, const char* fontName, Int_t pixelSize = 64, Double_t font3DSize = -1); Set title font derived from TAttAxis. void RnrTitle(const TString& title, TGLVector3& pos, TGLFont::ETextAlignH_e aH, TGLFont::ETextAlignV_e aV) const; Draw title at given position. void RnrLines() const; Render axis main line and tickmarks. void PaintAxis(TGLRnrCtx& ctx, TAxis* ax); GL render TAxis. TGLAxisPainter(const TGLAxisPainter& ). TGLAxisPainter& operator=(const TGLAxisPainter& ). Int_t GetTMNDim() const; GetSets. { return fTMNDim; }. void SetTMNDim(Int_t x); { fTMNDim = x; }. TGLVector3& RefDir(); { return fDir; }. TGLVector3& RefTMOff(Int_t i); { return fTMOff[i]; }. TGLFont::EMode GetFontMode() const; { return fFontMode; }. void S",MatchSource.WIKI,root/html602/TGLAxisPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLAxisPainter.html
Availability,down,downward,". TGLayoutHints. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLayoutHints. class TGLayoutHints: public TObject, public TRefCnt. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. virtual~TGLayoutHints(); voidTObject::AbstractMethod(const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::Draw",MatchSource.WIKI,root/html602/TGLayoutHints.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLayoutHints.html
Availability,down,downward,". TGLayoutManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLayoutManager. class TGLayoutManager: public TObject. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLayoutManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(In",MatchSource.WIKI,root/html602/TGLayoutManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLayoutManager.html
Availability,error,error,"e_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTGContainer::End(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGContainer::FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*TGContainer::FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*TGContainer::FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGCanvas*TGContainer::GetCanvas() const; TGClient*TGObject::Get",MatchSource.WIKI,root/html602/TGLBContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLBContainer.html
Deployability,update,update," Inherited Members; Includes; Libraries. Function documentation; TGLBContainer(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); Create a listbox container. ~TGLBContainer(); Delete the listbox container. void Layout(); Layout container. void DoRedraw(); redraw. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); Add listbox entry with hints to container. To show entry call; MapSubwindows() and Layout(). void InsertEntry(TGLBEntry* lbe, TGLayoutHints* lhints, Int_t afterID); Insert listbox entry after specified entry with id afterID. If afterID = -1; then add entry at head of list. To show entry call MapSubwindows() and; Layout(). void AddEntrySort(TGLBEntry* lbe, TGLayoutHints* lhints); Insert listbox entry before the list box entry with a higher id.; To show entry call MapSubwindows() and Layout(). void RemoveEntry(Int_t id); Remove the entry with specified id from the listbox container.; To update the listbox call Layout(). void RemoveEntries(Int_t from_ID, Int_t to_ID); Remove entries from from_ID to to_ID (including).; To update the listbox call Layout(). void RemoveAll(); Remove all entries in this container. TGLBEntry * Select(Int_t id); Select the entry with the specified id.; Returns the selected TGLBEntry. TGLBEntry * Select(Int_t id, Bool_t sel); Select / deselect the entry with the specified id.; Returns the selected TGLBEntry. Int_t GetSelected() const; Returns id of selected entry. In case of no selected entry or; if multi selection is switched on returns -1. Bool_t GetSelection(Int_t id); Returns kTrue if entry id is selected. void GetSelectedEntries(TList* selected); Adds all selected entries (TGLBEntry) of the list box into; the list selected. void SetMultipleSelections(Bool_t multi); Enables and disables multiple selections of entries. TGVScrollBar * GetVScrollbar() const; Return a pointer to vertical scroll bar. void SetVsbPosition(Int_t newPos); Set new vertical scroll",MatchSource.WIKI,root/html602/TGLBContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLBContainer.html
Integrability,message,messages,eElement*TGContainer::fLastActiveEllast active item; Bool_tTGContainer::fLastCasecase sensetivity of last search; Bool_tTGContainer::fLastDirdirection of last search; TStringTGContainer::fLastNamethe name of object of last search; Bool_tTGContainer::fLastSubstringsubstring search option of last search; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TGListBox*fListBoxlist box which contains this container; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGContainer::fMsgWindowwindow handling container messages; Bool_tfMultiSelecttrue if multi selection is switched on; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; Bool_tTGContainer::fOnMouseOverkTRUE when mouse pointer is over entry; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TTimer*TGContainer::fScrollTimerautoscroll timer; Bool_tTGContainer::fScrollingkTRUE - when scrolling is ON; Int_tTGContainer::fSelectednumber of selected items; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTGContainer::fTotaltotal items; TGViewPort*TGContainer::fViewPortcontainer viewport; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGContainer::fX0corner of rubber band box; Int_tTGContainer::fXDND; Int_tTGContainer::fXfother corner of rubber band box; Int_tTGContainer::fXpprevious pointer position; Int_tTGFrame::fY,MatchSource.WIKI,root/html602/TGLBContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLBContainer.html
Usability,simpl,simple,". TGLBContainer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLBContainer. class TGLBContainer: public TGContainer. TGListBox, TGLBContainer, TGLBEntry and TGTextLBEntry. A listbox is a box, possibly with scrollbar, containing entries.; Currently entries are simple text strings (TGTextLBEntry).; A TGListBox looks a lot like a TGCanvas. It has a TGViewPort; containing a TGLBContainer which contains the entries and it also; has a vertical scrollbar which becomes visible if there are more; items than fit in the visible part of the container. The TGListBox is user callable. The other classes are service; classes of the listbox. Selecting an item in the listbox will generate the event:; kC_COMMAND, kCM_LISTBOX, listbox id, item id. Function Members (Methods); public:. virtual~TGLBContainer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidActivateItem(TGFrameElement* el); virtual voidAddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidAddEntrySort(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTGContainer::AdjustPosition(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidAssociate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual c",MatchSource.WIKI,root/html602/TGLBContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLBContainer.html
Availability,error,error,"::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); Int_tEntryId() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option",MatchSource.WIKI,root/html602/TGLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLBEntry.html
Usability,simpl,simple,". TGLBEntry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLBEntry. class TGLBEntry: public TGFrame. TGListBox, TGLBContainer, TGLBEntry and TGTextLBEntry. A listbox is a box, possibly with scrollbar, containing entries.; Currently entries are simple text strings (TGTextLBEntry).; A TGListBox looks a lot like a TGCanvas. It has a TGViewPort; containing a TGLBContainer which contains the entries and it also; has a vertical scrollbar which becomes visible if there are more; items than fit in the visible part of the container. The TGListBox is user callable. The other classes are service; classes of the listbox. Selecting an item in the listbox will generate the event:; kC_COMMAND, kCM_LISTBOX, listbox id, item id. Function Members (Methods); public:. virtual~TGLBEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivate(Bool_t a); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* si",MatchSource.WIKI,root/html602/TGLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLBEntry.html
Performance,cache,cached,"ingBox& other); TGLBoundingBox(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); voidTransform(const TGLMatrix& matrix); voidTranslate(const TGLVector3& offset); const TGLVertex3&Vertex(UInt_t index) const; const TGLVertex3*Vertices() const; Double_tVolume() const; Double_tXMax() const; Double_tXMin() const; Double_tYMax() const; Double_tYMin() const; Double_tZMax() const; Double_tZMin() const. private:. Double_tMax(UInt_t index) const; Double_tMin(UInt_t index) const; voidUpdateCache(); Bool_tValidIndex(UInt_t index) const. Data Members; public:. static TGLBoundingBox::EFacekFaceCount; static TGLBoundingBox::EFacekFaceHighX; static TGLBoundingBox::EFacekFaceHighY; static TGLBoundingBox::EFacekFaceHighZ; static TGLBoundingBox::EFacekFaceLowX; static TGLBoundingBox::EFacekFaceLowY; static TGLBoundingBox::EFacekFaceLowZ. private:. TGLVector3fAxes[3]! box axes in global frame - cached for speed; TGLVector3fAxesNorm[3]! normalised box axes in global frame - cached for speed; Double_tfDiagonal! max box diagonal - cached for speed; TGLVertex3fVertex[8]! the 8 bounding box vertices; Double_tfVolume! box volume - cached for speed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLBoundingBox(); Construct an empty bounding box. TGLBoundingBox(const TGLVertex3 vertex[8]); Construct a bounding box from provided 8 vertices. TGLBoundingBox(const Double_t vertex[8][3]); Construct a bounding box from provided 8 vertices. TGLBoundingBox(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); Construct an global axis ALIGNED bounding box from provided low/high vertex pair. TGLBoundingBox(const TGLBoundingBox& other); Construct a bounding box as copy of existing one. ~TGLBoundingBox(); Destroy bounding box. void UpdateCache(); Update the internally cached volume and axes vectors - these are retained; for efficiency - many more reads than modifications. void Set(const TGLVertex3 vertex[8]); Set a bounding box from provided 8 ve",MatchSource.WIKI,root/html602/TGLBoundingBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLBoundingBox.html
Testability,test,tests,". TGLBoundingBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLBoundingBox. class TGLBoundingBox. TGLBoundingBox. Concrete class describing an orientated (free) or axis aligned box; of 8 verticies. Supports methods for setting aligned or orientated; boxes, find volume, axes, extents, centers, face planes etc.; Also tests for overlap testing of planes and other bounding boxes,; with fast sphere approximation. Function Members (Methods); public:. virtual~TGLBoundingBox(); const TGLVector3&Axis(UInt_t i, Bool_t normalised = kTRUE) const; TGLVertex3Center() const; static TClass*Class(); Double_tDiagonal() const; voidDraw(Bool_t solid = kFALSE) const; voidDump() const; voidExpandAligned(const TGLVertex3& point); TGLVector3Extents() const; const vector<UInt_t>&FaceVertices(TGLBoundingBox::EFace face) const; TGLPlaneGetNearPlane() const; virtual TClass*IsA() const; Bool_tIsEmpty() const; TGLVertex3MaxAAVertex() const; voidMergeAligned(const TGLBoundingBox& other); TGLVertex3MinAAVertex() const; Int_tNumVertices() const; TGLBoundingBox&operator=(const TGLBoundingBox& other); const TGLVertex3&operator[](UInt_t index) const; Rgl::EOverlapOverlap(const TGLPlane& plane) const; Rgl::EOverlapOverlap(const TGLBoundingBox& box) const; voidPlaneSet(TGLPlaneSet_t& planeSet) const; voidScale(Double_t factor); voidScale(Double_t xFactor, Double_t yFactor, Double_t zFactor); voidSet(const TGLVertex3[8] vertex); voidSet(const Double_t[8][3] vertex); voidSet(const TGLBoundingBox& other); voidSetAligned(const TGLVertex3& lowVertex, const TGLVertex3& highVertex); voidSetAligned(UInt_t nbPnts, const Double_t* pnts); voidSetEmpty(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLBoundingBox(); TGLBoundingBo",MatchSource.WIKI,root/html602/TGLBoundingBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLBoundingBox.html
Modifiability,variab,variable-sized,". TGLBoxPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLBoxPainter. class TGLBoxPainter: public TGLPlotPainter. Paints TH3 histograms by rendering variable-sized bozes matching the; bin contents. Function Members (Methods); public:. virtual~TGLBoxPainter(); virtual voidAddOption(const TString& stringOption); static TClass*Class(); Bool_tTGLPlotPainter::CutAxisSelected() const; Bool_tTGLPlotPainter::GetDrawAxes(); virtual char*GetPlotInfo(Int_t px, Int_t py); virtual Bool_tInitGeometry(); voidTGLPlotPainter::InvalidateSelection(); virtual TClass*IsA() const; virtual voidTGLPlotPainter::Paint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tTGLPlotPainter::PlotSelected(Int_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&TGLPlotPainter::RefBackBox() const; voidTGLPlotPainter::SetDrawAxes(Bool_t s); voidTGLPlotPainter::SetDrawBackBox(Bool_t b); voidTGLPlotPainter::SetDrawFrontBox(Bool_t b); virtual voidTGLPlotPainter::SetFrameColor(const TColor* frameColor); voidTGLPlotPainter::SetPadColor(const TColor* color); voidTGLPlotPainter::SetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLBoxPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); TGLBoxPainter(TH1* hist, TPolyMarker3D* pm, TGLPlotCamera* camera, TGLPlotCoordinates* coord). protected:. virtual voidTGLPlotPainter::ClearBuffers() const; voidTGLPlotPainter::DrawSections() const; const TColor*TGLPlotPainter::GetPadColor() const; voidTGLPlotPainter::MoveSection(Int_t px, Int_t py); voidTGLPlotPainter::PrintPlot() const; voidTGLPlotPainter::RestoreModelviewMatrix() const; voidTGLPlot",MatchSource.WIKI,root/html602/TGLBoxPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLBoxPainter.html
Availability,avail,available,"ex; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLCamera. class TGLCamera: public TObject. TGLCamera. Abstract base camera class - concrete classes for orthographic and; persepctive cameras derive from it. This class maintains values for; the current:; i) Viewport; ii) Projection, modelview and clip matricies - extracted from GL; iii) The 6 frustum planes; iv) Expanded frustum interest box. It provides methods for various projection, overlap and intersection; tests for viewport and world locations, against the true frustum and; expanded interest box, and for extracting eye position and direction. It also defines the pure virtual manipulation interface methods the; concrete ortho and prespective classes must implement. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLCamera(); voidTObject::AbstractMethod(const char* method) const; Bool_tAdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Double_tAdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidConfigure(Double_t zoom, Double_t dolly, Double_t[3] center, Double_t hRotate, Double_t vRotate); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual ",MatchSource.WIKI,root/html602/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLCamera.html
Deployability,configurat,configuration,"er last modifcation, before using. TGLVector3 ViewportDeltaToWorld(const TGLVertex3& worldRef, Double_t viewportXDelta, Double_t viewportYDelta, TGLMatrix* modviewMat = 0) const; Apply a 2D viewport delta (shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box, Bool_t ignoreSize) const; Calculate if the an object defined by world frame bounding box; is 'of interest' to the camera. This is defined as box:. i) intersecting completely or partially (kInside/kPartial) with; cameras interest box (fInterestBox); ii) having significant length OR volume ratio compared to this; interest box. If a box is 'of interest' returns kTRUE, kFALSE otherwise. See; TGLCamera::UpdateInterest() for more details of camera interest; box. Note: Length/volume ratios NOT dependent on the projected size; of box at current camera configuration as we do not want; continual changes. This is used when (re) populating the scene; with objects from external client. TODO: Might be more logical to move this test out to client -; and have accessor for fInterestBox instead?. Bool_t UpdateInterest(Bool_t force); Update the internal interest box (fInterestBox) of the camera.; The interest box is an orientated bounding box, calculated as; an expanded container round the frustum. It is used to test if; if object bounding boxes are of interest (should be accepted; into viewer scene) for a camera - see TGLCamera::OfInterest(). The interest box is updated if the frustum is no longer contained; in the existing one, or a new one calculated on the current frustum; differs significantly in volume (camera has been zoomed/dollyed; sizable amount). If the interest box is updated we return kTRUE - kFALSE otherwise. void ResetInterest(); Clear out the existing interest box. Bool_t AdjustAndClampVal(Double_t& val, Doub",MatchSource.WIKI,root/html602/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLCamera.html
Integrability,interface,interface,". TGLCamera. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLCamera. class TGLCamera: public TObject. TGLCamera. Abstract base camera class - concrete classes for orthographic and; persepctive cameras derive from it. This class maintains values for; the current:; i) Viewport; ii) Projection, modelview and clip matricies - extracted from GL; iii) The 6 frustum planes; iv) Expanded frustum interest box. It provides methods for various projection, overlap and intersection; tests for viewport and world locations, against the true frustum and; expanded interest box, and for extracting eye position and direction. It also defines the pure virtual manipulation interface methods the; concrete ortho and prespective classes must implement. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLCamera(); voidTObject::AbstractMethod(const char* method) const; Bool_tAdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Double_tAdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidConfigure(Double_t zoom, Double_t dolly, Double_t[3] center, Double_t hRotate, Double_t vRotate); virtual voidTObject::Copy(TObject& object) const; virtual voidTO",MatchSource.WIKI,root/html602/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLCamera.html
Modifiability,extend,extended,"near to far camera clip planes; (the minimum and maximum visible depth). See also; TGLVertex3 TGLCamera::ViewportToWorld(const TGLVertex3 & viewportVertex) const; for 3D viewport -> 3D world vertex conversions.; See also OpenGL gluUnProject & glDepth documentation. Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(Double_t viewportX, Double_t viewportY, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport point (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of Bool_t and TGLVertex3. If line intersects std::pair.first (Bool_t) is; kTRUE, and std::pair.second (TGLVertex) contains the intersection vertex.; If line does not intersect (line and plane parallel) std::pair.first; (Bool_t) if kFALSE, and std::pair.second (TGLVertex) is invalid. NOTE: The projection lines is extended for the plane intersection test; hence the intersection vertex can lie outside the near/far clip regions; (not visible). Camera must have valid frustum cache - call Apply() after last modifcation, before using. std::pair<Bool_t, TGLVertex3> ViewportPlaneIntersection(const TPoint& viewport, const TGLPlane& worldPlane) const; Find the intersection of projection of supplied viewport TPoint (a 3D world; line - see ViewportToWorld) with supplied world plane. Returns std::pair; of bool and vertex. If line intersects. Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 ViewportDeltaToWorld(const TGLVertex3& worldRef, Double_t viewportXDelta, Double_t viewportYDelta, TGLMatrix* modviewMat = 0) const; Apply a 2D viewport delta (shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box",MatchSource.WIKI,root/html602/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLCamera.html
Performance,cache,cached, static TObject::(anonymous)TObject::kOverwrite; static TGLCamera::EFrustumPlanekPlanesPerFrustum; static TGLCamera::EFrustumPlanekRight; static TObject::(anonymous)TObject::kSingleKey; static TGLCamera::EFrustumPlanekTop; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfCacheDirty! cached items dirty?; TGLMatrixfCamBasetranformation to center and rotation from up to x vector; TGLMatrixfCamTranstransformation relative to fCamTrans; TGLVector3*fCenter! current camera center; TGLMatrixfClipM! object space clip matrix (cached); TGLVector3fDefCenterdefault camera center; Double_tfDollyDefaultdefault distnce from viewing centre; Double_tfDollyDistanceunit distance for camera movement in fwd/bck direction; TGLVector3fExtCenterexternal camera center; Bool_tfExternalCenteruse external center insead of scene center; TGLVector3fFDCenterfixed default camera center; Double_tfFarClip! last applied far-clip; Bool_tfFixDefCenteruse fixed default center; TGLPlanefFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxfInterestBox! the interest box - created in UpdateInterest(); Double_tfLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixfLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixfModVM! modelView matrix (cached); Double_tfNearClip! last applied near-clip; TGLMatrixfProjM! projection matrix (cached); UInt_tfTimeStamp! timestamp; Float_tfVAxisMinAngleminimal allowed angle between up and fCamTrans Z vector; TGLRectfViewport! viewport (GL coords - origin bottom left); Bool_tfWasArcBalledset when arc-ball rotation is used; static UInt_tfgDollyDeltaSens. private:. TGLBoundingBoxfInterestFrustum! frustum basis of current interest box - NOT a true BB! (DEBUG); TGLBoundingBoxfInterestFrustumAsBox! frustum basis (as box) of current interest box (DEBUG); TGLBoundingBoxfPreviousInterestBox! previous interest box (DEBUG); static const Double_tfgInterestBoxExpansion! expansion c.f. al,MatchSource.WIKI,root/html602/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLCamera.html
Security,access,accessor,"(shift) to the projection of worldRef onto viewport,; returning the resultant world vector which equates to it. Useful for making; 3D world objects track mouse moves. Camera must have valid frustum cache - call Apply(). Bool_t OfInterest(const TGLBoundingBox& box, Bool_t ignoreSize) const; Calculate if the an object defined by world frame bounding box; is 'of interest' to the camera. This is defined as box:. i) intersecting completely or partially (kInside/kPartial) with; cameras interest box (fInterestBox); ii) having significant length OR volume ratio compared to this; interest box. If a box is 'of interest' returns kTRUE, kFALSE otherwise. See; TGLCamera::UpdateInterest() for more details of camera interest; box. Note: Length/volume ratios NOT dependent on the projected size; of box at current camera configuration as we do not want; continual changes. This is used when (re) populating the scene; with objects from external client. TODO: Might be more logical to move this test out to client -; and have accessor for fInterestBox instead?. Bool_t UpdateInterest(Bool_t force); Update the internal interest box (fInterestBox) of the camera.; The interest box is an orientated bounding box, calculated as; an expanded container round the frustum. It is used to test if; if object bounding boxes are of interest (should be accepted; into viewer scene) for a camera - see TGLCamera::OfInterest(). The interest box is updated if the frustum is no longer contained; in the existing one, or a new one calculated on the current frustum; differs significantly in volume (camera has been zoomed/dollyed; sizable amount). If the interest box is updated we return kTRUE - kFALSE otherwise. void ResetInterest(); Clear out the existing interest box. Bool_t AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Adjust a passed REFERENCE value 'val', based on screenShift delta.; Two modifier flags ('mod1' / 'mod2' ",MatchSource.WIKI,root/html602/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLCamera.html
Testability,test,tests,". TGLCamera. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLCamera. class TGLCamera: public TObject. TGLCamera. Abstract base camera class - concrete classes for orthographic and; persepctive cameras derive from it. This class maintains values for; the current:; i) Viewport; ii) Projection, modelview and clip matricies - extracted from GL; iii) The 6 frustum planes; iv) Expanded frustum interest box. It provides methods for various projection, overlap and intersection; tests for viewport and world locations, against the true frustum and; expanded interest box, and for extracting eye position and direction. It also defines the pure virtual manipulation interface methods the; concrete ortho and prespective classes must implement. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLCamera(); voidTObject::AbstractMethod(const char* method) const; Bool_tAdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Double_tAdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidConfigure(Double_t zoom, Double_t dolly, Double_t[3] center, Double_t hRotate, Double_t vRotate); virtual voidTObject::Copy(TObject& object) const; virtual voidTO",MatchSource.WIKI,root/html602/TGLCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLCamera.html
Availability,avail,available,". TGLClip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLClip. class TGLClip: public TGLPhysicalShape. TGLClip. Abstract clipping shape - derives from TGLPhysicalShape; Adds clip mode (inside/outside) and pure virtual method to; approximate shape as set of planes. This plane set is used to perform; interactive clipping using OpenGL clip planes. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLClip(); voidTGLPhysicalShape::AddReference(TGLPShapeRef* ref); const TGLBoundingBox&TGLPhysicalShape::BoundingBox() const; virtual voidTGLPhysicalShape::CalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*TGLPhysicalShape::Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*TGLPhysicalShape::GetLogical() const; TGLPhysicalShape::EManipTGLPhysicalShape::GetManip() const; TGLClip::EModeGetMode() const; const TGLPhysicalShape*TGLPhysicalShape::GetNextPhysical() const; TGLVector3TGLPhysicalShape::GetScale() const; UChar_tTGLPhysicalShape::GetSelected() const; TGLVertex3TGLPhysicalShape::GetTranslation() const; UInt_tTGLPhysicalShape::ID() const; voidIncTimeStamp(); voidInvalidate(); voidTGLPhysicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; Bool_tTGLPhysicalShape::IsInvisible() const; Bool_tTGLPhysicalShape::IsModified() const; Bool_tTGLPhysicalShape::IsSelected() const; Bool_tTGLPhysicalShape::IsTransparent() const; Bool_tIsValid() const; virtual voidModified(); TGLClip&operator=(const TGLClip&); virtual voidPlaneSet(TGLPlaneSet_t& set) const; virtual voidTGLPhysicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLO",MatchSource.WIKI,root/html602/TGLClip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLClip.html
Performance,perform,perform,". TGLClip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLClip. class TGLClip: public TGLPhysicalShape. TGLClip. Abstract clipping shape - derives from TGLPhysicalShape; Adds clip mode (inside/outside) and pure virtual method to; approximate shape as set of planes. This plane set is used to perform; interactive clipping using OpenGL clip planes. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLClip(); voidTGLPhysicalShape::AddReference(TGLPShapeRef* ref); const TGLBoundingBox&TGLPhysicalShape::BoundingBox() const; virtual voidTGLPhysicalShape::CalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*TGLPhysicalShape::Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*TGLPhysicalShape::GetLogical() const; TGLPhysicalShape::EManipTGLPhysicalShape::GetManip() const; TGLClip::EModeGetMode() const; const TGLPhysicalShape*TGLPhysicalShape::GetNextPhysical() const; TGLVector3TGLPhysicalShape::GetScale() const; UChar_tTGLPhysicalShape::GetSelected() const; TGLVertex3TGLPhysicalShape::GetTranslation() const; UInt_tTGLPhysicalShape::ID() const; voidIncTimeStamp(); voidInvalidate(); voidTGLPhysicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; Bool_tTGLPhysicalShape::IsInvisible() const; Bool_tTGLPhysicalShape::IsModified() const; Bool_tTGLPhysicalShape::IsSelected() const; Bool_tTGLPhysicalShape::IsTransparent() const; Bool_tIsValid() const; virtual voidModified(); TGLClip&operator=(const TGLClip&); virtual voidPlaneSet(TGLPlaneSet_t& set) const; virtual voidTGLPhysicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLO",MatchSource.WIKI,root/html602/TGLClip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLClip.html
Testability,log,logical,"tTGLPhysicalShape::ID() const; voidIncTimeStamp(); voidInvalidate(); voidTGLPhysicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; Bool_tTGLPhysicalShape::IsInvisible() const; Bool_tTGLPhysicalShape::IsModified() const; Bool_tTGLPhysicalShape::IsSelected() const; Bool_tTGLPhysicalShape::IsTransparent() const; Bool_tIsValid() const; virtual voidModified(); TGLClip&operator=(const TGLClip&); virtual voidPlaneSet(TGLPlaneSet_t& set) const; virtual voidTGLPhysicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD, Short_t& quantLOD) const; voidTGLPhysicalShape::RemoveReference(TGLPShapeRef* ref); voidTGLPhysicalShape::Rotate(const TGLVertex3& pivot, const TGLVector3& axis, Double_t angle); voidTGLPhysicalShape::Scale(const TGLVector3& scale); voidTGLPhysicalShape::Select(UChar_t select); voidTGLPhysicalShape::SetColor(const Float_t[17] rgba); voidTGLPhysicalShape::SetColorOnFamily(const Float_t[17] rgba); voidTGLPhysicalShape::SetDiffuseColor(const Float_t[4] rgba); voidTGLPhysicalShape::SetDiffuseColor(const UChar_t[4] rgba); voidTGLPhysicalShape::SetDiffuseColor(Color_t ci, UChar_t transparency); voidTGLPhysicalShape::SetManip(TGLPhysicalShape::EManip manip); voidSetMode(TGLClip::EMode mode); voidTGLPhysicalShape::SetTransform(const TGLMatrix& transform); voidTGLPhysicalShape::SetTransform(const Double_t[16] vals); voidTGLPhysicalShape::SetTranslation(const TGLVertex3& translation); virtual voidSetup(const TGLBoundingBox& bbox); virtual voidSetup(const TGLVector3&, const TGLVector3&); voidTGLPhysicalShape::SetupGLColors(TGLRnrCtx& rnrCtx, const Float_t* color = 0) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLClip(const TGLClip&); TGLClip(const TGLLogicalShape& logical, const TGLMatrix& transform, const float[4] color); UInt_tTimeStamp() const; voidTGLPhysicalShape::Translate(const TGLVector3& vect).",MatchSource.WIKI,root/html602/TGLClip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLClip.html
Deployability,update,update,"ape::EManipTGLPhysicalShape::kRotateY; static TGLPhysicalShape::EManipTGLPhysicalShape::kRotateZ; static TGLPhysicalShape::EManipTGLPhysicalShape::kScaleAll; static TGLPhysicalShape::EManipTGLPhysicalShape::kScaleX; static TGLPhysicalShape::EManipTGLPhysicalShape::kScaleY; static TGLPhysicalShape::EManipTGLPhysicalShape::kScaleZ; static TGLPhysicalShape::EManipTGLPhysicalShape::kTranslateAll; static TGLPhysicalShape::EManipTGLPhysicalShape::kTranslateX; static TGLPhysicalShape::EManipTGLPhysicalShape::kTranslateY; static TGLPhysicalShape::EManipTGLPhysicalShape::kTranslateZ. protected:. TGLClip::EModeTGLClip::fMode; UInt_tTGLClip::fTimeStamp; Bool_tTGLClip::fValid. private:. static const floatfgColor[4]! Fixed color of clip box. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLClipBox(); Construct an (initially) axis aligned clip pbox object, extents; 'halfLengths', centered on 'center' vertex.; Box can be translated, rotated and scaled in all (xyz) local axes. ~TGLClipBox(); Destroy clip box object. void Setup(const TGLBoundingBox& bbox); Setup the clip object for scene encompassed by bbox. void Setup(const TGLVector3& min_point, const TGLVector3& max_point); Setup the clip box with min/max points directly. This only makes sense if you disable auto-update of the; clip-object:; gl_viewer->SetClipAutoUpdate(kFALSE).; After calling this also call gl_viewer->RefreshPadEditor(gl_viewer); and gl_viewer->RequestDraw(). void PlaneSet(TGLPlaneSet_t& set) const; Return set of 6 planes describing faces of the box but invert them; so that they point inside of box. TGLClipBox(). TGLClipSet& operator=(const TGLClipBox& ). » Author: Richard Maunder 16/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLClipBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLClipBox.html
Deployability,update,update," UInt_tTGLClip::fTimeStamp; Bool_tTGLClip::fValid. private:. static const floatfgColor[4]! Fixed color of clip plane. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLClipPlane(); Construct a clip plane object, based on supplied 'plane', with; initial manipulation pivot at 'center', with drawn extents (in; local x/y axes) of 'extents'. Plane can have center pivot translated in all directions, and; rotated round center in X/Y axes , the in-plane axes. It cannot; be scaled. Note theorectically a plane is of course infinite - however we; want to draw the object in viewer - so we fake it with a single; GL face (polygon) - extents defines the width/depth of this -; should be several times scene extents - see Setup(). ~TGLClipPlane(); Destroy clip plane object. void Setup(const TGLBoundingBox& bbox); Setup the clip object for scene encompassed by bbox. void Setup(const TGLVector3& point, const TGLVector3& normal); Setup the clipping plane by point and normal.; Length of the normal determines the size of the plane drawn in; GL viewer. The normal points into the direction of visible half-plane. This only makes sense if you disable auto-update of the; clip-object:; gl_viewer->SetClipAutoUpdate(kFALSE).; After calling this also call gl_viewer->RefreshPadEditor(gl_viewer); and gl_viewer->RequestDraw(). void Set(const TGLPlane& plane); Update clip plane object to follow passed 'plane' equation. Center pivot; is shifted to nearest point on new plane. void PlaneSet(TGLPlaneSet_t& set) const; Return set of planes (actually a single one) describing this clip plane. TGLClipPlane(). TGLClipSet& operator=(const TGLClipPlane& ). » Author: Richard Maunder 16/09/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLClipPlane.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLClipPlane.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGLClipSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLClipSetEditor.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGLClipSetSubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLClipSetSubEditor.html
Deployability,update,update,"ed for suppression of signals; TGButtonGroup*fTypeButtons; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLClipSetSubEditor(const TGWindow* p); Constructor. void SetModel(TGLClipSet* m); Set model object. void Changed(); Emit Changed signal. void ClipValueChanged(); One of number entries was changed. void ClipTypeChanged(Int_t ); Clip type radio button changed - update viewer. void UpdateViewerClip(); Change clipping volume. void ResetViewerClip(); Reset transformation of the current clip. TGLClipSetSubEditor(const TGLClipSetSubEditor& ). TGLClipSetSubEditor& operator=(const TGLClipSetSubEditor& ). virtual ~TGLClipSetSubEditor(); {}. » Author: Matevz Tadel, Jun 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLClipSetSubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLClipSetSubEditor.html
Performance,cache,cached,". TGLColor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLColor. class TGLColor. Class encapsulating color information in preferred GL format - an; array of four unsigned bytes.; Color index is also cached for easier interfacing with the; traditional ROOT graphics. Function Members (Methods); public:. virtual~TGLColor(); UChar_t*Arr(); TStringAsString() const; const UChar_t*CArr() const; static TClass*Class(); UChar_tGetAlpha() const; UChar_tGetBlue() const; Color_tGetColorIndex() const; UChar_tGetGreen() const; UChar_tGetRed() const; Char_tGetTransparency() const; virtual TClass*IsA() const; TGLColor&operator=(const TGLColor& c); voidSetAlpha(Int_t v); voidSetBlue(Int_t v); voidSetColor(Color_t color_index); voidSetColor(Color_t color_index, Char_t transparency); voidSetColor(Int_t r, Int_t g, Int_t b, Int_t a = 255); voidSetColor(Float_t r, Float_t g, Float_t b, Float_t a = 1); voidSetGreen(Int_t v); voidSetRed(Int_t v); voidSetTransparency(Char_t transparency); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLColor(); TGLColor(const TGLColor&); TGLColor(Color_t color_index, Char_t transparency = 0); TGLColor(Int_t r, Int_t g, Int_t b, Int_t a = 255); TGLColor(Float_t r, Float_t g, Float_t b, Float_t a = 1). Data Members; protected:. Short_tfIndex; UChar_tfRGBA[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLColor(); Default constructor. Color is initialized to black. TGLColor(Int_t r, Int_t g, Int_t b, Int_t a = 255); Constructor from Int_t values. TGLColor(Float_t r, Float_t g, Float_t b, Float_t a = 1); Constructor from Float_t values. TGLColor(Color_t color_index, Char_t transparency = 0); Constructor from color-index and transp",MatchSource.WIKI,root/html602/TGLColor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLColor.html
Energy Efficiency,reduce,reduced," virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLContextIdentity(); TGLContextIdentity(const TGLContextIdentity&). private:. voidCheckDestroy(). Data Members; protected:. TGLFontManager*fFontManagerFreeType font manager. private:. Int_tfClientCnt; Int_tfCnt; TGLContextIdentity::CtxList_tfCtxs; TGLContextIdentity::DLTrash_tfDLTrash; static TGLContextIdentity*fgDefaultIdentity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLContextIdentity(); Constructor. ~TGLContextIdentity(); Destructor. void AddRef(TGLContext* ctx); Add context ctx to the list of references. void Release(TGLContext* ctx); Remove context ctx from the list of references. void RegisterDLNameRangeToWipe(UInt_t base, Int_t size); Remember dl range for deletion in next MakeCurrent or dtor execution. void DeleteGLResources(); Delete GL resources registered for destruction. TGLContextIdentity* GetCurrent(); Find identitfy of current context. Static. TGLContextIdentity* GetDefaultIdentity(); Get identity of a default Gl context. Static. TGLContext* GetDefaultContextAny(); Get the first GL context with the default identity.; Can return zero, but that's OK, too. Static. TGLFontManager* GetFontManager(); Get the free-type font-manager associated with this context-identity. void CheckDestroy(); Private function called when reference count is reduced. Bool_t IsValid() const; { return fValid; }. TGLContextIdentity(). void AddClientRef(); { ++fClientCnt; }. void ReleaseClient(); { --fClientCnt; CheckDestroy(); }. Int_t GetRefCnt() const; { return fCnt; }. Int_t GetClientRefCnt() const; { return fClientCnt; }. » Author: Timur Pocheptsov, Jun 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLContextIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLContextIdentity.html
Performance,cache,cached,"ss*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tDLOffset(Short_t lod) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; TGLCylinder&operator=(const TGLCylinder&); virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tQuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesSupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TGLCylinder(const TBuffer3DTube& buffer); TGLCylinder(const TGLCylinder&); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html602/TGLCylinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLCylinder.html
Availability,error,error,"char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTGLViewer::EndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGLViewer::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Bool_tTGLViewerBase::FindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); TGLLogicalShape*TGLViewerBase::FindLogicalInScenes(TObject* id); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGLAutoRotator*TGLViewer::GetAutoRotator(); TGLCameraOverlay*TGLViewer::GetCameraOverlay() const; Bool_tTGLViewer::GetClipAutoUpdate() const; TGLClipSet*TGLViewer::GetClipSet() const; TGLOverlayElement*TGLViewer::GetCurrentOvlElm() const; static TGLColorSet&TGLViewer::GetDefaultColorSet(); Int_tTGLViewer::GetDev() const; TGLV",MatchSource.WIKI,root/html602/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLEmbeddedViewer.html
Deployability,update,update,"(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TGLAutoRotator*TGLViewer::fAutoRotator!; Bool_tTGLViewer::fAxesDepthTest! remove guides hidden-lines; Int_tTGLViewer::fAxesType! axes type; TGLCamera*TGLViewerBase::fCameraCamera for rendering.; TGLCameraOverlay*TGLViewer::fCameraOverlay! markup size of viewport in scene units; Bool_tTGLViewerBase::fChangedChange requiring redraw is pending.; TGLClip*TGLViewerBase::fClipViewer clipping-plane.; TGLClipSet*TGLViewer::fClipSet!; TContextMenu*TGLViewer::fContextMenu!; TGLCamera*TGLViewer::fCurrentCamera!; TGLOverlayElement*TGLViewer::fCurrentOvlElm! current overlay element; TGLSelectRecordTGLViewer::fCurrentSelRec! select record in use as selected; TGLColorSetTGLViewer::fDarkColorSet! color-set with dark background; Bool_tTGLViewer::fDebugMode! debug mode (forced rebuild + draw scene/frustum/interest boxes); TGLViewer::EDragActionTGLViewer::fDragAction; Bool_tTGLViewer::fDrawCameraCenter! reference marker on?; TGEventHandler*TGLViewer::fEventHandler! event handler; Float_tTGLViewer::fFader! fade the view (0 - no fade/default, 1 - full fade/no rendering done); TGLContextIdentity*TGLViewer::fGLCtxId!for embedded gl viewer; Int_tTGLViewer::fGLDevice!for embedded gl viewer; TGLWidget*TGLViewer::fGLWidget; TGedEditor*TGLViewer::fGedEditor! GED editor; Bool_tTGLViewer::fIgnoreSizesOnUpdateignore sizes of bounding-boxes on update; Bool_tTGLViewer::fIsPrinting!; Short_tTGLViewerBase::fLODViewer-lod for rendering.; TGLColorSetTGLViewer::fLightColorSet! color-set with light background; TGLLightSet*TGLViewer::fLightSet!; Float_tTGLViewer::fLineScale! width scale for lines; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGLLockable::ELockTGLLockable::fLockLock state.; Float_tTGLViewer::fMaxSceneDrawTimeHQ! max time for scene rendering at high LOD (in ms); Float_tTGLViewer::fMaxSceneDrawTimeLQ! max time f",MatchSource.WIKI,root/html602/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLEmbeddedViewer.html
Performance,cache,cache,"cale! size scale for points; TGLViewer::EPushActionTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; TGLViewerBase::SceneInfoList_tTGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds; Bool_tTGLViewer::fSmoothLines! smooth line edge rendering; Bool_tTGLViewer::fSmoothPoints! smooth point edge rendering; Bool_tTGLViewer::fStereo! use stereo rendering; Float_tTGLViewer::fStereoEyeOffsetFac!; Float_tTGLViewer::fStereoFrustumAsymFac!; Float_tTGLViewer::fStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectTGLViewer::fViewport! viewport - drawn area; TGLViewerBase::SceneInfoVec_tTGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetTGLViewer::fgDefaultColorSet! a shared, default color-set; static Bool_tTGLViewer::fgUseDefaultColorSetForNewViewers! name says it all. private:. Int_tfBorder; TGCompositeFrame*fFrame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLEmbeddedVie",MatchSource.WIKI,root/html602/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLEmbeddedViewer.html
Testability,log,logicals,"cale! size scale for points; TGLViewer::EPushActionTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; TGLViewerBase::SceneInfoList_tTGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds; Bool_tTGLViewer::fSmoothLines! smooth line edge rendering; Bool_tTGLViewer::fSmoothPoints! smooth point edge rendering; Bool_tTGLViewer::fStereo! use stereo rendering; Float_tTGLViewer::fStereoEyeOffsetFac!; Float_tTGLViewer::fStereoFrustumAsymFac!; Float_tTGLViewer::fStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectTGLViewer::fViewport! viewport - drawn area; TGLViewerBase::SceneInfoVec_tTGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetTGLViewer::fgDefaultColorSet! a shared, default color-set; static Bool_tTGLViewer::fgUseDefaultColorSetForNewViewers! name says it all. private:. Int_tfBorder; TGCompositeFrame*fFrame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLEmbeddedVie",MatchSource.WIKI,root/html602/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLEmbeddedViewer.html
Usability,guid,guides,"::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TGLLockable::ELockTGLLockable::kModifyLock; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TGLViewer::ESecSelTypeTGLViewer::kOnKeyMod1; static TGLViewer::ESecSelTypeTGLViewer::kOnRequest; static TObject::(anonymous)TObject::kOverwrite; static TGLViewer::EPushActionTGLViewer::kPushAnnotate; static TGLViewer::EPushActionTGLViewer::kPushCamCenter; static TGLViewer::EPushActionTGLViewer::kPushStd; static TGLLockable::ELockTGLLockable::kSelectLock; static TObject::(anonymous)TObject::kSingleKey; static TGLLockable::ELockTGLLockable::kUnlocked; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TGLAutoRotator*TGLViewer::fAutoRotator!; Bool_tTGLViewer::fAxesDepthTest! remove guides hidden-lines; Int_tTGLViewer::fAxesType! axes type; TGLCamera*TGLViewerBase::fCameraCamera for rendering.; TGLCameraOverlay*TGLViewer::fCameraOverlay! markup size of viewport in scene units; Bool_tTGLViewerBase::fChangedChange requiring redraw is pending.; TGLClip*TGLViewerBase::fClipViewer clipping-plane.; TGLClipSet*TGLViewer::fClipSet!; TContextMenu*TGLViewer::fContextMenu!; TGLCamera*TGLViewer::fCurrentCamera!; TGLOverlayElement*TGLViewer::fCurrentOvlElm! current overlay element; TGLSelectRecordTGLViewer::fCurrentSelRec! select record in use as selected; TGLColorSetTGLViewer::fDarkColorSet! color-set with dark background; Bool_tTGLViewer::fDebugMode! debug mode (forced rebuild + draw scene/frustum/interest boxes); TGLViewer::EDragActionTGLViewer::fDragAction; Bool_tTGLViewer::fDrawCameraCenter! reference marker on?; TGEventHandler*TGLViewer::fEventHandler! event handler; Float_tTGLViewer::fFader! fade the view (0 - no fade/default, 1 - full fade/no rendering done); TGLContextIdentity*TGLVi",MatchSource.WIKI,root/html602/TGLEmbeddedViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLEmbeddedViewer.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetArcBall() const; Bool_tGetDoInternalSelection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetSecSelType() const; virtual const char*TNamed::GetTitle() const; Int_t",MatchSource.WIKI,root/html602/TGLEventHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLEventHandler.html
Modifiability,config,configure,"void SelectForMouseOver(); Run selection (optionally with on secondary selection) and emit; corresponding MouseOver() signals.; Protected method. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Process event of type 'event' - one of EEventType types,; occuring at window location px, py; This is provided for use when embedding GL viewer into pad. Bool_t HandleEvent(Event_t* event); Handle generic Event_t type 'event' - provided to catch focus changes; and terminate any interaction in viewer. Bool_t HandleFocusChange(Event_t* event); Handle generic Event_t type 'event' - provided to catch focus changes; and terminate any interaction in viewer. Bool_t HandleCrossing(Event_t* event); Handle generic Event_t type 'event' - provided to catch focus changes; and terminate any interaction in viewer. Bool_t HandleButton(Event_t* event); Handle mouse button 'event'. Bool_t HandleDoubleClick(Event_t* event); Handle mouse double click 'event'. Bool_t HandleConfigureNotify(Event_t* event); Handle configure notify 'event' - a window resize/movement. Bool_t HandleExpose(Event_t* event); Handle window expose 'event' - show. Bool_t HandleKey(Event_t* event); Handle keyboard 'event'. Bool_t HandleMotion(Event_t* event); Handle mouse motion 'event'. Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Method to handle action TGLViewer::kDragCameraRotate. Bool_t HandleTimer(TTimer* t); If mouse delay timer times out emit signal. void StartMouseTimer(); Start mouse timer in single-shot mode. void StopMouseTimer(); Make sure mouse timers are not running. void ClearMouseOver(); Clear mouse-over state and emit mouse-over signals.; Current overlay element is also told the mouse has left. void Repaint(); Handle window expose 'event' - show. void PopupContextMenu(TGLPhysicalShape* pshp, Event_t* event, Int_t gx, Int_t gy); Popup context menu. void TriggerTooltip(const char* text); Trigger display of tooltip. void RemoveTooltip(); Hide the tooltip. void SetMouseOverSelectDela",MatchSource.WIKI,root/html602/TGLEventHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLEventHandler.html
Security,expose,expose,"; corresponding MouseOver() signals.; Protected method. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Process event of type 'event' - one of EEventType types,; occuring at window location px, py; This is provided for use when embedding GL viewer into pad. Bool_t HandleEvent(Event_t* event); Handle generic Event_t type 'event' - provided to catch focus changes; and terminate any interaction in viewer. Bool_t HandleFocusChange(Event_t* event); Handle generic Event_t type 'event' - provided to catch focus changes; and terminate any interaction in viewer. Bool_t HandleCrossing(Event_t* event); Handle generic Event_t type 'event' - provided to catch focus changes; and terminate any interaction in viewer. Bool_t HandleButton(Event_t* event); Handle mouse button 'event'. Bool_t HandleDoubleClick(Event_t* event); Handle mouse double click 'event'. Bool_t HandleConfigureNotify(Event_t* event); Handle configure notify 'event' - a window resize/movement. Bool_t HandleExpose(Event_t* event); Handle window expose 'event' - show. Bool_t HandleKey(Event_t* event); Handle keyboard 'event'. Bool_t HandleMotion(Event_t* event); Handle mouse motion 'event'. Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Method to handle action TGLViewer::kDragCameraRotate. Bool_t HandleTimer(TTimer* t); If mouse delay timer times out emit signal. void StartMouseTimer(); Start mouse timer in single-shot mode. void StopMouseTimer(); Make sure mouse timers are not running. void ClearMouseOver(); Clear mouse-over state and emit mouse-over signals.; Current overlay element is also told the mouse has left. void Repaint(); Handle window expose 'event' - show. void PopupContextMenu(TGLPhysicalShape* pshp, Event_t* event, Int_t gx, Int_t gy); Popup context menu. void TriggerTooltip(const char* text); Trigger display of tooltip. void RemoveTooltip(); Hide the tooltip. void SetMouseOverSelectDelay(Int_t ms); Set delay of mouse-over probe (highlight). void SetMouseOverTooltipDelay(Int_",MatchSource.WIKI,root/html602/TGLEventHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLEventHandler.html
Performance,cache,cached," voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; voidEnforceTriangles(); static Bool_tGetEnforceTriangles(); TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); UInt_tGetNbPols(); vector<Double_t>&GetNormals(); vector<Int_t>&GetPolyDesc(); TGLScene*TGLLogicalShape::GetScene() const; vector<Double_t>&GetVertices(); TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; TGLFaceSet&operator=(const TGLFaceSet&); TGLFaceSet&operator=(TGLFaceSet&&); virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidSetEnforceTriangles(Bool_t e); voidSetFromMesh(const RootCsg::TBaseMesh* m); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TGLFaceSet(const TBuffer3D& buffer); TGLFaceSet(const TGLFaceSet&); TGLFaceSet(TGLFaceSet&&); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html602/TGLFaceSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLFaceSet.html
Testability,test,test,"delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!); static Bool_tTGLLogicalShape::fgIgnoreSizeForCameraInterest. private:. UInt_tfNbPols; vector<Double_t>fNormals; vector<Int_t>fPolyDesc; vector<Double_t>fVertices; static Bool_tfgEnforceTriangles. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLFaceSet(const TBuffer3D& buffer); constructor. void SetFromMesh(const RootCsg::TBaseMesh* m); Should only be done on an empty faceset object. void EnforceTriangles(); Use GLU tesselator to replace all polygons with N > 3 with triangles.; After this call polygon descriptions are changed.; New vertices are not expected -- exception is thrown if this is; requested by the triangulator. Support for adding of new vertices can be; provided. void DirectDraw(TGLRnrCtx& rnrCtx) const; Debug tracing. Int_t CheckPoints(const Int_t* source, Int_t* dest) const; CheckPoints. Bool_t Eq(const Double_t* p1, const Double_t* p2); test equality. void CalculateNormals(); CalculateNormals. Bool_t GetEnforceTriangles(); Get current state of static flag EnforceTriangles. void SetEnforceTriangles(Bool_t e); Set state of static flag EnforceTriangles.; When this is set, all tesselations will be automatically converted into; triangle-only meshes.; This is needed to export TGeo shapes and CSG meshes to external; triangle-mesh libraries that can not handle arbitrary polygons. TGLFaceSet(const TBuffer3D& buffer). std::vector<Double_t>& GetVertices(); { return fVertices; }. std::vector<Double_t>& GetNormals(); { return fNormals; }. std::vector<Int_t>& GetPolyDesc(); { return fPolyDesc; }. UInt_t GetNbPols(); { return fNbPols; }. void GLDrawPolys() const. » Author: Timur Pocheptsov 03/08/2004 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:52; This page has been automatically generated. For comments or suggestions regarding the docum",MatchSource.WIKI,root/html602/TGLFaceSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLFaceSet.html
Energy Efficiency,allocate,allocated,"rs (Methods); public:. virtual~TGLFBO(); voidBind(); voidBindTexture(); static TClass*Class(); voidInit(int w, int h, int ms_samples = 0); virtual TClass*IsA() const; voidRelease(); voidSetAsReadBuffer(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLFBO(); voidUnbind(); voidUnbindTexture(). protected:. UInt_tCreateAndAttachColorTexture(); UInt_tCreateAndAttachRenderBuffer(Int_t format, Int_t type); voidInitMultiSample(); voidInitStandard(). private:. TGLFBO&operator=(const TGLFBO&); TGLFBO(const TGLFBO&). Data Members; protected:. UInt_tfColorTexture; UInt_tfDepthBuffer; UInt_tfFrameBuffer; Int_tfH; Float_tfHScale; Bool_tfIsRescaled; UInt_tfMSColorBuffer; Int_tfMSCoverageSamples; UInt_tfMSFrameBuffer; Int_tfMSSamples; Int_tfW; Float_tfWScale; static Bool_tfgMultiSampleNAWarned; static Bool_tfgRescaleToPow2. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLFBO(); Constructor. ~TGLFBO(); Destructor. void Init(int w, int h, int ms_samples = 0); Acquire GL resources for given width, height and number of; multi-sampling samples. void Release(); Release the allocated GL resources. void Bind(); Bind the frame-buffer object. void Unbind(); Unbind the frame-buffer object. void BindTexture(); Bind texture. void UnbindTexture(); Unbind texture. void SetAsReadBuffer(). void InitStandard(). void InitMultiSample(). UInt_t CreateAndAttachRenderBuffer(Int_t format, Int_t type). UInt_t CreateAndAttachColorTexture(); Initialize color-texture and attach it to current FB. TGLFBO(const TGLFBO& ). TGLFBO& operator=(const TGLFBO& ). » Author: Matevz Tadel, Aug 2009 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLFBO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLFBO.html
Integrability,wrap,wrapper,". TGLFont. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLFont. class TGLFont. TGLFont. A wrapper class for FTFont.; Holds pointer to FTFont object and its description: face size, font file; and class ID. It wraps Render and BBox functions. Function Members (Methods); public:. virtual~TGLFont(); voidBBox(const char* txt, Float_t& llx, Float_t& lly, Float_t& llz, Float_t& urx, Float_t& ury, Float_t& urz) const; voidBBox(const wchar_t* txt, Float_t& llx, Float_t& lly, Float_t& llz, Float_t& urx, Float_t& ury, Float_t& urz) const; static TClass*Class(); voidCopyAttributes(const TGLFont& o); Float_tGetAscent() const; Float_tGetDepth() const; Float_tGetDescent() const; Int_tGetFile() const; const FTFont*GetFont() const; Float_tGetLineHeight() const; const TGLFontManager*GetManager() const; TGLFont::EModeGetMode() const; Int_tGetSize() const; Int_tGetTrashCount() const; Int_tIncTrashCount() const; virtual TClass*IsA() const; voidMeasureBaseLineParams(Float_t& ascent, Float_t& descent, Float_t& line_height, const char* txt = ""Xj"") const; Bool_toperator<(const TGLFont& o) const; virtual voidPostRender() const; virtual voidPreRender(Bool_t autoLight = kTRUE, Bool_t lightOn = kFALSE) const; voidRender(const TString& txt) const; voidRender(const char* txt, Double_t x, Double_t y, Double_t angle, Double_t mgn) const; voidRender(const wchar_t* txt, Double_t x, Double_t y, Double_t angle, Double_t mgn) const; voidRender(const TString& txt, Float_t x, Float_t y, Float_t z, TGLFont::ETextAlignH_e alignH, TGLFont::ETextAlignV_e alignV) const; voidSetDepth(Float_t d); voidSetFont(FTFont* f); voidSetManager(TGLFontManager* mng); voidSetTrashCount(Int_t c) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual",MatchSource.WIKI,root/html602/TGLFont.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLFont.html
Availability,avail,availabe,"irtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLFontManager(). protected:. static voidInitStatics(). private:. TGLFontManager&operator=(const TGLFontManager&); TGLFontManager(const TGLFontManager&). Data Members; protected:. TGLFontManager::FontMap_tfFontMapmap of created fonts; TGLFontManager::FontList_tfFontTrashfonts to purge; static Int_tfgExtendedFontStart; static TObjArrayfgFontFileArraymap font-id to ttf-font-file; static TGLFontManager::FontSizeVec_tfgFontSizeArraymap of valid font-size; static Bool_tfgStaticInitDoneglobal initialization flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLFontManager(); Destructor. void RegisterFont(Int_t size, Int_t file, TGLFont::EMode mode, TGLFont& out); Provide font with given size, file and FTGL class. void RegisterFont(Int_t size, const char* name, TGLFont::EMode mode, TGLFont& out); Get mapping from ttf id to font names. Table taken from TTF.cxx. void ReleaseFont(TGLFont& font); Release font with given attributes. Returns false if font has; not been found in the managers font set. TObjArray* GetFontFileArray(); Get id to file name map. Int_t GetExtendedFontStartIndex(). Int_t GetFontSize(Int_t ds); Get availabe font size. Int_t GetFontSize(Int_t ds, Int_t min, Int_t max); Get availabe font size. const char* GetFontNameFromId(Int_t ); Get font name from TAttAxis font id. void InitStatics(); Create a list of available font files and allowed font sizes. void ClearFontTrash(); Delete FTFFont objects registered for destruction. TGLFont& operator=(const TGLFontManager& ). TGLFontManager(const TGLFontManager& ). TGLFontManager(); {}. FontSizeVec_t* GetFontSizeArray(). » Author: Alja Mrak-Tadel 2008 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLFontManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLFontManager.html
Integrability,depend,depends,"Size(Int_t depth); voidSetDoubleBuffered(Bool_t db); voidSetSamples(Int_t samples); voidSetStencilSize(Int_t stencil); voidSetStereo(Bool_t db); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLFormat(); TGLFormat(Rgl::EFormatOptions options); TGLFormat(const TGLFormat&). private:. static Int_tGetDefaultSamples(); static voidInitAvailableSamples(). Data Members; private:. Int_tfAccumSize; Int_tfDepthSize; Bool_tfDoubleBuffered; Int_tfSamples; Int_tfStencilSize; Bool_tfStereo; static vector<Int_t>fgAvailableSamples. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLFormat(); 16-bits needed for some virtual machines (VirtualBox) and Xming-mesa; (when running ssh from windows to linux).; All others seem to have 24-bit depth-buffers only and use this anyway.; Default ctor. Default surface is:; -double buffered; -RGBA; -with depth buffer; -no accumulation buffer; -with stencil; -multi-sampling depends on seeting of ""OpenGL.Framebuffer.Multisample"". TGLFormat(Rgl::EFormatOptions options); Define surface using options. ~TGLFormat(); Destructor. Int_t GetDepthSize() const; Get the size of depth buffer. void SetDepthSize(Int_t depth); Set the size of color buffer. Bool_t HasDepth() const; Check, if this surface has depth buffer. Int_t GetStencilSize() const; Get the size of stencil buffer. void SetStencilSize(Int_t stencil); Set the size of stencil buffer. Bool_t HasStencil() const; Check, if this surface has stencil buffer. Int_t GetAccumSize() const; Get the size of accum buffer. void SetAccumSize(Int_t accum); Set the size of accum buffer. Bool_t HasAccumBuffer() const; Check, if this surface has accumulation buffer. Bool_t IsDoubleBuffered() const; Check, if the surface is double buffered. void SetDoubleBuffered(Bool_t db); Set the surface as double/single buffered. Bool_t IsStereo() const; Check, if the surface is stereo buffere",MatchSource.WIKI,root/html602/TGLFormat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLFormat.html
Deployability,update,updates,"TGLPlotPainter::fHist; TPointTGLPlotPainter::fMousePosition; Double_tTGLPlotPainter::fPadPhi; Double_tTGLPlotPainter::fPadTheta; const Float_t*TGLPlotPainter::fPhysicalShapeColor; Int_tTGLPlotPainter::fSelectedPart; TGLSelectionBufferTGLPlotPainter::fSelection; Int_tTGLPlotPainter::fSelectionBase; Bool_tTGLPlotPainter::fSelectionPass; Bool_tTGLPlotPainter::fUpdateSelection; TAxis*TGLPlotPainter::fXAxis; Double_tTGLPlotPainter::fXOYSectionPos; Double_tTGLPlotPainter::fXOZSectionPos; TAxis*TGLPlotPainter::fYAxis; Double_tTGLPlotPainter::fYOZSectionPos; TAxis*TGLPlotPainter::fZAxis; vector<Double_t>TGLPlotPainter::fZLevels; static TGLPlotPainter::ESelectionBaseTGLPlotPainter::kHighColorSelectionBase; static TGLPlotPainter::ESelectionBaseTGLPlotPainter::kTrueColorSelectionBase. private:. vector<Int_t>fBinColors; TStringfBinInfoUsed by GetPlotInfo.; list<Rgl::Pad::Tesselation_t>fCapsCaps for all bins.; vector<Double_t>fPolygonTemporary array for polygon's vertices.; Bool_tfZLogChange in logZ updates only bin heights.; Double_tfZMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLH2PolyPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Ctor. char * GetPlotInfo(Int_t px, Int_t py); Show number of bin and bin contents, if bin is under the cursor. Bool_t InitGeometry(); Tesselate polygons, if not done yet.; All pointers are validated here (and in functions called from here).; If any pointer is invalid - zero, or has unexpected type (dynamic_cast fails) -; InitGeometry will return false and nothing will be painted later.; That's why there are no checks in other functions. void StartPan(Int_t px, Int_t py); User clicks on a lego with middle mouse button (middle for pad). void Pan(Int_t px, Int_t py); Mouse events handler. void AddOption(const TString& stringOption); No additional options. void ProcessEvent(Int_t event, Int_t px, Int_t py); No events. void InitGL() const; Initialize some gl state variables. void D",MatchSource.WIKI,root/html602/TGLH2PolyPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLH2PolyPainter.html
Modifiability,variab,variables,"vertices.; Bool_tfZLogChange in logZ updates only bin heights.; Double_tfZMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLH2PolyPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Ctor. char * GetPlotInfo(Int_t px, Int_t py); Show number of bin and bin contents, if bin is under the cursor. Bool_t InitGeometry(); Tesselate polygons, if not done yet.; All pointers are validated here (and in functions called from here).; If any pointer is invalid - zero, or has unexpected type (dynamic_cast fails) -; InitGeometry will return false and nothing will be painted later.; That's why there are no checks in other functions. void StartPan(Int_t px, Int_t py); User clicks on a lego with middle mouse button (middle for pad). void Pan(Int_t px, Int_t py); Mouse events handler. void AddOption(const TString& stringOption); No additional options. void ProcessEvent(Int_t event, Int_t px, Int_t py); No events. void InitGL() const; Initialize some gl state variables. void DeInitGL() const; Return some gl states to original values. void DrawPlot() const; Draw extruded polygons and plot's frame. void DrawExtrusion() const; Extruded part of bins.; GL_QUADS, GL_QUAD_STRIP - have the same time on my laptop, so I use; GL_QUADS and forgot about vertex arrays (can require more memory BTW). void DrawExtrusion(const TGraph* polygon, Double_t zMin, Double_t zMax, Int_t nBin) const; Extrude polygon, described by TGraph. void DrawExtrusion(const TMultiGraph* polygon, Double_t zMin, Double_t zMax, Int_t nBin) const; Multigraph contains a list of graphs, draw them. void DrawCaps() const; Caps on bins. void DrawCap(TGLH2PolyPainter::CIter_t cap, Int_t bin) const; Draw a cap on top of a bin. Bool_t CacheGeometry(); Cache all data for TH2Poly object. Bool_t BuildTesselation(Rgl::Pad::Tesselator& tess, const TGraph* g, Double_t z); Tesselate a polygon described by TGraph. Bool_t BuildTesselation(Rgl::Pad::Tesselator& tess, const TMultiGra",MatchSource.WIKI,root/html602/TGLH2PolyPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLH2PolyPainter.html
Security,validat,validated,"lotPainter::fXOYSectionPos; Double_tTGLPlotPainter::fXOZSectionPos; TAxis*TGLPlotPainter::fYAxis; Double_tTGLPlotPainter::fYOZSectionPos; TAxis*TGLPlotPainter::fZAxis; vector<Double_t>TGLPlotPainter::fZLevels; static TGLPlotPainter::ESelectionBaseTGLPlotPainter::kHighColorSelectionBase; static TGLPlotPainter::ESelectionBaseTGLPlotPainter::kTrueColorSelectionBase. private:. vector<Int_t>fBinColors; TStringfBinInfoUsed by GetPlotInfo.; list<Rgl::Pad::Tesselation_t>fCapsCaps for all bins.; vector<Double_t>fPolygonTemporary array for polygon's vertices.; Bool_tfZLogChange in logZ updates only bin heights.; Double_tfZMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLH2PolyPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Ctor. char * GetPlotInfo(Int_t px, Int_t py); Show number of bin and bin contents, if bin is under the cursor. Bool_t InitGeometry(); Tesselate polygons, if not done yet.; All pointers are validated here (and in functions called from here).; If any pointer is invalid - zero, or has unexpected type (dynamic_cast fails) -; InitGeometry will return false and nothing will be painted later.; That's why there are no checks in other functions. void StartPan(Int_t px, Int_t py); User clicks on a lego with middle mouse button (middle for pad). void Pan(Int_t px, Int_t py); Mouse events handler. void AddOption(const TString& stringOption); No additional options. void ProcessEvent(Int_t event, Int_t px, Int_t py); No events. void InitGL() const; Initialize some gl state variables. void DeInitGL() const; Return some gl states to original values. void DrawPlot() const; Draw extruded polygons and plot's frame. void DrawExtrusion() const; Extruded part of bins.; GL_QUADS, GL_QUAD_STRIP - have the same time on my laptop, so I use; GL_QUADS and forgot about vertex arrays (can require more memory BTW). void DrawExtrusion(const TGraph* polygon, Double_t zMin, Double_t zMax, Int_t nBin) const; Extrude poly",MatchSource.WIKI,root/html602/TGLH2PolyPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLH2PolyPainter.html
Testability,log,logZ,"TGLPlotPainter::fHist; TPointTGLPlotPainter::fMousePosition; Double_tTGLPlotPainter::fPadPhi; Double_tTGLPlotPainter::fPadTheta; const Float_t*TGLPlotPainter::fPhysicalShapeColor; Int_tTGLPlotPainter::fSelectedPart; TGLSelectionBufferTGLPlotPainter::fSelection; Int_tTGLPlotPainter::fSelectionBase; Bool_tTGLPlotPainter::fSelectionPass; Bool_tTGLPlotPainter::fUpdateSelection; TAxis*TGLPlotPainter::fXAxis; Double_tTGLPlotPainter::fXOYSectionPos; Double_tTGLPlotPainter::fXOZSectionPos; TAxis*TGLPlotPainter::fYAxis; Double_tTGLPlotPainter::fYOZSectionPos; TAxis*TGLPlotPainter::fZAxis; vector<Double_t>TGLPlotPainter::fZLevels; static TGLPlotPainter::ESelectionBaseTGLPlotPainter::kHighColorSelectionBase; static TGLPlotPainter::ESelectionBaseTGLPlotPainter::kTrueColorSelectionBase. private:. vector<Int_t>fBinColors; TStringfBinInfoUsed by GetPlotInfo.; list<Rgl::Pad::Tesselation_t>fCapsCaps for all bins.; vector<Double_t>fPolygonTemporary array for polygon's vertices.; Bool_tfZLogChange in logZ updates only bin heights.; Double_tfZMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLH2PolyPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Ctor. char * GetPlotInfo(Int_t px, Int_t py); Show number of bin and bin contents, if bin is under the cursor. Bool_t InitGeometry(); Tesselate polygons, if not done yet.; All pointers are validated here (and in functions called from here).; If any pointer is invalid - zero, or has unexpected type (dynamic_cast fails) -; InitGeometry will return false and nothing will be painted later.; That's why there are no checks in other functions. void StartPan(Int_t px, Int_t py); User clicks on a lego with middle mouse button (middle for pad). void Pan(Int_t px, Int_t py); Mouse events handler. void AddOption(const TString& stringOption); No additional options. void ProcessEvent(Int_t event, Int_t px, Int_t py); No events. void InitGL() const; Initialize some gl state variables. void D",MatchSource.WIKI,root/html602/TGLH2PolyPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLH2PolyPainter.html
Availability,error,error,,MatchSource.WIKI,root/html602/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLHistPainter.html
Energy Efficiency,green,green,"rfaces.; ; TH3 as color boxes - (TGLVoxelPainter); The supported option is:; ; ""GLCOL"" : TH3 is drawn using semi-transparent colored boxes.; See $ROOTSYS/tutorials/gl/glvox1.C.; ; TF3 (implicit function) - (TGLTF3Painter); The supported option is:; ; ""GLTF3"" : Draw a TF3.; ; Parametric surfaces - (TGLParametricPlot); $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric equations and; visualize the surface. Interaction with the plots. General information. All the interactions are implemented via standard methods DistancetoPrimitive and; ExecuteEvent. That's why all the interactions with the OpenGL plots are possible i; only when the mouse cursor is in the plot's area (the plot's area is the part of a the pad; occupied by gl-produced picture). If the mouse cursor is not above gl-picture,; the standard pad interaction is performed.; Selectable parts. Different parts of the plot can be selected:; ; xoz, yoz, xoy back planes:; When such a plane selected, it's highlighted in green if the dynamic slicing; by this plane is supported, and it's highlighted in red, if the dynamic slicing; is not supported.; The plot itself:; On surfaces, the selected surface is outlined in red. (TF3 and ISO are not; outlined). On lego plots, the selected bin is highlihted. The bin number and content are displayed in pad's status; bar. In box plots, the box or sphere is highlighted and the bin info is displayed in pad's status bar.; ; Rotation and zooming. Rotation:; ; When the plot is selected, it can be rotated by pressing and holding the left mouse button and move the cursor.; Zoom/Unzoom:; ; Mouse wheel or 'j', 'J', 'k', 'K' keys.; ; Panning. The selected plot can be moved in a pad's area by; pressing and holding the left mouse button and the shift key. Box cut; Surface, iso, box, TF3 and parametric painters support box cut by pressing the 'c' or; 'C' key when the mouse cursor is in a plot's area. That will display a transparent box,; cutting away part of the surface (or boxes",MatchSource.WIKI,root/html602/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLHistPainter.html
Integrability,message,message,"_tIsInside(Double_t x, Double_t y); Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual Int_tMakeCuts(char* cutsOpt); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidPaint(Option_t* option); virtual voidPaintStat(Int_t dostat, TF1* fit); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidProcessMessage(const char* message, const TObject* obj); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetHistogram(TH1* hist); static voidTObject::SetObjectStat(Bool_t stat); static voidTVirtualHistPainter::SetPainter(const char* painter); virtual voidSetShowProjection(const char* option, Int_t nbins); virtual voidSetStack(TList* stack); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const",MatchSource.WIKI,root/html602/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLHistPainter.html
Performance,perform,performed,"n content.; ""GLBOX1"": the same as ""glbox"", but spheres are drawn instead of boxes.; ; TH3 as iso-surface(s) - (TGLIsoPainter); The supported option is:; ; ""GLISO"" : TH3 is drawn using iso-surfaces.; ; TH3 as color boxes - (TGLVoxelPainter); The supported option is:; ; ""GLCOL"" : TH3 is drawn using semi-transparent colored boxes.; See $ROOTSYS/tutorials/gl/glvox1.C.; ; TF3 (implicit function) - (TGLTF3Painter); The supported option is:; ; ""GLTF3"" : Draw a TF3.; ; Parametric surfaces - (TGLParametricPlot); $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric equations and; visualize the surface. Interaction with the plots. General information. All the interactions are implemented via standard methods DistancetoPrimitive and; ExecuteEvent. That's why all the interactions with the OpenGL plots are possible i; only when the mouse cursor is in the plot's area (the plot's area is the part of a the pad; occupied by gl-produced picture). If the mouse cursor is not above gl-picture,; the standard pad interaction is performed.; Selectable parts. Different parts of the plot can be selected:; ; xoz, yoz, xoy back planes:; When such a plane selected, it's highlighted in green if the dynamic slicing; by this plane is supported, and it's highlighted in red, if the dynamic slicing; is not supported.; The plot itself:; On surfaces, the selected surface is outlined in red. (TF3 and ISO are not; outlined). On lego plots, the selected bin is highlihted. The bin number and content are displayed in pad's status; bar. In box plots, the box or sphere is highlighted and the bin info is displayed in pad's status bar.; ; Rotation and zooming. Rotation:; ; When the plot is selected, it can be rotated by pressing and holding the left mouse button and move the cursor.; Zoom/Unzoom:; ; Mouse wheel or 'j', 'J', 'k', 'K' keys.; ; Panning. The selected plot can be moved in a pad's area by; pressing and holding the left mouse button and the shift key. Box cut; Surface, iso, box, TF3 and p",MatchSource.WIKI,root/html602/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLHistPainter.html
Testability,log,logarithmic,". TGLHistPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLHistPainter. class TGLHistPainter: public TVirtualHistPainter. The histogram painter class using OpenGL; Histograms are, by default, drawn via the THistPainter class.; TGLHistPainter allows to paint them using the OpenGL 3D graphics; library. The plotting options provided by TGLHistPainter start with; GL keyword.; General information: plot types and supported options; The following types of plots are provided:. Lego - (TGLLegoPainter); The supported options are:; ; ""GLLEGO"" : Draw a lego plot.; ""GLLEGO2"" : Bins with color levels.; ""GLLEGO3"" : Cylindrical bars.; ; Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y (if you see; what it means).; Surfaces (TF2 and TH2 with ""GLSURF"" options) - (TGLSurfacePainter); The supported options are:; ; ""GLSURF"" : Draw a surface.; ""GLSURF1"" : Surface with color levels; ""GLSURF2"" : The same as ""GLSURF1"" but without polygon outlines.; ""GLSURF3"" : Color level projection on top of plot (works only in cartesian coordinate system).; ""GLSURF4"" : Same as ""GLSURF"" but without polygon outlines.; ; The surface painting in cartesian coordinates supports logarithmic scales along X, Y, Z axis.; In polar coordinates only the Z axis can be logarithmic, in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:; The supported options are:; ; "" "" : Default, cartesian coordinates system.; ""POL"" : Polar coordinates system.; ""CYL"" : Cylindrical coordinates system.; ""SPH"" : Spherical coordinates system.; ; TH3 as boxes (spheres) - (TGLBoxPainter); The supported options are:; ; ""GLBOX"" : TH3 as a set of boxes, size of box is proportional to bin content.; ""GLBOX1"": the same as ""glbox"", ",MatchSource.WIKI,root/html602/TGLHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLHistPainter.html
Availability,error,error,"t char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); Int_tTGLBEntry::EntryId() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGTextLBEntry::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGTextLBEntry::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtu",MatchSource.WIKI,root/html602/TGLineLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLineLBEntry.html
Usability,simpl,simple,". TGLineLBEntry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLineLBEntry. class TGLineLBEntry: public TGTextLBEntry. TGListBox, TGLBContainer, TGLBEntry and TGTextLBEntry. A listbox is a box, possibly with scrollbar, containing entries.; Currently entries are simple text strings (TGTextLBEntry).; A TGListBox looks a lot like a TGCanvas. It has a TGViewPort; containing a TGLBContainer which contains the entries and it also; has a vertical scrollbar which becomes visible if there are more; items than fit in the visible part of the container. The TGListBox is user callable. The other classes are service; classes of the listbox. Selecting an item in the listbox will generate the event:; kC_COMMAND, kCM_LISTBOX, listbox id, item id. Function Members (Methods); public:. virtual~TGLineLBEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGLBEntry::Activate(Bool_t a); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect",MatchSource.WIKI,root/html602/TGLineLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLineLBEntry.html
Availability,down,down,". TGLineStyleComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLineStyleComboBox. class TGLineStyleComboBox: public TGComboBox. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. virtual~TGLineStyleComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGComboBox::AddEntry(TGString* s, Int_t id); virtual voidTGComboBox::AddEntry(const char* s, Int_t id); virtual voidTGComboBox::AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); st",MatchSource.WIKI,root/html602/TGLineStyleComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLineStyleComboBox.html
Availability,down,down,". TGLineWidthComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLineWidthComboBox. class TGLineWidthComboBox: public TGComboBox. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. virtual~TGLineWidthComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGComboBox::AddEntry(TGString* s, Int_t id); virtual voidTGComboBox::AddEntry(const char* s, Int_t id); virtual voidTGComboBox::AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); st",MatchSource.WIKI,root/html602/TGLineWidthComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLineWidthComboBox.html
Modifiability,variab,variables," TGLIsoPainter::MeshList_tfIsos; Rgl::Range_tfMinMax; TGLLevelPalettefPalette; TGLTH3SlicefXOYSlice; TGLTH3SlicefXOZSlice; TGLTH3SlicefYOZSlice. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLIsoPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Constructor. char * GetPlotInfo(Int_t px, Int_t py); Return info for plot part under cursor. Bool_t InitGeometry(); Initializes meshes for 3d iso contours. void StartPan(Int_t px, Int_t py); User clicks right mouse button (in a pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement.; User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. void AddOption(const TString& option); No additional options for TGLIsoPainter. void ProcessEvent(Int_t event, Int_t px, Int_t py); Change color sheme. void InitGL() const; Initialize OpenGL state variables. void DeInitGL() const; Initialize OpenGL state variables. void DrawPlot() const; Draw mesh. void DrawSectionXOZ() const; Draw XOZ parallel section. void DrawSectionYOZ() const; Draw YOZ parallel section. void DrawSectionXOY() const; Draw XOY parallel section. Bool_t HasSections() const; Any section exists. void SetSurfaceColor(Int_t ind) const; Set color for surface. void SetMesh(TGLIsoPainter::Mesh_t& mesh, Double_t isoValue); Grid geometry. void DrawMesh(const TGLIsoPainter::Mesh_t& mesh, Int_t level) const; Draw TF3 surface. void FindMinMax(); Find max/min bin contents for TH3. TGLIsoPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord). » Author: Timur Pocheptsov 31/08/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to RO",MatchSource.WIKI,root/html602/TGLIsoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLIsoPainter.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; virtual TGFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html602/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGListBox.html
Integrability,rout,routine,"youtHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGListBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kSunkenFrame | kDoubleBorder, Pixel_t back = GetWhitePixel()); Create a listbox. ~TGListBox(); Delete a listbox widget. void InitListBox(); Initiate the internal classes of a list box. void DrawBorder(); Draw borders of the list box widget. void AddEntry(TGString* s, Int_t id); Add entry with specified string and id to listbox. The id will be; used in the event processing routine when the item is selected.; The string will be adopted by the listbox. void AddEntry(const char* s, Int_t id); Add entry with specified string and id to listbox. The id will be; used in the event processing routine when the item is selected. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); Add specified TGLBEntry and TGLayoutHints to listbox. The; entry and layout will be adopted and later deleted by the listbox. void AddEntrySort(TGString* s, Int_t id); Add entry with specified string and id to listbox sorted by increasing id.; This sorting works proberly only if EntrySort functions are used to add; entries without mixing them with other add or insert functions. The id will be; used in the event processing routine when the item is selected.; The string will be adopted by the listbox. void AddEntrySort(const char* s, Int_t id); Add entry with specified string and id to listbox sorted by increasing id.; This sorting works proberly only if EntrySort functions are used ",MatchSource.WIKI,root/html602/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGListBox.html
Usability,simpl,simple,". TGListBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGListBox. class TGListBox: public TGCompositeFrame, public TGWidget. TGListBox, TGLBContainer, TGLBEntry and TGTextLBEntry. A listbox is a box, possibly with scrollbar, containing entries.; Currently entries are simple text strings (TGTextLBEntry).; A TGListBox looks a lot like a TGCanvas. It has a TGViewPort; containing a TGLBContainer which contains the entries and it also; has a vertical scrollbar which becomes visible if there are more; items than fit in the visible part of the container. The TGListBox is user callable. The other classes are service; classes of the listbox. Selecting an item in the listbox will generate the event:; kC_COMMAND, kCM_LISTBOX, listbox id, item id. Function Members (Methods); public:. virtual~TGListBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddEntry(TGString* s, Int_t id); virtual voidAddEntry(const char* s, Int_t id); virtual voidAddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidAddEntrySort(TGString* s, Int_t id); virtual voidAddEntrySort(const char* s, Int_t id); virtual voidAddEntrySort(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t opt",MatchSource.WIKI,root/html602/TGListBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGListBox.html
Availability,down,downward,". TGListDetailsLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGListDetailsLayout. class TGListDetailsLayout: public TGTileLayout. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. virtual~TGListDetailsLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMEN",MatchSource.WIKI,root/html602/TGListDetailsLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGListDetailsLayout.html
Availability,down,downward,". TGListLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGListLayout. class TGListLayout: public TGTileLayout. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. virtual~TGListLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject:",MatchSource.WIKI,root/html602/TGListLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGListLayout.html
Availability,mask,mask,"ate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); voidCheckAllChildren(TGListTreeItem* item, Bool_t state); virtual voidChecked(TObject* obj, Bool_t check)SIGNAL ; voidCheckItem(TGListTreeItem* item, Bool_t check = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClearHighlighted(); virtual voidTGContainer::ClearViewPort(); virtual voidClicked(TGListTreeItem* entry, Int_t btn)SIGNAL ; virtual voidClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y)SIGNAL ; virtual voidClicked(TGListTreeItem* entry, Int_t btn, UInt_t mask, Int_t x, Int_t y)SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidCloseItem(TGListTreeItem* item); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDataDropped(TGListTreeItem* item, TDNDData* data)SIGNAL ; virtual voidTGFrame::Delete(Option_t* = """"); Int_tDeleteChildren(TGListTreeItem* item); Int_tDeleteItem(TGListTreeItem* item); Int_tDeleteSelected()MENU ;",MatchSource.WIKI,root/html602/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGListTree.html
Integrability,message,messages,t search; Bool_tTGContainer::fLastDirdirection of last search; UInt_tfLastEventStatemodifier state of the last keyboard event; TStringTGContainer::fLastNamethe name of object of last search; Bool_tTGContainer::fLastSubstringsubstring search option of last search; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; GContext_tfLineGCdashed line drawing context; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; Int_tfMarginnumber of pixels margin from left side; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGContainer::fMsgWindowwindow handling container messages; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; Bool_tTGContainer::fOnMouseOverkTRUE when mouse pointer is over entry; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TTimer*TGContainer::fScrollTimerautoscroll timer; Bool_tTGContainer::fScrollingkTRUE - when scrolling is ON; TGListTreeItem*fSelectedpointer to selected item in list; Int_tTGContainer::fSelectednumber of selected items; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGToolTip*fTiptooltip shown when moving over list items; TGListTreeItem*fTipItemitem for which tooltip is set; Int_tTGContainer::fTotaltotal items; Bool_tfUserControlledlet user decides what is the behaviour on events; TGViewPort*TGContainer::fViewPortcontainer viewport; Int_tfVspacingvertical spacing between items; UInt_tTGFrame::fWidthframe widt,MatchSource.WIKI,root/html602/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGListTree.html
Usability,clear,clear,"::DestroyWindow(); voidDisableOpen(Bool_t disable = kTRUE); Bool_tTQObject::Disconnect(const char* signal = 0, void* receiver = 0, const char* slot = 0); static Bool_tTQObject::Disconnect(TQObject* sender, const char* signal = 0, void* receiver = 0, const char* slot = 0); static Bool_tTQObject::Disconnect(const char* class_name, const char* signal, void* receiver = 0, const char* slot = 0); virtual voidTQObject::Disconnected(const char*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDoubleClicked(TGListTreeItem* entry, Int_t btn)SIGNAL ; virtual voidDoubleClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y)SIGNAL ; virtual voidDrawActive(Handle_t id, TGListTreeItem* item); virtual voidTGFrame::DrawBorder(); virtual voidTGFrame::DrawClass() const; virtual TObject*TGFrame::DrawClone(Option_t* = """") const; virtual voidTGFrame::DrawCopy(Handle_t, Int_t, Int_t); virtual voidDrawOutline(Handle_t id, TGListTreeItem* item, Pixel_t col = 12303291, Bool_t clear = kFALSE); virtual voidDrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGFrame::Dump() const; voidTQObject::Emit(const char* signal); voidTQObject::Emit(const char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::Emi",MatchSource.WIKI,root/html602/TGListTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGListTree.html
Availability,avail,available,". TGListTreeItem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGListTreeItem. class TGListTreeItem. TGListTree and TGListTreeItem. A list tree is a widget that can contain a number of items; arranged in a tree structure. The items are represented by small; folder icons that can be either open or closed. The TGListTree is user callable. The TGListTreeItem is a service; class of the list tree. A list tree can generate the following events:; kC_LISTTREE, kCT_ITEMCLICK, which button, location (y<<16|x).; kC_LISTTREE, kCT_ITEMDBLCLICK, which button, location (y<<16|x). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGListTreeItem(); virtual voidCheckAllChildren(Bool_t = kTRUE); virtual voidCheckChildren(TGListTreeItem*, Bool_t); virtual voidCheckItem(Bool_t = kTRUE); static TClass*Class(); virtual voidClearColor(); virtual Pixel_tGetActiveColor() const; virtual const TGPicture*GetCheckBoxPicture() const; virtual Color_tGetColor() const; TGListTreeItem*GetFirstChild() const; TGListTreeItem*GetLastChild() const; TGListTreeItem*GetNextSibling() const; TGListTreeItem*GetParent() const; virtual const TGPicture*GetPicture() const; virtual UInt_tGetPicWidth() const; TGListTreeItem*GetPrevSibling() const; virtual const char*GetText() const; virtual Int_tGetTextLength() const; virtual const char*GetTipText() const; virtual Int_tGetTipTextLength() const; virtual void*GetUserData() const; virtual voidHandleDrag(); virtual voidHandleDrop(); virtual Bool_tHandlesDragAndDrop() const; virtual Bool_tHasCheckBox() const; virtual Bool_tHasCheckedChild(Bool_t = kFALSE); virtual Bool_tHasColor() const; virtual Bool_tHasUnCheckedChild(Bool_t = kFALSE); virtual TClass*IsA() const; virt",MatchSource.WIKI,root/html602/TGListTreeItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGListTreeItem.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; TGFrame*TGCanvas::GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCanvas::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGF",MatchSource.WIKI,root/html602/TGListView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGListView.html
Integrability,message,messages,"xt and cmode is the x text; alignmode for the item text. const char * GetHeader(Int_t idx) const; Returns name of header idx. If illegal idx or header not set for idx; 0 is returned. void SetDefaultHeaders(); Default headers are: Name, Attributes, Size, Owner, Group, Modified.; The default is good for file system items. void SetViewMode(EListViewMode viewMode); Set list view mode. void SetContainer(TGFrame* f); Set list view container. Container must be at least of type; TGLVContainer. void SetIncrements(Int_t hInc, Int_t vInc); Set horizontal and vertical scrollbar increments. void SetDefaultColumnWidth(TGVFileSplitter* splitter); Set default column width of the columns headers. void ResizeColumns(); Resize column headers to show whole item names. void Layout(); Layout list view components (container and contents of container). void LayoutHeader(TGFrame* head); Layout list view components (container and contents of container). Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle messages generated by the list view components. void Clicked(TGLVEntry* entry, Int_t btn); Emit Clicked() signal. void Clicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void DoubleClicked(TGLVEntry* entry, Int_t btn); Emit DoubleClicked() signal. void DoubleClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Emit DoubleClicked() signal. FontStruct_t GetDefaultFontStruct(); Return the default font structure in use. const TGGC & GetDefaultGC(); Return the default graphics context in use. void SavePrimitive(ostream& out, Option_t* option = """"); Save a list view widget as a C++ statement(s) on output stream out. TGLVEntry& operator=(const TGListView& ). EListViewMode GetViewMode() const; { return fViewMode; }. TGListView(const TGListView& ). void AdjustHeaders(); { fJustChanged = kTRUE; LayoutHeader(0); }. TGTextButton** GetHeaderButtons(); { return fColHeader; }. UInt_t GetNumColumns(); { return fNColumns; }. TGDimension GetMaxItemSize() const;",MatchSource.WIKI,root/html602/TGListView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGListView.html
Modifiability,variab,variables,"Range_t>fXEdges; vector<Rgl::Range_t>fYEdges; static TGLLegoPainter::ELegoTypekColorLevel; static TGLLegoPainter::ELegoTypekColorSimple; static TGLLegoPainter::ELegoTypekCylindricBars. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLegoPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Ctor. char * GetPlotInfo(Int_t px, Int_t py); Obtain bin's info (i, j, value). Bool_t InitGeometry(); Select method. Bool_t InitGeometryCartesian(); Geometry for lego in cartesian coords. Bool_t InitGeometryPolar(); Geometry for lego in polar coords. Bool_t InitGeometryCylindrical(); Geometry for lego in cylindrical coords. Bool_t InitGeometrySpherical(); Geometry for lego in spherical coords. void StartPan(Int_t px, Int_t py); User clicks on a lego with middle mouse button (middle for pad). void Pan(Int_t px, Int_t py); Move lego or section. void AddOption(const TString& stringOption); Parse additional options. void InitGL() const; Initialize some gl state variables. void DeInitGL() const; Return some gl states to original values. void DrawPlot() const; Select method corresponding to coordinate system. void DrawLegoCartesian() const; Lego in cartesian system. void DrawLegoPolar() const; Lego in polar system. void DrawLegoCylindrical() const; Lego in cylindrical system. void DrawLegoSpherical() const; Lego in spherical system. void SetLegoColor() const; Set lego's color. void DrawSectionXOZ() const; XOZ plane parallel section. void DrawSectionYOZ() const; YOZ plane parallel section. void DrawSectionXOY() const; Empty. No such sections for lego. void ProcessEvent(Int_t event, Int_t px, Int_t py); Remove all sections and repaint. Bool_t ClampZ(Double_t& zVal) const; Clamp z value. Bool_t PreparePalette() const; Initialize color palette. void DrawPalette() const; Draw. Palette.; Originally, fCamera was never null.; It can be a null now because of gl-viewer. void DrawPaletteAxis() const; Draw. Palette. Axis. TGLLegoPainter(c",MatchSource.WIKI,root/html602/TGLLegoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLLegoPainter.html
Availability,error,error," virtual~TGLLightSet(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetFrontPower() const; virtual const char*TObject::GetIconName() const; UInt_tGetLightState(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::G",MatchSource.WIKI,root/html602/TGLLightSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLLightSet.html
Energy Efficiency,power,power,"BitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TGLLightSet::ELightkLightBottom; static TGLLightSet::ELightkLightFront; static TGLLightSet::ELightkLightLeft; static TGLLightSet::ELightkLightMask; static TGLLightSet::ELightkLightRight; static TGLLightSet::ELightkLightSpecular; static TGLLightSet::ELightkLightTop; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_tfFrontPower! power of the front lamp; UInt_tfLightState! light states (on/off) mask; Float_tfSidePower! power of the side lamps; Float_tfSpecularPower! power of specular lamp; Bool_tfUseSpecular!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLightSet(); Constructor. void ToggleLight(TGLLightSet::ELight light); Toggle light on/off. void SetLight(TGLLightSet::ELight light, Bool_t on); Set a light on/off. void StdSetupLights(const TGLBoundingBox& bbox, const TGLCamera& camera, Bool_t debug = kFALSE); Setup lights for current given bounding box and camera.; This is called by standard GL viewer.; Expects matrix-mode to be model-view. TGLLightSet(const TGLLightSet& ). TGLLightSet& operator=(const TGLLightSet& ). virtual ~TGLLightSet(); {}. UInt_t GetLightState(); { return fLightState; }. Bool_t GetUseSpecular() const; { return fUseSpecular; }. void SetUseSpecular(Bool_t s); { fUseSpecular = s; }. Float_t GetFrontPower() const; { return fFrontPower; }. Float_t GetSidePower() const; { return fSidePower; }. Float_t GetSpecularPower() cons",MatchSource.WIKI,root/html602/TGLLightSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLLightSet.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGLLightSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLLightSetEditor.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGLLightSetSubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLLightSetSubEditor.html
Integrability,wrap,wraps,". TGLLine3. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLine3. class TGLLine3. TGLLine3. 3D space, fixed length, line class, with direction / length 'vector',; passing through point 'vertex'. Just wraps a TGLVector3 / TGLVertex3; pair. Function Members (Methods); public:. virtual~TGLLine3(); static TClass*Class(); voidDraw() const; const TGLVertex3End() const; virtual TClass*IsA() const; TGLLine3&operator=(const TGLLine3&); voidSet(const TGLVertex3& start, const TGLVertex3& end); voidSet(const TGLVertex3& start, const TGLVector3& vector); virtual voidShowMembers(TMemberInspector& insp) const; const TGLVertex3&Start() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLLine3(const TGLLine3&); TGLLine3(const TGLVertex3& start, const TGLVertex3& end); TGLLine3(const TGLVertex3& start, const TGLVector3& vector); const TGLVector3&Vector() const. Data Members; private:. TGLVector3fVector! Vector of line from fVertex; TGLVertex3fVertex! Start vertex of line. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLine3(const TGLVertex3& start, const TGLVertex3& end); Construct 3D line running from 'start' to 'end'. TGLLine3(const TGLVertex3& start, const TGLVector3& vector); Construct 3D line running from 'start', magnitude 'vect'. ~TGLLine3(); Destroy 3D line object. void Set(const TGLVertex3& start, const TGLVertex3& end); Set 3D line running from 'start' to 'end'. void Set(const TGLVertex3& start, const TGLVector3& vector); Set 3D line running from start, magnitude 'vect'. void Draw() const; Draw line in current basic GL color. Assume we are in the correct reference; frame. TGLLine3(const TGLVertex3& start, const TGLVertex3& end). const TGLVertex3 & Start() const; Bitwise copy constructor and = ope",MatchSource.WIKI,root/html602/TGLLine3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLLine3.html
Availability,failure,failure,"IdStr() const; static const char*LockName(TGLLockable::ELock lock); static Bool_tLockValid(TGLLockable::ELock lock); Bool_tReleaseLock(TGLLockable::ELock lock) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Bool_tTakeLock(TGLLockable::ELock lock) const; TGLLockable(). private:. TGLLockable&operator=(const TGLLockable&); TGLLockable(const TGLLockable&). Data Members; public:. static TGLLockable::ELockkDrawLock; static TGLLockable::ELockkModifyLock; static TGLLockable::ELockkSelectLock; static TGLLockable::ELockkUnlocked. protected:. TGLLockable::ELockfLockLock state. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLockable(); Constructor. Bool_t TakeLock(TGLLockable::ELock lock) const; Lock the object in mode 'lock'. Return TRUE if successful, FALSE; if the object is already locked. Bool_t ReleaseLock(TGLLockable::ELock lock) const; Release current lock, make sure it the same as the 'lock' argument.; Returns TRUE on success, FALSE on failure. const char* LockName(TGLLockable::ELock lock); Return name-string for given lock-type. Bool_t LockValid(TGLLockable::ELock lock); Test if lock is a valid type to take/release.; kUnlocked is never valid in these cases. TGLLockable(const TGLLockable& ). TGLLockable& operator=(const TGLLockable& ). virtual ~TGLLockable(); {}. const char* LockIdStr() const; { return ""<unknown>""; }. Bool_t IsLocked() const; { return (fLock != kUnlocked); }. ELock CurrentLock() const; { return fLock; }. Bool_t IsDrawOrSelectLock() const; { return fLock == kDrawLock || fLock == kSelectLock; }. » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLLockable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLLockable.html
Deployability,release,release,"IdStr() const; static const char*LockName(TGLLockable::ELock lock); static Bool_tLockValid(TGLLockable::ELock lock); Bool_tReleaseLock(TGLLockable::ELock lock) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Bool_tTakeLock(TGLLockable::ELock lock) const; TGLLockable(). private:. TGLLockable&operator=(const TGLLockable&); TGLLockable(const TGLLockable&). Data Members; public:. static TGLLockable::ELockkDrawLock; static TGLLockable::ELockkModifyLock; static TGLLockable::ELockkSelectLock; static TGLLockable::ELockkUnlocked. protected:. TGLLockable::ELockfLockLock state. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLockable(); Constructor. Bool_t TakeLock(TGLLockable::ELock lock) const; Lock the object in mode 'lock'. Return TRUE if successful, FALSE; if the object is already locked. Bool_t ReleaseLock(TGLLockable::ELock lock) const; Release current lock, make sure it the same as the 'lock' argument.; Returns TRUE on success, FALSE on failure. const char* LockName(TGLLockable::ELock lock); Return name-string for given lock-type. Bool_t LockValid(TGLLockable::ELock lock); Test if lock is a valid type to take/release.; kUnlocked is never valid in these cases. TGLLockable(const TGLLockable& ). TGLLockable& operator=(const TGLLockable& ). virtual ~TGLLockable(); {}. const char* LockIdStr() const; { return ""<unknown>""; }. Bool_t IsLocked() const; { return (fLock != kUnlocked); }. ELock CurrentLock() const; { return fLock; }. Bool_t IsDrawOrSelectLock() const; { return fLock == kDrawLock || fLock == kSelectLock; }. » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLLockable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLLockable.html
Integrability,interface,interface,". TGLLockable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLockable. class TGLLockable. TGLLockable. Simple locking interface used by viewer and scene. Function Members (Methods); public:. virtual~TGLLockable(); static TClass*Class(); TGLLockable::ELockCurrentLock() const; virtual TClass*IsA() const; Bool_tIsDrawOrSelectLock() const; Bool_tIsLocked() const; virtual const char*LockIdStr() const; static const char*LockName(TGLLockable::ELock lock); static Bool_tLockValid(TGLLockable::ELock lock); Bool_tReleaseLock(TGLLockable::ELock lock) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Bool_tTakeLock(TGLLockable::ELock lock) const; TGLLockable(). private:. TGLLockable&operator=(const TGLLockable&); TGLLockable(const TGLLockable&). Data Members; public:. static TGLLockable::ELockkDrawLock; static TGLLockable::ELockkModifyLock; static TGLLockable::ELockkSelectLock; static TGLLockable::ELockkUnlocked. protected:. TGLLockable::ELockfLockLock state. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLockable(); Constructor. Bool_t TakeLock(TGLLockable::ELock lock) const; Lock the object in mode 'lock'. Return TRUE if successful, FALSE; if the object is already locked. Bool_t ReleaseLock(TGLLockable::ELock lock) const; Release current lock, make sure it the same as the 'lock' argument.; Returns TRUE on success, FALSE on failure. const char* LockName(TGLLockable::ELock lock); Return name-string for given lock-type. Bool_t LockValid(TGLLockable::ELock lock); Test if lock is a valid type to take/release.; kUnlocked is never valid in these cases. TGLLockable(const TGLLockable& ). TGLLockable& operator=(const TGLLockable& ). virtual ~TGLLockable()",MatchSource.WIKI,root/html602/TGLLockable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLLockable.html
Availability,avail,available,"ical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes do not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how external viewer clients use it. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLLogicalShape(); voidAddRef(TGLPhysicalShape* phys) const; virtual Bool_tAlwaysSecondarySelect() const; const TGLBoundingBox&BoundingBox() const; static TClass*Class(); voidDestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidDLCacheClear(); virtual voidDLCacheDrop(); virtual voidDLCachePurge(); virtual UInt_tDLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidDrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*GetExternal() const; const TGLPhysicalShape*GetFirstPhysical() const; static Bool_tGetIgnoreSizeForCameraInterest(); TGLScene*GetScene() const; TObject*ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidInvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Sho",MatchSource.WIKI,root/html602/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLLogicalShape.html
Energy Efficiency,reduce,reduces,":; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes do not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how e",MatchSource.WIKI,root/html602/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLLogicalShape.html
Integrability,depend,dependent,"ref (delete on 0 ref); not in scene; TGLScene*fScene! scene where object is stored (can be zero!); static Bool_tfgIgnoreSizeForCameraInterest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLLogicalShape(); Constructor. TGLLogicalShape(TObject* obj); Constructor with external object. TGLLogicalShape(const TBuffer3D& buffer); Constructor from TBuffer3D. ~TGLLogicalShape(); Destroy logical shape. void AddRef(TGLPhysicalShape* phys) const; Add reference to given physical shape. void SubRef(TGLPhysicalShape* phys) const; Remove reference to given physical shape, potentially deleting; *this* object when hitting zero ref-count (if fRefStrong is; true). void DestroyPhysicals(); Destroy all physicals attached to this logical. UInt_t UnrefFirstPhysical(); Unreference first physical in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);; b) secondary selection is not in progress as different; render-path is usually taken in this case. Otherwise we return internal bool. Override this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids from GL context. void DLCacheDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Pur",MatchSource.WIKI,root/html602/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLLogicalShape.html
Performance,perform,performed," description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes do not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how external viewer clients use it. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look",MatchSource.WIKI,root/html602/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLLogicalShape.html
Safety,detect,detector,":; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes do not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how e",MatchSource.WIKI,root/html602/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLLogicalShape.html
Testability,log,logical,". TGLLogicalShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLLogicalShape. class TGLLogicalShape. Abstract logical shape - a GL 'drawable' - base for all shapes -; faceset sphere etc. Logical shapes are a unique piece of geometry,; described in it's local frame - e.g if we have three spheres in :; Sphere A - Radius r1, center v1; Sphere B - Radius r2, center v2; Sphere C - Radius r1, center v3. Spheres A and C can share a common logical sphere of radius r1 - and; place them with two physicals with translations of v1 & v2. Sphere B; requires a different logical (radius r2), placed with physical with; translation v2. Physical shapes know about and can share logicals. Logicals do not; about (aside from reference counting) physicals or share them. This sharing of logical shapes greatly reduces memory consumption and; scene (re)build times in typical detector geometries which have many; repeated objects placements. TGLLogicalShapes have reference counting, performed by the client; physical shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes do not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; ",MatchSource.WIKI,root/html602/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLLogicalShape.html
Usability,simpl,simply,"ly discreet LOD values,; especially in view of display-list caching.; This function should be overriden to perform the desired quantization.; See TGLSphere. void Draw(TGLRnrCtx& rnrCtx) const; Draw the GL drawable, using draw flags. If DL caching is enabled; (see SetDLCache) then attempt to draw from the cache, if not found; attempt to capture the draw - done by DirectDraw() - into a new cache entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. Bool_t IgnoreSizeForOfInterest() const; Return true if size of this shape should be ignored when determining if; the object should be drawn. In this base-class we simply return state of; static flag fgIgnoreSizeForCameraInterest. Several sub-classes override this virtual function. Bool_t GetIgnoreSizeForCameraInterest(); Get state of static fgIgnoreSizeForCameraInterest flag.; When this is true all objects, also very small, will be drawn by GL. void SetIgnoreSizeForCameraInterest(Bool_t isfci); Set state of static fgIgnoreSizeForCameraInterest flag. TGLLogicalShape(const TGLLogicalShape& ). TGLLogicalShape& operator=(const TGLLogicalShape& ). UInt_t Ref() const; Physical shape reference-counting, replica management. { return fRef; }. void StrongRef(Bool_t strong) const; { fRefStro",MatchSource.WIKI,root/html602/TGLLogicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLLogicalShape.html
Availability,avail,available,". TGLManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLManager. class TGLManager: public TNamed. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Bool_tAttachOffScreenDevice(Int_t ctxInd, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCreateGLContext(Int_t winInd); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteGLContext(Int_t ctxInd); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual ",MatchSource.WIKI,root/html602/TGLManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLManager.html
Integrability,interface,interface,". TGLManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLManager. class TGLManager: public TNamed. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Bool_tAttachOffScreenDevice(Int_t ctxInd, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCreateGLContext(Int_t winInd); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteGLContext(Int_t ctxInd); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual ",MatchSource.WIKI,root/html602/TGLManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLManager.html
Availability,avail,available,". TGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLManip. class TGLManip: public TVirtualGLManip. Abstract base class for viewer manipulators, which allow direct in; viewer manipulation of a (TGlPhysicalShape) object - currently; translation, scaling and rotation along/round objects local axes.; See derived classes for these implementations. This class provides binding to the zero or one manipulated physical,; hit testing (selection) for manipulator sub component (widget), and; some common mouse action handling/tracking. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLManip(); voidAttach(TGLPhysicalShape* shape); static TClass*Class(); virtual voidDraw(const TGLCamera& camera) const; Bool_tGetActive() const; TGLPhysicalShape*GetAttached() const; UInt_tGetSelectedWidget() const; virtual Bool_tHandleButton(const Event_t& event, const TGLCamera& camera); virtual Bool_tHandleMotion(const Event_t& event, const TGLCamera& camera); virtual TClass*IsA() const; virtual Bool_tSelect(const TGLCamera&, const TGLRect&, const TGLBoundingBox&); voidSetActive(Bool_t a); voidSetSelectedWidget(UInt_t s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLManip(); TGLManip(TGLPhysicalShape* shape). protected:. voidCalcDrawScale(const TGLBoundingBox& box, const TGLCamera& camera, Double_t& base, TGLVector3[3] axis) const; const UChar_t*ColorFor(UInt_t widget) const; TGLManip&operator=(const TGLManip&); TGLManip(const TGLManip&). Data Members; protected:. Bool_tfActive! manipulator is active?; TPointfFirstMouse! first (start) mouse position (in WINDOW coords); TPointfLas",MatchSource.WIKI,root/html602/TGLManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLManip.html
Testability,test,testing,". TGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLManip. class TGLManip: public TVirtualGLManip. Abstract base class for viewer manipulators, which allow direct in; viewer manipulation of a (TGlPhysicalShape) object - currently; translation, scaling and rotation along/round objects local axes.; See derived classes for these implementations. This class provides binding to the zero or one manipulated physical,; hit testing (selection) for manipulator sub component (widget), and; some common mouse action handling/tracking. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLManip(); voidAttach(TGLPhysicalShape* shape); static TClass*Class(); virtual voidDraw(const TGLCamera& camera) const; Bool_tGetActive() const; TGLPhysicalShape*GetAttached() const; UInt_tGetSelectedWidget() const; virtual Bool_tHandleButton(const Event_t& event, const TGLCamera& camera); virtual Bool_tHandleMotion(const Event_t& event, const TGLCamera& camera); virtual TClass*IsA() const; virtual Bool_tSelect(const TGLCamera&, const TGLRect&, const TGLBoundingBox&); voidSetActive(Bool_t a); voidSetSelectedWidget(UInt_t s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLManip(); TGLManip(TGLPhysicalShape* shape). protected:. voidCalcDrawScale(const TGLBoundingBox& box, const TGLCamera& camera, Double_t& base, TGLVector3[3] axis) const; const UChar_t*ColorFor(UInt_t widget) const; TGLManip&operator=(const TGLManip&); TGLManip(const TGLManip&). Data Members; protected:. Bool_tfActive! manipulator is active?; TPointfFirstMouse! first (start) mouse position (in WINDOW coords); TPointfLas",MatchSource.WIKI,root/html602/TGLManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLManip.html
Availability,avail,available,". TGLManipSet. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLManipSet. class TGLManipSet: public TGLOverlayElement, public TGLPShapeRef. Combine all available manipulators in a collection. At first I wanted to merge them back into TGLManip (to have a; single class) but then it seemed somehow messy.; Maybe next time. Function Members (Methods); public:. virtual~TGLManipSet(); static TClass*Class(); TGLManip*GetCurrentManip() const; Bool_tGetDrawBBox() const; Int_tGetManipType() const; TGLPhysicalShape*TGLPShapeRef::GetPShape() const; TGLOverlayElement::ERoleTGLOverlayElement::GetRole() const; TGLOverlayElement::EStateTGLOverlayElement::GetState() const; virtual Bool_tHandle(TGLRnrCtx& rnrCtx, TGLOvlSelectRecord& selRec, Event_t* event); virtual TClass*IsA() const; virtual Bool_tMouseEnter(TGLOvlSelectRecord& selRec); virtual voidMouseLeave(); virtual Bool_tTGLOverlayElement::MouseStillInside(TGLOvlSelectRecord& selRec); virtual voidTGLPShapeRef::PShapeModified(); virtual voidRender(TGLRnrCtx& rnrCtx); voidTGLOverlayElement::SetBinaryState(Bool_t s); voidSetDrawBBox(Bool_t bb); voidSetManipType(Int_t type); virtual voidSetPShape(TGLPhysicalShape* shape); voidTGLOverlayElement::SetRole(TGLOverlayElement::ERole r); voidTGLOverlayElement::SetState(TGLOverlayElement::EState s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLManipSet(). protected:. voidTGLOverlayElement::ProjectionMatrixPushIdentity(). private:. TGLManipSet&operator=(const TGLManipSet&); TGLManipSet(const TGLManipSet&). Data Members; public:. static TGLOverlayElement::EStateTGLOverlayElement::kActive; static TGLOverlayElement::ERoleTGLOverlayElement::kAll; static TGLOverlayElement::EStateTGLOverlayElement::kAllVisible; st",MatchSource.WIKI,root/html602/TGLManipSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLManipSet.html
Security,access,accessors,". TGLMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLMatrix. class TGLMatrix. TGLMatrix. 16 component (4x4) transform matrix - column MAJOR as per GL.; Provides limited support for adjusting the translation, scale and; rotation components. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. virtual~TGLMatrix(); Double_t*Arr(); const Double_t*CArr() const; static TClass*Class(); voidDump() const; TGLVector3GetBaseVec(Int_t b) const; voidGetBaseVec(Int_t b, TGLVector3& v) const; voidGetBaseVec(Int_t b, Double_t* x) const; TGLVector3GetScale() const; TGLVector3GetTranslation() const; Double_tInvert(); virtual TClass*IsA() const; Bool_tIsScalingForRender() const; voidMove3LF(Double_t x, Double_t y, Double_t z); voidMoveLF(Int_t ai, Double_t amount); TGLVector3Multiply(const TGLVector3& v, Double_t w = 1) const; voidMultiplyIP(TGLVector3& v, Double_t w = 1) const; voidMultLeft(const TGLMatrix& lhs); voidMultRight(const TGLMatrix& rhs); TGLMatrix&operator*=(const TGLMatrix& rhs); TGLMatrix&operator=(const TGLMatrix& rhs); Double_t&operator[](Int_t index); Double_toperator[](Int_t index) const; TGLVector3Rotate(const TGLVector3& v) const; voidRotate(const TGLVertex3& pivot, const TGLVector3& axis, Double_t angle); voidRotateIP(TGLVector3& v) const; voidRotateLF(Int_t i1, Int_t i2, Double_t amount); voidRotatePF(Int_t i1, Int_t i2, Double_t amount); voidScale(const TGLVector3& scale); voidSet(const Double_t[16] vals); voidSet(const TGLVertex3& origin, const TGLVe",MatchSource.WIKI,root/html602/TGLMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLMatrix.html
Usability,simpl,simple,". TGLMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLMatrix. class TGLMatrix. TGLMatrix. 16 component (4x4) transform matrix - column MAJOR as per GL.; Provides limited support for adjusting the translation, scale and; rotation components. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. virtual~TGLMatrix(); Double_t*Arr(); const Double_t*CArr() const; static TClass*Class(); voidDump() const; TGLVector3GetBaseVec(Int_t b) const; voidGetBaseVec(Int_t b, TGLVector3& v) const; voidGetBaseVec(Int_t b, Double_t* x) const; TGLVector3GetScale() const; TGLVector3GetTranslation() const; Double_tInvert(); virtual TClass*IsA() const; Bool_tIsScalingForRender() const; voidMove3LF(Double_t x, Double_t y, Double_t z); voidMoveLF(Int_t ai, Double_t amount); TGLVector3Multiply(const TGLVector3& v, Double_t w = 1) const; voidMultiplyIP(TGLVector3& v, Double_t w = 1) const; voidMultLeft(const TGLMatrix& lhs); voidMultRight(const TGLMatrix& rhs); TGLMatrix&operator*=(const TGLMatrix& rhs); TGLMatrix&operator=(const TGLMatrix& rhs); Double_t&operator[](Int_t index); Double_toperator[](Int_t index) const; TGLVector3Rotate(const TGLVector3& v) const; voidRotate(const TGLVertex3& pivot, const TGLVector3& axis, Double_t angle); voidRotateIP(TGLVector3& v) const; voidRotateLF(Int_t i1, Int_t i2, Double_t amount); voidRotatePF(Int_t i1, Int_t i2, Double_t amount); voidScale(const TGLVector3& scale); voidSet(const Double_t[16] vals); voidSet(const TGLVertex3& origin, const TGLVe",MatchSource.WIKI,root/html602/TGLMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLMatrix.html
Availability,error,error," virtual~TGlobal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*GetAddress() const; virtual Int_tGetArr",MatchSource.WIKI,root/html602/TGlobal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGlobal.html
Modifiability,variab,variables,". TGlobal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TGlobal. class TGlobal: public TDictionary. Global variables class (global variables are obtained from CINT).; This class describes the attributes of a global variable.; The TROOT class contains a list of all currently defined global; variables (accessible via TROOT::GetListOfGlobals()). Function Members (Methods); public:. virtual~TGlobal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*GetAddress() const; virtual Int_tGetArr",MatchSource.WIKI,root/html602/TGlobal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGlobal.html
Performance,load,loaded," TDictionary::ESTLTypeTDictionary::kSet; static TObject::(anonymous)TObject::kSingleKey; static TDictionary::ESTLTypeTDictionary::kVector; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. DataMemberInfo_t*fInfo!pointer to CINT data member info. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGlobal(DataMemberInfo_t* info = 0); Default TGlobal ctor. TGlobal(const TGlobal& ); Copy constructor. TGlobal & operator=(const TGlobal& ); Assignment operator. ~TGlobal(); TGlobal dtor deletes adopted CINT DataMemberInfo object. void * GetAddress() const; Return address of global. Int_t GetArrayDim() const; Return number of array dimensions. TDictionary::DeclId_t GetDeclId() const. Int_t GetMaxIndex(Int_t dim) const; Return maximum index for array dimension ""dim"". const char * GetTypeName() const; Get type of global variable, e,g.: ""class TDirectory*"" -> ""TDirectory"".; Result needs to be used or copied immediately. const char * GetFullTypeName() const; Get full type description of global variable, e,g.: ""class TDirectory*"". Bool_t IsValid(); Return true if this global object is pointing to a currently; loaded global. If a global is unloaded after the TGlobal; is created, the TGlobal will be set to be invalid. Long_t Property() const; Get property description word. For meaning of bits see EProperty. Bool_t Update(DataMemberInfo_t* info); Update the TFunction to reflect the new info. This can be used to implement unloading (info == 0) and then reloading; (info being the 'new' decl address). » Author: Rene Brun 13/11/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-30 15:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGlobal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGlobal.html
Security,access,accessible,". TGlobal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TGlobal. class TGlobal: public TDictionary. Global variables class (global variables are obtained from CINT).; This class describes the attributes of a global variable.; The TROOT class contains a list of all currently defined global; variables (accessible via TROOT::GetListOfGlobals()). Function Members (Methods); public:. virtual~TGlobal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*GetAddress() const; virtual Int_tGetArr",MatchSource.WIKI,root/html602/TGlobal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGlobal.html
Availability,avail,available,". TGLObject. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLObject. class TGLObject: public TGLLogicalShape. Base-class for direct OpenGL renderers.; This allows classes to circumvent passing of TBuffer3D and; use user-provided OpenGL code.; By convention, if you want class TFoo : public TObject to have direct rendering; you should also provide TFooGL : public TGLObject and implement; abstract functions SetModel() and SetBBox().; TAttBBox can be used to facilitate calculation of bounding-boxes.; See TPointSet3D and TPointSet3DGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLObject(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu",MatchSource.WIKI,root/html602/TGLObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLObject.html
Performance,cache,cached,"rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; TGLObject&operator=(const TGLObject&); virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, const Option_t* opt = 0); virtual Bool_tShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TGLObject(); TGLObject(const TGLObject&); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidUpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html602/TGLObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLObject.html
Availability,down,down,". TGLOrthoCamera. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLOrthoCamera. class TGLOrthoCamera: public TGLCamera. TGLOrthoCamera. Orthographic projection camera. Currently limited to three types; defined at construction time - kXOY, kXOZ, kZOY - where this refers; to the viewport plane axis - e.g. kXOY has X axis horizontal, Y; vertical - i.e. looking down Z axis with Y vertical. The plane types restriction could easily be removed to supported; arbitary ortho projections along any axis/orientation with free; rotations about them. Function Members (Methods); public:. virtual~TGLOrthoCamera(); voidTObject::AbstractMethod(const char* method) const; Bool_tTGLCamera::AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Double_tTGLCamera::AdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidConfigure(Double_t zoom, Double_t dolly, Double_t[3] center, Double_t hRotate, Double_t vRotate); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tDolly(Int_t delta, Bool_t mod1, Bool_t mod2); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option",MatchSource.WIKI,root/html602/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLOrthoCamera.html
Deployability,update,updates,"ens 'focal length'. Returns kTRUE is redraw required (camera change), kFALSE otherwise. void SetZoomMin(Double_t z); Set minimum zoom factor. If current zoom is less than z it is; set to z. void SetZoomMax(Double_t z); Set maximum zoom factor. If current zoom is greater than z it; is set to z. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Rotate the camera - 'swivel round the view volume center'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - ignored for ortho camera. Assumed to be same; as one passed to Setup().; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t zoom, Double_t dolly, Double_t[3] center, Double_t hRotate, Double_t vRotate); Configure the camera state.; zoom - set directly (default = 0.78);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. TGLOrthoCamera(). Bool_t IsOrthographic() const; { return kTRUE; }. void SetEnableRotate(Bool_t x); { fEnableRotate = x; }. Bool_t GetEnableRotate() const; { return fEnableRotate; }. Double_t GetZoomMin() const; { return fZoomMin; }. Double_t GetZoomMax() const; { return fZoomMax; }. void SetZoomMinMax(Double_t min, Double_t max); { Se",MatchSource.WIKI,root/html602/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLOrthoCamera.html
Performance,cache,cached,"tic TGLOrthoCamera::ETypekXnOY; static TGLOrthoCamera::ETypekXnOZ; static TGLOrthoCamera::ETypekZOY; static TGLOrthoCamera::ETypekZnOY; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBasetranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTranstransformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenterdefault camera center; Double_tTGLCamera::fDollyDefaultdefault distnce from viewing centre; Double_tTGLCamera::fDollyDistanceunit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenterexternal camera center; Bool_tTGLCamera::fExternalCenteruse external center insead of scene center; TGLVector3TGLCamera::fFDCenterfixed default camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenteruse fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngleminimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); Bool_tTGLCamera::fWasArcBalledset when arc-ball rotation is used; static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfDefXSize! x, y size of scene from camera view; Double_tfDefYSize! x, y size of scene from camera view; Bool_tfDollyToZoomzoom when dolly is requested; Bool_tfEnableRotateen",MatchSource.WIKI,root/html602/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLOrthoCamera.html
Testability,log,logically,"hAxis, const TGLVector3& vAxis); Construct orthographic camera. ~TGLOrthoCamera(); Destroy orthographic camera. void Setup(const TGLBoundingBox& box, Bool_t reset = kTRUE); Setup camera limits suitible to view the world volume defined by 'box'; and call Reset() to initialise camera. void Reset(); Reset the camera to defaults - trucking, zooming to reframe the world volume; established in Setup(). Note: limits defined in Setup() are not adjusted. Bool_t Dolly(Int_t delta, Bool_t mod1, Bool_t mod2); Dolly the camera.; By default the dolly is reinterpreted to zoom, but it can be; changed by modifying the fDollyToZoom data-member. Bool_t Zoom(Int_t delta, Bool_t mod1, Bool_t mod2); Zoom the camera - 'adjust lens focal length, retaining camera position'.; Arguments are:. 'delta' - mouse viewport delta (pixels) - +ive zoom in, -ive zoom out; 'mod1' / 'mod2' - sensitivity modifiers - see TGLCamera::AdjustAndClampVal(). For an orthographic camera dollying and zooming are identical and both equate; logically to a rescaling of the viewport limits - without center shift.; There is no perspective foreshortening or lens 'focal length'. Returns kTRUE is redraw required (camera change), kFALSE otherwise. void SetZoomMin(Double_t z); Set minimum zoom factor. If current zoom is less than z it is; set to z. void SetZoomMax(Double_t z); Set maximum zoom factor. If current zoom is greater than z it; is set to z. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Rotate the camera - 'swivel round the view volume center'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this v",MatchSource.WIKI,root/html602/TGLOrthoCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLOrthoCamera.html
Integrability,rout,routines,". TGLOutput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLOutput. class TGLOutput. TGLOutput. Wrapper class for GL capture & output routines. Function Members (Methods); public:. virtual~TGLOutput(); static voidCapture(TGLViewer& viewer); static Bool_tCapture(TGLViewer& viewer, TGLOutput::EFormat format, const char* filePath = 0); static TClass*Class(); static voidCloseEmbeddedPS(); virtual TClass*IsA() const; TGLOutput&operator=(const TGLOutput&); virtual voidShowMembers(TMemberInspector& insp) const; static voidStartEmbeddedPS(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLOutput(); TGLOutput(const TGLOutput&). private:. static Bool_tCapturePostscript(TGLViewer& viewer, TGLOutput::EFormat format, const char* filePath). Data Members; public:. static TGLOutput::EFormatkEPS_BSP; static TGLOutput::EFormatkEPS_SIMPLE; static TGLOutput::EFormatkPDF_BSP; static TGLOutput::EFormatkPDF_SIMPLE. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t Capture(TGLViewer& viewer, TGLOutput::EFormat format, const char* filePath = 0); Capture viewer to file. Arguments are:; 'viewer' - viewer object to capture from; 'format' - output format - only postscript types presently.; One of kEPS_SIMPLE, kEPS_BSP, kPDF_SIMPLE or kPDF_BSP; See TGLOutput::CapturePostscript() for meanings; 'filePath' - file output name. If null defaults to './viewer.eps' or './viewer.pdf'; depending on format requested. Note : Output files can be large and take considerable time (up to mins); to generate. Bool_t CapturePostscript(TGLViewer& viewer, TGLOutput::EFormat format, const char* filePath); Capture viewer to postscript file. Arguments are:; 'viewer' - viewer object to capture from; 'format' - output format; kEPS_SIMPLE - lower",MatchSource.WIKI,root/html602/TGLOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLOutput.html
Availability,avail,available,". TGLOverlayElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLOverlayElement. class TGLOverlayElement. An overlay element. Supports drawing (Render) and event-handling. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLOverlayElement(); static TClass*Class(); TGLOverlayElement::ERoleGetRole() const; TGLOverlayElement::EStateGetState() const; virtual Bool_tHandle(TGLRnrCtx& rnrCtx, TGLOvlSelectRecord& selRec, Event_t* event); virtual TClass*IsA() const; virtual Bool_tMouseEnter(TGLOvlSelectRecord& selRec); virtual voidMouseLeave(); virtual Bool_tMouseStillInside(TGLOvlSelectRecord& selRec); virtual voidRender(TGLRnrCtx& rnrCtx); voidSetBinaryState(Bool_t s); voidSetRole(TGLOverlayElement::ERole r); voidSetState(TGLOverlayElement::EState s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLOverlayElement(TGLOverlayElement::ERole r = kUser, TGLOverlayElement::EState s = kActive). protected:. voidProjectionMatrixPushIdentity(). private:. TGLOverlayElement&operator=(const TGLOverlayElement&); TGLOverlayElement(const TGLOverlayElement&). Data Members; public:. static TGLOverlayElement::EStatekActive; static TGLOverlayElement::ERolekAll; static TGLOverlayElement::EStatekAllVisible; static TGLOverlayElement::ERolekAnnotation; static TGLOverlayElement::EStatekDisabled; static TGLOverlayElement::EStatekInvisible; static TGLOverlayElement::ERolekUser; static TGLOverlayElement::ERolekViewer. protected:. TGLOverlayElement::ERolefRole; TGLOverlayElement::EStatefState. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t M",MatchSource.WIKI,root/html602/TGLOverlayElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLOverlayElement.html
Modifiability,inherit,inherit,". TGLPadPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPadPainter. class TGLPadPainter: public TVirtualPadPainter. ""Delegating"" part of TGLPadPainter. Line/fill/etc. attributes can be; set inside TPad, but not only there:; many of them are set by base sub-objects of 2d primitives; (2d primitives usually inherit TAttLine or TAttFill etc.). And these sub-objects; call gVirtualX->SetLineWidth ... etc. So, if I save some attributes in my painter,; it will be mess - at any moment I do not know, where to take line attribute - from; gVirtualX or from my own member. So! All attributed, _ALL_ go to/from gVirtualX. Function Members (Methods); public:. virtual~TGLPadPainter(); static TClass*Class(); virtual voidClearDrawable(); virtual voidCopyDrawable(Int_t id, Int_t px, Int_t py); virtual Int_tCreateDrawable(UInt_t w, UInt_t h); virtual voidDestroyDrawable(); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); virtual voidDrawFillArea(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawFillArea(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidDrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); virtual voidDrawPixels(const unsigned char* pixelData, UInt_t width, UInt_t height, Int_t dstX, Int_t dstY, Bool_t enableBlending); virtual voidDrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); virtual voidDrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawText(Double_t x, Double",MatchSource.WIKI,root/html602/TGLPadPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPadPainter.html
Testability,test,test,"tTextSize() const; Delegate to gVirtualX. Float_t GetTextMagnitude() const; Delegate to gVirtualX. void SetTextAlign(Short_t align); Delegate to gVirtualX. void SetTextAngle(Float_t tangle); Delegate to gVirtualX. void SetTextColor(Color_t tcolor); Delegate to gVirtualX. void SetTextFont(Font_t tfont); Delegate to gVirtualX. void SetTextSize(Float_t tsize); Delegate to gVirtualX. void SetTextSizePixels(Int_t npixels); Delegate to gVirtualX. Int_t CreateDrawable(UInt_t w, UInt_t h); Not required at the moment. void ClearDrawable(); Not required at the moment. void CopyDrawable(Int_t id, Int_t px, Int_t py); Not required at the moment. void DestroyDrawable(); Not required at the moment. void SelectDrawable(Int_t device); For gVirtualX this means select pixmap (or window); and all subsequent drawings will go into; this pixmap. For OpenGL this means the change of; coordinate system and viewport. void InitPainter(); Init gl-pad painter:; 1. 2D painter does not use depth test, should not modify; depth-buffer content (except initial cleanup).; 2. Disable cull face.; 3. Disable lighting.; 4. Set viewport (to the whole canvas area).; 5. Set camera.; 6. Unlock painter. void InvalidateCS(); When TPad::Range for gPad is called, projection; must be changed in OpenGL. void LockPainter(); Locked state of painter means, that; GL context can be invalid, so no GL calls; can be executed. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw line segment. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Draw line segment in NDC coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Draw filled or hollow box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Draw tesselated polygon (probably, outline only). void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Draw tesselated polygon (never called, probably, since TPad::PaintFillArea for floats; is deprecated). voi",MatchSource.WIKI,root/html602/TGLPadPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPadPainter.html
Availability,avail,available,". TGLPaintDevice. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLPaintDevice. class TGLPaintDevice. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLPaintDevice(); static TClass*Class(); virtual voidExtractViewport(Int_t* vp) const; virtual const TGLContext*GetContext() const; virtual const TGLFormat*GetPixelFormat() const; virtual TClass*IsA() const; virtual Bool_tMakeCurrent(); TGLPaintDevice&operator=(const TGLPaintDevice&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidSwapBuffers(); TGLPaintDevice(); TGLPaintDevice(const TGLPaintDevice&). private:. virtual voidAddContext(TGLContext* ctx); virtual voidRemoveContext(TGLContext* ctx). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ExtractViewport(Int_t ctxInd, Int_t *vp); Off-screen device holds sizes for glViewport. Bool_t MakeCurrent(Int_t ctxInd); ]; Make the gl context current. virtual ~TGLPaintDevice(); {}. void SwapBuffers(). const TGLFormat * GetPixelFormat() const. const TGLContext * GetContext() const. void AddContext(TGLContext* ctx). void Remove",MatchSource.WIKI,root/html602/TGLPaintDevice.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPaintDevice.html
Integrability,interface,interface,". TGLPaintDevice. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLPaintDevice. class TGLPaintDevice. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLPaintDevice(); static TClass*Class(); virtual voidExtractViewport(Int_t* vp) const; virtual const TGLContext*GetContext() const; virtual const TGLFormat*GetPixelFormat() const; virtual TClass*IsA() const; virtual Bool_tMakeCurrent(); TGLPaintDevice&operator=(const TGLPaintDevice&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidSwapBuffers(); TGLPaintDevice(); TGLPaintDevice(const TGLPaintDevice&). private:. virtual voidAddContext(TGLContext* ctx); virtual voidRemoveContext(TGLContext* ctx). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ExtractViewport(Int_t ctxInd, Int_t *vp); Off-screen device holds sizes for glViewport. Bool_t MakeCurrent(Int_t ctxInd); ]; Make the gl context current. virtual ~TGLPaintDevice(); {}. void SwapBuffers(). const TGLFormat * GetPixelFormat() const. const TGLContext * GetContext() const. void AddContext(TGLContext* ctx). void Remove",MatchSource.WIKI,root/html602/TGLPaintDevice.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPaintDevice.html
Availability,error,error,"LParametricEquation(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidEvalVertex(TGLVertex3& newVertex, Double_t u, Double_t v) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Rgl::Range_tGetURange() const; Rgl::Range_tGetVRange() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, c",MatchSource.WIKI,root/html602/TGLParametricEquation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLParametricEquation.html
Integrability,wrap,wrapper,". TGLParametricEquationGL. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLParametricEquationGL. class TGLParametricEquationGL: public TGLPlot3D. GL-renderer wrapper for TGLParametricEquation.; This allows rendering of parametric-equations in standard GL viewer. Function Members (Methods); public:. virtual~TGLParametricEquationGL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, const Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, const Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTG",MatchSource.WIKI,root/html602/TGLParametricEquationGL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLParametricEquationGL.html
Performance,cache,cached,"irectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, const Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TGLParametricEquationGL(); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html602/TGLParametricEquationGL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLParametricEquationGL.html
Testability,log,logx," virtual~TGLParametricEquationGL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, const Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, const Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTG",MatchSource.WIKI,root/html602/TGLParametricEquationGL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLParametricEquationGL.html
Usability,simpl,simple,"xis; TAxisfCartesianYAxis; TAxisfCartesianZAxis; Int_tfColorScheme; TGLParametricEquation*fEquation; TGL2DArray<TGLParametricPlot::Vertex_t>fMesh; Int_tfMeshSize; Bool_tfShowMesh; static TGLParametricPlot::EMeshSizekHigh; static TGLParametricPlot::EMeshSizekLow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLParametricPlot(TGLParametricEquation* equation, TGLPlotCamera* camera); Constructor. Bool_t InitGeometry(); Build mesh. The surface is 'immutable':; the only reason to rebuild it - the change in size or; if one of equations contain reference to TF2 function, whose; parameters were changed. void StartPan(Int_t px, Int_t py); User clicks right mouse button (in a pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. char * GetPlotInfo(Int_t px, Int_t py); No object info yet. void AddOption(const TString& option); No additional options for parametric surfaces. void ProcessEvent(Int_t event, Int_t px, Int_t py); Change color/mesh size or switch on/off mesh/box cut.; Left double click - remove box cut. void InitGL() const; Initialize gl state. void DeInitGL() const; Initialize gl state. void DrawPlot() const; Draw parametric surface. void InitColors(); Calculate colors for vertices,; using one of 20 color themes.; -1 simple 'metal' surface. void DrawSectionXOZ() const; No such sections. void DrawSectionYOZ() const; No such sections. void DrawSectionXOY() const; No such sections. void SetSurfaceColor() const; Set material properties. TGLParametricPlot(TGLParametricEquation* equation, TGLPlotCamera* camera). » Author: Timur Pocheptsov 26/01/2007 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLParametricPlot.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLParametricPlot.html
Availability,error,error,"owse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidConfigure(Double_t fov, Double_t dolly, Double_t[3] center, Double_t hRotate, Double_t vRotate); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTGLCamera::Dolly(Int_t delta, Bool_t mod1, Bool_t mod2); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidTGLCamera::DrawDebugAids() const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); TGLVector3TGLCamera::EyeDirection() const; TGLVertex3TGLCamera::EyePoint() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGLVertex3TGLCamera::FrustumCenter() const; Rgl::EOverlapTGLCamera::FrustumOverlap(const TGLBoundingBox& box) const; const TGLPlane&TGLCamera::FrustumPlane(TGLCamera::EFrustumPlane plane) const; const TGLMatrix&TGLCamera::GetCamBase() const; const TGLMatrix&TGLCamera::GetCamTrans() const; Double_t*TGLCamera::GetCenterVec(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tTGLCamera::GetExternalCenter(); Double_tTGLCamera::GetFarClip() const; Double_t*TGLCamera::GetFixDefCenterVec(); Double_tGetFOV() const; virt",MatchSource.WIKI,root/html602/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPerspectiveCamera.html
Deployability,update,updates,"camera to defaults - reframe the world volume established in Setup(); in default state. Note: limits defined in Setup() are not adjusted. Bool_t Zoom(Int_t delta, Bool_t mod1, Bool_t mod2); Zoom the camera - 'adjust lens focal length, retaining camera position'.; Arguments are:. 'delta' - mouse viewport delta (pixels) - +ive zoom in, -ive zoom out; 'mod1' / 'mod2' - sensitivity modifiers - see TGLCamera::AdjustAndClampVal(). Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& box, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - used to adjust near/far clipping; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t fov, Double_t dolly, Double_t[3] center, Double_t hRotate, Double_t vRotate); Configure the camera state.; fov - set directly field-of-view in degrees (default = 30);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. TGLPerspectiveCamera(). Bool_t IsPerspective() const; { return kTRUE; }. Double_t GetFOV() const; { return fFOV; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:53; This page has been automatically generated. For comments or suggestions rega",MatchSource.WIKI,root/html602/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPerspectiveCamera.html
Performance,cache,cached,ject::(anonymous)TObject::kSingleKey; static TGLCamera::EFrustumPlaneTGLCamera::kTop; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTGLCamera::fCacheDirty! cached items dirty?; TGLMatrixTGLCamera::fCamBasetranformation to center and rotation from up to x vector; TGLMatrixTGLCamera::fCamTranstransformation relative to fCamTrans; TGLVector3*TGLCamera::fCenter! current camera center; TGLMatrixTGLCamera::fClipM! object space clip matrix (cached); TGLVector3TGLCamera::fDefCenterdefault camera center; Double_tTGLCamera::fDollyDefaultdefault distnce from viewing centre; Double_tTGLCamera::fDollyDistanceunit distance for camera movement in fwd/bck direction; TGLVector3TGLCamera::fExtCenterexternal camera center; Bool_tTGLCamera::fExternalCenteruse external center insead of scene center; TGLVector3TGLCamera::fFDCenterfixed default camera center; Double_tTGLCamera::fFarClip! last applied far-clip; Bool_tTGLCamera::fFixDefCenteruse fixed default center; TGLPlaneTGLCamera::fFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxTGLCamera::fInterestBox! the interest box - created in UpdateInterest(); Double_tTGLCamera::fLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixTGLCamera::fLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixTGLCamera::fModVM! modelView matrix (cached); Double_tTGLCamera::fNearClip! last applied near-clip; TGLMatrixTGLCamera::fProjM! projection matrix (cached); UInt_tTGLCamera::fTimeStamp! timestamp; Float_tTGLCamera::fVAxisMinAngleminimal allowed angle between up and fCamTrans Z vector; TGLRectTGLCamera::fViewport! viewport (GL coords - origin bottom left); Bool_tTGLCamera::fWasArcBalledset when arc-ball rotation is used; static UInt_tTGLCamera::fgDollyDeltaSens. private:. Double_tfFOV; static Double_tfgFOVDefault; static UInt_tfgFOVDeltaSens; static Double_tfgFOVMax; static Double_tfgFOVMin. Class Charts. Inheritance; Inherited Members; Includes; Lib,MatchSource.WIKI,root/html602/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPerspectiveCamera.html
Testability,test,tests,"camera to defaults - reframe the world volume established in Setup(); in default state. Note: limits defined in Setup() are not adjusted. Bool_t Zoom(Int_t delta, Bool_t mod1, Bool_t mod2); Zoom the camera - 'adjust lens focal length, retaining camera position'.; Arguments are:. 'delta' - mouse viewport delta (pixels) - +ive zoom in, -ive zoom out; 'mod1' / 'mod2' - sensitivity modifiers - see TGLCamera::AdjustAndClampVal(). Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& box, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - used to adjust near/far clipping; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t fov, Double_t dolly, Double_t[3] center, Double_t hRotate, Double_t vRotate); Configure the camera state.; fov - set directly field-of-view in degrees (default = 30);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. TGLPerspectiveCamera(). Bool_t IsPerspective() const; { return kTRUE; }. Double_t GetFOV() const; { return fFOV; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:53; This page has been automatically generated. For comments or suggestions rega",MatchSource.WIKI,root/html602/TGLPerspectiveCamera.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPerspectiveCamera.html
Performance,perform,perform,". TGLPhysicalShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPhysicalShape. class TGLPhysicalShape. Concrete physical shape - a GL drawable. Physical shapes are the; objects the user can actually see, select, move in the viewer. It is; a placement of the associated local frame TGLLogicaShape into the; world frame. The draw process is:. Load attributes - material colors etc; Load translation matrix - placement; Load gl name (for selection); Call our associated logical shape Draw() to draw placed shape. The physical shape supports translation, scaling and rotation,; selection, color changes, and permitted modification flags etc.; A physical shape cannot modify or be bound to another (or no); logical shape - hence const & handle. It can perform mutable; reference counting on the logical to enable purging. Physical shape also maintains a list of references to it and; provides notifications of change and destruction.; See class TGLPShapeRef which needs to be sub-classes for real use. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how external viewer clients use it. Function Members (Methods); public:. virtual~TGLPhysicalShape(); voidAddReference(TGLPShapeRef* ref); const TGLBoundingBox&BoundingBox() const; virtual voidCalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*GetLogical() const; TGLPhysicalShape::EManipGetManip() const; const TGLPhysicalShape*GetNextPhysical() const; TGLVector3GetScale() const; UChar_tGetSelected() const; TGLVertex3GetTranslation() const; UInt_tID() const; voidInvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; Bool_tIsInvisibl",MatchSource.WIKI,root/html602/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPhysicalShape.html
Safety,avoid,avoid,"hat the information; can be propagated to the object referencing it. void UpdateBoundingBox(); Update our internal bounding box (in global frame). void InitColor(const Float_t[4] rgba); Initialise the colors, using basic RGBA diffuse material color supplied. void SetColor(const Float_t[17] rgba); Set full color attributes - see OpenGL material documentation; for full description.; 0->3 diffuse, 4->7 ambient, 8->11 specular, 12->15 emission, 16 shininess. void SetColorOnFamily(const Float_t[17] rgba); Set full color attributes to all physicals sharing the same; logical with this object. void SetDiffuseColor(const Float_t rgba[4]); Set color from ROOT color index and transparency [0,100]. void SetDiffuseColor(const UChar_t rgba[4]); Set color from RGBA quadruplet. void SetDiffuseColor(Color_t ci, UChar_t transparency); Set color from standard ROOT representation, that is color index; + transparency in range [0, 100]. void SetupGLColors(TGLRnrCtx& rnrCtx, const Float_t* color = 0) const; Setup colors - avoid setting things not required; for current draw flags. void Draw(TGLRnrCtx& rnrCtx) const; Draw physical shape, using LOD flags, potential from display list cache. void CalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; Calculate shape-lod, suitible for use under; projection defined by 'rnrCtx', taking account of which local; axes of the shape support LOD adjustment, and the global; 'sceneFlags' passed. Returned shapeLOD component is from 0 (kLODPixel - lowest; quality) to 100 (kLODHigh - highest quality). Scene flags are not used. LOD quantization is not done. RnrCtx; is not modified as this is called via lodification stage of; rendering. void QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD, Short_t& quantLOD) const; Factor in scene/vierer LOD and Quantize ... forward to; logical shape. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Request creation of context menu on shape, attached to 'menu' at screen positio",MatchSource.WIKI,root/html602/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPhysicalShape.html
Testability,log,logical,". TGLPhysicalShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPhysicalShape. class TGLPhysicalShape. Concrete physical shape - a GL drawable. Physical shapes are the; objects the user can actually see, select, move in the viewer. It is; a placement of the associated local frame TGLLogicaShape into the; world frame. The draw process is:. Load attributes - material colors etc; Load translation matrix - placement; Load gl name (for selection); Call our associated logical shape Draw() to draw placed shape. The physical shape supports translation, scaling and rotation,; selection, color changes, and permitted modification flags etc.; A physical shape cannot modify or be bound to another (or no); logical shape - hence const & handle. It can perform mutable; reference counting on the logical to enable purging. Physical shape also maintains a list of references to it and; provides notifications of change and destruction.; See class TGLPShapeRef which needs to be sub-classes for real use. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how external viewer clients use it. Function Members (Methods); public:. virtual~TGLPhysicalShape(); voidAddReference(TGLPShapeRef* ref); const TGLBoundingBox&BoundingBox() const; virtual voidCalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*GetLogical() const; TGLPhysicalShape::EManipGetManip() const; const TGLPhysicalShape*GetNextPhysical() const; TGLVector3GetScale() const; UChar_tGetSelected() const; TGLVertex3GetTranslation() const; UInt_tID() const; voidInvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; Bool_tIsInvisibl",MatchSource.WIKI,root/html602/TGLPhysicalShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPhysicalShape.html
Security,access,accessors,". TGLPlane. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlane. class TGLPlane. TGLPlane. 3D plane class - of format Ax + By + Cz + D = 0. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. virtual~TGLPlane(); Double_tA() const; Double_t*Arr(); Double_tB() const; Double_tC() const; const Double_t*CArr() const; static TClass*Class(); Double_tD() const; Double_tDistanceTo(const TGLVertex3& vertex) const; voidDump() const; virtual TClass*IsA() const; TGLVertex3NearestOn(const TGLVertex3& point) const; voidNegate(); TGLVector3Norm() const; TGLPlane&operator=(const TGLPlane&); voidSet(const TGLPlane& other); voidSet(Double_t[4] eq); voidSet(const TGLVector3& norm, const TGLVertex3& point); voidSet(const TGLVertex3& p1, const TGLVertex3& p2, const TGLVertex3& p3); voidSet(Double_t a, Double_t b, Double_t c, Double_t d); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLPlane(); TGLPlane(const TGLPlane& other); TGLPlane(Double_t[4] eq); TGLPlane(const TGLVector3& norm, const TGLVertex3& point); TGLPlane(const TGLVertex3& p1, const TGLVertex3& p2, const TGLVertex3& p3); TGLPlane(Double_t a, Double_t b, Double_t c, Double_t d). private:. voidNormalise(). Data Members; private:. Double_tfVals[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlane(); Construct a default plane of x + y + z = 0. TGLPlane(const TGLPlane& other",MatchSource.WIKI,root/html602/TGLPlane.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPlane.html
Usability,simpl,simple,". TGLPlane. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlane. class TGLPlane. TGLPlane. 3D plane class - of format Ax + By + Cz + D = 0. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. virtual~TGLPlane(); Double_tA() const; Double_t*Arr(); Double_tB() const; Double_tC() const; const Double_t*CArr() const; static TClass*Class(); Double_tD() const; Double_tDistanceTo(const TGLVertex3& vertex) const; voidDump() const; virtual TClass*IsA() const; TGLVertex3NearestOn(const TGLVertex3& point) const; voidNegate(); TGLVector3Norm() const; TGLPlane&operator=(const TGLPlane&); voidSet(const TGLPlane& other); voidSet(Double_t[4] eq); voidSet(const TGLVector3& norm, const TGLVertex3& point); voidSet(const TGLVertex3& p1, const TGLVertex3& p2, const TGLVertex3& p3); voidSet(Double_t a, Double_t b, Double_t c, Double_t d); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLPlane(); TGLPlane(const TGLPlane& other); TGLPlane(Double_t[4] eq); TGLPlane(const TGLVector3& norm, const TGLVertex3& point); TGLPlane(const TGLVertex3& p1, const TGLVertex3& p2, const TGLVertex3& p3); TGLPlane(Double_t a, Double_t b, Double_t c, Double_t d). private:. voidNormalise(). Data Members; private:. Double_tfVals[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlane(); Construct a default plane of x + y + z = 0. TGLPlane(const TGLPlane& other",MatchSource.WIKI,root/html602/TGLPlane.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPlane.html
Availability,avail,available,". TGLPlot3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlot3D. class TGLPlot3D: public TGLObject. Description of TGLPlot3D. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLPlot3D(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*CreatePlot(TObject* obj, const Option_t* opt, TVirtualPad* pad); static TGLPlot3D*CreatePlot(TObject* obj, const Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(",MatchSource.WIKI,root/html602/TGLPlot3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPlot3D.html
Performance,cache,cached,"w(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidTGLObject::SetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tTGLObject::SetModel(TObject* obj, const Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TGLPlot3D(); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html602/TGLPlot3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPlot3D.html
Testability,log,logx," virtual~TGLPlot3D(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*CreatePlot(TObject* obj, const Option_t* opt, TVirtualPad* pad); static TGLPlot3D*CreatePlot(TObject* obj, const Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(",MatchSource.WIKI,root/html602/TGLPlot3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPlot3D.html
Availability,error,errors,"ers; class charts. ROOT; » GRAF3D; » GL; » TGLPlotCoordinates. class TGLPlotCoordinates. Helper class for plot-painters holding information about axis; ranges, numbers of bins and flags if certain axis is logartihmic. Function Members (Methods); public:. virtual~TGLPlotCoordinates(); static TClass*Class(); EGLCoordTypeGetCoordType() const; Double_tGetFactor() const; Int_tGetFirstXBin() const; Int_tGetFirstYBin() const; Int_tGetFirstZBin() const; Int_tGetLastXBin() const; Int_tGetLastYBin() const; Int_tGetLastZBin() const; Int_tGetNXBins() const; Int_tGetNYBins() const; Int_tGetNZBins() const; const Rgl::BinRange_t&GetXBins() const; Double_tGetXLength() const; Bool_tGetXLog() const; const Rgl::Range_t&GetXRange() const; const Rgl::Range_t&GetXRangeScaled() const; Double_tGetXScale() const; const Rgl::BinRange_t&GetYBins() const; Double_tGetYLength() const; Bool_tGetYLog() const; const Rgl::Range_t&GetYRange() const; const Rgl::Range_t&GetYRangeScaled() const; Double_tGetYScale() const; const Rgl::BinRange_t&GetZBins() const; Double_tGetZLength() const; Bool_tGetZLog() const; const Rgl::Range_t&GetZRange() const; const Rgl::Range_t&GetZRangeScaled() const; Double_tGetZScale() const; virtual TClass*IsA() const; Bool_tModified() const; voidResetModified(); voidSetCoordType(EGLCoordType type); Bool_tSetRanges(TH2Poly* hist); Bool_tSetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Bool_tSetRanges(const TAxis* xAxis, const TAxis* yAxis, const TAxis* zAxis); voidSetXLog(Bool_t xLog); voidSetYLog(Bool_t yLog); voidSetZLog(Bool_t zLog); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLPlotCoordinates(). private:. TGLPlotCoordinates&operator=(const TGLPlotCoordinates&); Bool_tSetRangesCartesian(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Bool_tSetRangesCylindrical(const TH1* hist); Bool_tSetRangesPolar(const TH1* hist); Bool_tSetRan",MatchSource.WIKI,root/html602/TGLPlotCoordinates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPlotCoordinates.html
Testability,log,logartihmic,". TGLPlotCoordinates. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlotCoordinates. class TGLPlotCoordinates. Helper class for plot-painters holding information about axis; ranges, numbers of bins and flags if certain axis is logartihmic. Function Members (Methods); public:. virtual~TGLPlotCoordinates(); static TClass*Class(); EGLCoordTypeGetCoordType() const; Double_tGetFactor() const; Int_tGetFirstXBin() const; Int_tGetFirstYBin() const; Int_tGetFirstZBin() const; Int_tGetLastXBin() const; Int_tGetLastYBin() const; Int_tGetLastZBin() const; Int_tGetNXBins() const; Int_tGetNYBins() const; Int_tGetNZBins() const; const Rgl::BinRange_t&GetXBins() const; Double_tGetXLength() const; Bool_tGetXLog() const; const Rgl::Range_t&GetXRange() const; const Rgl::Range_t&GetXRangeScaled() const; Double_tGetXScale() const; const Rgl::BinRange_t&GetYBins() const; Double_tGetYLength() const; Bool_tGetYLog() const; const Rgl::Range_t&GetYRange() const; const Rgl::Range_t&GetYRangeScaled() const; Double_tGetYScale() const; const Rgl::BinRange_t&GetZBins() const; Double_tGetZLength() const; Bool_tGetZLog() const; const Rgl::Range_t&GetZRange() const; const Rgl::Range_t&GetZRangeScaled() const; Double_tGetZScale() const; virtual TClass*IsA() const; Bool_tModified() const; voidResetModified(); voidSetCoordType(EGLCoordType type); Bool_tSetRanges(TH2Poly* hist); Bool_tSetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Bool_tSetRanges(const TAxis* xAxis, const TAxis* yAxis, const TAxis* zAxis); voidSetXLog(Bool_t xLog); voidSetYLog(Bool_t yLog); voidSetZLog(Bool_t zLog); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLPlotCoordinates(). private:. TGLPlotCoordinates&operator=(const",MatchSource.WIKI,root/html602/TGLPlotCoordinates.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPlotCoordinates.html
Availability,avail,available,". TGLPlotPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlotPainter. class TGLPlotPainter: public TVirtualGLPainter. Base class for plot-painters that provide GL rendering of various; 2D and 3D histograms, functions and parametric surfaces. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLPlotPainter(); virtual voidAddOption(const TString& stringOption); static TClass*Class(); Bool_tCutAxisSelected() const; virtual voidDeInitGL() const; virtual voidDrawPlot() const; Bool_tGetDrawAxes(); virtual char*TVirtualGLPainter::GetPlotInfo(Int_t px, Int_t py); virtual Bool_tInitGeometry(); virtual voidInitGL() const; voidInvalidateSelection(); virtual TClass*IsA() const; TGLPlotPainter&operator=(const TGLPlotPainter&); TGLPlotPainter&operator=(TGLPlotPainter&&); virtual voidPaint(); virtual voidTVirtualGLPainter::Pan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&RefBackBox() const; voidSetDrawAxes(Bool_t s); voidSetDrawBackBox(Bool_t b); voidSetDrawFrontBox(Bool_t b); virtual voidSetFrameColor(const TColor* frameColor); voidSetPadColor(const TColor* color); voidSetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLPlotPainter(TGLPlotCamera* camera); TGLPlotPainter(const TGLPlotPainter&); TGLPlotPainter(TGLPlotPainter&&); TGLPlotPainter(TGL5DDataSet* data, TGLPlotCamera* camera, TGLPlotCoordinates* coord); TGLPlotPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord, B",MatchSource.WIKI,root/html602/TGLPlotPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPlotPainter.html
Deployability,update,updated,"*fYAxis; Double_tfYOZSectionPos; TAxis*fZAxis; vector<Double_t>fZLevels; static TGLPlotPainter::ESelectionBasekHighColorSelectionBase; static TGLPlotPainter::ESelectionBasekTrueColorSelectionBase. private:. const TColor*fPadColor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPlotPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord, Bool_t xoySelectable, Bool_t xozSelectable, Bool_t yozSelectable); TGLPlotPainter's ctor. TGLPlotPainter(TGL5DDataSet* data, TGLPlotCamera* camera, TGLPlotCoordinates* coord); TGLPlotPainter's ctor. TGLPlotPainter(TGLPlotCamera* camera); TGLPlotPainter's ctor. void Paint(); Draw lego/surf/whatever you can. void PrintPlot() const; Generate PS using gl2ps. Bool_t PlotSelected(Int_t px, Int_t py); Read color buffer content to find selected object. void SetPadColor(const TColor* color); Used in a pad. void SetFrameColor(const TColor* frameColor); Set plot's back box color. void InvalidateSelection(); Selection must be updated. const TColor * GetPadColor() const; Get pad color. void MoveSection(Int_t px, Int_t py); Create dynamic profile using selected plane. void DrawSections() const; Draw sections (if any). void ClearBuffers() const. // Clear buffer.; Float_t rgb[3] = {1.f, 1.f, 1.f};; if (const TColor *color = GetPadColor()); color->GetRGB(rgb[0], rgb[1], rgb[2]);; glClearColor(rgb[0], rgb[1], rgb[2], 1.);; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);. void DrawPaletteAxis() const; Draw. Palette. Axis. void SaveModelviewMatrix() const. void SaveProjectionMatrix() const. void RestoreModelviewMatrix() const. void RestoreProjectionMatrix() const. TGLPlotPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord, Bool_t xoySelectable, Bool_t xozSelectable, Bool_t yozSelectable); TGLPlotPainter(TH1 *hist, TGLPlotCamera *camera, TGLPlotCoordinates *coord, Int_t context,; Bool_t xoySelectable, Bool_t xozSelectable, Bool_t yozSelectable);; TGLPlotPainter(TGLPlotCamera *c",MatchSource.WIKI,root/html602/TGLPlotPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPlotPainter.html
Modifiability,inherit,inheritance,"pe::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals(). protected:. voidTGLLogicalShape::PurgeDLRange(UInt_t base, Int_t size) const. Data Members; public:. static TGLLogicalShape::ELODAxesTGLLogicalShape::kLODAxesAll; static TGLLogicalShape::ELODAxesTGLLogicalShape::kLODAxesNone; static TGLLogicalShape::ELODAxesTGLLogicalShape::kLODAxesX; static TGLLogicalShape::ELODAxesTGLLogicalShape::kLODAxesY; static TGLLogicalShape::ELODAxesTGLLogicalShape::kLODAxesZ. protected:. TGLBoundingBoxTGLLogicalShape::fBoundingBox! Shape's bounding box.; UInt_tTGLLogicalShape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!); static Bool_tTGLLogicalShape::fgIgnoreSizeForCameraInterest. private:. Double_tfLineWidth; vector<Double_t>fVertices. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPolyLine(const TBuffer3D& buffer); constructor; dynamic_cast because of multiple inheritance. void DirectDraw(TGLRnrCtx& rnrCtx) const; Debug tracing. TGLPolyLine(const TBuffer3D& buffer). » Author: Timur Pocheptsov 03/08/2004 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLPolyLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPolyLine.html
Performance,cache,cached," voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; TGLPolyLine&operator=(const TGLPolyLine&); TGLPolyLine&operator=(TGLPolyLine&&); virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TGLPolyLine(const TBuffer3D& buffer); TGLPolyLine(const TGLPolyLine&); TGLPolyLine(TGLPolyLine&&); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html602/TGLPolyLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPolyLine.html
Performance,cache,cached,"voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; TGLPolyMarker&operator=(const TGLPolyMarker&); TGLPolyMarker&operator=(TGLPolyMarker&&); virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TGLPolyMarker(const TBuffer3D& buffer); TGLPolyMarker(const TGLPolyMarker&); TGLPolyMarker(TGLPolyMarker&&); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html602/TGLPolyMarker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPolyMarker.html
Availability,error,error," virtual~TGLPShapeObj(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Opti",MatchSource.WIKI,root/html602/TGLPShapeObj.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPShapeObj.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGeoValueSet(Long_t unusedVal); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompo",MatchSource.WIKI,root/html602/TGLPShapeObjEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPShapeObjEditor.html
Deployability,update,update,"PShapeObjEditor::ELightModekDiffuse; static TGLPShapeObjEditor::ELightModekEmission; static TGLPShapeObjEditor::ELightModekSpecular. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPShapeObjEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of TGLPhysicalShape editor GUI. ~TGLPShapeObjEditor(); Destroy color editor GUI component.; Done automatically. void SetPShape(TGLPhysicalShape* shape); Shape has changed.; Check if set to zero and make sure we're no longer in editor. void PShapeModified(); Shape has been modified.; Update editor if we're still shown. Otherwise unref. void SetModel(TObject* obj); Sets model or disables/hides viewer. void SetCenter(const Double_t* center); Set internal center data from 3 component 'c'. void SetScale(const Double_t* scale); Set internal scale data from 3 component 'c'. void DoGeoButton(); Process 'Apply' - update the viewer object from GUI. void GetObjectData(Double_t* shift, Double_t* scale); Extract the GUI object data, return center in 3 component 'center'; scale in 3 component 'scale'. void GeoValueSet(Long_t unusedVal); Process setting of value in edit box - activate 'Apply' button. void CreateGeoControls(); Create GUI for setting scale and position. void SetRGBA(const Float_t* rgba); Set color sliders from 17 component 'rgba'. void DoColorSlider(Int_t val); Process slider movement. void DoColorButton(); Process button action. void CreateColorRadioButtons(); Create Diffuse/Ambient/Specular/Emissive radio buttons and sub-frames. void CreateColorSliders(); Create GUI for setting light color. void SetColorSlidersPos(); Update GUI sliders from internal data. void DoRedraw(); Redraw widget. Render sphere and pass to base-class. void DrawSphere() const; Draw local sphere reflecting current color options. void CreateColorControls(); Create widgets to chhos colors componnet and its RGBA v",MatchSource.WIKI,root/html602/TGLPShapeObjEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPShapeObjEditor.html
Performance,perform,perform,"o TGLPysicalShape that need to be notified; when the shape is destroyed.; Could also deliver 'change' notifications. Function Members (Methods); public:. virtual~TGLPShapeRef(); static TClass*Class(); TGLPhysicalShape*GetPShape() const; virtual TClass*IsA() const; virtual voidPShapeModified(); virtual voidSetPShape(TGLPhysicalShape* shape); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLPShapeRef(); TGLPShapeRef(TGLPhysicalShape* shape). private:. TGLPShapeRef&operator=(const TGLPShapeRef&); TGLPShapeRef(const TGLPShapeRef&). Data Members; protected:. TGLPhysicalShape*fPShapePointer to referenced physical shape. private:. TGLPShapeRef*fNextPSRefInternal pointer to the next reference (used by TGLPhysicalShape directly). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLPShapeRef(); Default contructor. TGLPShapeRef(TGLPhysicalShape* shape); Constructor with known shape - reference it. ~TGLPShapeRef(); Destructor - unreference the shape if set. void SetPShape(TGLPhysicalShape* shape); Set the shape. Unreference the old and reference the new.; This is virtual so that sub-classes can perform other tasks; on change. This function should be called first from there. This is also called from destructor of the refereced physical; shape with 0 argument. void PShapeModified(); This is called from physical shape when it is modified.; Sub-classes can override and take appropriate action. TGLPShapeRef(const TGLPShapeRef& ). TGLPShapeRef& operator=(const TGLPShapeRef& ). TGLPhysicalShape * GetPShape() const; { return fPShape; }. » Author: Matevz Tadel, Feb 2007 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLPShapeRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLPShapeRef.html
Availability,avail,available,"Base* viewer); Constructor. ~TGLRnrCtx(); Destructor. TGLSceneBase * GetScene(); Return current scene (based on scene-info data). TGLSceneBase & RefScene(); Return current scene (based on scene-info data). Bool_t IsDrawPassFilled() const; Returns true if current render-pass uses filled polygon style. Bool_t HasStopwatchTimedOut(); Check if the stopwatch went beyond the render time limit. void BeginSelection(Int_t x, Int_t y, Int_t r = 3); Setup context for running selection.; x and y are in window coordinates. void EndSelection(Int_t glResult); End selection. TGLRect * GetPickRectangle(); Return current pick rectangle. This is *zero* when; selection is not set. Int_t GetPickRadius(); Return pick radius. If selection is not active it returns 0. void PushColorSet(); Create copy of current color-set on the top of the stack. TGLColorSet& ColorSet(); Return reference to current color-set (top of hte stack). void PopColorSet(); Pops the top-most color-set.; If only one entry is available, error is printed and the entry remains. TGLColorSet* ChangeBaseColorSet(TGLColorSet* set); Change the default/bottom color-set.; Returns the previous color-set. TGLColorSet* GetBaseColorSet(); Returns the current base color-set. void ColorOrForeground(Color_t col); Set col if it is different from background, otherwise use; current foreground color. void OpenDLCapture(); Start display-list capture. void CloseDLCapture(); End display list capture. void ReleaseFont(TGLFont& font); Release font in the GL rendering context. void RegisterFontNoScale(Int_t size, Int_t file, Int_t mode, TGLFont& out); Get font in the GL rendering context. void RegisterFontNoScale(Int_t size, const char* name, Int_t mode, TGLFont& out); Get font in the GL rendering context. void RegisterFont(Int_t size, Int_t file, Int_t mode, TGLFont& out); Get font in the GL rendering context.; The font is scaled relative to current render scale. void RegisterFont(Int_t size, const char* name, Int_t mode, TGLFont& out); Get font",MatchSource.WIKI,root/html602/TGLRnrCtx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLRnrCtx.html
Testability,log,logical,". TGLRnrCtx. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLRnrCtx. class TGLRnrCtx. The TGLRnrCtx class aggregates data for a given redering context as; needed by various parts of the ROOT's OpenGL infractructure. It; serves as a connecting point between the steering part of the; infrastructure (viewer, scene) and concrete rendering classes; (logical, physical shape). It is just a data-holder, there is no; functionality in it. Development notes:. One RnrCtx is created by each viewer and it is just an extension of; the viewer context that changes along the render; descend. Separating this also has some abstract benefit of hiding; viewer implementation from those that do not need to know it. Current scene / scene-info part is always initialized by viewer,; scenes can assume they're ok. Function Members (Methods); public:. virtual~TGLRnrCtx(); voidBeginSelection(Int_t x, Int_t y, Int_t r = 3); TGLColorSet*ChangeBaseColorSet(TGLColorSet* set); static TClass*Class(); TGLClip*Clip() const; voidCloseDLCapture(); voidColorOrForeground(Color_t col); TGLColorSet&ColorSet(); Short_tCombiLOD() const; Short_tDrawPass() const; voidEndSelection(Int_t glResult); TGLColorSet*GetBaseColorSet(); TGLCamera*GetCamera(); const TGLCamera*GetCamera() const; UInt_tGetEventKeySym() const; TGLContextIdentity*GetGLCtxIdentity() const; GLUquadric*GetGluQuadric(); Bool_tGetGrabImage() const; Int_tGetPickRadius(); TGLRect*GetPickRectangle(); Float_tGetRenderScale() const; TGLSceneBase*GetScene(); TGLSceneInfo*GetSceneInfo(); TGLSelectBuffer*GetSelectBuffer() const; TGLViewerBase*GetViewer(); Bool_tHasClip() const; Bool_tHasStopwatchTimedOut(); Bool_tHighlight() const; Bool_tHighlightOutline() const; virtual TClass*IsA() const; Bool_tIsDLCaptureOpen() const; Bool_tIsDrawPassFilled() const; Bool_tIsDrawPassOutlineL",MatchSource.WIKI,root/html602/TGLRnrCtx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLRnrCtx.html
Energy Efficiency,green,green,". TGLRotateManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLRotateManip. class TGLRotateManip: public TGLManip. Rotate manipulator - attaches to physical shape and draws local axes; widgets - rings drawn from attached physical center, in plane defined; by axis. User can mouse over (turns yellow) and L click/drag to; rotate attached physical round the ring center.; Widgets use standard 3D package axes colours: X red, Y green, Z blue. Function Members (Methods); public:. virtual~TGLRotateManip(); voidTGLManip::Attach(TGLPhysicalShape* shape); static TClass*Class(); virtual voidDraw(const TGLCamera& camera) const; Bool_tTGLManip::GetActive() const; TGLPhysicalShape*TGLManip::GetAttached() const; UInt_tTGLManip::GetSelectedWidget() const; virtual Bool_tHandleButton(const Event_t& event, const TGLCamera& camera); virtual Bool_tHandleMotion(const Event_t& event, const TGLCamera& camera); virtual TClass*IsA() const; TGLRotateManip&operator=(const TGLRotateManip&); virtual Bool_tTGLManip::Select(const TGLCamera&, const TGLRect&, const TGLBoundingBox&); voidTGLManip::SetActive(Bool_t a); voidTGLManip::SetSelectedWidget(UInt_t s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLRotateManip(); TGLRotateManip(TGLPhysicalShape* shape); TGLRotateManip(const TGLRotateManip&). protected:. static Double_tAngle(const TGLVector3& v1, const TGLVector3& v2); static Double_tAngle(const TGLVector3& v1, const TGLVector3& v2, const TGLVector3& ref); voidTGLManip::CalcDrawScale(const TGLBoundingBox& box, const TGLCamera& camera, Double_t& base, TGLVector3[3] axis) const; const UChar_t*TGLManip::ColorFor(UInt_t widget) const. private:. Double_tCalculateAngleDelta(const TPoint& mouse, const TGLCamera& came",MatchSource.WIKI,root/html602/TGLRotateManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLRotateManip.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html602/TGLSAFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSAFrame.html
Integrability,message,message,"n; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGLSAViewer&fViewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLSAFrame(TGLSAViewer& viewer); Construct GUI frame, bound to passed 'viewer'. TGLSAFrame(const TGWindow* parent, TGLSAViewer& viewer); Construct GUI frame, bound to passed 'viewer'. ~TGLSAFrame(); Destroy the GUI frame. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process GUI message - defered back up to TGLSAViewer::ProcessFrameMessage(). void CloseWindow(); Close the GUI frame. TGLSAFrame(const TGLSAFrame& ); non-copyable class. » Author: Richard Maunder 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLSAFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSAFrame.html
Availability,error,error,"m); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEnableMenuBarHiding(); virtual voidTGLViewer::EndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGLViewer::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Bool_tTGLViewerBase::FindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); TGLLogicalShape*TGLViewerBase::FindLogicalInScenes(TObject* id); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGLAutoRotator*TGLViewer::GetAutoRotator(); TGLCameraOverlay*TGLViewer::GetCameraOverlay() const; Bool_tTGLViewer::GetClipAutoUpdate() const; TGLClipSet*TGLViewer::GetClipSet() const; TGLOverlayElement*TGLViewer::GetCurrentOvlElm() const; static TGLColorSet&TGLViewer::GetDefaultColorSet(); Int_tTGLViewer::GetDev() const; TGLV",MatchSource.WIKI,root/html602/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSAViewer.html
Deployability,update,update,"(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TGLAutoRotator*TGLViewer::fAutoRotator!; Bool_tTGLViewer::fAxesDepthTest! remove guides hidden-lines; Int_tTGLViewer::fAxesType! axes type; TGLCamera*TGLViewerBase::fCameraCamera for rendering.; TGLCameraOverlay*TGLViewer::fCameraOverlay! markup size of viewport in scene units; Bool_tTGLViewerBase::fChangedChange requiring redraw is pending.; TGLClip*TGLViewerBase::fClipViewer clipping-plane.; TGLClipSet*TGLViewer::fClipSet!; TContextMenu*TGLViewer::fContextMenu!; TGLCamera*TGLViewer::fCurrentCamera!; TGLOverlayElement*TGLViewer::fCurrentOvlElm! current overlay element; TGLSelectRecordTGLViewer::fCurrentSelRec! select record in use as selected; TGLColorSetTGLViewer::fDarkColorSet! color-set with dark background; Bool_tTGLViewer::fDebugMode! debug mode (forced rebuild + draw scene/frustum/interest boxes); TGLViewer::EDragActionTGLViewer::fDragAction; Bool_tTGLViewer::fDrawCameraCenter! reference marker on?; TGEventHandler*TGLViewer::fEventHandler! event handler; Float_tTGLViewer::fFader! fade the view (0 - no fade/default, 1 - full fade/no rendering done); TGLContextIdentity*TGLViewer::fGLCtxId!for embedded gl viewer; Int_tTGLViewer::fGLDevice!for embedded gl viewer; TGLWidget*TGLViewer::fGLWidget; TGedEditor*TGLViewer::fGedEditor! GED editor; Bool_tTGLViewer::fIgnoreSizesOnUpdateignore sizes of bounding-boxes on update; Bool_tTGLViewer::fIsPrinting!; Short_tTGLViewerBase::fLODViewer-lod for rendering.; TGLColorSetTGLViewer::fLightColorSet! color-set with light background; TGLLightSet*TGLViewer::fLightSet!; Float_tTGLViewer::fLineScale! width scale for lines; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGLLockable::ELockTGLLockable::fLockLock state.; Float_tTGLViewer::fMaxSceneDrawTimeHQ! max time for scene rendering at high LOD (in ms); Float_tTGLViewer::fMaxSceneDrawTimeLQ! max time f",MatchSource.WIKI,root/html602/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSAViewer.html
Integrability,message,message," GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSAViewer.html
Modifiability,plugin,plugin,". TGLSAViewer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLSAViewer. class TGLSAViewer: public TGLViewer. The top level standalone GL-viewer - created via plugin manager. Function Members (Methods); public:. virtual~TGLSAViewer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGLViewer::Activated()SIGNAL ; virtual voidTGLViewer::AddCompositeOp(UInt_t); virtual Int_tTGLViewer::AddObject(const TBuffer3D&, Bool_t* = 0); virtual Int_tTGLViewer::AddObject(UInt_t, const TBuffer3D&, Bool_t* = 0); virtual voidTGLViewerBase::AddOverlayElement(TGLOverlayElement* el); TGLSceneInfo*TGLViewerBase::AddScene(TGLSceneBase* scene); virtual voidTObject::AppendPad(Option_t* option = """"); voidTGLViewer::ApplySelection(); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; voidTGLViewer::AutoFade(Float_t fade, Float_t time = 1, Int_t steps = 10); virtual voidTGLViewer::BeginScene(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTGLViewer::BuildingScene() const; virtual Bool_tTGLViewer::CanLoopOnPrimitives() const; virtual voidTGLViewerBase::Changed(); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGLViewer::ClearCurrentOvlElm(); virtual voidTGLViewer::Clicked(TObject* obj)SIGNAL ; virtual voidTGLViewer::Clicked(TObject* obj, UInt_t button, UInt_t state)SIGNAL ; TGLClip*TGLViewerBase::Clip() const; virtual TObject*TObject::Clone(const char* newname = """") const; voidClose(); virtual voidTGLViewer::CloseComposite(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); TGLColorSet&TGLViewer::ColorSet(); virt",MatchSource.WIKI,root/html602/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSAViewer.html
Performance,cache,cache,"cale! size scale for points; TGLViewer::EPushActionTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; TGLViewerBase::SceneInfoList_tTGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds; Bool_tTGLViewer::fSmoothLines! smooth line edge rendering; Bool_tTGLViewer::fSmoothPoints! smooth point edge rendering; Bool_tTGLViewer::fStereo! use stereo rendering; Float_tTGLViewer::fStereoEyeOffsetFac!; Float_tTGLViewer::fStereoFrustumAsymFac!; Float_tTGLViewer::fStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectTGLViewer::fViewport! viewport - drawn area; TGLViewerBase::SceneInfoVec_tTGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetTGLViewer::fgDefaultColorSet! a shared, default color-set; static Bool_tTGLViewer::fgUseDefaultColorSetForNewViewers! name says it all. private:. TGPopupMenu*fCameraMenu; Bool_tfDeleteMenuBar; TStringfDirName; TGPopupMenu*fFileMenu; TGPopupMenu*fFileSaveMenu; TGLFormat*fFormat; TGLSAFrame*",MatchSource.WIKI,root/html602/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSAViewer.html
Safety,timeout,timeout,"tBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGLViewer::SetCameraOverlay(TGLCameraOverlay* m); voidTGLViewer::SetClearColor(Color_t col); voidTGLViewerBase::SetClip(TGLClip* p); voidTGLViewer::SetClipAutoUpdate(Bool_t x); voidTGLViewer::SetCurrentCamera(TGLViewer::ECameraType camera); voidTGLViewer::SetDrawCameraCenter(Bool_t x); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTGLViewer::SetEventHandler(TGEventHandler* handler); voidTGLViewer::SetFader(Float_t x); virtual voidTGLViewer::SetGedEditor(TGedEditor* ed); voidTGLViewer::SetGuideState(Int_t axesType, Bool_t axesDepthTest, Bool_t referenceOn, const Double_t* referencePos); voidTGLViewer::SetIgnoreSizesOnUpdate(Bool_t v); voidTGLViewer::SetLineScale(Float_t s); voidTGLViewerBase::SetLOD(Short_t lod); voidTGLViewer::SetMaxSceneDrawTimeHQ(Float_t t); voidTGLViewer::SetMaxSceneDrawTimeLQ(Float_t t); static voidSetMenuHidingTimeout(Long_t timeout); static voidTObject::SetObjectStat(Bool_t stat); voidTGLViewerBase::SetOLLineW(Float_t w); voidTGLViewer::SetOrthoCamera(TGLViewer::ECameraType camera, Double_t zoom, Double_t dolly, Double_t[3] center, Double_t hRotate, Double_t vRotate); voidTGLViewer::SetPerspectiveCamera(TGLViewer::ECameraType camera, Double_t fov, Double_t dolly, Double_t[3] center, Double_t hRotate, Double_t vRotate); voidTGLViewer::SetPictureFileName(const TString& f); voidTGLViewer::SetPointScale(Float_t s); voidTGLViewer::SetResetCamerasOnUpdate(Bool_t v); voidTGLViewer::SetSmartRefresh(Bool_t smart_ref); voidTGLViewer::SetSmoothLines(Bool_t s); voidTGLViewer::SetSmoothPoints(Bool_t s); voidTGLViewer::SetStereo(Bool_t s); voidTGLViewer::SetStereoEyeOffsetFac(Float_t f); voidTGLViewer::SetStereoFrustumAsymFac(Float_t f); voidTGLViewer::SetStereoZeroParallax(Float_t f); voidTGLViewerBase::SetStyle(Short_t st); virtual voidTObject::SetUniqueID(UInt_t uid); voidTGLViewerBase::SetWFLineW(Float_t w); voidShow()",MatchSource.WIKI,root/html602/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSAViewer.html
Testability,log,logicals,"cale! size scale for points; TGLViewer::EPushActionTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; TGLViewerBase::SceneInfoList_tTGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds; Bool_tTGLViewer::fSmoothLines! smooth line edge rendering; Bool_tTGLViewer::fSmoothPoints! smooth point edge rendering; Bool_tTGLViewer::fStereo! use stereo rendering; Float_tTGLViewer::fStereoEyeOffsetFac!; Float_tTGLViewer::fStereoFrustumAsymFac!; Float_tTGLViewer::fStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectTGLViewer::fViewport! viewport - drawn area; TGLViewerBase::SceneInfoVec_tTGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetTGLViewer::fgDefaultColorSet! a shared, default color-set; static Bool_tTGLViewer::fgUseDefaultColorSetForNewViewers! name says it all. private:. TGPopupMenu*fCameraMenu; Bool_tfDeleteMenuBar; TStringfDirName; TGPopupMenu*fFileMenu; TGPopupMenu*fFileSaveMenu; TGLFormat*fFormat; TGLSAFrame*",MatchSource.WIKI,root/html602/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSAViewer.html
Usability,guid,guides,"::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TGLLockable::ELockTGLLockable::kModifyLock; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TGLViewer::ESecSelTypeTGLViewer::kOnKeyMod1; static TGLViewer::ESecSelTypeTGLViewer::kOnRequest; static TObject::(anonymous)TObject::kOverwrite; static TGLViewer::EPushActionTGLViewer::kPushAnnotate; static TGLViewer::EPushActionTGLViewer::kPushCamCenter; static TGLViewer::EPushActionTGLViewer::kPushStd; static TGLLockable::ELockTGLLockable::kSelectLock; static TObject::(anonymous)TObject::kSingleKey; static TGLLockable::ELockTGLLockable::kUnlocked; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TGLAutoRotator*TGLViewer::fAutoRotator!; Bool_tTGLViewer::fAxesDepthTest! remove guides hidden-lines; Int_tTGLViewer::fAxesType! axes type; TGLCamera*TGLViewerBase::fCameraCamera for rendering.; TGLCameraOverlay*TGLViewer::fCameraOverlay! markup size of viewport in scene units; Bool_tTGLViewerBase::fChangedChange requiring redraw is pending.; TGLClip*TGLViewerBase::fClipViewer clipping-plane.; TGLClipSet*TGLViewer::fClipSet!; TContextMenu*TGLViewer::fContextMenu!; TGLCamera*TGLViewer::fCurrentCamera!; TGLOverlayElement*TGLViewer::fCurrentOvlElm! current overlay element; TGLSelectRecordTGLViewer::fCurrentSelRec! select record in use as selected; TGLColorSetTGLViewer::fDarkColorSet! color-set with dark background; Bool_tTGLViewer::fDebugMode! debug mode (forced rebuild + draw scene/frustum/interest boxes); TGLViewer::EDragActionTGLViewer::fDragAction; Bool_tTGLViewer::fDrawCameraCenter! reference marker on?; TGEventHandler*TGLViewer::fEventHandler! event handler; Float_tTGLViewer::fFader! fade the view (0 - no fade/default, 1 - full fade/no rendering done); TGLContextIdentity*TGLVi",MatchSource.WIKI,root/html602/TGLSAViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSAViewer.html
Energy Efficiency,green,green,". TGLScaleManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLScaleManip. class TGLScaleManip: public TGLManip. TGLScaleManip. Scale manipulator - attaches to physical shape and draws local axes; widgets with box heads. User can mouse over (turns yellow) and L; click/drag to scale along this axis.; Widgets use standard 3D package axes colours: X red, Y green, Z blue. Function Members (Methods); public:. virtual~TGLScaleManip(); voidTGLManip::Attach(TGLPhysicalShape* shape); static TClass*Class(); virtual voidDraw(const TGLCamera& camera) const; Bool_tTGLManip::GetActive() const; TGLPhysicalShape*TGLManip::GetAttached() const; UInt_tTGLManip::GetSelectedWidget() const; virtual Bool_tHandleButton(const Event_t& event, const TGLCamera& camera); virtual Bool_tHandleMotion(const Event_t& event, const TGLCamera& camera); virtual TClass*IsA() const; TGLScaleManip&operator=(const TGLScaleManip&); virtual Bool_tTGLManip::Select(const TGLCamera&, const TGLRect&, const TGLBoundingBox&); voidTGLManip::SetActive(Bool_t a); voidTGLManip::SetSelectedWidget(UInt_t s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLScaleManip(); TGLScaleManip(TGLPhysicalShape* shape); TGLScaleManip(const TGLScaleManip&). protected:. voidTGLManip::CalcDrawScale(const TGLBoundingBox& box, const TGLCamera& camera, Double_t& base, TGLVector3[3] axis) const; const UChar_t*TGLManip::ColorFor(UInt_t widget) const. private:. voidLimitScale(Double_t& factor) const. Data Members; protected:. Bool_tTGLManip::fActive! manipulator is active?; TPointTGLManip::fFirstMouse! first (start) mouse position (in WINDOW coords); TPointTGLManip::fLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tTGLManip::fSelectedWidget!",MatchSource.WIKI,root/html602/TGLScaleManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLScaleManip.html
Availability,error,error,"wElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t DestroyLogicals(); Destroy all logical shapes in scene.; Return number of destroyed logicals. TGLLogicalShape * FindLogical(TObject* logid) const; Find and return logical shape identified by unqiue logid.; Returns 0 if not found. void AdoptPhysical(TGLPhysicalShape& shape); Adopt dynamically created physical 'shape' - add to internal map and take; responsibility for deleting. void DestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); Virtual function to destroy a physical. Sub-classes might have; special checks to perform.; Caller should also invalidate the draw-list. Bool_t DestroyPhysical(UInt_t phid); Destroy physical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. Int_t DestroyPhysicals(); Destroy physical shapes. TGLPhysicalShape* FindPhysical(UInt_t phid) const; Find and return physical shape identified by unqiue 'ID'.; Returns 0 if not found. UInt_t GetMaxPhysicalID(); Returns the maximum used ",MatchSource.WIKI,root/html602/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLScene.html
Deployability,update,updateViewers, virtual~TGLScene(); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidAdoptLogical(TGLLogicalShape& shape); virtual voidAdoptPhysical(TGLPhysicalShape& shape); UInt_tBeginSmartRefresh(); virtual Bool_tBeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*TGLSceneBase::Clip() const; virtual TGLScene::TSceneInfo*CreateSceneInfo(TGLViewerBase* view); TGLLockable:,MatchSource.WIKI,root/html602/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLScene.html
Integrability,interface,interface,". TGLScene. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLScene. class TGLScene: public TGLSceneBase. TGLScene provides managememnt and rendering of ROOT's default 3D; object representation as logical and physical shapes. A GL scene is the container for all the viewable objects (shapes); loaded into the viewer. It consists of two main stl::maps containing; the TGLLogicalShape and TGLPhysicalShape collections, and interface; functions enabling viewers to manage objects in these. The physical; shapes defined the placement of copies of the logical shapes - see; TGLLogicalShape/TGLPhysicalShape for more information on relationship. The scene can be drawn by owning viewer, passing camera, draw style; & quality (LOD), clipping etc - see Draw(). The scene can also be; drawn for selection in similar fashion - see Select(). The scene; keeps track of a single selected physical - which can be modified by; viewers. The scene maintains a lazy calculated bounding box for the total; scene extents, axis aligned round TGLPhysicalShape shapes. Currently a scene is owned exclusively by one viewer - however it is; intended that it could easily be shared by multiple viewers - for; efficiency and syncronisation reasons. Hence viewer variant objects; camera, clips etc being owned by viewer and passed at draw/select. Function Members (Methods); public:. virtual~TGLScene(); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidAdoptLogical(TGLLogicalShape& shape); virtual voidAdoptPhysical(TGLPhysicalShape& shape); UInt_tBeginSmartRefresh(); virtual Bool_tBeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*TGLSceneBase::Clip() const; virtual TGLScene::TSceneInfo*CreateSceneInfo(TGLViewerBase* view); TGLLockable:",MatchSource.WIKI,root/html602/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLScene.html
Performance,load,loaded,". TGLScene. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLScene. class TGLScene: public TGLSceneBase. TGLScene provides managememnt and rendering of ROOT's default 3D; object representation as logical and physical shapes. A GL scene is the container for all the viewable objects (shapes); loaded into the viewer. It consists of two main stl::maps containing; the TGLLogicalShape and TGLPhysicalShape collections, and interface; functions enabling viewers to manage objects in these. The physical; shapes defined the placement of copies of the logical shapes - see; TGLLogicalShape/TGLPhysicalShape for more information on relationship. The scene can be drawn by owning viewer, passing camera, draw style; & quality (LOD), clipping etc - see Draw(). The scene can also be; drawn for selection in similar fashion - see Select(). The scene; keeps track of a single selected physical - which can be modified by; viewers. The scene maintains a lazy calculated bounding box for the total; scene extents, axis aligned round TGLPhysicalShape shapes. Currently a scene is owned exclusively by one viewer - however it is; intended that it could easily be shared by multiple viewers - for; efficiency and syncronisation reasons. Hence viewer variant objects; camera, clips etc being owned by viewer and passed at draw/select. Function Members (Methods); public:. virtual~TGLScene(); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidAdoptLogical(TGLLogicalShape& shape); virtual voidAdoptPhysical(TGLPhysicalShape& shape); UInt_tBeginSmartRefresh(); virtual Bool_tBeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*TGLSceneBase::Clip() const; virtual TGLScene::TSceneInfo*CreateSceneInfo(TGLViewerBase* view); TGLLockable:",MatchSource.WIKI,root/html602/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLScene.html
Safety,timeout,timeout,"ansp(TGLRnrCtx& rnrCtx); Render transparent elements. void RenderSelOpaque(TGLRnrCtx& rnrCtx); Render selected opaque elements. void RenderSelTransp(TGLRnrCtx& rnrCtx); Render selected transparent elements. void RenderSelOpaqueForHighlight(TGLRnrCtx& rnrCtx); Render selected opaque elements for highlight. void RenderSelTranspForHighlight(TGLRnrCtx& rnrCtx); Render selected transparent elements for highlight. void RenderHighlight(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec). void PostDraw(TGLRnrCtx& rnrCtx); Called after the rendering is finished.; In debug mode draw statistcs is dumped.; Parent's PostDraw is called for GL cleanup. void RenderAllPasses(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout); Do full rendering of scene. First draw the opaques, then the transparents. For each we do; the number of passes required by draw mode and clipping setup. void RenderElements(TGLRnrCtx& rnrCtx, TGLScene::DrawElementPtrVec_t& elVec, Bool_t check_timeout, const TGLPlaneSet_t* clipPlanes = 0); Render DrawElements in elementVec with given timeout.; If clipPlanes is non-zero, test each element against its; clipping planes. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. void CalcBoundingBox() const; Encapsulates all physical shapes bounding box with axes aligned box.; Validity checked in the base-class. void AdoptLogical(TGLLogicalShape& shape); Adopt dynamically created logical 'shape' - add to internal map; and take responsibility for deleting. Bool_t DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); Destroy logical shape defined by unique 'ID'.; Returns kTRUE if found/destroyed - kFALSE otherwise. If mustFind is true, an error is reported if the logical is not; found. Int_t ",MatchSource.WIKI,root/html602/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLScene.html
Security,access,access,"har_t transp = 0); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, UChar_t* col); virtual voidUpdatePhysioLogical(TObject* logid, Double_t* trans, Color_t cidx, UChar_t transp); virtual voidUpdateSceneInfo(TGLRnrCtx& rnrCtx). protected:. virtual voidDestroyPhysicalInternal(TGLScene::PhysicalShapeMapIt_t pit); voidReleaseGLCtxIdentity(). private:. static Bool_tComparePhysicalDiagonals(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); static Bool_tComparePhysicalVolumes(const TGLPhysicalShape* shape1, const TGLPhysicalShape* shape2); TGLScene&operator=(const TGLScene&); TGLScene(const TGLScene&). Data Members; public:. static TGLLockable::ELockTGLLockable::kDrawLock; static TGLLockable::ELockTGLLockable::kModifyLock; static TGLLockable::ELockTGLLockable::kSelectLock; static TGLLockable::ELockTGLLockable::kUnlocked. protected:. Bool_tTGLSceneBase::fAutoDestruct; TGLBoundingBoxTGLSceneBase::fBoundingBoxbounding box for scene (axis aligned) - lazy update - use BoundingBox() to access; Bool_tTGLSceneBase::fBoundingBoxValidbounding box valid?; TGLClip*TGLSceneBase::fClipScene clipping-plane.; Bool_tTGLSceneBase::fDoClipCheckPerform global clip-plane-check in UpdateSceneInfo(); Bool_tTGLSceneBase::fDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); TGLContextIdentity*fGLCtxIdentity; Bool_tfInSmartRefresh!; Short_tTGLSceneBase::fLODScene-lod.; Float_tfLastLineWidthScale; Float_tfLastPointSizeScale; TGLLockable::ELockTGLLockable::fLockLock state.; TGLScene::LogicalShapeMap_tfLogicalShapes!; UInt_tTGLSceneBase::fMinorStampCounter increased on minimal update.; TStringTGLSceneBase::fNameObject identifier.; Float_tTGLSceneBase::fOLLineWScene outline line-width.; TGLScene::PhysicalShapeMap_tfPhysicalShapes!; UInt_tTGLSceneBase::fSceneIDUnique scene id.; Bool_tTGLSceneBase::fSelectableObjects in the scene are selectable.; TGLScene::LogicalShapeMap_tfSmartRefreshCache!; Short_tTGLSceneBase::fStyleScene-style.; UInt_tTGLSceneBase::fTimeSta",MatchSource.WIKI,root/html602/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLScene.html
Testability,log,logical,". TGLScene. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLScene. class TGLScene: public TGLSceneBase. TGLScene provides managememnt and rendering of ROOT's default 3D; object representation as logical and physical shapes. A GL scene is the container for all the viewable objects (shapes); loaded into the viewer. It consists of two main stl::maps containing; the TGLLogicalShape and TGLPhysicalShape collections, and interface; functions enabling viewers to manage objects in these. The physical; shapes defined the placement of copies of the logical shapes - see; TGLLogicalShape/TGLPhysicalShape for more information on relationship. The scene can be drawn by owning viewer, passing camera, draw style; & quality (LOD), clipping etc - see Draw(). The scene can also be; drawn for selection in similar fashion - see Select(). The scene; keeps track of a single selected physical - which can be modified by; viewers. The scene maintains a lazy calculated bounding box for the total; scene extents, axis aligned round TGLPhysicalShape shapes. Currently a scene is owned exclusively by one viewer - however it is; intended that it could easily be shared by multiple viewers - for; efficiency and syncronisation reasons. Hence viewer variant objects; camera, clips etc being owned by viewer and passed at draw/select. Function Members (Methods); public:. virtual~TGLScene(); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidAdoptLogical(TGLLogicalShape& shape); virtual voidAdoptPhysical(TGLPhysicalShape& shape); UInt_tBeginSmartRefresh(); virtual Bool_tBeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*TGLSceneBase::Clip() const; virtual TGLScene::TSceneInfo*CreateSceneInfo(TGLViewerBase* view); TGLLockable:",MatchSource.WIKI,root/html602/TGLScene.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLScene.html
Availability,avail,available,"T Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLSceneBase. class TGLSceneBase: public TGLLockable. Scene base-class -- provides basic interface expected by the; TGLViewer or its sub-classes:; * unique scene id; * scene locking; * overall bounding box; * list of viewers displaying the scene (for update propagation); * virtual interface for draw/select/render (?). The standard ROOT OpenGL scene is implemented in direct sub-class; TGLScene. Note that while each scene can be shared among several viewers, ALL; of them are obliged to share the same display-list space (this can; be achieved on GL-context creation time; Matevz believes that by; default all GL contexts must use shared display-lists etc). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLSceneBase(); voidAddViewer(TGLViewerBase* viewer); const TGLBoundingBox&BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*Clip() const; virtual TGLSceneInfo*CreateSceneInfo(TGLViewerBase* view); TGLLockable::ELockTGLLockable::CurrentLock() const; virtual TGLLogicalShape*FindLogical(TObject*) const; Bool_tGetAutoDestruct() const; UInt_tGetMinorStamp() const; virtual const char*GetName() const; Bool_tGetSelectable() const; UInt_tGetTimeStamp() const; virtual const char*GetTitle() const; voidIncMinorStamp(); voidIncTimeStamp(); voidInvalidateBoundingBox(); virtual TClass*IsA() const; Bool_tTGLLockable::IsDrawOrSelectLock() const; Bool_tTGLLockable::IsLocked() const; virtual const char*LockIdStr() const; static const char*TGLLockable::LockName(TGLLockable::ELock lock); static Bool_tTGLLockable::LockValid(TGLLockable::ELock lock); Short_tLOD() const; virtual voidLodifySceneInfo(TGLRnrCtx& ctx); virtua",MatchSource.WIKI,root/html602/TGLSceneBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSceneBase.html
Deployability,update,update,". TGLSceneBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLSceneBase. class TGLSceneBase: public TGLLockable. Scene base-class -- provides basic interface expected by the; TGLViewer or its sub-classes:; * unique scene id; * scene locking; * overall bounding box; * list of viewers displaying the scene (for update propagation); * virtual interface for draw/select/render (?). The standard ROOT OpenGL scene is implemented in direct sub-class; TGLScene. Note that while each scene can be shared among several viewers, ALL; of them are obliged to share the same display-list space (this can; be achieved on GL-context creation time; Matevz believes that by; default all GL contexts must use shared display-lists etc). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLSceneBase(); voidAddViewer(TGLViewerBase* viewer); const TGLBoundingBox&BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*Clip() const; virtual TGLSceneInfo*CreateSceneInfo(TGLViewerBase* view); TGLLockable::ELockTGLLockable::CurrentLock() const; virtual TGLLogicalShape*FindLogical(TObject*) const; Bool_tGetAutoDestruct() const; UInt_tGetMinorStamp() const; virtual const char*GetName() const; Bool_tGetSelectable() const; UInt_tGetTimeStamp() const; virtual const char*GetTitle() const; voidIncMinorStamp(); voidIncTimeStamp(); voidInvalidateBoundingBox(); virtual TClass*IsA() const; Bool_tTGLLockable::IsDrawOrSelectLock() const; Bool_tTGLLockable::IsLocked() const; virtual const char*LockIdStr() const; static const char*TGLLockable::LockName(TGLLockable::ELock lock); static Bool_tTGLLockable::LockValid(TGLLockable::ELock lock); Short_tLOD() const; virtual voidLodify",MatchSource.WIKI,root/html602/TGLSceneBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSceneBase.html
Integrability,interface,interface,". TGLSceneBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLSceneBase. class TGLSceneBase: public TGLLockable. Scene base-class -- provides basic interface expected by the; TGLViewer or its sub-classes:; * unique scene id; * scene locking; * overall bounding box; * list of viewers displaying the scene (for update propagation); * virtual interface for draw/select/render (?). The standard ROOT OpenGL scene is implemented in direct sub-class; TGLScene. Note that while each scene can be shared among several viewers, ALL; of them are obliged to share the same display-list space (this can; be achieved on GL-context creation time; Matevz believes that by; default all GL contexts must use shared display-lists etc). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLSceneBase(); voidAddViewer(TGLViewerBase* viewer); const TGLBoundingBox&BoundingBox() const; virtual voidCalcBoundingBox() const; static TClass*Class(); TGLClip*Clip() const; virtual TGLSceneInfo*CreateSceneInfo(TGLViewerBase* view); TGLLockable::ELockTGLLockable::CurrentLock() const; virtual TGLLogicalShape*FindLogical(TObject*) const; Bool_tGetAutoDestruct() const; UInt_tGetMinorStamp() const; virtual const char*GetName() const; Bool_tGetSelectable() const; UInt_tGetTimeStamp() const; virtual const char*GetTitle() const; voidIncMinorStamp(); voidIncTimeStamp(); voidInvalidateBoundingBox(); virtual TClass*IsA() const; Bool_tTGLLockable::IsDrawOrSelectLock() const; Bool_tTGLLockable::IsLocked() const; virtual const char*LockIdStr() const; static const char*TGLLockable::LockName(TGLLockable::ELock lock); static Bool_tTGLLockable::LockValid(TGLLockable::ELock lock); Short_tLOD() const; virtual voidLodify",MatchSource.WIKI,root/html602/TGLSceneBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSceneBase.html
Security,access,access,"ol_t a); voidSetClip(TGLClip* p); voidSetLOD(Short_t lod); virtual voidSetName(const char* name); virtual voidSetNameTitle(const char* name, const char* title); voidSetSelectable(Bool_t a); voidSetStyle(Short_t st); virtual voidSetTitle(const char* title); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Short_tStyle() const; voidTagViewersChanged(); Bool_tTGLLockable::TakeLock(TGLLockable::ELock lock) const; TGLSceneBase(); virtual voidUpdateSceneInfo(TGLRnrCtx& ctx). private:. TGLSceneBase&operator=(const TGLSceneBase&); TGLSceneBase(const TGLSceneBase&). Data Members; public:. static TGLLockable::ELockTGLLockable::kDrawLock; static TGLLockable::ELockTGLLockable::kModifyLock; static TGLLockable::ELockTGLLockable::kSelectLock; static TGLLockable::ELockTGLLockable::kUnlocked. protected:. Bool_tfAutoDestruct; TGLBoundingBoxfBoundingBoxbounding box for scene (axis aligned) - lazy update - use BoundingBox() to access; Bool_tfBoundingBoxValidbounding box valid?; TGLClip*fClipScene clipping-plane.; Bool_tfDoClipCheckPerform global clip-plane-check in UpdateSceneInfo(); Bool_tfDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); Short_tfLODScene-lod.; TGLLockable::ELockTGLLockable::fLockLock state.; UInt_tfMinorStampCounter increased on minimal update.; TStringfNameObject identifier.; Float_tfOLLineWScene outline line-width.; UInt_tfSceneIDUnique scene id.; Bool_tfSelectableObjects in the scene are selectable.; Short_tfStyleScene-style.; UInt_tfTimeStampCounter increased on every update.; TStringfTitleObject title.; TGLSceneBase::ViewerList_tfViewers; Float_tfWFLineWScene wire-frame line-width. private:. static UInt_tfgSceneIDSrc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLSceneBase(); Default constructor. ~TGLSceneBase(); Destructor. void AddViewer(TGLViewerBase* viewer); Add viewer to the list. void RemoveViewer(",MatchSource.WIKI,root/html602/TGLSceneBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSceneBase.html
Usability,clear,clear,"; Remove viewer from the list.; If auto-destruct is on and the last viewer is removed the scene; destructs itself. void TagViewersChanged(); Tag all viewers as changed. const char* LockIdStr() const; Name printed on locking info messages. TGLSceneInfo* CreateSceneInfo(TGLViewerBase* view); Create a scene-info instance appropriate for this scene class.; Here we instantiate the scene-info base-class TGLSceneInfo. void RebuildSceneInfo(TGLRnrCtx& ctx); Fill scene-info with very basic information that is practically; view independent. This is called when scene content is changed; or when camera-interest changes. void UpdateSceneInfo(TGLRnrCtx& ctx); Fill scene-info with information needed for rendering, take into; account the render-context (viewer state, camera, clipping).; Usually called from TGLViewer before rendering a scene if some; moderately significant part of render-context has changed. Here we update the basic state (clear last-LOD, mark the time,; set global <-> scene transforamtion matrices) and potentially; study and refine the clipping planes based on scene bounding box. void LodifySceneInfo(TGLRnrCtx& ctx); Setup LOD-dependant values in scene-info. Nothing to be done here but to store the last LOD. void PreDraw(TGLRnrCtx& rnrCtx); Perform basic pre-render initialization:; - calculate LOD, Style, Clipping,; - build draw lists. This is called in the beginning of the GL-viewer draw cycle. void PreRender(TGLRnrCtx& rnrCtx); Perform pre-render initialization - fill rnrCtx with; values stored during PreDraw(). This is called each time before RenderXyzz(). void Render(TGLRnrCtx& rnrCtx); This function does rendering of all stages, the shapes are; rendered in the following order: opaque, transparent,; selected-opaque, selected-transparent. GL-depth buffer is cleared after transparent shapes have been; rendered. This is never called from ROOT GL directly. Use it if you know; you are rendering a single scene. void RenderOpaque(TGLRnrCtx& rnrCtx); Render opaque eleme",MatchSource.WIKI,root/html602/TGLSceneBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSceneBase.html
Deployability,update,update,"tLastClip(TGLClip* p); voidSetLastLOD(Short_t ld); voidSetLastOLLineW(Float_t w); voidSetLastStyle(Short_t st); voidSetLastWFLineW(Float_t w); voidSetLOD(Short_t lod); voidSetOLLineW(Float_t w); voidSetSceneStamp(UInt_t ts); virtual voidSetSceneTrans(TGLMatrix&); voidSetStyle(Short_t st); voidSetupTransformsAndBBox(); voidSetWFLineW(Float_t w); Bool_tShouldClip() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Short_tStyle() const; TGLSceneInfo(TGLViewerBase* view = 0, TGLSceneBase* scene = 0); voidUpdateTimeouted(); Bool_tViewCheck() const; voidViewCheck(Bool_t c); Float_tWFLineW() const. private:. TGLSceneInfo&operator=(const TGLSceneInfo&); TGLSceneInfo(const TGLSceneInfo&). Data Members; public:. static TGLSceneInfo::EClipTestkClipInside; static TGLSceneInfo::EClipTestkClipNone; static TGLSceneInfo::EClipTestkClipOutside. protected:. Bool_tfActiveShow fScene in fViewer; UInt_tfCameraStampCamera's time-stamp on last update.; TGLClip*fClipOptional override of clipping-plane; Char_tfClipModeClipping mode, can be disbled.; TGLPlaneSet_tfClipPlanesClipping planes from clip-object; which planes are kept depends on inside/outside mode.; UInt_tfClipStampClip's time-stamp on last update.; TGLPlaneSet_tfFrustumPlanesClipping planes defined by frustum; only those intersecting the scene volume are kept.; Bool_tfInClipIs scene contained within clipping-volume.; Bool_tfInFrustumIs scene intersecting view-frustum.; Short_tfLODOptional override of scene lod; TGLCamera*fLastCameraLast camera used.; TGLClip*fLastClipLast combined viewer/scene clip (set in scene::update); Short_tfLastLODLast combined viewer/scene lod (set in scene::lodify-scene-info).; Float_tfLastOLLineWLast combined viewer/scene outline line-width (set in scene::pre-draw).; Short_tfLastStyleLast combined viewer/scene style (set in scene::pre-draw).; Float_tfLastWFLineWLast combined viewer/scene wire-frame lin",MatchSource.WIKI,root/html602/TGLSceneInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSceneInfo.html
Integrability,depend,depends,"SetSceneStamp(UInt_t ts); virtual voidSetSceneTrans(TGLMatrix&); voidSetStyle(Short_t st); voidSetupTransformsAndBBox(); voidSetWFLineW(Float_t w); Bool_tShouldClip() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Short_tStyle() const; TGLSceneInfo(TGLViewerBase* view = 0, TGLSceneBase* scene = 0); voidUpdateTimeouted(); Bool_tViewCheck() const; voidViewCheck(Bool_t c); Float_tWFLineW() const. private:. TGLSceneInfo&operator=(const TGLSceneInfo&); TGLSceneInfo(const TGLSceneInfo&). Data Members; public:. static TGLSceneInfo::EClipTestkClipInside; static TGLSceneInfo::EClipTestkClipNone; static TGLSceneInfo::EClipTestkClipOutside. protected:. Bool_tfActiveShow fScene in fViewer; UInt_tfCameraStampCamera's time-stamp on last update.; TGLClip*fClipOptional override of clipping-plane; Char_tfClipModeClipping mode, can be disbled.; TGLPlaneSet_tfClipPlanesClipping planes from clip-object; which planes are kept depends on inside/outside mode.; UInt_tfClipStampClip's time-stamp on last update.; TGLPlaneSet_tfFrustumPlanesClipping planes defined by frustum; only those intersecting the scene volume are kept.; Bool_tfInClipIs scene contained within clipping-volume.; Bool_tfInFrustumIs scene intersecting view-frustum.; Short_tfLODOptional override of scene lod; TGLCamera*fLastCameraLast camera used.; TGLClip*fLastClipLast combined viewer/scene clip (set in scene::update); Short_tfLastLODLast combined viewer/scene lod (set in scene::lodify-scene-info).; Float_tfLastOLLineWLast combined viewer/scene outline line-width (set in scene::pre-draw).; Short_tfLastStyleLast combined viewer/scene style (set in scene::pre-draw).; Float_tfLastWFLineWLast combined viewer/scene wire-frame line-width (set in scene::pre-draw).; Float_tfOLLineWOptional override of scene outline line-width; TGLSceneBase*fScene; UInt_tfSceneStampScene's time-stamp on last update.; Short_tfStyleOptional overri",MatchSource.WIKI,root/html602/TGLSceneInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSceneInfo.html
Modifiability,extend,extended,. TGLSceneInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLSceneInfo. class TGLSceneInfo. TGLSceneInfo. Base class for extended scene context. Scenes can be shared among several viewers and each scene needs to; cache some viewer/camera/clipping specific state => this is a; storage class for this data. Sub-classes of TGLSceneBase can override the virtual; CreateSceneInfo() method and in it instantiate a sub-class of; TGLSceneInfo containing the needed information. See TGLScene and; inner class SceneInfo; note that some casting is needed in actual; methods as TGLRnrCtx holds the base-class pointer. Function Members (Methods); public:. virtual~TGLSceneInfo(); UInt_tCameraStamp() const; static TClass*Class(); TGLClip*Clip() const; Char_tClipMode() const; voidClipMode(Char_t m); vector<TGLPlane>&ClipPlanes(); UInt_tClipStamp() const; vector<TGLPlane>&FrustumPlanes(); Bool_tGetActive() const; TGLSceneBase*GetScene() const; const TGLBoundingBox&GetTransformedBBox(); TGLViewerBase*GetViewer() const; Bool_tHasUpdateTimeouted() const; voidInClip(Bool_t c); voidInFrustum(Bool_t f); virtual TClass*IsA() const; Bool_tIsInClip() const; Bool_tIsInFrustum() const; Bool_tIsVisible() const; TGLCamera*LastCamera() const; TGLClip*LastClip() const; Short_tLastLOD() const; Float_tLastOLLineW() const; Short_tLastStyle() const; Float_tLastWFLineW() const; Short_tLOD() const; Float_tOLLineW() const; TGLSceneBase&RefScene() const; TGLViewerBase&RefViewer() const; voidResetCameraStamp(); voidResetClipStamp(); voidResetSceneStamp(); voidResetUpdateTimeouted(); UInt_tSceneStamp() const; voidSetActive(Bool_t a); voidSetCameraStamp(UInt_t ts); voidSetClip(TGLClip* p); voidSetClipStamp(UInt_t ts); voidSetLastCamera(TGLCamera* p); voidSetLastClip(TGLClip* p); voidSetLastLOD(Short_t ld); voidSetLastOLLineW(Float_,MatchSource.WIKI,root/html602/TGLSceneInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSceneInfo.html
Performance,cache,cache,. TGLSceneInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLSceneInfo. class TGLSceneInfo. TGLSceneInfo. Base class for extended scene context. Scenes can be shared among several viewers and each scene needs to; cache some viewer/camera/clipping specific state => this is a; storage class for this data. Sub-classes of TGLSceneBase can override the virtual; CreateSceneInfo() method and in it instantiate a sub-class of; TGLSceneInfo containing the needed information. See TGLScene and; inner class SceneInfo; note that some casting is needed in actual; methods as TGLRnrCtx holds the base-class pointer. Function Members (Methods); public:. virtual~TGLSceneInfo(); UInt_tCameraStamp() const; static TClass*Class(); TGLClip*Clip() const; Char_tClipMode() const; voidClipMode(Char_t m); vector<TGLPlane>&ClipPlanes(); UInt_tClipStamp() const; vector<TGLPlane>&FrustumPlanes(); Bool_tGetActive() const; TGLSceneBase*GetScene() const; const TGLBoundingBox&GetTransformedBBox(); TGLViewerBase*GetViewer() const; Bool_tHasUpdateTimeouted() const; voidInClip(Bool_t c); voidInFrustum(Bool_t f); virtual TClass*IsA() const; Bool_tIsInClip() const; Bool_tIsInFrustum() const; Bool_tIsVisible() const; TGLCamera*LastCamera() const; TGLClip*LastClip() const; Short_tLastLOD() const; Float_tLastOLLineW() const; Short_tLastStyle() const; Float_tLastWFLineW() const; Short_tLOD() const; Float_tOLLineW() const; TGLSceneBase&RefScene() const; TGLViewerBase&RefViewer() const; voidResetCameraStamp(); voidResetClipStamp(); voidResetSceneStamp(); voidResetUpdateTimeouted(); UInt_tSceneStamp() const; voidSetActive(Bool_t a); voidSetCameraStamp(UInt_t ts); voidSetClip(TGLClip* p); voidSetClipStamp(UInt_t ts); voidSetLastCamera(TGLCamera* p); voidSetLastClip(TGLClip* p); voidSetLastLOD(Short_t ld); voidSetLastOLLineW(Float_,MatchSource.WIKI,root/html602/TGLSceneInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSceneInfo.html
Availability,error,error," view); TGLLockable::ELockTGLLockable::CurrentLock() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Bool_tTGLScene::DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); virtual Int_tTGLScene::DestroyLogicals(); virtual Bool_tTGLScene::DestroyPhysical(UInt_t phid); virtual Int_tTGLScene::DestroyPhysicals(); virtual Int_tDistancetoPrimitive(Int_t, Int_t); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; voidTGLScene::DumpMapSizes() const; virtual voidEndScene(); voidTGLScene::EndSmartRefresh(); virtual voidTGLScene::EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t updateViewers = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t, Int_t, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLLogicalShape*TGLScene::FindLogical(TObject* logid) const; TGLLogicalShape*TGLScene::FindLogicalSmartRefresh(TObject* ID) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGLPhysicalShape*TGLScene::FindPhysical(UInt_t phid) const; Bool_tTGLSceneBase::GetAutoDestruct() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGLContextIdentity*TGLScene::GetGLCtxIdentity() const; virtual const char*TObject::GetIconName() const; virtual UInt_tTGLScene::GetMaxPhysicalID(); UInt_tTGLSceneBase::GetMinorStamp() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Get",MatchSource.WIKI,root/html602/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLScenePad.html
Deployability,update,updateViewers,"l Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGLScene::TSceneInfo*TGLScene::CreateSceneInfo(TGLViewerBase* view); TGLLockable::ELockTGLLockable::CurrentLock() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Bool_tTGLScene::DestroyLogical(TObject* logid, Bool_t mustFind = kTRUE); virtual Int_tTGLScene::DestroyLogicals(); virtual Bool_tTGLScene::DestroyPhysical(UInt_t phid); virtual Int_tTGLScene::DestroyPhysicals(); virtual Int_tDistancetoPrimitive(Int_t, Int_t); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; voidTGLScene::DumpMapSizes() const; virtual voidEndScene(); voidTGLScene::EndSmartRefresh(); virtual voidTGLScene::EndUpdate(Bool_t minorChange = kTRUE, Bool_t sceneChanged = kTRUE, Bool_t updateViewers = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t, Int_t, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLLogicalShape*TGLScene::FindLogical(TObject* logid) const; TGLLogicalShape*TGLScene::FindLogicalSmartRefresh(TObject* ID) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGLPhysicalShape*TGLScene::FindPhysical(UInt_t phid) const; Bool_tTGLSceneBase::GetAutoDestruct() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGLContextIdentity*TGLScene::GetGLCtxIdentity() const; virtual const char*TObject::GetIconName() const; virtual UInt_tTGLScene::GetMaxPhysicalID(); UInt_t",MatchSource.WIKI,root/html602/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLScenePad.html
Integrability,interface,interface,". TGLScenePad. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLScenePad. class TGLScenePad: public TVirtualViewer3D, public TGLScene. TGLScenePad. Implements VirtualViewer3D interface and fills the base-class; visualization structures from pad contents. Function Members (Methods); public:. virtual~TGLScenePad(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddCompositeOp(UInt_t operation); voidAddHistoPhysical(TGLLogicalShape* log, const Float_t* histColor = 0); virtual Int_tAddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual Int_tAddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren = 0); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidTGLScene::AdoptLogical(TGLLogicalShape& shape); virtual voidTGLScene::AdoptPhysical(TGLPhysicalShape& shape); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginScene(); UInt_tTGLScene::BeginSmartRefresh(); virtual Bool_tTGLScene::BeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual voidTGLScene::CalcBoundingBox() const; virtual Bool_tCanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); TGLClip*TGLSceneBase::Clip() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGLScene::TSceneInfo*TGLScene::CreateSceneInfo(TGLViewerBase* view); TGLLockable::ELockTGLLockable::CurrentLock() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Bool_tTGLScene::DestroyLogical(TObject* logid, Bool_t must",MatchSource.WIKI,root/html602/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLScenePad.html
Performance,cache,cache,"SceneBase::fDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); TGLContextIdentity*TGLScene::fGLCtxIdentity; Bool_tTGLScene::fInSmartRefresh!; Bool_tfInternalPIDs! using internal physical IDs; Short_tTGLSceneBase::fLODScene-lod.; Float_tTGLScene::fLastLineWidthScale; UInt_tfLastPID! last physical ID that was processed in AddObject(); Float_tTGLScene::fLastPointSizeScale; TGLLockable::ELockTGLLockable::fLockLock state.; TGLScene::LogicalShapeMap_tTGLScene::fLogicalShapes!; UInt_tTGLSceneBase::fMinorStampCounter increased on minimal update.; TStringTGLSceneBase::fNameObject identifier.; UInt_tfNextInternalPID! next internal physical ID (from 1 - 0 reserved); Float_tTGLSceneBase::fOLLineWScene outline line-width.; TVirtualPad*fPad; TGLScene::PhysicalShapeMap_tTGLScene::fPhysicalShapes!; UInt_tTGLSceneBase::fSceneIDUnique scene id.; Bool_tTGLSceneBase::fSelectableObjects in the scene are selectable.; Bool_tfSmartRefresh! cache logicals during scene rebuilds; TGLScene::LogicalShapeMap_tTGLScene::fSmartRefreshCache!; Short_tTGLSceneBase::fStyleScene-style.; UInt_tTGLSceneBase::fTimeStampCounter increased on every update.; TStringTGLSceneBase::fTitleObject title.; TGLSceneBase::ViewerList_tTGLSceneBase::fViewers; Float_tTGLSceneBase::fWFLineWScene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLScenePad(TVirtualPad* pad); Constructor. void AddHistoPhysical(TGLLogicalShape* log, const Float_t* histColor = 0); Scale and rotate a histo object to mimic placement in canvas. void SubPadPaint(TVirtualPad* pad); Iterate over pad-primitves and import them. void ObjectPaint(TObject* obj, Option_t* opt = """"); Override of virtual TVirtualViewer3D::ObjectPaint().; Special handling of 2D/3D histograms to activate Timur's; histo-painters. void PadPaintFromViewer(TGLViewer* viewer); Entry point for requesting update of scene's contents from; gl-viewer. void PadPaint(TVirtualPad* pad); Entry point for updatin",MatchSource.WIKI,root/html602/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLScenePad.html
Security,access,access,usBitsTObject::kCannotPick; static TGLLockable::ELockTGLLockable::kDrawLock; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TGLLockable::ELockTGLLockable::kModifyLock; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TGLLockable::ELockTGLLockable::kSelectLock; static TObject::(anonymous)TObject::kSingleKey; static TGLLockable::ELockTGLLockable::kUnlocked; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tfAcceptedPhysicals; Bool_tTGLSceneBase::fAutoDestruct; TGLBoundingBoxTGLSceneBase::fBoundingBoxbounding box for scene (axis aligned) - lazy update - use BoundingBox() to access; Bool_tTGLSceneBase::fBoundingBoxValidbounding box valid?; UInt_tfCSLevel; vector<TGLScenePad::CSPart_t>fCSTokens; TGLClip*TGLSceneBase::fClipScene clipping-plane.; TGLFaceSet*fComposite! Paritally created composite; Bool_tTGLSceneBase::fDoClipCheckPerform global clip-plane-check in UpdateSceneInfo(); Bool_tTGLSceneBase::fDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); TGLContextIdentity*TGLScene::fGLCtxIdentity; Bool_tTGLScene::fInSmartRefresh!; Bool_tfInternalPIDs! using internal physical IDs; Short_tTGLSceneBase::fLODScene-lod.; Float_tTGLScene::fLastLineWidthScale; UInt_tfLastPID! last physical ID that was processed in AddObject(); Float_tTGLScene::fLastPointSizeScale; TGLLockable::ELockTGLLockable::fLockLock state.; TGLScene::LogicalShapeMap_tTGLScene::fLogicalShapes!; UInt_tTGLSceneBase::fMinorStampCounter increased on minimal update.; TStringTGLSceneBase::fNameObject identifier.; UInt_tfNextInternalPID! next internal physical ID (from 1 - 0 reserved); ,MatchSource.WIKI,root/html602/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLScenePad.html
Testability,log,log," virtual~TGLScenePad(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddCompositeOp(UInt_t operation); voidAddHistoPhysical(TGLLogicalShape* log, const Float_t* histColor = 0); virtual Int_tAddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual Int_tAddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren = 0); voidTGLSceneBase::AddViewer(TGLViewerBase* viewer); virtual voidTGLScene::AdoptLogical(TGLLogicalShape& shape); virtual voidTGLScene::AdoptPhysical(TGLPhysicalShape& shape); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginScene(); UInt_tTGLScene::BeginSmartRefresh(); virtual Bool_tTGLScene::BeginUpdate(); const TGLBoundingBox&TGLSceneBase::BoundingBox() const; virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual voidTGLScene::CalcBoundingBox() const; virtual Bool_tCanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); TGLClip*TGLSceneBase::Clip() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGLScene::TSceneInfo*TGLScene::CreateSceneInfo(TGLViewerBase* view); TGLLockable::ELockTGLLockable::CurrentLock() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Bool_tTGLScene::DestroyLogical(TObject* logid, Bool_t must",MatchSource.WIKI,root/html602/TGLScenePad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLScenePad.html
Deployability,update,update,"Check() const; voidTGLSceneInfo::ViewCheck(Bool_t c); Float_tTGLSceneInfo::WFLineW() const. protected:. voidClearDrawElementPtrVec(TGLScene::DrawElementPtrVec_t& vec, Int_t maxSize); voidClearDrawElementVec(TGLScene::DrawElementVec_t& vec, Int_t maxSize). private:. Bool_tCmpDrawElements(const TGLScene::DrawElement_t& de1, const TGLScene::DrawElement_t& de2). Data Members; public:. Int_tfAsPixelCnt; map<TClass*,UInt_t>fByShapeCnt; UInt_tfMinorStamp; Int_tfOpaqueCnt; TGLScene::DrawElementPtrVec_tfOpaqueElements; TGLScene::DrawElementPtrVec_tfSelOpaqueElements; TGLScene::DrawElementPtrVec_tfSelTranspElements; TGLScene::ShapeVec_tfShapesOfInterest; Int_tfTranspCnt; TGLScene::DrawElementPtrVec_tfTranspElements; TGLScene::DrawElementVec_tfVisibleElements; static TGLSceneInfo::EClipTestTGLSceneInfo::kClipInside; static TGLSceneInfo::EClipTestTGLSceneInfo::kClipNone; static TGLSceneInfo::EClipTestTGLSceneInfo::kClipOutside. protected:. Bool_tTGLSceneInfo::fActiveShow fScene in fViewer; UInt_tTGLSceneInfo::fCameraStampCamera's time-stamp on last update.; TGLClip*TGLSceneInfo::fClipOptional override of clipping-plane; Char_tTGLSceneInfo::fClipModeClipping mode, can be disbled.; TGLPlaneSet_tTGLSceneInfo::fClipPlanesClipping planes from clip-object; which planes are kept depends on inside/outside mode.; UInt_tTGLSceneInfo::fClipStampClip's time-stamp on last update.; TGLPlaneSet_tTGLSceneInfo::fFrustumPlanesClipping planes defined by frustum; only those intersecting the scene volume are kept.; Bool_tTGLSceneInfo::fInClipIs scene contained within clipping-volume.; Bool_tTGLSceneInfo::fInFrustumIs scene intersecting view-frustum.; Short_tTGLSceneInfo::fLODOptional override of scene lod; TGLCamera*TGLSceneInfo::fLastCameraLast camera used.; TGLClip*TGLSceneInfo::fLastClipLast combined viewer/scene clip (set in scene::update); Short_tTGLSceneInfo::fLastLODLast combined viewer/scene lod (set in scene::lodify-scene-info).; Float_tTGLSceneInfo::fLastOLLineWLast combined viewer/scene o",MatchSource.WIKI,root/html602/TGLScene__TSceneInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLScene__TSceneInfo.html
Integrability,depend,depends,"xSize). private:. Bool_tCmpDrawElements(const TGLScene::DrawElement_t& de1, const TGLScene::DrawElement_t& de2). Data Members; public:. Int_tfAsPixelCnt; map<TClass*,UInt_t>fByShapeCnt; UInt_tfMinorStamp; Int_tfOpaqueCnt; TGLScene::DrawElementPtrVec_tfOpaqueElements; TGLScene::DrawElementPtrVec_tfSelOpaqueElements; TGLScene::DrawElementPtrVec_tfSelTranspElements; TGLScene::ShapeVec_tfShapesOfInterest; Int_tfTranspCnt; TGLScene::DrawElementPtrVec_tfTranspElements; TGLScene::DrawElementVec_tfVisibleElements; static TGLSceneInfo::EClipTestTGLSceneInfo::kClipInside; static TGLSceneInfo::EClipTestTGLSceneInfo::kClipNone; static TGLSceneInfo::EClipTestTGLSceneInfo::kClipOutside. protected:. Bool_tTGLSceneInfo::fActiveShow fScene in fViewer; UInt_tTGLSceneInfo::fCameraStampCamera's time-stamp on last update.; TGLClip*TGLSceneInfo::fClipOptional override of clipping-plane; Char_tTGLSceneInfo::fClipModeClipping mode, can be disbled.; TGLPlaneSet_tTGLSceneInfo::fClipPlanesClipping planes from clip-object; which planes are kept depends on inside/outside mode.; UInt_tTGLSceneInfo::fClipStampClip's time-stamp on last update.; TGLPlaneSet_tTGLSceneInfo::fFrustumPlanesClipping planes defined by frustum; only those intersecting the scene volume are kept.; Bool_tTGLSceneInfo::fInClipIs scene contained within clipping-volume.; Bool_tTGLSceneInfo::fInFrustumIs scene intersecting view-frustum.; Short_tTGLSceneInfo::fLODOptional override of scene lod; TGLCamera*TGLSceneInfo::fLastCameraLast camera used.; TGLClip*TGLSceneInfo::fLastClipLast combined viewer/scene clip (set in scene::update); Short_tTGLSceneInfo::fLastLODLast combined viewer/scene lod (set in scene::lodify-scene-info).; Float_tTGLSceneInfo::fLastOLLineWLast combined viewer/scene outline line-width (set in scene::pre-draw).; Short_tTGLSceneInfo::fLastStyleLast combined viewer/scene style (set in scene::pre-draw).; Float_tTGLSceneInfo::fLastWFLineWLast combined viewer/scene wire-frame line-width (set in scene::pre-draw).; Flo",MatchSource.WIKI,root/html602/TGLScene__TSceneInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLScene__TSceneInfo.html
Security,access,accessors,". TGLSelectionBuffer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLSelectionBuffer. class TGLSelectionBuffer. TGLVertex3. 3 component (x/y/z) vertex class. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. virtual~TGLSelectionBuffer(); static TClass*Class(); const UChar_t*GetPixelColor(Int_t px, Int_t py) const; virtual TClass*IsA() const; voidReadColorBuffer(Int_t width, Int_t height); voidReadColorBuffer(Int_t x, Int_t y, Int_t width, Int_t height); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLSelectionBuffer(). private:. TGLSelectionBuffer&operator=(const TGLSelectionBuffer&); TGLSelectionBuffer(const TGLSelectionBuffer&). Data Members; private:. vector<UChar_t>fBuffer; Int_tfHeight; Int_tfWidth. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLSelectionBuffer(); TGLSelectionBuffer constructor. ~TGLSelectionBuffer(); TGLSelectionBuffer destructor. void ReadColorBuffer(Int_t width, Int_t height); Read color buffer. void ReadColorBuffer(Int_t x, Int_t y, Int_t width, Int_t height); Read color buffer. const UChar_t * GetPixelColor(Int_t px, Int_t py) const; Get pixel color. TGLColor& operator=(const TGLSelectionBuffer& ). TGLSelectionBuffer(). » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:54; This pa",MatchSource.WIKI,root/html602/TGLSelectionBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSelectionBuffer.html
Usability,simpl,simple,". TGLSelectionBuffer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLSelectionBuffer. class TGLSelectionBuffer. TGLVertex3. 3 component (x/y/z) vertex class. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. virtual~TGLSelectionBuffer(); static TClass*Class(); const UChar_t*GetPixelColor(Int_t px, Int_t py) const; virtual TClass*IsA() const; voidReadColorBuffer(Int_t width, Int_t height); voidReadColorBuffer(Int_t x, Int_t y, Int_t width, Int_t height); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLSelectionBuffer(). private:. TGLSelectionBuffer&operator=(const TGLSelectionBuffer&); TGLSelectionBuffer(const TGLSelectionBuffer&). Data Members; private:. vector<UChar_t>fBuffer; Int_tfHeight; Int_tfWidth. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLSelectionBuffer(); TGLSelectionBuffer constructor. ~TGLSelectionBuffer(); TGLSelectionBuffer destructor. void ReadColorBuffer(Int_t width, Int_t height); Read color buffer. void ReadColorBuffer(Int_t x, Int_t y, Int_t width, Int_t height); Read color buffer. const UChar_t * GetPixelColor(Int_t px, Int_t py) const; Get pixel color. TGLColor& operator=(const TGLSelectionBuffer& ). TGLSelectionBuffer(). » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:54; This pa",MatchSource.WIKI,root/html602/TGLSelectionBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSelectionBuffer.html
Usability,simpl,simply,". TGLSelectRecord. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLSelectRecord. class TGLSelectRecord: public TGLSelectRecordBase. Standard selection record including information about containing; scene and details ob out selected object (TGLPhysicalShape*,; TObject* or simply a void* for foreign scenes). Function Members (Methods); public:. virtual~TGLSelectRecord(); static Bool_tAreSameSelectionWise(const TGLSelectRecord& r1, const TGLSelectRecord& r2); static TClass*Class(); UInt_tTGLSelectRecordBase::GetCurrItem() const; Bool_tGetHighlight() const; UInt_tTGLSelectRecordBase::GetItem(Int_t i) const; UInt_t*TGLSelectRecordBase::GetItems() const; TGLLogicalShape*GetLogShape() const; Float_tTGLSelectRecordBase::GetMaxZ() const; Float_tTGLSelectRecordBase::GetMinZ() const; Bool_tGetMultiple() const; Int_tTGLSelectRecordBase::GetN() const; Int_tTGLSelectRecordBase::GetNLeft() const; TObject*GetObject() const; TGLPhysicalShape*GetPhysShape() const; TGLSceneInfo*GetSceneInfo() const; TGLSelectRecord::ESecSelResultGetSecSelResult() const; void*GetSpecific() const; Bool_tGetTransparent() const; virtual TClass*IsA() const; voidTGLSelectRecordBase::NextPos(); TGLSelectRecord&operator=(const TGLSelectRecord& rec); voidTGLSelectRecordBase::PrevPos(); voidPrint(); virtual voidReset(); voidTGLSelectRecordBase::ResetPos(); virtual voidSet(UInt_t* data); voidSetHighlight(Bool_t hlt); voidSetLogShape(TGLLogicalShape* lshp); voidSetMultiple(Bool_t multi); voidSetObject(TObject* obj); voidSetPhysShape(TGLPhysicalShape* pshp); voidTGLSelectRecordBase::SetRawOnly(UInt_t* data); voidSetSceneInfo(TGLSceneInfo* si); voidSetSecSelResult(TGLSelectRecord::ESecSelResult r); voidSetSpecific(void* spec); voidSetTransparent(Bool_t t); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TB",MatchSource.WIKI,root/html602/TGLSelectRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSelectRecord.html
Performance,cache,cached,"); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tDLOffset(Short_t lod) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; TGLSphere&operator=(const TGLSphere&); TGLSphere&operator=(TGLSphere&&); virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tQuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesSupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TGLSphere(const TBuffer3DSphere& buffer); TGLSphere(const TGLSphere&); TGLSphere(TGLSphere&&); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html602/TGLSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSphere.html
Performance,perform,perform,". TGLStopwatch. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLStopwatch. class TGLStopwatch. TGLStopwatch. Stopwatch object for timing GL work. We do not use the TStopwatch as; we need to perform GL flushing to get accurate times + we record; timing overheads here. Function Members (Methods); public:. virtual~TGLStopwatch(); static TClass*Class(); Double_tEnd(); virtual TClass*IsA() const; Double_tLap() const; Double_tLastRun() const; TGLStopwatch&operator=(const TGLStopwatch&); virtual voidShowMembers(TMemberInspector& insp) const; voidStart(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLStopwatch(); TGLStopwatch(const TGLStopwatch&). private:. Double_tGetClock() const. Data Members; private:. Double_tfEnd! end time (millisec); Double_tfLastRun! time of last run (milisec); Double_tfStart! start time (millisec). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLStopwatch(); Construct stopwatch object. ~TGLStopwatch(); Destroy stopwatch object. void Start(); Start timing. Double_t Lap() const; Return lap time since Start(), in milliseconds. Double_t End(); End timing, return total time since Start(), in milliseconds. Double_t GetClock(void); Get internal clock time, in milliseconds. TGLStopwatch(). Double_t LastRun() const; { return fLastRun; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:54; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLStopwatch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLStopwatch.html
Modifiability,variab,variables,"atic TGLSurfacePainter::ESurfaceTypekSurf; static TGLSurfacePainter::ESurfaceTypekSurf1; static TGLSurfacePainter::ESurfaceTypekSurf2; static TGLSurfacePainter::ESurfaceTypekSurf3; static TGLSurfacePainter::ESurfaceTypekSurf4; static TGLSurfacePainter::ESurfaceTypekSurf5. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLSurfacePainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Constructor. char * GetPlotInfo(Int_t px, Int_t py); Coords for point on surface under cursor. Bool_t InitGeometry(); Set mesh, normals. void StartPan(Int_t px, Int_t py); User clicks right mouse button (in a pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. void AddOption(const TString& stringOption); Additional options for surfaces. void ProcessEvent(Int_t event, Int_t px, Int_t py); Remove all profiles/sections. void InitGL() const; Initialize some OpenGL state variables. void DeInitGL() const; Initialize some OpenGL state variables. void SetNormals(); One normal per vertex;; this normal is average of; neighbouring triangles normals. void SetSurfaceColor() const; Set color for surface. void DrawPlot() const; Draw surf/surf1/surf2/surf4. Bool_t InitGeometryCartesian(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometryPolar(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometryCylindrical(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometrySpherical(); Find bin ranges for X and Y axes,; axes ranges for ",MatchSource.WIKI,root/html602/TGLSurfacePainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSurfacePainter.html
Testability,log,logarithmic,"ctor. char * GetPlotInfo(Int_t px, Int_t py); Coords for point on surface under cursor. Bool_t InitGeometry(); Set mesh, normals. void StartPan(Int_t px, Int_t py); User clicks right mouse button (in a pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. void AddOption(const TString& stringOption); Additional options for surfaces. void ProcessEvent(Int_t event, Int_t px, Int_t py); Remove all profiles/sections. void InitGL() const; Initialize some OpenGL state variables. void DeInitGL() const; Initialize some OpenGL state variables. void SetNormals(); One normal per vertex;; this normal is average of; neighbouring triangles normals. void SetSurfaceColor() const; Set color for surface. void DrawPlot() const; Draw surf/surf1/surf2/surf4. Bool_t InitGeometryCartesian(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometryPolar(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometryCylindrical(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. Bool_t InitGeometrySpherical(); Find bin ranges for X and Y axes,; axes ranges for X, Y and Z.; Function returns false, if logarithmic scale for; some axis was requested, but we cannot; find correct range. void DrawProjections() const; Draw projections. void DrawSectionXOZ() const; Draw section X. void DrawSectionYOZ() const; Draw section Y. void DrawSectionXOY() const; Draw section Z. void ClampZ(Double_t& zVal) const; Clamp z value. char * WindowPointTo3DPoint(Int_t px, Int_t py) const; Find 3d coords using mouse cursor coords",MatchSource.WIKI,root/html602/TGLSurfacePainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLSurfacePainter.html
Integrability,interface,interface,". TGLText. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLText. class TGLText: public TAttText. GL Text; To draw a 3D text in a GL window. This class uses uses FTGL to render text.; FTGL is a package making the interface between the Free Type fonts and GL.; . Function Members (Methods); public:. virtual~TGLText(); voidBBox(const char* string, float& llx, float& lly, float& llz, float& urx, float& ury, float& urz); static TClass*Class(); voidTAttText::Copy(TAttText& atttext) const; FTFont*GetFont(); virtual Short_tTAttText::GetTextAlign() const; virtual Float_tTAttText::GetTextAngle() const; virtual Color_tTAttText::GetTextColor() const; virtual Font_tTAttText::GetTextFont() const; virtual Float_tTAttText::GetTextSize() const; virtual TClass*IsA() const; virtual voidTAttText::Modify(); voidPaintBBox(const char* text); voidPaintGLText(Double_t x, Double_t y, Double_t z, const char* text); virtual voidTAttText::ResetAttText(Option_t* toption = """"); virtual voidTAttText::SaveTextAttributes(ostream& out, const char* name, Int_t alidef = 12, Float_t angdef = 0, Int_t coldef = 1, Int_t fondef = 61, Float_t sizdef = 1); voidSetGLTextAngles(Double_t a1, Double_t a2, Double_t a3); voidSetGLTextFont(Font_t fontnumber); virtual voidTAttText::SetTextAlign(Short_t align = 11); virtual voidTAttText::SetTextAngle(Float_t tangle = 0)MENU ; virtual voidTAttText::SetTextAttributes()MENU ; virtual voidTAttText::SetTextColor(Color_t tcolor = 1); virtual voidTAttText::SetTextColorAlpha(Color_t tcolor, Float_t talpha); virtual voidTAttText::SetTextFont(Font_t tfont = 62); virtual voidTAttText::SetTextSize(Float_t tsize = 1); virtual voidTAttText::SetTextSizePixels(Int_t npixels); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_St",MatchSource.WIKI,root/html602/TGLText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLText.html
Modifiability,variab,variables,":ETF3StylefStyle; TGLTH3SlicefXOYSlice; TGLTH3SlicefXOZSlice; TGLTH3SlicefYOZSlice; static TGLTF3Painter::ETF3StylekDefault; static TGLTF3Painter::ETF3StylekMaple0; static TGLTF3Painter::ETF3StylekMaple1; static TGLTF3Painter::ETF3StylekMaple2. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLTF3Painter(TF3* fun, TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Constructor. char * GetPlotInfo(Int_t px, Int_t py); Coords for point on surface under cursor. Bool_t InitGeometry(); Create mesh. void StartPan(Int_t px, Int_t py); User clicks right mouse button (in a pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement.; Slicing is disabled (since somebody has broken it). void AddOption(const TString& stringOption); No options for tf3. void ProcessEvent(Int_t event, Int_t px, Int_t py); Change color sheme. void InitGL() const; Initialize OpenGL state variables. void DeInitGL() const; Initialize OpenGL state variables. void DrawToSelectionBuffer() const; Draw triangles, no normals, no lighting. void DrawDefaultPlot() const; Surface with material properties and lighting. void DrawMaplePlot() const; Colored surface, without lighting and; material properties. void DrawPlot() const; Draw mesh. void SetSurfaceColor() const; Set color for surface. Bool_t HasSections() const; Any section exists. void DrawSectionXOZ() const; Draw XOZ parallel section. void DrawSectionYOZ() const; Draw YOZ parallel section. void DrawSectionXOY() const; Draw XOY parallel section. TGLTF3Painter(TF3* fun, TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord). » Author: Timur Pocheptsov 31/08/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:54; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general",MatchSource.WIKI,root/html602/TGLTF3Painter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLTF3Painter.html
Availability,error,error,"tory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char* name_postfix = ""_copy"") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTH1::ExtendAxis(Double_t x, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, Double_t y, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, Double_t y, const char* namez, Double_t w); virtual voidTNamed::Fill",MatchSource.WIKI,root/html602/TGLTH3Composition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLTH3Composition.html
Modifiability,extend,extendBitMask,"nt_t biny, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBinErrorOption(TH1::EBinErrorOpt type); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidTH3C::SetBinsLength(Int_t n = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual UInt_tTH1::SetCanExtend(UInt_t extendBitMask); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis",MatchSource.WIKI,root/html602/TGLTH3Composition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLTH3Composition.html
Modifiability,variab,variables,"lectedPart; TGLSelectionBufferTGLPlotPainter::fSelection; Int_tTGLPlotPainter::fSelectionBase; Bool_tTGLPlotPainter::fSelectionPass; Bool_tTGLPlotPainter::fUpdateSelection; TAxis*TGLPlotPainter::fXAxis; Double_tTGLPlotPainter::fXOYSectionPos; Double_tTGLPlotPainter::fXOZSectionPos; TAxis*TGLPlotPainter::fYAxis; Double_tTGLPlotPainter::fYOZSectionPos; TAxis*TGLPlotPainter::fZAxis; vector<Double_t>TGLPlotPainter::fZLevels; static TGLPlotPainter::ESelectionBaseTGLPlotPainter::kHighColorSelectionBase; static TGLPlotPainter::ESelectionBaseTGLPlotPainter::kTrueColorSelectionBase. private:. TGLTH3Composition*fData; pair<Double_t,Double_t>fMinMaxVal; TGLQuadricfQuadric. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLTH3CompositionPainter(TGLTH3Composition* data, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Ctor. char * GetPlotInfo(Int_t px, Int_t py); Will be never called from TPad. Bool_t InitGeometry(). void StartPan(Int_t px, Int_t py); Move plot or box cut. void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. void AddOption(const TString& option); No options for composition. void ProcessEvent(Int_t event, Int_t px, Int_t py); Switch on/off box cut. void InitGL() const; Initialize some gl state variables. void DeInitGL() const; Return back some gl state variables. void DrawPlot() const; Draw composition of TH3s. void SetColor(Int_t color) const; Set material. TGLTH3CompositionPainter(TGLTH3Composition* data, TGLPlotCamera* camera, TGLPlotCoordinates* coord); TGLPlotPainter final-overriders. void DrawSectionXOZ() const; Empty overriders. {}. void DrawSectionYOZ() const; {}. void DrawSectionXOY() const; {}. » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:54; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLTH3CompositionPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLTH3CompositionPainter.html
Availability,error,error," virtual~TGLTH3Slice(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawSlice(Double_t pos) const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjec",MatchSource.WIKI,root/html602/TGLTH3Slice.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLTH3Slice.html
Energy Efficiency,green,green,". TGLTransManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLTransManip. class TGLTransManip: public TGLManip. TGLTransManip. Translation manipulator - attaches to physical shape and draws local; axes widgets with arrow heads. User can mouse over (turns yellow) and; L click/drag to translate along this axis.; Widgets use standard 3D package axes colours: X red, Y green, Z blue. Function Members (Methods); public:. virtual~TGLTransManip(); voidTGLManip::Attach(TGLPhysicalShape* shape); static TClass*Class(); virtual voidDraw(const TGLCamera& camera) const; Bool_tTGLManip::GetActive() const; TGLPhysicalShape*TGLManip::GetAttached() const; UInt_tTGLManip::GetSelectedWidget() const; virtual Bool_tTGLManip::HandleButton(const Event_t& event, const TGLCamera& camera); virtual Bool_tHandleMotion(const Event_t& event, const TGLCamera& camera); virtual TClass*IsA() const; TGLTransManip&operator=(const TGLTransManip&); virtual Bool_tTGLManip::Select(const TGLCamera&, const TGLRect&, const TGLBoundingBox&); voidTGLManip::SetActive(Bool_t a); voidTGLManip::SetSelectedWidget(UInt_t s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLTransManip(); TGLTransManip(TGLPhysicalShape* shape); TGLTransManip(const TGLTransManip&). protected:. voidTGLManip::CalcDrawScale(const TGLBoundingBox& box, const TGLCamera& camera, Double_t& base, TGLVector3[3] axis) const; const UChar_t*TGLManip::ColorFor(UInt_t widget) const. Data Members; protected:. Bool_tTGLManip::fActive! manipulator is active?; TPointTGLManip::fFirstMouse! first (start) mouse position (in WINDOW coords); TPointTGLManip::fLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tTGLManip::fSelectedWidget! active width (axis) compone",MatchSource.WIKI,root/html602/TGLTransManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLTransManip.html
Availability,error,error,". TGLUtil. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLUtil. class TGLUtil. Wrapper class for various misc static functions - error checking,; draw helpers etc. Function Members (Methods); public:. virtual~TGLUtil(); static voidBeginAttLine(const TAttLine& aline, Char_t transp, Int_t pick_radius = 0, Bool_t selection = kFALSE); static voidBeginExtendPickRegion(Float_t scale); static Int_tCheckError(const char* loc); static TClass*Class(); static voidColor(const TGLColor& color); static voidColor3f(Float_t r, Float_t g, Float_t b); static voidColor3fv(const Float_t* rgb); static voidColor3ub(UChar_t r, UChar_t g, UChar_t b); static voidColor3ubv(const UChar_t* rgb); static voidColor4f(Float_t r, Float_t g, Float_t b, Float_t a); static voidColor4fv(const Float_t* rgba); static voidColor4ub(UChar_t r, UChar_t g, UChar_t b, UChar_t a); static voidColor4ubv(const UChar_t* rgba); static voidColorAlpha(const TGLColor& color, UChar_t alpha); static voidColorAlpha(const TGLColor& color, Float_t alpha); static voidColorAlpha(Color_t color_index, Float_t alpha = 1); static voidColorTransparency(Color_t color_index, Char_t transparency = 0); static voidDrawLine(const TGLLine3& line, TGLUtil::ELineHeadShape head, Double_t size, const UChar_t[4] rgba); static voidDrawLine(const TGLVertex3& start, const TGLVector3& vector, TGLUtil::ELineHeadShape head, Double_t size, const UChar_t[4] rgba); static voidDrawNumber(const TString& num, const TGLVertex3& pos, Bool_t center = kFALSE); static voidDrawReferenceMarker(const TGLCamera& camera, const TGLVertex3& pos, Float_t radius = 3, const UChar_t* rgba = 0); static voidDrawRing(const TGLVertex3& center, const TGLVector3& normal, Double_t radius, const UChar_t* rgba); static voidDrawSimpleAxes(const TGLCamera& camera, const TGLBoundingBox& bbox, Int_t ",MatchSource.WIKI,root/html602/TGLUtil.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLUtil.html
Integrability,rout,routines,".; Color is never changed. void RenderPoints(const TAttMarker& marker, const vector<Double_t>& points); Render markers as circular or square points.; Color is never changed. void RenderCrosses(const TAttMarker& marker, Float_t* p, Int_t n, Bool_t sec_selection = kFALSE); Render markers as crosses.; Color is never changed. void RenderCrosses(const TAttMarker& marker, const vector<Double_t>& points, Double_t dX, Double_t dY, Double_t dZ); Render markers as crosses.; Color is never changed. void RenderPolyLine(const TAttLine& aline, Char_t transp, Float_t* p, Int_t n, Int_t pick_radius = 0, Bool_t selection = kFALSE); Render poly-line as specified by the p-array. void BeginAttLine(const TAttLine& aline, Char_t transp, Int_t pick_radius = 0, Bool_t selection = kFALSE); Setup drawing parrameters according to passed TAttLine. void EndAttLine(Int_t pick_radius = 0, Bool_t selection = kFALSE); Restore previous line drawing state. void SetDrawColors(const UChar_t[4] rgba); Set basic draw colors from 4 component 'rgba'; Used by other TGLUtil drawing routines. Sets basic (unlit) color - glColor; and also GL materials (see OpenGL docs) thus:. diffuse : rgba; ambient : 0.0 0.0 0.0 1.0; specular : 0.6 0.6 0.6 1.0; emission : rgba/4.0; shininess: 60.0. emission is set so objects with no lights (but lighting still enabled); are partially visible. void DrawSphere(const TGLVertex3& position, Double_t radius, const UChar_t[4] rgba); Draw sphere, centered on vertex 'position', with radius 'radius',; color 'rgba'. void DrawLine(const TGLLine3& line, TGLUtil::ELineHeadShape head, Double_t size, const UChar_t[4] rgba); Draw thick line (tube) defined by 'line', with head at end shape; 'head' - box/arrow/none, (head) size 'size', color 'rgba'. void DrawLine(const TGLVertex3& start, const TGLVector3& vector, TGLUtil::ELineHeadShape head, Double_t size, const UChar_t[4] rgba); Draw thick line (tube) running from 'start', length 'vector',; with head at end of shape 'head' - box/arrow/none,; (h",MatchSource.WIKI,root/html602/TGLUtil.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLUtil.html
Performance,cache,cached,"default 0). void Color3ub(UChar_t r, UChar_t g, UChar_t b); Wrapper for glColor3ub. void Color4ub(UChar_t r, UChar_t g, UChar_t b, UChar_t a); Wrapper for glColor4ub. void Color3ubv(const UChar_t* rgb); Wrapper for glColor3ubv. void Color4ubv(const UChar_t* rgba); Wrapper for glColor4ubv. void Color3f(Float_t r, Float_t g, Float_t b); Wrapper for glColor3f. void Color4f(Float_t r, Float_t g, Float_t b, Float_t a); Wrapper for glColor4f. void Color3fv(const Float_t* rgb); Wrapper for glColor3fv. void Color4fv(const Float_t* rgba); Wrapper for glColor4fv. void PointToViewport(Int_t& x, Int_t& y); Convert from point/screen coordinates to GL viewport coordinates. void PointToViewport(Int_t& x, Int_t& y, Int_t& w, Int_t& h); Convert from point/screen coordinates to GL viewport coordinates. Float_t GetScreenScalingFactor(); Returns scaling factor between screen points and GL viewport pixels.; This is what is returned by gVirtualX->GetOpenGLScalingFactor() but is; cached here to avoid a virtual function call as it is used quite often in; TGLPhysical shape when drawing the selection highlight. Float_t GetPointLineScalingFactor(); Return extra scaling factor for points and lines.; By default this is set to the same value as ScreenScalingFactor to keep; the same appearance. To override use rootrc entry, e.g.:; OpenGL.PointLineScalingFactor: 1.0. Int_t GetPickingRadius(); Returns picking radius. Float_t GetPointSizeScale(); Get global point-size scale. void SetPointSizeScale(Float_t scale); Set global point-size scale. Float_t GetLineWidthScale(); Returns global line-width scale. void SetLineWidthScale(Float_t scale); Set global line-width scale. void PointSize(Float_t point_size); Set the point-size, taking the global scaling into account.; Wrapper for glPointSize. void LineWidth(Float_t line_width); Set the line-width, taking the global scaling into account.; Wrapper for glLineWidth. Float_t PointSize(); Get the point-size, taking the global scaling into account. Float_t Lin",MatchSource.WIKI,root/html602/TGLUtil.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLUtil.html
Safety,avoid,avoid,"default 0). void Color3ub(UChar_t r, UChar_t g, UChar_t b); Wrapper for glColor3ub. void Color4ub(UChar_t r, UChar_t g, UChar_t b, UChar_t a); Wrapper for glColor4ub. void Color3ubv(const UChar_t* rgb); Wrapper for glColor3ubv. void Color4ubv(const UChar_t* rgba); Wrapper for glColor4ubv. void Color3f(Float_t r, Float_t g, Float_t b); Wrapper for glColor3f. void Color4f(Float_t r, Float_t g, Float_t b, Float_t a); Wrapper for glColor4f. void Color3fv(const Float_t* rgb); Wrapper for glColor3fv. void Color4fv(const Float_t* rgba); Wrapper for glColor4fv. void PointToViewport(Int_t& x, Int_t& y); Convert from point/screen coordinates to GL viewport coordinates. void PointToViewport(Int_t& x, Int_t& y, Int_t& w, Int_t& h); Convert from point/screen coordinates to GL viewport coordinates. Float_t GetScreenScalingFactor(); Returns scaling factor between screen points and GL viewport pixels.; This is what is returned by gVirtualX->GetOpenGLScalingFactor() but is; cached here to avoid a virtual function call as it is used quite often in; TGLPhysical shape when drawing the selection highlight. Float_t GetPointLineScalingFactor(); Return extra scaling factor for points and lines.; By default this is set to the same value as ScreenScalingFactor to keep; the same appearance. To override use rootrc entry, e.g.:; OpenGL.PointLineScalingFactor: 1.0. Int_t GetPickingRadius(); Returns picking radius. Float_t GetPointSizeScale(); Get global point-size scale. void SetPointSizeScale(Float_t scale); Set global point-size scale. Float_t GetLineWidthScale(); Returns global line-width scale. void SetLineWidthScale(Float_t scale); Set global line-width scale. void PointSize(Float_t point_size); Set the point-size, taking the global scaling into account.; Wrapper for glPointSize. void LineWidth(Float_t line_width); Set the line-width, taking the global scaling into account.; Wrapper for glLineWidth. Float_t PointSize(); Get the point-size, taking the global scaling into account. Float_t Lin",MatchSource.WIKI,root/html602/TGLUtil.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLUtil.html
Usability,simpl,simple,"s with no lights (but lighting still enabled); are partially visible. void DrawSphere(const TGLVertex3& position, Double_t radius, const UChar_t[4] rgba); Draw sphere, centered on vertex 'position', with radius 'radius',; color 'rgba'. void DrawLine(const TGLLine3& line, TGLUtil::ELineHeadShape head, Double_t size, const UChar_t[4] rgba); Draw thick line (tube) defined by 'line', with head at end shape; 'head' - box/arrow/none, (head) size 'size', color 'rgba'. void DrawLine(const TGLVertex3& start, const TGLVector3& vector, TGLUtil::ELineHeadShape head, Double_t size, const UChar_t[4] rgba); Draw thick line (tube) running from 'start', length 'vector',; with head at end of shape 'head' - box/arrow/none,; (head) size 'size', color 'rgba'. void DrawRing(const TGLVertex3& center, const TGLVector3& normal, Double_t radius, const UChar_t* rgba); Draw ring, centered on 'center', lying on plane defined by 'center' & 'normal'; of outer radius 'radius', color 'rgba'. void DrawReferenceMarker(const TGLCamera& camera, const TGLVertex3& pos, Float_t radius = 3, const UChar_t* rgba = 0); Draw a sphere- marker on world-coordinate 'pos' with pixel; radius 'radius'. Color argument is optional. void DrawSimpleAxes(const TGLCamera& camera, const TGLBoundingBox& bbox, Int_t axesType); Draw simple xyz-axes for given bounding-box. void DrawNumber(const TString& num, const TGLVertex3& pos, Bool_t center = kFALSE); Draw number in string 'num' via internal 8x8-pixel bitmap on; vertex 'pos'. If 'center' is true, the number is centered on 'pos'.; Only numbers, '.', '-' and ' ' are supported. TGLColor& operator=(const TGLUtil& ). TGLUtil(const TGLUtil& ). virtual ~TGLUtil(); {}. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:54; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLUtil.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLUtil.html
Security,access,accessors,". TGLUtil::TColorLocker. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLUtil::TColorLocker. class TGLUtil::TColorLocker. TGLVertex3. 3 component (x/y/z) vertex class. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. virtual~TColorLocker(); static TClass*Class(); virtual TClass*IsA() const; TGLUtil::TColorLocker&operator=(const TGLUtil::TColorLocker&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLUtil::TColorLockerTColorLocker(); TGLUtil::TColorLockerTColorLocker(const TGLUtil::TColorLocker&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLColor& operator=(const TGLUtil::TColorLocker& ). TColorLocker(); { LockColor(); }. virtual ~TColorLocker(); { UnlockColor(); }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:54; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLUtil__TColorLocker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLUtil__TColorLocker.html
Usability,simpl,simple,". TGLUtil::TColorLocker. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLUtil::TColorLocker. class TGLUtil::TColorLocker. TGLVertex3. 3 component (x/y/z) vertex class. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. virtual~TColorLocker(); static TClass*Class(); virtual TClass*IsA() const; TGLUtil::TColorLocker&operator=(const TGLUtil::TColorLocker&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLUtil::TColorLockerTColorLocker(); TGLUtil::TColorLockerTColorLocker(const TGLUtil::TColorLocker&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLColor& operator=(const TGLUtil::TColorLocker& ). TColorLocker(); { LockColor(); }. virtual ~TColorLocker(); { UnlockColor(); }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:54; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLUtil__TColorLocker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLUtil__TColorLocker.html
Security,access,accessors,". TGLUtil::TDrawQualityModifier. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLUtil::TDrawQualityModifier. class TGLUtil::TDrawQualityModifier. TGLVertex3. 3 component (x/y/z) vertex class. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. virtual~TDrawQualityModifier(); static TClass*Class(); virtual TClass*IsA() const; TGLUtil::TDrawQualityModifier&operator=(const TGLUtil::TDrawQualityModifier&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLUtil::TDrawQualityModifierTDrawQualityModifier(Int_t dq); TGLUtil::TDrawQualityModifierTDrawQualityModifier(const TGLUtil::TDrawQualityModifier&). Data Members; private:. Int_tfOldQuality. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLColor& operator=(const TGLUtil::TDrawQualityModifier& ). TDrawQualityModifier(Int_t dq); {SetDrawQuality(dq); }. virtual ~TDrawQualityModifier(); { SetDrawQuality(fOldQuality); }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:54; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLUtil__TDrawQualityModifier.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLUtil__TDrawQualityModifier.html
Usability,simpl,simple,". TGLUtil::TDrawQualityModifier. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLUtil::TDrawQualityModifier. class TGLUtil::TDrawQualityModifier. TGLVertex3. 3 component (x/y/z) vertex class. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. virtual~TDrawQualityModifier(); static TClass*Class(); virtual TClass*IsA() const; TGLUtil::TDrawQualityModifier&operator=(const TGLUtil::TDrawQualityModifier&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLUtil::TDrawQualityModifierTDrawQualityModifier(Int_t dq); TGLUtil::TDrawQualityModifierTDrawQualityModifier(const TGLUtil::TDrawQualityModifier&). Data Members; private:. Int_tfOldQuality. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLColor& operator=(const TGLUtil::TDrawQualityModifier& ). TDrawQualityModifier(Int_t dq); {SetDrawQuality(dq); }. virtual ~TDrawQualityModifier(); { SetDrawQuality(fOldQuality); }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:54; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLUtil__TDrawQualityModifier.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLUtil__TDrawQualityModifier.html
Security,access,accessors,". TGLUtil::TDrawQualityScaler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLUtil::TDrawQualityScaler. class TGLUtil::TDrawQualityScaler. TGLVertex3. 3 component (x/y/z) vertex class. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. virtual~TDrawQualityScaler(); static TClass*Class(); virtual TClass*IsA() const; TGLUtil::TDrawQualityScaler&operator=(const TGLUtil::TDrawQualityScaler&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLUtil::TDrawQualityScalerTDrawQualityScaler(Float_t fac); TGLUtil::TDrawQualityScalerTDrawQualityScaler(const TGLUtil::TDrawQualityScaler&). Data Members; private:. Int_tfOldQuality. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLColor& operator=(const TGLUtil::TDrawQualityScaler& ). TDrawQualityScaler(Float_t fac); {SetDrawQuality((Int_t)(fac*fOldQuality)); }. virtual ~TDrawQualityScaler(); { SetDrawQuality(fOldQuality); }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:54; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLUtil__TDrawQualityScaler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLUtil__TDrawQualityScaler.html
Usability,simpl,simple,". TGLUtil::TDrawQualityScaler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLUtil::TDrawQualityScaler. class TGLUtil::TDrawQualityScaler. TGLVertex3. 3 component (x/y/z) vertex class. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. virtual~TDrawQualityScaler(); static TClass*Class(); virtual TClass*IsA() const; TGLUtil::TDrawQualityScaler&operator=(const TGLUtil::TDrawQualityScaler&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLUtil::TDrawQualityScalerTDrawQualityScaler(Float_t fac); TGLUtil::TDrawQualityScalerTDrawQualityScaler(const TGLUtil::TDrawQualityScaler&). Data Members; private:. Int_tfOldQuality. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLColor& operator=(const TGLUtil::TDrawQualityScaler& ). TDrawQualityScaler(Float_t fac); {SetDrawQuality((Int_t)(fac*fOldQuality)); }. virtual ~TDrawQualityScaler(); { SetDrawQuality(fOldQuality); }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:54; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLUtil__TDrawQualityScaler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLUtil__TDrawQualityScaler.html
Availability,error,error,"e_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTGContainer::End(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGContainer::FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*TGContainer::FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*TGContainer::FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGCanvas*TGContainer::GetCanvas() const; TGClient*TGObject::Get",MatchSource.WIKI,root/html602/TGLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLVContainer.html
Integrability,message,messages,lement*TGContainer::fLastActiveEllast active item; Bool_tTGContainer::fLastCasecase sensetivity of last search; Bool_tTGContainer::fLastDirdirection of last search; TStringTGContainer::fLastNamethe name of object of last search; Bool_tTGContainer::fLastSubstringsubstring search option of last search; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGListView*fListViewlistview which contains this container; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGContainer::fMsgWindowwindow handling container messages; Bool_tfMultiSelecttrue = multiple file selection; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; Bool_tTGContainer::fOnMouseOverkTRUE when mouse pointer is over entry; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TTimer*TGContainer::fScrollTimerautoscroll timer; Bool_tTGContainer::fScrollingkTRUE - when scrolling is ON; Int_tTGContainer::fSelectednumber of selected items; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTGContainer::fTotaltotal items; EListViewModefViewModelist view viewing mode; TGViewPort*TGContainer::fViewPortcontainer viewport; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGContainer::fX0corner of rubber band box; Int_tTGContainer::fXDND; Int_tTGContainer::fXfother corner of rubber band box; Int_tTGContainer::fXpprevi,MatchSource.WIKI,root/html602/TGLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLVContainer.html
Security,access,accessors,". TGLVector3. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLVector3. class TGLVector3: public TGLVertex3. TGLVector3. 3 component (x/y/z) vector class. This is part of collection of utility classes for GL in TGLUtil.h/cxx; These provide const and non-const accessors Arr() / CArr() to a GL; compatible internal field - so can be used directly with OpenGL C API; calls. They are not intended to be fully featured just provide; minimum required. Function Members (Methods); public:. virtual~TGLVector3(); Double_t*TGLVertex3::Arr(); const Double_t*TGLVertex3::CArr() const; static TClass*Class(); voidTGLVertex3::Dump() const; voidTGLVertex3::Fill(Double_t val); virtual TClass*IsA() const; Double_tMag() const; voidTGLVertex3::Maximum(const TGLVertex3& other); voidTGLVertex3::Minimum(const TGLVertex3& other); voidTGLVertex3::Negate(); voidNormalise(); TGLVertex3&TGLVertex3::operator*=(Double_t f); const TGLVertex3&TGLVertex3::operator+=(const TGLVector3& val); TGLVector3operator-() const; const TGLVertex3&TGLVertex3::operator-=(const TGLVector3& val); TGLVector3&operator/=(Double_t val); TGLVector3&operator=(const TGLVertex3& v); TGLVector3&operator=(const TGLVector3&); Bool_tTGLVertex3::operator==(const TGLVertex3& rhs) const; Double_t&TGLVertex3::operator[](Int_t index); const Double_t&TGLVertex3::operator[](Int_t index) const; voidTGLVertex3::Set(const Double_t* xyz); voidTGLVertex3::Set(const TGLVertex3& other); voidTGLVertex3::Set(Double_t x, Double_t y, Double_t z); voidTGLVertex3::Shift(TGLVector3& shift); voidTGLVertex3::Shift(Double_t xDelta, Double_t yDelta, Double_t zDelta); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLVector3(); TGLVector3(const Double_t* src); TGLVector3(const ",MatchSource.WIKI,root/html602/TGLVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLVector3.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObjec",MatchSource.WIKI,root/html602/TGLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLVEntry.html
Security,access,accessors,". TGLVertex3. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLVertex3. class TGLVertex3. TGLVertex3. 3 component (x/y/z) vertex class. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. virtual~TGLVertex3(); Double_t*Arr(); const Double_t*CArr() const; static TClass*Class(); voidDump() const; voidFill(Double_t val); virtual TClass*IsA() const; voidMaximum(const TGLVertex3& other); voidMinimum(const TGLVertex3& other); voidNegate(); TGLVertex3&operator*=(Double_t f); const TGLVertex3&operator+=(const TGLVector3& val); TGLVertex3operator-() const; const TGLVertex3&operator-=(const TGLVector3& val); TGLVertex3&operator=(const TGLVertex3& rhs); Bool_toperator==(const TGLVertex3& rhs) const; Double_t&operator[](Int_t index); const Double_t&operator[](Int_t index) const; voidSet(const Double_t* xyz); voidSet(const TGLVertex3& other); voidSet(Double_t x, Double_t y, Double_t z); voidShift(TGLVector3& shift); voidShift(Double_t xDelta, Double_t yDelta, Double_t zDelta); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLVertex3(); TGLVertex3(Double_t* v); TGLVertex3(const TGLVertex3& other); TGLVertex3(Double_t x, Double_t y, Double_t z); Double_tX() const; Double_t&X(); Double_tY() const; Double_t&Y(); Double_tZ() const; Double_t&Z(). protected:. Bool_tValidIndex(UInt_t index) const. Data Members; protected:. Double_tfVals[3]. Class Charts. Inheritance; Inherited Members;",MatchSource.WIKI,root/html602/TGLVertex3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLVertex3.html
Usability,simpl,simple,". TGLVertex3. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLVertex3. class TGLVertex3. TGLVertex3. 3 component (x/y/z) vertex class. This is part of collection of simple utility classes for GL only in; TGLUtil.h/cxx. These provide const and non-const accessors Arr() &; CArr() to a GL compatible internal field - so can be used directly; with OpenGL C API calls - which TVector3 etc cannot (easily).; They are not intended to be fully featured just provide minimum; required. Function Members (Methods); public:. virtual~TGLVertex3(); Double_t*Arr(); const Double_t*CArr() const; static TClass*Class(); voidDump() const; voidFill(Double_t val); virtual TClass*IsA() const; voidMaximum(const TGLVertex3& other); voidMinimum(const TGLVertex3& other); voidNegate(); TGLVertex3&operator*=(Double_t f); const TGLVertex3&operator+=(const TGLVector3& val); TGLVertex3operator-() const; const TGLVertex3&operator-=(const TGLVector3& val); TGLVertex3&operator=(const TGLVertex3& rhs); Bool_toperator==(const TGLVertex3& rhs) const; Double_t&operator[](Int_t index); const Double_t&operator[](Int_t index) const; voidSet(const Double_t* xyz); voidSet(const TGLVertex3& other); voidSet(Double_t x, Double_t y, Double_t z); voidShift(TGLVector3& shift); voidShift(Double_t xDelta, Double_t yDelta, Double_t zDelta); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLVertex3(); TGLVertex3(Double_t* v); TGLVertex3(const TGLVertex3& other); TGLVertex3(Double_t x, Double_t y, Double_t z); Double_tX() const; Double_t&X(); Double_tY() const; Double_t&Y(); Double_tZ() const; Double_t&Z(). protected:. Bool_tValidIndex(UInt_t index) const. Data Members; protected:. Double_tfVals[3]. Class Charts. Inheritance; Inherited Members;",MatchSource.WIKI,root/html602/TGLVertex3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLVertex3.html
Availability,error,error,"Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Bool_tTGLViewerBase::FindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); TGLLogicalShape*TGLViewerBase::FindLogicalInScenes(TObject* id); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGLAutoRotator*GetAutoRotator(); TGLCameraOverlay*GetCameraOverlay() const; Bool_tGetClipAutoUpdate() const; TGLClipSet*GetClipSet() const; TGLOverlayElement*GetCurrentOvlElm() const; static TGLColorSet&GetDefaultColorSet(); Int_tGetDev() const; TGLViewer::EDragActionGetDragAction() const; Bool_tGetDrawCameraCenter(); virtual Option_t*T",MatchSource.WIKI,root/html602/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLViewer.html
Deployability,update,update,"LLockable::kSelectLock; static TObject::(anonymous)TObject::kSingleKey; static TGLLockable::ELockTGLLockable::kUnlocked; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TGLAutoRotator*fAutoRotator!; Bool_tfAxesDepthTest! remove guides hidden-lines; Int_tfAxesType! axes type; TGLCamera*TGLViewerBase::fCameraCamera for rendering.; TGLCameraOverlay*fCameraOverlay! markup size of viewport in scene units; Bool_tTGLViewerBase::fChangedChange requiring redraw is pending.; TGLClip*TGLViewerBase::fClipViewer clipping-plane.; TGLClipSet*fClipSet!; TContextMenu*fContextMenu!; TGLCamera*fCurrentCamera!; TGLOverlayElement*fCurrentOvlElm! current overlay element; TGLSelectRecordfCurrentSelRec! select record in use as selected; TGLColorSetfDarkColorSet! color-set with dark background; Bool_tfDebugMode! debug mode (forced rebuild + draw scene/frustum/interest boxes); TGLViewer::EDragActionfDragAction; Bool_tfDrawCameraCenter! reference marker on?; TGEventHandler*fEventHandler! event handler; Float_tfFader! fade the view (0 - no fade/default, 1 - full fade/no rendering done); TGLContextIdentity*fGLCtxId!for embedded gl viewer; Int_tfGLDevice!for embedded gl viewer; TGLWidget*fGLWidget; TGedEditor*fGedEditor! GED editor; Bool_tfIgnoreSizesOnUpdateignore sizes of bounding-boxes on update; Bool_tfIsPrinting!; Short_tTGLViewerBase::fLODViewer-lod for rendering.; TGLColorSetfLightColorSet! color-set with light background; TGLLightSet*fLightSet!; Float_tfLineScale! width scale for lines; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGLLockable::ELockTGLLockable::fLockLock state.; Float_tfMaxSceneDrawTimeHQ! max time for scene rendering at high LOD (in ms); Float_tfMaxSceneDrawTimeLQ! max time for scene rendering at high LOD (in ms); Float_tTGLViewerBase::fOLLineWOptional override of scene outline line-width; TGLOrthoCamerafOrthoXOYCamera!;",MatchSource.WIKI,root/html602/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLViewer.html
Integrability,interface,interface,"ewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetfgDefaultColorSet! a shared, default color-set; static Bool_tfgUseDefaultColorSetForNewViewers! name says it all. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLViewer(TVirtualPad* pad, Int_t x, Int_t y, Int_t width, Int_t height); Construct the viewer object, with following arguments:; 'pad' - external pad viewer is bound to; 'x', 'y' - initial top left position; 'width', 'height' - initial width/height. TGLViewer(TVirtualPad* pad); gl-embedded viewer's ctor; Construct the viewer object, with following arguments:; 'pad' - external pad viewer is bound to; 'x', 'y' - initial top left position; 'width', 'height' - initial width/height. void InitSecondaryObjects(); Common initialization. ~TGLViewer(); Destroy viewer object. void PadPaint(TVirtualPad* pad); Entry point for updating viewer contents via VirtualViewer3D; interface.; We search and forward the request to appropriate TGLScenePad.; If it is not found we create a new TGLScenePad so this can; potentially also be used for registration of new pads. void UpdateScene(Bool_t redraw = kTRUE); Force update of pad-scenes. Eventually this could be generalized; to all scene-types via a virtual function in TGLSceneBase. void ResetCurrentCamera(); Resets position/rotation of current camera to default values. void SetupCameras(Bool_t reset); Setup cameras for current bounding box. void PostSceneBuildSetup(Bool_t resetCameras); Perform post scene-build setup. void InitGL(); Initialise GL state. void RequestDraw(Short_t LOD = TGLRnrCtx::kLODMed); Post request for redraw of viewer at level of detail 'LOD'; Request is directed via cross thread gVirtualGL object. void SetupClipObject(); Setup clip-object. Protected virtual method. void PreRender(); Initialize objects that influence rendering.; Called before every ren",MatchSource.WIKI,root/html602/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLViewer.html
Modifiability,plugin,plugin,"ta members; class charts. ROOT; » GRAF3D; » GL; » TGLViewer. class TGLViewer: public TVirtualViewer3D, public TGLViewerBase, public TQObject. Base GL viewer object - used by both standalone and embedded (in pad); GL. Contains core viewer objects :. GL scene - collection of main drawn objects - see TGLStdScene; Cameras (fXyzzCamera) - ortho and perspective cameras - see TGLCamera; Clipping (fClipXyzz) - collection of clip objects - see TGLClip; Manipulators (fXyzzManip) - collection of manipulators - see TGLManip. It maintains the current active draw styles, clipping object,; manipulator, camera etc. TGLViewer is 'GUI free' in that it does not derive from any ROOT GUI; TGFrame etc - see TGLSAViewer for this. However it contains GUI; GUI style methods HandleButton() etc to which GUI events can be; directed from standalone frame or embedding pad to perform; interaction. Also, the TGLWidget needs to be created externally. It is not owned; by the viewer. For embedded (pad) GL this viewer is created directly by plugin; manager. For standalone the derived TGLSAViewer is. Function Members (Methods); public:. virtual~TGLViewer(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivated()SIGNAL ; virtual voidAddCompositeOp(UInt_t); virtual Int_tAddObject(const TBuffer3D&, Bool_t* = 0); virtual Int_tAddObject(UInt_t, const TBuffer3D&, Bool_t* = 0); virtual voidTGLViewerBase::AddOverlayElement(TGLOverlayElement* el); TGLSceneInfo*TGLViewerBase::AddScene(TGLSceneBase* scene); virtual voidTObject::AppendPad(Option_t* option = """"); voidApplySelection(); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; voidAutoFade(Float_t fade, Float_t time = 1, Int_t steps = 10); virtual voidBeginScene(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual Bool_tCanLoopOnPrimitives() const; virtual voidTGLViewerBa",MatchSource.WIKI,root/html602/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLViewer.html
Performance,perform,perform,". TGLViewer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLViewer. class TGLViewer: public TVirtualViewer3D, public TGLViewerBase, public TQObject. Base GL viewer object - used by both standalone and embedded (in pad); GL. Contains core viewer objects :. GL scene - collection of main drawn objects - see TGLStdScene; Cameras (fXyzzCamera) - ortho and perspective cameras - see TGLCamera; Clipping (fClipXyzz) - collection of clip objects - see TGLClip; Manipulators (fXyzzManip) - collection of manipulators - see TGLManip. It maintains the current active draw styles, clipping object,; manipulator, camera etc. TGLViewer is 'GUI free' in that it does not derive from any ROOT GUI; TGFrame etc - see TGLSAViewer for this. However it contains GUI; GUI style methods HandleButton() etc to which GUI events can be; directed from standalone frame or embedding pad to perform; interaction. Also, the TGLWidget needs to be created externally. It is not owned; by the viewer. For embedded (pad) GL this viewer is created directly by plugin; manager. For standalone the derived TGLSAViewer is. Function Members (Methods); public:. virtual~TGLViewer(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivated()SIGNAL ; virtual voidAddCompositeOp(UInt_t); virtual Int_tAddObject(const TBuffer3D&, Bool_t* = 0); virtual Int_tAddObject(UInt_t, const TBuffer3D&, Bool_t* = 0); virtual voidTGLViewerBase::AddOverlayElement(TGLOverlayElement* el); TGLSceneInfo*TGLViewerBase::AddScene(TGLSceneBase* scene); virtual voidTObject::AppendPad(Option_t* option = """"); voidApplySelection(); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; voidAutoFade(Float_t fade, Float_t time = 1, Int_t steps = 10); virtual voidBeginScene(); static Bool_tTQObject::BlockAllSignals(Boo",MatchSource.WIKI,root/html602/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLViewer.html
Safety,timeout,timeouts,"Center(); { fPushAction = kPushCamCenter; RefreshPadEditor(this); }. void PickAnnotate(); { fPushAction = kPushAnnotate; RefreshPadEditor(this); }. TGLCameraOverlay* GetCameraOverlay() const; { return fCameraOverlay; }. void SetCameraOverlay(TGLCameraOverlay* m); { fCameraOverlay = m; }. Bool_t GetStereo() const; Stereo. { return fStereo; }. Float_t GetStereoZeroParallax() const; { return fStereoZeroParallax; }. Float_t GetStereoEyeOffsetFac() const; { return fStereoEyeOffsetFac; }. Float_t GetStereoFrustumAsymFac() const; { return fStereoFrustumAsymFac; }. void SetStereo(Bool_t s); { fStereo = s; }. void SetStereoZeroParallax(Float_t f); { fStereoZeroParallax = f; }. void SetStereoEyeOffsetFac(Float_t f); { fStereoEyeOffsetFac = f; }. void SetStereoFrustumAsymFac(Float_t f); { fStereoFrustumAsymFac = f; }. EPushAction GetPushAction() const; Push / drag action. { return fPushAction; }. EDragAction GetDragAction() const; { return fDragAction; }. Float_t GetMaxSceneDrawTimeHQ() const; Draw and selection; Scene rendering timeouts. { return fMaxSceneDrawTimeHQ; }. Float_t GetMaxSceneDrawTimeLQ() const; { return fMaxSceneDrawTimeLQ; }. void SetMaxSceneDrawTimeHQ(Float_t t); { fMaxSceneDrawTimeHQ = t; }. void SetMaxSceneDrawTimeLQ(Float_t t); { fMaxSceneDrawTimeLQ = t; }. const char* GetPictureFileName() const; { return fPictureFileName.Data(); }. void SetPictureFileName(const TString& f); { fPictureFileName = f; }. Float_t GetFader() const; { return fFader; }. void SetFader(Float_t x); { fFader = x; }. Bool_t GetIgnoreSizesOnUpdate() const; { return fIgnoreSizesOnUpdate; }. void SetIgnoreSizesOnUpdate(Bool_t v); { fIgnoreSizesOnUpdate = v; }. Bool_t GetResetCamerasOnUpdate() const; { return fResetCamerasOnUpdate; }. void SetResetCamerasOnUpdate(Bool_t v); { fResetCamerasOnUpdate = v; }. void Activated(); { Emit(""Activated()""); }. void DoubleClicked(); { Emit(""DoubleClicked()""); }. TGEventHandler * GetEventHandler() const; { return fEventHandler; }. TGedEditor* GetGedEdito",MatchSource.WIKI,root/html602/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLViewer.html
Testability,log,logicals," TGLPerspectiveCamerafPerspectiveCameraYOZ!; TStringfPictureFileName! default file-name for SavePicture(); Float_tfPointScale! size scale for points; TGLViewer::EPushActionfPushAction; TGLRedrawTimer*fRedrawTimer! timer for triggering redraws; Bool_tfReferenceOn! reference marker on?; TGLVertex3fReferencePos! reference position; Bool_tfResetCamerasOnNextUpdatereposition camera on next update; Bool_tfResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; TGLViewerBase::SceneInfoList_tTGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordfSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordfSelRec! select record from last select (should go to context); TGLManipSet*fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tfSmartRefresh! cache logicals during scene rebuilds; Bool_tfSmoothLines! smooth line edge rendering; Bool_tfSmoothPoints! smooth point edge rendering; Bool_tfStereo! use stereo rendering; Float_tfStereoEyeOffsetFac!; Float_tfStereoFrustumAsymFac!; Float_tfStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectfViewport! viewport - drawn area; TGLViewerBase::SceneInfoVec_tTGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetfgDefaultColorSet! a shared, default color-set; static Bool_tfgUseDefaultColorSetForNewViewers! name says it all. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLViewer(TVirtualPad* pad, Int_t x, Int_t y, Int_t width, Int_t height); Construct the viewer object, with following arguments:; 'pad' - external pad ",MatchSource.WIKI,root/html602/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLViewer.html
Usability,guid,guides,"UUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TGLLockable::ELockTGLLockable::kModifyLock; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TGLViewer::ESecSelTypekOnKeyMod1; static TGLViewer::ESecSelTypekOnRequest; static TObject::(anonymous)TObject::kOverwrite; static TGLViewer::EPushActionkPushAnnotate; static TGLViewer::EPushActionkPushCamCenter; static TGLViewer::EPushActionkPushStd; static TGLLockable::ELockTGLLockable::kSelectLock; static TObject::(anonymous)TObject::kSingleKey; static TGLLockable::ELockTGLLockable::kUnlocked; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TGLAutoRotator*fAutoRotator!; Bool_tfAxesDepthTest! remove guides hidden-lines; Int_tfAxesType! axes type; TGLCamera*TGLViewerBase::fCameraCamera for rendering.; TGLCameraOverlay*fCameraOverlay! markup size of viewport in scene units; Bool_tTGLViewerBase::fChangedChange requiring redraw is pending.; TGLClip*TGLViewerBase::fClipViewer clipping-plane.; TGLClipSet*fClipSet!; TContextMenu*fContextMenu!; TGLCamera*fCurrentCamera!; TGLOverlayElement*fCurrentOvlElm! current overlay element; TGLSelectRecordfCurrentSelRec! select record in use as selected; TGLColorSetfDarkColorSet! color-set with dark background; Bool_tfDebugMode! debug mode (forced rebuild + draw scene/frustum/interest boxes); TGLViewer::EDragActionfDragAction; Bool_tfDrawCameraCenter! reference marker on?; TGEventHandler*fEventHandler! event handler; Float_tfFader! fade the view (0 - no fade/default, 1 - full fade/no rendering done); TGLContextIdentity*fGLCtxId!for embedded gl viewer; Int_tfGLDevice!for embedded gl viewer; TGLWidget*fGLWidget; TGedEditor*fGedEditor! GED editor; Bool_tfIgnoreSizesOnUpdate",MatchSource.WIKI,root/html602/TGLViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLViewer.html
Availability,avail,available,". TGLViewerBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLViewerBase. class TGLViewerBase: public TGLLockable. Base class for GL viewers. Provides a basic scene management and a; small set of control variables (camera, LOD, style, clip) that are; used by the scene classes. Renering wrappers are available but; minimal. There is no concept of GL-context here ... we just draw; into whatever is set from outside. Development notes:. Each viewer automatically creates a TGLRnrCtx and passes it down; all render functions. Function Members (Methods); public:. virtual~TGLViewerBase(); virtual voidAddOverlayElement(TGLOverlayElement* el); TGLSceneInfo*AddScene(TGLSceneBase* scene); virtual voidChanged(); static TClass*Class(); TGLClip*Clip() const; TGLLockable::ELockTGLLockable::CurrentLock() const; virtual voidDeleteOverlayAnnotations(); virtual voidDeleteOverlayElements(TGLOverlayElement::ERole r); Bool_tFindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Bool_tFindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Bool_tFindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); TGLLogicalShape*FindLogicalInScenes(TObject* id); TGLRnrCtx*GetRnrCtx() const; TGLSceneInfo*GetSceneInfo(TGLSceneBase* scene); virtual TClass*IsA() const; virtual Bool_tIsChanged() const; Bool_tTGLLockable::IsDrawOrSelectLock() const; Bool_tTGLLockable::IsLocked() const; virtual const char*LockIdStr() const; static const char*TGLLockable::LockName(TGLLockable::ELock lock); static Bool_tTGLLockable::LockValid(TGLLockable::ELock lock); Short_tLOD() const; virtual voidMergeSceneBBoxes(TGLBoundingBox& bbox); Float_tOLLineW() const; virtual voidPostRender(); virtual voidPostRenderOverlaySelection(); virtual voidPreRender(); virtual voidPreRenderOverlaySelection(); Bool_tTGLLockable::ReleaseLock(TGLL",MatchSource.WIKI,root/html602/TGLViewerBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLViewerBase.html
Integrability,wrap,wrappers,". TGLViewerBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLViewerBase. class TGLViewerBase: public TGLLockable. Base class for GL viewers. Provides a basic scene management and a; small set of control variables (camera, LOD, style, clip) that are; used by the scene classes. Renering wrappers are available but; minimal. There is no concept of GL-context here ... we just draw; into whatever is set from outside. Development notes:. Each viewer automatically creates a TGLRnrCtx and passes it down; all render functions. Function Members (Methods); public:. virtual~TGLViewerBase(); virtual voidAddOverlayElement(TGLOverlayElement* el); TGLSceneInfo*AddScene(TGLSceneBase* scene); virtual voidChanged(); static TClass*Class(); TGLClip*Clip() const; TGLLockable::ELockTGLLockable::CurrentLock() const; virtual voidDeleteOverlayAnnotations(); virtual voidDeleteOverlayElements(TGLOverlayElement::ERole r); Bool_tFindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Bool_tFindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Bool_tFindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); TGLLogicalShape*FindLogicalInScenes(TObject* id); TGLRnrCtx*GetRnrCtx() const; TGLSceneInfo*GetSceneInfo(TGLSceneBase* scene); virtual TClass*IsA() const; virtual Bool_tIsChanged() const; Bool_tTGLLockable::IsDrawOrSelectLock() const; Bool_tTGLLockable::IsLocked() const; virtual const char*LockIdStr() const; static const char*TGLLockable::LockName(TGLLockable::ELock lock); static Bool_tTGLLockable::LockValid(TGLLockable::ELock lock); Short_tLOD() const; virtual voidMergeSceneBBoxes(TGLBoundingBox& bbox); Float_tOLLineW() const; virtual voidPostRender(); virtual voidPostRenderOverlaySelection(); virtual voidPreRender(); virtual voidPreRenderOverlaySelection(); Bool_tTGLLockable::ReleaseLock(TGLL",MatchSource.WIKI,root/html602/TGLViewerBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLViewerBase.html
Modifiability,variab,variables,". TGLViewerBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLViewerBase. class TGLViewerBase: public TGLLockable. Base class for GL viewers. Provides a basic scene management and a; small set of control variables (camera, LOD, style, clip) that are; used by the scene classes. Renering wrappers are available but; minimal. There is no concept of GL-context here ... we just draw; into whatever is set from outside. Development notes:. Each viewer automatically creates a TGLRnrCtx and passes it down; all render functions. Function Members (Methods); public:. virtual~TGLViewerBase(); virtual voidAddOverlayElement(TGLOverlayElement* el); TGLSceneInfo*AddScene(TGLSceneBase* scene); virtual voidChanged(); static TClass*Class(); TGLClip*Clip() const; TGLLockable::ELockTGLLockable::CurrentLock() const; virtual voidDeleteOverlayAnnotations(); virtual voidDeleteOverlayElements(TGLOverlayElement::ERole r); Bool_tFindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Bool_tFindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Bool_tFindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); TGLLogicalShape*FindLogicalInScenes(TObject* id); TGLRnrCtx*GetRnrCtx() const; TGLSceneInfo*GetSceneInfo(TGLSceneBase* scene); virtual TClass*IsA() const; virtual Bool_tIsChanged() const; Bool_tTGLLockable::IsDrawOrSelectLock() const; Bool_tTGLLockable::IsLocked() const; virtual const char*LockIdStr() const; static const char*TGLLockable::LockName(TGLLockable::ELock lock); static Bool_tTGLLockable::LockValid(TGLLockable::ELock lock); Short_tLOD() const; virtual voidMergeSceneBBoxes(TGLBoundingBox& bbox); Float_tOLLineW() const; virtual voidPostRender(); virtual voidPostRenderOverlaySelection(); virtual voidPreRender(); virtual voidPreRenderOverlaySelection(); Bool_tTGLLockable::ReleaseLock(TGLL",MatchSource.WIKI,root/html602/TGLViewerBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLViewerBase.html
Testability,log,logical-shape,"ViewerBase::SceneInfoVec_tfVisScenesVisible scenes.; Float_tfWFLineWOptional override of scene wire-frame line-width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLViewerBase(); Constructor. ~TGLViewerBase(); Destructor. const char* LockIdStr() const; Name to print in locking output. FindScene(TGLSceneBase* scene); Find scene-info corresponding to scene. TGLSceneInfo* AddScene(TGLSceneBase* scene); Add new scene, appropriate scene-info is created. void RemoveScene(TGLSceneBase* scene); Remove scene from the viewer, its scene-info is deleted. void RemoveAllScenes(); Remove all scenes from the viewer, their scene-infos are deleted. void SceneDestructing(TGLSceneBase* scene); Remove scene, its scene-info is deleted.; Called from scene that is being destroyed while still holding; viewer references. TGLSceneInfo* GetSceneInfo(TGLSceneBase* scene); Find scene-info corresponding to scene. TGLLogicalShape* FindLogicalInScenes(TObject* id); Find logical-shape representing object id in the list of scenes.; Return 0 if not found. void AddOverlayElement(TGLOverlayElement* el); Add overlay element. void RemoveOverlayElement(TGLOverlayElement* el); Remove overlay element. void DeleteOverlayAnnotations(); Delete overlay elements that are annotations. void DeleteOverlayElements(TGLOverlayElement::ERole r); Delete overlay elements. void ResetSceneInfos(); Force rebuild of view-dependent scene-info structures. This should be called before calling render (draw/select) if; something that affects camera interest has been changed. void MergeSceneBBoxes(TGLBoundingBox& bbox); Merge bounding-boxes of all active registered scenes. void SetupClipObject(); Setup clip-object. Protected virtual method. void PreRender(); Initialize render-context, setup camera, GL, render-area.; Check and lock scenes, determine their visibility. void SubRenderScenes(TGLViewerBase::SubRender_foo render_foo); Call sub-rendering function render_foo on all currently vi",MatchSource.WIKI,root/html602/TGLViewerBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLViewerBase.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGLViewerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLViewerEditor.html
Deployability,toggle,toggled,"roupFrame*fRefContainer; TGCheckButton*fReferenceOn; TGNumberEntry*fReferencePosX; TGNumberEntry*fReferencePosY; TGNumberEntry*fReferencePosZ; TGCheckButton*fResetCamerasOnUpdate; TGCheckButton*fRotateSceneOn; TGNumberEntry*fSceneRotDt; TGNumberEntry*fStereoEyeOffsetFac; TGCompositeFrame*fStereoFrame; TGNumberEntry*fStereoFrustumAsymFac; TGNumberEntry*fStereoZeroParallax; TGTextButton*fUpdateScene; TGLViewer*fViewer; TGNumberEntry*fWFLineWidth. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLViewerEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor. ~TGLViewerEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void ViewerRedraw(); Initiate redraw of the viewer. void SetModel(TObject* obj); Sets model or disables/hides viewer. void DoClearColor(Pixel_t color); Clear-color was changed. void DoIgnoreSizesOnUpdate(); ResetCamerasOnUpdate was toggled. void DoResetCamerasOnUpdate(); ResetCamerasOnUpdate was toggled. void DoUpdateScene(); UpdateScene was clicked. void DoCameraHome(); CameraHome was clicked. void UpdateMaxDrawTimes(); Slot for fMaxSceneDrawTimeHQ and fMaxSceneDrawTimeLQ. void UpdatePointLineStuff(); Slot for point-sizes and line-widths. void DoCameraOverlay(); Update viewer with GUI state. void DoCameraCenterExt(); Set external camera center. void DoCaptureCenter(); Capture camera-center via picking. void DoDrawCameraCenter(); Draw camera center. void UpdateCameraCenter(); Update current camera with GUI state. void DoAnnotation(); Create annotation via picking. void UpdateViewerAxes(Int_t id); Update viewer with GUI state. void UpdateViewerReference(); Update viewer with GUI state. TGNumberEntry* MakeLabeledNEntry(TGCompositeFrame* p, const char* name, Int_t labelw, Int_t nd = 7, Int_t s = 5); Helper function to create fixed width TGLabel and TGNumberEntry in same row. void CreateStyleT",MatchSource.WIKI,root/html602/TGLViewerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLViewerEditor.html
Modifiability,variab,variables,"dths. void DoCameraOverlay(); Update viewer with GUI state. void DoCameraCenterExt(); Set external camera center. void DoCaptureCenter(); Capture camera-center via picking. void DoDrawCameraCenter(); Draw camera center. void UpdateCameraCenter(); Update current camera with GUI state. void DoAnnotation(); Create annotation via picking. void UpdateViewerAxes(Int_t id); Update viewer with GUI state. void UpdateViewerReference(); Update viewer with GUI state. TGNumberEntry* MakeLabeledNEntry(TGCompositeFrame* p, const char* name, Int_t labelw, Int_t nd = 7, Int_t s = 5); Helper function to create fixed width TGLabel and TGNumberEntry in same row. void CreateStyleTab(); Creates ""Style"" tab. void CreateGuidesTab(); Create ""Guides"" tab. void CreateClippingTab(); Create GUI controls - clip type (none/plane/box) and plane/box properties. void CreateExtrasTab(); Create Extra Tab controls - camera rotator and stereo. void UpdateReferencePosState(); Enable/disable reference position (x/y/z) number edits based on; reference check box. void SetGuides(); Configuration of guides GUI called from SetModel(). void SetRotatorMode(). void UpdateRotator(); Update rotator related variables. void DoRotatorStart(); Start auto-rotator. void DoRotatorStop(); Stop auto-rotator. void DoASavImageGUIBaseName(const char* t); Update base-name. void DoASavImageGUIOutMode(Int_t m); Update output mode. void DoASavImageStart(); Start auto-rotator image auto-save. void DoASavImageStop(); Stop auto-rotator image auto-save. void UpdateStereo(); Update stereo related variables. TGLViewerEditor(const TGLViewerEditor& ). void DetachFromPad(); {fIsInPad = kFALSE;}. » Author: Alja Mrak-Tadel, Matevz Tadel, Timur Pocheptsov 08/03/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:54; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLViewerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLViewerEditor.html
Usability,guid,guides,"dths. void DoCameraOverlay(); Update viewer with GUI state. void DoCameraCenterExt(); Set external camera center. void DoCaptureCenter(); Capture camera-center via picking. void DoDrawCameraCenter(); Draw camera center. void UpdateCameraCenter(); Update current camera with GUI state. void DoAnnotation(); Create annotation via picking. void UpdateViewerAxes(Int_t id); Update viewer with GUI state. void UpdateViewerReference(); Update viewer with GUI state. TGNumberEntry* MakeLabeledNEntry(TGCompositeFrame* p, const char* name, Int_t labelw, Int_t nd = 7, Int_t s = 5); Helper function to create fixed width TGLabel and TGNumberEntry in same row. void CreateStyleTab(); Creates ""Style"" tab. void CreateGuidesTab(); Create ""Guides"" tab. void CreateClippingTab(); Create GUI controls - clip type (none/plane/box) and plane/box properties. void CreateExtrasTab(); Create Extra Tab controls - camera rotator and stereo. void UpdateReferencePosState(); Enable/disable reference position (x/y/z) number edits based on; reference check box. void SetGuides(); Configuration of guides GUI called from SetModel(). void SetRotatorMode(). void UpdateRotator(); Update rotator related variables. void DoRotatorStart(); Start auto-rotator. void DoRotatorStop(); Stop auto-rotator. void DoASavImageGUIBaseName(const char* t); Update base-name. void DoASavImageGUIOutMode(Int_t m); Update output mode. void DoASavImageStart(); Start auto-rotator image auto-save. void DoASavImageStop(); Stop auto-rotator image auto-save. void UpdateStereo(); Update stereo related variables. TGLViewerEditor(const TGLViewerEditor& ). void DetachFromPad(); {fIsInPad = kFALSE;}. » Author: Alja Mrak-Tadel, Matevz Tadel, Timur Pocheptsov 08/03/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:54; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLViewerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLViewerEditor.html
Modifiability,variab,variables,"tPainter::fYAxis; Double_tTGLPlotPainter::fYOZSectionPos; TAxis*TGLPlotPainter::fZAxis; vector<Double_t>TGLPlotPainter::fZLevels; static TGLPlotPainter::ESelectionBaseTGLPlotPainter::kHighColorSelectionBase; static TGLPlotPainter::ESelectionBaseTGLPlotPainter::kTrueColorSelectionBase. private:. vector<Double_t>fLevels; Rgl::Range_tfMinMaxVal; TGLLevelPalettefPalette; TStringfPlotInfo; TF1*fTransferFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLVoxelPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord); Constructor.; This plot always needs a palette. char * GetPlotInfo(Int_t px, Int_t py); Show box info (i, j, k, binContent). Bool_t InitGeometry(); Set ranges, find min and max bin content. void StartPan(Int_t px, Int_t py); User clicks right mouse button (in a pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. void AddOption(const TString& stringOption); ""z"" draw palette or not. void ProcessEvent(Int_t event, Int_t px, Int_t py); Remove sections, switch on/off box cut. void InitGL() const; Initialize some gl state variables. void DeInitGL() const; Return back some gl state variables. void DrawPlot() const; Draw ""voxels"". void DrawSectionXOZ() const; Noop. void DrawSectionYOZ() const; Noop. void DrawSectionXOY() const; Noop. void DrawPalette() const; Draw. Palette. void DrawPaletteAxis() const; Draw. Palette. Axis. void PreparePalette() const; Generate palette. void FindVoxelColor(Double_t binContent, Float_t* rgba) const; Find box color. void SetVoxelColor(const Float_t* rgba) const; Set box color. TGLVoxelPainter(const TGLVoxelPainter& ). Bool_t HasSections() const. » Last changed: Tue Jun 30 14:54:56 2015 » Last generated: 2015-06-30 14:54; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGLVoxelPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLVoxelPainter.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractViewport(Int_t* vp) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; virtual const TGLContext*GetContext() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDND",MatchSource.WIKI,root/html602/TGLWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLWidget.html
Energy Efficiency,allocate,allocated,"awing in overrider of PaintGL. Bool_t MakeCurrent(); Make the gl-context current. Bool_t ClearCurrent(); Clear the current gl-context. void SwapBuffers(); Swap buffers. const TGLContext * GetContext() const; Get gl context. const TGLFormat * GetPixelFormat() const; Pixel format. std::pair<void *, void *> GetInnerData() const; Dpy*, XVisualInfo *. void AddContext(TGLContext* ctx); Register gl-context created for this window. void RemoveContext(TGLContext* ctx); Remove context (no real deletion, done by TGLContex dtor). void ExtractViewport(Int_t* vp) const; For camera. Window_t CreateWindow(const TGWindow* parent, const TGLFormat& format, UInt_t width, UInt_t height, pair<void*,void*>& innerData); CreateWidget.; Static function called prior to widget construction,; I've extracted this code from ctors to make WIN32/X11; separation simpler and because of gInterpreter usage.; new, TGLContext can throw; std::bad_alloc and std::runtime_error. Before try block, the only; resource allocated is pointed by fWindowIndex (InitWindow cannot throw).; In try block (and after successful constraction); resources are controlled by std::auto_ptrs and dtor. void SetFormat(); Set pixel format.; Resource - hDC, owned and freed by guard object. void SetEventHandler(TGEventHandler* eh); Set event-handler. All events are passed to this object. Bool_t HandleCrossing(Event_t* ); Handle mouse crossing event. Bool_t HandleButton(Event_t* ev); Delegate call to the owner. Bool_t HandleDoubleClick(Event_t* ev); Delegate call to the owner. Bool_t HandleConfigureNotify(Event_t* ev); Delegate call to the owner. Bool_t HandleFocusChange(Event_t* ); Delegate call to the owner. Bool_t HandleKey(Event_t* ev); Delegate call to the owner. Bool_t HandleMotion(Event_t* ev); Delegate call to the owner. void DoRedraw(); Delegate call to the owner.; if (!gVirtualX->IsCmdThread()) {; gROOT->ProcessLineFast(Form(""((TGLWidget *)0x%lx)->DoRedraw()"", this));; return;; }; R__LOCKGUARD2(gROOTMutex);. TGEventHandler * G",MatchSource.WIKI,root/html602/TGLWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLWidget.html
Modifiability,inherit,inherits,". TGLWidget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLWidget. class TGLWidget: public TGFrame, public TGLPaintDevice. GL window with context. _Must_ _have_ a parent window; (the 'parent' parameter of ctors). The current version inherits; TGCanvas (I'm not sure about future versions), probably, in future; multiple inheritance will be added - the second; base class will be TGLPaintDevice or something like this. Usage:; - Simply create TGLWidget as an embedded widget, and; connect your slots to signals you need: HandleExpose, HandleConfigureNotify, etc.; In your slots you can use gl API directly - under Win32 TGLWidget switches; between threads internally (look TGLPShapeObjEditor for such usage).; - You can write your own class, derived from TGLWidget, with PaintGL and InitGL; overriden. Resources (and invariants):; -fContainer (TGLWidgetContainer) - controlled by std::auto_ptr; -fWindowIndex - controlled manually (see CreateWidget and dtor); -fGLContext - controlled manually (see CreateWidget and dtor); -visual info for X11 version, controlled manually (see CreateGLContainer and dtor). Exceptions:; -can be thrown only during construction.; -under win32 class does not throw itself (but some internal operations can throw); -under X11 can throw std::runtime_error (from CreateGLContext).; -In case of exceptions resources will be freed. TGLWidget object is immutable as far as it was created. Boolean parameter defines, if you want to grab user's input or not.; By default you want, but for example when not - see TGLPShapeObjEditor. Non-copyable. Function Members (Methods); public:. virtual~TGLWidget(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); s",MatchSource.WIKI,root/html602/TGLWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLWidget.html
Usability,simpl,simpler,"tInput); Creates widget with default pixel format. ~TGLWidget(); Destructor. Deletes window ???? and XVisualInfo. void InitGL(); Call glEnable(... in overrider of InitGL. void PaintGL(); Do actual drawing in overrider of PaintGL. Bool_t MakeCurrent(); Make the gl-context current. Bool_t ClearCurrent(); Clear the current gl-context. void SwapBuffers(); Swap buffers. const TGLContext * GetContext() const; Get gl context. const TGLFormat * GetPixelFormat() const; Pixel format. std::pair<void *, void *> GetInnerData() const; Dpy*, XVisualInfo *. void AddContext(TGLContext* ctx); Register gl-context created for this window. void RemoveContext(TGLContext* ctx); Remove context (no real deletion, done by TGLContex dtor). void ExtractViewport(Int_t* vp) const; For camera. Window_t CreateWindow(const TGWindow* parent, const TGLFormat& format, UInt_t width, UInt_t height, pair<void*,void*>& innerData); CreateWidget.; Static function called prior to widget construction,; I've extracted this code from ctors to make WIN32/X11; separation simpler and because of gInterpreter usage.; new, TGLContext can throw; std::bad_alloc and std::runtime_error. Before try block, the only; resource allocated is pointed by fWindowIndex (InitWindow cannot throw).; In try block (and after successful constraction); resources are controlled by std::auto_ptrs and dtor. void SetFormat(); Set pixel format.; Resource - hDC, owned and freed by guard object. void SetEventHandler(TGEventHandler* eh); Set event-handler. All events are passed to this object. Bool_t HandleCrossing(Event_t* ); Handle mouse crossing event. Bool_t HandleButton(Event_t* ev); Delegate call to the owner. Bool_t HandleDoubleClick(Event_t* ev); Delegate call to the owner. Bool_t HandleConfigureNotify(Event_t* ev); Delegate call to the owner. Bool_t HandleFocusChange(Event_t* ); Delegate call to the owner. Bool_t HandleKey(Event_t* ev); Delegate call to the owner. Bool_t HandleMotion(Event_t* ev); Delegate call to the owner. void DoRedr",MatchSource.WIKI,root/html602/TGLWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGLWidget.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidGetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDime",MatchSource.WIKI,root/html602/TGMainFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMainFrame.html
Integrability,message,messages,"cumentation; TGMainFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kVerticalFrame); Create a top level main frame. A main frame interacts; with the window manager. ~TGMainFrame(); TGMainFrame destructor. Bool_t SaveFrameAsCodeOrImage(); Opens dialog window allowing user to save the frame contents; as a ROOT macro or as an image.; Returns kTRUE if something was saved. This is bound to Ctrl-S by default. Bool_t HandleKey(Event_t* event); Handle keyboard events. Bool_t BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; Bind key to a window. void RemoveBind(const TGWindow* w, Int_t keycode, Int_t modifier) const; Remove key binding. Bool_t HandleButton(Event_t* event); Handle mouse button events. Bool_t HandleMotion(Event_t* event); Handle mouse motion events. Bool_t HandleSelection(Event_t* event); Handle primary selection event. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request event. Bool_t HandleClientMessage(Event_t* event); Handle client messages sent to this frame. void SendCloseMessage(); Send close message to self. This method should be called from; a button to close this window. void CloseWindow(); Close and delete main frame. We get here in response to ALT+F4 or; a window manager close command. To terminate the application when this; happens override this method and call gApplication->Terminate(0) or; make a connection to this signal (if after the slot this method; should not be called call DontCallClose() in the slot).; By default the window will be deleted. void DontCallClose(); Typically call this method in the slot connected to the CloseWindow(); signal to prevent the calling of the default or any derived CloseWindow(); methods to prevent premature or double deletion of this window. void SetWindowName(const char* name = 0); Set window name. This is typically done via the window manager. void SetIconName(const char* name); Set window icon name. This is typically done via the window manager. const",MatchSource.WIKI,root/html602/TGMainFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMainFrame.html
Testability,log,logically,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. virtual~TGMainFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tBindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voi",MatchSource.WIKI,root/html602/TGMainFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMainFrame.html
Usability,simpl,simple,". TGMainFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGMainFrame. class TGMainFrame: public TGCompositeFrame. TGFrame, TGCompositeFrame, TGVerticalFrame, TGHorizontalFrame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. virtual~TGMainFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tBindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual vo",MatchSource.WIKI,root/html602/TGMainFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMainFrame.html
Availability,down,downward,". TGMatrixLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGMatrixLayout. class TGMatrixLayout: public TGLayoutManager. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. virtual~TGMatrixLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObje",MatchSource.WIKI,root/html602/TGMatrixLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMatrixLayout.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGPictureButton*GetButton(Int_t no) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_",MatchSource.WIKI,root/html602/TGMdiButtons.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMdiButtons.html
Integrability,message,messages,"lay server; TGLayoutHints*fCloseHintLayout hints; Int_tTGFrame::fDNDStateEDNDFlags; TGLayoutHints*fDefaultHintLayout hints; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*fMsgWindowwindow handling container messages; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedB",MatchSource.WIKI,root/html602/TGMdiButtons.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMdiButtons.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObjec",MatchSource.WIKI,root/html602/TGMdiContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMdiContainer.html
Modifiability,config,configure,"avePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGMdiContainer(const TGMdiMainFrame* p, Int_t w, Int_t h, UInt_t options = 0, ULong_t back = GetDefaultFrameBackground()); TGMdiContainer constructor. TGDimension GetDefaultSize() const; Return dimension of MDI container. Bool_t HandleConfigureNotify(Event_t* event); Handle configure notify events for MDI container. TGMdiContainer(const TGMdiMainFrame* p, Int_t w, Int_t h, UInt_t options = 0, ULong_t back = GetDefaultFrameBackground()). » Author: Bertrand Bellenot 20/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGMdiContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMdiContainer.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGF",MatchSource.WIKI,root/html602/TGMdiCornerWinResizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMdiCornerWinResizer.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGMdiDecorFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMdiDecorFrame.html
Modifiability,config,configure," const TGGC* boxGC, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); TGMdiDecorFrame constructor.; The TGMdiDecorFrame is the frame containing MDI decorations like; title bar, minimize, maximize, restore and close buttons, and resizers. ~TGMdiDecorFrame(); TGMdiDecorFrame destructor. void SetDecorBorderWidth(Int_t bw); Set border width of the decor. void SetMdiButtons(ULong_t buttons); Set-up MDI buttons. void SetResizeMode(Int_t mode = kMdiDefaultResizeMode); Set resize mode (opaque or transparent). void Layout(); Recalculates the postion and the size of all decor frame components. void SetWindowName(const char* name); Set MDI Window name (appearing in the title bar). void SetWindowIcon(const TGPicture* pic); Set Window icon (appearing in the title bar). void Move(Int_t x, Int_t y); Move the MDI window at position x, y. void MoveResize(Int_t x, Int_t y, UInt_t w, UInt_t h); Move the MDI window at position x, y and set size to w, h. Bool_t HandleConfigureNotify(Event_t* event); Handle configure notify event. Bool_t HandleButton(Event_t* event); Handle mouse button events. TGMdiDecorFrame(TGMdiMainFrame* main, TGMdiFrame* frame, Int_t w, Int_t h, const TGGC* boxGC, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()). Int_t CloseWindow(); { return fFrame->CloseWindow(); }. ULong_t GetMdiButtons() const; { return fButtonMask; }. const char * GetWindowName(). const TGPicture * GetWindowIcon(); { return fTitlebar->GetWinIcon()->GetPicture(); }. Bool_t IsCurrent() const; { return fIsCurrent; }. Bool_t IsMinimized() const; { return fIsMinimized; }. Bool_t IsMaximized() const; { return fIsMaximized; }. Int_t GetPreResizeX() const; { return fPreResizeX; }. Int_t GetPreResizeY() const; { return fPreResizeY; }. Int_t GetPreResizeWidth() const; { return fPreResizeWidth; }. Int_t GetPreResizeHeight() const; { return fPreResizeHeight; }. Int_t GetMinimizedX() const; { return fMinimizedX; }. Int_t GetMinimizedY() const; { return fMinimizedY; }. Bool_t Ge",MatchSource.WIKI,root/html602/TGMdiDecorFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMdiDecorFrame.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGMdiFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMdiFrame.html
Availability,mask,mask,". TGMdiGeometry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGMdiGeometry. class TGMdiGeometry. TGMdiMainFrame. This file contains the TGMdiMainFrame class. Function Members (Methods); public:. virtual~TGMdiGeometry(); static TClass*Class(); virtual TClass*IsA() const; TGMdiGeometry&operator=(const TGMdiGeometry&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGMdiGeometry(); TGMdiGeometry(const TGMdiGeometry&). Data Members; public:. TGRectanglefClientclient, decoration and icon rectangles; TGRectanglefDecorationclient, decoration and icon rectangles; TGRectanglefIconclient, decoration and icon rectangles; Int_tfValueMaskMDI hints mask. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TGMdiGeometry(); { }. » Author: Bertrand Bellenot 20/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGMdiGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMdiGeometry.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGF",MatchSource.WIKI,root/html602/TGMdiHorizontalWinResizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMdiHorizontalWinResizer.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFrameClosed(Int_t id)SIGNAL ; virtual voidFrameCreated(Int_t id)SIGNAL ; virtual voidFrameMaximized(Int_t id)SIGNAL ; virtual voidFrameMinimized(Int_t id)SIGNAL ; virtual voidFrameRestored(Int_t id)SIGNAL ; virtual voidFramesArranged(Int_t mode)SIGNAL ; virtual voidFreeMove(TGMdiFrame* frame); virtual voidFreeSize(TGMdiFrame* frame); virtual Pixel_tTGFrame::GetBackground() const; TGRectangleGetBBox() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; TGFrame*GetContaine",MatchSource.WIKI,root/html602/TGMdiMainFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMdiMainFrame.html
Integrability,depend,depending," frame list). void CirculateUp(); Bring the lowest window to the top. void CirculateDown(); Send the highest window to the bottom. TGMdiDecorFrame * GetDecorFrame(TGMdiFrame* frame) const; Return decor frame of MDI child window (by frame pointer). TGMdiDecorFrame * GetDecorFrame(UInt_t id) const; Return decor frame of MDI child window (by id). TGMdiFrame * GetMdiFrame(UInt_t id) const; Return frame of MDI child window (by id). TGRectangle GetBBox() const; Return resizing box (rectangle) for current MDI child. TGRectangle GetMinimizedBBox() const; Return minimized box (rectangle) for current MDI child. void UpdateWinListMenu(); Update MDI menu entries with current list of MDI child windows. void Layout(); Recalculates the postion and the size of all MDI child windows. void UpdateMdiButtons(); Update the status of MDI buttons in the decor frame of all children. void ArrangeFrames(Int_t mode); Automatic repositionning and resizing of every MDI child window.; depending on mode : tile horizontal, tile vertical, or cascade. void ArrangeMinimized(); This is an attempt to an ""smart"" minimized window re-arrangement. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages MDI main frame. void Maximize(TGMdiFrame* frame); Maximize MDI child window mdiframe. void Restore(TGMdiFrame* frame); Restore size of MDI child window mdiframe. void Minimize(TGMdiFrame* frame); Minimize MDI child window mdiframe. Int_t Close(TGMdiFrame* frame); Close MDI child window mdiframe. void FreeMove(TGMdiFrame* frame); Allow to move MDI child window mdiframe. void FreeSize(TGMdiFrame* frame); Allow to resize MDI child window mdiframe. Int_t ContextHelp(TGMdiFrame* frame); Calls Help() method of MDI child window mdiframe. TGMdiFrame * GetCurrent() const; Return pointer on current (active) MDI child window. TGMdiGeometry GetWindowGeometry(TGMdiFrame* f) const; Get MDI geometry of MDI child window f. void ConfigureWindow(TGMdiFrame* f, TGMdiGeometry& geom); Set MDI geometry for ",MatchSource.WIKI,root/html602/TGMdiMainFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMdiMainFrame.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGMdiMenuBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMdiMenuBar.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGMdiButtons*GetButtons() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGComposi",MatchSource.WIKI,root/html602/TGMdiTitleBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMdiTitleBar.html
Integrability,depend,depends,"static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGMdiTitleBar(const TGWindow* p, const TGWindow* mdiwin, const char* name = ""Untitled""); TGMdiTitleBar constructor.; the TGMdiTitleBar is the frame containing a title (window name); an icon and MDI picture buttons as minimize, maximize, restore,; close and help. ~TGMdiTitleBar(); TGMdiTitleBar destructor. void LayoutButtons(UInt_t buttonmask, Bool_t isMinimized, Bool_t isMaximized); Recalculates the position of every enabled (displayed) buttons. void SetTitleBarColors(UInt_t fore, UInt_t back, TGFont* f); Set title bar color (blue or grey, depends on active state). Bool_t HandleDoubleClick(Event_t* event); Handle double click in title bar (maximize window). Bool_t HandleButton(Event_t* event); Handle mouse click on title bar. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for title bar. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in title bar (used to move MDI window). void AddFrames(TGMdiTitleIcon* icon, TGMdiButtons* buttons); This is called from TGMdiMainFrame on Restore(). void RemoveFrames(TGMdiTitleIcon* icon, TGMdiButtons* buttons); This is called from TGMdiMainFrame on Maximize(). TGMdiTitleBar(const TGWindow* p, const TGWindow* mdiwin, const char* name = ""Untitled""). TGMdiButtons * GetButtons() const; { return fButtons; }. TGMdiTitleIcon * GetWinIcon() const; { return fWinIcon; }. TGLabel * GetWinName() const; { return fWinName; }. Int_t GetX0(); { return fX0; }. Int_t GetY0(); { return fY0; }. Bool_t IsLeftButPressed(); { r",MatchSource.WIKI,root/html602/TGMdiTitleBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMdiTitleBar.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGIcon::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_",MatchSource.WIKI,root/html602/TGMdiTitleIcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMdiTitleIcon.html
Integrability,message,messages,,MatchSource.WIKI,root/html602/TGMdiTitleIcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMdiTitleIcon.html
Security,access,access,":fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGMdiTitleIcon(const TGWindow* p, const TGWindow* titlebar, const TGPicture* pic, Int_t w, Int_t h); TGMdiTitleIcon constructor.; the TGMdiTitleIcon is the left icon used also for the MDI; popup menu allowing access to MDI commands as : restore,; move, size, minimize and close. ~TGMdiTitleIcon(); TGMdiTitleIcon destructor. void DoRedraw(); Redraw icon. Bool_t HandleDoubleClick(Event_t* event); Handle double click event on MDI icon (close the window). Bool_t HandleButton(Event_t* event); Handle button event on MDI icon (popup menu). TGMdiTitleIcon(const TGWindow* p, const TGWindow* titlebar, const TGPicture* pic, Int_t w, Int_t h). TGPopupMenu * GetPopup() const; { return fPopup; }. » Author: Bertrand Bellenot 20/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGMdiTitleIcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMdiTitleIcon.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGF",MatchSource.WIKI,root/html602/TGMdiVerticalWinResizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMdiVerticalWinResizer.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGF",MatchSource.WIKI,root/html602/TGMdiWinResizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMdiWinResizer.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); virtual TGMenuTitle*GetCurrent() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTG",MatchSource.WIKI,root/html602/TGMenuBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMenuBar.html
Integrability,interface,interfaces,"enuBar. class TGMenuBar: public TGHorizontalFrame. TGMenuBar, TGPopupMenu, TGMenuTitle and TGMenuEntry. The TGMenu.h header contains all different menu classes. The TGMenuBar class implements a menu bar widget. It is used to; specify and provide access to common and frequently used application; actions grouped under menu titles (TGMenuTitle class). The menu bar; takes the highest-level of the menu system and it is a starting; point for many interactions. It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu item will generate the event:; kC_COMMAND, kCM_MENU, menu id, user data. Function Members (Methods); public:. virtual~TGMenuBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompos",MatchSource.WIKI,root/html602/TGMenuBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMenuBar.html
Safety,avoid,avoid,"It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu item will generate the event:; kC_COMMAND, kCM_MENU, menu id, user data. Function Members (Methods); public:. virtual~TGMenuBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidAddPopup(TGHotString* s, TGPopupMenu* menu, TGLayoutHints* l, TGPopupMenu* before = 0); virtual voidAddPopup(const char* s, TGPopupMenu* menu, TGLayoutHints* l, TGPopupMenu* before = 0); virtual TGPopupMenu*AddPopup(const TString& s, Int_t padleft = 4, Int_t padright = 0, Int_t padtop = 0, Int_t padbottom = 0); virtual voidAddTitle(TGMenuTitle* title, TGL",MatchSource.WIKI,root/html602/TGMenuBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMenuBar.html
Security,access,access,". TGMenuBar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGMenuBar. class TGMenuBar: public TGHorizontalFrame. TGMenuBar, TGPopupMenu, TGMenuTitle and TGMenuEntry. The TGMenu.h header contains all different menu classes. The TGMenuBar class implements a menu bar widget. It is used to; specify and provide access to common and frequently used application; actions grouped under menu titles (TGMenuTitle class). The menu bar; takes the highest-level of the menu system and it is a starting; point for many interactions. It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu i",MatchSource.WIKI,root/html602/TGMenuBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMenuBar.html
Availability,error,error,,MatchSource.WIKI,root/html602/TGMenuEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMenuEntry.html
Integrability,interface,interfaces," » TGMenuEntry. class TGMenuEntry: public TObject. TGMenuBar, TGPopupMenu, TGMenuTitle and TGMenuEntry. The TGMenu.h header contains all different menu classes. The TGMenuBar class implements a menu bar widget. It is used to; specify and provide access to common and frequently used application; actions grouped under menu titles (TGMenuTitle class). The menu bar; takes the highest-level of the menu system and it is a starting; point for many interactions. It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu item will generate the event:; kC_COMMAND, kCM_MENU, menu id, user data. Function Members (Methods); public:. virtual~TGMenuEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); vi",MatchSource.WIKI,root/html602/TGMenuEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMenuEntry.html
Safety,avoid,avoid,"It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu item will generate the event:; kC_COMMAND, kCM_MENU, menu id, user data. Function Members (Methods); public:. virtual~TGMenuEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTOb",MatchSource.WIKI,root/html602/TGMenuEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMenuEntry.html
Security,access,access,". TGMenuEntry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGMenuEntry. class TGMenuEntry: public TObject. TGMenuBar, TGPopupMenu, TGMenuTitle and TGMenuEntry. The TGMenu.h header contains all different menu classes. The TGMenuBar class implements a menu bar widget. It is used to; specify and provide access to common and frequently used application; actions grouped under menu titles (TGMenuTitle class). The menu bar; takes the highest-level of the menu system and it is a starting; point for many interactions. It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu item ",MatchSource.WIKI,root/html602/TGMenuEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMenuEntry.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); static const TGGC&GetDefaultSelectedGC(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaul",MatchSource.WIKI,root/html602/TGMenuTitle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMenuTitle.html
Integrability,interface,interfaces," » TGMenuTitle. class TGMenuTitle: public TGFrame. TGMenuBar, TGPopupMenu, TGMenuTitle and TGMenuEntry. The TGMenu.h header contains all different menu classes. The TGMenuBar class implements a menu bar widget. It is used to; specify and provide access to common and frequently used application; actions grouped under menu titles (TGMenuTitle class). The menu bar; takes the highest-level of the menu system and it is a starting; point for many interactions. It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu item will generate the event:; kC_COMMAND, kCM_MENU, menu id, user data. Function Members (Methods); public:. virtual~TGMenuTitle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddIn",MatchSource.WIKI,root/html602/TGMenuTitle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMenuTitle.html
Safety,avoid,avoid,"It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu item will generate the event:; kC_COMMAND, kCM_MENU, menu id, user data. Function Members (Methods); public:. virtual~TGMenuTitle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options);",MatchSource.WIKI,root/html602/TGMenuTitle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMenuTitle.html
Security,access,access,". TGMenuTitle. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGMenuTitle. class TGMenuTitle: public TGFrame. TGMenuBar, TGPopupMenu, TGMenuTitle and TGMenuEntry. The TGMenu.h header contains all different menu classes. The TGMenuBar class implements a menu bar widget. It is used to; specify and provide access to common and frequently used application; actions grouped under menu titles (TGMenuTitle class). The menu bar; takes the highest-level of the menu system and it is a starting; point for many interactions. It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu item ",MatchSource.WIKI,root/html602/TGMenuTitle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMenuTitle.html
Availability,error,error,"tMethod(const char* method) const; voidAddType(const char* type, const char* pat, const char* icon, const char* sicon, const char* action); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAction(const char* filename, char* action); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TGPicture*GetIcon(const char* filename, Bool_t small_icon); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; Bool_tGetType(const char* filename, char* type); virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_",MatchSource.WIKI,root/html602/TGMimeTypes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMimeTypes.html
Performance,cache,cache,"c TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfChangedtrue if file has changed; TGClient*fClientclient to which mime types belong (display server); TStringfFilenamefile name of mime type file; TOrdCollection*fListlist of mime types. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGMimeTypes(TGClient* client, const char* file); Create a mime type cache. Read the mime types file ""filename"" and; built a list of mime types. ~TGMimeTypes(); Delete mime type pool. TGMimeTypes(const TGMimeTypes& gmt); Copy constructor. TGMimeTypes& operator=(const TGMimeTypes& gmt); Assignment operator. TGMime * Find(const char* filename); Given a filename find the matching mime type object. const TGPicture * GetIcon(const char* filename, Bool_t small_icon); Return icon belonging to mime type of filename. Bool_t GetAction(const char* filename, char* action); Return in action the mime action string belonging to filename. Bool_t GetType(const char* filename, char* type); Return in type the mime type belonging to filename. void Print(Option_t* option = """") const; Print list of mime types. void SaveMimes(); Save mime types in user's mime type file. void AddType(const char* type, const char* pat, const char* icon, const char* sicon, const char* action); Add a mime type to the list of mime types. Bool_t HasChanged",MatchSource.WIKI,root/html602/TGMimeTypes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMimeTypes.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html602/TGMsgBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMsgBox.html
Integrability,message,message,". TGMsgBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGMsgBox. class TGMsgBox: public TGTransientFrame. TMsgBox. A message dialog box. Function Members (Methods); public:. virtual~TGMsgBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const ",MatchSource.WIKI,root/html602/TGMsgBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGMsgBox.html
Availability,down,down,". TGNumberEntry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGNumberEntry. class TGNumberEntry: public TGCompositeFrame, public TGWidget, public TGNumberFormat. TGNumberEntry, TGNumberEntryField and TGNumberFormat. TGNumberEntry is a number entry input widget with up/down buttons.; TGNumberEntryField is a number entry input widget.; TGNumberFormat contains enum types to specify the numeric format. The number entry widget is based on TGTextEntry but allows only; numerical input. The widget support numerous formats including; integers, hex numbers, real numbers, fixed fraction reals and; time/date formats. The widget also allows to restrict input values; to non-negative or positive numbers and to specify explicit limits. The following styles are supported:; kNESInteger: integer number; kNESRealOne: real number with one digit (no exponent); kNESRealTwo: real number with two digits (no exponent); kNESRealThree: real number with three digits (no exponent); kNESRealFour: real number with four digits (no exponent); kNESReal: arbitrary real number; kNESDegree: angle in degree:minutes:seconds format; kNESMinSec: time in minutes:seconds format; kNESHourMin: time in hour:minutes format; kNESHourMinSec: time in hour:minutes:seconds format; kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas; TGNumberEntry adds two small",MatchSource.WIKI,root/html602/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGNumberEntry.html
Integrability,message,messages,,MatchSource.WIKI,root/html602/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGNumberEntry.html
Testability,log,logarithmic," kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas; TGNumberEntry adds two small buttons to increase and decrease the; numerical value in the field. The number entry widgets also support; using the up and down cursor keys to change the numerical values.; The step size can be selected with control and shift keys:; -- small step (1 unit/factor of 3); shift medium step (10 units/factor of 10); control large step (100 units/factor of 30); shift-control huge step (1000 units/factor of 100). The steps are either linear or logarithmic. The default behaviour; is set when the entry field is created, but it can be changed by; pressing the alt key at the same time. Changing the number in the widget will generate the event:; kC_TEXTENTRY, kTE_TEXTCHANGED, widget id, 0.; Hitting the enter key will generate:; kC_TEXTENTRY, kTE_ENTER, widget id, 0.; Hitting the tab key will generate:; kC_TEXTENTRY, kTE_TAB, widget id, 0. /*. */. Function Members (Methods); public:. virtual~TGNumberEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidAssociate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b)",MatchSource.WIKI,root/html602/TGNumberEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGNumberEntry.html
Availability,down,down,". TGNumberEntryField. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGNumberEntryField. class TGNumberEntryField: public TGTextEntry, public TGNumberFormat. TGNumberEntry, TGNumberEntryField and TGNumberFormat. TGNumberEntry is a number entry input widget with up/down buttons.; TGNumberEntryField is a number entry input widget.; TGNumberFormat contains enum types to specify the numeric format. The number entry widget is based on TGTextEntry but allows only; numerical input. The widget support numerous formats including; integers, hex numbers, real numbers, fixed fraction reals and; time/date formats. The widget also allows to restrict input values; to non-negative or positive numbers and to specify explicit limits. The following styles are supported:; kNESInteger: integer number; kNESRealOne: real number with one digit (no exponent); kNESRealTwo: real number with two digits (no exponent); kNESRealThree: real number with three digits (no exponent); kNESRealFour: real number with four digits (no exponent); kNESReal: arbitrary real number; kNESDegree: angle in degree:minutes:seconds format; kNESMinSec: time in minutes:seconds format; kNESHourMin: time in hour:minutes format; kNESHourMinSec: time in hour:minutes:seconds format; kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas; TGNumberEntry adds two small button",MatchSource.WIKI,root/html602/TGNumberEntryField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGNumberEntryField.html
Integrability,message,message,"epresentation). Long_t GetIntNumber() const; Get the numeric value (integer representation). void GetTime(Int_t& hour, Int_t& min, Int_t& sec) const; Get the numeric value (time format). void GetDate(Int_t& year, Int_t& month, Int_t& day) const; Get the numeric value (date format). ULong_t GetHexNumber() const; Get the numeric value (hex format). Int_t GetCharWidth(const char* text = ""0"") const; Get the text width in pixels. void IncreaseNumber(TGNumberFormat::EStepSize step = kNSSSmall, Int_t sign = 1, Bool_t logstep = kFALSE); Increase the number value. void SetFormat(TGNumberFormat::EStyle style, TGNumberFormat::EAttribute attr = kNEAAnyNumber); Set the numerical format. void SetLimits(TGNumberFormat::ELimit limits = kNELNoLimits, Double_t min = 0, Double_t max = 1); Set the numerical limits. void SetState(Bool_t state); Set the active state. Bool_t HandleKey(Event_t* event); Handle keys. Bool_t HandleFocusChange(Event_t* event); Handle focus change. void TextChanged(const char* text = 0); Text has changed message. void ReturnPressed(); Return was pressed. void Layout(); Layout. void SavePrimitive(ostream& out, Option_t* = """"); Save a number entry widget as a C++ statement(s) on output stream out. TGNumberEntryField(const TGWindow* p, Int_t id, Double_t val, GContext_t norm, FontStruct_t font = GetDefaultFontStruct(), UInt_t option = kSunkenFrame | kDoubleBorder, Pixel_t back = GetWhitePixel()). void SetLogStep(Bool_t on = kTRUE); Set logarithmic steps. EStyle GetNumStyle() const; Get the numerical style. EAttribute GetNumAttr() const; Get the numerical attribute. ELimit GetNumLimits() const; Get the numerialc limit attribute. Double_t GetNumMin() const; Get the lower limit. Double_t GetNumMax() const; Get the upper limit. Bool_t IsLogStep() const; Is log step enabled?. Bool_t IsEditable() const; { return kFALSE; }. void InvalidInput(const char* instr); { Emit(""InvalidInput(char*)"", instr); }. TGNumberEntry& operator=(const TGNumberEntry&). TGNumberEntryLayout& o",MatchSource.WIKI,root/html602/TGNumberEntryField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGNumberEntryField.html
Testability,log,logarithmic," kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas; TGNumberEntry adds two small buttons to increase and decrease the; numerical value in the field. The number entry widgets also support; using the up and down cursor keys to change the numerical values.; The step size can be selected with control and shift keys:; -- small step (1 unit/factor of 3); shift medium step (10 units/factor of 10); control large step (100 units/factor of 30); shift-control huge step (1000 units/factor of 100). The steps are either linear or logarithmic. The default behaviour; is set when the entry field is created, but it can be changed by; pressing the alt key at the same time. Changing the number in the widget will generate the event:; kC_TEXTENTRY, kTE_TEXTCHANGED, widget id, 0.; Hitting the enter key will generate:; kC_TEXTENTRY, kTE_ENTER, widget id, 0.; Hitting the tab key will generate:; kC_TEXTENTRY, kTE_TAB, widget id, 0. /*. */. Function Members (Methods); public:. virtual~TGNumberEntryField(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGTextEntry::AppendText(const char* text); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); voidTGTextEntry::Backspace(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTO",MatchSource.WIKI,root/html602/TGNumberEntryField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGNumberEntryField.html
Availability,down,down,". TGNumberEntryLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGNumberEntryLayout. class TGNumberEntryLayout: public TGLayoutManager. TGNumberEntry, TGNumberEntryField and TGNumberFormat. TGNumberEntry is a number entry input widget with up/down buttons.; TGNumberEntryField is a number entry input widget.; TGNumberFormat contains enum types to specify the numeric format. The number entry widget is based on TGTextEntry but allows only; numerical input. The widget support numerous formats including; integers, hex numbers, real numbers, fixed fraction reals and; time/date formats. The widget also allows to restrict input values; to non-negative or positive numbers and to specify explicit limits. The following styles are supported:; kNESInteger: integer number; kNESRealOne: real number with one digit (no exponent); kNESRealTwo: real number with two digits (no exponent); kNESRealThree: real number with three digits (no exponent); kNESRealFour: real number with four digits (no exponent); kNESReal: arbitrary real number; kNESDegree: angle in degree:minutes:seconds format; kNESMinSec: time in minutes:seconds format; kNESHourMin: time in hour:minutes format; kNESHourMinSec: time in hour:minutes:seconds format; kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas; TGNumberEntry adds two small buttons to increase an",MatchSource.WIKI,root/html602/TGNumberEntryLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGNumberEntryLayout.html
Testability,log,logarithmic," kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas; TGNumberEntry adds two small buttons to increase and decrease the; numerical value in the field. The number entry widgets also support; using the up and down cursor keys to change the numerical values.; The step size can be selected with control and shift keys:; -- small step (1 unit/factor of 3); shift medium step (10 units/factor of 10); control large step (100 units/factor of 30); shift-control huge step (1000 units/factor of 100). The steps are either linear or logarithmic. The default behaviour; is set when the entry field is created, but it can be changed by; pressing the alt key at the same time. Changing the number in the widget will generate the event:; kC_TEXTENTRY, kTE_TEXTCHANGED, widget id, 0.; Hitting the enter key will generate:; kC_TEXTENTRY, kTE_ENTER, widget id, 0.; Hitting the tab key will generate:; kC_TEXTENTRY, kTE_TAB, widget id, 0. /*. */. Function Members (Methods); public:. virtual~TGNumberEntryLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::",MatchSource.WIKI,root/html602/TGNumberEntryLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGNumberEntryLayout.html
Availability,down,down,". TGNumberFormat. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGNumberFormat. class TGNumberFormat. TGNumberEntry, TGNumberEntryField and TGNumberFormat. TGNumberEntry is a number entry input widget with up/down buttons.; TGNumberEntryField is a number entry input widget.; TGNumberFormat contains enum types to specify the numeric format. The number entry widget is based on TGTextEntry but allows only; numerical input. The widget support numerous formats including; integers, hex numbers, real numbers, fixed fraction reals and; time/date formats. The widget also allows to restrict input values; to non-negative or positive numbers and to specify explicit limits. The following styles are supported:; kNESInteger: integer number; kNESRealOne: real number with one digit (no exponent); kNESRealTwo: real number with two digits (no exponent); kNESRealThree: real number with three digits (no exponent); kNESRealFour: real number with four digits (no exponent); kNESReal: arbitrary real number; kNESDegree: angle in degree:minutes:seconds format; kNESMinSec: time in minutes:seconds format; kNESHourMin: time in hour:minutes format; kNESHourMinSec: time in hour:minutes:seconds format; kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas; TGNumberEntry adds two small buttons to increase and decrease the; numerical value in the ",MatchSource.WIKI,root/html602/TGNumberFormat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGNumberFormat.html
Testability,log,logarithmic," kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas; TGNumberEntry adds two small buttons to increase and decrease the; numerical value in the field. The number entry widgets also support; using the up and down cursor keys to change the numerical values.; The step size can be selected with control and shift keys:; -- small step (1 unit/factor of 3); shift medium step (10 units/factor of 10); control large step (100 units/factor of 30); shift-control huge step (1000 units/factor of 100). The steps are either linear or logarithmic. The default behaviour; is set when the entry field is created, but it can be changed by; pressing the alt key at the same time. Changing the number in the widget will generate the event:; kC_TEXTENTRY, kTE_TEXTCHANGED, widget id, 0.; Hitting the enter key will generate:; kC_TEXTENTRY, kTE_ENTER, widget id, 0.; Hitting the tab key will generate:; kC_TEXTENTRY, kTE_TAB, widget id, 0. /*. */. Function Members (Methods); public:. virtual~TGNumberFormat(); static TClass*Class(); virtual TClass*IsA() const; TGNumberFormat&operator=(const TGNumberFormat&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGNumberFormat(); TGNumberFormat(const TGNumberFormat&). Data Members; public:. static TGNumberFormat::EAttributekNEAAnyNumber; static TGNumberFormat::EAttributekNEANonNegative; static TGNumberFormat::EAttributekNEAPositive; static TGNumberFormat::ELimitkNELLimitMax; static",MatchSource.WIKI,root/html602/TGNumberFormat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGNumberFormat.html
Availability,error,error," virtual~TGObject(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGClient*GetClient() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Handle_tGetId() const; virtual c",MatchSource.WIKI,root/html602/TGObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGObject.html
Availability,error,error,"taBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTQpSolverBase::DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tTQpSolverBase::DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTQpSolverBase::DumbStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tTQpSolverBase::FinalStepLength(TQpVar* iterate, TQpVar* step); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tTQpSolverBase::GetArTol(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TQpLinSolverBase*TQpSolverBase::GetLinearSystem(); Double_tTQpSolverBase::GetMuTol(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::H",MatchSource.WIKI,root/html602/TGondzioSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGondzioSolver.html
Energy Efficiency,monitor,monitor,"defined as the sum of the complementarity gap; Double_t*TQpSolverBase::fPhi_history[fMaxit] history of values of phi obtained on all iterations to date; Double_t*TQpSolverBase::fPhi_min_history[fMaxit] the i-th entry of this array contains the minimum value of phi; Int_tfPrintlevelparameter in range [0,100] determines verbosity. (Higher value; Double_t*TQpSolverBase::fRnorm_history[fMaxit] history of values of residual norm obtained on all iterations to date; TQpVar*fStep; Double_tfStepFactor0various parameters associated with Gondzio correction; Double_tfStepFactor1; TQpLinSolverBase*TQpSolverBase::fSys; Double_tfTsigexponent in Mehrotra's centering parameter, which is usually. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGondzioSolver(); Default constructor. TGondzioSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); Constructor. TGondzioSolver(const TGondzioSolver& another); Copy constructor. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); Solve the quadratic programming problem as formulated through prob, store; the final solution in iterate->fX . Monitor the residuals during the iterations; through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); Print information about the optimization process and monitor the convergence; status of thye algorithm. ~TGondzioSolver(); Deconstructor. TGondzioSolver & operator=(const TGondzioSolver& source); Assignment operator. void Reset_parameters(); {}. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id$ » Last generated: 2015-06-30 15:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGondzioSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGondzioSolver.html
Performance,optimiz,optimization,"defined as the sum of the complementarity gap; Double_t*TQpSolverBase::fPhi_history[fMaxit] history of values of phi obtained on all iterations to date; Double_t*TQpSolverBase::fPhi_min_history[fMaxit] the i-th entry of this array contains the minimum value of phi; Int_tfPrintlevelparameter in range [0,100] determines verbosity. (Higher value; Double_t*TQpSolverBase::fRnorm_history[fMaxit] history of values of residual norm obtained on all iterations to date; TQpVar*fStep; Double_tfStepFactor0various parameters associated with Gondzio correction; Double_tfStepFactor1; TQpLinSolverBase*TQpSolverBase::fSys; Double_tfTsigexponent in Mehrotra's centering parameter, which is usually. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGondzioSolver(); Default constructor. TGondzioSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); Constructor. TGondzioSolver(const TGondzioSolver& another); Copy constructor. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); Solve the quadratic programming problem as formulated through prob, store; the final solution in iterate->fX . Monitor the residuals during the iterations; through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); Print information about the optimization process and monitor the convergence; status of thye algorithm. ~TGondzioSolver(); Deconstructor. TGondzioSolver & operator=(const TGondzioSolver& source); Assignment operator. void Reset_parameters(); {}. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id$ » Last generated: 2015-06-30 15:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGondzioSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGondzioSolver.html
Safety,predict,predictor-corrector,". TGondzioSolver. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TGondzioSolver. class TGondzioSolver: public TQpSolverBase. TGondzioSolver. Derived class of TQpSolverBase implementing Gondzio-correction; version of Mehrotra's original predictor-corrector algorithm. Function Members (Methods); public:. virtual~TGondzioSolver(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tTQpSolverBase::DataNorm(); virtual voidDefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); virtual voidTQpSolverBase::DefStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual Int_tTQpSolverBase::DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTQpSolverBase::DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tTQpSolverBase::DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; v",MatchSource.WIKI,root/html602/TGondzioSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGondzioSolver.html
Availability,error,error,"::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEqualizeFrames(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGPack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGPack.html
Security,password,passwords,". TGPasswdDialog. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGPasswdDialog. class TGPasswdDialog. TGPasswdDialog. Graphic dialog to enter passwords. Usage:. {; Buffer for the passwd; char pwdbuf[128]. Open the dialog box; TGPasswdDialog dialog(""My prompt"", pwdbuf, 128);. Wait until the user is done; while (gROOT->IsInterrupted()); gSystem->DispatchOneEvent(kFALSE);. Password is now in pwdbuf. }. Function Members (Methods); public:. virtual~TGPasswdDialog(); static TClass*Class(); voidCloseWindow(); voidDoClose(); virtual TClass*IsA() const; TGPasswdDialog&operator=(const TGPasswdDialog&); voidReturnPressed(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGPasswdDialog(const TGPasswdDialog&); TGPasswdDialog(const char* prompt, char* pwdbuf, Int_t pwdlenmax, UInt_t w = 400, UInt_t h = 400). Data Members; private:. TGTransientFrame*fDialogmain frame of this widget; TGTextButton*fOkOk button; TGTextEntry*fPasswdPassword TextEntry; TGTextBuffer*fPasswdTextPasswd Buffer; char*fPwdBufbuffer where to store the passwd; Int_tfPwdLenMaxpasswd buffer length. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGPasswdDialog(const char* prompt, char* pwdbuf, Int_t pwdlenmax, UInt_t w = 400, UInt_t h = 400); Create an editor in a dialog. ~TGPasswdDialog(); Delete log window. void DoClose(); Handle close button. void CloseWindow(); Called when closed via window manager action. void ReturnPressed(); Handle return. TGPasswdDialog(const char* prompt, char* pwdbuf, Int_t pwdlenmax, UInt_t w = 400, UInt_t h = 400). » Author: G. Ganis 10/10/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14",MatchSource.WIKI,root/html602/TGPasswdDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGPasswdDialog.html
Testability,log,log,"lass description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGPasswdDialog. class TGPasswdDialog. TGPasswdDialog. Graphic dialog to enter passwords. Usage:. {; Buffer for the passwd; char pwdbuf[128]. Open the dialog box; TGPasswdDialog dialog(""My prompt"", pwdbuf, 128);. Wait until the user is done; while (gROOT->IsInterrupted()); gSystem->DispatchOneEvent(kFALSE);. Password is now in pwdbuf. }. Function Members (Methods); public:. virtual~TGPasswdDialog(); static TClass*Class(); voidCloseWindow(); voidDoClose(); virtual TClass*IsA() const; TGPasswdDialog&operator=(const TGPasswdDialog&); voidReturnPressed(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGPasswdDialog(const TGPasswdDialog&); TGPasswdDialog(const char* prompt, char* pwdbuf, Int_t pwdlenmax, UInt_t w = 400, UInt_t h = 400). Data Members; private:. TGTransientFrame*fDialogmain frame of this widget; TGTextButton*fOkOk button; TGTextEntry*fPasswdPassword TextEntry; TGTextBuffer*fPasswdTextPasswd Buffer; char*fPwdBufbuffer where to store the passwd; Int_tfPwdLenMaxpasswd buffer length. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGPasswdDialog(const char* prompt, char* pwdbuf, Int_t pwdlenmax, UInt_t w = 400, UInt_t h = 400); Create an editor in a dialog. ~TGPasswdDialog(); Delete log window. void DoClose(); Handle close button. void CloseWindow(); Called when closed via window manager action. void ReturnPressed(); Handle return. TGPasswdDialog(const char* prompt, char* pwdbuf, Int_t pwdlenmax, UInt_t w = 400, UInt_t h = 400). » Author: G. Ganis 10/10/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGPasswdDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGPasswdDialog.html
Availability,error,error," virtual~TGPicture(); voidTObject::AbstractMethod(const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Handle_t id, GContext_t gc, Int_t x, Int_t y) const; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObjec",MatchSource.WIKI,root/html602/TGPicture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGPicture.html
Performance,cache,cache,". TGPicture. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGPicture. class TGPicture: public TObject, public TRefCnt. TGPicture & TGPicturePool. The TGPicture class implements pictures and icons used in the; different GUI elements and widgets. The TGPicturePool class; implements a TGPicture cache. TGPictures are created, managed and; destroyed by the TGPicturePool. Function Members (Methods); public:. virtual~TGPicture(); voidTObject::AbstractMethod(const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Handle_t id, GContext_t gc, Int_t x, Int_t y) const; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObjec",MatchSource.WIKI,root/html602/TGPicture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGPicture.html
Availability,avail,available,"_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Methods); public:. virtual~TGPictureButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); vir",MatchSource.WIKI,root/html602/TGPictureButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGPictureButton.html
Deployability,release,released,; Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; Bool_tfOwnDisabledPickTRUE if disabled picture was autogenerated; const TGWindow*TGWindow::fParentParent window; const TGPicture*fPicpicture to be put in button; const TGPicture*fPicDpicture shown when button disabled; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled.,MatchSource.WIKI,root/html602/TGPictureButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGPictureButton.html
Integrability,message,message,"""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Method",MatchSource.WIKI,root/html602/TGPictureButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGPictureButton.html
Performance,perform,perform,". TGPictureButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGPictureButton. class TGPictureButton: public TGButton. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- bu",MatchSource.WIKI,root/html602/TGPictureButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGPictureButton.html
Security,access,access,". TGPictureButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGPictureButton. class TGPictureButton: public TGButton. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- bu",MatchSource.WIKI,root/html602/TGPictureButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGPictureButton.html
Testability,log,logical," widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked",MatchSource.WIKI,root/html602/TGPictureButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGPictureButton.html
Availability,error,error," virtual~TGPicturePool(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFreePicture(const TGPicture* pic); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtor",MatchSource.WIKI,root/html602/TGPicturePool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGPicturePool.html
Performance,cache,cache,". TGPicturePool. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGPicturePool. class TGPicturePool: public TObject. TGPicture & TGPicturePool. The TGPicture class implements pictures and icons used in the; different GUI elements and widgets. The TGPicturePool class; implements a TGPicture cache. TGPictures are created, managed and; destroyed by the TGPicturePool. Function Members (Methods); public:. virtual~TGPicturePool(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFreePicture(const TGPicture* pic); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtor",MatchSource.WIKI,root/html602/TGPicturePool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGPicturePool.html
Availability,error,error,"ject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidEnableEntry(Int_t id); virtual Int_tEndMenu(void*& userData); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); virtual TGMenuEntry*GetCurrent() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFr",MatchSource.WIKI,root/html602/TGPopupMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGPopupMenu.html
Integrability,interface,interfaces," » TGPopupMenu. class TGPopupMenu: public TGFrame. TGMenuBar, TGPopupMenu, TGMenuTitle and TGMenuEntry. The TGMenu.h header contains all different menu classes. The TGMenuBar class implements a menu bar widget. It is used to; specify and provide access to common and frequently used application; actions grouped under menu titles (TGMenuTitle class). The menu bar; takes the highest-level of the menu system and it is a starting; point for many interactions. It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu item will generate the event:; kC_COMMAND, kCM_MENU, menu id, user data. Function Members (Methods); public:. virtual~TGPopupMenu(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivate(Bool_t); virtual voidActivate(TGMenu",MatchSource.WIKI,root/html602/TGPopupMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGPopupMenu.html
Safety,avoid,avoid,"It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu item will generate the event:; kC_COMMAND, kCM_MENU, menu id, user data. Function Members (Methods); public:. virtual~TGPopupMenu(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivate(Bool_t); virtual voidActivate(TGMenuEntry* entry); virtual voidActivated(Int_t id)SIGNAL ; virtual voidAddEntry(TGHotString* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidAddEntry(const char* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidAddLabel(TGHotString* s, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidAddLabel(const char* s, const TGPicture* p = 0, ",MatchSource.WIKI,root/html602/TGPopupMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGPopupMenu.html
Security,access,access,". TGPopupMenu. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGPopupMenu. class TGPopupMenu: public TGFrame. TGMenuBar, TGPopupMenu, TGMenuTitle and TGMenuEntry. The TGMenu.h header contains all different menu classes. The TGMenuBar class implements a menu bar widget. It is used to; specify and provide access to common and frequently used application; actions grouped under menu titles (TGMenuTitle class). The menu bar; takes the highest-level of the menu system and it is a starting; point for many interactions. It is always visible and allows using; the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar; automatically resizes itself so that it has the same width as its; parent (typically TGMainFrame). A menu bar contains one or more; popup menus and usually is placed along the top of the application; window. Any popup menu is invisible until the user invokes it by; using the mouse pointer or the keyboard. Popup menus implemented by TGPopupMenu class are unique in that,; by convention, they are not placed with the other GUI components in; the user interfaces. Instead, a popup menu usually appears either in; a menu bar or as a context menu on the TOP of the GUI. For that; reason it needs gClient->GetDefaultRoot() as a parent to get the; pointer to the root (i.e. desktop) window. This way a popup menu; will never be embedded.; NOTE: Using gClient->GetRoot() as a parent of TGPopupMenu will not; avoid the possibility of embedding the corresponding popup menu; because the current window hierarchy can be changed by using; gClient->SetRoot() method. As a context menus TGPopupMenu shows up after pressing the right; mouse button, over a popup-enabled component. The popup menu then; appears under the mouse pointer. Selecting a menu item ",MatchSource.WIKI,root/html602/TGPopupMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGPopupMenu.html
Availability,avail,available,". TGPrintDialog. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGPrintDialog. class TGPrintDialog: public TGTransientFrame. TGTextEditDialogs. This file defines several dialogs that are used by the TGTextEdit; widget via its associated context popup menu.; The following dialogs are available: TGSearchDialog, TGGotoDialog; and TGPrintDialog. Function Members (Methods); public:. virtual~TGPrintDialog(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static ",MatchSource.WIKI,root/html602/TGPrintDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGPrintDialog.html
Integrability,message,messages,"Frame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGPrintDialog(const TGWindow* p = 0, const TGWindow* main = 0, UInt_t w = 1, UInt_t h = 1, char** printerName = 0, char** printProg = 0, Int_t* ret_code = 0, UInt_t options = kVerticalFrame); Create the printer dialog box. Returns kTRUE in ret_code when; printerName and printProg have been set and cancel was not pressed,; kFALSE otherwise. ~TGPrintDialog(); Clean up print dialog. void CloseWindow(); Close the dialog. On close the dialog will be deleted and cannot be; re-used. void GetPrinters(); Ask the system fo the list of available printers and populate the combo; box. If there is a default printer, select it in the list. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process print dialog widget messages. TGPrintDialog(const TGWindow* p = 0, const TGWindow* main = 0, UInt_t w = 1, UInt_t h = 1, char** printerName = 0, char** printProg = 0, Int_t* ret_code = 0, UInt_t options = kVerticalFrame). » Author: Fons Rademakers 10/7/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGPrintDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGPrintDialog.html
Availability,avail,available,". TGProgressBar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGProgressBar. class TGProgressBar: public TGFrame. TGProgressBar, TGHProgressBar and TGVProgressBar. The classes in this file implement progress bars. Progress bars can; be used to show progress of tasks taking more then a few seconds.; TGProgressBar is an abstract base class, use either TGHProgressBar; or TGVProgressBar. TGHProgressBar can in addition show the position; as text in the bar. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGProgressBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class",MatchSource.WIKI,root/html602/TGProgressBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGProgressBar.html
Usability,progress bar,progress bars,". TGProgressBar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGProgressBar. class TGProgressBar: public TGFrame. TGProgressBar, TGHProgressBar and TGVProgressBar. The classes in this file implement progress bars. Progress bars can; be used to show progress of tasks taking more then a few seconds.; TGProgressBar is an abstract base class, use either TGHProgressBar; or TGVProgressBar. TGHProgressBar can in addition show the position; as text in the bar. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGProgressBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class",MatchSource.WIKI,root/html602/TGProgressBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGProgressBar.html
Availability,mask,mask,"(Window_t id, EGEventType type, Event_t& ev); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearArea(Window_t id, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidClearWindow(); virtual voidClearWindow(Window_t id); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidCloseDisplay(); virtual voidClosePixmap(); virtual voidCloseWindow(); static intCoinFlag(); virtual const QColor&ColorIndex(Color_t indx) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConvertPrimarySelection(Window_t id, Atom_t clipboard, Time_t when); virtual voidConvertSelection(Window_t, Atom_t&, Atom_t&, Atom_t&, Time_t&); virtual voidTNamed::Copy(TObject& named) const; virtual voidCopyArea(Drawable_t src, Drawable_t dest, GContext_t gc, Int_t src_x, Int_t src_y, UInt_t width, UInt_t height, Int_t dest_x, Int_t dest_y); virtual voidCopyGC(GContext_t org, GContext_t dest, Mask_t mask); virtual voidCopyPixmap(Int_t wid, Int_t xpos, Int_t ypos); virtual voidCopyPixmap(const QPixmap& p, Int_t px1, Int_t py1); virtual Pixmap_tCreateBitmap(Drawable_t id, const char* bitmap, UInt_t width, UInt_t height); virtual Cursor_tCreateCursor(ECursor cursor); virtual GContext_tCreateGC(Drawable_t id, GCValues_t* gval); virtual Drawable_tCreateImage(UInt_t width, UInt_t height); virtual voidCreateOpenGLContext(Int_t wid = 0); virtual Window_tTVirtualX::CreateOpenGLWindow(Window_t parentID, UInt_t width, UInt_t height, const vector<pair<UInt_t,Int_t> >& format); virtual Bool_tCreatePictureFromData(Drawable_t id, char** data, Pixmap_t& pict, Pixmap_t& pict_mask, PictureAttributes_t& attr); virtual Bool_tCreatePictureFromFile(Drawable_t id, const char* filename, Pixmap_t& pict, Pixmap_t& pict_mask, PictureAttributes_t& attr); virtual Pixmap_tCreatePixmap(Drawable_t id, UInt_t w, UInt_t h); virtual Pixmap_tCreatePixmap(Drawable_t id, const char* bitmap, UInt_t width, UInt_t height, U",MatchSource.WIKI,root/html602/TGQt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGQt.html
Deployability,install,installation,"w_t id); method to restore (dynamic cast) the QWidget object pointer (if any) from ROOT windows ""id"". void PrintEvent(Event_t& ); Dump trhe ROOT Event_t structure to debug the code. int CoinFlag(); return the Coin/QGL viewer flag safely. void SetCoinFlag(int flag); Set the Coin/QGL viewer flag safely. void SetCoinLoaded(); { fgCoinLoaded = 1; }. Int_t IsCoinLoaded(); { return fgCoinLoaded;}. QString RootFileFormat(const char* selector); { return RootFileFormat(QString(selector)); }. QString RootFileFormat(const QString& selector); Define whether the input string contains any pattern; that matches the ROOT image formats; those Qt library can not provide. QString QtFileFormat(const char* selector); { return QtFileFormat(QString(selector)); }. QString QtFileFormat(const QString& selector); returns Qt file format. if no suitable format found and the selector is empty; the default PNG format is returned. a special treatment of the ""gif"" format.; If ""gif"" is not provided with the local Qt installation; replace ""gif"" format with ""png"" one. TQtApplication * CreateQtApplicationImp(); The method to instantiate the QApplication if needed. void PostQtEvent(QObject* receiver, QEvent* event); Qt announced that QThread::postEvent to become obsolete and; we have to switch to the QAppication instead. TGQt(); Default Constructor *-*-*-; *-* ===================. TGQt(const char* name, const char* title); Normal Constructor*-*-*-. ~TGQt(); Default Destructor*-*-*-*-; *-* ==================. Bool_t Init(void* display = 0); Qt GUI initialization-. Int_t CreatROOTThread(); dummy*-*-*-*-; -. Int_t RegisterWid(QPaintDevice* wid); register QWidget for the embedded TCanvas. Int_t UnRegisterWid(QPaintDevice* wid); unregister QWidget to the TCanvas; return = Root registration Id or zero if the wd was not registered. Bool_t IsRegistered(QPaintDevice* wid); Check whether the object has been registered. Int_t InitWindow(ULong_t window); -; *-* if window == 0 InitWindow creates its own instance of T",MatchSource.WIKI,root/html602/TGQt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGQt.html
Integrability,interface,interface,". TGQt. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » QT; » TGQt. class TGQt: public TVirtualX. TGQt. This class is the basic interface to the Qt graphics system. It is; an implementation of the abstract TVirtualX class. Function Members (Methods); public:. virtual~TGQt(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTVirtualX::AddPixmap(ULong_t pixid, UInt_t w, UInt_t h); virtual Int_tAddWindow(ULong_t qwid, UInt_t w, UInt_t h); virtual Bool_tAllocColor(Colormap_t cmap, ColorStruct_t& color); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualX::BeginModalSessionFor(Window_t window); virtual voidBell(Int_t percent); virtual voidTObject::Browse(TBrowser* b); virtual voidChangeActivePointerGrab(Window_t, UInt_t, Cursor_t); virtual voidChangeGC(GContext_t gc, GCValues_t* gval); virtual voidChangeProperties(Window_t id, Atom_t property, Atom_t type, Int_t format, UChar_t* data, Int_t len); virtual voidChangeProperty(Window_t id, Atom_t property, Atom_t type, UChar_t* data, Int_t len); virtual voidChangeWindowAttributes(Window_t id, SetWindowAttributes_t* attr); virtual Bool_tCheckEvent(Window_t id, EGEventType type, Event_t& ev); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearArea(Window_t id, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidClearWindow(); virtual voidClearWindow(Window_t id); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidCloseDisplay(); virtual voidClosePixmap(); virtual voidCloseWindow(); static intCoinFlag(); virtual const QColor&ColorIndex(Color_t indx) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConvertPrimarySelection(Window_t id, Atom_t clipboard, Time_t when); virtual voidCo",MatchSource.WIKI,root/html602/TGQt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGQt.html
Modifiability,extend,extend,"ev offscreen buffer if any. Int_t GetDoubleBuffer(Int_t wid); Query the double buffer value for the window wd.; return pointer to the off-screen buffer if any. void GetGeometry(Int_t wid, Int_t& x, Int_t& y, UInt_t& w, UInt_t& h); Returns the global cooordinate of the window ""wd"". const char * DisplayName(const char* = 0); { return ""localhost""; }. ULong_t GetPixel(Color_t cindex); Return pixel value associated to specified ROOT color number.; see: GQTGUI.cxx:QtColor() also. void GetRGB(Int_t index, Float_t& r, Float_t& g, Float_t& b); Get rgb values for color ""index"". const QTextCodec * GetTextDecoder(). Float_t GetTextMagnitude(); {return fTextMagnitude;}. void SetTextMagnitude(Float_t mgn); { fTextMagnitude = mgn;}. void GetTextExtent(UInt_t& w, UInt_t& h, char* mess); Return the size of a character string.; iw : text width; ih : text height; mess : message. Int_t GetFontAscent() const; Returns ascent of the current font (in pixels).; The ascent of a font is the distance from the baseline; to the highest position characters extend to. Int_t GetFontDescent() const; Returns the descent of the current font (in pixels.; The descent is the distance from the base line; to the lowest point characters extend to. Bool_t HasTTFonts() const; {return fUseTTF;}. void MoveWindow(Int_t wid, Int_t x, Int_t y); Move the window wd.; wd : Window identifier.; x : x new window position; y : y new window position. void PutByte(Byte_t b). void QueryPointer(Int_t& ix, Int_t& iy); Query pointer position.; ix : X coordinate of pointer; iy : Y coordinate of pointer. Pixmap_t ReadGIF(Int_t x0, Int_t y0, const char* file, Window_t id = 0); If id is NULL - loads the specified gif file at position [x0,y0] in the; current window. Otherwise creates pixmap from gif file. Int_t RequestLocator(Int_t mode, Int_t ctyp, Int_t& x, Int_t& y); deprecated. Int_t RequestString(Int_t x, Int_t y, char* text); Request string*-*-*-*-*-*-*-; *-* ==============; *-* x,y : position where text is displayed; *-* text",MatchSource.WIKI,root/html602/TGQt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGQt.html
Performance,load,loads,"fTextMagnitude;}. void SetTextMagnitude(Float_t mgn); { fTextMagnitude = mgn;}. void GetTextExtent(UInt_t& w, UInt_t& h, char* mess); Return the size of a character string.; iw : text width; ih : text height; mess : message. Int_t GetFontAscent() const; Returns ascent of the current font (in pixels).; The ascent of a font is the distance from the baseline; to the highest position characters extend to. Int_t GetFontDescent() const; Returns the descent of the current font (in pixels.; The descent is the distance from the base line; to the lowest point characters extend to. Bool_t HasTTFonts() const; {return fUseTTF;}. void MoveWindow(Int_t wid, Int_t x, Int_t y); Move the window wd.; wd : Window identifier.; x : x new window position; y : y new window position. void PutByte(Byte_t b). void QueryPointer(Int_t& ix, Int_t& iy); Query pointer position.; ix : X coordinate of pointer; iy : Y coordinate of pointer. Pixmap_t ReadGIF(Int_t x0, Int_t y0, const char* file, Window_t id = 0); If id is NULL - loads the specified gif file at position [x0,y0] in the; current window. Otherwise creates pixmap from gif file. Int_t RequestLocator(Int_t mode, Int_t ctyp, Int_t& x, Int_t& y); deprecated. Int_t RequestString(Int_t x, Int_t y, char* text); Request string*-*-*-*-*-*-*-; *-* ==============; *-* x,y : position where text is displayed; *-* text : text displayed (input), edited text (output); -; *-* Request string:; *-* text is displayed and can be edited with Emacs-like keybinding; *-* return termination code (0 for ESC, 1 for RETURN); -; *-* Return value:; -; *-* 0 - input was canceled; *-* 1 - input was Ok; -; *. void RescaleWindow(Int_t wid, UInt_t w, UInt_t h); Rescale the window wd.; wd : Window identifier; w : Width; h : Heigth. Int_t ResizePixmap(Int_t wid, UInt_t w, UInt_t h); Resize a pixmap.; wd : pixmap to be resized; w,h : Width and height of the pixmap. void ResizeWindow(Int_t wid); Resize the current window if necessary.; No implementation is required under Qt. voi",MatchSource.WIKI,root/html602/TGQt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGQt.html
Safety,safe,safely,"c intfgCoinLoadedno coin viewer;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; QString SetFileName(const QString& fileName); Set the file pattern. QString GetNewFileName(const QString& fileNamePrototype); Find the filename for the given ""fileNamePrototype"". QPaintDevice * iwid(Window_t wid); Convert ROOT Widget Id to the Qt QPaintDevice pointer. Int_t iwid(QPaintDevice* wid); method to provide the ROOT ""cast"" from (QPaintDevice*) to ROOT windows ""id"". QPaintDevice * iwid(Int_t wid); method to restore (cast) the QPaintDevice object pointer from ROOT windows ""id"". QWidget * winid(Window_t id); returns the top level QWidget for the ROOT widget. Window_t wid(TQtClientWidget* widget). Window_t rootwid(QPaintDevice* dev). QWidget * wid(Window_t id); method to restore (dynamic cast) the QWidget object pointer (if any) from ROOT windows ""id"". void PrintEvent(Event_t& ); Dump trhe ROOT Event_t structure to debug the code. int CoinFlag(); return the Coin/QGL viewer flag safely. void SetCoinFlag(int flag); Set the Coin/QGL viewer flag safely. void SetCoinLoaded(); { fgCoinLoaded = 1; }. Int_t IsCoinLoaded(); { return fgCoinLoaded;}. QString RootFileFormat(const char* selector); { return RootFileFormat(QString(selector)); }. QString RootFileFormat(const QString& selector); Define whether the input string contains any pattern; that matches the ROOT image formats; those Qt library can not provide. QString QtFileFormat(const char* selector); { return QtFileFormat(QString(selector)); }. QString QtFileFormat(const QString& selector); returns Qt file format. if no suitable format found and the selector is empty; the default PNG format is returned. a special treatment of the ""gif"" format.; If ""gif"" is not provided with the local Qt installation; replace ""gif"" format with ""png"" one. TQtApplication * CreateQtApplicationImp(); The method to instantiate the QApplication if needed. void PostQtEvent(QObject* receiver, QEvent* event); Qt announce",MatchSource.WIKI,root/html602/TGQt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGQt.html
Usability,feedback,feedback,"::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TVirtualX::ETextSetModeTVirtualX::kLoad; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TVirtualX::ETextModeTVirtualX::kOpaque; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TVirtualX::EDrawModeTVirtualX::kXor; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfBlockRGBProtect against color double setting; Float_tfCharacterUpXCharacter Up vector along X; Float_tfCharacterUpYCharacter Up vector along Y; TGQt::TQTCLIPMAPfClipMap; QTextCodec*fCodecThe Current text decoder; TGQt::COLORMAPfColorMapto back the TG widgets; ECursorfCursorCurrent cursor number;; QVector<QCursor*>fCursors; Int_tfDisplayOpened; QPainter::CompositionModefDrawMode; TVirtualX::EDrawModeTVirtualX::fDrawModeDrawing mode; TQtEmitterfEmitterobject to emit Qt signals on behalf of TVirtualX; Bool_tfFeedBackModeTCanvas feedback mode; TQtFeedBackWidget*fFeedBackWidgetThe dedicated widget for TCanvas feedback mode; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; QStringfFontTextCodeThe default code text code page (from the Gui.DefaultFont); Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tfMarkerStyle; Style_tTAttMarker::fMarkerStyleMarker style; TStringTNamed::fNameobject identifier; QMap<Color_t,QColor*>fPallete; TQtClientWidget*fPointerGrabber; QPaintDevice*fPrevWindowPointer to the previous ""Window""; TQtBrush*fQBrush; TQtClientFilter*fQClientFilter; TQtEventQueue*fQClientFilterBuffer; TQtClientGuardfQClientGuardguard TQtClientWibdget against of dead poi",MatchSource.WIKI,root/html602/TGQt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGQt.html
Availability,avail,available,"_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Methods); public:. virtual~TGRadioButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtu",MatchSource.WIKI,root/html602/TGRadioButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGRadioButton.html
Deployability,release,released,e; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled.,MatchSource.WIKI,root/html602/TGRadioButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGRadioButton.html
Integrability,message,message,"""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Method",MatchSource.WIKI,root/html602/TGRadioButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGRadioButton.html
Performance,perform,perform,". TGRadioButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGRadioButton. class TGRadioButton: public TGTextButton. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- butt",MatchSource.WIKI,root/html602/TGRadioButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGRadioButton.html
Security,access,access,". TGRadioButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGRadioButton. class TGRadioButton: public TGTextButton. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- butt",MatchSource.WIKI,root/html602/TGRadioButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGRadioButton.html
Testability,log,logical," widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked",MatchSource.WIKI,root/html602/TGRadioButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGRadioButton.html
Availability,error,error," voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* chopt = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawGraph(Int_t n, const Int_t* x, const Int_t* y, Option_t* option = """"); virtual voidDrawGraph(Int_t n, const Float_t* x, const Float_t* y, Option_t* option = """"); virtual voidDrawGraph(Int_t n, const Double_t* x = 0, const Double_t* y = 0, Option_t* option = """"); virtual voidDrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t x, TSpline* spline = 0, Option_t* option = """") const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExpand(Int_t newsize); virtual voidExpand(Int_t newsize, Int_t step); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TFitResultPtrFit(const char* formula, Option_t* option = """", Option_t* goption = """", Axis_t xmin = 0, Axis_t xmax = 0)MENU ; virtual TFitResultPtrFit(TF1* f1, Option_t* option = """", Option_t* goption = """", Axis_t xmin = 0, Axis_t xmax = 0); virtual voidFitPanel()MENU ; virtual Double_tGetCorrelationFactor() const; virtual Double_tGetCovariance() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditable() const; virtual Double_tGetErrorX(Int_t bin) const; virtual Double_tGet",MatchSource.WIKI,root/html602/TGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraph.html
Deployability,release,released,"h with new attributes. void DrawGraph(Int_t n, const Double_t* x = 0, const Double_t* y = 0, Option_t* option = """"); Draw this graph with new attributes. void DrawPanel(); Display a panel with all graph drawing options. Double_t Eval(Double_t x, TSpline* spline = 0, Option_t* option = """") const; Interpolate points in this graph at x using a TSpline; -if spline==0 and option="""" a linear interpolation between the two points; close to x is computed. If x is outside the graph range, a linear; extrapolation is computed.; -if spline==0 and option=""S"" a TSpline3 object is created using this graph; and the interpolated value from the spline is returned.; the internally created spline is deleted on return.; -if spline is specified, it is used to return the interpolated value. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a graph is clicked with the locator. If Left button clicked on one of the line end points, this point; follows the cursor until button is released. if Middle button clicked, the line is moved parallel to itself; until the button is released. void Expand(Int_t newsize); If array sizes <= newsize, expand storage to 2*newsize. void Expand(Int_t newsize, Int_t step); If graph capacity is less than newsize points then make array sizes; equal to least multiple of step to contain newsize points.; Returns kTRUE if size was altered. Double_t ** ExpandAndCopy(Int_t size, Int_t iend); if size > fMaxSize allocate new arrays of 2*size points; and copy oend first points.; Return pointer to new arrays. void FillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE); Set zero values for point arrays in the range [begin, end); Should be redefined in descendant classes. TObject * FindObject(const char* name) const; Search object named name in the list of functions. TObject * FindObject(const TObject* obj) const; Search object obj in the list of functions. TFitResultPtr Fit(const char* formula,",MatchSource.WIKI,root/html602/TGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraph.html
Energy Efficiency,allocate,allocate,"n is computed.; -if spline==0 and option=""S"" a TSpline3 object is created using this graph; and the interpolated value from the spline is returned.; the internally created spline is deleted on return.; -if spline is specified, it is used to return the interpolated value. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a graph is clicked with the locator. If Left button clicked on one of the line end points, this point; follows the cursor until button is released. if Middle button clicked, the line is moved parallel to itself; until the button is released. void Expand(Int_t newsize); If array sizes <= newsize, expand storage to 2*newsize. void Expand(Int_t newsize, Int_t step); If graph capacity is less than newsize points then make array sizes; equal to least multiple of step to contain newsize points.; Returns kTRUE if size was altered. Double_t ** ExpandAndCopy(Int_t size, Int_t iend); if size > fMaxSize allocate new arrays of 2*size points; and copy oend first points.; Return pointer to new arrays. void FillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE); Set zero values for point arrays in the range [begin, end); Should be redefined in descendant classes. TObject * FindObject(const char* name) const; Search object named name in the list of functions. TObject * FindObject(const TObject* obj) const; Search object obj in the list of functions. TFitResultPtr Fit(const char* formula, Option_t* option = """", Option_t* goption = """", Axis_t xmin = 0, Axis_t xmax = 0); Fit this graph with function with name fname. interface to TGraph::Fit(TF1 *f1... fname is the name of an already predefined function created by TF1 or TF2; Predefined functions such as gaus, expo and poln are automatically; created by ROOT.; fname can also be a formula, accepted by the linear fitter (linear parts divided; by ""++"" sign), for example ""x++sin(x)"" for fitting ""[0]*x+[1]*sin(x)"". TFitResultPtr Fit(TF1* f1,",MatchSource.WIKI,root/html602/TGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraph.html
Integrability,interface,interface,"sed. void Expand(Int_t newsize); If array sizes <= newsize, expand storage to 2*newsize. void Expand(Int_t newsize, Int_t step); If graph capacity is less than newsize points then make array sizes; equal to least multiple of step to contain newsize points.; Returns kTRUE if size was altered. Double_t ** ExpandAndCopy(Int_t size, Int_t iend); if size > fMaxSize allocate new arrays of 2*size points; and copy oend first points.; Return pointer to new arrays. void FillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE); Set zero values for point arrays in the range [begin, end); Should be redefined in descendant classes. TObject * FindObject(const char* name) const; Search object named name in the list of functions. TObject * FindObject(const TObject* obj) const; Search object obj in the list of functions. TFitResultPtr Fit(const char* formula, Option_t* option = """", Option_t* goption = """", Axis_t xmin = 0, Axis_t xmax = 0); Fit this graph with function with name fname. interface to TGraph::Fit(TF1 *f1... fname is the name of an already predefined function created by TF1 or TF2; Predefined functions such as gaus, expo and poln are automatically; created by ROOT.; fname can also be a formula, accepted by the linear fitter (linear parts divided; by ""++"" sign), for example ""x++sin(x)"" for fitting ""[0]*x+[1]*sin(x)"". TFitResultPtr Fit(TF1* f1, Option_t* option = """", Option_t* goption = """", Axis_t xmin = 0, Axis_t xmax = 0); Fit this graph with function f1. f1 is an already predefined function created by TF1.; Predefined functions such as gaus, expo and poln are automatically; created by ROOT. The list of fit options is given in parameter option.; option = ""W"" Set all weights to 1; ignore error bars; = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" User defined parameter settings are used for predefined functio",MatchSource.WIKI,root/html602/TGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraph.html
Performance,perform,performed,". TGraph. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraph. class TGraph: public TNamed, public TAttLine, public TAttFill, public TAttMarker. Graph class; A Graph is a graphics object made of two arrays X and Y with npoints each. The TGraph painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. Note:Unlike histogram or tree (or even TGraph2D), TGraph objects; are not automatically attached to the current TFile, in order to keep the; management and size of the TGraph has small as possible. The picture below gives an example:. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""A Simple Graph Example"",200,10,700,500);; Double_t x[100], y[100];; Int_t n = 20;; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; gr = new TGraph(n,x,y);; gr->Draw(""AC*"");; return c1;; } . Function Members (Methods); public:. virtual~TGraph(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(TF1* f); virtual voidBrowse(TBrowser* b); virtual Double_tChisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; static Bool_tCompareArg(const TGraph* gr, Int_t left, Int_t right); static Bool_tCompareRadius(const TGraph* gr, Int_t left, Int_t right); static Bool_tCompareX(const TGraph* gr, Int_t left, Int_t right); static Bool_tCompareY(const TGraph* gr, Int_t left, Int_t right); virtual voidComputeRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; virtual voidTNamed::Copy(TObject& named) co",MatchSource.WIKI,root/html602/TGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraph.html
Safety,avoid,avoid,"ith points computed; at the fNpx points of f.; if option ==""d"", a TGraph is created with points computed with the derivatives; at the fNpx points of f.; if option ==""i"", a TGraph is created with points computed with the integral; at the fNpx points of f.; if option ==""I"", a TGraph is created with points computed with the integral; at the fNpx+1 points of f and the integral is normalized to 1. TGraph(const char* filename, const char* format = ""%lg %lg"", Option_t* option = """"); Graph constructor reading input from filename.; filename is assumed to contain at least two columns of numbers.; the string format is by default ""%lg %lg"".; this is a standard c formatting for scanf. If columns of numbers should be; skipped, a ""%*lg"" or ""%*s"" for each column can be added,; e.g. ""%lg %*lg %lg"" would read x-values from the first and y-values from; the third column.; For files separated by a specific delimiter different from ' ' and '\t' (e.g. ';' in csv files); you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; e.g. option="" \t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';'); used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; Note in that case, the instanciation is about 2 times slower. ~TGraph(); Graph default destructor. Double_t** AllocateArrays(Int_t Narrays, Int_t arraySize); Allocate arrays. void Apply(TF1* f); Apply function f to all the data points; f may be a 1-D function TF1 or 2-d function TF2; The Y values of the graph are replaced by the new values computed; using the function. void Browse(TBrowser* b); Browse. Double_t Chisquare(TF1* f1, Option_t* option = """") const; Return the chisquare of this graph with respect to f1.; The chisquare is computed as the sum of the quantity below at each point:. where x and y are the graph point coordinates and f1'(x) is the derivative of function f1(x).; This method to approximate the uncertainty in y because of the errors in x, is called; ""effe",MatchSource.WIKI,root/html602/TGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraph.html
Security,access,access,"ions the errors in x willnot be considere.; If errors in x are important, go through minuit (use option ""F"" for polynomial fitting). 5) When fitting a TGraph (i.e. no errors associated with each point),; a correction is applied to the errors on the parameters with the following; formula:; errorp *= sqrt(chisquare/(ndf-1)). Access to the fit result. The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; By default the TFitResultPtr contains only the status of the fit which is return by an; automatic conversion of the TFitResultPtr to an integer. One can write in this case; directly:; Int_t fitStatus = h->Fit(myFunc). If the option ""S"" is instead used, TFitResultPtr contains the TFitResult and behaves; as a smart pointer to it. For example one can do:; TFitResultPtr r = h->Fit(myFunc,""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Value(0); // retrieve the value for the parameter 0; Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; from the fitted function.; If the histogram is made persistent, the list of; associated functions is also persistent. Given a pointer (see above); to an associated function myfunc, one can retrieve the function/fit; parameters with calls such as:; Double_t chi2 = myfunc->GetChisquare();; Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; Double_t err0 = myfunc->GetParError(0); //error on first parameter. Access to the fit status. The status of the fit can be obtained converting the TFitResultPtr to an integer; indipendently if the fit option ""S"" is used or not:; TFitResultPtr r = h->Fit(myFunc,opt);; Int_t fitStatus = r;. The fitStatus is 0 if the fit is O",MatchSource.WIKI,root/html602/TGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraph.html
Testability,test,test,"(Int_t first = 0, Int_t last = -1) const; Integrate the TGraph data within a given (index) range; Note that this function computes the area of the polygon enclosed by the points of the TGraph.; The polygon segments, which are defined by the points of the TGraph, do not need to form a closed polygon,; since the last polygon segment, which closes the polygon, is taken as the line connecting the last TGraph point; with the first one. It is clear that the order of the point is essential in defining the polygon.; Also note that the segments should not intersect. NB: if last=-1 (default) last is set to the last point.; if (first <0) the first point (0) is taken. Method:; There are many ways to calculate the surface of a polygon. It all depends on what kind of data; you have to deal with. The most evident solution would be to divide the polygon in triangles and; calculate the surface of them. But this can quickly become complicated as you will have to test; every segments of every triangles and check if they are intersecting with a current polygon's; segment or if it goes outside the polygon. Many calculations that would lead to many problems...; The solution (implemented by R.Brun); Fortunately for us, there is a simple way to solve this problem, as long as the polygon's; segments don't intersect.; It takes the x coordinate of the current vertex and multiply it by the y coordinate of the next; vertex. Then it subtracts from it the result of the y coordinate of the current vertex multiplied; by the x coordinate of the next vertex. Then divide the result by 2 to get the surface/area.; Sources; http://forums.wolfram.com/mathgroup/archive/1998/Mar/msg00462.html; http://stackoverflow.com/questions/451426/how-do-i-calculate-the-surface-area-of-a-2d-polygon. Int_t IsInside(Double_t x, Double_t y) const; Return 1 if the point (x,y) is inside the polygon defined by; the graph vertices 0 otherwise. Algorithm:; The loop is executed with the end-point coordinates of a line segment; (",MatchSource.WIKI,root/html602/TGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraph.html
Usability,simpl,simple," is projected along the y-direction by calculating the function at the points x-exlow and; x+exhigh. The chisquare is then computed as the sum of the quantity below at each point:. where x and y are the point coordinates, and f'(x) is the derivative of the; function f(x). In case the function lies below (above) the data point, ey is ey_low (ey_high). thanks to Andy Haas (haas@yahoo.com) for adding the case with TGraphAsymmErrors; University of Washington. The approach used to approximate the uncertainty in y because of the; errors in x is to make it equal the error in x times the slope of the line.; The improvement, compared to the first method (f(x+ exhigh) - f(x-exlow))/2; is of (error of x)**2 order. This approach is called ""effective variance method"".; This improvement has been made in version 4.00/08 by Anna Kreshuk.; The implementation is provided in the function FitUtil::EvaluateChi2Effective. NOTE:; 1) By using the ""effective variance"" method a simple linear regression; becomes a non-linear case, which takes several iterations; instead of 0 as in the linear case. 2) The effective variance technique assumes that there is no correlation; between the x and y coordinate. 3) The standard chi2 (least square) method without error in the coordinates (x) can; be forced by using option ""EX0"". 4) The linear fitter doesn't take into account the errors in x. When fitting a; TGraphErrors with a linear functions the errors in x willnot be considere.; If errors in x are important, go through minuit (use option ""F"" for polynomial fitting). 5) When fitting a TGraph (i.e. no errors associated with each point),; a correction is applied to the errors on the parameters with the following; formula:; errorp *= sqrt(chisquare/(ndf-1)). Access to the fit result. The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; By default the TFitResultPtr contains only the status of the fit which is return by an; automatic conversion of the TFitResultPtr to an in",MatchSource.WIKI,root/html602/TGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraph.html
Availability,error,error,"nst char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TFitResultPtrFit(const char* formula, Option_t* option = """", Option_t* goption = """")MENU ; virtual TFitResultPtrFit(TF2* f2, Option_t* option = """", Option_t* goption = """")MENU ; virtual voidFitPanel()MENU ; TList*GetContourList(Double_t contour); TDirectory*GetDirectory() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tGetErrorX(Int_t bin) const; virtual Double_tGetErrorY(Int_t bin) const; virtual Double_tGetErrorZ(Int_t bin) const; virtual Double_t*GetEX() const; virtual Double_t*GetEY() const; virtual Double_t*GetEZ() const; virtual Color_tTAtt",MatchSource.WIKI,root/html602/TGraph2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraph2D.html
Energy Efficiency,allocate,allocated,"e filled via; calls to SetPoint. TGraph2D(const char* filename, const char* format = ""%lg %lg %lg"", Option_t* option = """"); Graph2D constructor reading input from filename; filename is assumed to contain at least three columns of numbers.; For files separated by a specific delimiter different from ' ' and '\t' (e.g. ';' in csv files); you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; e.g. option="" \t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';'); used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; Note in that case, the instanciation is about 2 times slower. TGraph2D(const TGraph2D& ); Graph2D copy constructor.; copy everything apart from the list of contained functions. ~TGraph2D(); TGraph2D destructor. TGraph2D& operator=(const TGraph2D& ); Graph2D operator ""="". void Build(Int_t n); Creates the 2D graph basic data structure. void Browse(TBrowser* ); Browse. void Clear(Option_t* option = """"); Free all memory allocated by this object. void DirectoryAutoAdd(TDirectory* ); Perform the automatic addition of the graph to the given directory. Note this function is called in place when the semantic requires; this object to be added to a directory (I.e. when being read from; a TKey or being Cloned). Int_t DistancetoPrimitive(Int_t px, Int_t py); Computes distance from point px,py to a graph. void Draw(Option_t* option = """"); Specific drawing options can be used to paint a TGraph2D:. ""TRI"" : The Delaunay triangles are drawn using filled area.; An hidden surface drawing technique is used. The surface is; painted with the current fill area color. The edges of each; triangles are painted with the current line color.; ""TRIW"" : The Delaunay triangles are drawn as wire frame; ""TRI1"" : The Delaunay triangles are painted with color levels. The edges; of each triangles are painted with the current line color.; ""TRI2"" : the Delaunay triangles are painted with color levels.; ""P"" : Draw a marker a",MatchSource.WIKI,root/html602/TGraph2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraph2D.html
Integrability,depend,depending,"n interpolated 2D histogram.; If the ""empty"" option is selected, returns an empty histogram booked with; the limits of fX, fY and fZ. This option is used when the data set is; drawn with markers only. In that particular case there is no need to; find the Delaunay triangles. Double_t GetXmax() const; Returns the X maximum. Double_t GetXmin() const; Returns the X minimum. Double_t GetYmax() const; Returns the Y maximum. Double_t GetYmin() const; Returns the Y minimum. Double_t GetZmax() const; Returns the Z maximum. Double_t GetZmin() const; Returns the Z minimum. Double_t Interpolate(Double_t x, Double_t y); Finds the z value at the position (x,y) thanks to; the Delaunay interpolation. void Paint(Option_t* option = """"); Paints this 2D graph with its current attributes. TH1 * Project(Option_t* option = ""x"") const; Projects a 2-d graph into 1 or 2-d histograms depending on the; option parameter; option may contain a combination of the characters x,y,z; option = ""x"" return the x projection into a TH1D histogram; option = ""y"" return the y projection into a TH1D histogram; option = ""xy"" return the x versus y projection into a TH2D histogram; option = ""yx"" return the y versus x projection into a TH2D histogram. Int_t RemovePoint(Int_t ipoint); Deletes point number ipoint. void SavePrimitive(ostream& out, Option_t* option = """"); Saves primitive as a C++ statement(s) on output stream out. void Set(Int_t n); Set number of points in the 2D graph.; Existing coordinates are preserved.; New coordinates above fNpoints are preset to 0. void SetDirectory(TDirectory* dir); By default when an 2D graph is created, it is added to the list; of 2D graph objects in the current directory in memory.; This method removes reference to this 2D graph from current directory and add; reference to new directory dir. dir can be 0 in which case the; 2D graph does not belong to any directory. void SetHistogram(TH2* h); Sets the histogram to be filled.; If the 2D graph needs to be save in a TFile the fo",MatchSource.WIKI,root/html602/TGraph2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraph2D.html
Modifiability,extend,extended,"Marker. Graph 2D class; A Graph2D is a graphics object made of three arrays X, Y and Z with the same; number of points each. This class has different constructors:. With an array's dimension and three arrays x, y, and z:. TGraph2D *g = new TGraph2D(n, x, y, z);. x, y, z arrays can be doubles, floats, or ints.; With an array's dimension only:. TGraph2D *g = new TGraph2D(n);. The internal arrays are then filled with SetPoint. The following line; fills the the internal arrays at the position ""i"" with the values x,y,z. g->SetPoint(i, x, y, z);. Without parameters:. TGraph2D *g = new TGraph2D();. again SetPoint must be used to fill the internal arrays.; From a file:. TGraph2D *g = new TGraph2D(""graph.dat"");. Arrays are read from the ASCII file ""graph.dat"" according to a specifies; format. The format's default value is ""%lg %lg %lg"". Note that in any of these three cases, SetPoint can be used to change a data; point or add a new one. If the data point index (i) is greater than the; current size of the internal arrays, they are automatically extended. Specific drawing options can be used to paint a TGraph2D:. ""TRI""; The Delaunay triangles are drawn using filled area.; An hidden surface drawing technique is used. The surface is; painted with the current fill area color. The edges of each; triangles are painted with the current line color. ""TRIW; The Delaunay triangles are drawn as wire frame. ""TRI1; The Delaunay triangles are painted with color levels. The edges; of each triangles are painted with the current line color. ""TRI2; the Delaunay triangles are painted with color levels. ""P"" ; Draw a marker at each vertex. ""P0"" ; Draw a circle at each vertex. Each circle background is white. ""PCOL"" ; Draw a marker at each vertex. The color of each marker is; defined according to its Z position. ""CONT"" ; Draw contours. ""LINE"" ; Draw a 3D polyline. A TGraph2D can be also drawn with ANY options valid to draw a 2D histogram. When a TGraph2D is drawn with one of the 2D histogram drawing",MatchSource.WIKI,root/html602/TGraph2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraph2D.html
Safety,avoid,avoid,"HistoTrue when SetHistogram has been called. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGraph2D(); Graph2D default constructor. TGraph2D(Int_t n, Int_t* x, Int_t* y, Int_t* z); Graph2D constructor with three vectors of ints as input. TGraph2D(Int_t n, Float_t* x, Float_t* y, Float_t* z); Graph2D constructor with three vectors of floats as input. TGraph2D(Int_t n, Double_t* x, Double_t* y, Double_t* z); Graph2D constructor with three vectors of doubles as input. TGraph2D(TH2* h2); Graph2D constructor with a TH2 (h2) as input.; Only the h2's bins within the X and Y axis ranges are used.; Empty bins, recognized when both content and errors are zero, are excluded. TGraph2D(const char* name, const char* title, Int_t n, Double_t* x, Double_t* y, Double_t* z); Graph2D constructor with name, title and three vectors of doubles as input.; name : name of 2D graph (avoid blanks); title : 2D graph title; if title is of the form ""stringt;stringx;stringy;stringz""; the 2D graph title is set to stringt, the x axis title to stringx,; the y axis title to stringy,etc. TGraph2D(Int_t n); Graph2D constructor. The arrays fX, fY and fZ should be filled via; calls to SetPoint. TGraph2D(const char* filename, const char* format = ""%lg %lg %lg"", Option_t* option = """"); Graph2D constructor reading input from filename; filename is assumed to contain at least three columns of numbers.; For files separated by a specific delimiter different from ' ' and '\t' (e.g. ';' in csv files); you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; e.g. option="" \t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';'); used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; Note in that case, the instanciation is about 2 times slower. TGraph2D(const TGraph2D& ); Graph2D copy constructor.; copy everything apart from the list of contained functions. ~TGraph2D(); TGraph2D destructor. TGraph2D&",MatchSource.WIKI,root/html602/TGraph2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraph2D.html
Security,access,access,"); where MyFittingFunction is of type:; extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);. Associated functions. One or more object (typically a TF2*) can be added to the list; of functions (fFunctions) associated to each graph.; When TGraph::Fit is invoked, the fitted function is added to this list.; Given a graph gr, one can retrieve an associated function; with: TF2 *myfunc = gr->GetFunction(""myfunc"");. Access to the fit results. The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; By default the TFitResultPtr contains only the status of the fit and it converts automatically to an; integer. If the option ""S"" is instead used, TFitResultPtr contains the TFitResult and behaves as a smart; pointer to it. For example one can do:; TFitResultPtr r = graph->Fit(""myFunc"",""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t par0 = r->Value(0); // retrieve the value for the parameter 0; Double_t err0 = r->Error(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; from the fitted function.; If the graph is made persistent, the list of; associated functions is also persistent. Given a pointer (see above); to an associated function myfunc, one can retrieve the function/fit; parameters with calls such as:; Double_t chi2 = myfunc->GetChisquare();; Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; Double_t err0 = myfunc->GetParError(0); //error on first parameter. Fit Statistics. You can change the statistics box to display the fit parameters with; the TStyle::SetOptFit(mode) method. This mode has four digits.; mode = pcev (default = 0111); v = 1; print name/values of parameters; e = 1; print errors (if e=1, v must be 1); c = 1; print Chisquare/",MatchSource.WIKI,root/html602/TGraph2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraph2D.html
Availability,error,errors,". TGraph2DErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraph2DErrors. class TGraph2DErrors: public TGraph2D. Graph 2D class with errors; A TGraph2DErrors is a TGraph2D with errors. It behaves like a TGraph2D and has; the same drawing options. The ""ERR"" drawing option allows to display the error bars. The; following example shows how to use it:. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Graph2DErrors example"",0,0,600,600);; Double_t P = 6.;; Int_t np = 200;. Double_t *rx=0, *ry=0, *rz=0;; Double_t *ex=0, *ey=0, *ez=0;. rx = new Double_t[np];; ry = new Double_t[np];; rz = new Double_t[np];; ex = new Double_t[np];; ey = new Double_t[np];; ez = new Double_t[np];. TRandom *r = new TRandom();. for (Int_t N=0; N<np;N++) {; rx[N] = 2*P*(r->Rndm(N))-P;; ry[N] = 2*P*(r->Rndm(N))-P;; rz[N] = rx[N]*rx[N]-ry[N]*ry[N];; rx[N] = 10.+rx[N];; ry[N] = 10.+ry[N];; rz[N] = 40.+rz[N];; ex[N] = r->Rndm(N);; ey[N] = r->Rndm(N);; ez[N] = 10*r->Rndm(N);; }. TGraph2DErrors *dte = new TGraph2DErrors(np, rx, ry, rz, ex, ey, ez);; dte->SetTitle(""TGraph2D with error bars: option \""ERR\"""");; dte->SetFillColor(29);; dte->SetMarkerSize(0.8);; dte->SetMarkerStyle(20);; dte->SetMarkerColor(kRed);; dte->SetLineColor(kBlue-3);; dte->SetLineWidth(2);; dte->Draw(""err p0"");; gPad->SetLogy(1);; return c;; }. Function Members (Methods); public:. virtual~TGraph2DErrors(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGraph2D::Browse(TBrowser*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGraph2D::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtua",MatchSource.WIKI,root/html602/TGraph2DErrors.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraph2DErrors.html
Availability,error,error," virtual~TGraph2DPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TList*GetContourList(Double_t contour); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetO",MatchSource.WIKI,root/html602/TGraph2DPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraph2DPainter.html
Availability,error,error,". TGraphAsymmErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraphAsymmErrors. class TGraphAsymmErrors: public TGraph. TGraphAsymmErrors class; A TGraphAsymmErrors is a TGraph with assymetric error bars. The TGraphAsymmErrors painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. The picture below gives an example:. Picture; Source. {; c1 = new TCanvas(""c1"",""A Simple Graph with assymetric error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; return c1;; } . Function Members (Methods); public:. virtual~TGraphAsymmErrors(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(TF1* f); virtual voidBayesDivide(const TH1* pass, const TH1* total, Option_t* opt = """"); virtual voidTGraph::Browse(TBrowser* b); virtual Double_tTGraph::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; static Bo",MatchSource.WIKI,root/html602/TGraphAsymmErrors.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphAsymmErrors.html
Deployability,release,release,"ne by default if mode is set); - central: use central interval (done by default if mode is NOT set); - pois: interpret histograms as poisson ratio instead of efficiency; - e0 : plot (in Bayesian case) efficiency and interval for bins where total=0; (default is to skip them). Note:; Unfortunately there is no straightforward approach for determining a confidence; interval for a given confidence level. The actual coverage probability of the; confidence interval oscillates significantly according to the total number of; events and the true efficiency. In order to decrease the impact of this; oscillation on the actual coverage probability a couple of approximations and; methodes has been developped. For a detailed discussion, please have a look at; this statistical paper:. http://www-stat.wharton.upenn.edu/~tcai/paper/Binomial-StatSci.pdf. void ComputeRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; Compute Range. void CopyAndRelease(Double_t** newarrays, Int_t ibegin, Int_t iend, Int_t obegin); Copy and release. Bool_t CopyPoints(Double_t** arrays, Int_t ibegin, Int_t iend, Int_t obegin); Copy errors from fE*** to arrays[***]; or to f*** Copy points. Bool_t CtorAllocate(void); Should be called from ctors after fNpoints has been set; Note: This function should be called only from the constructor; since it does not delete previously existing arrays. Bool_t DoMerge(const TGraph* g); protected function to perform the merge operation of a graph with asymmetric errors. void FillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE); Set zero values for point arrays in the range [begin, end). Double_t GetErrorX(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorY(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along Y at point i. Double_t GetErrorXhigh(Int_t i) const; Get high error on X. Double_t GetErrorXlow(Int_t i) const; Get low error on",MatchSource.WIKI,root/html602/TGraphAsymmErrors.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphAsymmErrors.html
Integrability,depend,depends,"nted by Miroslav Helbich <helbich@mail.desy.de>. void BayesDivide(const TH1* pass, const TH1* total, Option_t* opt = """"); This function is only kept for backward compatibility.; You should rather use the Divide method.; It calls Divide(pass,total,""cl=0.683 b(1,1) mode"") which is equivalent to the; former BayesDivide method. void Divide(const TH1* pass, const TH1* total, Option_t* opt = ""cp""); Fill this TGraphAsymmErrors by dividing two 1-dimensional histograms pass/total. This method serves two purposes:. 1) calculating efficiencies:. The assumption is that the entries in ""pass"" are a subset of those in; ""total"". That is, we create an ""efficiency"" graph, where each entry is; between 0 and 1, inclusive. If the histograms are not filled with unit weights, the number of effective; entries is used to normalise the bin contents which might lead to wrong results.; . The points are assigned a x value at the center of each histogram bin.; The y values are for all options except for the; bayesian methods where the result depends on the chosen option. If the denominator becomes 0 or pass > total, the corresponding bin is; skipped. 2) calculating ratios of two Poisson means (option 'pois'):. The two histograms are interpreted as independent Poisson processes and the ratio; ; The histogram 'pass' is interpreted as n_{1} and the total histogram; is used for n_{2}. The (asymmetric) uncertainties of the Poisson ratio are linked to the uncertainties; of efficiency by a parameter transformation:; . The x errors span each histogram bin (lowedge ... lowedge+width); The y errors depend on the chosen statistic methode which can be determined; by the options given below. For a detailed description of the used statistic; calculations please have a look at the corresponding functions!. Options:; - v : verbose mode: prints information about the number of used bins; and calculated efficiencies with their errors; - cl=x : determine the used confidence level (0<x<1) (default is 0.683); - cp : ",MatchSource.WIKI,root/html602/TGraphAsymmErrors.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphAsymmErrors.html
Performance,perform,performed,". TGraphAsymmErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraphAsymmErrors. class TGraphAsymmErrors: public TGraph. TGraphAsymmErrors class; A TGraphAsymmErrors is a TGraph with assymetric error bars. The TGraphAsymmErrors painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. The picture below gives an example:. Picture; Source. {; c1 = new TCanvas(""c1"",""A Simple Graph with assymetric error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; return c1;; } . Function Members (Methods); public:. virtual~TGraphAsymmErrors(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(TF1* f); virtual voidBayesDivide(const TH1* pass, const TH1* total, Option_t* opt = """"); virtual voidTGraph::Browse(TBrowser* b); virtual Double_tTGraph::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; static Bo",MatchSource.WIKI,root/html602/TGraphAsymmErrors.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphAsymmErrors.html
Availability,error,error,". TGraphBentErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraphBentErrors. class TGraphBentErrors: public TGraph. TGraphBentErrors class; A TGraphBentErrors is a TGraph with bent, assymetric error bars. The TGraphBentErrors painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. The picture below gives an example:. Picture; Source. {; c1 = new TCanvas(""c1"",""A Simple Graph with bent error bars"",200,10,700,500);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; return c1;; } . Function Members (Methods); public:. virtual~TGraphBentErrors(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(TF1* f); virtual voidTGraph::Browse(TBrowser* b); virtual Double_tTGraph::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(c",MatchSource.WIKI,root/html602/TGraphBentErrors.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphBentErrors.html
Deployability,release,release,"nstructor. if exl,h or eyl,h are null, the corresponding arrays are preset to zero. TGraphBentErrors(Int_t n, const Double_t* x, const Double_t* y, const Double_t* exl = 0, const Double_t* exh = 0, const Double_t* eyl = 0, const Double_t* eyh = 0, const Double_t* exld = 0, const Double_t* exhd = 0, const Double_t* eyld = 0, const Double_t* eyhd = 0); TGraphBentErrors normal constructor. if exl,h or eyl,h are null, the corresponding arrays are preset to zero. ~TGraphBentErrors(); TGraphBentErrors default destructor. void Apply(TF1* f); apply a function to all data points; y = f(x,y). Errors are calculated as eyh = f(x,y+eyh)-f(x,y) and; eyl = f(x,y)-f(x,y-eyl). Special treatment has to be applied for the functions where the; role of ""up"" and ""down"" is reversed.; function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>. void ComputeRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; Compute range. void CopyAndRelease(Double_t** newarrays, Int_t ibegin, Int_t iend, Int_t obegin); Copy and release. Bool_t CopyPoints(Double_t** arrays, Int_t ibegin, Int_t iend, Int_t obegin); Copy errors from fE*** to arrays[***]; or to f*** Copy points. Bool_t CtorAllocate(void); Should be called from ctors after fNpoints has been set. Bool_t DoMerge(const TGraph* g); protected function to perform the merge operation of a graph with asymmetric errors. Double_t GetErrorX(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorY(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along Y at point i. Double_t GetErrorXhigh(Int_t bin) const; Get high error on X[i]. Double_t GetErrorXlow(Int_t bin) const; Get low error on X[i]. Double_t GetErrorYhigh(Int_t bin) const; Get high error on Y[i]. Double_t GetErrorYlow(Int_t bin) const; Get low error on Y[i]. void FillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE); Set zero values for point arrays in",MatchSource.WIKI,root/html602/TGraphBentErrors.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphBentErrors.html
Performance,perform,performed,". TGraphBentErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraphBentErrors. class TGraphBentErrors: public TGraph. TGraphBentErrors class; A TGraphBentErrors is a TGraph with bent, assymetric error bars. The TGraphBentErrors painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. The picture below gives an example:. Picture; Source. {; c1 = new TCanvas(""c1"",""A Simple Graph with bent error bars"",200,10,700,500);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; return c1;; } . Function Members (Methods); public:. virtual~TGraphBentErrors(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(TF1* f); virtual voidTGraph::Browse(TBrowser* b); virtual Double_tTGraph::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(c",MatchSource.WIKI,root/html602/TGraphBentErrors.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphBentErrors.html
Availability,error,error," virtual~TGraphDelaunay(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tComputeZ(Double_t x, Double_t y); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MEN",MatchSource.WIKI,root/html602/TGraphDelaunay.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphDelaunay.html
Performance,perform,performed,"ContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfAllTri!True if FindAllTriangles() has been performed on fGraph2D; Double_t*fDist!Array used to order mass points by distance; TGraph2D*fGraph2D!2D graph containing the user data; Int_t*fHullPoints!Hull points of size fNhull; Bool_tfInit!True if CreateTrianglesDataStructure() and FindHull() have been performed; Int_t*fMTried!; Int_tfMaxIter!Maximum number of iterations to find Delaunay triangles; Int_t*fNTried!Delaunay triangles storage of size fNdt; TStringTNamed::fNameobject identifier; Int_tfNdt!Number of Delaunay triangles found; Int_tfNhull!Number of points in the hull; Int_tfNpoints!Number of data points in fGraph2D; Int_t*fOrder!Array used to order mass points by distance; Int_t*fPTried!; TStringTNamed::fTitleobject title; Int_tfTriedSize!Real size of the fxTried arrays; Double_t*fX!Pointer to fGraph2D->fX; Double_t*fXN!fGraph2D vectors normalized of size fNpoints; Double_tfXNmax!Maximum value of fXN; Double_tfXNmin!Minimum value of fXN; Double_tfXScaleFactor!; Double_tfXoffset!; Double_t*fY!Pointer to fGraph2D->fY; Double_t*fYN!fGraph2D vectors normalized of size fNpoints; Double_tfYNmax!Maximum value of fYN; Double_tfYNmin!Minimum value of fYN; Double_tfYScaleFactor!; Double_tfYoffset!Parameters used to normalize user data; Double_t*fZ!Pointer to fGraph2D->fZ; Double_tfZout!Histogram bin height for points lying outside the convex hull. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGraphDelaunay(); TGraphDelaunay default constructor. TGraphDelaunay(TGraph2D* g); TGraphDelaunay normal constructor. ~TGraphDelaunay(); TGraphDelaunay destructor. Double_t ComputeZ(Double_t x, Double_t y); Return the z va",MatchSource.WIKI,root/html602/TGraphDelaunay.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphDelaunay.html
Testability,test,tested,"non-shared sides. Fiddling with; the size of the `alittlebit' parameter may help. void FindHull(); Finds those points which make up the convex hull of the set. If the xy; plane were a sheet of wood, and the points were nails hammered into it; at the respective coordinates, then if an elastic band were stretched; over all the nails it would form the shape of the convex hull. Those; nails in contact with it are the points that make up the hull. Bool_t InHull(Int_t E, Int_t X) const; Is point e inside the hull defined by all points apart from x ?. Double_t InterpolateOnPlane(Int_t TI1, Int_t TI2, Int_t TI3, Int_t E) const; Finds the z-value at point e given that it lies; on the plane defined by t1,t2,t3. Double_t Interpolate(Double_t x, Double_t y); Finds the Delaunay triangle that the point (xi,yi) sits in (if any) and; calculate a z-value for it by linearly interpolating the z-values that; make up that triangle. void SetMaxIter(Int_t n = 100000); Defines the number of triangles tested for a Delaunay triangle; (number of iterations) before abandoning the search. void SetMarginBinsContent(Double_t z = 0.); Sets the histogram bin height for points lying outside the convex hull ie:; the bins in the margin. TGraphDelaunay(const TGraphDelaunay& ). TGraphDelaunay& operator=(const TGraphDelaunay& ). TGraph2D * GetGraph2D() const; {return fGraph2D;}. Double_t GetMarginBinsContent() const; {return fZout;}. Int_t GetNdt() const; {return fNdt;}. Int_t * GetPTried() const; {return fPTried;}. Int_t * GetNTried() const; {return fNTried;}. Int_t * GetMTried() const; {return fMTried;}. Double_t * GetXN() const; {return fXN;}. Double_t * GetYN() const; {return fYN;}. Double_t GetXNmin() const; {return fXNmin;}. Double_t GetXNmax() const; {return fXNmax;}. Double_t GetYNmin() const; {return fYNmin;}. Double_t GetYNmax() const; {return fYNmax;}. » Author: Olivier Couet, Luke Jones (Royal Holloway, University of London) » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last ",MatchSource.WIKI,root/html602/TGraphDelaunay.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphDelaunay.html
Availability,error,error,"onst; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidCreateGVEdge(GVizAgraph_t* gv); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); GVizAgedge_t*GetGVEdge(); virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; TGraphNode*GetNode1(); TGraphNode*GetNode2(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObjec",MatchSource.WIKI,root/html602/TGraphEdge.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphEdge.html
Performance,perform,performed,"ey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_tfArrXArrow X position; Double_tfArrYArrow Y position; GVizAgedge_t*fGVEdgeGraphviz edge; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_t*fNnumber of edge points (GV); TGraphNode*fNode1First node; TGraphNode*fNode2Second node; Double_t*fXX edge points (GV); Double_t*fYX edge points (GV). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGraphEdge(); Graph Edge default constructor. TGraphEdge(TGraphNode* n1, TGraphNode* n2); Graph Edge normal constructor. ~TGraphEdge(); Graph Edge default destructor. void CreateGVEdge(GVizAgraph_t* gv); Create the GraphViz edge into the GraphViz data structure gv. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to an edge. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. void Layout(); Layout this edge in the GraphViz space. This is done after gvLayout; has been performed. void Paint(Option_t* option = """"); Paint this edge with its current attributes. void SavePrimitive(ostream& , Option_t* ); Save primitive as a C++ statement(s) on output stream out. void SaveAttributes(ostream& , const char* ); Save attributes as a C++ statement(s) on output stream out; called by TGraphStruct::SavePrimitive. void Streamer(TBuffer& ). TGraphEdge(). void SetGVEdge(GVizAgedge_t* gve); {fGVEdge = gve;}. GVizAgedge_t * GetGVEdge(); {return fGVEdge;}. TGraphNode * GetNode1(); {return fNode1;}. TGraphNode * GetNode2(); {return fNode2;}. » Author: Olivier Couet 13/07/09 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-30 15:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGraphEdge.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphEdge.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGraphEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphEditor.html
Usability,simpl,simple,". TGraphEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGraphEditor. class TGraphEditor: public TGedFrame. TGraphEditor. Implements GUI for graph attributes. Title': set the title of the graph; Change the Shape of the graph:; 'No Line' = "" "": just draw unconnected points; 'Simple Line' = ""L"":simple poly line between every point is drawn; 'Smooth Line' = ""C"":smooth curve is drawn; 'Bar Chart' = ""B"": A bar chart is drawn at each point; 'Fill Area' = ""F"": A fill area is drawn; Check box: 'Marker On/Off' Set Marker visible/invisible. /*. */. Function Members (Methods); public:. virtual~TGraphEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject:",MatchSource.WIKI,root/html602/TGraphEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphEditor.html
Availability,error,error,". TGraphErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraphErrors. class TGraphErrors: public TGraph. TGraphErrors class; A TGraphErrors is a TGraph with error bars. The TGraphErrors painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. The picture below gives an example:. Picture; Source. {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; return c1;; } . Function Members (Methods); public:. virtual~TGraphErrors(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(TF1* f); virtual voidTGraph::Browse(TBrowser* b); static Int_tCalculateScanfFields(const char* fmt); virtual Double_tTGraph::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; static Bool_tTGraph::CompareArg(const TGraph* gr, Int_t left, Int_t right); static Bool_tTGraph::CompareRadius(const TGraph* gr, Int_t left, Int_t right); static Bool_tTGraph::CompareX(const TGraph* gr, Int_t left, Int_t right); st",MatchSource.WIKI,root/html602/TGraphErrors.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphErrors.html
Deployability,release,release,"rgument,; e.g. option="" \t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';'); used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; Note in that case, the instanciation is about 2 times slower.; In case a delimiter is specified, the format ""%lg %lg %lg"" will read X,Y,EX. ~TGraphErrors(); TGraphErrors default destructor. void Apply(TF1* f); apply function to all the data points; y = f(x,y). The error is calculated as ey=(f(x,y+ey)-f(x,y-ey))/2; This is the same as error(fy) = df/dy * ey for small errors. For generic functions the symmetric errors might become non-symmetric; and are averaged here. Use TGraphAsymmErrors if desired. error on x doesn't change; function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>. Int_t CalculateScanfFields(const char* fmt); Calculate scan fields. void ComputeRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; Compute range. void CopyAndRelease(Double_t** newarrays, Int_t ibegin, Int_t iend, Int_t obegin); Copy and release. Bool_t CopyPoints(Double_t** arrays, Int_t ibegin, Int_t iend, Int_t obegin); Copy errors from fEX and fEY to arrays[0] and arrays[1]; or to fX and fY. Copy points. Bool_t CtorAllocate(); Constructor allocate.; Note: This function should be called only from the constructor; since it does not delete previously existing arrays. Bool_t DoMerge(const TGraph* g); protected function to perform the merge operation of a graph with errors. void FillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE); Set zero values for point arrays in the range [begin, end]. Double_t GetErrorX(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorY(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along Y at point i. Double_t GetErrorXhigh(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t G",MatchSource.WIKI,root/html602/TGraphErrors.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphErrors.html
Energy Efficiency,allocate,allocate,"case a delimiter is specified, the format ""%lg %lg %lg"" will read X,Y,EX. ~TGraphErrors(); TGraphErrors default destructor. void Apply(TF1* f); apply function to all the data points; y = f(x,y). The error is calculated as ey=(f(x,y+ey)-f(x,y-ey))/2; This is the same as error(fy) = df/dy * ey for small errors. For generic functions the symmetric errors might become non-symmetric; and are averaged here. Use TGraphAsymmErrors if desired. error on x doesn't change; function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>. Int_t CalculateScanfFields(const char* fmt); Calculate scan fields. void ComputeRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; Compute range. void CopyAndRelease(Double_t** newarrays, Int_t ibegin, Int_t iend, Int_t obegin); Copy and release. Bool_t CopyPoints(Double_t** arrays, Int_t ibegin, Int_t iend, Int_t obegin); Copy errors from fEX and fEY to arrays[0] and arrays[1]; or to fX and fY. Copy points. Bool_t CtorAllocate(); Constructor allocate.; Note: This function should be called only from the constructor; since it does not delete previously existing arrays. Bool_t DoMerge(const TGraph* g); protected function to perform the merge operation of a graph with errors. void FillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE); Set zero values for point arrays in the range [begin, end]. Double_t GetErrorX(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorY(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along Y at point i. Double_t GetErrorXhigh(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorXlow(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorYhigh(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at ",MatchSource.WIKI,root/html602/TGraphErrors.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphErrors.html
Performance,perform,performed,". TGraphErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraphErrors. class TGraphErrors: public TGraph. TGraphErrors class; A TGraphErrors is a TGraph with error bars. The TGraphErrors painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. The picture below gives an example:. Picture; Source. {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; return c1;; } . Function Members (Methods); public:. virtual~TGraphErrors(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(TF1* f); virtual voidTGraph::Browse(TBrowser* b); static Int_tCalculateScanfFields(const char* fmt); virtual Double_tTGraph::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; static Bool_tTGraph::CompareArg(const TGraph* gr, Int_t left, Int_t right); static Bool_tTGraph::CompareRadius(const TGraph* gr, Int_t left, Int_t right); static Bool_tTGraph::CompareX(const TGraph* gr, Int_t left, Int_t right); st",MatchSource.WIKI,root/html602/TGraphErrors.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphErrors.html
Safety,avoid,avoid,"coord from vy; and the errors from vectors vex and vey.; The number of points in the graph is the minimum of number of points; in vx and vy. TGraphErrors(const TGraphErrors& gr); TGraphErrors copy constructor. TGraphErrors& operator=(const TGraphErrors& gr); TGraphErrors assignment operator. TGraphErrors(const TH1* h); TGraphErrors constructor importing its parameters from the TH1 object passed as argument. TGraphErrors(const char* filename, const char* format = ""%lg %lg %lg %lg"", Option_t* option = """"); GraphErrors constructor reading input from filename; filename is assumed to contain at least 3 columns of numbers; convention for format (default=""%lg %lg %lg %lg); format = ""%lg %lg"" read only 2 first columns into X,Y; format = ""%lg %lg %lg"" read only 3 first columns into X,Y and EY; format = ""%lg %lg %lg %lg"" read only 4 first columns into X,Y,EX,EY. For files separated by a specific delimiter different from ' ' and '\t' (e.g. ';' in csv files); you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; e.g. option="" \t,;"" for columns of figures separated by any of these characters (' ', '\t', ',', ';'); used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; Note in that case, the instanciation is about 2 times slower.; In case a delimiter is specified, the format ""%lg %lg %lg"" will read X,Y,EX. ~TGraphErrors(); TGraphErrors default destructor. void Apply(TF1* f); apply function to all the data points; y = f(x,y). The error is calculated as ey=(f(x,y+ey)-f(x,y-ey))/2; This is the same as error(fy) = df/dy * ey for small errors. For generic functions the symmetric errors might become non-symmetric; and are averaged here. Use TGraphAsymmErrors if desired. error on x doesn't change; function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>. Int_t CalculateScanfFields(const char* fmt); Calculate scan fields. void ComputeRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; Compute range. voi",MatchSource.WIKI,root/html602/TGraphErrors.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphErrors.html
Availability,error,error,"st; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidCreateGVNode(GVizAgraph_t* gv); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; GVizAgnode_t*GetGVNode(); virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Short_tT",MatchSource.WIKI,root/html602/TGraphNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphNode.html
Performance,perform,performed,"VNodeGraphviz node; Double_tfHNode height; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TStringTNamed::fNameobject identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; Double_tfWNode width; Double_tfXNode's center X coordinate; Double_tfYNode's center Y coordinate. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGraphNode(); Graph node default constructor. TGraphNode(const char* name, const char* title = """"); Graph node normal constructor. ~TGraphNode(); Graph Node default destructor. void CreateGVNode(GVizAgraph_t* gv); Create the GraphViz node into the GraphViz data structure gv. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a node. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. void Layout(); Layout this node in the GraphViz space. This is done after gvLayout; has been performed. void Paint(Option_t* option = """"); Paint this node with its current attributes. void SavePrimitive(ostream& , Option_t* ); Save primitive as a C++ statement(s) on output stream out. void SaveAttributes(ostream& ); Save attributes as a C++ statement(s) on output stream out; called by TGraphStruct::SavePrimitive. void Streamer(TBuffer& ). TGraphNode(). void SetGVNode(GVizAgnode_t* gvn); {fGVNode = gvn;}. void SetTextAngle(Float_t ); {;}. GVizAgnode_t * GetGVNode(); {return fGVNode;}. » Author: Olivier Couet 13/07/09 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-30 15:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGraphNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphNode.html
Availability,error,error,". TGraphPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HISTPAINTER; » TGraphPainter. class TGraphPainter: public TVirtualGraphPainter. The graph painter class. Introduction; Graphs' plotting options; Exclusion graphs; Graphs with error bars. TGraphErrors; TGraphAsymmErrors; TGraphBentErrors. TGraphPolar options. Introduction; Graphs are drawn via the painter TGraphPainter class. This class; implements techniques needed to display the various kind of; graphs i.e.: TGraph, TGraphErrors,; TGraphBentErrors and TGraphAsymmErrors. To draw a graph ""graph"" it's enough to do:. graph->Draw(""AL"");. The option ""AL"" in the Draw() method means:. The axis should be drawn (option ""A""),; The graph should be drawn as a simple line (option ""L""). By default a graph is drawn in the current pad in the current coordinate system.; To define a suitable coordinate system and draw the axis the option; ""A"" must be specified. TGraphPainter offers many options to paint the various kind of graphs. It is separated from the graph classes so that one can have graphs without the; graphics overhead, for example in a batch program. When a displayed graph is modified, there is no need to call; Draw() again; the image will be refreshed the next time the; pad will be updated.; A pad is updated after one of these three actions:. a carriage return on the ROOT command line,; a click inside the pad,; a call to TPad::Update. Graphs' plotting options; Graphs can be drawn with the following options:. ""A""; Axis are drawn around the graph. ""L""; A simple polyline is drawn. ""F""; A fill area is drawn ('CF' draw a smoothed fill area). ""C""; A smooth Curve is drawn. ""*""; A Star is plotted at each point. ""P""; The current marker is plotted at each point. ""B""; A Bar chart is drawn. ""1""; When a graph is drawn as a bar chart, this option makes ",MatchSource.WIKI,root/html602/TGraphPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphPainter.html
Deployability,update,updated,"otting options; Exclusion graphs; Graphs with error bars. TGraphErrors; TGraphAsymmErrors; TGraphBentErrors. TGraphPolar options. Introduction; Graphs are drawn via the painter TGraphPainter class. This class; implements techniques needed to display the various kind of; graphs i.e.: TGraph, TGraphErrors,; TGraphBentErrors and TGraphAsymmErrors. To draw a graph ""graph"" it's enough to do:. graph->Draw(""AL"");. The option ""AL"" in the Draw() method means:. The axis should be drawn (option ""A""),; The graph should be drawn as a simple line (option ""L""). By default a graph is drawn in the current pad in the current coordinate system.; To define a suitable coordinate system and draw the axis the option; ""A"" must be specified. TGraphPainter offers many options to paint the various kind of graphs. It is separated from the graph classes so that one can have graphs without the; graphics overhead, for example in a batch program. When a displayed graph is modified, there is no need to call; Draw() again; the image will be refreshed the next time the; pad will be updated.; A pad is updated after one of these three actions:. a carriage return on the ROOT command line,; a click inside the pad,; a call to TPad::Update. Graphs' plotting options; Graphs can be drawn with the following options:. ""A""; Axis are drawn around the graph. ""L""; A simple polyline is drawn. ""F""; A fill area is drawn ('CF' draw a smoothed fill area). ""C""; A smooth Curve is drawn. ""*""; A Star is plotted at each point. ""P""; The current marker is plotted at each point. ""B""; A Bar chart is drawn. ""1""; When a graph is drawn as a bar chart, this option makes the bars start from; the bottom of the pad. By default they start at 0. ""X+""; The X-axis is drawn on the top side of the plot. ""Y+""; The Y-axis is drawn on the right side of the plot. Drawing options can be combined. In the following example the graph; is drawn as a smooth curve (option ""C"") with markers (option ""P"") and; with axes (option ""A""). Picture; Source. {; ",MatchSource.WIKI,root/html602/TGraphPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphPainter.html
Integrability,rout,routine,"aph, Option_t* option). Paint this TGraphPolar with its current attributes.; . void PaintGraphQQ(TGraph* theGraph, Option_t* option). Paint this graphQQ. No options for the time being.; ; . void PaintGraphSimple(TGraph* theGraph, Option_t* option). Paint a simple graph, without errors bars.; ; . void PaintPolyLineHatches(TGraph* theGraph, Int_t n, const Double_t* x, const Double_t* y). Paint a polyline with hatches on one side showing an exclusion zone. x and y; are the the vectors holding the polyline and n the number of points in the; polyline and w the width of the hatches. w can be negative.; This method is not meant to be used directly. It is called automatically; according to the line style convention.; ; . void PaintStats(TGraph* theGraph, TF1* fit). Paint the statistics box with the fit info.; ; . void Smooth(TGraph* theGraph, Int_t npoints, Double_t* x, Double_t* y, Int_t drawtype). Smooth a curve given by N points.; ; The original code is from an underlaying routine for Draw based on the; CERN GD3 routine TVIPTE:; ; Author - Marlow etc. Modified by - P. Ward Date - 3.10.1973; ; This method draws a smooth tangentially continuous curve through; the sequence of data points P(I) I=1,N where P(I)=(X(I),Y(I)).; The curve is approximated by a polygonal arc of short vectors.; The data points can represent open curves, P(1) != P(N) or closed; curves P(2) == P(N). If a tangential discontinuity at P(I) is; required, then set P(I)=P(I+1). Loops are also allowed.; ; Reference Marlow and Powell, Harwell report No.R.7092.1972; MCCONALOGUE, Computer Journal VOL.13, NO4, NOV1970P p392 6; . npoints : Number of data points.; x : Abscissa; y : Ordinate; ; . TGraphPainter(). » Author: Olivier Couet » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/histpainter:$Id: TGraphPainter.h,v 1.00 » Last generated: 2015-06-30 15:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please",MatchSource.WIKI,root/html602/TGraphPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphPainter.html
Modifiability,variab,variables,"mous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGraphPainter(). Default constructor; ; . ~TGraphPainter(). Destructor.; ; . void ComputeLogs(Int_t npoints, Int_t opt). Compute the logarithm of global variables gxwork and gywork; according to the value of Options and put the results in the global; variables gxworkl and gyworkl.; ; npoints : Number of points in gxwork and in gywork.; ; opt = 1 ComputeLogs is called from PaintGrapHist; opt = 0 ComputeLogs is called from PaintGraph; ; . Int_t DistancetoPrimitiveHelper(TGraph* theGraph, Int_t px, Int_t py). Compute distance from point px,py to a graph.; ; Compute the closest distance of approach from point px,py to this line.; The distance is computed in pixels units.; ; . void DrawPanelHelper(TGraph* theGraph). Display a panel with all histogram drawing options.; ; . void ExecuteEventHelper(TGraph* theGraph, Int_t event, Int_t px, Int_t py). Execute action corresponding to one event.; ; This member function is called when a graph is clicked with the locator.; ; If the left mouse button is clicked on one of the line end points, this point; follows the cursor until button is released.; ; If the middle mouse button clicked, the line is moved parallel to itself; until the button is rele",MatchSource.WIKI,root/html602/TGraphPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphPainter.html
Testability,log,logarithm,"mous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGraphPainter(). Default constructor; ; . ~TGraphPainter(). Destructor.; ; . void ComputeLogs(Int_t npoints, Int_t opt). Compute the logarithm of global variables gxwork and gywork; according to the value of Options and put the results in the global; variables gxworkl and gyworkl.; ; npoints : Number of points in gxwork and in gywork.; ; opt = 1 ComputeLogs is called from PaintGrapHist; opt = 0 ComputeLogs is called from PaintGraph; ; . Int_t DistancetoPrimitiveHelper(TGraph* theGraph, Int_t px, Int_t py). Compute distance from point px,py to a graph.; ; Compute the closest distance of approach from point px,py to this line.; The distance is computed in pixels units.; ; . void DrawPanelHelper(TGraph* theGraph). Display a panel with all histogram drawing options.; ; . void ExecuteEventHelper(TGraph* theGraph, Int_t event, Int_t px, Int_t py). Execute action corresponding to one event.; ; This member function is called when a graph is clicked with the locator.; ; If the left mouse button is clicked on one of the line end points, this point; follows the cursor until button is released.; ; If the middle mouse button clicked, the line is moved parallel to itself; until the button is rele",MatchSource.WIKI,root/html602/TGraphPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphPainter.html
Usability,simpl,simple,". TGraphPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HISTPAINTER; » TGraphPainter. class TGraphPainter: public TVirtualGraphPainter. The graph painter class. Introduction; Graphs' plotting options; Exclusion graphs; Graphs with error bars. TGraphErrors; TGraphAsymmErrors; TGraphBentErrors. TGraphPolar options. Introduction; Graphs are drawn via the painter TGraphPainter class. This class; implements techniques needed to display the various kind of; graphs i.e.: TGraph, TGraphErrors,; TGraphBentErrors and TGraphAsymmErrors. To draw a graph ""graph"" it's enough to do:. graph->Draw(""AL"");. The option ""AL"" in the Draw() method means:. The axis should be drawn (option ""A""),; The graph should be drawn as a simple line (option ""L""). By default a graph is drawn in the current pad in the current coordinate system.; To define a suitable coordinate system and draw the axis the option; ""A"" must be specified. TGraphPainter offers many options to paint the various kind of graphs. It is separated from the graph classes so that one can have graphs without the; graphics overhead, for example in a batch program. When a displayed graph is modified, there is no need to call; Draw() again; the image will be refreshed the next time the; pad will be updated.; A pad is updated after one of these three actions:. a carriage return on the ROOT command line,; a click inside the pad,; a call to TPad::Update. Graphs' plotting options; Graphs can be drawn with the following options:. ""A""; Axis are drawn around the graph. ""L""; A simple polyline is drawn. ""F""; A fill area is drawn ('CF' draw a smoothed fill area). ""C""; A smooth Curve is drawn. ""*""; A Star is plotted at each point. ""P""; The current marker is plotted at each point. ""B""; A Bar chart is drawn. ""1""; When a graph is drawn as a bar chart, this option makes ",MatchSource.WIKI,root/html602/TGraphPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphPainter.html
Availability,error,error,". TGraphPolar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TGraphPolar. class TGraphPolar: public TGraphErrors. TGraphPolar : to draw a polar graph; TGraphPolar creates a polar graph (including error bars). A TGraphPolar is; a TGraphErrors represented in polar coordinates.; It uses the class TGraphPolargram to draw the polar axis. Example:. Picture; Source. {; TCanvas * CPol = new TCanvas(""CPol"",""TGraphPolar Example"",500,500);. Double_t theta[8];; Double_t radius[8];; Double_t etheta[8];; Double_t eradius[8];. for (int i=0; i<8; i++) {; theta[i] = (i+1)*(TMath::Pi()/4.);; radius[i] = (i+1)*0.05;; etheta[i] = TMath::Pi()/8.;; eradius[i] = 0.05;; }. TGraphPolar * grP1 = new TGraphPolar(8, theta, radius, etheta, eradius);; grP1->SetTitle(""TGraphPolar Example"");. grP1->SetMarkerStyle(20);; grP1->SetMarkerSize(2.);; grP1->SetMarkerColor(4);; grP1->SetLineColor(2);; grP1->SetLineWidth(3);; grP1->Draw(""PE"");. // Update, otherwise GetPolargram returns 0; CPol->Update();; grP1->GetPolargram()->SetToRadian();. return CPol;; } . Function Members (Methods); public:. virtual~TGraphPolar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGraphErrors::Apply(TF1* f); virtual voidTGraph::Browse(TBrowser* b); static Int_tTGraphErrors::CalculateScanfFields(const char* fmt); virtual Double_tTGraph::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; static Bool_tTGraph::CompareArg(const TGraph* gr, Int_t left, Int_t right); static Bool_tTGraph::CompareRadius(const TGraph* gr, Int_t left, Int_t ri",MatchSource.WIKI,root/html602/TGraphPolar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphPolar.html
Availability,error,error,"ual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidChangeRangePolar(Double_t tmin, Double_t tmax); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* options = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetAngle(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TNamed::GetName() const; Int_tGetNdivPolar(); Int_tGetNdivRadial(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Color_tGetPolarColorLabel(); Font_tGetPolarLabelFont(); Double_tGetPolarL",MatchSource.WIKI,root/html602/TGraphPolargram.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphPolargram.html
Usability,simpl,simplifed,"ax, Double_t tmin, Double_t tmax); TGraphPolargram Constructor. TGraphPolargram(const char* name = """"); Short constructor used in the case of a spider plot. ~TGraphPolargram(); TGraphPolargram destructor. void ChangeRangePolar(Double_t tmin, Double_t tmax); Set the Polar range.; tmin is the start number.; tmax is the end number. Int_t DistancetoPrimitive(Int_t px, Int_t py); Everything within the circle belongs to the TGraphPolargram. void Draw(Option_t* options = """"); Draw Polargram. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Indicate that there is something to click here. Int_t FindAlign(Double_t angle); Find the alignement rule to apply for TText::SetTextAlign(Short_t). Double_t FindTextAngle(Double_t theta); Determine the orientation of the polar labels according to their angle. void Init(); Initiallize some of the fields of TGraphPolargram. void Paint(Option_t* options = """"); Paint TGraphPolargram. void PaintCircle(Double_t x, Double_t y, Double_t r, Double_t phimin, Double_t phimax, Double_t theta); This is simplifed from TEllipse::PaintEllipse.; Draw this ellipse with new coordinates. void PaintPolarDivisions(Bool_t noLabels); Draw Polar divisions.; Check for editable pad or create default. void PaintRadialDivisions(Bool_t drawaxis); Paint radial divisions.; Check for editable pad or create default. void ReduceFraction(Int_t Num, Int_t Denom, Int_t& rnum, Int_t& rden); Reduce fractions. void SetAxisAngle(Double_t angle = 0); Set axis angle. void SetNdivPolar(Int_t Ndiv = 508); Set the number of Polar divisions: enter a number ij with 0<i<99; 0<j<99; i sets the major Polar divisions.; j sets the minor Polar divisions. void SetNdivRadial(Int_t Ndiv = 508); Set the number of radial divisions: enter a number ij with 0<i<99; 0<j<99; i sets the major radial divisions.; j sets the minor radial divisions. void SetPolarLabel(Int_t div, const TString& label); Set some specified polar labels, used in the case of a spider plot. void SetPolarLabelColor(Color_t tco",MatchSource.WIKI,root/html602/TGraphPolargram.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphPolargram.html
Availability,robust,robust,". TGraphQQ. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TGraphQQ. class TGraphQQ: public TGraph. This class allows to draw quantile-quantile plots. Plots can be drawn for 2 datasets or for a dataset and a theoretical; distribution function. 2 datasets:; Quantile-quantile plots are used to determine whether 2 samples come from; the same distribution.; A qq-plot draws the quantiles of one dataset against the quantile of the; the other. The quantiles of the dataset with fewer entries are on Y axis,; with more entries - on X axis.; A straight line, going through 0.25 and 0.75 quantiles is also plotted; for reference. It represents a robust linear fit, not sensitive to the; extremes of the datasets.; If the datasets come from the same distribution, points of the plot should; fall approximately on the 45 degrees line. If they have the same; distribution function, but location or scale different parameters,; they should still fall on the straight line, but not the 45 degrees one.; The greater their departure from the straight line, the more evidence there; is, that the datasets come from different distributions.; The advantage of qq-plot is that it not only shows that the underlying; distributions are different, but, unlike the analytical methods, it also; gives information on the nature of this difference: heavier tails,; different location/scale, different shape, etc. Some examples of qqplots of 2 datasets:. /*. */. 1 dataset:; Quantile-quantile plots are used to determine if the dataset comes from the; specified theoretical distribution, such as normal.; A qq-plot draws quantiles of the dataset against quantiles of the specified; theoretical distribution.; (NOTE, that density, not CDF should be specified); A straight line, going through 0.25 and 0.75 quantiles can also be plotted; for ",MatchSource.WIKI,root/html602/TGraphQQ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphQQ.html
Availability,error,error,"raphNode* n2); voidAddNode(TGraphNode* node); TGraphNode*AddNode(const char* name, const char* title = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidDumpAsDotFile(const char* filename); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfEdges() const; TList*GetListOfNodes() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; vi",MatchSource.WIKI,root/html602/TGraphStruct.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphStruct.html
Integrability,interface,interface,". TGraphStruct. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GVIZ; » TGraphStruct. class TGraphStruct: public TObject. Graph Structure class; The Graph Structure is an interface to the graphviz package. The graphviz package is a graph visualization system. This interface consists in; three classes:. TGraphStruct: holds the graph structure. It uses the graphiz library to; layout the graphs and the ROOT graphics to paint them.; TGraphNode: Is a graph node object which can be added in a TGraphStruct.; TGraphEdge: Is an edge object connecting two nodes which can be added in; a TGraphStruct. Picture; Source. // Draw a simple graph structure.; // The graph layout is made using graphviz. This macro creates some; // nodes and edges and change a few graphical attributes on some of them.; // Author: Olivier Couet; {; TGraphStruct *gs = new TGraphStruct();. // create some nodes and put them in the graph in one go ...; TGraphNode *n0 = gs->AddNode(""n0"",""Node 0"");; TGraphNode *n1 = gs->AddNode(""n1"",""First node"");; TGraphNode *n2 = gs->AddNode(""n2"",""Second node"");; TGraphNode *n3 = gs->AddNode(""n3"",""Third node"");; TGraphNode *n4 = gs->AddNode(""n4"",""Fourth node"");; TGraphNode *n5 = gs->AddNode(""n5"",""5th node"");; TGraphNode *n6 = gs->AddNode(""n6"",""Node number six"");; TGraphNode *n7 = gs->AddNode(""n7"",""Node 7"");; TGraphNode *n8 = gs->AddNode(""n8"",""Node 8"");; TGraphNode *n9 = gs->AddNode(""n9"",""Node 9"");. n4->SetTextSize(0.03);; n6->SetTextSize(0.03);; n2->SetTextSize(0.04);. n3->SetTextFont(132);. n0->SetTextColor(kRed);. n9->SetFillColor(kRed-10);; n0->SetFillColor(kYellow-9);; n7->SetFillColor(kViolet-9);. // some edges ...; gs->AddEdge(n0,n1)->SetLineColor(kRed);; TGraphEdge *e06 = gs->AddEdge(n0,n6);; e06->SetLineColor(kRed-3);; e06->SetLineWidth(4);; gs->AddEdge(n1,n7);; gs->AddEdge(n4,n6);; gs->AddEdge",MatchSource.WIKI,root/html602/TGraphStruct.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphStruct.html
Usability,simpl,simple,". TGraphStruct. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GVIZ; » TGraphStruct. class TGraphStruct: public TObject. Graph Structure class; The Graph Structure is an interface to the graphviz package. The graphviz package is a graph visualization system. This interface consists in; three classes:. TGraphStruct: holds the graph structure. It uses the graphiz library to; layout the graphs and the ROOT graphics to paint them.; TGraphNode: Is a graph node object which can be added in a TGraphStruct.; TGraphEdge: Is an edge object connecting two nodes which can be added in; a TGraphStruct. Picture; Source. // Draw a simple graph structure.; // The graph layout is made using graphviz. This macro creates some; // nodes and edges and change a few graphical attributes on some of them.; // Author: Olivier Couet; {; TGraphStruct *gs = new TGraphStruct();. // create some nodes and put them in the graph in one go ...; TGraphNode *n0 = gs->AddNode(""n0"",""Node 0"");; TGraphNode *n1 = gs->AddNode(""n1"",""First node"");; TGraphNode *n2 = gs->AddNode(""n2"",""Second node"");; TGraphNode *n3 = gs->AddNode(""n3"",""Third node"");; TGraphNode *n4 = gs->AddNode(""n4"",""Fourth node"");; TGraphNode *n5 = gs->AddNode(""n5"",""5th node"");; TGraphNode *n6 = gs->AddNode(""n6"",""Node number six"");; TGraphNode *n7 = gs->AddNode(""n7"",""Node 7"");; TGraphNode *n8 = gs->AddNode(""n8"",""Node 8"");; TGraphNode *n9 = gs->AddNode(""n9"",""Node 9"");. n4->SetTextSize(0.03);; n6->SetTextSize(0.03);; n2->SetTextSize(0.04);. n3->SetTextFont(132);. n0->SetTextColor(kRed);. n9->SetFillColor(kRed-10);; n0->SetFillColor(kYellow-9);; n7->SetFillColor(kViolet-9);. // some edges ...; gs->AddEdge(n0,n1)->SetLineColor(kRed);; TGraphEdge *e06 = gs->AddEdge(n0,n6);; e06->SetLineColor(kRed-3);; e06->SetLineWidth(4);; gs->AddEdge(n1,n7);; gs->AddEdge(n4,n6);; gs->AddEdge",MatchSource.WIKI,root/html602/TGraphStruct.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphStruct.html
Availability,error,error,"rtual~TGraphTime(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAdd(const TObject* obj, Int_t slot, Option_t* option = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* chopt = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObjArray*GetSteps() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfm",MatchSource.WIKI,root/html602/TGraphTime.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGraphTime.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html602/TGRecorder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGRecorder.html
Safety,timeout,timeouts,"DefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGCheckButton*fCursorCheckBoxCheck box ""Show mouse cursor"" for replaying; time_tfElapsedplaying/recording time; Window_tfFilteredIds[12]IDs of these windows in GUI recorder; TRecorder*fRecorderRecorder; TGPictureButton*fReplayButton for start of replaying; time_tfStartplaying/recording time; TGPictureButton*fStartStopButton for start and stop of recording; TGLabel*fStatusLabel with actual status; TGLabel*fTimeDisplayLabel with time counter; TTimer*fTimerTimer for handling GUI of recorder; static const Int_tfgWidgetsCountNumber of windows in GUI recorder. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGRecorder(const TGWindow* p = 0, UInt_t w = 230, UInt_t h = 150); The GUI for the recorder. void SetDefault(); Sets GUI to the default inactive state. void Update(); Called when fTimer timeouts (every 0.025 second); Updates GUI of recorder. void StartStop(); Handles push of the fStartStop button; according to the current recorder state. void Replay(); Handles push of fReplay button; according to the current recorder state. ~TGRecorder(); Destructor. Cleanup the GUI. TRecorder & operator=(const TGRecorder& ). TGRecorder(const TGWindow* p = 0, UInt_t w = 230, UInt_t h = 150). » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGRecorder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGRecorder.html
Availability,error,error," virtual~TGRectMap(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tContains(Int_t px, Int_t py) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const ",MatchSource.WIKI,root/html602/TGRectMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGRectMap.html
Safety,safe,safe,". TGRedirectOutputGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGRedirectOutputGuard. class TGRedirectOutputGuard. TGRedirectOutputGuard. This class provides output redirection to a TGTextView in guaranteed; exception safe way. Use like this:; {; TGRedirectOutputGuard guard(textview);; ... // do something; guard.Update();; ... // do something else; }; when guard goes out of scope, Update() is called to flush what left; on the screed and the output is automatically redirected again to; the standard units.; The exception mechanism takes care of calling the dtors; of local objects so it is exception safe.; Optionally the output can also be saved into a file:; {; TGRedirectOutputGuard guard(textview, file, mode);; ... // do something; }. Function Members (Methods); public:. virtual~TGRedirectOutputGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGRedirectOutputGuard(TGTextView* tv, const char* flog = 0, const char* mode = ""a""); voidUpdate(). private:. TGRedirectOutputGuard&operator=(const TGRedirectOutputGuard&); TGRedirectOutputGuard(const TGRedirectOutputGuard&). Data Members; private:. TStringfLogFile; FILE*fLogFileRead; TGTextView*fTextView; Bool_tfTmpFile. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGRedirectOutputGuard(TGTextView* tv, const char* flog = 0, const char* mode = ""a""); Create output redirection guard.; The TGTextView instance should be initialized outside.; Text is added to the existing text in the frame.; If defined, 'flog' is interpreted as the path of a file; where to save the output; in such a case 'mode' if the; opening mode of the file (either ""w"" or ""a"").;",MatchSource.WIKI,root/html602/TGRedirectOutputGuard.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGRedirectOutputGuard.html
Availability,error,error,"t char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tContains(const TPoint& p) const; Bool_tContains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TGRegionEor(const TGRegion& r) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGDimensionGetDimension() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGPositionGetPosition() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const",MatchSource.WIKI,root/html602/TGRegion.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGRegion.html
Availability,error,error,"Pad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTGRegion::Contains(const TPoint& p) const; Bool_tTGRegion::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDisplayPopup(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TGRegionTGRegion::Eor(const TGRegion& r) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGDimensionTGRegion::GetDimension() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetId() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGPopupMenu*GetPopup() const; TGPositionTGRegion::GetPosition() const; virtual const char*TObject::GetTitle() const; TGToolTip*GetToolTipText() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtu",MatchSource.WIKI,root/html602/TGRegionWithId.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGRegionWithId.html
Availability,error,error," virtual~TGResourcePool(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Pixel_tGetBlackColor() const; const TGGC*GetBlackGC() const; Pixmap_tGetCheckeredBitmap() const; Pixmap_tGetCheckeredPixmap() const; TGClient*TGObject::GetClient() const; Atom_tGetClipboard() const; Colormap_tGetDefaultColormap() const; Cursor_tGetDe",MatchSource.WIKI,root/html602/TGResourcePool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGResourcePool.html
Availability,error,error,"r* b); virtual Bool_tCd(const char* = """", Bool_t = kFALSE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual TGridResult*Command(const char*, Bool_t = kFALSE, UInt_t = 2); virtual Int_tTObject::Compare(const TObject* obj) const; static TGrid*Connect(const char* grid, const char* uid = 0, const char* pw = 0, const char* options = 0); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetGrid() const; virtual const char*GetHomeDirectory(); const char*GetHost() const; virtual const char*TObject::GetIconName() const; virtual TGridJDL*GetJDLGenerator(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetOptions() const; Int_tGetPort() const; const char*GetPw() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*Get",MatchSource.WIKI,root/html602/TGrid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGrid.html
Integrability,interface,interface,". TGrid. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TGrid. class TGrid: public TObject. TGrid. Abstract base class defining interface to common GRID services. To open a connection to a GRID use the static method Connect().; The argument of Connect() is of the form:; <grid>[://<host>][:<port>], e.g.; alien, alien://alice.cern.ch, globus://glsvr1.cern.ch, ...; Depending on the <grid> specified an appropriate plugin library; will be loaded which will provide the real interface. Related classes are TGridResult. Function Members (Methods); public:. virtual~TGrid(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCd(const char* = """", Bool_t = kFALSE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual TGridResult*Command(const char*, Bool_t = kFALSE, UInt_t = 2); virtual Int_tTObject::Compare(const TObject* obj) const; static TGrid*Connect(const char* grid, const char* uid = 0, const char* pw = 0, const char* options = 0); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual vo",MatchSource.WIKI,root/html602/TGrid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGrid.html
Modifiability,plugin,plugin,". TGrid. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TGrid. class TGrid: public TObject. TGrid. Abstract base class defining interface to common GRID services. To open a connection to a GRID use the static method Connect().; The argument of Connect() is of the form:; <grid>[://<host>][:<port>], e.g.; alien, alien://alice.cern.ch, globus://glsvr1.cern.ch, ...; Depending on the <grid> specified an appropriate plugin library; will be loaded which will provide the real interface. Related classes are TGridResult. Function Members (Methods); public:. virtual~TGrid(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCd(const char* = """", Bool_t = kFALSE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual TGridResult*Command(const char*, Bool_t = kFALSE, UInt_t = 2); virtual Int_tTObject::Compare(const TObject* obj) const; static TGrid*Connect(const char* grid, const char* uid = 0, const char* pw = 0, const char* options = 0); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual vo",MatchSource.WIKI,root/html602/TGrid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGrid.html
Performance,load,loaded,". TGrid. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TGrid. class TGrid: public TObject. TGrid. Abstract base class defining interface to common GRID services. To open a connection to a GRID use the static method Connect().; The argument of Connect() is of the form:; <grid>[://<host>][:<port>], e.g.; alien, alien://alice.cern.ch, globus://glsvr1.cern.ch, ...; Depending on the <grid> specified an appropriate plugin library; will be loaded which will provide the real interface. Related classes are TGridResult. Function Members (Methods); public:. virtual~TGrid(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCd(const char* = """", Bool_t = kFALSE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual TGridResult*Command(const char*, Bool_t = kFALSE, UInt_t = 2); virtual Int_tTObject::Compare(const TObject* obj) const; static TGrid*Connect(const char* grid, const char* uid = 0, const char* pw = 0, const char* options = 0); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual vo",MatchSource.WIKI,root/html602/TGrid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGrid.html
Security,password,password,"stCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfGridtype of GRID (AliEn, Globus, ...); TStringfGridUrlthe GRID url used to create the grid connection; TStringfHostGRID portal to which we are connected; TStringfOptionsoptions specified; Int_tfPortport to which we are connected; TStringfPwuser passwd; TStringfUseruser name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGrid * Connect(const char* grid, const char* uid = 0, const char* pw = 0, const char* options = 0); The grid should be of the form: <grid>://<host>[:<port>],; e.g.: alien://alice.cern.ch, globus://glsrv1.cern.ch, ...; The uid is the username and pw the password that should be used for; the connection. Depending on the <grid> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. For AliEn the supported options are:; -domain=<domain name>; -debug=<debug level from 1 to 10>; Example: ""-domain=cern.ch -debug=5"". TGrid(); { }. virtual ~TGrid(); { }. const char * GridUrl() const; { return fGridUrl; }. const char * GetGrid() const; { return fGrid; }. const char * GetHost() const; { return fHost; }. const char * GetUser() const; { return fUser; }. const char * GetPw() const; { return fPw; }. const char * GetOptions() const; { return fOptions; }. Int_t GetPort() const; { return fPort; }. Bool_t IsConnected() const; { return fPort == -1 ? kFALSE : kTRUE; }. void Shell(); { MayNotUse(""Shell""); }. void Stdout(); { MayNotUse(""Stdout""); }. void Stderr(); { MayNotUse(""Stderr""); }. TGridResult * Command(const char* , Bool_t = kFALSE, UInt_t = 2); { MayNotUse(""Command""); return 0; }. TG",MatchSource.WIKI,root/html602/TGrid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGrid.html
Availability,error,error,"ct::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCheckIfOnline(Bool_t = kFALSE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Bool_tDeselectFile(const char*, Int_t = -1, Int_t = -1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tDownscaleSelection(UInt_t = 2); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExportXML(const char*, Bool_t = kTRUE, Bool_t = kTRUE, const char* = ""ROOT xml"", const char* = ""Exported XML""); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetCollectionName() const; virtual TDSet*GetDataset(const char*, const char*, const char*); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TEntryList*GetEntryList(const char*); virtual const char*GetExportUrl(); virtual TFileCollection*GetFileCollection(const char* = """", const char* = """") const; virtual TList*GetFileGroupList() const; virtual TGridResult*GetGridResult(const char* = """", Bool_t = kTRUE, Bool_t = kFALSE); virtual const char*TObject",MatchSource.WIKI,root/html602/TGridCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGridCollection.html
Availability,avail,available,". TGridJDL. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TGridJDL. class TGridJDL: public TObject. TGridJDL. Abstract base class to generate JDL files for job submission to the; Grid. Related classes are TGLiteJDL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGridJDL(); voidTObject::AbstractMethod(const char* method) const; TStringAddQuotes(const char* value); virtual voidAddToInputData(const char* value = 0, const char* description = 0); virtual voidAddToInputDataCollection(const char* value = 0, const char* description = 0); virtual voidAddToInputSandbox(const char* value = 0, const char* description = 0); virtual voidAddToOutputArchive(const char* value = 0, const char* description = 0); virtual voidAddToOutputSandbox(const char* value = 0, const char* description = 0); virtual voidAddToPackages(const char* name = ""AliRoot"", const char* version = ""default"", const char* type = ""VO_ALICE"", const char* description = 0); virtual voidAddToRequirements(const char* value = 0, const char* description = 0); voidAddToSet(const char* key, const char* value); voidAddToSetDescription(const char* key, const char* description); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(const Option_t* = 0); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); vir",MatchSource.WIKI,root/html602/TGridJDL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGridJDL.html
Availability,avail,available,". TGridJob. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TGridJob. class TGridJob: public TObject. TGridJob. Abstract base class defining interface to a GRID job. Related classes are TGridJobStatus. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGridJob(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCancel(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() cons",MatchSource.WIKI,root/html602/TGridJob.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGridJob.html
Integrability,interface,interface,". TGridJob. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TGridJob. class TGridJob: public TObject. TGridJob. Abstract base class defining interface to a GRID job. Related classes are TGridJobStatus. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGridJob(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCancel(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() cons",MatchSource.WIKI,root/html602/TGridJob.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGridJob.html
Availability,avail,available,". TGridJobStatus. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TGridJobStatus. class TGridJobStatus: public TNamed. TGridJobStatus. Abstract base class containing the status of a Grid job. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGridJobStatus(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObjec",MatchSource.WIKI,root/html602/TGridJobStatus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGridJobStatus.html
Energy Efficiency,reduce,reduces,":Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TGridJobStatus::EGridJobStatuskABORTED; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGridJobStatus::EGridJobStatuskDONE; static TGridJobStatus::EGridJobStatuskFAIL; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TGridJobStatus::EGridJobStatuskRUNNING; static TObject::(anonymous)TObject::kSingleKey; static TGridJobStatus::EGridJobStatuskUNKNOWN; static TGridJobStatus::EGridJobStatuskWAITING; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGridJobStatus(); { }. virtual ~TGridJobStatus(); { }. EGridJobStatus GetStatus() const; These functions reduces the possible job states to the subset given above; in EGridJobStatus, for detailed status information query the specific; implementation. » Author: Jan Fiete Grosse-Oetringhaus 06/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-02 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGridJobStatus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGridJobStatus.html
Availability,error,error,"); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTList::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TList::FindObject(const char* name) const; virtual TObject*TList::FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**TList::GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Opti",MatchSource.WIKI,root/html602/TGridJobStatusList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGridJobStatusList.html
Performance,cache,cache,"t; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TStringfJobIDthe job's ID; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGridJobStatusList(); { }. virtual ~TGridJobStatusList(); { }. » Author: Andreas-Joachim Peters 10/12/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-30 15:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGridJobStatusList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGridJobStatusList.html
Availability,error,error,"); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTList::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TList::FindObject(const char* name) const; virtual TObject*TList::FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const TEntryList*GetEntryList(UInt_t) const; virtual TList*GetFileInfoList() const; virtual const char*GetFileName(UInt_t) const; virtual const char*GetFileNamePath(UInt_t) const; virtual const char*TObject::GetIconName() const; virtual const char*GetKey(UInt_t, const char*) const; virtual Int_tTSeqCollection::Ge",MatchSource.WIKI,root/html602/TGridResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGridResult.html
Integrability,interface,interface,". TGridResult. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TGridResult. class TGridResult: public TList. TGridResult. Abstract base class defining interface to a GRID result.; Objects of this class are created by TGrid methods. Related classes are TGrid. Function Members (Methods); public:. virtual~TGridResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTList::Add(TObject* obj); virtual voidTList::Add(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); virtual voidTList::AddFirst(TObject* obj, Option_t* opt); virtual voidTList::AddLast(TObject* obj); virtual voidTList::AddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; virtual TObject*TList::Before(const TObject* obj) const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObje",MatchSource.WIKI,root/html602/TGridResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGridResult.html
Performance,cache,cache,"CannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGridResult(); { SetOwner(kTRUE); }. virtual ~TGridResult(); { }. const char * GetFileName(UInt_t ) const; { MayNotUse(""GetFileName""); return 0; }. const char * GetFileNamePath(UInt_t ) const; { MayNotUse(""GetFileNamePath""); return 0; }. const char * GetPath(UInt_t ) const; { MayNotUse(""GetPath""); return 0; }. const TEntryList * GetEntryList(UInt_t ) const; { MayNotUse(""GetEntryList""); return 0; }. const char * GetKey(UInt_t , const char* ) const; { MayNotUse(""GetKey""); return 0; }. Bool_t SetKey(UInt_t , const char* , const char* ); { MayNotUse(""SetKey""); return 0; }. TList * GetFileInfoList() const; { MayNotUse(""GetFileInfoList""); retur",MatchSource.WIKI,root/html602/TGridResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGridResult.html
Availability,error,error,"r* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteAction(); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Rectangle_tTPad::GetBBox(); virtual TPointTPad::GetBBoxCenter(); virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tT",MatchSource.WIKI,root/html602/TGroupButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGroupButton.html
Testability,log,log,"e if fixed aspect ratio; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); TStringTButton::fMethodMethod to be executed by this button; Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TObject*TPad::fPadView3D! 3D View of this TPad; Double_tTPad::fPhiphi angle to view as lego/surface; Double_tTPad::fPixeltoXxworld = fPixeltoXk + fPixeltoX*xpixel; Double_tTPad::fPixeltoXkConversion coefficient for pixel to X World; Double_tTPad::fPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixel; Double_tTPad::fPixeltoYkConversion coefficient for pixel to Y World; Int_tTPad::fPixmapID! Off-screen pixmap identifier; TList*TPad::fPrimitives->List of primitives (subpads); Bool_tTVirtualPad::fResizing!true when resizing the pad; Float_tTAttPad::f",MatchSource.WIKI,root/html602/TGroupButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGroupButton.html
Availability,down,downward,". TGRowLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGRowLayout. class TGRowLayout: public TGVerticalLayout. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. virtual~TGRowLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject:",MatchSource.WIKI,root/html602/TGRowLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGRowLayout.html
Availability,avail,available,"s:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGScrollBar. class TGScrollBar: public TGFrame, public TGWidget. TGScrollBar and TGScrollBarElement. The classes in this file implement scrollbars. Scrollbars can be; either placed horizontal or vertical. A scrollbar contains three; TGScrollBarElements: The ""head"", ""tail"" and ""slider"". The head and; tail are fixed at either end and have the typical arrows in them. The TGHScrollBar will generate the following event messages:; kC_HSCROLL, kSB_SLIDERPOS, position, 0; kC_HSCROLL, kSB_SLIDERTRACK, position, 0. The TGVScrollBar will generate the following event messages:; kC_VSCROLL, kSB_SLIDERPOS, position, 0; kC_VSCROLL, kSB_SLIDERTRACK, position, 0. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGScrollBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Conn",MatchSource.WIKI,root/html602/TGScrollBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGScrollBar.html
Integrability,message,messages,". TGScrollBar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGScrollBar. class TGScrollBar: public TGFrame, public TGWidget. TGScrollBar and TGScrollBarElement. The classes in this file implement scrollbars. Scrollbars can be; either placed horizontal or vertical. A scrollbar contains three; TGScrollBarElements: The ""head"", ""tail"" and ""slider"". The head and; tail are fixed at either end and have the typical arrows in them. The TGHScrollBar will generate the following event messages:; kC_HSCROLL, kSB_SLIDERPOS, position, 0; kC_HSCROLL, kSB_SLIDERTRACK, position, 0. The TGVScrollBar will generate the following event messages:; kC_VSCROLL, kSB_SLIDERPOS, position, 0; kC_VSCROLL, kSB_SLIDERTRACK, position, 0. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGScrollBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) co",MatchSource.WIKI,root/html602/TGScrollBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGScrollBar.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option",MatchSource.WIKI,root/html602/TGScrollBarElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGScrollBarElement.html
Integrability,message,messages,". TGScrollBarElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGScrollBarElement. class TGScrollBarElement: public TGFrame. TGScrollBar and TGScrollBarElement. The classes in this file implement scrollbars. Scrollbars can be; either placed horizontal or vertical. A scrollbar contains three; TGScrollBarElements: The ""head"", ""tail"" and ""slider"". The head and; tail are fixed at either end and have the typical arrows in them. The TGHScrollBar will generate the following event messages:; kC_HSCROLL, kSB_SLIDERPOS, position, 0; kC_HSCROLL, kSB_SLIDERTRACK, position, 0. The TGVScrollBar will generate the following event messages:; kC_VSCROLL, kSB_SLIDERPOS, position, 0; kC_VSCROLL, kSB_SLIDERTRACK, position, 0. Function Members (Methods); public:. virtual~TGScrollBarElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, co",MatchSource.WIKI,root/html602/TGScrollBarElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGScrollBarElement.html
Availability,avail,available,". TGSearchDialog. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSearchDialog. class TGSearchDialog: public TGTransientFrame. TGTextEditDialogs. This file defines several dialogs that are used by the TGTextEdit; widget via its associated context popup menu.; The following dialogs are available: TGSearchDialog, TGGotoDialog; and TGPrintDialog. Function Members (Methods); public:. virtual~TGSearchDialog(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); sta",MatchSource.WIKI,root/html602/TGSearchDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSearchDialog.html
Integrability,message,messages,"AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static TGSearchDialog*fgSearchDialogglobal singleton; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGSearchDialog(const TGWindow* p = 0, const TGWindow* main = 0, UInt_t w = 1, UInt_t h = 1, TGSearchType* sstruct = 0, Int_t* ret_code = 0, UInt_t options = kVerticalFrame); Create a search dialog box. Used to get from the user the required; search instructions. Ret_code is kTRUE when sstruct has been set,; kFALSE otherwise (like when dialog was canceled). ~TGSearchDialog(); Clean up search dialog. void CloseWindow(); Close the dialog. On close the dialog will be deleted and cannot be; re-used. void TextEntered(const char* text); emit signal when search text entered. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process search dialog widget messages. TGSearchDialog *& SearchDialog(); Return global search dialog. TGSearchDialog(const TGWindow* p = 0, const TGWindow* main = 0, UInt_t w = 1, UInt_t h = 1, TGSearchType* sstruct = 0, Int_t* ret_code = 0, UInt_t options = kVerticalFrame). void SetClose(Bool_t on); { fType->fClose = on; }. Bool_t IsClose() const; { return fType->fClose; }. TGSearchType * GetType() const; { return fType; }. » Author: Fons Rademakers 10/7/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGSearchDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSearchDialog.html
Availability,avail,available,". TGSearchType. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSearchType. class TGSearchType. TGTextEditDialogs. This file defines several dialogs that are used by the TGTextEdit; widget via its associated context popup menu.; The following dialogs are available: TGSearchDialog, TGGotoDialog; and TGPrintDialog. Function Members (Methods); public:. ~TGSearchType(); TGSearchType&operator=(const TGSearchType&); TGSearchType(); TGSearchType(const TGSearchType&). Data Members; public:. char*fBuffer; Bool_tfCaseSensitive; Bool_tfClose; Bool_tfDirection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGSearchType(); { fDirection = kTRUE; fCaseSensitive = kFALSE; fBuffer = 0; fClose = kTRUE; }. ~TGSearchType(); { if (fBuffer) delete [] fBuffer;}. » Author: Fons Rademakers 10/7/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGSearchType.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSearchType.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html602/TGSelectBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSelectBox.html
Availability,error,error,"ual~TGSelectedPicture(); voidTObject::AbstractMethod(const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTGPicture::Draw(Handle_t id, GContext_t gc, Int_t x, Int_t y) const; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); UInt_tTGPicture::GetHeight() const; virtual const char*TObject::GetIconName() const; Pixmap_tTGPicture::GetMask() const; virtual const char*TGPicture::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Pixmap_tTGPicture::GetPicture() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; UInt_tTGPicture::GetWidth() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTGPicture:",MatchSource.WIKI,root/html602/TGSelectedPicture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSelectedPicture.html
Performance,cache,cache,". TGSelectedPicture. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSelectedPicture. class TGSelectedPicture: public TGPicture. TGPicture & TGPicturePool. The TGPicture class implements pictures and icons used in the; different GUI elements and widgets. The TGPicturePool class; implements a TGPicture cache. TGPictures are created, managed and; destroyed by the TGPicturePool. Function Members (Methods); public:. virtual~TGSelectedPicture(); voidTObject::AbstractMethod(const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTGPicture::Draw(Handle_t id, GContext_t gc, Int_t x, Int_t y) const; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption",MatchSource.WIKI,root/html602/TGSelectedPicture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSelectedPicture.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGShapedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGShapedFrame.html
Availability,error,error,"am); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidEnableItem(const char* name, Bool_t on = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*",MatchSource.WIKI,root/html602/TGShutter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGShutter.html
Integrability,message,messages,"fault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGShutter(const TGWindow* p = 0, UInt_t options = kSunkenFrame); Create shutter frame. ~TGShutter(); Cleanup shutter widget. void AddItem(TGShutterItem* item); Add shutter item to shutter frame. void RemoveItem(const char* name); Remove item from shutter. void RemovePage(); Remove selected page. void RenamePage(const char* name); Rename selected page. TGShutterItem * AddPage(const char* item = ""Page""); Add new page (shutter item). Bool_t ProcessMessage(Long_t cmd, Long_t parm1, Long_t parm2); Handle shutter messages. Bool_t HandleTimer(TTimer* t); Shutter item animation. void Layout(); Layout shutter items. void SetSelectedItem(TGShutterItem* item); Set item to be the currently open shutter item. void SetSelectedItem(const char* name); Set item to be the currently open shutter item. void EnableItem(const char* name, Bool_t on = kTRUE); Disable/enbale shutter item. TGShutterItem * GetItem(const char* name); returns a shutter item by name (name is hot string of shutter item). TGDimension GetDefaultSize() const; Return the default / minimal size of the widget. void SetDefaultSize(UInt_t w, UInt_t h); Set the default / minimal size of the widget. void SavePrimitive(ostream& out, Option_t* option = """"); Save a shutter widget as a C++ statement(s) on output stream out. TGShutterItem& operator=(const TGShutter& ). void Selected(); { Emit("" Selected()""); }. TGShutter(const TGShutter& ). void SetLayoutManager(TGLayoutManager* ); { }. TGShutterItem * GetSelectedIt",MatchSource.WIKI,root/html602/TGShutter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGShutter.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGButton*GetButton() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; TGFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensio",MatchSource.WIKI,root/html602/TGShutterItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGShutterItem.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual const TGTableCell*TGTable::FindCell(TGString label) const; virtual TGTableCell*TGTable::FindCell(TGString label); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TGCanvas*TGTable::GetCanvas(); virtual const TGTableCell*TGTable::GetCell(UInt_t i, UInt_t j) const; virtual TGTableCell*TGTable::GetCell(UInt_t i, UInt_t j); virtual const TGTableHeaderFrame*TGTable::GetCHdrFrame(); TGClient*",MatchSource.WIKI,root/html602/TGSimpleTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSimpleTable.html
Deployability,update,update, options; const TGWindow*TGWindow::fParentParent window; TGTextButton*TGTable::fPrevButtonButton to view previous chunk; TGTableHeaderFrame*TGTable::fRHdrFrameFrame that contains the row headers; TList*TGTable::fRHdrHintsList; TGTextEntry*TGTable::fRangeEntryTextEntry for the range frame; TGHorizontalFrame*TGTable::fRangeFrameFrame that contains the top part; TGLabel*TGTable::fRangeLabelLabel for the range frame; Bool_tTGTable::fReadOnlyTable readonly state; TObjArray*TGTable::fRowHeadersArray of row headers; TObjArray*TGTable::fRowsArray of rows; Pixel_tTGTable::fSelectColorSelect Color; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTGTable::fTModeText justify mode; TGTableFrame*TGTable::fTableFrameContainer for the frames; TGTableHeader*TGTable::fTableHeaderTop left element of the table; TGHorizontalFrame*TGTable::fTopExtraFrameDev idea; TGHorizontalFrame*TGTable::fTopFrameFrame that contains the top part; TGTextButton*TGTable::fUpdateButtonButton to update current view; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTG,MatchSource.WIKI,root/html602/TGSimpleTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSimpleTable.html
Integrability,interface,interface,". TGSimpleTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSimpleTable. class TGSimpleTable: public TGTable. TGSimpleTable. To provide a simple class to visualize an array of doubles, the class; TGSimpleTable is provided. TGSimpleTable creates it's own; TGSimpleTableInterface. For more information, see the documentation of; TGTable. The interface is accesible through the GetInterface() method. Function Members (Methods); public:. virtual~TGSimpleTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* s",MatchSource.WIKI,root/html602/TGSimpleTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSimpleTable.html
Performance,load,loaded,,MatchSource.WIKI,root/html602/TGSimpleTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSimpleTable.html
Usability,simpl,simple,". TGSimpleTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSimpleTable. class TGSimpleTable: public TGTable. TGSimpleTable. To provide a simple class to visualize an array of doubles, the class; TGSimpleTable is provided. TGSimpleTable creates it's own; TGSimpleTableInterface. For more information, see the documentation of; TGTable. The interface is accesible through the GetInterface() method. Function Members (Methods); public:. virtual~TGSimpleTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* s",MatchSource.WIKI,root/html602/TGSimpleTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSimpleTable.html
Integrability,interface,interface,". TGSimpleTableInterface. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSimpleTableInterface. class TGSimpleTableInterface: public TVirtualTableInterface. TGSimpleTableInterface. TGSimpleTableInterface is a very simple implementation of a; TVirtualTableInterface. This interface provides a TGTable with data; from a two dimensional array of doubles in memory. It is mostly; meant as an example implementation for a TVirtualTableInterface. Function Members (Methods); public:. virtual~TGSimpleTableInterface(); static TClass*Class(); virtual const char*GetColumnHeader(UInt_t column); virtual UInt_tGetNColumns(); virtual UInt_tGetNRows(); virtual const char*GetRowHeader(UInt_t row); virtual Double_tGetValue(UInt_t row, UInt_t column); virtual const char*GetValueAsString(UInt_t row, UInt_t column); virtual TClass*IsA() const; TGSimpleTableInterface&operator=(const TGSimpleTableInterface&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGSimpleTableInterface(const TGSimpleTableInterface&); TGSimpleTableInterface(Double_t** data, UInt_t nrows = 2, UInt_t ncolumns = 2). Data Members; private:. Double_t**fDataPointer to 2 dimensional array of Double_t; UInt_tfNColumns; UInt_tfNRows. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGSimpleTableInterface(Double_t** data, UInt_t nrows = 2, UInt_t ncolumns = 2); TGSimpleTableInterfac constructor. ~TGSimpleTableInterface(); TGSimpleTableInterface destructor. Double_t GetValue(UInt_t row, UInt_t column); Return the value of the double in row,column of the data. const char * GetValueAsString(UInt_t row, UInt_t column); Return the value of the double in row,column of the data as a string. const char * GetRowHeader(",MatchSource.WIKI,root/html602/TGSimpleTableInterface.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSimpleTableInterface.html
Usability,simpl,simple,". TGSimpleTableInterface. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSimpleTableInterface. class TGSimpleTableInterface: public TVirtualTableInterface. TGSimpleTableInterface. TGSimpleTableInterface is a very simple implementation of a; TVirtualTableInterface. This interface provides a TGTable with data; from a two dimensional array of doubles in memory. It is mostly; meant as an example implementation for a TVirtualTableInterface. Function Members (Methods); public:. virtual~TGSimpleTableInterface(); static TClass*Class(); virtual const char*GetColumnHeader(UInt_t column); virtual UInt_tGetNColumns(); virtual UInt_tGetNRows(); virtual const char*GetRowHeader(UInt_t row); virtual Double_tGetValue(UInt_t row, UInt_t column); virtual const char*GetValueAsString(UInt_t row, UInt_t column); virtual TClass*IsA() const; TGSimpleTableInterface&operator=(const TGSimpleTableInterface&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGSimpleTableInterface(const TGSimpleTableInterface&); TGSimpleTableInterface(Double_t** data, UInt_t nrows = 2, UInt_t ncolumns = 2). Data Members; private:. Double_t**fDataPointer to 2 dimensional array of Double_t; UInt_tfNColumns; UInt_tfNRows. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGSimpleTableInterface(Double_t** data, UInt_t nrows = 2, UInt_t ncolumns = 2); TGSimpleTableInterfac constructor. ~TGSimpleTableInterface(); TGSimpleTableInterface destructor. Double_t GetValue(UInt_t row, UInt_t column); Return the value of the double in row,column of the data. const char * GetValueAsString(UInt_t row, UInt_t column); Return the value of the double in row,column of the data as a string. const char * GetRowHeader(",MatchSource.WIKI,root/html602/TGSimpleTableInterface.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSimpleTableInterface.html
Availability,avail,available,". class TGSlider: public TGFrame, public TGWidget. TGSlider, TGVSlider and TGHSlider. Slider widgets allow easy selection of a range.; Sliders can be either horizontal or vertical oriented and there is; a choice of two different slider types and three different types; of tick marks. TGSlider is an abstract base class. Use the concrete TGVSlider and; TGHSlider. Dragging the slider will generate the event:; kC_VSLIDER, kSL_POS, slider id, position (for vertical slider); kC_HSLIDER, kSL_POS, slider id, position (for horizontal slider). Pressing the mouse will generate the event:; kC_VSLIDER, kSL_PRESS, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_PRESS, slider id, 0 (for horizontal slider). Releasing the mouse will generate the event:; kC_VSLIDER, kSL_RELEASE, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_RELEASE, slider id, 0 (for horizontal slider). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGSlider(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); virtual voidChangeSliderPic(const char* name); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Co",MatchSource.WIKI,root/html602/TGSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSlider.html
Availability,avail,available,". TGSpeedo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSpeedo. class TGSpeedo: public TGFrame, public TGWidget. TGSpeedo. TGSpeedo is a widget looking like a speedometer, with a needle,; a counter and a small odometer window. /*. */; //. Three thresholds are configurable, with their glowing color; A peak mark can be enabled, allowing to keep track of the highest; value displayed. The mark can be reset by right-clicking on the; widget.; Two signals are available:; OdoClicked(): when user click on the small odometer window; LedClicked(): when user click on the small led near the counter. Function Members (Methods); public:. virtual~TGSpeedo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBuild(); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const",MatchSource.WIKI,root/html602/TGSpeedo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSpeedo.html
Energy Efficiency,meter,meter,,MatchSource.WIKI,root/html602/TGSpeedo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSpeedo.html
Modifiability,config,configurable,". TGSpeedo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSpeedo. class TGSpeedo: public TGFrame, public TGWidget. TGSpeedo. TGSpeedo is a widget looking like a speedometer, with a needle,; a counter and a small odometer window. /*. */; //. Three thresholds are configurable, with their glowing color; A peak mark can be enabled, allowing to keep track of the highest; value displayed. The mark can be reset by right-clicking on the; widget.; Two signals are available:; OdoClicked(): when user click on the small odometer window; LedClicked(): when user click on the small led near the counter. Function Members (Methods); public:. virtual~TGSpeedo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBuild(); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const",MatchSource.WIKI,root/html602/TGSpeedo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSpeedo.html
Availability,avail,available,"_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Methods); public:. virtual~TGSplitButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtu",MatchSource.WIKI,root/html602/TGSplitButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSplitButton.html
Deployability,release,released,TQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tfSplitkTRUE if menu is in split mode; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tfTBWidthwidth of text button; UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; TGStringfWidestLabelLongest label that can be on the button; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled.,MatchSource.WIKI,root/html602/TGSplitButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSplitButton.html
Integrability,message,message,"""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Method",MatchSource.WIKI,root/html602/TGSplitButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSplitButton.html
Performance,perform,perform,". TGSplitButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSplitButton. class TGSplitButton: public TGTextButton. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- butt",MatchSource.WIKI,root/html602/TGSplitButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSplitButton.html
Security,access,access,". TGSplitButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSplitButton. class TGSplitButton: public TGTextButton. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- butt",MatchSource.WIKI,root/html602/TGSplitButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSplitButton.html
Testability,log,logical," widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked",MatchSource.WIKI,root/html602/TGSplitButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSplitButton.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExtractFrame()MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame:",MatchSource.WIKI,root/html602/TGSplitFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSplitFrame.html
Usability,undo,undocking,"GCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TGSplitFrame*fSecondPointer to the second child (if any); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGSplitTool*fSplitToolSplitFrame Tool; TGSplitter*fSplitterPointer to the (H/V) Splitter (if any); TGTransientFrame*fUndockedMain frame used when ""undocking"" frame; Float_tfWRatioWidth ratio between the first child and this; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::",MatchSource.WIKI,root/html602/TGSplitFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSplitFrame.html
Availability,avail,available,". TGSplitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSplitter. class TGSplitter: public TGFrame. TGSplitter, TGVSplitter and TGHSplitter. A splitter allows the frames left and right or above and below of; it to be resized. The frame to be resized must have the kFixedWidth; or kFixedHeight property set. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGSplitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Co",MatchSource.WIKI,root/html602/TGSplitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSplitter.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGSplitTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGSplitTool.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; TGCompositeFrame*GetBarPart(Int_t npart) const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGCompositeF",MatchSource.WIKI,root/html602/TGStatusBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGStatusBar.html
Integrability,depend,depending,Connections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; Int_tfNpartnumber of parts; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Int_t*fPartssize of parts (in percent of total width); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGStatusBarPart**fStatusPartframes containing statusbar text; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_t*fXtx position for each part; Int_tTGFrame::fYframe y position; Int_tfYty drawing position (depending on font); static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*fgDefaultGC; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled.,MatchSource.WIKI,root/html602/TGStatusBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGStatusBar.html
Integrability,wrap,wraps,". TGString. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGString. class TGString: public TString. TGString and TGHotString. TGString wraps a TString and adds some graphics routines like; drawing, size of string on screen depending on font, etc.; TGHotString is a string with a ""hot"" character unerlined. Function Members (Methods); public:. virtual~TGString(); TString&TString::Append(const char* cs); TString&TString::Append(const TString& s); TString&TString::Append(const char* cs, Ssiz_t n); TString&TString::Append(const TString& s, Ssiz_t n); TString&TString::Append(char c, Ssiz_t rep = 1); Double_tTString::Atof() const; Int_tTString::Atoi() const; Long64_tTString::Atoll() const; static TStringTString::BaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); Bool_tTString::BeginsWith(const char* s, TString::ECaseCompare cmp = kExact) const; Bool_tTString::BeginsWith(const TString& pat, TString::ECaseCompare cmp = kExact) const; Ssiz_tTString::Capacity() const; Ssiz_tTString::Capacity(Ssiz_t n); TString&TString::Chop(); static TClass*Class(); voidTString::Clear(); intTString::CompareTo(const char* cs, TString::ECaseCompare cmp = kExact) const; intTString::CompareTo(const TString& st, TString::ECaseCompare cmp = kExact) const; Bool_tTString::Contains(const TRegexp& pat) const; Bool_tTString::Contains(TPRegexp& pat) const; Bool_tTString::Contains(const char* pat, TString::ECaseCompare cmp = kExact) const; Bool_tTString::Contains(const TString& pat, TString::ECaseCompare cmp = kExact) const; TStringTString::Copy() const; Int_tTString::CountChar(Int_t c) const; const char*TString::Data() const; virtual voidDraw(Drawable_t id, GContext_t gc, Int_t x, Int_t y); virtual voidDrawWrapped(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, FontStruct_t font); Bool_tTString::EndsWith",MatchSource.WIKI,root/html602/TGString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGString.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; TGCompositeFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); Int_tGetCurrent() const; TGCompositeFrame*GetCurrentContainer() const; TGTabElement*GetCurrentTab() const; static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); ",MatchSource.WIKI,root/html602/TGTab.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTab.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObjec",MatchSource.WIKI,root/html602/TGTabElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTabElement.html
Availability,error,error," virtual~TGTabLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject",MatchSource.WIKI,root/html602/TGTabLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTabLayout.html
Availability,avail,available,". TGTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTable. class TGTable: public TGCompositeFrame, public TGWidget. TGTable. TGTable implements a table widget to display data in rows and; columns. The data is supplied by a TVirtualTableInterface. The table is a TGCanvas to make use of already available viewport; functionality and drawing optimizations. The top left cell in a table has coordinates (0,0). A TObjArray is used internally to ensure little overhead and fast; acces to cells. If the data source has more rows than the default 50 rows of cells in; memory, buttons at the bottom of the table can be used to load the; next or previous chunk of data. At the top of the table, a frame is visible that shows the coordinates; of the top left cell currently in memmory in row,column. The amount of; rows and columns is also shown in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate; TVirtualTableInterface from the data that needs visualization and; then creating the TGTable using this interface. A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; ",MatchSource.WIKI,root/html602/TGTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTable.html
Deployability,update,update,"is created by first creating an appropriate; TVirtualTableInterface from the data that needs visualization and; then creating the TGTable using this interface. A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimpleTableInterface *iface = new TGSimpleTableInterface(data, 6, 5);. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. //Update data; data[5][1] = 3.01;; //update the table view; table->Update();. // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainframe->MapWindow() ;. return mainframe;; }; It is also possible to visualise data from a tree. A simple macro; showing the use of a TTreeTableInterface follows. Picture; Source. {; // Open a root file.; TFile *file = new TFile(""$ROOTSYS/tutorials/hsimple.root"");; // Load a tree from the file; TNtuple *ntuple = (TNtuple *)file->Get(""ntuple"");. // Create an interface; TTreeTableInterface *iface = new TTreeTableInterface(ntuple);. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface, 10, 6);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. // Set a selection; iface->SetSelection(""px >",MatchSource.WIKI,root/html602/TGTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTable.html
Integrability,interface,interface,"ta is supplied by a TVirtualTableInterface. The table is a TGCanvas to make use of already available viewport; functionality and drawing optimizations. The top left cell in a table has coordinates (0,0). A TObjArray is used internally to ensure little overhead and fast; acces to cells. If the data source has more rows than the default 50 rows of cells in; memory, buttons at the bottom of the table can be used to load the; next or previous chunk of data. At the top of the table, a frame is visible that shows the coordinates; of the top left cell currently in memmory in row,column. The amount of; rows and columns is also shown in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate; TVirtualTableInterface from the data that needs visualization and; then creating the TGTable using this interface. A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimpleTableInterface *iface = new TGSimpleTableInterface(data, 6, 5);. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. //Update data; data[5][1] = 3.01;; //update the table view; table->Update();. // Layout and map the main frame; mainframe->SetW",MatchSource.WIKI,root/html602/TGTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTable.html
Performance,optimiz,optimizations,". TGTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTable. class TGTable: public TGCompositeFrame, public TGWidget. TGTable. TGTable implements a table widget to display data in rows and; columns. The data is supplied by a TVirtualTableInterface. The table is a TGCanvas to make use of already available viewport; functionality and drawing optimizations. The top left cell in a table has coordinates (0,0). A TObjArray is used internally to ensure little overhead and fast; acces to cells. If the data source has more rows than the default 50 rows of cells in; memory, buttons at the bottom of the table can be used to load the; next or previous chunk of data. At the top of the table, a frame is visible that shows the coordinates; of the top left cell currently in memmory in row,column. The amount of; rows and columns is also shown in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate; TVirtualTableInterface from the data that needs visualization and; then creating the TGTable using this interface. A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; ",MatchSource.WIKI,root/html602/TGTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTable.html
Usability,simpl,simple,"onality and drawing optimizations. The top left cell in a table has coordinates (0,0). A TObjArray is used internally to ensure little overhead and fast; acces to cells. If the data source has more rows than the default 50 rows of cells in; memory, buttons at the bottom of the table can be used to load the; next or previous chunk of data. At the top of the table, a frame is visible that shows the coordinates; of the top left cell currently in memmory in row,column. The amount of; rows and columns is also shown in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate; TVirtualTableInterface from the data that needs visualization and; then creating the TGTable using this interface. A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimpleTableInterface *iface = new TGSimpleTableInterface(data, 6, 5);. // Create the table; TGTable *table = new TGTable(mainframe, 999, iface);. // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. //Update data; data[5][1] = 3.01;; //update the table view; table->Update();. // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainframe-",MatchSource.WIKI,root/html602/TGTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTable.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; virtual UInt_tGetColumn() const; static Int_tTGWindow::GetCounter(); static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() ",MatchSource.WIKI,root/html602/TGTableCell.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTableCell.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; virtual UInt_tTGTableCell::GetColumn() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGTableCell::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGTableCell::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; vi",MatchSource.WIKI,root/html602/TGTableHeader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTableHeader.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGTableHeaderFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTableHeaderFrame.html
Availability,error,error,,MatchSource.WIKI,root/html602/TGTableLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTableLayout.html
Availability,error,error,,MatchSource.WIKI,root/html602/TGTableLayoutHints.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTableLayoutHints.html
Availability,failure,failure,"ther text buffer. TGText(const char* string); Create text buffer and initialize with single line string. ~TGText(); Destroy text buffer. void Clear(); Clear text buffer. Bool_t Load(const char* fn, Long_t startpos = 0, Long_t length = -1); Load text from file fn. Startpos is the begin from where to; load the file and length is the number of characters to read; from the file. Bool_t LoadBuffer(const char* txtbuf); Load a 0 terminated buffer. Lines will be split at '\n'. Bool_t Save(const char* fn); Save text buffer to file fn. Bool_t Append(const char* fn); Append buffer to file fn. Bool_t DelChar(TGLongPosition pos); Delete character at specified position pos. Bool_t InsChar(TGLongPosition pos, char c); Insert character c at the specified position pos. char GetChar(TGLongPosition pos); Get character a position pos. If charcater not valid return -1. Bool_t DelText(TGLongPosition start, TGLongPosition end); Delete text between start and end positions. Returns false in; case of failure (start and end not being within bounds). Bool_t InsText(TGLongPosition ins_pos, TGText* src, TGLongPosition start_src, TGLongPosition end_src); Insert src text from start_src to end_src into text at position ins_pos.; Returns false in case of failure (start_src, end_src out of range for; src, and ins_pos out of range for this). Bool_t InsText(TGLongPosition pos, const char* buf); Insert single line at specified position. Return false in case position; is out of bounds. Bool_t AddText(TGText* text); Add another text buffer to this buffer. Bool_t InsLine(ULong_t row, const char* string); Insert string before specified position.; Returns false if insertion failed. Bool_t DelLine(ULong_t pos); Delete specified row. Returns false if row does not exist. char * GetLine(TGLongPosition pos, ULong_t length); Return string at position pos. Returns 0 in case pos is not valid.; The returned string must be deleted by the user. Bool_t BreakLine(TGLongPosition pos); Break line at position pos. Returns fa",MatchSource.WIKI,root/html602/TGText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGText.html
Performance,load,loaded,". TGText. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGText. class TGText. TGText. A TGText is a multi line text buffer. It allows the text to be; loaded from file, saved to file and edited. It is used in the; TGTextEdit widget. Single line text is handled by TGTextBuffer; and the TGTextEntry widget. Function Members (Methods); public:. virtual~TGText(); Bool_tAddText(TGText* text); Bool_tAppend(const char* fn); TStringAsString(); Bool_tBreakLine(TGLongPosition pos); static TClass*Class(); voidClear(); Long_tColCount() const; Bool_tDelChar(TGLongPosition pos); Bool_tDelLine(ULong_t pos); Bool_tDelText(TGLongPosition start, TGLongPosition end); charGetChar(TGLongPosition pos); TGTextLine*GetCurrentLine() const; const char*GetFileName() const; char*GetLine(TGLongPosition pos, ULong_t length); Long_tGetLineLength(Long_t row); Long_tGetLongestLine() const; Bool_tInsChar(TGLongPosition pos, char c); Bool_tInsLine(ULong_t row, const char* string); Bool_tInsText(TGLongPosition pos, const char* buf); Bool_tInsText(TGLongPosition ins_pos, TGText* src, TGLongPosition start_src, TGLongPosition end_src); virtual TClass*IsA() const; Bool_tIsSaved() const; Bool_tLoad(const char* fn, Long_t startpos = 0, Long_t length = -1); Bool_tLoadBuffer(const char* txtbuf); Bool_tReplace(TGLongPosition start, const char* oldText, const char* newText, Bool_t direction, Bool_t caseSensitive); voidReTab(Long_t row); Long_tRowCount() const; Bool_tSave(const char* fn); Bool_tSearch(TGLongPosition* foundPos, TGLongPosition start, const char* searchString, Bool_t direction, Bool_t caseSensitive); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGText(); TGText(TGText* text); TGText(const char* string). protected:. voidIn",MatchSource.WIKI,root/html602/TGText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGText.html
Energy Efficiency,power,powerful,". TGTextBuffer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTextBuffer. class TGTextBuffer. TGTextBuffer. A text buffer is used in several widgets, like TGTextEntry,; TGFileDialog, etc. It is a little wrapper around the powerful; TString class and used for single line texts. For multi line texts; use TGText. Function Members (Methods); public:. virtual~TGTextBuffer(); voidAddText(Int_t pos, const char* text); voidAddText(Int_t pos, const char* text, Int_t length); static TClass*Class(); voidClear(); UInt_tGetBufferLength() const; const char*GetString() const; UInt_tGetTextLength() const; virtual TClass*IsA() const; voidRemoveText(Int_t pos, Int_t length); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGTextBuffer(); TGTextBuffer(Int_t length). protected:. TGTextBuffer&operator=(const TGTextBuffer& tb); TGTextBuffer(const TGTextBuffer& tb). Data Members; private:. TString*fBuffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGTextBuffer(const TGTextBuffer& tb); { }. TGTextBuffer& operator=(const TGTextBuffer& tb); {if(this!=&tb) fBuffer=tb.fBuffer; return *this;}. TGTextBuffer(); { }. TGTextBuffer(Int_t length); { }. virtual ~TGTextBuffer(); { delete fBuffer; }. UInt_t GetTextLength() const; { return fBuffer->Length(); }. UInt_t GetBufferLength() const; { return fBuffer->Capacity(); }. const char * GetString() const; { return fBuffer->Data(); }. void AddText(Int_t pos, const char* text); { fBuffer->Insert(pos, text); }. void AddText(Int_t pos, const char* text, Int_t length); { fBuffer->Insert(pos, text, length); }. void RemoveText(Int_t pos, Int_t length); { fBuffer->Remove(pos, length); }. void Clear(); { fBuffer->Remove(0, fBuffer->Leng",MatchSource.WIKI,root/html602/TGTextBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextBuffer.html
Integrability,wrap,wrapper,". TGTextBuffer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTextBuffer. class TGTextBuffer. TGTextBuffer. A text buffer is used in several widgets, like TGTextEntry,; TGFileDialog, etc. It is a little wrapper around the powerful; TString class and used for single line texts. For multi line texts; use TGText. Function Members (Methods); public:. virtual~TGTextBuffer(); voidAddText(Int_t pos, const char* text); voidAddText(Int_t pos, const char* text, Int_t length); static TClass*Class(); voidClear(); UInt_tGetBufferLength() const; const char*GetString() const; UInt_tGetTextLength() const; virtual TClass*IsA() const; voidRemoveText(Int_t pos, Int_t length); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGTextBuffer(); TGTextBuffer(Int_t length). protected:. TGTextBuffer&operator=(const TGTextBuffer& tb); TGTextBuffer(const TGTextBuffer& tb). Data Members; private:. TString*fBuffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGTextBuffer(const TGTextBuffer& tb); { }. TGTextBuffer& operator=(const TGTextBuffer& tb); {if(this!=&tb) fBuffer=tb.fBuffer; return *this;}. TGTextBuffer(); { }. TGTextBuffer(Int_t length); { }. virtual ~TGTextBuffer(); { delete fBuffer; }. UInt_t GetTextLength() const; { return fBuffer->Length(); }. UInt_t GetBufferLength() const; { return fBuffer->Capacity(); }. const char * GetString() const; { return fBuffer->Data(); }. void AddText(Int_t pos, const char* text); { fBuffer->Insert(pos, text); }. void AddText(Int_t pos, const char* text, Int_t length); { fBuffer->Insert(pos, text, length); }. void RemoveText(Int_t pos, Int_t length); { fBuffer->Remove(pos, length); }. void Clear(); { fBuffer->Remove(0, fBuffer->Leng",MatchSource.WIKI,root/html602/TGTextBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextBuffer.html
Availability,avail,available,"_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Methods); public:. virtual~TGTextButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtua",MatchSource.WIKI,root/html602/TGTextButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextButton.html
Deployability,release,released,Context_tTGButton::fNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tfPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tfStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*fTLayouttext layout; Int_tfTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tfWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled.,MatchSource.WIKI,root/html602/TGTextButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextButton.html
Integrability,message,message,"""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Method",MatchSource.WIKI,root/html602/TGTextButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextButton.html
Performance,perform,perform,". TGTextButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTextButton. class TGTextButton: public TGButton. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; ",MatchSource.WIKI,root/html602/TGTextButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextButton.html
Security,access,access,". TGTextButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTextButton. class TGTextButton: public TGButton. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; ",MatchSource.WIKI,root/html602/TGTextButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextButton.html
Testability,log,logical," widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked",MatchSource.WIKI,root/html602/TGTextButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextButton.html
Availability,error,error,":Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidEnableCursorWithoutFocus(Bool_t on = kTRUE); virtual voidEnableMenu(Bool_t on = kTRUE)TOGGLE GETTER ; virtual voidEnd(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFindAgain()SIGNAL ; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGViewFrame*TGView::GetCanvas() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); TGLongPositionGetCurrentPos() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::",MatchSource.WIKI,root/html602/TGTextEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextEdit.html
Integrability,message,messages,". TGTextEdit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTextEdit. class TGTextEdit: public TGTextView. TGTextEdit. A TGTextEdit is a specialization of TGTextView. It provides the; text edit functionality to the static text viewing widget.; For the messages supported by this widget see the TGView class. Function Members (Methods); public:. virtual~TGTextEdit(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTGTextView::AddLine(const char* string); virtual voidTGTextView::AddLineFast(const char* string); virtual voidTGTextView::AddText(TGText* text); virtual voidTGTextView::AdjustWidth(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidBreakLine(); virtual voidTObject::Browse(TBrowser* b); virtual voidTGView::ChangeBackground(Pixel_t); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidClear(Option_t* = """"); virtual voidTGTextView::Clicked(const char* word)SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClosed()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* ",MatchSource.WIKI,root/html602/TGTextEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextEdit.html
Availability,avail,available,"nge the file name use File menu /; Save As... or corresponding SaveAs button on the toolbar. Text Selection. You can move the cursor by simply clicking on the desired location; with the left mouse button. To highlight some text, press the mouse; and drag the mouse while holding the left button pressed.; To select a word, double-click on it;; to select the text line - triple-click on it;; to select all do quadruple-click. Cut, Copy, Paste. After selecting some text, you can cut or copy it to the clipboard.; A subsequent paste operation will insert the contents of the; clipboard at the current cursor location. Text Search. The editor uses a standard Search dialog. You can specify a forward; or backward search direction starting from the current cursor; location according to the selection made of a case sensitive mode; or not. The last search can be repeated by pressing F3. Text Font. You can change the text font by selecting Edit menu / Set Font.; The Font Dialog pops up and shows the Name, Style, and Size of any; available font. The selected font sample is shown in the preview; area. Executing Macros. You can execute the currently loaded macro in the editor by; selecting Tools menu / Execute Macro; by clicking on the; corresponding toolbar button, or by using Ctrl+F5 accelerator keys.; This is identical to the command "".x macro.C"" in the root prompt; command line. Compiling Macros. The currently loaded macro can be compiled with ACLiC if you select; Tools menu / Compile Macro; by clicking on the corresponding; toolbar button, or by using Ctrl+F7 accelerator keys.; This is identical to the command "".L macro.C++"" in the root prompt; command line. Interrupting a Running Macro. You can interrupt a running macro by selecting the Tools menu /; Interrupt; by clicking on the corresponding toolbar button, or by; using Shift+F5 accelerator keys. Interface to CINT Interpreter. Any command entered in the Command combo box will be passed to; the CINT interpreter. This combo box wi",MatchSource.WIKI,root/html602/TGTextEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextEditor.html
Deployability,update,update,"ar; TGLayoutHints*fMenuBarItemLayoutused for for menubar items; TGLayoutHints*fMenuBarLayoutused for the menubar; TGPopupMenu*fMenuEdit""Edit"" menu entry; TGPopupMenu*fMenuFile""File"" menu entry; TGPopupMenu*fMenuHelp""Help"" menu entry; TGPopupMenu*fMenuSearch""Search"" menu entry; TGPopupMenu*fMenuTools""Tools"" menu entry; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TStringTGMainFrame::fResourceNameWM resource name; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGStatusBar*fStatusBarfor file name, line and col number; Bool_tfTextChangedtrue if text has changed; TGTextEdit*fTextEdittext edit widget; TTimer*fTimerfor statusbar and toolbar update; TGToolBar*fToolBartoolbar with common tool buttons; UInt_tTGMainFrame::fWMHeightWM height; UInt_tTGMainFrame::fWMHeightIncWM height increments; EInitialStateTGMainFrame::fWMInitStateWM initial state; UInt_tTGMainFrame::fWMMaxHeightWM max height; UInt_tTGMainFrame::fWMMaxWidthWM max width; UInt_tTGMainFrame::fWMMinHeightWM min height; UInt_tTGMainFrame::fWMMinWidthWM min width; UInt_tTGMainFrame::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; sta",MatchSource.WIKI,root/html602/TGTextEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextEditor.html
Modifiability,extend,extend,"bar button, or by using Ctrl+F5 accelerator keys.; This is identical to the command "".x macro.C"" in the root prompt; command line. Compiling Macros. The currently loaded macro can be compiled with ACLiC if you select; Tools menu / Compile Macro; by clicking on the corresponding; toolbar button, or by using Ctrl+F7 accelerator keys.; This is identical to the command "".L macro.C++"" in the root prompt; command line. Interrupting a Running Macro. You can interrupt a running macro by selecting the Tools menu /; Interrupt; by clicking on the corresponding toolbar button, or by; using Shift+F5 accelerator keys. Interface to CINT Interpreter. Any command entered in the Command combo box will be passed to; the CINT interpreter. This combo box will keep the commands history; and will allow you to re-execute the same commands during an editor; session. Keyboard Bindings. The following table lists the keyboard shortcuts and accelerator; keys. Key: Action:. Up Move cursor up.; Shift+Up Move cursor up and extend selection.; Down Move cursor down.; Shift+Down Move cursor down and extend selection.; Left Move cursor left.; Shift+Left Move cursor left and extend selection.; Right Move cursor right.; Shift+Right Move cursor right and extend selection.; Home Move cursor to begin of line.; Shift+Home Move cursor to begin of line and extend selection.; Ctrl+Home Move cursor to top of page.; End Move cursor to end of line.; Shift+End Move cursor to end of line and extend selection.; Ctrl+End Move cursor to end of page.; PgUp Move cursor up one page.; Shift+PgUp Move cursor up one page and extend selection.; PgDn Move cursor down one page.; Shift+PgDn Move cursor down one page and extend selection.; Delete Delete character after cursor, or text selection.; BackSpace Delete character before cursor, or text selection.; Ctrl+B Move cursor left.; Ctrl+D Delete character after cursor, or text selection.; Ctrl+E Move cursor to end of line.; Ctrl+H Delete character before cursor, or text selectio",MatchSource.WIKI,root/html602/TGTextEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextEditor.html
Performance,load,loaded,"ghlight some text, press the mouse; and drag the mouse while holding the left button pressed.; To select a word, double-click on it;; to select the text line - triple-click on it;; to select all do quadruple-click. Cut, Copy, Paste. After selecting some text, you can cut or copy it to the clipboard.; A subsequent paste operation will insert the contents of the; clipboard at the current cursor location. Text Search. The editor uses a standard Search dialog. You can specify a forward; or backward search direction starting from the current cursor; location according to the selection made of a case sensitive mode; or not. The last search can be repeated by pressing F3. Text Font. You can change the text font by selecting Edit menu / Set Font.; The Font Dialog pops up and shows the Name, Style, and Size of any; available font. The selected font sample is shown in the preview; area. Executing Macros. You can execute the currently loaded macro in the editor by; selecting Tools menu / Execute Macro; by clicking on the; corresponding toolbar button, or by using Ctrl+F5 accelerator keys.; This is identical to the command "".x macro.C"" in the root prompt; command line. Compiling Macros. The currently loaded macro can be compiled with ACLiC if you select; Tools menu / Compile Macro; by clicking on the corresponding; toolbar button, or by using Ctrl+F7 accelerator keys.; This is identical to the command "".L macro.C++"" in the root prompt; command line. Interrupting a Running Macro. You can interrupt a running macro by selecting the Tools menu /; Interrupt; by clicking on the corresponding toolbar button, or by; using Shift+F5 accelerator keys. Interface to CINT Interpreter. Any command entered in the Command combo box will be passed to; the CINT interpreter. This combo box will keep the commands history; and will allow you to re-execute the same commands during an editor; session. Keyboard Bindings. The following table lists the keyboard shortcuts and accelerator; keys. Key: Action",MatchSource.WIKI,root/html602/TGTextEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextEditor.html
Usability,simpl,simple,". TGTextEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTextEditor. class TGTextEditor: public TGMainFrame. TGTextEditor. A simple text editor that uses the TGTextEdit widget.; It provides all functionalities of TGTextEdit as copy, paste, cut,; search, go to a given line number. In addition, it provides the; possibilities for compiling, executing or interrupting a running; macro. This class can be used in following ways:; - with file name as argument:; new TGTextEditor(""hsimple.C"");; - with a TMacro* as argument:; TMacro *macro = new TMacro(""hsimple.C"");; new TGTextEditor(macro);. Basic Features:. New Document. To create a new blank document, select File menu / New, or click; the New toolbar button. It will create a new instance of; TGTextEditor. Open/Save File. To open a file, select File menu / Open or click on the Open; toolbar button. This will bring up the standard File Dialog for; opening files.; If the current document has not been saved yet, you will be asked; either to save or abandon the changes.; To save the file using the same name, select File menu / Save or; the toolbar Save button. To change the file name use File menu /; Save As... or corresponding SaveAs button on the toolbar. Text Selection. You can move the cursor by simply clicking on the desired location; with the left mouse button. To highlight some text, press the mouse; and drag the mouse while holding the left button pressed.; To select a word, double-click on it;; to select the text line - triple-click on it;; to select all do quadruple-click. Cut, Copy, Paste. After selecting some text, you can cut or copy it to the clipboard.; A subsequent paste operation will insert the contents of the; clipboard at the current cursor location. Text Search. The editor uses a standard Search dialog. You can specify a f",MatchSource.WIKI,root/html602/TGTextEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextEditor.html
Availability,error,error,"nst char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEnd(Bool_t mark = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; ETextJustificationGetAlignment() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGTextBuffer*GetBuffer() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); Int_tGetCursorPosition() const; static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSel",MatchSource.WIKI,root/html602/TGTextEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextEntry.html
Testability,test,test,"GC; static const TGGC*fgDefaultSelectedGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGTextEntry(const TGWindow* p, TGTextBuffer* text, Int_t id = -1, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t option = kSunkenFrame | kDoubleBorder, Pixel_t back = GetWhitePixel()); Create a text entry widget. It will adopt the TGTextBuffer object; (i.e. the text buffer will be deleted by the text entry widget). TGTextEntry(const TGWindow* parent = 0, const char* text = 0, Int_t id = -1); Simple text entry constructor. TGTextEntry(const TString& contents, const TGWindow* parent, Int_t id = -1); Simple test entry constructor. Notice TString argument comes before the; parent argument (to make this ctor different from the first one taking a; const char*). ~TGTextEntry(); Delete a text entry widget. void Init(); Do default initialization. TGDimension GetDefaultSize() const; Return the default / minimal size of the widget. void SetDefaultSize(UInt_t w, UInt_t h); Set the default / minimal size of the widget. void ReturnPressed(); This signal is emitted when the return or enter key is pressed. void ShiftTabPressed(); This signal is emitted when <SHIFT> and <TAB> keys are pressed. void TabPressed(); This signal is emitted when the <TAB> key is pressed. void TextChanged(const char* text = 0); This signal is emitted every time the text has changed. void CursorOutLeft(); This signal is emitted when cursor is going out of left side. void CursorOutRight(); This signal is emitted when cursor is going out of right side. void CursorOutUp(); This signal is emitted whe",MatchSource.WIKI,root/html602/TGTextEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextEntry.html
Usability,clear,clears," widget is double clicked. TString GetDisplayText() const; Returns the text that's currently displayed. This is normally; the same as GetText(), but can be e.g.; ""*****"" if EEchoMode is kPassword or; """" if it is kNoEcho. void SetState(Bool_t state); Set state of widget. If kTRUE=enabled, kFALSE=disabled. Int_t GetCharacterIndex(Int_t xcoord); Returns the index of the character to whose left edge xcoord is closest. void SetFrameDrawn(Bool_t flag = kTRUE); Sets the text entry to draw itself inside a two-pixel frame if; enable is kTRUE, and to draw itself without any frame if enable is; kFALSE. The default is kTRUE. void SetAlignment(ETextJustification mode = kTextLeft); Sets the alignment of the text entry.; Possible values are kTextLeft(default), kTextRight, kTextCenterX.; See also GetAlignment(). void SetInsertMode(TGTextEntry::EInsertMode mode = kInsert); Sets the mode how characters are entered to the text entry. void SetText(const char* text, Bool_t emit = kTRUE); Sets text entry to text, clears the selection and moves; the cursor to the end of the line.; If necessary the text is truncated to fit MaxLength().; See also GetText(). void SetMaxLength(Int_t maxlen); Set the maximum length of the text in the editor. If the text is; currently too long, it is chopped off at the limit. Any marked text will; be unmarked. The cursor position is set to 0 and the first part of the; string is shown.; See also GetMaxLength(). void SetEchoMode(TGTextEntry::EEchoMode mode = kNormal); The echo modes available are:. ; kNormal - display characters as they are entered. This is the default.; kNoEcho - do not display anything.; kPassword - display asterisks instead of the characters actually entered.; . It is always possible to cut and paste any marked text; only the widget's own; display is affected.; See also GetEchoMode(), GetDisplayText(). TString GetMarkedText() const; Returns the text marked by the user (e.g. by clicking and; dragging), or zero if no text is marked.; See also Has",MatchSource.WIKI,root/html602/TGTextEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextEntry.html
Availability,error,error,"e(TBrowser* b); Int_tCharBbox(Int_t index, Int_t* x, Int_t* y, Int_t* w, Int_t* h) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Int_tDistanceToText(Int_t x, Int_t y) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawText(Drawable_t dst, GContext_t gc, Int_t x, Int_t y, Int_t firstChar, Int_t lastChar) const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html602/TGTextLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextLayout.html
Integrability,depend,depending,",; or overlaps a given rectangle. Non-displaying space characters that occur; at the end of individual lines in the text layout are ignored for; intersection calculations. The return value is -1 if the text layout is entirely outside of the; rectangle, 0 if it overlaps, and 1 if it is entirely inside of the; rectangle. x, y -- Upper-left hand corner, in pixels, of rectangular area to compare; with text layout. Coordinates are with respect to the upper-left; hand corner of the text layout itself.; w, h -- The width and height of the above rectangular area, in pixels. void ToPostscript(TString* dst) const; Outputs the contents of a text layout in Postscript format. The set of; lines in the text layout will be rendered by the user supplied Postscript; function. The function should be of the form:. justify x y string function --. Justify is -1, 0, or 1, depending on whether the following string should; be left, center, or right justified, x and y is the location for the; origin of the string, string is the sequence of characters to be printed,; and function is the name of the caller-provided function; the function; should leave nothing on the stack. The meaning of the origin of the string (x and y) depends on the; justification. For left justification, x is where the left edge of the; string should appear. For center justification, x is where the center of; the string should appear. And for right justification, x is where the; right edge of the string should appear. This behavior is necessary; because, for example, right justified text on the screen is justified; with screen metrics. The same string needs to be justified with printer; metrics on the printer to appear in the correct place with respect to; other similarly justified strings. In all circumstances, y is the; location of the baseline for the string. result is modified to hold the Postscript code that will render the text; layout. FontAttributes_t& operator=(const TGTextLayout& tlayout). TGTextLayout(const TGT",MatchSource.WIKI,root/html602/TGTextLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextLayout.html
Modifiability,extend,extends,"o the; first character in the text layout; any point whose y-value is greater; than the height of the text layout will be considered closest to the last; character in the text layout. Any point whose x-value is less than 0 will be considered closest to the; first character on that line; any point whose x-value is greater than the; width of the text layout will be considered closest to the last character; on that line. The return value is the index of the character that was closest to the; point. Given a text layout with no characters, the value 0 will always; be returned, referring to a hypothetical zero-width placeholder character. Int_t CharBbox(Int_t index, Int_t* x, Int_t* y, Int_t* w, Int_t* h) const; Use the information in the TGTextLayout token to return the bounding box; for the character specified by index. The width of the bounding box is the advance width of the character, and; does not include and left- or right-bearing. Any character that extends; partially outside of the text layout is considered to be truncated at the; edge. Any character which is located completely outside of the text; layout is considered to be zero-width and pegged against the edge. The height of the bounding box is the line height for this font,; extending from the top of the ascent to the bottom of the descent.; Information about the actual height of the individual letter is not; available. A text layout that contains no characters is considered to contain a; single zero-width placeholder character. The return value is 0 if the index did not specify a character in the; text layout, or non-zero otherwise. In that case, *bbox is filled with; the bounding box of the character. layout -- Layout information, from a previous call to ComputeTextLayout().; index -- The index of the character whose bbox is desired.; x, y -- Filled with the upper-left hand corner, in pixels, of the; bounding box for the character specified by index, if non-NULL.; w, h -- Filled with the width and height of ",MatchSource.WIKI,root/html602/TGTextLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextLayout.html
Safety,detect,detection,"from the top of the ascent to the bottom of the descent.; Information about the actual height of the individual letter is not; available. A text layout that contains no characters is considered to contain a; single zero-width placeholder character. The return value is 0 if the index did not specify a character in the; text layout, or non-zero otherwise. In that case, *bbox is filled with; the bounding box of the character. layout -- Layout information, from a previous call to ComputeTextLayout().; index -- The index of the character whose bbox is desired.; x, y -- Filled with the upper-left hand corner, in pixels, of the; bounding box for the character specified by index, if non-NULL.; w, h -- Filled with the width and height of the bounding box for the; character specified by index, if non-NULL. Int_t DistanceToText(Int_t x, Int_t y) const; Computes the distance in pixels from the given point to the given; text layout. Non-displaying space characters that occur at the end of; individual lines in the text layout are ignored for hit detection; purposes. The return value is 0 if the point (x, y) is inside the text layout.; If the point isn't inside the text layout then the return value is the; distance in pixels from the point to the text item. x, y -- Coordinates of point to check, with respect to the upper-left; corner of the text layout (in pixels). Int_t IntersectText(Int_t x, Int_t y, Int_t w, Int_t h) const; Determines whether a text layout lies entirely inside, entirely outside,; or overlaps a given rectangle. Non-displaying space characters that occur; at the end of individual lines in the text layout are ignored for; intersection calculations. The return value is -1 if the text layout is entirely outside of the; rectangle, 0 if it overlaps, and 1 if it is entirely inside of the; rectangle. x, y -- Upper-left hand corner, in pixels, of rectangular area to compare; with text layout. Coordinates are with respect to the upper-left; hand corner of the text layout i",MatchSource.WIKI,root/html602/TGTextLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextLayout.html
Usability,simpl,simple,"atic TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. LayoutChunk_t*fChunksArray of chunks. The actual size will be maxChunks.; const TGFont*fFontThe font used when laying out the text.; Int_tfNumChunksNumber of chunks actually used in following array.; const char*fStringThe string that was layed out.; Int_tfWidthThe maximum width of all lines in the text layout. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGTextLayout(); destructor. void DrawText(Drawable_t dst, GContext_t gc, Int_t x, Int_t y, Int_t firstChar, Int_t lastChar) const; Use the information in the TGTextLayout object to display a multi-line,; justified string of text. This procedure is useful for simple widgets that need to display; single-font, multi-line text and want TGFont to handle the details. dst -- Window or pixmap in which to draw.; gc -- Graphics context to use for drawing text.; x, y -- Upper-left hand corner of rectangle in which to draw; (pixels).; firstChar -- The index of the first character to draw from the given; text item. 0 specfies the beginning.; lastChar -- The index just after the last character to draw from the; given text item. A number < 0 means to draw all characters. void UnderlineChar(Drawable_t dst, GContext_t gc, Int_t x, Int_t y, Int_t underline) const; Use the information in the TGTextLayout object to display an underline; below an individual character. This procedure does not draw the text,; just the underline. This procedure is useful for simple widgets that need to display; single-font, multi-line text with an individual character underlined; and want TGFont to handle the details. To display larger amounts of; underlined text, construct and use an underlined font. dst -- Window ",MatchSource.WIKI,root/html602/TGTextLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextLayout.html
Availability,error,error,"t char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); Int_tTGLBEntry::EntryId() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDDat",MatchSource.WIKI,root/html602/TGTextLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextLBEntry.html
Usability,simpl,simple,". TGTextLBEntry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTextLBEntry. class TGTextLBEntry: public TGLBEntry. TGListBox, TGLBContainer, TGLBEntry and TGTextLBEntry. A listbox is a box, possibly with scrollbar, containing entries.; Currently entries are simple text strings (TGTextLBEntry).; A TGListBox looks a lot like a TGCanvas. It has a TGViewPort; containing a TGLBContainer which contains the entries and it also; has a vertical scrollbar which becomes visible if there are more; items than fit in the visible part of the container. The TGListBox is user callable. The other classes are service; classes of the listbox. Selecting an item in the listbox will generate the event:; kC_COMMAND, kCM_LISTBOX, listbox id, item id. Function Members (Methods); public:. virtual~TGTextLBEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGLBEntry::Activate(Bool_t a); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQO",MatchSource.WIKI,root/html602/TGTextLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextLBEntry.html
Performance,load,loaded,". TGTextLine. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTextLine. class TGTextLine. TGText. A TGText is a multi line text buffer. It allows the text to be; loaded from file, saved to file and edited. It is used in the; TGTextEdit widget. Single line text is handled by TGTextBuffer; and the TGTextEntry widget. Function Members (Methods); public:. virtual~TGTextLine(); static TClass*Class(); voidClear(); voidDelChar(ULong_t pos); voidDelText(ULong_t pos, ULong_t length); charGetChar(ULong_t pos); ULong_tGetLineLength(); char*GetText() const; char*GetText(ULong_t pos, ULong_t length); char*GetWord(ULong_t pos); voidInsChar(ULong_t pos, char character); voidInsText(ULong_t pos, const char* text); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGTextLine(); TGTextLine(TGTextLine* line); TGTextLine(const char* string). protected:. TGTextLine&operator=(const TGTextLine&); TGTextLine(const TGTextLine&). Data Members; protected:. ULong_tfLengthlength of line; TGTextLine*fNextnext line; TGTextLine*fPrevprevious line; char*fStringline of text. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGTextLine(); Create empty line of text (default ctor). TGTextLine(TGTextLine* line); Initialize line of text with other line of text (not copy ctor). TGTextLine(const char* string); Initialize line of text with a const char*. TGTextLine(const TGTextLine& ); copy constructor. TGTextLine& operator=(const TGTextLine& ); assignment operator. ~TGTextLine(); Delete a line of text. void Clear(); Clear a line of text. void DelText(ULong_t pos, ULong_t length); Delete length chars from line starting at position pos. void InsText(ULong_t pos, cons",MatchSource.WIKI,root/html602/TGTextLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextLine.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGViewFrame*TGView::GetCanvas() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGView::GetDefault",MatchSource.WIKI,root/html602/TGTextView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextView.html
Deployability,update,update,"Pixel()); Create a text view widget. TGTextView(const TGWindow* parent, UInt_t w, UInt_t h, TGText* text, Int_t id = -1, UInt_t sboptions = 0, Pixel_t back = GetWhitePixel()); Create a text view widget. TGTextView(const TGWindow* parent, UInt_t w, UInt_t h, const char* string, Int_t id = -1, UInt_t sboptions = 0, Pixel_t back = GetWhitePixel()); Create a text view widget. ~TGTextView(); Cleanup text view widget. void SetBackground(Pixel_t p); set background color. void SetSelectBack(Pixel_t p); set selected text background color. void SetSelectFore(Pixel_t p); set selected text color. void SetText(TGText* text); Adopt a new text buffer. The text will be deleted by this object. void AddText(TGText* text); Add text to the view widget. void AddLine(const char* string); Add a line of text to the view widget. void AddLineFast(const char* string); Add a line of text to the view widget.; Fast version. Use it if you are going to add; several lines, than call Update(). void Update(); update the whole window of text view. Long_t ReturnLongestLineWidth(); Return width of longest line. Bool_t Search(const char* string, Bool_t direction, Bool_t caseSensitive); Search for string in text. If direction is true search forward.; Returns true if string is found. void SetFont(FontStruct_t font); Changes text entry font. Long_t ToScrYCoord(Long_t yCoord); Convert line number to screen coordinate. Long_t ToScrXCoord(Long_t xCoord, Long_t line); Convert column number in specified line to screen coordinate. Long_t ToObjYCoord(Long_t yCoord); Convert y screen coordinate to line number. Long_t ToObjXCoord(Long_t xCoord, Long_t line); Convert x screen coordinate to column in specified line. void Clear(Option_t* = """"); Clear text view widget. Bool_t LoadFile(const char* fname, long startpos = 0, long length = -1); Load a file in the text view widget. Return false in case file does not; exist. Bool_t LoadBuffer(const char* txtbuf); Load text from a text buffer. Return false in case of failure. B",MatchSource.WIKI,root/html602/TGTextView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextView.html
Integrability,message,messages,". TGTextView. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTextView. class TGTextView: public TGView. TGTextView. A TGTextView is a text viewer widget. It is a specialization of; TGView. It uses the TGText class (which contains all text; manipulation code, i.e. loading a file in memory, changing,; removing lines, etc.). Use a TGTextView to view non-editable text.; For supported messages see TGView. Function Members (Methods); public:. virtual~TGTextView(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidAddLine(const char* string); virtual voidAddLineFast(const char* string); virtual voidAddText(TGText* text); virtual voidAdjustWidth(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGView::ChangeBackground(Pixel_t); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidClear(Option_t* = """"); virtual voidClicked(const char* word)SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char*",MatchSource.WIKI,root/html602/TGTextView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextView.html
Performance,load,loading,". TGTextView. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTextView. class TGTextView: public TGView. TGTextView. A TGTextView is a text viewer widget. It is a specialization of; TGView. It uses the TGText class (which contains all text; manipulation code, i.e. loading a file in memory, changing,; removing lines, etc.). Use a TGTextView to view non-editable text.; For supported messages see TGView. Function Members (Methods); public:. virtual~TGTextView(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidAddLine(const char* string); virtual voidAddLineFast(const char* string); virtual voidAddText(TGText* text); virtual voidAdjustWidth(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGView::ChangeBackground(Pixel_t); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidClear(Option_t* = """"); virtual voidClicked(const char* word)SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char*",MatchSource.WIKI,root/html602/TGTextView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextView.html
Security,expose,exposed,"n, Bool_t caseSensitive); Search for string in text. If direction is true search forward.; Returns true if string is found. void SetFont(FontStruct_t font); Changes text entry font. Long_t ToScrYCoord(Long_t yCoord); Convert line number to screen coordinate. Long_t ToScrXCoord(Long_t xCoord, Long_t line); Convert column number in specified line to screen coordinate. Long_t ToObjYCoord(Long_t yCoord); Convert y screen coordinate to line number. Long_t ToObjXCoord(Long_t xCoord, Long_t line); Convert x screen coordinate to column in specified line. void Clear(Option_t* = """"); Clear text view widget. Bool_t LoadFile(const char* fname, long startpos = 0, long length = -1); Load a file in the text view widget. Return false in case file does not; exist. Bool_t LoadBuffer(const char* txtbuf); Load text from a text buffer. Return false in case of failure. Bool_t Copy(); Copy selected text to clipboard. Bool_t SelectAll(); Select all text in the viewer. void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw lines in exposed region. Bool_t HandleCrossing(Event_t* event); Handle mouse crossing event. Bool_t HandleTimer(TTimer* t); Handle scroll timer. Bool_t HandleButton(Event_t* event); Handle mouse button event in text editor. Bool_t HandleDoubleClick(Event_t* event); handle double click. Bool_t HandleMotion(Event_t* event); Handle mouse motion event in the text editor widget. Bool_t HandleSelectionClear(Event_t* event); Handle selection clear event. Bool_t HandleSelectionRequest(Event_t* event); Handle request to send current clipboard contents to requestor window. Bool_t HandleDNDDrop(TDNDData* data); Handle Drop event. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle Drag position event. Atom_t HandleDNDEnter(Atom_t* typelist); Handle Drag Enter event. Bool_t HandleDNDLeave(); Handle Drag Leave event. void Mark(Long_t xPos, Long_t yPos); Mark a text region from xPos to yPos. void UnMark(); Clear marked region. void AdjustWidt",MatchSource.WIKI,root/html602/TGTextView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextView.html
Usability,clear,clear,"to line number. Long_t ToObjXCoord(Long_t xCoord, Long_t line); Convert x screen coordinate to column in specified line. void Clear(Option_t* = """"); Clear text view widget. Bool_t LoadFile(const char* fname, long startpos = 0, long length = -1); Load a file in the text view widget. Return false in case file does not; exist. Bool_t LoadBuffer(const char* txtbuf); Load text from a text buffer. Return false in case of failure. Bool_t Copy(); Copy selected text to clipboard. Bool_t SelectAll(); Select all text in the viewer. void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw lines in exposed region. Bool_t HandleCrossing(Event_t* event); Handle mouse crossing event. Bool_t HandleTimer(TTimer* t); Handle scroll timer. Bool_t HandleButton(Event_t* event); Handle mouse button event in text editor. Bool_t HandleDoubleClick(Event_t* event); handle double click. Bool_t HandleMotion(Event_t* event); Handle mouse motion event in the text editor widget. Bool_t HandleSelectionClear(Event_t* event); Handle selection clear event. Bool_t HandleSelectionRequest(Event_t* event); Handle request to send current clipboard contents to requestor window. Bool_t HandleDNDDrop(TDNDData* data); Handle Drop event. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle Drag position event. Atom_t HandleDNDEnter(Atom_t* typelist); Handle Drag Enter event. Bool_t HandleDNDLeave(); Handle Drag Leave event. void Mark(Long_t xPos, Long_t yPos); Mark a text region from xPos to yPos. void UnMark(); Clear marked region. void AdjustWidth(); Adjust widget width to longest line. void Layout(); Layout the components of view. void HLayout(); Horizontal layout of widgets (canvas, scrollbar). void VLayout(); Vertical layout of widgets (canvas, scrollbar). void SetSBRange(Int_t direction); Set the range for the kVertical or kHorizontal scrollbar. void SetHsbPosition(Long_t newPos); Set position of horizontal scrollbar. void SetVsbPosition(Long_t newPos); Set position",MatchSource.WIKI,root/html602/TGTextView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTextView.html
Availability,down,downward,". TGTileLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTileLayout. class TGTileLayout: public TGLayoutManager. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. virtual~TGTileLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObje",MatchSource.WIKI,root/html602/TGTileLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTileLayout.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TGButton*GetButton(Int_t id) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt",MatchSource.WIKI,root/html602/TGToolBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGToolBar.html
Integrability,message,messages,"rame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGToolBar(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kHorizontalFrame, Pixel_t back = GetDefaultFrameBackground()); Create toolbar widget. ~TGToolBar(); Delete toolbar and its buttons and layout hints. TGButton * AddButton(const TGWindow* w, ToolBarData_t* button, Int_t spacing = 0); Add button to toolbar. All buttons added via this method will be; deleted by the toolbar. On return the TGButton field of the; ToolBarData_t struct is filled in (if fPixmap was valid).; Window w is the window to which the button messages will be send. TGButton * AddButton(const TGWindow* w, TGPictureButton* button, Int_t spacing = 0); Add button to toolbar. All buttons added via this method will be deleted; by the toolbar, w is the window to which the button messages will be send. TGButton * GetButton(Int_t id) const; Finds and returns a pointer to the button with the specified; identifier id. Returns null if the button was not found. void SetId(TGButton* button, Long_t id); changes id for button. Long_t GetId(TGButton* button) const; Finds and returns the id of the button.; Returns -1 if the button is not a member of this group. void ChangeIcon(ToolBarData_t* button, const char* new_icon); Change the icon of a toolbar button. void Cleanup(); Cleanup and delete all objects contained in this composite frame.; This will delete all objects added via AddFrame().; CAUTION: all objects (frames and layout hints) must be unique, i.e.; cannot be shared. void ButtonPressed(); This slot is activated when one o",MatchSource.WIKI,root/html602/TGToolBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGToolBar.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGToolTip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGToolTip.html
Availability,error,error,"ethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBRIK::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Float_tGetAlpha1() const; Float_tGetAlpha2() const; Float_tGetBl1() const; Float_tGetBl2() const; virtual const TBuffer3D&TBRIK::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tTBRIK::GetDx() const; Float_tTBRIK::GetDy() const; Float_tTBRIK::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; Float_tGetH1() const; Float_tGetH2() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttL",MatchSource.WIKI,root/html602/TGTRA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTRA.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html602/TGTransientFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTransientFrame.html
Testability,log,logically,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. virtual~TGTransientFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidCenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubf",MatchSource.WIKI,root/html602/TGTransientFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTransientFrame.html
Usability,simpl,simple,". TGTransientFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTransientFrame. class TGTransientFrame: public TGMainFrame. TGFrame, TGCompositeFrame, TGVerticalFrame, TGHorizontalFrame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. virtual~TGTransientFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockS",MatchSource.WIKI,root/html602/TGTransientFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTransientFrame.html
Availability,error,error,"t char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); Int_tTGLBEntry::EntryId() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDDat",MatchSource.WIKI,root/html602/TGTreeLBEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTreeLBEntry.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual const TGTableCell*TGTable::FindCell(TGString label) const; virtual TGTableCell*TGTable::FindCell(TGString label); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TGCanvas*TGTable::GetCanvas(); virtual const TGTableCell*TGTable::GetCell(UInt_t i, UInt_t j) const; virtual TGTableCell*TGTable::GetCell(UInt_t i, UInt_t j); virtual const TGTableHeaderFrame*TGTable::GetCHdrFrame(); TGClient*",MatchSource.WIKI,root/html602/TGTreeTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTreeTable.html
Deployability,update,update, options; const TGWindow*TGWindow::fParentParent window; TGTextButton*TGTable::fPrevButtonButton to view previous chunk; TGTableHeaderFrame*TGTable::fRHdrFrameFrame that contains the row headers; TList*TGTable::fRHdrHintsList; TGTextEntry*TGTable::fRangeEntryTextEntry for the range frame; TGHorizontalFrame*TGTable::fRangeFrameFrame that contains the top part; TGLabel*TGTable::fRangeLabelLabel for the range frame; Bool_tTGTable::fReadOnlyTable readonly state; TObjArray*TGTable::fRowHeadersArray of row headers; TObjArray*TGTable::fRowsArray of rows; Pixel_tTGTable::fSelectColorSelect Color; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTGTable::fTModeText justify mode; TGTableFrame*TGTable::fTableFrameContainer for the frames; TGTableHeader*TGTable::fTableHeaderTop left element of the table; TGHorizontalFrame*TGTable::fTopExtraFrameDev idea; TGHorizontalFrame*TGTable::fTopFrameFrame that contains the top part; TGTextButton*TGTable::fUpdateButtonButton to update current view; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTG,MatchSource.WIKI,root/html602/TGTreeTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTreeTable.html
Integrability,interface,interface,". TGTreeTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TGTreeTable. class TGTreeTable: public TGTable. TGTreeTable. TGTreeTable is a TGTable that owns it's own interface, it; can be used to view a TTree. If an expression is given to the; constuctor, it will be used to define the columns. A selection can; also be given. This selection is applied to the TTree as a; TEntryList. See the documentation of TGTable for more information. The interface is accesible after the creation through the; GetInterface() method. Function Members (Methods); public:. virtual~TGTreeTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); st",MatchSource.WIKI,root/html602/TGTreeTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTreeTable.html
Performance,load,loaded,,MatchSource.WIKI,root/html602/TGTreeTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTreeTable.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGDoubleHSlider::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual ",MatchSource.WIKI,root/html602/TGTripleHSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTripleHSlider.html
Modifiability,inherit,inherit,". TGTripleHSlider. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTripleHSlider. class TGTripleHSlider: public TGDoubleHSlider. TGTripleVSlider and TGTripleHSlider. TripleSlider inherit from DoubleSlider widgets and allow easy; selection of a min, max and pointer value out of a range.; The pointer position can be constrained to edges of slider and / or; can be relative to the slider position. To change the min value press the mouse near to the left / bottom; edge of the slider.; To change the max value press the mouse near to the right / top; edge of the slider.; To change both values simultaneously press the mouse near to the; center of the slider.; To change pointer value press the mouse on the pointer and drag it; to the desired position. Dragging the slider will generate the event:; kC_VSLIDER, kSL_POS, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_POS, slider id, 0 (for horizontal slider). Pressing the mouse will generate the event:; kC_VSLIDER, kSL_PRESS, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_PRESS, slider id, 0 (for horizontal slider). Releasing the mouse will generate the event:; kC_VSLIDER, kSL_RELEASE, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_RELEASE, slider id, 0 (for horizontal slider). Moving the pointer will generate the event:; kC_VSLIDER, kSL_POINTER, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_POINTER, slider id, 0 (for horizontal slider). Use the functions GetMinPosition(), GetMaxPosition() and; GetPosition() to retrieve the position of the slider.; Use the function GetPointerPosition() to retrieve the position of; the pointer. Function Members (Methods); public:. virtual~TGTripleHSlider(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voi",MatchSource.WIKI,root/html602/TGTripleHSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTripleHSlider.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGDoubleVSlider::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual ",MatchSource.WIKI,root/html602/TGTripleVSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTripleVSlider.html
Modifiability,inherit,inherit,". TGTripleVSlider. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTripleVSlider. class TGTripleVSlider: public TGDoubleVSlider. TGTripleVSlider and TGTripleHSlider. TripleSlider inherit from DoubleSlider widgets and allow easy; selection of a min, max and pointer value out of a range.; The pointer position can be constrained to edges of slider and / or; can be relative to the slider position. To change the min value press the mouse near to the left / bottom; edge of the slider.; To change the max value press the mouse near to the right / top; edge of the slider.; To change both values simultaneously press the mouse near to the; center of the slider.; To change pointer value press the mouse on the pointer and drag it; to the desired position. Dragging the slider will generate the event:; kC_VSLIDER, kSL_POS, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_POS, slider id, 0 (for horizontal slider). Pressing the mouse will generate the event:; kC_VSLIDER, kSL_PRESS, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_PRESS, slider id, 0 (for horizontal slider). Releasing the mouse will generate the event:; kC_VSLIDER, kSL_RELEASE, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_RELEASE, slider id, 0 (for horizontal slider). Moving the pointer will generate the event:; kC_VSLIDER, kSL_POINTER, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_POINTER, slider id, 0 (for horizontal slider). Use the functions GetMinPosition(), GetMaxPosition() and; GetPosition() to retrieve the position of the slider.; Use the function GetPointerPosition() to retrieve the position of; the pointer. Function Members (Methods); public:. virtual~TGTripleVSlider(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voi",MatchSource.WIKI,root/html602/TGTripleVSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGTripleVSlider.html
Availability,error,error,,MatchSource.WIKI,root/html602/TGuiBldAction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGuiBldAction.html
Testability,test,tested,"Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGuiBldAction. class TGuiBldAction: public TNamed. TGuiBuilder. ROOT GUI Builder principles. With the GUI builder, we try to make the next step from WYSIWYG; to embedded editing concept - WYSIWYE (""what you see is what you edit"").; The ROOT GUI Builder allows modifying real GUI objects.; For example, one can edit the existing GUI application created by; $ROOTSYS/tutorials/gui/guitest.C.; GUI components can be added to a design area from a widget palette,; or can be borrowed from another application.; One can drag and and drop TCanvas's menu bar into the application.; GUI objects can be resized and dragged, copied and pasted.; ROOT GUI Builder allows changing the layout, snap to grid, change object's; layout order via the GUI Builder toolbar, or by options in the right-click; context menus.; A final design can be immediatly tested and used, or saved as a C++ macro.; For example, it's possible to rearrange buttons in control bar,; add separators etc. and continue to use a new fancy control bar in the; application. The following is a short description of the GUI Builder actions and key shortcuts:. o Press Ctrl-Double-Click to start/stop edit mode; o Press Double-Click to activate quick edit action (defined in root.mimes). Selection, grabbing, dropping. It is possible to select, drag any frame and drop it to any frame. o Click left mouse button or Ctrl-Click to select an object to edit.; o Press right mouse button to activate context menu; o Multiple selection (grabbing):; - draw lasso and press Return key; - press Shift key and draw lasso; o Dropping:; - select frame and press Ctrl-Return key; o Changing layout order:; - select frame and use arrow keys to change layout order; o Alignment:; - draw lasso and press arrow keys (or Shift-Arrow key) to align frames. Key shortcuts. o Return - grab selected frames; o ",MatchSource.WIKI,root/html602/TGuiBldAction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGuiBldAction.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option",MatchSource.WIKI,root/html602/TGuiBldDragManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGuiBldDragManager.html
Deployability,release,release,"iginated here; It repeadeatly queries pointer state and position on the screen.; From this info an Event_t structure is built. Bool_t HandleTimerEvent(Event_t* ev, TTimer* t); Handle timer events or events coming from the recorder. Bool_t RecognizeGesture(Event_t* , TGFrame* frame = 0); Recognize what was done when mouse button pressed. void HandleButon3Pressed(Event_t* , TGFrame* frame = 0); Handle 3d mouse pressed (popup context menu). Bool_t HandleButton(Event_t* ); Handle button event occured in some ROOT frame. Bool_t HandleConfigureNotify(Event_t* ); Resize events. Bool_t HandleExpose(Event_t* ); Handle repaint event. Bool_t HandleEvent(Event_t* ); Handle all events. Bool_t HandleDoubleClick(Event_t* ); Mouse double click handler (never should happen). TGFrame * GetBtnEnableParent(TGFrame* fr); Return a parent which can handle button evevents. void UnmapAllPopups(); Unmap all popups. Bool_t HandleButtonPress(Event_t* ); Handle button press event. Bool_t HandleButtonRelease(Event_t* ); Handle button release event. Bool_t HandleKey(Event_t* ); Handle key event. void ReparentFrames(TGFrame* newfr, TGCompositeFrame* oldfr); Reparent frames. TList * GetFramesInside(Int_t x0, Int_t y0, Int_t x, Int_t y); Return the list of frames inside of some area. void DropCanvas(TGCanvas* canvas); Drop canvas container. void PutToCanvas(TGCompositeFrame* cont); Create a new TGCanvas and place container into it. void HandleReturn(Bool_t on = kFALSE); Handling of return/enter key pressing. If on is kFALSE:; If Return or Enter key was pressed - Grab Act; If lasso is drawn - new composite frame is created and; all frames inside lasso adopted as childrens.; If lasso is not drawn and selected frame is composite one,; - new TGCanvas widget is created and selcted frmae became; container for this canvas. If on is kTRUE:; If Return or Enter key was pressed with Control Key - Drop Act,; The opposite action to the Grab Act.; If selected/grabbed frame is not a TGCanvas widget -; all frames i",MatchSource.WIKI,root/html602/TGuiBldDragManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGuiBldDragManager.html
Integrability,message,message,"n. void DoReplace(TGFrame* frame); Replace frame (doesn't work yet properly). void HandleReplace(); Handle replace. void CloneEditable(); Create a frame which is the same as currently editted frame. Bool_t Save(const char* file = """"); Save an editted frame to the file. Bool_t SaveFrame(const char* file = 0); Save composite frame as macro. void DoResize(); handle resize. void DoMove(); Handle move. TGFrame * FindMdiFrame(TGFrame* in); Return a pointer to the parent mdi frame. void RaiseMdiFrame(TGFrame* in); Raise guibuilder's mdi frame. void CheckTargetUnderGrab(); Look for the drop target under grabbed/selected frame while moving. Bool_t CheckTargetAtPoint(Int_t x, Int_t y); Helper. Look for the drop target under grabbed/selected frame while moving. Bool_t HandleMotion(Event_t* ); Handle motion event. void PlaceFrame(TGFrame* , TGLayoutHints* ); Put created frame at position of the last mouse click. void DrawLasso(); Draw lasso for allocation new object. Bool_t HandleClientMessage(Event_t* ); Handle client message. Bool_t HandleDestroyNotify(Event_t* ); Handle destroy notify. Bool_t HandleSelection(Event_t* ); not used yet. Bool_t HandleSelectionRequest(Event_t* ); not used yet. TGFrame * GetMovableParent(TGWindow* p); Find parent frame which can be dragged. TGWindow * GetResizableParent(TGWindow* p); Find parent frame which can be resized. Bool_t StartDrag(TGFrame* src, Int_t x, Int_t y); Start dragging. Bool_t EndDrag(); End dragging. Bool_t Cancel(Bool_t delSrc); Do cancel action. Bool_t Drop(); Drop grabbed frame. Bool_t IsMoveWaiting() const; Waits for either the mouse move from the given initial ButtonPress location; or for the mouse button to be released. If mouse moves away from the initial; ButtonPress location before the mouse button is released ""IsMoveWaiting""; returns kTRUE. If the mouse button released before the mose moved from the; initial ButtonPress location, ""IsMoveWaiting"" returns kFALSE. void Compact(Bool_t global = kTRUE); Layout and Resize fra",MatchSource.WIKI,root/html602/TGuiBldDragManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGuiBldDragManager.html
Usability,progress bar,progress bar,building. void ChangeTextColor(TGTextButton* ); Change text color via color selection dialog. This method is activated; via context menu during guibuilding. void ChangePicture(TGPictureButton* ); Invoke file dialog to assign a new picture.; This method is activated via context menu during guibuilding. void ChangeBackgroundColor(TGCanvas* ); Change background color via context menu. void ChangeBackgroundColor(TGComboBox* ); Change background color for list box entries. This method is invoked; via context menu during guibuilding. void ChangeProperties(TGLabel* ); Edit properties via font selection dialog. This method is activated; via context menu during guibuilding. void ChangeTextColor(TGLabel* ); Change text color via color selection dialog. This method is activated; via context menu during guibuilding. void ChangeBackgroundColor(TGListBox* ); Set background color for list box entries. This method is invoked; via context menu during guibuilding. void ChangeBarColor(TGProgressBar* ); Set progress bar color via TGColorDialog.; This method is activated via context menu during guibuilding. void ChangeTextColor(TGProgressBar* ); Change text color which displays position. void ChangeTextColor(TGTextEntry* ); Set text color. This method is invoked; via context menu during guibuilding. void ChangeTextFont(TGTextEntry* ); Change text font via font selection dialog. This method is activated; via context menu during guibuilding. void ChangeImage(TGIcon* ); Invoke file dialog to assign a new image.; This method is activated via context menu during guibuilding. void SetLassoDrawn(Bool_t on); Set lasso drawn flag. Bool_t IsEditDisabled(TGWindow* f) const; { return (f && (f->GetEditDisabled() & kEditDisable)); }. Bool_t IsGrabDisabled(TGWindow* f) const; { return (f && (f->GetEditDisabled() & kEditDisableGrab)); }. Bool_t IsEventsDisabled(TGWindow* f) const; { return (f && (f->GetEditDisabled() & kEditDisableEvents)); }. Bool_t IsFixedLayout(TGWindow* f) const; { return (f && (f-,MatchSource.WIKI,root/html602/TGuiBldDragManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGuiBldDragManager.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGuiBldEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGuiBldEditor.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGuiBldGeometryFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGuiBldGeometryFrame.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*T",MatchSource.WIKI,root/html602/TGuiBldHintsButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGuiBldHintsButton.html
Deployability,release,released,Frame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled.,MatchSource.WIKI,root/html602/TGuiBldHintsButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGuiBldHintsButton.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGuiBldHintsEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGuiBldHintsEditor.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; TGListTreeItem*FindItemByName(TGListTree* tree, const char* name, TGListTreeItem* item = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCom",MatchSource.WIKI,root/html602/TGuiBldNameFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGuiBldNameFrame.html
Testability,test,tested,"Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGuiBuilder. class TGuiBuilder. TGuiBuilder. ROOT GUI Builder principles. With the GUI builder, we try to make the next step from WYSIWYG; to embedded editing concept - WYSIWYE (""what you see is what you edit"").; The ROOT GUI Builder allows modifying real GUI objects.; For example, one can edit the existing GUI application created by; $ROOTSYS/tutorials/gui/guitest.C.; GUI components can be added to a design area from a widget palette,; or can be borrowed from another application.; One can drag and and drop TCanvas's menu bar into the application.; GUI objects can be resized and dragged, copied and pasted.; ROOT GUI Builder allows changing the layout, snap to grid, change object's; layout order via the GUI Builder toolbar, or by options in the right-click; context menus.; A final design can be immediatly tested and used, or saved as a C++ macro.; For example, it's possible to rearrange buttons in control bar,; add separators etc. and continue to use a new fancy control bar in the; application. The following is a short description of the GUI Builder actions and key shortcuts:. o Press Ctrl-Double-Click to start/stop edit mode; o Press Double-Click to activate quick edit action (defined in root.mimes). Selection, grabbing, dropping. It is possible to select, drag any frame and drop it to any frame. o Click left mouse button or Ctrl-Click to select an object to edit.; o Press right mouse button to activate context menu; o Multiple selection (grabbing):; - draw lasso and press Return key; - press Shift key and draw lasso; o Dropping:; - select frame and press Ctrl-Return key; o Changing layout order:; - select frame and use arrow keys to change layout order; o Alignment:; - draw lasso and press arrow keys (or Shift-Arrow key) to align frames. Key shortcuts. o Return - grab selected frames; o ",MatchSource.WIKI,root/html602/TGuiBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGuiBuilder.html
Availability,error,error,"ar* title, UInt_t width, UInt_t height); virtual TCanvasImp*CreateCanvasImp(TCanvas* c, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height); virtual TContextMenuImp*CreateContextMenuImp(TContextMenu* c, const char* name, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title, Int_t x, Int_t y); virtual TInspectorImp*CreateInspectorImp(const TObject* obj, UInt_t width, UInt_t height); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root/html602/TGuiFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGuiFactory.html
Integrability,depend,dependent,". TGuiFactory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGuiFactory. class TGuiFactory: public TNamed. TGuiFactory. This ABC is a factory for GUI components. Depending on which; factory is active one gets either ROOT native (X11 based with Win95; look and feel), Win32 or Mac components.; In case there is no platform dependent implementation on can run in; batch mode directly using an instance of this base class. Function Members (Methods); public:. virtual~TGuiFactory(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual TApplicationImp*CreateApplicationImp(const char* classname, int* argc, char** argv); virtual TBrowserImp*CreateBrowserImp(TBrowser* b, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); virtual TBrowserImp*CreateBrowserImp(TBrowser* b, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"); virtual TCanvasImp*CreateCanvasImp(TCanvas* c, const char* title, UInt_t width, UInt_t height); virtual TCanvasImp*CreateCanvasImp(TCanvas* c, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height); virtual TContextMenuImp*CreateContextMenuImp(TContextMenu* c, const char* name, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title, Int_t x, Int_t y); virtual TInspectorImp*CreateInspectorImp(const TObject* obj, ",MatchSource.WIKI,root/html602/TGuiFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGuiFactory.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFixSize(); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDe",MatchSource.WIKI,root/html602/TGUndockedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGUndockedFrame.html
Usability,undo,undocked,". TGUndockedFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGUndockedFrame. class TGUndockedFrame: public TGTransientFrame. A TGDockableFrame is a frame with handles that allow it to be; undocked (i.e. put in a transient frame of its own) and to be docked; again or hidden and shown again. It uses the TGDockButton, which is; a button with two vertical bars (||) and TGDockHideButton, which is; a button with a small triangle. The TGUndockedFrame is a transient; frame that on closure will put the frame back in the dock. Function Members (Methods); public:. virtual~TGUndockedFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list",MatchSource.WIKI,root/html602/TGUndockedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGUndockedFrame.html
Availability,avail,available,". TGUnknownWindowHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGUnknownWindowHandler. class TGUnknownWindowHandler: public TObject. TGWindow. ROOT GUI Window base class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGUnknownWindowHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject:",MatchSource.WIKI,root/html602/TGUnknownWindowHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGUnknownWindowHandler.html
Availability,down,down," ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widget organizes TGButton widgets in a group; with one horizontal row. TGHButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. The TGVButtonGroup widget organizes TGButton widgets in a group; with one vertical column. TGVButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. Function Members (Methods); public:. virtual~TGVButtonGroup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInp",MatchSource.WIKI,root/html602/TGVButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGVButtonGroup.html
Deployability,toggle,toggle,". TGVButtonGroup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGVButtonGroup. class TGVButtonGroup: public TGButtonGroup. The TGButtonGroup widget organizes TGButton widgets in a group. A button group widget makes it easier to deal with groups of buttons.; A button in a button group is associated with a unique identifier.; The button group emits a Clicked() signal with this identifier when; the button is clicked. Thus, a button group is an ideal solution; when you have several similar buttons and want to connect all their; Clicked() signals, for example, to one slot. An exclusive button group switches off all toggle buttons except; the one that was clicked. A button group is by default non-exclusive.; All radio buttons that are inserted, will be mutually exclusive even; if the button group is non-exclusive. There are two ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> ",MatchSource.WIKI,root/html602/TGVButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGVButtonGroup.html
Modifiability,inherit,inherits,"roup. A button group widget makes it easier to deal with groups of buttons.; A button in a button group is associated with a unique identifier.; The button group emits a Clicked() signal with this identifier when; the button is clicked. Thus, a button group is an ideal solution; when you have several similar buttons and want to connect all their; Clicked() signals, for example, to one slot. An exclusive button group switches off all toggle buttons except; the one that was clicked. A button group is by default non-exclusive.; All radio buttons that are inserted, will be mutually exclusive even; if the button group is non-exclusive. There are two ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widg",MatchSource.WIKI,root/html602/TGVButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGVButtonGroup.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option",MatchSource.WIKI,root/html602/TGVertical3DLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGVertical3DLine.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGVerticalFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGVerticalFrame.html
Testability,log,logically,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. virtual~TGVerticalFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); v",MatchSource.WIKI,root/html602/TGVerticalFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGVerticalFrame.html
Usability,simpl,simple,". TGVerticalFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGVerticalFrame. class TGVerticalFrame: public TGCompositeFrame. TGFrame, TGCompositeFrame, TGVerticalFrame, TGHorizontalFrame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. virtual~TGVerticalFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBack",MatchSource.WIKI,root/html602/TGVerticalFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGVerticalFrame.html
Availability,down,downward,". TGVerticalLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGVerticalLayout. class TGVerticalLayout: public TGLayoutManager. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. virtual~TGVerticalLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtu",MatchSource.WIKI,root/html602/TGVerticalLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGVerticalLayout.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option",MatchSource.WIKI,root/html602/TGVFileSplitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGVFileSplitter.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGViewFrame*GetCanvas() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; vi",MatchSource.WIKI,root/html602/TGView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGView.html
Deployability,update,update,"Init; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGView(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, Int_t id = -1, UInt_t xMargin = 0, UInt_t yMargin = 0, UInt_t options = kSunkenFrame | kDoubleBorder, UInt_t sboptions = 0, Pixel_t back = GetWhitePixel()); Create an editor view, containing an TGEditorFrame and (optionally); a horizontal and vertical scrollbar. ~TGView(); Delete view. void Clear(Option_t* = """"); Clear view. void SetVisibleStart(Int_t newTop, Int_t direction); Scroll view in specified direction to make newTop the visible location. void DrawRegion(Int_t x, Int_t y, UInt_t width, UInt_t height); Draw region. void UpdateRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); update a part of view. void UpdateBackgroundStart(); set some gc values. Bool_t HandleButton(Event_t* event); handle button. void DoRedraw(); redraw. Bool_t HandleExpose(Event_t* event); Handle expose events. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process scrollbar messages. void Layout(); layout view. void DrawBorder(); Draw the border of the text edit widget. void ScrollToPosition(TGLongPosition newPos); Scroll the canvas to pos. void ScrollCanvas(Int_t newTop, Int_t direction); Scroll the canvas to new_top in the kVertical or kHorizontal direction. void ChangeBackground(Pixel_t ); Change background color of the canvas frame. void SetBackgroundColor(Pixel_t ); Set background color of the canvas frame. void SetBackgroundPixmap(Pixmap_t p); Set backgound pixmap. Bool_t ItemLayout(); { return kFALSE; }. TGView(const TGView& ). TGView& operator=(const TGView& ). TGViewFrame * GetCanvas() const; { return fCanvas; }. void SetLayoutManager(TGLayoutM",MatchSource.WIKI,root/html602/TGView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGView.html
Integrability,message,messages,". TGView. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGView. class TGView: public TGCompositeFrame, public TGWidget. TGView. A TGView provides the infrastructure for text viewer and editor; widgets. It provides a canvas (TGViewFrame) and (optionally) a; vertical and horizontal scrollbar and methods for marking and; scrolling. The TGView (and derivatives) will generate the following; event messages:; kC_TEXTVIEW, kTXT_ISMARKED, widget id, [true|false]; kC_TEXTVIEW, kTXT_DATACHANGE, widget id, 0; kC_TEXTVIEW, kTXT_CLICK2, widget id, position (y << 16) | x); kC_TEXTVIEW, kTXT_CLICK3, widget id, position (y << 16) | x); kC_TEXTVIEW, kTXT_F3, widget id, true; kC_TEXTVIEW, kTXT_OPEN, widget id, 0; kC_TEXTVIEW, kTXT_CLOSE, widget id, 0; kC_TEXTVIEW, kTXT_SAVE, widget id, 0. Function Members (Methods); public:. virtual~TGView(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidChangeBackground(Pixel_t); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQO",MatchSource.WIKI,root/html602/TGView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGView.html
Security,expose,expose,"Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGView(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, Int_t id = -1, UInt_t xMargin = 0, UInt_t yMargin = 0, UInt_t options = kSunkenFrame | kDoubleBorder, UInt_t sboptions = 0, Pixel_t back = GetWhitePixel()); Create an editor view, containing an TGEditorFrame and (optionally); a horizontal and vertical scrollbar. ~TGView(); Delete view. void Clear(Option_t* = """"); Clear view. void SetVisibleStart(Int_t newTop, Int_t direction); Scroll view in specified direction to make newTop the visible location. void DrawRegion(Int_t x, Int_t y, UInt_t width, UInt_t height); Draw region. void UpdateRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); update a part of view. void UpdateBackgroundStart(); set some gc values. Bool_t HandleButton(Event_t* event); handle button. void DoRedraw(); redraw. Bool_t HandleExpose(Event_t* event); Handle expose events. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process scrollbar messages. void Layout(); layout view. void DrawBorder(); Draw the border of the text edit widget. void ScrollToPosition(TGLongPosition newPos); Scroll the canvas to pos. void ScrollCanvas(Int_t newTop, Int_t direction); Scroll the canvas to new_top in the kVertical or kHorizontal direction. void ChangeBackground(Pixel_t ); Change background color of the canvas frame. void SetBackgroundColor(Pixel_t ); Set background color of the canvas frame. void SetBackgroundPixmap(Pixmap_t p); Set backgound pixmap. Bool_t ItemLayout(); { return kFALSE; }. TGView(const TGView& ). TGView& operator=(const TGView& ). TGViewFrame * GetCanvas() const; { return fCanvas; }. void SetLayoutManager(TGLayoutManager* ); { }. void ScrollUp(Int_t pixels); { ScrollToPosition(TGLongPosition(fVisible.fX, fVisible.fY + pixels)); }. void ScrollDown(Int_t pixels); { ScrollToPosition(TGLongPosition(fVisible.fX, ",MatchSource.WIKI,root/html602/TGView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGView.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html602/TGViewFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGViewFrame.html
Integrability,message,messages,". TGViewFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGViewFrame. class TGViewFrame: public TGCompositeFrame. TGView. A TGView provides the infrastructure for text viewer and editor; widgets. It provides a canvas (TGViewFrame) and (optionally) a; vertical and horizontal scrollbar and methods for marking and; scrolling. The TGView (and derivatives) will generate the following; event messages:; kC_TEXTVIEW, kTXT_ISMARKED, widget id, [true|false]; kC_TEXTVIEW, kTXT_DATACHANGE, widget id, 0; kC_TEXTVIEW, kTXT_CLICK2, widget id, position (y << 16) | x); kC_TEXTVIEW, kTXT_CLICK3, widget id, position (y << 16) | x); kC_TEXTVIEW, kTXT_F3, widget id, true; kC_TEXTVIEW, kTXT_OPEN, widget id, 0; kC_TEXTVIEW, kTXT_CLOSE, widget id, 0; kC_TEXTVIEW, kTXT_SAVE, widget id, 0. Function Members (Methods); public:. virtual~TGViewFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalL",MatchSource.WIKI,root/html602/TGViewFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGViewFrame.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; TGFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWi",MatchSource.WIKI,root/html602/TGViewPort.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGViewPort.html
Integrability,depend,depends,"mitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGViewPort(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Create a viewport object. void SetContainer(TGFrame* f); Add container frame to the viewport. We must make sure that the added; container is at least a TGCompositeFrame (TGCanvas::AddFrame depends; on it). void SetHPos(Int_t xpos); Moves content of container frame in horizontal direction. void SetVPos(Int_t ypos); Moves content of container frame in vertical direction. void SetPos(Int_t xpos, Int_t ypos); Goto new position. Bool_t HandleConfigureNotify(Event_t* event); Handle resize events. TGContainer& operator=(const TGViewPort& ). void Layout(). TGViewPort(const TGViewPort& ). TGFrame * GetContainer() const; { return fContainer; }. void DrawBorder(); { }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fHeight); }. Int_t GetHPos() const; { return fX0; }. Int_t GetVPos() const; { return fY0; }. » Author: Fons Rademakers 11/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGViewPort.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGViewPort.html
Availability,error,error,"signal, void* receiver = 0, const char* slot = 0); virtual voidTQObject::Disconnected(const char*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTGFrame::DrawBorder(); virtual voidTGFrame::DrawClass() const; virtual TObject*TGFrame::DrawClone(Option_t* = """") const; virtual voidTGFrame::DrawCopy(Handle_t, Int_t, Int_t); virtual voidTGFrame::Dump() const; voidTQObject::Emit(const char* signal); voidTQObject::Emit(const char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTGProgressBar::Format(const char* format = ""%.",MatchSource.WIKI,root/html602/TGVProgressBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGVProgressBar.html
Usability,progress bar,progress bars,". TGVProgressBar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGVProgressBar. class TGVProgressBar: public TGProgressBar. TGProgressBar, TGHProgressBar and TGVProgressBar. The classes in this file implement progress bars. Progress bars can; be used to show progress of tasks taking more then a few seconds.; TGProgressBar is an abstract base class, use either TGHProgressBar; or TGVProgressBar. TGHProgressBar can in addition show the position; as text in the bar. Function Members (Methods); public:. virtual~TGVProgressBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(cons",MatchSource.WIKI,root/html602/TGVProgressBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGVProgressBar.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static Pixmap_tTGScrollBar::GetBckgndPixmap(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame",MatchSource.WIKI,root/html602/TGVScrollBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGVScrollBar.html
Integrability,message,messages,". TGVScrollBar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGVScrollBar. class TGVScrollBar: public TGScrollBar. TGScrollBar and TGScrollBarElement. The classes in this file implement scrollbars. Scrollbars can be; either placed horizontal or vertical. A scrollbar contains three; TGScrollBarElements: The ""head"", ""tail"" and ""slider"". The head and; tail are fixed at either end and have the typical arrows in them. The TGHScrollBar will generate the following event messages:; kC_HSCROLL, kSB_SLIDERPOS, position, 0; kC_HSCROLL, kSB_SLIDERTRACK, position, 0. The TGVScrollBar will generate the following event messages:; kC_VSCROLL, kSB_SLIDERPOS, position, 0; kC_VSCROLL, kSB_SLIDERTRACK, position, 0. Function Members (Methods); public:. virtual~TGVScrollBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGScrollBar::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQ",MatchSource.WIKI,root/html602/TGVScrollBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGVScrollBar.html
Testability,log,logical,"of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Int_tTGScrollBar::fgScrollBarWidth; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGVScrollBar(const TGWindow* p = 0, UInt_t w = 2, UInt_t h = 4, UInt_t options = kVerticalFrame, Pixel_t back = GetDefaultFrameBackground()); Create a vertical scrollbar. void Layout(); Layout and move vertical scrollbar components. Bool_t HandleButton(Event_t* event); Handle mouse button event in vertical scrollbar. Bool_t HandleMotion(Event_t* event); Handle mouse motion in a vertical scrollbar. void SetRange(Int_t range, Int_t page_size); Set range of vertical scrollbar. void SetPosition(Int_t pos); Set logical slider position of vertical scrollbar. void SavePrimitive(ostream& out, Option_t* option = """"); Save an vertical scrollbar as a C++ statement(s) on output stream out. TGScrollBarElement& operator=(const TGVScrollBar& ). TGDimension GetDefaultSize() const; { return TGDimension(fWidth, GetScrollBarWidth()); }. TGVScrollBar(const TGWindow* p = 0, UInt_t w = 2, UInt_t h = 4, UInt_t options = kVerticalFrame, Pixel_t back = GetDefaultFrameBackground()); { }. » Author: Fons Rademakers 10/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TGVScrollBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGVScrollBar.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::Get",MatchSource.WIKI,root/html602/TGVSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGVSlider.html
Availability,error,error," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option",MatchSource.WIKI,root/html602/TGVSplitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGVSplitter.html
Modifiability,inherit,inheritance,". TGWidget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGWidget. class TGWidget. TGWidget. The widget base class. It is light weight (all inline service; methods) and is typically used as mixin class (via multiple; inheritance), see for example TGButton. Function Members (Methods); public:. virtual~TGWidget(); virtual voidAssociate(const TGWindow* w); static TClass*Class(); const char*GetCommand() const; Bool_tHasFocus() const; virtual TClass*IsA() const; Bool_tIsEnabled() const; virtual voidSetCommand(const char* command); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGWidget(); TGWidget(Int_t id); Bool_tWantFocus() const; Int_tWidgetId() const. protected:. Int_tClearFlags(Int_t flags); TGWidget&operator=(const TGWidget& tgw); Int_tSetFlags(Int_t flags); TGWidget(const TGWidget& tgw). Data Members; protected:. TStringfCommandcommand to be executed; const TGWindow*fMsgWindowwindow which handles widget events; Int_tfWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tfWidgetIdthe widget id (used for event processing). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGWidget(const TGWidget& tgw); { }. TGWidget& operator=(const TGWidget& tgw). Int_t SetFlags(Int_t flags); { return fWidgetFlags |= flags; }. Int_t ClearFlags(Int_t flags); { return fWidgetFlags &= ~flags; }. TGWidget(); { }. TGWidget(Int_t id); { }. virtual ~TGWidget(); { }. Int_t WidgetId() const; { return fWidgetId; }. Bool_t IsEnabled() const; { return (Bool_t)((fWidgetFlags & kWidgetIsEnabled) != 0); }. Bool_t HasFocus() const; { return (Bool_t)((fWidgetFlags & kWidgetHasFocus) != 0); }. Bool_t WantFocus() const; { return (Bool_t)((fWidgetFlags & kWidgetWantFocus) != 0);",MatchSource.WIKI,root/html602/TGWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGWidget.html
Availability,error,error," virtual~TGWindow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDestroySubwindows(); virtual voidDestroyWindow(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGClient*TGObject::GetClient() const; static Int_tGetCounter(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual UInt_tGetEditDisabled() const; virtual const char*TObject::GetIconName() const; Handle_tTGObject::GetId() const; virtual const T",MatchSource.WIKI,root/html602/TGWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGWindow.html
Availability,mask,mask,"ributes(Window_t id, SetWindowAttributes_t* attr); virtual Bool_tCheckEvent(Window_t id, EGEventType type, Event_t& ev); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearArea(Window_t id, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidClearWindow(); virtual voidClearWindow(Window_t id); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidCloseDisplay(); virtual voidClosePixmap(); virtual voidCloseWindow(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConvertPrimarySelection(Window_t id, Atom_t clipboard, Time_t when); virtual voidConvertSelection(Window_t, Atom_t&, Atom_t&, Atom_t&, Time_t&); virtual voidTNamed::Copy(TObject& named) const; virtual voidCopyArea(Drawable_t src, Drawable_t dest, GContext_t gc, Int_t src_x, Int_t src_y, UInt_t width, UInt_t height, Int_t dest_x, Int_t dest_y); virtual voidCopyGC(GContext_t org, GContext_t dest, Mask_t mask); virtual voidCopyPixmap(Int_t wid, Int_t xpos, Int_t ypos); virtual Pixmap_tCreateBitmap(Drawable_t id, const char* bitmap, UInt_t width, UInt_t height); virtual Cursor_tCreateCursor(ECursor cursor); virtual GContext_tCreateGC(Drawable_t id, GCValues_t* gval); virtual Drawable_tCreateImage(UInt_t width, UInt_t height); virtual voidTVirtualX::CreateOpenGLContext(Int_t wid = 0); virtual Handle_tTVirtualX::CreateOpenGLContext(Window_t windowID, Handle_t sharedContext); virtual Window_tTVirtualX::CreateOpenGLWindow(Window_t parentID, UInt_t width, UInt_t height, const vector<pair<UInt_t,Int_t> >& format); virtual Bool_tCreatePictureFromData(Drawable_t id, char** data, Pixmap_t& pict, Pixmap_t& pict_mask, PictureAttributes_t& attr); virtual Bool_tCreatePictureFromFile(Drawable_t id, const char* filename, Pixmap_t& pict, Pixmap_t& pict_mask, PictureAttributes_t& attr); virtual Pixmap_tCreatePixmap(Drawable_t id, UInt_t w, UInt_t h); virtual Pixmap_tCreatePixmap(Drawable_t id, const char* ",MatchSource.WIKI,root/html602/TGX11.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGX11.html
Deployability,release,released,"rn window number.; Return -1 if window initialization fails. Int_t AddWindow(ULong_t qwid, UInt_t w, UInt_t h); Register a window created by Qt as a ROOT window (like InitWindow()). void RemoveWindow(ULong_t qwid); Remove a window created by Qt (like CloseWindow1()). void QueryPointer(Int_t& ix, Int_t& iy); Query pointer position.; ix : X coordinate of pointer; iy : Y coordinate of pointer; (both coordinates are relative to the origin of the root window). void RemovePixmap(Drawable* pix); Remove the pixmap pix. Int_t RequestLocator(Int_t mode, Int_t ctyp, Int_t& x, Int_t& y); Request Locator position.; x,y : cursor position at moment of button press (output); ctyp : cursor type (input); ctyp=1 tracking cross; ctyp=2 cross-hair; ctyp=3 rubber circle; ctyp=4 rubber band; ctyp=5 rubber rectangle. mode : input mode; mode=0 request; mode=1 sample. Request locator:; return button number 1 = left is pressed; 2 = middle is pressed; 3 = right is pressed; in sample mode:; 11 = left is released; 12 = middle is released; 13 = right is released; -1 = nothing is pressed or released; -2 = leave the window; else = keycode (keyboard is pressed). Int_t RequestString(Int_t x, Int_t y, char* text); Request a string.; x,y : position where text is displayed; text : text displayed (input), edited text (output). Request string:; text is displayed and can be edited with Emacs-like keybinding; return termination code (0 for ESC, 1 for RETURN). void RescaleWindow(Int_t wid, UInt_t w, UInt_t h); Rescale the window wid.; wid : Window identifier; w : Width; h : Heigth. int ResizePixmap(Int_t wid, UInt_t w, UInt_t h); Resize a pixmap.; wid : pixmap to be resized; w,h : Width and height of the pixmap. void ResizeWindow(Int_t wid); Resize the current window if necessary. void SelectWindow(Int_t wid); Select window to which subsequent output is directed. void SetCharacterUp(Float_t chupx, Float_t chupy); Set character up vector. void SetClipOFF(Int_t wid); Turn off the clipping for the window wid. v",MatchSource.WIKI,root/html602/TGX11.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGX11.html
Energy Efficiency,green,green,"ject::(anonymous)TObject::kWriteDelete; static TVirtualX::EDrawModeTVirtualX::kXor; static TObject::(anonymous)TObject::kZombie. protected:. ULong_tfBlackPixelValue of black pixel in colormap; Int_tfBlueDivBlue value divider; Int_tfBlueShiftBits to left shift blue; Float_tfCharacterUpXCharacter Up vector along X; Float_tfCharacterUpYCharacter Up vector along Y; ColormapfColormapDefault colormap, 0 if b/w; Int_tfDepthNumber of color planes; void*fDisplayPointer to display; TVirtualX::EDrawModeTVirtualX::fDrawModeDrawing mode; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Int_tfGreenDivGreen value divider; Int_tfGreenShiftBits to left shift green; Bool_tfHasTTFontsTrue when TrueType fonts are used; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; TStringTNamed::fNameobject identifier; Int_tfRedDivRed value divider, -1 if no TrueColor visual; Int_tfRedShiftBits to left shift red, -1 if no TrueColor visual; DrawablefRootWinRoot window used as parent of all windows; Int_tfScreenNumberScreen number; Int_tfTextAlignText alignment (set in SetTextAlign); Short_tTAttText::fTextAlignText alignment; Int_tfTextAlignHText Alignment Horizontal; Int_tfTextAlignVText Alignment Vertical; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tfTextMagnitudeText Magnitude; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; DrawablefVisRootWinRoot window with fVisual to be used to create GC's and XImages; RVisual*fVisualPointer to visual used by all windows; ULong_tfWhitePixelValue of white pixel in colormap. private:. TExMap*fColorsHash list of colors; CursorfCursors[19]List of cursors; Int_tfMaxNumberOfWindowsMaximum number of windows; XWindow_",MatchSource.WIKI,root/html602/TGX11.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGX11.html
Integrability,interface,interface,". TGX11. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » X11; » TGX11. class TGX11: public TVirtualX. TGX11. This class is the basic interface to the X11 graphics system. It is; an implementation of the abstract TVirtualX class. The companion; class for Win32 is TGWin32. This code was initially developed in the context of HIGZ and PAW; by Olivier Couet (package X11INT). Function Members (Methods); public:. virtual~TGX11(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddPixmap(ULong_t pixid, UInt_t w, UInt_t h); virtual Int_tAddWindow(ULong_t qwid, UInt_t w, UInt_t h); virtual Bool_tAllocColor(Colormap_t cmap, ColorStruct_t& color); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualX::BeginModalSessionFor(Window_t window); virtual voidBell(Int_t percent); virtual voidTObject::Browse(TBrowser* b); virtual voidChangeActivePointerGrab(Window_t, UInt_t, Cursor_t); virtual voidChangeGC(GContext_t gc, GCValues_t* gval); virtual voidChangeProperties(Window_t id, Atom_t property, Atom_t type, Int_t format, UChar_t* data, Int_t len); virtual voidChangeProperty(Window_t id, Atom_t property, Atom_t type, UChar_t* data, Int_t len); virtual voidChangeWindowAttributes(Window_t id, SetWindowAttributes_t* attr); virtual Bool_tCheckEvent(Window_t id, EGEventType type, Event_t& ev); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearArea(Window_t id, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidClearWindow(); virtual voidClearWindow(Window_t id); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidCloseDisplay(); virtual voidClosePixmap(); virtual voidCloseWindow(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConvertPrimarySele",MatchSource.WIKI,root/html602/TGX11.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TGX11.html
