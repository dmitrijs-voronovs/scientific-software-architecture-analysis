id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html:13788,Modifiability,variab,variable,13788,"e names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamMultiTarget(); Default constructor for streamer, user should not use it. PDEFoamMultiTarget(const TString& , TMVA::ETargetSelection ); User constructor. Parameters:. - name - name of PDEFoam object. - ts - target selection method used in; GetCellValue(const std::map<Int_t, Float_t>& xvec, ECellValue); Cadidates are: TMVA::kMean, TMVA::kMpv. - TMVA::kMean - The function GetCellValue() finds all cells; which contain a given event vector 'xvec' and returns the; mean target (for every target variable in the foam). - TMVA::kMpv - The function GetCellValue() finds all cells; which contain a given event vector 'xvec' and returns the; most probable target (for every target variable in the; foam), that is the target value which corresponds to the; cell with the largest event density. PDEFoamMultiTarget(const TMVA::PDEFoamMultiTarget& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). std::vector<Float_t> GetCellValue(const map<Int_t,Float_t>& , TMVA::ECellValue ); This function is overridden from PDFEFoam. It returns all; regression targets (in order), given an untransformed event; vector 'xvec'. The key of 'xvec' is the dimension and the value; (Float_t) is the coordinate. Note: number of foam dimensions = number of variables + number; of targets. Parameters:; - xvec - map of event variables (no targets!); - cv - cell value to return (ignored!). Return:; Targets, ordered by missing dimensions in 'xvec'.; The size of the returned vector = foam dimension - size of xvec. void CalculateMpv(map<Int_t,Float_t>& , const vector<TMVA::PDEFoamCell*>& ); This function calculates the most probable target value from a; given number of cells. Th",MatchSource.WIKI,root/html604/TMVA__PDEFoamMultiTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html
https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html:14341,Modifiability,variab,variables,14341,"on method used in; GetCellValue(const std::map<Int_t, Float_t>& xvec, ECellValue); Cadidates are: TMVA::kMean, TMVA::kMpv. - TMVA::kMean - The function GetCellValue() finds all cells; which contain a given event vector 'xvec' and returns the; mean target (for every target variable in the foam). - TMVA::kMpv - The function GetCellValue() finds all cells; which contain a given event vector 'xvec' and returns the; most probable target (for every target variable in the; foam), that is the target value which corresponds to the; cell with the largest event density. PDEFoamMultiTarget(const TMVA::PDEFoamMultiTarget& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). std::vector<Float_t> GetCellValue(const map<Int_t,Float_t>& , TMVA::ECellValue ); This function is overridden from PDFEFoam. It returns all; regression targets (in order), given an untransformed event; vector 'xvec'. The key of 'xvec' is the dimension and the value; (Float_t) is the coordinate. Note: number of foam dimensions = number of variables + number; of targets. Parameters:; - xvec - map of event variables (no targets!); - cv - cell value to return (ignored!). Return:; Targets, ordered by missing dimensions in 'xvec'.; The size of the returned vector = foam dimension - size of xvec. void CalculateMpv(map<Int_t,Float_t>& , const vector<TMVA::PDEFoamCell*>& ); This function calculates the most probable target value from a; given number of cells. The most probable target is defined to; be the coordinates of the cell which has the biggest event; density. Parameters:. - target - map of targets, where the key is the dimension and; the value is the target value. It is assumed that this map is; initialized such that there is a map entry for every target. - cells - vector of PDEFoam cells to pick the most probable; target from. void CalculateMean(map<Int_t,Float_t>& , const vector<TMVA::PDEFoamCell*>& ); This function calculates the mean target value from a given; number of cells. As weight the event density of th",MatchSource.WIKI,root/html604/TMVA__PDEFoamMultiTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html
https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html:14408,Modifiability,variab,variables,14408,"ates are: TMVA::kMean, TMVA::kMpv. - TMVA::kMean - The function GetCellValue() finds all cells; which contain a given event vector 'xvec' and returns the; mean target (for every target variable in the foam). - TMVA::kMpv - The function GetCellValue() finds all cells; which contain a given event vector 'xvec' and returns the; most probable target (for every target variable in the; foam), that is the target value which corresponds to the; cell with the largest event density. PDEFoamMultiTarget(const TMVA::PDEFoamMultiTarget& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). std::vector<Float_t> GetCellValue(const map<Int_t,Float_t>& , TMVA::ECellValue ); This function is overridden from PDFEFoam. It returns all; regression targets (in order), given an untransformed event; vector 'xvec'. The key of 'xvec' is the dimension and the value; (Float_t) is the coordinate. Note: number of foam dimensions = number of variables + number; of targets. Parameters:; - xvec - map of event variables (no targets!); - cv - cell value to return (ignored!). Return:; Targets, ordered by missing dimensions in 'xvec'.; The size of the returned vector = foam dimension - size of xvec. void CalculateMpv(map<Int_t,Float_t>& , const vector<TMVA::PDEFoamCell*>& ); This function calculates the most probable target value from a; given number of cells. The most probable target is defined to; be the coordinates of the cell which has the biggest event; density. Parameters:. - target - map of targets, where the key is the dimension and; the value is the target value. It is assumed that this map is; initialized such that there is a map entry for every target. - cells - vector of PDEFoam cells to pick the most probable; target from. void CalculateMean(map<Int_t,Float_t>& , const vector<TMVA::PDEFoamCell*>& ); This function calculates the mean target value from a given; number of cells. As weight the event density of the cell is; used. Parameters:. - target - map of targets, where the key is the dimension ",MatchSource.WIKI,root/html604/TMVA__PDEFoamMultiTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html
https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html:10961,Testability,log,logic,10961,"; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell;",MatchSource.WIKI,root/html604/TMVA__PDEFoamMultiTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html
https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html:11639,Testability,log,logger,11639,"Object::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 m",MatchSource.WIKI,root/html604/TMVA__PDEFoamMultiTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamMultiTarget.html
https://root.cern/root/html604/TMVA__PDEFoamTarget.html:458,Availability,error,error,458,". TMVA::PDEFoamTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::PDEFoamTarget. class TMVA::PDEFoamTarget: public TMVA::PDEFoam. PDEFoamTarget. This PDEFoam variant stores in every cell the average target; fTarget (see the Constructor) as well as the statistical error on; the target fTarget. It therefore acts as a target estimator. It; should be booked together with the PDEFoamTargetDensity density; estimator, which returns the target fTarget density at a given; phase space point during the foam build-up. Function Members (Methods); public:. virtual~PDEFoamTarget(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int",MatchSource.WIKI,root/html604/TMVA__PDEFoamTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamTarget.html
https://root.cern/root/html604/TMVA__PDEFoamTarget.html:2005,Availability,error,error,2005,"TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTMVA::PDEFoam::FillBinarySearchTree(const TMVA::Event* ev); virtual voidFillFoamCells(const TMVA::Event* ev, Float_t wt); virtual voidFinalize(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetCellValue(const vector<Float_t>& xvec, TMVA::ECellValue cv, TMVA::PDEFoamKernelBase*); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringTMVA::PDEFoam::GetFoamName() const; virtual const char*TObject::GetIconName() const; UInt_tTMVA::PDEFoam::GetMaxDepth() const; UInt_tTMVA::PDEFoam::GetNActiveCells() const; virtual const char*TObject::GetName() const; UInt_tTMVA::PDEFoam::GetNCells() const; UInt_tTMVA::PDEFoam::GetNInActiveCe",MatchSource.WIKI,root/html604/TMVA__PDEFoamTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamTarget.html
https://root.cern/root/html604/TMVA__PDEFoamTarget.html:2089,Availability,error,error,2089,"st char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTMVA::PDEFoam::FillBinarySearchTree(const TMVA::Event* ev); virtual voidFillFoamCells(const TMVA::Event* ev, Float_t wt); virtual voidFinalize(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetCellValue(const vector<Float_t>& xvec, TMVA::ECellValue cv, TMVA::PDEFoamKernelBase*); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringTMVA::PDEFoam::GetFoamName() const; virtual const char*TObject::GetIconName() const; UInt_tTMVA::PDEFoam::GetMaxDepth() const; UInt_tTMVA::PDEFoam::GetNActiveCells() const; virtual const char*TObject::GetName() const; UInt_tTMVA::PDEFoam::GetNCells() const; UInt_tTMVA::PDEFoam::GetNInActiveCells() const; UInt_tTMVA::PDEFoam::GetNmin(); virtual char*TObject::GetObjectInfo(Int",MatchSource.WIKI,root/html604/TMVA__PDEFoamTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamTarget.html
https://root.cern/root/html604/TMVA__PDEFoamTarget.html:12946,Availability,error,error,12946,"CKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamTarget(); Default constructor for streamer, user should not use it. PDEFoamTarget(const TString& , UInt_t ); User constructor. Parameters:. - name - name of PDEFoam object. - target - target number to range-search for. PDEFoamTarget(const TMVA::PDEFoamTarget& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void FillFoamCells(const TMVA::Event* ev, Float_t wt); This function fills an event into the discriminant PDEFoam. The; weight 'wt' is filled into cell element 0 if the event is of; class 'fTarget', and filled into cell element 1 otherwise. void Finalize(); Calculate average cell target in every cell and save them to the; cell. Cell element 0 will contain the average target and cell; element 1 will contain the error on the target. Bool_t CellValueIsUndefined(TMVA::PDEFoamCell* cell); Returns true, if the target error equals -1, as set in; Finalize() in case of no events in the cell. Float_t GetCellValue(const vector<Float_t>& xvec, TMVA::ECellValue cv, TMVA::PDEFoamKernelBase* ); This function finds the cell, which corresponds to the given; untransformed event vector 'xvec' and return its value, which is; given by the parameter 'cv'. If cv == kValue, it is checked wether the cell value is; undefined. If this is the case, then the mean of the neighbor's; target values is returned, using GetAverageNeighborsValue(). Float_t GetAverageNeighborsValue(vector<Float_t>& , TMVA::ECellValue ); This function returns the average value 'cv' of only nearest; neighbor cells. It is used in cases, where empty cells shall; not be evaluated. Parameters:; - txvec - event vector, transformed into foam coordinates [0, 1]; - cv - cell value, see definition of ECellValue. virtual ~PD",MatchSource.WIKI,root/html604/TMVA__PDEFoamTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamTarget.html
https://root.cern/root/html604/TMVA__PDEFoamTarget.html:13049,Availability,error,error,13049,"e transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamTarget(); Default constructor for streamer, user should not use it. PDEFoamTarget(const TString& , UInt_t ); User constructor. Parameters:. - name - name of PDEFoam object. - target - target number to range-search for. PDEFoamTarget(const TMVA::PDEFoamTarget& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void FillFoamCells(const TMVA::Event* ev, Float_t wt); This function fills an event into the discriminant PDEFoam. The; weight 'wt' is filled into cell element 0 if the event is of; class 'fTarget', and filled into cell element 1 otherwise. void Finalize(); Calculate average cell target in every cell and save them to the; cell. Cell element 0 will contain the average target and cell; element 1 will contain the error on the target. Bool_t CellValueIsUndefined(TMVA::PDEFoamCell* cell); Returns true, if the target error equals -1, as set in; Finalize() in case of no events in the cell. Float_t GetCellValue(const vector<Float_t>& xvec, TMVA::ECellValue cv, TMVA::PDEFoamKernelBase* ); This function finds the cell, which corresponds to the given; untransformed event vector 'xvec' and return its value, which is; given by the parameter 'cv'. If cv == kValue, it is checked wether the cell value is; undefined. If this is the case, then the mean of the neighbor's; target values is returned, using GetAverageNeighborsValue(). Float_t GetAverageNeighborsValue(vector<Float_t>& , TMVA::ECellValue ); This function returns the average value 'cv' of only nearest; neighbor cells. It is used in cases, where empty cells shall; not be evaluated. Parameters:; - txvec - event vector, transformed into foam coordinates [0, 1]; - cv - cell value, see definition of ECellValue. virtual ~PDEFoamTarget(); {}. » Author: Tancredi Carli, Dominik Dannheim, Alexander Voigt » Copyright (c) 2008, 2010: *; » Last changed: root",MatchSource.WIKI,root/html604/TMVA__PDEFoamTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamTarget.html
https://root.cern/root/html604/TMVA__PDEFoamTarget.html:10136,Deployability,integrat,integration,10136,"; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell;",MatchSource.WIKI,root/html604/TMVA__PDEFoamTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamTarget.html
https://root.cern/root/html604/TMVA__PDEFoamTarget.html:10136,Integrability,integrat,integration,10136,"; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell;",MatchSource.WIKI,root/html604/TMVA__PDEFoamTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamTarget.html
https://root.cern/root/html604/TMVA__PDEFoamTarget.html:10758,Integrability,message,message,10758,"Object::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 m",MatchSource.WIKI,root/html604/TMVA__PDEFoamTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamTarget.html
https://root.cern/root/html604/TMVA__PDEFoamTarget.html:11104,Modifiability,variab,variables,11104,"ITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; UInt_tfTargetthe target to fill the cells with; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable ",MatchSource.WIKI,root/html604/TMVA__PDEFoamTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamTarget.html
https://root.cern/root/html604/TMVA__PDEFoamTarget.html:11865,Modifiability,variab,variable,11865,"ell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; UInt_tfTargetthe target to fill the cells with; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamTarget(); Default constructor for streamer, user should not use it. PDEFoamTarget(const TString& , UInt_t ); User constructor. Parameters:. - name - name of PDEFoam object. - target - target number to range-search for. PDEFoamTarget(const TMVA::PDEFoamTarget& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void FillFoamCells(const TMVA::Event* ev, Float_t wt); This function fills an event into the discriminant PDEFoam. The; weight 'wt' is filled into cell element 0 if the event is of; class 'fTarget', and filled into cell element 1 otherwise. void Finalize(); Calculate average cell target in every cell and save them to the; cell. Cell element 0 will contain th",MatchSource.WIKI,root/html604/TMVA__PDEFoamTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamTarget.html
https://root.cern/root/html604/TMVA__PDEFoamTarget.html:12036,Modifiability,variab,variable,12036,"ell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; UInt_tfTargetthe target to fill the cells with; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamTarget(); Default constructor for streamer, user should not use it. PDEFoamTarget(const TString& , UInt_t ); User constructor. Parameters:. - name - name of PDEFoam object. - target - target number to range-search for. PDEFoamTarget(const TMVA::PDEFoamTarget& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void FillFoamCells(const TMVA::Event* ev, Float_t wt); This function fills an event into the discriminant PDEFoam. The; weight 'wt' is filled into cell element 0 if the event is of; class 'fTarget', and filled into cell element 1 otherwise. void Finalize(); Calculate average cell target in every cell and save them to the; cell. Cell element 0 will contain th",MatchSource.WIKI,root/html604/TMVA__PDEFoamTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamTarget.html
https://root.cern/root/html604/TMVA__PDEFoamTarget.html:12104,Modifiability,variab,variable,12104,"ell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; UInt_tfTargetthe target to fill the cells with; TMVA::Timer*TMVA::PDEFoam::fTimer! timer for graphical output; TObjArray*TMVA::PDEFoam::fVariableNamescollection of all variable names; Float_tTMVA::PDEFoam::fVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to total phase space; Double_t*TMVA::PDEFoam::fXmax[fDim] maximum for variable transform; Double_t*TMVA::PDEFoam::fXmin[fDim] minimum for variable transform. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamTarget(); Default constructor for streamer, user should not use it. PDEFoamTarget(const TString& , UInt_t ); User constructor. Parameters:. - name - name of PDEFoam object. - target - target number to range-search for. PDEFoamTarget(const TMVA::PDEFoamTarget& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void FillFoamCells(const TMVA::Event* ev, Float_t wt); This function fills an event into the discriminant PDEFoam. The; weight 'wt' is filled into cell element 0 if the event is of; class 'fTarget', and filled into cell element 1 otherwise. void Finalize(); Calculate average cell target in every cell and save them to the; cell. Cell element 0 will contain th",MatchSource.WIKI,root/html604/TMVA__PDEFoamTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamTarget.html
https://root.cern/root/html604/TMVA__PDEFoamTarget.html:10088,Testability,log,logic,10088,"; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell;",MatchSource.WIKI,root/html604/TMVA__PDEFoamTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamTarget.html
https://root.cern/root/html604/TMVA__PDEFoamTarget.html:10766,Testability,log,logger,10766,"Object::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TMVA::PDEFoam::fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**TMVA::PDEFoam::fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationTMVA::PDEFoam::fDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tTMVA::PDEFoam::fDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*TMVA::PDEFoam::fDistr! distribution of training events; Int_tTMVA::PDEFoam::fEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tTMVA::PDEFoam::fFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypeTMVA::PDEFoam::fFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*TMVA::PDEFoam::fHistEdgHistograms of wt, one for each cell edge; Int_t*TMVA::PDEFoam::fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tTMVA::PDEFoam::fLastCeIndex of the last cell; TMVA::MsgLogger*TMVA::PDEFoam::fLogger! message logger; Int_t*TMVA::PDEFoam::fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tTMVA::PDEFoam::fMaxDepthmaximum depth of cell tree; Int_tTMVA::PDEFoam::fNBinNo. of bins in the edge histogram for cell MC exploration; Int_tTMVA::PDEFoam::fNCellsMaximum number of cells; UInt_tTMVA::PDEFoam::fNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tTMVA::PDEFoam::fNSamplNo. of MC events, when dividing (exploring) cell; TStringTMVA::PDEFoam::fNameName of a given instance of the FOAM class; UInt_tTMVA::PDEFoam::fNminminimal number of events in cell to split cell; Int_tTMVA::PDEFoam::fNoActNumber of active cells; Bool_tTMVA::PDEFoam::fPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*TMVA::PDEFoam::fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*TMVA::PDEFoam::fRvec[fDim] random number vector from r.n. generator fDim+1 m",MatchSource.WIKI,root/html604/TMVA__PDEFoamTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamTarget.html
https://root.cern/root/html604/TMVA__PDEFoamTargetDensity.html:1600,Availability,error,error,1600,"Density(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(vector<Double_t>& Xarg, Double_t& event_density); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTMVA::PDEFoamDensityBase::FillBinarySearchTree(const TMVA::Event* ev); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const vector<Double_t>&TMVA::PDEFoamDensityBase::GetBox() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() co",MatchSource.WIKI,root/html604/TMVA__PDEFoamTargetDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamTargetDensity.html
https://root.cern/root/html604/TMVA__PDEFoamTargetDensity.html:1684,Availability,error,error,1684,"t::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(vector<Double_t>& Xarg, Double_t& event_density); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTMVA::PDEFoamDensityBase::FillBinarySearchTree(const TMVA::Event* ev); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const vector<Double_t>&TMVA::PDEFoamDensityBase::GetBox() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtua",MatchSource.WIKI,root/html604/TMVA__PDEFoamTargetDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamTargetDensity.html
https://root.cern/root/html604/TMVA__PDEFoamTargetDensity.html:6808,Integrability,message,message,6808,"_tTMVA::PDEFoamDensityBase::GetBoxVolume(); TMVA::MsgLogger&TMVA::PDEFoamDensityBase::Log() const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::BinarySearchTree*TMVA::PDEFoamDensityBase::fBstBinary tree to find events within a volume; TMVA::MsgLogger*TMVA::PDEFoamDensityBase::fLogger! message logger; UInt_tfTargetthe target to calculate the density for. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamTargetDensity(); {}. PDEFoamTargetDensity(vector<Double_t> box, UInt_t target); User construcor. Parameters:. - box - size of the range-searching box (n-dimensional; std::vector). - target - the target number to calculate the density for. PDEFoamTargetDensity(const TMVA::PDEFoamTargetDensity& ); Copy constructor. Double_t Density(vector<Double_t>& Xarg, Double_t& event_density); This function is needed during the foam buildup. It returns the; average target value within the range-searching box at point; xev, divided by volume (specified by fBox). Parameters:. - xev - event vector (in [fXmin,fXmax]) to place the box at. - event_density - here the event density is stored. Returns:. Average target value in the range-searching volume at point; 'xev', divided by the box volume. virtual ",MatchSource.WIKI,root/html604/TMVA__PDEFoamTargetDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamTargetDensity.html
https://root.cern/root/html604/TMVA__PDEFoamTargetDensity.html:6816,Testability,log,logger,6816,"_tTMVA::PDEFoamDensityBase::GetBoxVolume(); TMVA::MsgLogger&TMVA::PDEFoamDensityBase::Log() const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::BinarySearchTree*TMVA::PDEFoamDensityBase::fBstBinary tree to find events within a volume; TMVA::MsgLogger*TMVA::PDEFoamDensityBase::fLogger! message logger; UInt_tfTargetthe target to calculate the density for. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamTargetDensity(); {}. PDEFoamTargetDensity(vector<Double_t> box, UInt_t target); User construcor. Parameters:. - box - size of the range-searching box (n-dimensional; std::vector). - target - the target number to calculate the density for. PDEFoamTargetDensity(const TMVA::PDEFoamTargetDensity& ); Copy constructor. Double_t Density(vector<Double_t>& Xarg, Double_t& event_density); This function is needed during the foam buildup. It returns the; average target value within the range-searching box at point; xev, divided by volume (specified by fBox). Parameters:. - xev - event vector (in [fXmin,fXmax]) to place the box at. - event_density - here the event density is stored. Returns:. Average target value in the range-searching volume at point; 'xev', divided by the box volume. virtual ",MatchSource.WIKI,root/html604/TMVA__PDEFoamTargetDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamTargetDensity.html
https://root.cern/root/html604/TMVA__PDEFoamVect.html:1284,Availability,error,error,1284," virtual~PDEFoamVect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetCoord(Int_t i) const; Int_tGetDim() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TO",MatchSource.WIKI,root/html604/TMVA__PDEFoamVect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamVect.html
https://root.cern/root/html604/TMVA__PDEFoamVect.html:1368,Availability,error,error,1368," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetCoord(Int_t i) const; Int_tGetDim() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::Inh",MatchSource.WIKI,root/html604/TMVA__PDEFoamVect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamVect.html
https://root.cern/root/html604/TMVA__PDEFoamVect.html:6514,Security,access,access,6514,"TObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Double_t*fCoords[fDim] Coordinates; Int_tfDimDimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamVect(); Default constructor for streamer. PDEFoamVect(Int_t ); User constructor creating n-dimensional vector; and allocating dynamically array of components. PDEFoamVect(const TMVA::PDEFoamVect& ); Copy constructor. ~PDEFoamVect(); Destructor. Double_t & operator[](Int_t ); [] is for access to elements as in ordinary matrix like a[j]=b[j]; (Perhaps against some strict rules but rather practical.); Range protection is built in, consequently for substitution; one should use rather use a=b than explicit loop!. TMVA::PDEFoamVect& operator*=(const Double_t& ); unary multiplication operator *=. TMVA::PDEFoamVect& operator+=(const TMVA::PDEFoamVect& ); unary addition operator +=; adding vector c*=x,. TMVA::PDEFoamVect& operator-=(const TMVA::PDEFoamVect& ); unary subtraction operator -=. TMVA::PDEFoamVect operator+(const TMVA::PDEFoamVect& ); addition operator +; sum of 2 vectors: c=a+b, a=a+b,; NEVER USE IT, VERY SLOW!!!. TMVA::PDEFoamVect operator-(const TMVA::PDEFoamVect& ); subtraction operator -; difference of 2 vectors; c=a-b, a=a-b,; NEVER USE IT, VERY SLOW!!!. void Print(Option_t* option) const; Printout of all vector components. Int_t GetDim() const; { return fDim; }. Double_t GetCoord(Int_t i) const; { return fCoords[i]; }. » Author: S. Jadach, Tancredi Carli, Dominik Dannheim, Alexander Voigt » C",MatchSource.WIKI,root/html604/TMVA__PDEFoamVect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamVect.html
https://root.cern/root/html604/TMVA__PDF.html:1625,Availability,error,error,1625,"idTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGraph*GetGraph() const; Int_tGetHistNBins(Int_t evtNum = 0); virtual const char*TObject::GetIconName() const; Double_tGetIntegral(Double_t xmin, Double_t xmax); TMVA::PDF::EInterpolateMethodGetInterpolMethod(); virtual const char*GetName() const; Int_tGetNBins() const; TH1*GetNSmoothHist() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() c",MatchSource.WIKI,root/html604/TMVA__PDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDF.html
https://root.cern/root/html604/TMVA__PDF.html:1709,Availability,error,error,1709,"const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGraph*GetGraph() const; Int_tGetHistNBins(Int_t evtNum = 0); virtual const char*TObject::GetIconName() const; Double_tGetIntegral(Double_t xmin, Double_t xmax); TMVA::PDF::EInterpolateMethodGetInterpolMethod(); virtual const char*GetName() const; Int_tGetNBins() const; TH1*GetNSmoothHist() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TString&TMVA::Configurable::GetOptions() const; TH1*GetOriginalHist() co",MatchSource.WIKI,root/html604/TMVA__PDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDF.html
https://root.cern/root/html604/TMVA__PDF.html:10471,Deployability,integrat,integration,10471,"F::EInterpolateMethodkSpline3; static TMVA::PDF::EInterpolateMethodkSpline5; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfBorderMethodString; Bool_tfCheckHistcheck of source histogram; Float_tfFineFactorfine tuning factor for Adaptive KDE; TGraph*fGraph! needed to create PDF from histogram; TH1*fHistcopy of input histogram; Int_tfHistAvgEvtPerBinavg event per source hist bin; Int_tfHistDefinedNBinssource hist bin num set by user; TH1*fHistOriginalthe input histogram; TF1*fIGetValintegration interface; TMVA::PDF::EInterpolateMethodfInterpolMethodinterpolation method; TStringfInterpolateString; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects (string); TMVA::KDEKernel::EKernelIterfKDEiterNumber of iterations (adaptive or not); TStringfKDEiterString; TMVA::KDEKernel::EKernelTypefKDEtypeKernel type to use for KDE; TStringfKDEtypeStringstrings used to read definitions; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxNsmoothMax number of smoothing iterations; Int_tfMinNsmoothMin number of smoothing iterations; TH1*fNSmoothHistnumber of smooth for each bin; Bool_tfNormalizenormalize histogram (false for cumulative distribution used in GaussTranform); Int_tfNsmoothMin number of smoothing iterations; TH1*fPDFHistthe high-binned histogram corresponding to the PDF; TStringfPDFNamefor output; UInt_tfReadingVersionthe TMVA version of the weight file; TSpline*fSpline! the used spline type; TStringfSuffix! the suffix for options; Bool_tfUseHistogramspline0 uses histogram as reference; static const Double_tfgEpsilonminimum PDF return; static const Bool_tfgManualIntegrationmanual integration (sum over bins) or DGAUSS; static const Int_tfgNbin_PdfHistnumber of bins in high-binned reference histogram. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDF(const TString& name, Bool_t norm = kTRUE); default constructor needed for ROOT I/O. P",MatchSource.WIKI,root/html604/TMVA__PDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDF.html
https://root.cern/root/html604/TMVA__PDF.html:9596,Energy Efficiency,adapt,adaptive,9596,"F::EInterpolateMethodkSpline3; static TMVA::PDF::EInterpolateMethodkSpline5; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfBorderMethodString; Bool_tfCheckHistcheck of source histogram; Float_tfFineFactorfine tuning factor for Adaptive KDE; TGraph*fGraph! needed to create PDF from histogram; TH1*fHistcopy of input histogram; Int_tfHistAvgEvtPerBinavg event per source hist bin; Int_tfHistDefinedNBinssource hist bin num set by user; TH1*fHistOriginalthe input histogram; TF1*fIGetValintegration interface; TMVA::PDF::EInterpolateMethodfInterpolMethodinterpolation method; TStringfInterpolateString; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects (string); TMVA::KDEKernel::EKernelIterfKDEiterNumber of iterations (adaptive or not); TStringfKDEiterString; TMVA::KDEKernel::EKernelTypefKDEtypeKernel type to use for KDE; TStringfKDEtypeStringstrings used to read definitions; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxNsmoothMax number of smoothing iterations; Int_tfMinNsmoothMin number of smoothing iterations; TH1*fNSmoothHistnumber of smooth for each bin; Bool_tfNormalizenormalize histogram (false for cumulative distribution used in GaussTranform); Int_tfNsmoothMin number of smoothing iterations; TH1*fPDFHistthe high-binned histogram corresponding to the PDF; TStringfPDFNamefor output; UInt_tfReadingVersionthe TMVA version of the weight file; TSpline*fSpline! the used spline type; TStringfSuffix! the suffix for options; Bool_tfUseHistogramspline0 uses histogram as reference; static const Double_tfgEpsilonminimum PDF return; static const Bool_tfgManualIntegrationmanual integration (sum over bins) or DGAUSS; static const Int_tfgNbin_PdfHistnumber of bins in high-binned reference histogram. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDF(const TString& name, Bool_t norm = kTRUE); default constructor needed for ROOT I/O. P",MatchSource.WIKI,root/html604/TMVA__PDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDF.html
https://root.cern/root/html604/TMVA__PDF.html:13441,Energy Efficiency,adapt,adaptive,13441,"e PDF(x). Double_t GetValInverse(Double_t y, Bool_t isMonotonouslyIncreasingFunction = kFALSE) const; returns value PDF^{-1}(y). void FindBinInverse(const TH1* histogram, Int_t& lowerBin, Int_t& higherBin, Double_t& lowerBinValue, Double_t& higherBinValue, Double_t y, Bool_t isMonotonouslyIncreasingFunction = kFALSE) const; find bin from value on ordinate. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; PDFInterpol[ivar] <string> Spline0, Spline1, Spline2 <default>, Spline3, Spline5, KDE used to interpolate reference histograms; if no variable index is given, it is valid for ALL the variables. NSmooth <int> how often the input histos are smoothed; MinNSmooth <int> min number of smoothing iterations, for bins with most data; MaxNSmooth <int> max number of smoothing iterations, for bins with least data; NAvEvtPerBin <int> minimum average number of events per PDF bin; TransformOutput <bool> transform (often strongly peaked) likelihood output through sigmoid inversion; fKDEtype <KernelType> type of the Kernel to use (1 is Gaussian); fKDEiter <KerneIter> number of iterations (1 --> ""static KDE"", 2 --> ""adaptive KDE""); fBorderMethod <KernelBorder> the method to take care about ""border"" effects (1=no treatment , 2=kernel renormalization, 3=sample mirroring). void ProcessOptions(). void AddXMLTo(void* parent); XML file writing. void ReadXML(void* pdfnode); XML file reading. TMVA::PDF* ThisPDF( void ); return global ""this"" pointer of PDF. explicit PDF(const TString& name, Bool_t norm = kTRUE). TH1* GetPDFHist() const; histogram underlying the PDF. { return fPDFHist; }. TGraph* GetGraph() const; { return fGraph; }. TH1* GetOriginalHist() const; { return fHistOriginal; }. TH1* GetSmoothedHist() const; { return fHist; }. TH1* GetNSmoothHist() const; { return fNSmoothHist; }. TSpline* GetSpline() const; accessors. { return fSpline; }. Int_t GetNBins() const; { return fHist->GetNbinsX(); }. Double_t GetXmin() const; ",MatchSource.WIKI,root/html604/TMVA__PDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDF.html
https://root.cern/root/html604/TMVA__PDF.html:9337,Integrability,interface,interface,9337,"F::EInterpolateMethodkSpline3; static TMVA::PDF::EInterpolateMethodkSpline5; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfBorderMethodString; Bool_tfCheckHistcheck of source histogram; Float_tfFineFactorfine tuning factor for Adaptive KDE; TGraph*fGraph! needed to create PDF from histogram; TH1*fHistcopy of input histogram; Int_tfHistAvgEvtPerBinavg event per source hist bin; Int_tfHistDefinedNBinssource hist bin num set by user; TH1*fHistOriginalthe input histogram; TF1*fIGetValintegration interface; TMVA::PDF::EInterpolateMethodfInterpolMethodinterpolation method; TStringfInterpolateString; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects (string); TMVA::KDEKernel::EKernelIterfKDEiterNumber of iterations (adaptive or not); TStringfKDEiterString; TMVA::KDEKernel::EKernelTypefKDEtypeKernel type to use for KDE; TStringfKDEtypeStringstrings used to read definitions; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxNsmoothMax number of smoothing iterations; Int_tfMinNsmoothMin number of smoothing iterations; TH1*fNSmoothHistnumber of smooth for each bin; Bool_tfNormalizenormalize histogram (false for cumulative distribution used in GaussTranform); Int_tfNsmoothMin number of smoothing iterations; TH1*fPDFHistthe high-binned histogram corresponding to the PDF; TStringfPDFNamefor output; UInt_tfReadingVersionthe TMVA version of the weight file; TSpline*fSpline! the used spline type; TStringfSuffix! the suffix for options; Bool_tfUseHistogramspline0 uses histogram as reference; static const Double_tfgEpsilonminimum PDF return; static const Bool_tfgManualIntegrationmanual integration (sum over bins) or DGAUSS; static const Int_tfgNbin_PdfHistnumber of bins in high-binned reference histogram. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDF(const TString& name, Bool_t norm = kTRUE); default constructor needed for ROOT I/O. P",MatchSource.WIKI,root/html604/TMVA__PDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDF.html
https://root.cern/root/html604/TMVA__PDF.html:9781,Integrability,message,message,9781,"F::EInterpolateMethodkSpline3; static TMVA::PDF::EInterpolateMethodkSpline5; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfBorderMethodString; Bool_tfCheckHistcheck of source histogram; Float_tfFineFactorfine tuning factor for Adaptive KDE; TGraph*fGraph! needed to create PDF from histogram; TH1*fHistcopy of input histogram; Int_tfHistAvgEvtPerBinavg event per source hist bin; Int_tfHistDefinedNBinssource hist bin num set by user; TH1*fHistOriginalthe input histogram; TF1*fIGetValintegration interface; TMVA::PDF::EInterpolateMethodfInterpolMethodinterpolation method; TStringfInterpolateString; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects (string); TMVA::KDEKernel::EKernelIterfKDEiterNumber of iterations (adaptive or not); TStringfKDEiterString; TMVA::KDEKernel::EKernelTypefKDEtypeKernel type to use for KDE; TStringfKDEtypeStringstrings used to read definitions; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxNsmoothMax number of smoothing iterations; Int_tfMinNsmoothMin number of smoothing iterations; TH1*fNSmoothHistnumber of smooth for each bin; Bool_tfNormalizenormalize histogram (false for cumulative distribution used in GaussTranform); Int_tfNsmoothMin number of smoothing iterations; TH1*fPDFHistthe high-binned histogram corresponding to the PDF; TStringfPDFNamefor output; UInt_tfReadingVersionthe TMVA version of the weight file; TSpline*fSpline! the used spline type; TStringfSuffix! the suffix for options; Bool_tfUseHistogramspline0 uses histogram as reference; static const Double_tfgEpsilonminimum PDF return; static const Bool_tfgManualIntegrationmanual integration (sum over bins) or DGAUSS; static const Int_tfgNbin_PdfHistnumber of bins in high-binned reference histogram. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDF(const TString& name, Bool_t norm = kTRUE); default constructor needed for ROOT I/O. P",MatchSource.WIKI,root/html604/TMVA__PDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDF.html
https://root.cern/root/html604/TMVA__PDF.html:10471,Integrability,integrat,integration,10471,"F::EInterpolateMethodkSpline3; static TMVA::PDF::EInterpolateMethodkSpline5; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfBorderMethodString; Bool_tfCheckHistcheck of source histogram; Float_tfFineFactorfine tuning factor for Adaptive KDE; TGraph*fGraph! needed to create PDF from histogram; TH1*fHistcopy of input histogram; Int_tfHistAvgEvtPerBinavg event per source hist bin; Int_tfHistDefinedNBinssource hist bin num set by user; TH1*fHistOriginalthe input histogram; TF1*fIGetValintegration interface; TMVA::PDF::EInterpolateMethodfInterpolMethodinterpolation method; TStringfInterpolateString; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects (string); TMVA::KDEKernel::EKernelIterfKDEiterNumber of iterations (adaptive or not); TStringfKDEiterString; TMVA::KDEKernel::EKernelTypefKDEtypeKernel type to use for KDE; TStringfKDEtypeStringstrings used to read definitions; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxNsmoothMax number of smoothing iterations; Int_tfMinNsmoothMin number of smoothing iterations; TH1*fNSmoothHistnumber of smooth for each bin; Bool_tfNormalizenormalize histogram (false for cumulative distribution used in GaussTranform); Int_tfNsmoothMin number of smoothing iterations; TH1*fPDFHistthe high-binned histogram corresponding to the PDF; TStringfPDFNamefor output; UInt_tfReadingVersionthe TMVA version of the weight file; TSpline*fSpline! the used spline type; TStringfSuffix! the suffix for options; Bool_tfUseHistogramspline0 uses histogram as reference; static const Double_tfgEpsilonminimum PDF return; static const Bool_tfgManualIntegrationmanual integration (sum over bins) or DGAUSS; static const Int_tfgNbin_PdfHistnumber of bins in high-binned reference histogram. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDF(const TString& name, Bool_t norm = kTRUE); default constructor needed for ROOT I/O. P",MatchSource.WIKI,root/html604/TMVA__PDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDF.html
https://root.cern/root/html604/TMVA__PDF.html:9596,Modifiability,adapt,adaptive,9596,"F::EInterpolateMethodkSpline3; static TMVA::PDF::EInterpolateMethodkSpline5; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfBorderMethodString; Bool_tfCheckHistcheck of source histogram; Float_tfFineFactorfine tuning factor for Adaptive KDE; TGraph*fGraph! needed to create PDF from histogram; TH1*fHistcopy of input histogram; Int_tfHistAvgEvtPerBinavg event per source hist bin; Int_tfHistDefinedNBinssource hist bin num set by user; TH1*fHistOriginalthe input histogram; TF1*fIGetValintegration interface; TMVA::PDF::EInterpolateMethodfInterpolMethodinterpolation method; TStringfInterpolateString; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects (string); TMVA::KDEKernel::EKernelIterfKDEiterNumber of iterations (adaptive or not); TStringfKDEiterString; TMVA::KDEKernel::EKernelTypefKDEtypeKernel type to use for KDE; TStringfKDEtypeStringstrings used to read definitions; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxNsmoothMax number of smoothing iterations; Int_tfMinNsmoothMin number of smoothing iterations; TH1*fNSmoothHistnumber of smooth for each bin; Bool_tfNormalizenormalize histogram (false for cumulative distribution used in GaussTranform); Int_tfNsmoothMin number of smoothing iterations; TH1*fPDFHistthe high-binned histogram corresponding to the PDF; TStringfPDFNamefor output; UInt_tfReadingVersionthe TMVA version of the weight file; TSpline*fSpline! the used spline type; TStringfSuffix! the suffix for options; Bool_tfUseHistogramspline0 uses histogram as reference; static const Double_tfgEpsilonminimum PDF return; static const Bool_tfgManualIntegrationmanual integration (sum over bins) or DGAUSS; static const Int_tfgNbin_PdfHistnumber of bins in high-binned reference histogram. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDF(const TString& name, Bool_t norm = kTRUE); default constructor needed for ROOT I/O. P",MatchSource.WIKI,root/html604/TMVA__PDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDF.html
https://root.cern/root/html604/TMVA__PDF.html:12867,Modifiability,variab,variable,12867," of the; PDF for speed reasons. void CheckHist() const; sanity check: compare PDF with original histogram. void ValidatePDF(TH1* original = 0) const; comparison of original histogram with reference PDF. Double_t GetIntegral() const; computes normalisation. Double_t IGetVal(Double_t* , Double_t* ); static external auxiliary function (integrand). Double_t GetIntegral(Double_t xmin, Double_t xmax); computes PDF integral within given ranges. Double_t GetVal(Double_t x) const; returns value PDF(x). Double_t GetValInverse(Double_t y, Bool_t isMonotonouslyIncreasingFunction = kFALSE) const; returns value PDF^{-1}(y). void FindBinInverse(const TH1* histogram, Int_t& lowerBin, Int_t& higherBin, Double_t& lowerBinValue, Double_t& higherBinValue, Double_t y, Bool_t isMonotonouslyIncreasingFunction = kFALSE) const; find bin from value on ordinate. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; PDFInterpol[ivar] <string> Spline0, Spline1, Spline2 <default>, Spline3, Spline5, KDE used to interpolate reference histograms; if no variable index is given, it is valid for ALL the variables. NSmooth <int> how often the input histos are smoothed; MinNSmooth <int> min number of smoothing iterations, for bins with most data; MaxNSmooth <int> max number of smoothing iterations, for bins with least data; NAvEvtPerBin <int> minimum average number of events per PDF bin; TransformOutput <bool> transform (often strongly peaked) likelihood output through sigmoid inversion; fKDEtype <KernelType> type of the Kernel to use (1 is Gaussian); fKDEiter <KerneIter> number of iterations (1 --> ""static KDE"", 2 --> ""adaptive KDE""); fBorderMethod <KernelBorder> the method to take care about ""border"" effects (1=no treatment , 2=kernel renormalization, 3=sample mirroring). void ProcessOptions(). void AddXMLTo(void* parent); XML file writing. void ReadXML(void* pdfnode); XML file reading. TMVA::PDF* ThisPDF( void ); return global ""this"" pointer o",MatchSource.WIKI,root/html604/TMVA__PDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDF.html
https://root.cern/root/html604/TMVA__PDF.html:12916,Modifiability,variab,variables,12916," of the; PDF for speed reasons. void CheckHist() const; sanity check: compare PDF with original histogram. void ValidatePDF(TH1* original = 0) const; comparison of original histogram with reference PDF. Double_t GetIntegral() const; computes normalisation. Double_t IGetVal(Double_t* , Double_t* ); static external auxiliary function (integrand). Double_t GetIntegral(Double_t xmin, Double_t xmax); computes PDF integral within given ranges. Double_t GetVal(Double_t x) const; returns value PDF(x). Double_t GetValInverse(Double_t y, Bool_t isMonotonouslyIncreasingFunction = kFALSE) const; returns value PDF^{-1}(y). void FindBinInverse(const TH1* histogram, Int_t& lowerBin, Int_t& higherBin, Double_t& lowerBinValue, Double_t& higherBinValue, Double_t y, Bool_t isMonotonouslyIncreasingFunction = kFALSE) const; find bin from value on ordinate. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; PDFInterpol[ivar] <string> Spline0, Spline1, Spline2 <default>, Spline3, Spline5, KDE used to interpolate reference histograms; if no variable index is given, it is valid for ALL the variables. NSmooth <int> how often the input histos are smoothed; MinNSmooth <int> min number of smoothing iterations, for bins with most data; MaxNSmooth <int> max number of smoothing iterations, for bins with least data; NAvEvtPerBin <int> minimum average number of events per PDF bin; TransformOutput <bool> transform (often strongly peaked) likelihood output through sigmoid inversion; fKDEtype <KernelType> type of the Kernel to use (1 is Gaussian); fKDEiter <KerneIter> number of iterations (1 --> ""static KDE"", 2 --> ""adaptive KDE""); fBorderMethod <KernelBorder> the method to take care about ""border"" effects (1=no treatment , 2=kernel renormalization, 3=sample mirroring). void ProcessOptions(). void AddXMLTo(void* parent); XML file writing. void ReadXML(void* pdfnode); XML file reading. TMVA::PDF* ThisPDF( void ); return global ""this"" pointer o",MatchSource.WIKI,root/html604/TMVA__PDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDF.html
https://root.cern/root/html604/TMVA__PDF.html:13441,Modifiability,adapt,adaptive,13441,"e PDF(x). Double_t GetValInverse(Double_t y, Bool_t isMonotonouslyIncreasingFunction = kFALSE) const; returns value PDF^{-1}(y). void FindBinInverse(const TH1* histogram, Int_t& lowerBin, Int_t& higherBin, Double_t& lowerBinValue, Double_t& higherBinValue, Double_t y, Bool_t isMonotonouslyIncreasingFunction = kFALSE) const; find bin from value on ordinate. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; PDFInterpol[ivar] <string> Spline0, Spline1, Spline2 <default>, Spline3, Spline5, KDE used to interpolate reference histograms; if no variable index is given, it is valid for ALL the variables. NSmooth <int> how often the input histos are smoothed; MinNSmooth <int> min number of smoothing iterations, for bins with most data; MaxNSmooth <int> max number of smoothing iterations, for bins with least data; NAvEvtPerBin <int> minimum average number of events per PDF bin; TransformOutput <bool> transform (often strongly peaked) likelihood output through sigmoid inversion; fKDEtype <KernelType> type of the Kernel to use (1 is Gaussian); fKDEiter <KerneIter> number of iterations (1 --> ""static KDE"", 2 --> ""adaptive KDE""); fBorderMethod <KernelBorder> the method to take care about ""border"" effects (1=no treatment , 2=kernel renormalization, 3=sample mirroring). void ProcessOptions(). void AddXMLTo(void* parent); XML file writing. void ReadXML(void* pdfnode); XML file reading. TMVA::PDF* ThisPDF( void ); return global ""this"" pointer of PDF. explicit PDF(const TString& name, Bool_t norm = kTRUE). TH1* GetPDFHist() const; histogram underlying the PDF. { return fPDFHist; }. TGraph* GetGraph() const; { return fGraph; }. TH1* GetOriginalHist() const; { return fHistOriginal; }. TH1* GetSmoothedHist() const; { return fHist; }. TH1* GetNSmoothHist() const; { return fNSmoothHist; }. TSpline* GetSpline() const; accessors. { return fSpline; }. Int_t GetNBins() const; { return fHist->GetNbinsX(); }. Double_t GetXmin() const; ",MatchSource.WIKI,root/html604/TMVA__PDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDF.html
https://root.cern/root/html604/TMVA__PDF.html:11828,Safety,sanity check,sanity check,11828,"Method method = kSpline2, Int_t minnsmooth = 0, Int_t maxnsmooth = 0, Bool_t checkHist = kFALSE, Bool_t norm = kTRUE); constructor of spline based PDF:. PDF(const TString& name, const TH1* theHist, TMVA::KDEKernel::EKernelType ktype, TMVA::KDEKernel::EKernelIter kiter, TMVA::KDEKernel::EKernelBorder kborder, Float_t FineFactor, Bool_t norm = kTRUE); constructor of kernel based PDF:. PDF(const TString& name, const TString& options, const TString& suffix = """", TMVA::PDF* defaultPDF = 0, Bool_t norm = kTRUE). ~PDF(); destructor. void BuildPDF(const TH1* theHist). Int_t GetHistNBins(Int_t evtNum = 0). void BuildSplinePDF(); build the PDF from the original histograms. void BuildKDEPDF(); creates high-binned reference histogram to be used instead of the; PDF for speed reasons. void SmoothHistogram(). void FillHistToGraph(); Simple conversion. void FillSplineToHist(); creates high-binned reference histogram to be used instead of the; PDF for speed reasons. void CheckHist() const; sanity check: compare PDF with original histogram. void ValidatePDF(TH1* original = 0) const; comparison of original histogram with reference PDF. Double_t GetIntegral() const; computes normalisation. Double_t IGetVal(Double_t* , Double_t* ); static external auxiliary function (integrand). Double_t GetIntegral(Double_t xmin, Double_t xmax); computes PDF integral within given ranges. Double_t GetVal(Double_t x) const; returns value PDF(x). Double_t GetValInverse(Double_t y, Bool_t isMonotonouslyIncreasingFunction = kFALSE) const; returns value PDF^{-1}(y). void FindBinInverse(const TH1* histogram, Int_t& lowerBin, Int_t& higherBin, Double_t& lowerBinValue, Double_t& higherBinValue, Double_t y, Bool_t isMonotonouslyIncreasingFunction = kFALSE) const; find bin from value on ordinate. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; PDFInterpol[ivar] <string> Spline0, Spline1, Spline2 <default>, Spline3, Spline5, KDE used to interpolate re",MatchSource.WIKI,root/html604/TMVA__PDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDF.html
https://root.cern/root/html604/TMVA__PDF.html:14148,Security,access,accessors,14148," NAvEvtPerBin <int> minimum average number of events per PDF bin; TransformOutput <bool> transform (often strongly peaked) likelihood output through sigmoid inversion; fKDEtype <KernelType> type of the Kernel to use (1 is Gaussian); fKDEiter <KerneIter> number of iterations (1 --> ""static KDE"", 2 --> ""adaptive KDE""); fBorderMethod <KernelBorder> the method to take care about ""border"" effects (1=no treatment , 2=kernel renormalization, 3=sample mirroring). void ProcessOptions(). void AddXMLTo(void* parent); XML file writing. void ReadXML(void* pdfnode); XML file reading. TMVA::PDF* ThisPDF( void ); return global ""this"" pointer of PDF. explicit PDF(const TString& name, Bool_t norm = kTRUE). TH1* GetPDFHist() const; histogram underlying the PDF. { return fPDFHist; }. TGraph* GetGraph() const; { return fGraph; }. TH1* GetOriginalHist() const; { return fHistOriginal; }. TH1* GetSmoothedHist() const; { return fHist; }. TH1* GetNSmoothHist() const; { return fNSmoothHist; }. TSpline* GetSpline() const; accessors. { return fSpline; }. Int_t GetNBins() const; { return fHist->GetNbinsX(); }. Double_t GetXmin() const; { return fHist->GetXaxis()->GetXmin(); }. Double_t GetXmax() const; { return fHist->GetXaxis()->GetXmax(); }. TMVA::PDF::EInterpolateMethod GetInterpolMethod(); { return fInterpolMethod;}. const char* GetName() const; modified name (remove TMVA::). { return fPDFName; }. void SetReadingVersion(UInt_t rv); TMVA version control (for weight files). { fReadingVersion = rv; }. UInt_t GetReadingVersion() const; { return fReadingVersion; }. Double_t GetPdfHistBinWidth() const. Bool_t UseHistogram() const; do we use the original histogram as reference ?. { return fUseHistogram; }. PDF*& GetThisPdfThreadLocal(); static pointer to this object; This is a workaround for OSx where static thread_local data members are; not supported. The C++ solution would indeed be the following:. { TTHREAD_TLS(PDF*) fgThisPDF(nullptr); return fgThisPDF; }. » Author: Asen Christov, Andreas Hoeck",MatchSource.WIKI,root/html604/TMVA__PDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDF.html
https://root.cern/root/html604/TMVA__PDF.html:9789,Testability,log,logger,9789,"F::EInterpolateMethodkSpline3; static TMVA::PDF::EInterpolateMethodkSpline5; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfBorderMethodString; Bool_tfCheckHistcheck of source histogram; Float_tfFineFactorfine tuning factor for Adaptive KDE; TGraph*fGraph! needed to create PDF from histogram; TH1*fHistcopy of input histogram; Int_tfHistAvgEvtPerBinavg event per source hist bin; Int_tfHistDefinedNBinssource hist bin num set by user; TH1*fHistOriginalthe input histogram; TF1*fIGetValintegration interface; TMVA::PDF::EInterpolateMethodfInterpolMethodinterpolation method; TStringfInterpolateString; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects (string); TMVA::KDEKernel::EKernelIterfKDEiterNumber of iterations (adaptive or not); TStringfKDEiterString; TMVA::KDEKernel::EKernelTypefKDEtypeKernel type to use for KDE; TStringfKDEtypeStringstrings used to read definitions; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxNsmoothMax number of smoothing iterations; Int_tfMinNsmoothMin number of smoothing iterations; TH1*fNSmoothHistnumber of smooth for each bin; Bool_tfNormalizenormalize histogram (false for cumulative distribution used in GaussTranform); Int_tfNsmoothMin number of smoothing iterations; TH1*fPDFHistthe high-binned histogram corresponding to the PDF; TStringfPDFNamefor output; UInt_tfReadingVersionthe TMVA version of the weight file; TSpline*fSpline! the used spline type; TStringfSuffix! the suffix for options; Bool_tfUseHistogramspline0 uses histogram as reference; static const Double_tfgEpsilonminimum PDF return; static const Bool_tfgManualIntegrationmanual integration (sum over bins) or DGAUSS; static const Int_tfgNbin_PdfHistnumber of bins in high-binned reference histogram. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDF(const TString& name, Bool_t norm = kTRUE); default constructor needed for ROOT I/O. P",MatchSource.WIKI,root/html604/TMVA__PDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__PDF.html
https://root.cern/root/html604/TMVA__QuickMVAProbEstimator.html:1513,Usability,simpl,simple,1513," source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::QuickMVAProbEstimator. class TMVA::QuickMVAProbEstimator. Function Members (Methods); public:. virtual~QuickMVAProbEstimator(); voidAddEvent(Double_t val, Double_t weight, Int_t type); static TClass*Class(); static boolcompare(TMVA::QuickMVAProbEstimator::EventInfo e1, TMVA::QuickMVAProbEstimator::EventInfo e2); Double_tGetMVAProbAt(Double_t value); virtual TClass*IsA() const; TMVA::QuickMVAProbEstimator&operator=(const TMVA::QuickMVAProbEstimator&); TMVA::QuickMVAProbEstimatorQuickMVAProbEstimator(const TMVA::QuickMVAProbEstimator&); TMVA::QuickMVAProbEstimatorQuickMVAProbEstimator(Int_t nMin = 40, Int_t nMax = 5000); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TMVA::MsgLogger&Log() const. Data Members; private:. vector<TMVA::QuickMVAProbEstimator::EventInfo>fEvtVector; Bool_tfIsSorted; TMVA::MsgLogger*fLogger; UInt_tfNMax; UInt_tfNMin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddEvent(Double_t val, Double_t weight, Int_t type). Double_t GetMVAProbAt(Double_t value); Well.. if it's fast is actually another question all together, merely; it's a quick and dirty simple kNN approach to the 1-Dim signal/backgr. MVA; distributions. bool compare(TMVA::QuickMVAProbEstimator::EventInfo e1, TMVA::QuickMVAProbEstimator::EventInfo e2); {return e1.eventValue < e2.eventValue;}. QuickMVAProbEstimator(Int_t nMin = 40, Int_t nMax = 5000); { fLogger = new MsgLogger(""QuickMVAProbEstimator"");}. virtual ~QuickMVAProbEstimator(); {delete fLogger;}. » Last changed: Tue Sep 8 17:45:59 2015 » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__QuickMVAProbEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__QuickMVAProbEstimator.html
https://root.cern/root/html604/TMVA__Ranking.html:1070,Integrability,message,message,1070,"ick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::Ranking. class TMVA::Ranking. Ranking for variables in method (implementation). Function Members (Methods); public:. virtual~Ranking(); virtual voidAddRank(const TMVA::Rank& rank); static TClass*Class(); virtual TClass*IsA() const; TMVA::Ranking&operator=(const TMVA::Ranking&); virtual voidPrint() const; TMVA::RankingRanking(); TMVA::RankingRanking(const TMVA::Ranking&); TMVA::RankingRanking(const TString& context, const TString& rankingDiscriminatorName); voidSetContext(const TString& context); voidSetDiscrName(const TString& discrName); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TMVA::MsgLogger&Log() const. Data Members; private:. TStringfContextthe ranking context; TMVA::MsgLogger*fLogger! message logger; vector<TMVA::Rank>fRankingvector of ranks; TStringfRankingDiscriminatorNamethe name of the ranking discriminator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Ranking(); default constructor. Ranking(const TString& context, const TString& rankingDiscriminatorName); constructor. ~Ranking(); destructor. void SetContext(const TString& context). void AddRank(const TMVA::Rank& rank); Add a new rank; take ownership of it. void Print() const; get maximum length of variable names. Ranking(). void SetDiscrName(const TString& discrName); { fRankingDiscriminatorName = discrName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__Ranking.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Ranking.html
https://root.cern/root/html604/TMVA__Ranking.html:296,Modifiability,variab,variables,296,". TMVA::Ranking. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::Ranking. class TMVA::Ranking. Ranking for variables in method (implementation). Function Members (Methods); public:. virtual~Ranking(); virtual voidAddRank(const TMVA::Rank& rank); static TClass*Class(); virtual TClass*IsA() const; TMVA::Ranking&operator=(const TMVA::Ranking&); virtual voidPrint() const; TMVA::RankingRanking(); TMVA::RankingRanking(const TMVA::Ranking&); TMVA::RankingRanking(const TString& context, const TString& rankingDiscriminatorName); voidSetContext(const TString& context); voidSetDiscrName(const TString& discrName); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TMVA::MsgLogger&Log() const. Data Members; private:. TStringfContextthe ranking context; TMVA::MsgLogger*fLogger! message logger; vector<TMVA::Rank>fRankingvector of ranks; TStringfRankingDiscriminatorNamethe name of the ranking discriminator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Ranking(); default constructor. Ranking(const TString& context, const TString& rankingDiscriminatorName); constructor. ~Ranking(); destructor. void SetContext(const TString& context). void AddRank(const TMVA::Rank& rank); Add a new rank; take ownership of it. void Print() const; get maximum length of variable names. Ranking(). void SetDiscrName(const TString& discrName); { fRankingDiscriminatorName = discrName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail",MatchSource.WIKI,root/html604/TMVA__Ranking.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Ranking.html
https://root.cern/root/html604/TMVA__Ranking.html:1593,Modifiability,variab,variable,1593,"ick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::Ranking. class TMVA::Ranking. Ranking for variables in method (implementation). Function Members (Methods); public:. virtual~Ranking(); virtual voidAddRank(const TMVA::Rank& rank); static TClass*Class(); virtual TClass*IsA() const; TMVA::Ranking&operator=(const TMVA::Ranking&); virtual voidPrint() const; TMVA::RankingRanking(); TMVA::RankingRanking(const TMVA::Ranking&); TMVA::RankingRanking(const TString& context, const TString& rankingDiscriminatorName); voidSetContext(const TString& context); voidSetDiscrName(const TString& discrName); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TMVA::MsgLogger&Log() const. Data Members; private:. TStringfContextthe ranking context; TMVA::MsgLogger*fLogger! message logger; vector<TMVA::Rank>fRankingvector of ranks; TStringfRankingDiscriminatorNamethe name of the ranking discriminator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Ranking(); default constructor. Ranking(const TString& context, const TString& rankingDiscriminatorName); constructor. ~Ranking(); destructor. void SetContext(const TString& context). void AddRank(const TMVA::Rank& rank); Add a new rank; take ownership of it. void Print() const; get maximum length of variable names. Ranking(). void SetDiscrName(const TString& discrName); { fRankingDiscriminatorName = discrName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__Ranking.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Ranking.html
https://root.cern/root/html604/TMVA__Ranking.html:1078,Testability,log,logger,1078,"ick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::Ranking. class TMVA::Ranking. Ranking for variables in method (implementation). Function Members (Methods); public:. virtual~Ranking(); virtual voidAddRank(const TMVA::Rank& rank); static TClass*Class(); virtual TClass*IsA() const; TMVA::Ranking&operator=(const TMVA::Ranking&); virtual voidPrint() const; TMVA::RankingRanking(); TMVA::RankingRanking(const TMVA::Ranking&); TMVA::RankingRanking(const TString& context, const TString& rankingDiscriminatorName); voidSetContext(const TString& context); voidSetDiscrName(const TString& discrName); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TMVA::MsgLogger&Log() const. Data Members; private:. TStringfContextthe ranking context; TMVA::MsgLogger*fLogger! message logger; vector<TMVA::Rank>fRankingvector of ranks; TStringfRankingDiscriminatorNamethe name of the ranking discriminator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Ranking(); default constructor. Ranking(const TString& context, const TString& rankingDiscriminatorName); constructor. ~Ranking(); destructor. void SetContext(const TString& context). void AddRank(const TMVA::Rank& rank); Add a new rank; take ownership of it. void Print() const; get maximum length of variable names. Ranking(). void SetDiscrName(const TString& discrName); { fRankingDiscriminatorName = discrName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__Ranking.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Ranking.html
https://root.cern/root/html604/TMVA__Reader.html:4576,Availability,error,error,4576,"p() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; const vector<Float_t>&EvaluateMulticlass(const TString& methodTag, Double_t aux = 0); const vector<Float_t>&EvaluateMulticlass(TMVA::MethodBase* method, Double_t aux = 0); Float_tEvaluateMulticlass(UInt_t clsNumber, const TString& methodTag, Double_t aux = 0); Double_tEvaluateMVA(TMVA::MethodBase* method, Double_t aux = 0); Double_tEvaluateMVA(const TString& methodTag, Double_t aux = 0); Double_tEvaluateMVA(const vector<Float_t>&, const TString& methodTag, Double_t aux = 0); Double_tEvaluateMVA(const vector<Double_t>&, const TString& methodTag, Double_t aux = 0); const vector<Float_t>&EvaluateRegression(const TString& methodTag, Double_t aux = 0); const vector<Float_t>&EvaluateRegression(TMVA::MethodBase* method, Double_t aux = 0); Float_tEvaluateRegression(UInt_t tgtNumber, const TString& methodTag, Double_t aux = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TMVA::MethodCuts*FindCutsMVA(const TString& methodTag); TMVA::IMethod*FindMVA(const TString& methodTag); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Double_tGetMVAError() const; Double_tGetMVAErrorLower() const; Double_tGetMVAErrorUpper() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const ",MatchSource.WIKI,root/html604/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Reader.html
https://root.cern/root/html604/TMVA__Reader.html:4660,Availability,error,error,4660,"onst; const vector<Float_t>&EvaluateMulticlass(const TString& methodTag, Double_t aux = 0); const vector<Float_t>&EvaluateMulticlass(TMVA::MethodBase* method, Double_t aux = 0); Float_tEvaluateMulticlass(UInt_t clsNumber, const TString& methodTag, Double_t aux = 0); Double_tEvaluateMVA(TMVA::MethodBase* method, Double_t aux = 0); Double_tEvaluateMVA(const TString& methodTag, Double_t aux = 0); Double_tEvaluateMVA(const vector<Float_t>&, const TString& methodTag, Double_t aux = 0); Double_tEvaluateMVA(const vector<Double_t>&, const TString& methodTag, Double_t aux = 0); const vector<Float_t>&EvaluateRegression(const TString& methodTag, Double_t aux = 0); const vector<Float_t>&EvaluateRegression(TMVA::MethodBase* method, Double_t aux = 0); Float_tEvaluateRegression(UInt_t tgtNumber, const TString& methodTag, Double_t aux = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TMVA::MethodCuts*FindCutsMVA(const TString& methodTag); TMVA::IMethod*FindMVA(const TString& methodTag); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Double_tGetMVAError() const; Double_tGetMVAErrorLower() const; Double_tGetMVAErrorUpper() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TString&TMVA::Configurable::GetOptions() const; Double_tGetProba(const TString& meth",MatchSource.WIKI,root/html604/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Reader.html
https://root.cern/root/html604/TMVA__Reader.html:11299,Availability,error,error,11299,"ject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Bool_tfCalculateErrorerror calculation mode; Bool_tfColorcolor mode; TMVA::DataInputHandlerfDataInputHandler; TMVA::DataSetInfofDataSetInfothe data set; TMVA::DataSetManager*fDataSetManagerDSMTEST; TMVA::MsgLogger*fLoggermessage logger; map<TString,TMVA::IMethod*>fMethodMapmap of methods; Double_tfMvaEventErrorper-event error returned by MVA; Double_tfMvaEventErrorUpperper-event error returned by MVA; Bool_tfSilentsilent mode; vector<Float_t>fTmpEvalVectemporary evaluation vector (if user input is v<double>); Bool_tfVerboseverbosity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Reader(const TString& theOption = """", Bool_t verbose = 0); constructor. Reader(vector<TString>& varNames, const TString& theOption = """", Bool_t verbose = 0); constructor. Reader( std::vector<std::string>& inputVars, const TString& theOption, Bool_t verbose ); constructor. Reader( const std::string& varNames, const TString& theOption, Bool_t verbose ); constructor. Reader(const TString& varNames, const TString& theOption, Bool_t verbose = 0); constructor. void DeclareOptions(); declaration of configuration options. ~Reader( void ); destructor. void Init( void ); default initialisation (no member variables); default initialisation (",MatchSource.WIKI,root/html604/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Reader.html
https://root.cern/root/html604/TMVA__Reader.html:11359,Availability,error,error,11359,"ject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Bool_tfCalculateErrorerror calculation mode; Bool_tfColorcolor mode; TMVA::DataInputHandlerfDataInputHandler; TMVA::DataSetInfofDataSetInfothe data set; TMVA::DataSetManager*fDataSetManagerDSMTEST; TMVA::MsgLogger*fLoggermessage logger; map<TString,TMVA::IMethod*>fMethodMapmap of methods; Double_tfMvaEventErrorper-event error returned by MVA; Double_tfMvaEventErrorUpperper-event error returned by MVA; Bool_tfSilentsilent mode; vector<Float_t>fTmpEvalVectemporary evaluation vector (if user input is v<double>); Bool_tfVerboseverbosity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Reader(const TString& theOption = """", Bool_t verbose = 0); constructor. Reader(vector<TString>& varNames, const TString& theOption = """", Bool_t verbose = 0); constructor. Reader( std::vector<std::string>& inputVars, const TString& theOption, Bool_t verbose ); constructor. Reader( const std::string& varNames, const TString& theOption, Bool_t verbose ); constructor. Reader(const TString& varNames, const TString& theOption, Bool_t verbose = 0); constructor. void DeclareOptions(); declaration of configuration options. ~Reader( void ); destructor. void Init( void ); default initialisation (no member variables); default initialisation (",MatchSource.WIKI,root/html604/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Reader.html
https://root.cern/root/html604/TMVA__Reader.html:15709,Availability,error,error,15709,"r NaN in event data: (note: in the factory, this check was done already at the creation of the datasets, hence; it is not again checked in each of these subsequet calls.. Float_t EvaluateMulticlass(UInt_t clsNumber, const TString& methodTag, Double_t aux = 0); evaluates the multiclass MVA. TMVA::IMethod* FindMVA(const TString& methodTag); return pointer to method with tag ""methodTag"". TMVA::MethodCuts* FindCutsMVA(const TString& methodTag); special function for Cuts to avoid dynamic_casts in ROOT macros,; which are not properly handled by CINT. Double_t GetProba(const TString& methodTag, Double_t ap_sig = 0.5, Double_t mvaVal = -9999999); evaluates probability of MVA for given set of input variables. Double_t GetRarity(const TString& methodTag, Double_t mvaVal = -9999999); evaluates the MVA's rarity. void DecodeVarNames( const std::string& varNames ); decodes ""name1:name2:..."" form. void DecodeVarNames(const TString& varNames); decodes ""name1:name2:..."" form. Reader(const TString& theOption = """", Bool_t verbose = 0); without prior specification of variables. Double_t GetMVAError() const; returns error on MVA response for given event; NOTE: must be called AFTER ""EvaluateMVA(...)"" call !. { return fMvaEventError; }. Double_t GetMVAErrorLower() const; { return fMvaEventError; }. Double_t GetMVAErrorUpper() const; { return fMvaEventErrorUpper; }. const char* GetName() const; accessors. { return ""Reader""; }. Bool_t Verbose( void ); { return fVerbose; }. void SetVerbose(Bool_t v); { fVerbose = v; }. const DataSetInfo& DataInfo() const; { return fDataSetInfo; }. DataSetInfo& DataInfo(); { return fDataSetInfo; }. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Kai Voss, Eckhard von Toerne, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Reader.html
https://root.cern/root/html604/TMVA__Reader.html:12105,Deployability,configurat,configuration,12105,"aSetInfofDataSetInfothe data set; TMVA::DataSetManager*fDataSetManagerDSMTEST; TMVA::MsgLogger*fLoggermessage logger; map<TString,TMVA::IMethod*>fMethodMapmap of methods; Double_tfMvaEventErrorper-event error returned by MVA; Double_tfMvaEventErrorUpperper-event error returned by MVA; Bool_tfSilentsilent mode; vector<Float_t>fTmpEvalVectemporary evaluation vector (if user input is v<double>); Bool_tfVerboseverbosity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Reader(const TString& theOption = """", Bool_t verbose = 0); constructor. Reader(vector<TString>& varNames, const TString& theOption = """", Bool_t verbose = 0); constructor. Reader( std::vector<std::string>& inputVars, const TString& theOption, Bool_t verbose ); constructor. Reader( const std::string& varNames, const TString& theOption, Bool_t verbose ); constructor. Reader(const TString& varNames, const TString& theOption, Bool_t verbose = 0); constructor. void DeclareOptions(); declaration of configuration options. ~Reader( void ); destructor. void Init( void ); default initialisation (no member variables); default initialisation (no member variables). void AddVariable(const TString& expression, Float_t* ); Add a float variable or expression to the reader. void AddVariable(const TString& expression, Int_t* ). void AddSpectator(const TString& expression, Float_t* ); Add a float spectator or expression to the reader. void AddSpectator(const TString& expression, Int_t* ); Add an integer spectator or expression to the reader. TString GetMethodTypeFromFile(const TString& filename); read the method type from the file. TMVA::IMethod* BookMVA(const TString& methodTag, const TString& weightfile); read method name from weight file. TMVA::IMethod* BookMVA(TMVA::Types::EMVA method, const TString& weightfile); books MVA method from weightfile. TMVA::IMethod* BookMVA(TMVA::Types::EMVA methodType, const char* xmlstr). Double_t EvaluateMVA( const std::vector<Float_t>& inputVec, con",MatchSource.WIKI,root/html604/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Reader.html
https://root.cern/root/html604/TMVA__Reader.html:446,Modifiability,variab,variables,446,". TMVA::Reader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::Reader. class TMVA::Reader: public TMVA::Configurable. The Reader class serves to use the MVAs in a specific analysis context.; Within an event loop, a vector is filled that corresponds to the variables; that were used to train the MVA(s) during the training stage. This vector; is transfered to the Reader, who takes care of interpreting the weight; file of the MVA of choice, and to return the MVA's output. This is then; used by the user for further analysis. Usage:. // ------ before starting the event loop (eg, in the initialisation step). // create TMVA::Reader object. TMVA::Reader *reader = new TMVA::Reader();. // create a set of variables and declare them to the reader; // - the variable names must corresponds in name and type to; // those given in the weight file(s) that you use; Float_t var1, var2, var3, var4;; reader->AddVariable( ""var1"", &var1 );; reader->AddVariable( ""var2"", &var2 );; reader->AddVariable( ""var3"", &var3 );; reader->AddVariable( ""var4"", &var4 );. // book the MVA of your choice (prior training of these methods, ie,; // existence of the weight files is required); reader->BookMVA( ""Fisher method"", ""weights/Fisher.weights.txt"" );; reader->BookMVA( ""MLP method"", ""weights/MLP.weights.txt"" );; // ... etc. // ------- start your event loop. for (Long64_t ievt=0; ievt<myTree->GetEntries();ievt++) {. // fill vector with values of variables computed from those in the tree; var1 = myvar1;; var2 = myvar2;; var3 = myvar3;; var4 = myvar4;. // retrieve the corresponding MVA output; double mvaFi = reader->EvaluateMVA( ""Fisher method"" );; double mvaNN = reader->EvaluateMVA( ""MLP method"" );. // do something with these ...., e.g., fill them into your ntuple. } // end of event loop. delete reader;. An example applicat",MatchSource.WIKI,root/html604/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Reader.html
https://root.cern/root/html604/TMVA__Reader.html:893,Modifiability,variab,variables,893,"ex; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::Reader. class TMVA::Reader: public TMVA::Configurable. The Reader class serves to use the MVAs in a specific analysis context.; Within an event loop, a vector is filled that corresponds to the variables; that were used to train the MVA(s) during the training stage. This vector; is transfered to the Reader, who takes care of interpreting the weight; file of the MVA of choice, and to return the MVA's output. This is then; used by the user for further analysis. Usage:. // ------ before starting the event loop (eg, in the initialisation step). // create TMVA::Reader object. TMVA::Reader *reader = new TMVA::Reader();. // create a set of variables and declare them to the reader; // - the variable names must corresponds in name and type to; // those given in the weight file(s) that you use; Float_t var1, var2, var3, var4;; reader->AddVariable( ""var1"", &var1 );; reader->AddVariable( ""var2"", &var2 );; reader->AddVariable( ""var3"", &var3 );; reader->AddVariable( ""var4"", &var4 );. // book the MVA of your choice (prior training of these methods, ie,; // existence of the weight files is required); reader->BookMVA( ""Fisher method"", ""weights/Fisher.weights.txt"" );; reader->BookMVA( ""MLP method"", ""weights/MLP.weights.txt"" );; // ... etc. // ------- start your event loop. for (Long64_t ievt=0; ievt<myTree->GetEntries();ievt++) {. // fill vector with values of variables computed from those in the tree; var1 = myvar1;; var2 = myvar2;; var3 = myvar3;; var4 = myvar4;. // retrieve the corresponding MVA output; double mvaFi = reader->EvaluateMVA( ""Fisher method"" );; double mvaNN = reader->EvaluateMVA( ""MLP method"" );. // do something with these ...., e.g., fill them into your ntuple. } // end of event loop. delete reader;. An example application of the Reader can be found in TMVA/macros/TMVAppli",MatchSource.WIKI,root/html604/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Reader.html
https://root.cern/root/html604/TMVA__Reader.html:944,Modifiability,variab,variable,944,"ex; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::Reader. class TMVA::Reader: public TMVA::Configurable. The Reader class serves to use the MVAs in a specific analysis context.; Within an event loop, a vector is filled that corresponds to the variables; that were used to train the MVA(s) during the training stage. This vector; is transfered to the Reader, who takes care of interpreting the weight; file of the MVA of choice, and to return the MVA's output. This is then; used by the user for further analysis. Usage:. // ------ before starting the event loop (eg, in the initialisation step). // create TMVA::Reader object. TMVA::Reader *reader = new TMVA::Reader();. // create a set of variables and declare them to the reader; // - the variable names must corresponds in name and type to; // those given in the weight file(s) that you use; Float_t var1, var2, var3, var4;; reader->AddVariable( ""var1"", &var1 );; reader->AddVariable( ""var2"", &var2 );; reader->AddVariable( ""var3"", &var3 );; reader->AddVariable( ""var4"", &var4 );. // book the MVA of your choice (prior training of these methods, ie,; // existence of the weight files is required); reader->BookMVA( ""Fisher method"", ""weights/Fisher.weights.txt"" );; reader->BookMVA( ""MLP method"", ""weights/MLP.weights.txt"" );; // ... etc. // ------- start your event loop. for (Long64_t ievt=0; ievt<myTree->GetEntries();ievt++) {. // fill vector with values of variables computed from those in the tree; var1 = myvar1;; var2 = myvar2;; var3 = myvar3;; var4 = myvar4;. // retrieve the corresponding MVA output; double mvaFi = reader->EvaluateMVA( ""Fisher method"" );; double mvaNN = reader->EvaluateMVA( ""MLP method"" );. // do something with these ...., e.g., fill them into your ntuple. } // end of event loop. delete reader;. An example application of the Reader can be found in TMVA/macros/TMVAppli",MatchSource.WIKI,root/html604/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Reader.html
https://root.cern/root/html604/TMVA__Reader.html:1617,Modifiability,variab,variables,1617," output. This is then; used by the user for further analysis. Usage:. // ------ before starting the event loop (eg, in the initialisation step). // create TMVA::Reader object. TMVA::Reader *reader = new TMVA::Reader();. // create a set of variables and declare them to the reader; // - the variable names must corresponds in name and type to; // those given in the weight file(s) that you use; Float_t var1, var2, var3, var4;; reader->AddVariable( ""var1"", &var1 );; reader->AddVariable( ""var2"", &var2 );; reader->AddVariable( ""var3"", &var3 );; reader->AddVariable( ""var4"", &var4 );. // book the MVA of your choice (prior training of these methods, ie,; // existence of the weight files is required); reader->BookMVA( ""Fisher method"", ""weights/Fisher.weights.txt"" );; reader->BookMVA( ""MLP method"", ""weights/MLP.weights.txt"" );; // ... etc. // ------- start your event loop. for (Long64_t ievt=0; ievt<myTree->GetEntries();ievt++) {. // fill vector with values of variables computed from those in the tree; var1 = myvar1;; var2 = myvar2;; var3 = myvar3;; var4 = myvar4;. // retrieve the corresponding MVA output; double mvaFi = reader->EvaluateMVA( ""Fisher method"" );; double mvaNN = reader->EvaluateMVA( ""MLP method"" );. // do something with these ...., e.g., fill them into your ntuple. } // end of event loop. delete reader;. An example application of the Reader can be found in TMVA/macros/TMVApplication.C. Function Members (Methods); public:. virtual~Reader(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidAddSpectator(const TString& expression, Float_t*); voidAddSpectator(const TString& expression, Int_t*); voidAddVariable(const TString& expression, Float_t*); voidAddVariable(const TString& expression, Int_t*); virtual voidTObject::AppendPad(Option_t* option = """"); TMVA::IMethod*BookMVA(const TString& methodTag, const TString& weightfile); TMVA::IMethod*BookMVA(TMVA::Types::EMVA methodType, const char* xmlstr); v",MatchSource.WIKI,root/html604/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Reader.html
https://root.cern/root/html604/TMVA__Reader.html:12105,Modifiability,config,configuration,12105,"aSetInfofDataSetInfothe data set; TMVA::DataSetManager*fDataSetManagerDSMTEST; TMVA::MsgLogger*fLoggermessage logger; map<TString,TMVA::IMethod*>fMethodMapmap of methods; Double_tfMvaEventErrorper-event error returned by MVA; Double_tfMvaEventErrorUpperper-event error returned by MVA; Bool_tfSilentsilent mode; vector<Float_t>fTmpEvalVectemporary evaluation vector (if user input is v<double>); Bool_tfVerboseverbosity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Reader(const TString& theOption = """", Bool_t verbose = 0); constructor. Reader(vector<TString>& varNames, const TString& theOption = """", Bool_t verbose = 0); constructor. Reader( std::vector<std::string>& inputVars, const TString& theOption, Bool_t verbose ); constructor. Reader( const std::string& varNames, const TString& theOption, Bool_t verbose ); constructor. Reader(const TString& varNames, const TString& theOption, Bool_t verbose = 0); constructor. void DeclareOptions(); declaration of configuration options. ~Reader( void ); destructor. void Init( void ); default initialisation (no member variables); default initialisation (no member variables). void AddVariable(const TString& expression, Float_t* ); Add a float variable or expression to the reader. void AddVariable(const TString& expression, Int_t* ). void AddSpectator(const TString& expression, Float_t* ); Add a float spectator or expression to the reader. void AddSpectator(const TString& expression, Int_t* ); Add an integer spectator or expression to the reader. TString GetMethodTypeFromFile(const TString& filename); read the method type from the file. TMVA::IMethod* BookMVA(const TString& methodTag, const TString& weightfile); read method name from weight file. TMVA::IMethod* BookMVA(TMVA::Types::EMVA method, const TString& weightfile); books MVA method from weightfile. TMVA::IMethod* BookMVA(TMVA::Types::EMVA methodType, const char* xmlstr). Double_t EvaluateMVA( const std::vector<Float_t>& inputVec, con",MatchSource.WIKI,root/html604/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Reader.html
https://root.cern/root/html604/TMVA__Reader.html:12210,Modifiability,variab,variables,12210,"r; map<TString,TMVA::IMethod*>fMethodMapmap of methods; Double_tfMvaEventErrorper-event error returned by MVA; Double_tfMvaEventErrorUpperper-event error returned by MVA; Bool_tfSilentsilent mode; vector<Float_t>fTmpEvalVectemporary evaluation vector (if user input is v<double>); Bool_tfVerboseverbosity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Reader(const TString& theOption = """", Bool_t verbose = 0); constructor. Reader(vector<TString>& varNames, const TString& theOption = """", Bool_t verbose = 0); constructor. Reader( std::vector<std::string>& inputVars, const TString& theOption, Bool_t verbose ); constructor. Reader( const std::string& varNames, const TString& theOption, Bool_t verbose ); constructor. Reader(const TString& varNames, const TString& theOption, Bool_t verbose = 0); constructor. void DeclareOptions(); declaration of configuration options. ~Reader( void ); destructor. void Init( void ); default initialisation (no member variables); default initialisation (no member variables). void AddVariable(const TString& expression, Float_t* ); Add a float variable or expression to the reader. void AddVariable(const TString& expression, Int_t* ). void AddSpectator(const TString& expression, Float_t* ); Add a float spectator or expression to the reader. void AddSpectator(const TString& expression, Int_t* ); Add an integer spectator or expression to the reader. TString GetMethodTypeFromFile(const TString& filename); read the method type from the file. TMVA::IMethod* BookMVA(const TString& methodTag, const TString& weightfile); read method name from weight file. TMVA::IMethod* BookMVA(TMVA::Types::EMVA method, const TString& weightfile); books MVA method from weightfile. TMVA::IMethod* BookMVA(TMVA::Types::EMVA methodType, const char* xmlstr). Double_t EvaluateMVA( const std::vector<Float_t>& inputVec, const TString& methodTag, Double_t aux ); Evaluate a std::vector<float> of input data for a given method; The paramete",MatchSource.WIKI,root/html604/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Reader.html
https://root.cern/root/html604/TMVA__Reader.html:12256,Modifiability,variab,variables,12256,"r; map<TString,TMVA::IMethod*>fMethodMapmap of methods; Double_tfMvaEventErrorper-event error returned by MVA; Double_tfMvaEventErrorUpperper-event error returned by MVA; Bool_tfSilentsilent mode; vector<Float_t>fTmpEvalVectemporary evaluation vector (if user input is v<double>); Bool_tfVerboseverbosity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Reader(const TString& theOption = """", Bool_t verbose = 0); constructor. Reader(vector<TString>& varNames, const TString& theOption = """", Bool_t verbose = 0); constructor. Reader( std::vector<std::string>& inputVars, const TString& theOption, Bool_t verbose ); constructor. Reader( const std::string& varNames, const TString& theOption, Bool_t verbose ); constructor. Reader(const TString& varNames, const TString& theOption, Bool_t verbose = 0); constructor. void DeclareOptions(); declaration of configuration options. ~Reader( void ); destructor. void Init( void ); default initialisation (no member variables); default initialisation (no member variables). void AddVariable(const TString& expression, Float_t* ); Add a float variable or expression to the reader. void AddVariable(const TString& expression, Int_t* ). void AddSpectator(const TString& expression, Float_t* ); Add a float spectator or expression to the reader. void AddSpectator(const TString& expression, Int_t* ); Add an integer spectator or expression to the reader. TString GetMethodTypeFromFile(const TString& filename); read the method type from the file. TMVA::IMethod* BookMVA(const TString& methodTag, const TString& weightfile); read method name from weight file. TMVA::IMethod* BookMVA(TMVA::Types::EMVA method, const TString& weightfile); books MVA method from weightfile. TMVA::IMethod* BookMVA(TMVA::Types::EMVA methodType, const char* xmlstr). Double_t EvaluateMVA( const std::vector<Float_t>& inputVec, const TString& methodTag, Double_t aux ); Evaluate a std::vector<float> of input data for a given method; The paramete",MatchSource.WIKI,root/html604/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Reader.html
https://root.cern/root/html604/TMVA__Reader.html:12336,Modifiability,variab,variable,12336,"; Double_tfMvaEventErrorUpperper-event error returned by MVA; Bool_tfSilentsilent mode; vector<Float_t>fTmpEvalVectemporary evaluation vector (if user input is v<double>); Bool_tfVerboseverbosity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Reader(const TString& theOption = """", Bool_t verbose = 0); constructor. Reader(vector<TString>& varNames, const TString& theOption = """", Bool_t verbose = 0); constructor. Reader( std::vector<std::string>& inputVars, const TString& theOption, Bool_t verbose ); constructor. Reader( const std::string& varNames, const TString& theOption, Bool_t verbose ); constructor. Reader(const TString& varNames, const TString& theOption, Bool_t verbose = 0); constructor. void DeclareOptions(); declaration of configuration options. ~Reader( void ); destructor. void Init( void ); default initialisation (no member variables); default initialisation (no member variables). void AddVariable(const TString& expression, Float_t* ); Add a float variable or expression to the reader. void AddVariable(const TString& expression, Int_t* ). void AddSpectator(const TString& expression, Float_t* ); Add a float spectator or expression to the reader. void AddSpectator(const TString& expression, Int_t* ); Add an integer spectator or expression to the reader. TString GetMethodTypeFromFile(const TString& filename); read the method type from the file. TMVA::IMethod* BookMVA(const TString& methodTag, const TString& weightfile); read method name from weight file. TMVA::IMethod* BookMVA(TMVA::Types::EMVA method, const TString& weightfile); books MVA method from weightfile. TMVA::IMethod* BookMVA(TMVA::Types::EMVA methodType, const char* xmlstr). Double_t EvaluateMVA( const std::vector<Float_t>& inputVec, const TString& methodTag, Double_t aux ); Evaluate a std::vector<float> of input data for a given method; The parameter aux is obligatory for the cuts method where it represents the efficiency cutoff. Double_t EvaluateMVA( con",MatchSource.WIKI,root/html604/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Reader.html
https://root.cern/root/html604/TMVA__Reader.html:13661,Modifiability,variab,variables,13661,"r or expression to the reader. TString GetMethodTypeFromFile(const TString& filename); read the method type from the file. TMVA::IMethod* BookMVA(const TString& methodTag, const TString& weightfile); read method name from weight file. TMVA::IMethod* BookMVA(TMVA::Types::EMVA method, const TString& weightfile); books MVA method from weightfile. TMVA::IMethod* BookMVA(TMVA::Types::EMVA methodType, const char* xmlstr). Double_t EvaluateMVA( const std::vector<Float_t>& inputVec, const TString& methodTag, Double_t aux ); Evaluate a std::vector<float> of input data for a given method; The parameter aux is obligatory for the cuts method where it represents the efficiency cutoff. Double_t EvaluateMVA( const std::vector<Double_t>& inputVec, const TString& methodTag, Double_t aux ); Evaluate a std::vector<double> of input data for a given method; The parameter aux is obligatory for the cuts method where it represents the efficiency cutoff. Double_t EvaluateMVA(const TString& methodTag, Double_t aux = 0); evaluates MVA for given set of input variables. Double_t EvaluateMVA(TMVA::MethodBase* method, Double_t aux = 0); evaluates the MVA. const std::vector< Float_t >& EvaluateRegression(const TString& methodTag, Double_t aux = 0); evaluates MVA for given set of input variables. const std::vector< Float_t >& EvaluateRegression(TMVA::MethodBase* method, Double_t aux = 0); evaluates the regression MVA; check for NaN in event data: (note: in the factory, this check was done already at the creation of the datasets, hence; it is not again checked in each of these subsequet calls.. Float_t EvaluateRegression(UInt_t tgtNumber, const TString& methodTag, Double_t aux = 0); evaluates the regression MVA. const std::vector< Float_t >& EvaluateMulticlass(const TString& methodTag, Double_t aux = 0); evaluates MVA for given set of input variables. const std::vector< Float_t >& EvaluateMulticlass(TMVA::MethodBase* method, Double_t aux = 0); evaluates the multiclass MVA; check for NaN in event dat",MatchSource.WIKI,root/html604/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Reader.html
https://root.cern/root/html604/TMVA__Reader.html:13888,Modifiability,variab,variables,13888,"ame from weight file. TMVA::IMethod* BookMVA(TMVA::Types::EMVA method, const TString& weightfile); books MVA method from weightfile. TMVA::IMethod* BookMVA(TMVA::Types::EMVA methodType, const char* xmlstr). Double_t EvaluateMVA( const std::vector<Float_t>& inputVec, const TString& methodTag, Double_t aux ); Evaluate a std::vector<float> of input data for a given method; The parameter aux is obligatory for the cuts method where it represents the efficiency cutoff. Double_t EvaluateMVA( const std::vector<Double_t>& inputVec, const TString& methodTag, Double_t aux ); Evaluate a std::vector<double> of input data for a given method; The parameter aux is obligatory for the cuts method where it represents the efficiency cutoff. Double_t EvaluateMVA(const TString& methodTag, Double_t aux = 0); evaluates MVA for given set of input variables. Double_t EvaluateMVA(TMVA::MethodBase* method, Double_t aux = 0); evaluates the MVA. const std::vector< Float_t >& EvaluateRegression(const TString& methodTag, Double_t aux = 0); evaluates MVA for given set of input variables. const std::vector< Float_t >& EvaluateRegression(TMVA::MethodBase* method, Double_t aux = 0); evaluates the regression MVA; check for NaN in event data: (note: in the factory, this check was done already at the creation of the datasets, hence; it is not again checked in each of these subsequet calls.. Float_t EvaluateRegression(UInt_t tgtNumber, const TString& methodTag, Double_t aux = 0); evaluates the regression MVA. const std::vector< Float_t >& EvaluateMulticlass(const TString& methodTag, Double_t aux = 0); evaluates MVA for given set of input variables. const std::vector< Float_t >& EvaluateMulticlass(TMVA::MethodBase* method, Double_t aux = 0); evaluates the multiclass MVA; check for NaN in event data: (note: in the factory, this check was done already at the creation of the datasets, hence; it is not again checked in each of these subsequet calls.. Float_t EvaluateMulticlass(UInt_t clsNumber, const TString& ",MatchSource.WIKI,root/html604/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Reader.html
https://root.cern/root/html604/TMVA__Reader.html:14453,Modifiability,variab,variables,14453,"ux ); Evaluate a std::vector<double> of input data for a given method; The parameter aux is obligatory for the cuts method where it represents the efficiency cutoff. Double_t EvaluateMVA(const TString& methodTag, Double_t aux = 0); evaluates MVA for given set of input variables. Double_t EvaluateMVA(TMVA::MethodBase* method, Double_t aux = 0); evaluates the MVA. const std::vector< Float_t >& EvaluateRegression(const TString& methodTag, Double_t aux = 0); evaluates MVA for given set of input variables. const std::vector< Float_t >& EvaluateRegression(TMVA::MethodBase* method, Double_t aux = 0); evaluates the regression MVA; check for NaN in event data: (note: in the factory, this check was done already at the creation of the datasets, hence; it is not again checked in each of these subsequet calls.. Float_t EvaluateRegression(UInt_t tgtNumber, const TString& methodTag, Double_t aux = 0); evaluates the regression MVA. const std::vector< Float_t >& EvaluateMulticlass(const TString& methodTag, Double_t aux = 0); evaluates MVA for given set of input variables. const std::vector< Float_t >& EvaluateMulticlass(TMVA::MethodBase* method, Double_t aux = 0); evaluates the multiclass MVA; check for NaN in event data: (note: in the factory, this check was done already at the creation of the datasets, hence; it is not again checked in each of these subsequet calls.. Float_t EvaluateMulticlass(UInt_t clsNumber, const TString& methodTag, Double_t aux = 0); evaluates the multiclass MVA. TMVA::IMethod* FindMVA(const TString& methodTag); return pointer to method with tag ""methodTag"". TMVA::MethodCuts* FindCutsMVA(const TString& methodTag); special function for Cuts to avoid dynamic_casts in ROOT macros,; which are not properly handled by CINT. Double_t GetProba(const TString& methodTag, Double_t ap_sig = 0.5, Double_t mvaVal = -9999999); evaluates probability of MVA for given set of input variables. Double_t GetRarity(const TString& methodTag, Double_t mvaVal = -9999999); evaluates th",MatchSource.WIKI,root/html604/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Reader.html
https://root.cern/root/html604/TMVA__Reader.html:15295,Modifiability,variab,variables,15295,"ng& methodTag, Double_t aux = 0); evaluates the regression MVA. const std::vector< Float_t >& EvaluateMulticlass(const TString& methodTag, Double_t aux = 0); evaluates MVA for given set of input variables. const std::vector< Float_t >& EvaluateMulticlass(TMVA::MethodBase* method, Double_t aux = 0); evaluates the multiclass MVA; check for NaN in event data: (note: in the factory, this check was done already at the creation of the datasets, hence; it is not again checked in each of these subsequet calls.. Float_t EvaluateMulticlass(UInt_t clsNumber, const TString& methodTag, Double_t aux = 0); evaluates the multiclass MVA. TMVA::IMethod* FindMVA(const TString& methodTag); return pointer to method with tag ""methodTag"". TMVA::MethodCuts* FindCutsMVA(const TString& methodTag); special function for Cuts to avoid dynamic_casts in ROOT macros,; which are not properly handled by CINT. Double_t GetProba(const TString& methodTag, Double_t ap_sig = 0.5, Double_t mvaVal = -9999999); evaluates probability of MVA for given set of input variables. Double_t GetRarity(const TString& methodTag, Double_t mvaVal = -9999999); evaluates the MVA's rarity. void DecodeVarNames( const std::string& varNames ); decodes ""name1:name2:..."" form. void DecodeVarNames(const TString& varNames); decodes ""name1:name2:..."" form. Reader(const TString& theOption = """", Bool_t verbose = 0); without prior specification of variables. Double_t GetMVAError() const; returns error on MVA response for given event; NOTE: must be called AFTER ""EvaluateMVA(...)"" call !. { return fMvaEventError; }. Double_t GetMVAErrorLower() const; { return fMvaEventError; }. Double_t GetMVAErrorUpper() const; { return fMvaEventErrorUpper; }. const char* GetName() const; accessors. { return ""Reader""; }. Bool_t Verbose( void ); { return fVerbose; }. void SetVerbose(Bool_t v); { fVerbose = v; }. const DataSetInfo& DataInfo() const; { return fDataSetInfo; }. DataSetInfo& DataInfo(); { return fDataSetInfo; }. » Author: Andreas Hoecker, Pe",MatchSource.WIKI,root/html604/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Reader.html
https://root.cern/root/html604/TMVA__Reader.html:15660,Modifiability,variab,variables,15660,"r NaN in event data: (note: in the factory, this check was done already at the creation of the datasets, hence; it is not again checked in each of these subsequet calls.. Float_t EvaluateMulticlass(UInt_t clsNumber, const TString& methodTag, Double_t aux = 0); evaluates the multiclass MVA. TMVA::IMethod* FindMVA(const TString& methodTag); return pointer to method with tag ""methodTag"". TMVA::MethodCuts* FindCutsMVA(const TString& methodTag); special function for Cuts to avoid dynamic_casts in ROOT macros,; which are not properly handled by CINT. Double_t GetProba(const TString& methodTag, Double_t ap_sig = 0.5, Double_t mvaVal = -9999999); evaluates probability of MVA for given set of input variables. Double_t GetRarity(const TString& methodTag, Double_t mvaVal = -9999999); evaluates the MVA's rarity. void DecodeVarNames( const std::string& varNames ); decodes ""name1:name2:..."" form. void DecodeVarNames(const TString& varNames); decodes ""name1:name2:..."" form. Reader(const TString& theOption = """", Bool_t verbose = 0); without prior specification of variables. Double_t GetMVAError() const; returns error on MVA response for given event; NOTE: must be called AFTER ""EvaluateMVA(...)"" call !. { return fMvaEventError; }. Double_t GetMVAErrorLower() const; { return fMvaEventError; }. Double_t GetMVAErrorUpper() const; { return fMvaEventErrorUpper; }. const char* GetName() const; accessors. { return ""Reader""; }. Bool_t Verbose( void ); { return fVerbose; }. void SetVerbose(Bool_t v); { fVerbose = v; }. const DataSetInfo& DataInfo() const; { return fDataSetInfo; }. DataSetInfo& DataInfo(); { return fDataSetInfo; }. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Kai Voss, Eckhard von Toerne, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Reader.html
https://root.cern/root/html604/TMVA__Reader.html:15070,Safety,avoid,avoid,15070,"e factory, this check was done already at the creation of the datasets, hence; it is not again checked in each of these subsequet calls.. Float_t EvaluateRegression(UInt_t tgtNumber, const TString& methodTag, Double_t aux = 0); evaluates the regression MVA. const std::vector< Float_t >& EvaluateMulticlass(const TString& methodTag, Double_t aux = 0); evaluates MVA for given set of input variables. const std::vector< Float_t >& EvaluateMulticlass(TMVA::MethodBase* method, Double_t aux = 0); evaluates the multiclass MVA; check for NaN in event data: (note: in the factory, this check was done already at the creation of the datasets, hence; it is not again checked in each of these subsequet calls.. Float_t EvaluateMulticlass(UInt_t clsNumber, const TString& methodTag, Double_t aux = 0); evaluates the multiclass MVA. TMVA::IMethod* FindMVA(const TString& methodTag); return pointer to method with tag ""methodTag"". TMVA::MethodCuts* FindCutsMVA(const TString& methodTag); special function for Cuts to avoid dynamic_casts in ROOT macros,; which are not properly handled by CINT. Double_t GetProba(const TString& methodTag, Double_t ap_sig = 0.5, Double_t mvaVal = -9999999); evaluates probability of MVA for given set of input variables. Double_t GetRarity(const TString& methodTag, Double_t mvaVal = -9999999); evaluates the MVA's rarity. void DecodeVarNames( const std::string& varNames ); decodes ""name1:name2:..."" form. void DecodeVarNames(const TString& varNames); decodes ""name1:name2:..."" form. Reader(const TString& theOption = """", Bool_t verbose = 0); without prior specification of variables. Double_t GetMVAError() const; returns error on MVA response for given event; NOTE: must be called AFTER ""EvaluateMVA(...)"" call !. { return fMvaEventError; }. Double_t GetMVAErrorLower() const; { return fMvaEventError; }. Double_t GetMVAErrorUpper() const; { return fMvaEventErrorUpper; }. const char* GetName() const; accessors. { return ""Reader""; }. Bool_t Verbose( void ); { return fVerbose;",MatchSource.WIKI,root/html604/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Reader.html
https://root.cern/root/html604/TMVA__Reader.html:15990,Security,access,accessors,15990,"r NaN in event data: (note: in the factory, this check was done already at the creation of the datasets, hence; it is not again checked in each of these subsequet calls.. Float_t EvaluateMulticlass(UInt_t clsNumber, const TString& methodTag, Double_t aux = 0); evaluates the multiclass MVA. TMVA::IMethod* FindMVA(const TString& methodTag); return pointer to method with tag ""methodTag"". TMVA::MethodCuts* FindCutsMVA(const TString& methodTag); special function for Cuts to avoid dynamic_casts in ROOT macros,; which are not properly handled by CINT. Double_t GetProba(const TString& methodTag, Double_t ap_sig = 0.5, Double_t mvaVal = -9999999); evaluates probability of MVA for given set of input variables. Double_t GetRarity(const TString& methodTag, Double_t mvaVal = -9999999); evaluates the MVA's rarity. void DecodeVarNames( const std::string& varNames ); decodes ""name1:name2:..."" form. void DecodeVarNames(const TString& varNames); decodes ""name1:name2:..."" form. Reader(const TString& theOption = """", Bool_t verbose = 0); without prior specification of variables. Double_t GetMVAError() const; returns error on MVA response for given event; NOTE: must be called AFTER ""EvaluateMVA(...)"" call !. { return fMvaEventError; }. Double_t GetMVAErrorLower() const; { return fMvaEventError; }. Double_t GetMVAErrorUpper() const; { return fMvaEventErrorUpper; }. const char* GetName() const; accessors. { return ""Reader""; }. Bool_t Verbose( void ); { return fVerbose; }. void SetVerbose(Bool_t v); { fVerbose = v; }. const DataSetInfo& DataInfo() const; { return fDataSetInfo; }. DataSetInfo& DataInfo(); { return fDataSetInfo; }. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Kai Voss, Eckhard von Toerne, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Reader.html
https://root.cern/root/html604/TMVA__Reader.html:11206,Testability,log,logger,11206,"ject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Bool_tfCalculateErrorerror calculation mode; Bool_tfColorcolor mode; TMVA::DataInputHandlerfDataInputHandler; TMVA::DataSetInfofDataSetInfothe data set; TMVA::DataSetManager*fDataSetManagerDSMTEST; TMVA::MsgLogger*fLoggermessage logger; map<TString,TMVA::IMethod*>fMethodMapmap of methods; Double_tfMvaEventErrorper-event error returned by MVA; Double_tfMvaEventErrorUpperper-event error returned by MVA; Bool_tfSilentsilent mode; vector<Float_t>fTmpEvalVectemporary evaluation vector (if user input is v<double>); Bool_tfVerboseverbosity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Reader(const TString& theOption = """", Bool_t verbose = 0); constructor. Reader(vector<TString>& varNames, const TString& theOption = """", Bool_t verbose = 0); constructor. Reader( std::vector<std::string>& inputVars, const TString& theOption, Bool_t verbose ); constructor. Reader( const std::string& varNames, const TString& theOption, Bool_t verbose ); constructor. Reader(const TString& varNames, const TString& theOption, Bool_t verbose = 0); constructor. void DeclareOptions(); declaration of configuration options. ~Reader( void ); destructor. void Init( void ); default initialisation (no member variables); default initialisation (",MatchSource.WIKI,root/html604/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Reader.html
https://root.cern/root/html604/TMVA__RegressionVariance.html:1717,Performance,optimiz,optimized,1717,"A::RegressionVariance&operator=(const TMVA::RegressionVariance&); TMVA::RegressionVarianceRegressionVariance(); TMVA::RegressionVarianceRegressionVariance(const TMVA::RegressionVariance& s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationGain(const Double_t& nLeft, const Double_t& targetLeft, const Double_t& target2Left, const Double_t& nTot, const Double_t& targetTot, const Double_t& target2Tot); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system; for the Regression: as the ""Gain is maximised"", the RMS (sqrt(variance)); which is used as a ""separation"" index should be as small as possible.; the ""figure of merit"" here has to be -(rms left+rms-right) or 1/rms... Double_t GetSeparationIndex(const Double_t& n, const Double_t& target, const Double_t& target2); Separation Index: a simple Variance. RegressionVariance(); default constructor. {fName = ""Variance for Regression"";}. RegressionVariance(const TMVA::RegressionVariance& s); copy constructor. {}. virtual ~RegressionVariance(); destructor. {}. TString GetName(); Return the name of the concrete Index implementation. { return fName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__RegressionVariance.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RegressionVariance.html
https://root.cern/root/html604/TMVA__RegressionVariance.html:2120,Usability,simpl,simple,2120,"A::RegressionVariance&operator=(const TMVA::RegressionVariance&); TMVA::RegressionVarianceRegressionVariance(); TMVA::RegressionVarianceRegressionVariance(const TMVA::RegressionVariance& s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationGain(const Double_t& nLeft, const Double_t& targetLeft, const Double_t& target2Left, const Double_t& nTot, const Double_t& targetTot, const Double_t& target2Tot); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system; for the Regression: as the ""Gain is maximised"", the RMS (sqrt(variance)); which is used as a ""separation"" index should be as small as possible.; the ""figure of merit"" here has to be -(rms left+rms-right) or 1/rms... Double_t GetSeparationIndex(const Double_t& n, const Double_t& target, const Double_t& target2); Separation Index: a simple Variance. RegressionVariance(); default constructor. {fName = ""Variance for Regression"";}. RegressionVariance(const TMVA::RegressionVariance& s); copy constructor. {}. virtual ~RegressionVariance(); destructor. {}. TString GetName(); Return the name of the concrete Index implementation. { return fName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__RegressionVariance.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RegressionVariance.html
https://root.cern/root/html604/TMVA__ROCCalc.html:949,Availability,toler,tolerance,949,"_tGetEffSForEffBof(Double_t effBref, Double_t& effSerr); TH1*GetMvaBpdf(); TH1*GetMvaSpdf(); TH1*GetPurity(Int_t nStot, Int_t nBtot); TH1D*GetROC(); Double_tGetROCIntegral(); Double_tGetSignalReferenceCut(); TH1*GetSignificance(Int_t nStot, Int_t nBtot); TMVA::ROCCalc&operator=(const TMVA::ROCCalc&); TMVA::ROCCalcROCCalc(const TMVA::ROCCalc&); TMVA::ROCCalcROCCalc(TH1* mvaS, TH1* mvaB). private:. Double_tGetEffForRoot(Double_t theCut); TMVA::MsgLogger&Log() const; Double_tRoot(Double_t). Data Members; private:. Double_tfAbsTolabsolute tolerance deviation; Int_tfCutOrientation+1 if larger mva value means more signal like, -1 otherwise; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxItermaximum number of iterations; UInt_tfNbins; Double_tfNevtSnumber of signal events (used in error calculation); TH1*fPurity; Double_tfSignalCutMVA cut value for last demanded background rejection or signal efficiency; TH1*fSignificance; TSpline*fSplB; TSpline*fSplS; TSpline*fSpleffBvsS; TSpline*fSplmvaCumBspline of cumulated mva distributions; TSpline*fSplmvaCumSspline of cumulated mva distributions; Bool_tfUseSplines; Float_tfXmaxmin and max of the mva distribution; Float_tfXminmin and max of the mva distribution; TH1*fmvaBthe input mva distributions; TH1*fmvaBcumul; TH1*fmvaBpdfthe normalized (and rebinned) input mva distributions; TH1*fmvaSthe input mva distributions; TH1*fmvaScumul; TH1*fmvaSpdfthe normalized (and rebinned) input mva distributions; Int_tfnBtot; Int_tfnStot. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ROCCalc(TH1* mvaS, TH1* mvaB). void ApplySignalAndBackgroundStyle(TH1* sig, TH1* bkg, TH1* any = 0); Int_t c_Canvas = TColor::GetColor( ""#f0f0f0"" );; Int_t c_FrameFill = TColor::GetColor( ""#fffffd"" );; Int_t c_TitleBox = TColor::GetColor( ""#5D6B7D"" );; Int_t c_TitleBorder = TColor::GetColor( ""#7D8B9D"" );; Int_t c_TitleText = TColor::GetColor( ""#FFFFFF"" );. ~ROCCalc(); destructor. TH1D* GetROC(); get the ROC curve. Double",MatchSource.WIKI,root/html604/TMVA__ROCCalc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__ROCCalc.html
https://root.cern/root/html604/TMVA__ROCCalc.html:1196,Availability,error,error,1196,"_tGetEffSForEffBof(Double_t effBref, Double_t& effSerr); TH1*GetMvaBpdf(); TH1*GetMvaSpdf(); TH1*GetPurity(Int_t nStot, Int_t nBtot); TH1D*GetROC(); Double_tGetROCIntegral(); Double_tGetSignalReferenceCut(); TH1*GetSignificance(Int_t nStot, Int_t nBtot); TMVA::ROCCalc&operator=(const TMVA::ROCCalc&); TMVA::ROCCalcROCCalc(const TMVA::ROCCalc&); TMVA::ROCCalcROCCalc(TH1* mvaS, TH1* mvaB). private:. Double_tGetEffForRoot(Double_t theCut); TMVA::MsgLogger&Log() const; Double_tRoot(Double_t). Data Members; private:. Double_tfAbsTolabsolute tolerance deviation; Int_tfCutOrientation+1 if larger mva value means more signal like, -1 otherwise; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxItermaximum number of iterations; UInt_tfNbins; Double_tfNevtSnumber of signal events (used in error calculation); TH1*fPurity; Double_tfSignalCutMVA cut value for last demanded background rejection or signal efficiency; TH1*fSignificance; TSpline*fSplB; TSpline*fSplS; TSpline*fSpleffBvsS; TSpline*fSplmvaCumBspline of cumulated mva distributions; TSpline*fSplmvaCumSspline of cumulated mva distributions; Bool_tfUseSplines; Float_tfXmaxmin and max of the mva distribution; Float_tfXminmin and max of the mva distribution; TH1*fmvaBthe input mva distributions; TH1*fmvaBcumul; TH1*fmvaBpdfthe normalized (and rebinned) input mva distributions; TH1*fmvaSthe input mva distributions; TH1*fmvaScumul; TH1*fmvaSpdfthe normalized (and rebinned) input mva distributions; Int_tfnBtot; Int_tfnStot. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ROCCalc(TH1* mvaS, TH1* mvaB). void ApplySignalAndBackgroundStyle(TH1* sig, TH1* bkg, TH1* any = 0); Int_t c_Canvas = TColor::GetColor( ""#f0f0f0"" );; Int_t c_FrameFill = TColor::GetColor( ""#fffffd"" );; Int_t c_TitleBox = TColor::GetColor( ""#5D6B7D"" );; Int_t c_TitleBorder = TColor::GetColor( ""#7D8B9D"" );; Int_t c_TitleText = TColor::GetColor( ""#FFFFFF"" );. ~ROCCalc(); destructor. TH1D* GetROC(); get the ROC curve. Double",MatchSource.WIKI,root/html604/TMVA__ROCCalc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__ROCCalc.html
https://root.cern/root/html604/TMVA__ROCCalc.html:1076,Integrability,message,message,1076,"_tGetEffSForEffBof(Double_t effBref, Double_t& effSerr); TH1*GetMvaBpdf(); TH1*GetMvaSpdf(); TH1*GetPurity(Int_t nStot, Int_t nBtot); TH1D*GetROC(); Double_tGetROCIntegral(); Double_tGetSignalReferenceCut(); TH1*GetSignificance(Int_t nStot, Int_t nBtot); TMVA::ROCCalc&operator=(const TMVA::ROCCalc&); TMVA::ROCCalcROCCalc(const TMVA::ROCCalc&); TMVA::ROCCalcROCCalc(TH1* mvaS, TH1* mvaB). private:. Double_tGetEffForRoot(Double_t theCut); TMVA::MsgLogger&Log() const; Double_tRoot(Double_t). Data Members; private:. Double_tfAbsTolabsolute tolerance deviation; Int_tfCutOrientation+1 if larger mva value means more signal like, -1 otherwise; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxItermaximum number of iterations; UInt_tfNbins; Double_tfNevtSnumber of signal events (used in error calculation); TH1*fPurity; Double_tfSignalCutMVA cut value for last demanded background rejection or signal efficiency; TH1*fSignificance; TSpline*fSplB; TSpline*fSplS; TSpline*fSpleffBvsS; TSpline*fSplmvaCumBspline of cumulated mva distributions; TSpline*fSplmvaCumSspline of cumulated mva distributions; Bool_tfUseSplines; Float_tfXmaxmin and max of the mva distribution; Float_tfXminmin and max of the mva distribution; TH1*fmvaBthe input mva distributions; TH1*fmvaBcumul; TH1*fmvaBpdfthe normalized (and rebinned) input mva distributions; TH1*fmvaSthe input mva distributions; TH1*fmvaScumul; TH1*fmvaSpdfthe normalized (and rebinned) input mva distributions; Int_tfnBtot; Int_tfnStot. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ROCCalc(TH1* mvaS, TH1* mvaB). void ApplySignalAndBackgroundStyle(TH1* sig, TH1* bkg, TH1* any = 0); Int_t c_Canvas = TColor::GetColor( ""#f0f0f0"" );; Int_t c_FrameFill = TColor::GetColor( ""#fffffd"" );; Int_t c_TitleBox = TColor::GetColor( ""#5D6B7D"" );; Int_t c_TitleBorder = TColor::GetColor( ""#7D8B9D"" );; Int_t c_TitleText = TColor::GetColor( ""#FFFFFF"" );. ~ROCCalc(); destructor. TH1D* GetROC(); get the ROC curve. Double",MatchSource.WIKI,root/html604/TMVA__ROCCalc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__ROCCalc.html
https://root.cern/root/html604/TMVA__ROCCalc.html:1084,Testability,log,logger,1084,"_tGetEffSForEffBof(Double_t effBref, Double_t& effSerr); TH1*GetMvaBpdf(); TH1*GetMvaSpdf(); TH1*GetPurity(Int_t nStot, Int_t nBtot); TH1D*GetROC(); Double_tGetROCIntegral(); Double_tGetSignalReferenceCut(); TH1*GetSignificance(Int_t nStot, Int_t nBtot); TMVA::ROCCalc&operator=(const TMVA::ROCCalc&); TMVA::ROCCalcROCCalc(const TMVA::ROCCalc&); TMVA::ROCCalcROCCalc(TH1* mvaS, TH1* mvaB). private:. Double_tGetEffForRoot(Double_t theCut); TMVA::MsgLogger&Log() const; Double_tRoot(Double_t). Data Members; private:. Double_tfAbsTolabsolute tolerance deviation; Int_tfCutOrientation+1 if larger mva value means more signal like, -1 otherwise; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxItermaximum number of iterations; UInt_tfNbins; Double_tfNevtSnumber of signal events (used in error calculation); TH1*fPurity; Double_tfSignalCutMVA cut value for last demanded background rejection or signal efficiency; TH1*fSignificance; TSpline*fSplB; TSpline*fSplS; TSpline*fSpleffBvsS; TSpline*fSplmvaCumBspline of cumulated mva distributions; TSpline*fSplmvaCumSspline of cumulated mva distributions; Bool_tfUseSplines; Float_tfXmaxmin and max of the mva distribution; Float_tfXminmin and max of the mva distribution; TH1*fmvaBthe input mva distributions; TH1*fmvaBcumul; TH1*fmvaBpdfthe normalized (and rebinned) input mva distributions; TH1*fmvaSthe input mva distributions; TH1*fmvaScumul; TH1*fmvaSpdfthe normalized (and rebinned) input mva distributions; Int_tfnBtot; Int_tfnStot. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ROCCalc(TH1* mvaS, TH1* mvaB). void ApplySignalAndBackgroundStyle(TH1* sig, TH1* bkg, TH1* any = 0); Int_t c_Canvas = TColor::GetColor( ""#f0f0f0"" );; Int_t c_FrameFill = TColor::GetColor( ""#fffffd"" );; Int_t c_TitleBox = TColor::GetColor( ""#5D6B7D"" );; Int_t c_TitleBorder = TColor::GetColor( ""#7D8B9D"" );; Int_t c_TitleText = TColor::GetColor( ""#FFFFFF"" );. ~ROCCalc(); destructor. TH1D* GetROC(); get the ROC curve. Double",MatchSource.WIKI,root/html604/TMVA__ROCCalc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__ROCCalc.html
https://root.cern/root/html604/TMVA__RootFinder.html:1942,Availability,error,error,1942," virtual~RootFinder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, T",MatchSource.WIKI,root/html604/TMVA__RootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RootFinder.html
https://root.cern/root/html604/TMVA__RootFinder.html:2026,Availability,error,error,2026," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html604/TMVA__RootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RootFinder.html
https://root.cern/root/html604/TMVA__RootFinder.html:6489,Availability,toler,tolerance,6489,"ct::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMVA::MsgLogger&Log() const. Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Double_tfAbsTolabsolute tolerance deviation; Double_t(*)(Double_t)fGetRootVal; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxItermaximum number of iterations; Double_tfRootMaxmaximum root value; Double_tfRootMinminimum root value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RootFinder(const TMVA::RootFinder& ). Construct a Root-Finder algorithm. virtual ~RootFinder(). RootFinder(const TMVA::RootFinder& ); usually copying is non trivial, so we make this unaccessible. {}. double Root(). Return the current and latest estimate of the Root. » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__RootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RootFinder.html
https://root.cern/root/html604/TMVA__RootFinder.html:6569,Integrability,message,message,6569,"ct::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMVA::MsgLogger&Log() const. Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Double_tfAbsTolabsolute tolerance deviation; Double_t(*)(Double_t)fGetRootVal; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxItermaximum number of iterations; Double_tfRootMaxmaximum root value; Double_tfRootMinminimum root value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RootFinder(const TMVA::RootFinder& ). Construct a Root-Finder algorithm. virtual ~RootFinder(). RootFinder(const TMVA::RootFinder& ); usually copying is non trivial, so we make this unaccessible. {}. double Root(). Return the current and latest estimate of the Root. » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__RootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RootFinder.html
https://root.cern/root/html604/TMVA__RootFinder.html:435,Modifiability,plug-in,plug-in,435,". TMVA::RootFinder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TMVA::RootFinder. class TMVA::RootFinder: public TObject. User Class to find the Root of one dimensional functions.; The GSL Methods are implemented in MathMore and they are loaded automatically; via the plug-in manager. The possible types of Root-finding algorithms are:; <ul>; <li>Root Bracketing Algorithms which do not require function derivatives; <ol>; <li>RootFinder::kBRENT (default method implemented in MathCore); <li>RootFinder::kGSL_BISECTION; <li>RootFinder::kGSL_FALSE_POS; <li>RootFinder::kGSL_BRENT; </ol>; <li>Root Finding Algorithms using Derivatives; <ol>; <li>RootFinder::kGSL_NEWTON; <li>RootFinder::kGSL_SECANT; <li>RootFinder::kGSL_STEFFENSON; </ol>; </ul>. This class does not cupport copying. @ingroup RootFinders. Function Members (Methods); public:. virtual~RootFinder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, T",MatchSource.WIKI,root/html604/TMVA__RootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RootFinder.html
https://root.cern/root/html604/TMVA__RootFinder.html:405,Performance,load,loaded,405,". TMVA::RootFinder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TMVA::RootFinder. class TMVA::RootFinder: public TObject. User Class to find the Root of one dimensional functions.; The GSL Methods are implemented in MathMore and they are loaded automatically; via the plug-in manager. The possible types of Root-finding algorithms are:; <ul>; <li>Root Bracketing Algorithms which do not require function derivatives; <ol>; <li>RootFinder::kBRENT (default method implemented in MathCore); <li>RootFinder::kGSL_BISECTION; <li>RootFinder::kGSL_FALSE_POS; <li>RootFinder::kGSL_BRENT; </ol>; <li>Root Finding Algorithms using Derivatives; <ol>; <li>RootFinder::kGSL_NEWTON; <li>RootFinder::kGSL_SECANT; <li>RootFinder::kGSL_STEFFENSON; </ol>; </ul>. This class does not cupport copying. @ingroup RootFinders. Function Members (Methods); public:. virtual~RootFinder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, T",MatchSource.WIKI,root/html604/TMVA__RootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RootFinder.html
https://root.cern/root/html604/TMVA__RootFinder.html:6577,Testability,log,logger,6577,"ct::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMVA::MsgLogger&Log() const. Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Double_tfAbsTolabsolute tolerance deviation; Double_t(*)(Double_t)fGetRootVal; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxItermaximum number of iterations; Double_tfRootMaxmaximum root value; Double_tfRootMinminimum root value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RootFinder(const TMVA::RootFinder& ). Construct a Root-Finder algorithm. virtual ~RootFinder(). RootFinder(const TMVA::RootFinder& ); usually copying is non trivial, so we make this unaccessible. {}. double Root(). Return the current and latest estimate of the Root. » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__RootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RootFinder.html
https://root.cern/root/html604/TMVA__RuleFit.html:4518,Integrability,message,message,4518,"aining events; vector<const TMVA::Event*>fTrainingEventsRndmidem, but randomly shuffled; Bool_tfVisHistsUseImpif true, use importance as weight; else coef in vis hists; static const Int_trandSEEDset to 1 for debugging purposes or to zero for random seeds. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RuleFit( const MethodBase *rfbase ); constructor. RuleFit(); default constructor. ~RuleFit(); destructor. void InitNEveEff(); init effective number of events (using event weights). void InitPtrs(const TMVA::MethodBase* rfbase); initialize pointers. void Initialize(const TMVA::MethodBase* rfbase); initialize the parameters of the RuleFit method and make rules. void SetMethodBase(const TMVA::MethodBase* rfbase); set MethodBase. void Copy(const TMVA::RuleFit& other); copy method. Double_t CalcWeightSum(const vector<const TMVA::Event*>* events, UInt_t neve = 0); calculate the sum of weights. void SetMsgType(TMVA::EMsgType t); set the current message type to that of mlog for this class and all other subtools. void BuildTree(TMVA::DecisionTree* dt); build the decision tree using fNTreeSample events from fTrainingEventsRndm. void MakeForest(); make a forest of decisiontrees. void SaveEventWeights(); save event weights - must be done before making the forest. void RestoreEventWeights(); save event weights - must be done before making the forest. void Boost(TMVA::DecisionTree* dt); Boost the events. The algorithm below is the called AdaBoost.; See MethodBDT for details.; Actually, this is a more or less copy of MethodBDT::AdaBoost(). void ForestStatistics(); summary of statistics of all trees; * end-nodes: average and spread. void FitCoefficients(). Fit the coefficients for the rule ensemble. void CalcImportance(); calculates the importance of each rule. Double_t EvalEvent(const TMVA::Event& e); evaluate single event. void SetTrainingEvents(const vector<const TMVA::Event*>& el); set the training events randomly. void GetRndmSampleEvent",MatchSource.WIKI,root/html604/TMVA__RuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RuleFit.html
https://root.cern/root/html604/TMVA__RuleFit.html:6216,Integrability,rout,routine,6216,"read. void FitCoefficients(). Fit the coefficients for the rule ensemble. void CalcImportance(); calculates the importance of each rule. Double_t EvalEvent(const TMVA::Event& e); evaluate single event. void SetTrainingEvents(const vector<const TMVA::Event*>& el); set the training events randomly. void GetRndmSampleEvents(vector<const TMVA::Event*>& evevec, UInt_t nevents); draw a random subsample of the training events without replacement. void NormVisHists(vector<TH2F*>& hlist); normalize rule importance hists. if all weights are positive, the scale will be 1/maxweight; if minimum weight < 0, then the scale will be 1/max(maxweight,abs(minweight)). void FillCut(TH2F* h2, const TMVA::Rule* rule, Int_t vind); Fill cut. void FillLin(TH2F* h2, Int_t vind); fill lin. void FillCorr(TH2F* h2, const TMVA::Rule* rule, Int_t v1, Int_t v2); fill rule correlation between vx and vy, weighted with either the importance or the coefficient. void FillVisHistCut(const TMVA::Rule* rule, vector<TH2F*>& hlist); help routine to MakeVisHists() - fills for all variables. void FillVisHistCorr(const TMVA::Rule* rule, vector<TH2F*>& hlist); help routine to MakeVisHists() - fills for all correlation plots. Bool_t GetCorrVars(TString& title, TString& var1, TString& var2); get first and second variables from title. void MakeVisHists(); this will create histograms visualizing the rule ensemble. void MakeDebugHists(); this will create a histograms intended rather for debugging or for the curious user. RuleFit(const TMVA::MethodBase* rfbase); main constructor. void ReshuffleEvents(); { std::random_shuffle(fTrainingEventsRndm.begin(),fTrainingEventsRndm.end()); }. void SetModelLinear(); set usage of linear term. { fRuleEnsemble.SetModelLinear(); }. void SetModelRules(); set usage of rules. { fRuleEnsemble.SetModelRules(); }. void SetModelFull(); set usage of linear term. { fRuleEnsemble.SetModelFull(); }. void SetImportanceCut(Double_t minimp = 0); set minimum importance allowed. { fRuleEnsemble.SetI",MatchSource.WIKI,root/html604/TMVA__RuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RuleFit.html
https://root.cern/root/html604/TMVA__RuleFit.html:6342,Integrability,rout,routine,6342," rule. Double_t EvalEvent(const TMVA::Event& e); evaluate single event. void SetTrainingEvents(const vector<const TMVA::Event*>& el); set the training events randomly. void GetRndmSampleEvents(vector<const TMVA::Event*>& evevec, UInt_t nevents); draw a random subsample of the training events without replacement. void NormVisHists(vector<TH2F*>& hlist); normalize rule importance hists. if all weights are positive, the scale will be 1/maxweight; if minimum weight < 0, then the scale will be 1/max(maxweight,abs(minweight)). void FillCut(TH2F* h2, const TMVA::Rule* rule, Int_t vind); Fill cut. void FillLin(TH2F* h2, Int_t vind); fill lin. void FillCorr(TH2F* h2, const TMVA::Rule* rule, Int_t v1, Int_t v2); fill rule correlation between vx and vy, weighted with either the importance or the coefficient. void FillVisHistCut(const TMVA::Rule* rule, vector<TH2F*>& hlist); help routine to MakeVisHists() - fills for all variables. void FillVisHistCorr(const TMVA::Rule* rule, vector<TH2F*>& hlist); help routine to MakeVisHists() - fills for all correlation plots. Bool_t GetCorrVars(TString& title, TString& var1, TString& var2); get first and second variables from title. void MakeVisHists(); this will create histograms visualizing the rule ensemble. void MakeDebugHists(); this will create a histograms intended rather for debugging or for the curious user. RuleFit(const TMVA::MethodBase* rfbase); main constructor. void ReshuffleEvents(); { std::random_shuffle(fTrainingEventsRndm.begin(),fTrainingEventsRndm.end()); }. void SetModelLinear(); set usage of linear term. { fRuleEnsemble.SetModelLinear(); }. void SetModelRules(); set usage of rules. { fRuleEnsemble.SetModelRules(); }. void SetModelFull(); set usage of linear term. { fRuleEnsemble.SetModelFull(); }. void SetImportanceCut(Double_t minimp = 0); set minimum importance allowed. { fRuleEnsemble.SetImportanceCut(minimp); }. void SetRuleMinDist(Double_t d); set minimum rule distance - see RuleEnsemble. { fRuleEnsemble.SetRuleMi",MatchSource.WIKI,root/html604/TMVA__RuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RuleFit.html
https://root.cern/root/html604/TMVA__RuleFit.html:6258,Modifiability,variab,variables,6258,"read. void FitCoefficients(). Fit the coefficients for the rule ensemble. void CalcImportance(); calculates the importance of each rule. Double_t EvalEvent(const TMVA::Event& e); evaluate single event. void SetTrainingEvents(const vector<const TMVA::Event*>& el); set the training events randomly. void GetRndmSampleEvents(vector<const TMVA::Event*>& evevec, UInt_t nevents); draw a random subsample of the training events without replacement. void NormVisHists(vector<TH2F*>& hlist); normalize rule importance hists. if all weights are positive, the scale will be 1/maxweight; if minimum weight < 0, then the scale will be 1/max(maxweight,abs(minweight)). void FillCut(TH2F* h2, const TMVA::Rule* rule, Int_t vind); Fill cut. void FillLin(TH2F* h2, Int_t vind); fill lin. void FillCorr(TH2F* h2, const TMVA::Rule* rule, Int_t v1, Int_t v2); fill rule correlation between vx and vy, weighted with either the importance or the coefficient. void FillVisHistCut(const TMVA::Rule* rule, vector<TH2F*>& hlist); help routine to MakeVisHists() - fills for all variables. void FillVisHistCorr(const TMVA::Rule* rule, vector<TH2F*>& hlist); help routine to MakeVisHists() - fills for all correlation plots. Bool_t GetCorrVars(TString& title, TString& var1, TString& var2); get first and second variables from title. void MakeVisHists(); this will create histograms visualizing the rule ensemble. void MakeDebugHists(); this will create a histograms intended rather for debugging or for the curious user. RuleFit(const TMVA::MethodBase* rfbase); main constructor. void ReshuffleEvents(); { std::random_shuffle(fTrainingEventsRndm.begin(),fTrainingEventsRndm.end()); }. void SetModelLinear(); set usage of linear term. { fRuleEnsemble.SetModelLinear(); }. void SetModelRules(); set usage of rules. { fRuleEnsemble.SetModelRules(); }. void SetModelFull(); set usage of linear term. { fRuleEnsemble.SetModelFull(); }. void SetImportanceCut(Double_t minimp = 0); set minimum importance allowed. { fRuleEnsemble.SetI",MatchSource.WIKI,root/html604/TMVA__RuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RuleFit.html
https://root.cern/root/html604/TMVA__RuleFit.html:6490,Modifiability,variab,variables,6490,"vent*>& el); set the training events randomly. void GetRndmSampleEvents(vector<const TMVA::Event*>& evevec, UInt_t nevents); draw a random subsample of the training events without replacement. void NormVisHists(vector<TH2F*>& hlist); normalize rule importance hists. if all weights are positive, the scale will be 1/maxweight; if minimum weight < 0, then the scale will be 1/max(maxweight,abs(minweight)). void FillCut(TH2F* h2, const TMVA::Rule* rule, Int_t vind); Fill cut. void FillLin(TH2F* h2, Int_t vind); fill lin. void FillCorr(TH2F* h2, const TMVA::Rule* rule, Int_t v1, Int_t v2); fill rule correlation between vx and vy, weighted with either the importance or the coefficient. void FillVisHistCut(const TMVA::Rule* rule, vector<TH2F*>& hlist); help routine to MakeVisHists() - fills for all variables. void FillVisHistCorr(const TMVA::Rule* rule, vector<TH2F*>& hlist); help routine to MakeVisHists() - fills for all correlation plots. Bool_t GetCorrVars(TString& title, TString& var1, TString& var2); get first and second variables from title. void MakeVisHists(); this will create histograms visualizing the rule ensemble. void MakeDebugHists(); this will create a histograms intended rather for debugging or for the curious user. RuleFit(const TMVA::MethodBase* rfbase); main constructor. void ReshuffleEvents(); { std::random_shuffle(fTrainingEventsRndm.begin(),fTrainingEventsRndm.end()); }. void SetModelLinear(); set usage of linear term. { fRuleEnsemble.SetModelLinear(); }. void SetModelRules(); set usage of rules. { fRuleEnsemble.SetModelRules(); }. void SetModelFull(); set usage of linear term. { fRuleEnsemble.SetModelFull(); }. void SetImportanceCut(Double_t minimp = 0); set minimum importance allowed. { fRuleEnsemble.SetImportanceCut(minimp); }. void SetRuleMinDist(Double_t d); set minimum rule distance - see RuleEnsemble. { fRuleEnsemble.SetRuleMinDist(d); }. void SetGDTau(Double_t t = 0.); set path related parameters. { fRuleFitParams.SetGDTau(t); }. void SetGDPathS",MatchSource.WIKI,root/html604/TMVA__RuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RuleFit.html
https://root.cern/root/html604/TMVA__RuleFit.html:7841,Security,access,accessors,7841,"(),fTrainingEventsRndm.end()); }. void SetModelLinear(); set usage of linear term. { fRuleEnsemble.SetModelLinear(); }. void SetModelRules(); set usage of rules. { fRuleEnsemble.SetModelRules(); }. void SetModelFull(); set usage of linear term. { fRuleEnsemble.SetModelFull(); }. void SetImportanceCut(Double_t minimp = 0); set minimum importance allowed. { fRuleEnsemble.SetImportanceCut(minimp); }. void SetRuleMinDist(Double_t d); set minimum rule distance - see RuleEnsemble. { fRuleEnsemble.SetRuleMinDist(d); }. void SetGDTau(Double_t t = 0.); set path related parameters. { fRuleFitParams.SetGDTau(t); }. void SetGDPathStep(Double_t s = 0.01); { fRuleFitParams.SetGDPathStep(s); }. void SetGDNPathSteps(Int_t n = 100); make visualization histograms. { fRuleFitParams.SetGDNPathSteps(n); }. void SetVisHistsUseImp(Bool_t f); { fVisHistsUseImp = f; }. void UseImportanceVisHists(); { fVisHistsUseImp = kTRUE; }. void UseCoefficientsVisHists(); { fVisHistsUseImp = kFALSE; }. UInt_t GetNTreeSample() const; accessors. { return fNTreeSample; }. Double_t GetNEveEff() const; { return fNEveEffTrain; }. const Event* GetTrainingEvent(UInt_t i) const; { return static_cast< const Event *>(fTrainingEvents[i]); }. Double_t GetTrainingEventWeight(UInt_t i) const; { return fTrainingEvents[i]->GetWeight(); }. const std::vector< const TMVA::Event * > & GetTrainingEvents() const; const Event* GetTrainingEvent(UInt_t i, UInt_t isub) const { return &(fTrainingEvents[fSubsampleEvents[isub]])[i]; }. { return fTrainingEvents; }. const std::vector< const TMVA::DecisionTree *> & GetForest() const. { return fForest; }. const RuleEnsemble & GetRuleEnsemble() const; { return fRuleEnsemble; }. RuleEnsemble * GetRuleEnsemblePtr(); { return &fRuleEnsemble; }. const RuleFitParams & GetRuleFitParams() const; { return fRuleFitParams; }. RuleFitParams * GetRuleFitParamsPtr(); { return &fRuleFitParams; }. const MethodRuleFit * GetMethodRuleFit() const; { return fMethodRuleFit; }. const MethodBase * GetMethodBa",MatchSource.WIKI,root/html604/TMVA__RuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RuleFit.html
https://root.cern/root/html604/TMVA__RuleFit.html:3041,Testability,log,logger,3041,"etModelRules(); voidSetMsgType(TMVA::EMsgType t); voidSetRuleMinDist(Double_t d); voidSetTrainingEvents(const vector<const TMVA::Event*>& el); voidSetVisHistsUseImp(Bool_t f); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidUseCoefficientsVisHists(); voidUseImportanceVisHists(). private:. voidCopy(const TMVA::RuleFit& other); TMVA::MsgLogger&Log() const; TMVA::RuleFitRuleFit(const TMVA::RuleFit& other). Data Members; private:. vector<Double_t>fEventWeightsoriginal weights of the events - follows fTrainingEvents; vector<const TMVA::DecisionTree*>fForestthe input forest of decision trees; TMVA::MsgLogger*fLoggermessage logger; const TMVA::MethodBase*fMethodBasepointer the method base which initialized this RuleFit instance; const TMVA::MethodRuleFit*fMethodRuleFitpointer the method which initialized this RuleFit instance; Double_tfNEveEffTrainreweighted number of events = sum(wi); UInt_tfNTreeSamplenumber of events in sub sample = frac*neve; TMVA::RuleEnsemblefRuleEnsemblethe ensemble of rules; TMVA::RuleFitParamsfRuleFitParamsfit rule parameters; vector<const TMVA::Event*>fTrainingEventsall training events; vector<const TMVA::Event*>fTrainingEventsRndmidem, but randomly shuffled; Bool_tfVisHistsUseImpif true, use importance as weight; else coef in vis hists; static const Int_trandSEEDset to 1 for debugging purposes or to zero for random seeds. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RuleFit( const MethodBase *rfbase ); constructor. RuleFit(); default constructor. ~RuleFit(); destructor. void InitNEveEff(); init effective number of events (using event weights). void InitPtrs(const TMVA::MethodBase* rfbase); initialize pointers. void Initialize(const TMVA::MethodBase* rfbase); initialize the parameters of the RuleFit method and make rules. void SetMethodBase(const TMVA::MethodBase* rfbase); set MethodBase. void Copy(c",MatchSource.WIKI,root/html604/TMVA__RuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RuleFit.html
https://root.cern/root/html604/TMVA__RuleFitAPI.html:4256,Availability,mask,mask,4256,"s Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RuleFitAPI(const TMVA::MethodRuleFit* rfbase, TMVA::RuleFit* rulefit, TMVA::EMsgType minType); standard constructor. ~RuleFitAPI(); destructor. void WelcomeMessage(); welcome message. void HowtoSetupRF(); howto message. void InitRuleFit(); default initialisation; SetRFWorkDir(""./rulefit"");. void ImportSetup(); import setup from MethodRuleFit. void SetRFWorkDir(const char* wdir); set the directory containing rf_go.exe. void CheckRFWorkDir(); check if the rulefit work dir is properly setup.; it aborts (kFATAL) if not. Check existance of directory. void SetTrainParms(); set the training parameters. void SetTestParms(); set the test params. void FillRealParmsDef(); set default real params. void FillIntParmsDef(); set default int params. Bool_t WriteAll(); write all files read by rf_go.exe. Bool_t WriteIntParms(); write int params file. Bool_t WriteRealParms(); write int params file. Bool_t WriteLx(); Save input variable mask. If the lx vector size is not the same as inputVars,; resize it and fill it with 1; NOTE: Always set all to 1; if (fRFLx.size() != m_inputVars->size()) {. Bool_t WriteProgram(); write command to rf_go.exe. Bool_t WriteRealVarImp(); write the minimum importance to be considered. Bool_t WriteRfOut(); written by rf_go.exe; write rulefit output (rfout). Bool_t WriteRfStatus(); written by rf_go.exe; write rulefit status. Bool_t WriteRuleFitMod(); written by rf_go.exe (NOTE:Format unknown!). Bool_t WriteRuleFitSum(); written by rf_go.exe (NOTE: format unknown!). Bool_t WriteTrain(); write training data, columnwise. Bool_t WriteTest(); Write test data. Bool_t WriteVarNames(); write variable names, ascii. Bool_t WriteVarImp(); written by rf_go.exe. Bool_t WriteYhat(); written by rf_go.exe. Bool_t ReadYhat(); read the score. Bool_t ReadVarImp(); read variable importance. Bool_t ReadModelSum(); read model from rulefit.sum. Int_t RunRuleFit(); execute rf_go.exe. void TrainRu",MatchSource.WIKI,root/html604/TMVA__RuleFitAPI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RuleFitAPI.html
https://root.cern/root/html604/TMVA__RuleFitAPI.html:3501,Integrability,message,message,3501,"gress; static TMVA::RuleFitAPI::EModelkRfRules; static TMVA::RuleFitAPI::ERFProgramkRfTrain; static TMVA::RuleFitAPI::ERFProgramkRfVarimp. private:. TMVA::MsgLoggerfLoggermessage logger; const TMVA::MethodRuleFit*fMethodRuleFitparent method - set in constructor; TStringfModelTypemodel type string; TMVA::RuleFitAPI::IntParmsfRFIntParmsinteger parameters; vector<int>fRFLxvariable selector; TMVA::RuleFitAPI::ERFProgramfRFProgramwhat to run; TMVA::RuleFitAPI::RealParmsfRFRealParmsreal parameters; vector<Float_t>fRFVarImpvariable importances; vector<Int_t>fRFVarImpIndvariable index; TStringfRFWorkDirworking directory; vector<Float_t>fRFYhatscore results from test sample; TMVA::RuleFit*fRuleFitnon const ptr to RuleFit class in MethodRuleFit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RuleFitAPI(const TMVA::MethodRuleFit* rfbase, TMVA::RuleFit* rulefit, TMVA::EMsgType minType); standard constructor. ~RuleFitAPI(); destructor. void WelcomeMessage(); welcome message. void HowtoSetupRF(); howto message. void InitRuleFit(); default initialisation; SetRFWorkDir(""./rulefit"");. void ImportSetup(); import setup from MethodRuleFit. void SetRFWorkDir(const char* wdir); set the directory containing rf_go.exe. void CheckRFWorkDir(); check if the rulefit work dir is properly setup.; it aborts (kFATAL) if not. Check existance of directory. void SetTrainParms(); set the training parameters. void SetTestParms(); set the test params. void FillRealParmsDef(); set default real params. void FillIntParmsDef(); set default int params. Bool_t WriteAll(); write all files read by rf_go.exe. Bool_t WriteIntParms(); write int params file. Bool_t WriteRealParms(); write int params file. Bool_t WriteLx(); Save input variable mask. If the lx vector size is not the same as inputVars,; resize it and fill it with 1; NOTE: Always set all to 1; if (fRFLx.size() != m_inputVars->size()) {. Bool_t WriteProgram(); write command to rf_go.exe. Bool_t WriteRealVarImp",MatchSource.WIKI,root/html604/TMVA__RuleFitAPI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RuleFitAPI.html
https://root.cern/root/html604/TMVA__RuleFitAPI.html:3537,Integrability,message,message,3537,"kRfRules; static TMVA::RuleFitAPI::ERFProgramkRfTrain; static TMVA::RuleFitAPI::ERFProgramkRfVarimp. private:. TMVA::MsgLoggerfLoggermessage logger; const TMVA::MethodRuleFit*fMethodRuleFitparent method - set in constructor; TStringfModelTypemodel type string; TMVA::RuleFitAPI::IntParmsfRFIntParmsinteger parameters; vector<int>fRFLxvariable selector; TMVA::RuleFitAPI::ERFProgramfRFProgramwhat to run; TMVA::RuleFitAPI::RealParmsfRFRealParmsreal parameters; vector<Float_t>fRFVarImpvariable importances; vector<Int_t>fRFVarImpIndvariable index; TStringfRFWorkDirworking directory; vector<Float_t>fRFYhatscore results from test sample; TMVA::RuleFit*fRuleFitnon const ptr to RuleFit class in MethodRuleFit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RuleFitAPI(const TMVA::MethodRuleFit* rfbase, TMVA::RuleFit* rulefit, TMVA::EMsgType minType); standard constructor. ~RuleFitAPI(); destructor. void WelcomeMessage(); welcome message. void HowtoSetupRF(); howto message. void InitRuleFit(); default initialisation; SetRFWorkDir(""./rulefit"");. void ImportSetup(); import setup from MethodRuleFit. void SetRFWorkDir(const char* wdir); set the directory containing rf_go.exe. void CheckRFWorkDir(); check if the rulefit work dir is properly setup.; it aborts (kFATAL) if not. Check existance of directory. void SetTrainParms(); set the training parameters. void SetTestParms(); set the test params. void FillRealParmsDef(); set default real params. void FillIntParmsDef(); set default int params. Bool_t WriteAll(); write all files read by rf_go.exe. Bool_t WriteIntParms(); write int params file. Bool_t WriteRealParms(); write int params file. Bool_t WriteLx(); Save input variable mask. If the lx vector size is not the same as inputVars,; resize it and fill it with 1; NOTE: Always set all to 1; if (fRFLx.size() != m_inputVars->size()) {. Bool_t WriteProgram(); write command to rf_go.exe. Bool_t WriteRealVarImp(); write the minimum importance to be",MatchSource.WIKI,root/html604/TMVA__RuleFitAPI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RuleFitAPI.html
https://root.cern/root/html604/TMVA__RuleFitAPI.html:4247,Modifiability,variab,variable,4247,"s Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RuleFitAPI(const TMVA::MethodRuleFit* rfbase, TMVA::RuleFit* rulefit, TMVA::EMsgType minType); standard constructor. ~RuleFitAPI(); destructor. void WelcomeMessage(); welcome message. void HowtoSetupRF(); howto message. void InitRuleFit(); default initialisation; SetRFWorkDir(""./rulefit"");. void ImportSetup(); import setup from MethodRuleFit. void SetRFWorkDir(const char* wdir); set the directory containing rf_go.exe. void CheckRFWorkDir(); check if the rulefit work dir is properly setup.; it aborts (kFATAL) if not. Check existance of directory. void SetTrainParms(); set the training parameters. void SetTestParms(); set the test params. void FillRealParmsDef(); set default real params. void FillIntParmsDef(); set default int params. Bool_t WriteAll(); write all files read by rf_go.exe. Bool_t WriteIntParms(); write int params file. Bool_t WriteRealParms(); write int params file. Bool_t WriteLx(); Save input variable mask. If the lx vector size is not the same as inputVars,; resize it and fill it with 1; NOTE: Always set all to 1; if (fRFLx.size() != m_inputVars->size()) {. Bool_t WriteProgram(); write command to rf_go.exe. Bool_t WriteRealVarImp(); write the minimum importance to be considered. Bool_t WriteRfOut(); written by rf_go.exe; write rulefit output (rfout). Bool_t WriteRfStatus(); written by rf_go.exe; write rulefit status. Bool_t WriteRuleFitMod(); written by rf_go.exe (NOTE:Format unknown!). Bool_t WriteRuleFitSum(); written by rf_go.exe (NOTE: format unknown!). Bool_t WriteTrain(); write training data, columnwise. Bool_t WriteTest(); Write test data. Bool_t WriteVarNames(); write variable names, ascii. Bool_t WriteVarImp(); written by rf_go.exe. Bool_t WriteYhat(); written by rf_go.exe. Bool_t ReadYhat(); read the score. Bool_t ReadVarImp(); read variable importance. Bool_t ReadModelSum(); read model from rulefit.sum. Int_t RunRuleFit(); execute rf_go.exe. void TrainRu",MatchSource.WIKI,root/html604/TMVA__RuleFitAPI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RuleFitAPI.html
https://root.cern/root/html604/TMVA__RuleFitAPI.html:4945,Modifiability,variab,variable,4945,"tParms(); set the test params. void FillRealParmsDef(); set default real params. void FillIntParmsDef(); set default int params. Bool_t WriteAll(); write all files read by rf_go.exe. Bool_t WriteIntParms(); write int params file. Bool_t WriteRealParms(); write int params file. Bool_t WriteLx(); Save input variable mask. If the lx vector size is not the same as inputVars,; resize it and fill it with 1; NOTE: Always set all to 1; if (fRFLx.size() != m_inputVars->size()) {. Bool_t WriteProgram(); write command to rf_go.exe. Bool_t WriteRealVarImp(); write the minimum importance to be considered. Bool_t WriteRfOut(); written by rf_go.exe; write rulefit output (rfout). Bool_t WriteRfStatus(); written by rf_go.exe; write rulefit status. Bool_t WriteRuleFitMod(); written by rf_go.exe (NOTE:Format unknown!). Bool_t WriteRuleFitSum(); written by rf_go.exe (NOTE: format unknown!). Bool_t WriteTrain(); write training data, columnwise. Bool_t WriteTest(); Write test data. Bool_t WriteVarNames(); write variable names, ascii. Bool_t WriteVarImp(); written by rf_go.exe. Bool_t WriteYhat(); written by rf_go.exe. Bool_t ReadYhat(); read the score. Bool_t ReadVarImp(); read variable importance. Bool_t ReadModelSum(); read model from rulefit.sum. Int_t RunRuleFit(); execute rf_go.exe. void TrainRuleFit(). void TestRuleFit(). void VarImp(). TString GetRFName(TString name). Bool_t OpenRFile(TString name, ofstream& f). Bool_t OpenRFile(TString name, ifstream& f). Bool_t WriteInt(ofstream& f, const Int_t* v, Int_t n = 1). Bool_t WriteFloat(ofstream& f, const Float_t* v, Int_t n = 1). Int_t ReadInt(ifstream& f, Int_t* v, Int_t n = 1) const. Int_t ReadFloat(ifstream& f, Float_t* v, Int_t n = 1) const. RuleFitAPI(const TMVA::MethodRuleFit* rfbase, TMVA::RuleFit* rulefit, TMVA::EMsgType minType). const TString GetRFWorkDir() const; Get working directory. { return fRFWorkDir; }. void SetRFTrain(); set rf_go.exe running mode. { fRFProgram = kRfTrain; }. void SetRFPredict(); { fRFProgram = kRfPre",MatchSource.WIKI,root/html604/TMVA__RuleFitAPI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RuleFitAPI.html
https://root.cern/root/html604/TMVA__RuleFitAPI.html:5115,Modifiability,variab,variable,5115," rf_go.exe. Bool_t WriteIntParms(); write int params file. Bool_t WriteRealParms(); write int params file. Bool_t WriteLx(); Save input variable mask. If the lx vector size is not the same as inputVars,; resize it and fill it with 1; NOTE: Always set all to 1; if (fRFLx.size() != m_inputVars->size()) {. Bool_t WriteProgram(); write command to rf_go.exe. Bool_t WriteRealVarImp(); write the minimum importance to be considered. Bool_t WriteRfOut(); written by rf_go.exe; write rulefit output (rfout). Bool_t WriteRfStatus(); written by rf_go.exe; write rulefit status. Bool_t WriteRuleFitMod(); written by rf_go.exe (NOTE:Format unknown!). Bool_t WriteRuleFitSum(); written by rf_go.exe (NOTE: format unknown!). Bool_t WriteTrain(); write training data, columnwise. Bool_t WriteTest(); Write test data. Bool_t WriteVarNames(); write variable names, ascii. Bool_t WriteVarImp(); written by rf_go.exe. Bool_t WriteYhat(); written by rf_go.exe. Bool_t ReadYhat(); read the score. Bool_t ReadVarImp(); read variable importance. Bool_t ReadModelSum(); read model from rulefit.sum. Int_t RunRuleFit(); execute rf_go.exe. void TrainRuleFit(). void TestRuleFit(). void VarImp(). TString GetRFName(TString name). Bool_t OpenRFile(TString name, ofstream& f). Bool_t OpenRFile(TString name, ifstream& f). Bool_t WriteInt(ofstream& f, const Int_t* v, Int_t n = 1). Bool_t WriteFloat(ofstream& f, const Float_t* v, Int_t n = 1). Int_t ReadInt(ifstream& f, Int_t* v, Int_t n = 1) const. Int_t ReadFloat(ifstream& f, Float_t* v, Int_t n = 1) const. RuleFitAPI(const TMVA::MethodRuleFit* rfbase, TMVA::RuleFit* rulefit, TMVA::EMsgType minType). const TString GetRFWorkDir() const; Get working directory. { return fRFWorkDir; }. void SetRFTrain(); set rf_go.exe running mode. { fRFProgram = kRfTrain; }. void SetRFPredict(); { fRFProgram = kRfPredict; }. void SetRFVarimp(); { fRFProgram = kRfVarimp; }. Bool_t ReadIntParms(). Bool_t ReadRealParms(). Bool_t ReadLx(). Bool_t ReadProgram(). Bool_t ReadRealVarImp(). Bo",MatchSource.WIKI,root/html604/TMVA__RuleFitAPI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RuleFitAPI.html
https://root.cern/root/html604/TMVA__RuleFitAPI.html:3824,Safety,abort,aborts,3824,"parameters; vector<int>fRFLxvariable selector; TMVA::RuleFitAPI::ERFProgramfRFProgramwhat to run; TMVA::RuleFitAPI::RealParmsfRFRealParmsreal parameters; vector<Float_t>fRFVarImpvariable importances; vector<Int_t>fRFVarImpIndvariable index; TStringfRFWorkDirworking directory; vector<Float_t>fRFYhatscore results from test sample; TMVA::RuleFit*fRuleFitnon const ptr to RuleFit class in MethodRuleFit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RuleFitAPI(const TMVA::MethodRuleFit* rfbase, TMVA::RuleFit* rulefit, TMVA::EMsgType minType); standard constructor. ~RuleFitAPI(); destructor. void WelcomeMessage(); welcome message. void HowtoSetupRF(); howto message. void InitRuleFit(); default initialisation; SetRFWorkDir(""./rulefit"");. void ImportSetup(); import setup from MethodRuleFit. void SetRFWorkDir(const char* wdir); set the directory containing rf_go.exe. void CheckRFWorkDir(); check if the rulefit work dir is properly setup.; it aborts (kFATAL) if not. Check existance of directory. void SetTrainParms(); set the training parameters. void SetTestParms(); set the test params. void FillRealParmsDef(); set default real params. void FillIntParmsDef(); set default int params. Bool_t WriteAll(); write all files read by rf_go.exe. Bool_t WriteIntParms(); write int params file. Bool_t WriteRealParms(); write int params file. Bool_t WriteLx(); Save input variable mask. If the lx vector size is not the same as inputVars,; resize it and fill it with 1; NOTE: Always set all to 1; if (fRFLx.size() != m_inputVars->size()) {. Bool_t WriteProgram(); write command to rf_go.exe. Bool_t WriteRealVarImp(); write the minimum importance to be considered. Bool_t WriteRfOut(); written by rf_go.exe; write rulefit output (rfout). Bool_t WriteRfStatus(); written by rf_go.exe; write rulefit status. Bool_t WriteRuleFitMod(); written by rf_go.exe (NOTE:Format unknown!). Bool_t WriteRuleFitSum(); written by rf_go.exe (NOTE: format unknown!). Bool_t Wr",MatchSource.WIKI,root/html604/TMVA__RuleFitAPI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RuleFitAPI.html
https://root.cern/root/html604/TMVA__RuleFitAPI.html:2668,Testability,log,logger,2668,"l_tWriteLx(); Bool_tWriteProgram(); Bool_tWriteRealParms(); Bool_tWriteRealVarImp(); Bool_tWriteRfOut(); Bool_tWriteRfStatus(); Bool_tWriteRuleFitMod(); Bool_tWriteRuleFitSum(); Bool_tWriteTest(); Bool_tWriteTrain(); Bool_tWriteVarImp(); Bool_tWriteVarNames(); Bool_tWriteYhat(). private:. TMVA::RuleFitAPIRuleFitAPI(). Data Members; protected:. static TMVA::RuleFitAPI::EModelkRfBoth; static TMVA::RuleFitAPI::ERFModekRfClass; static TMVA::RuleFitAPI::EModelkRfLinear; static TMVA::RuleFitAPI::ERFProgramkRfPredict; static TMVA::RuleFitAPI::ERFModekRfRegress; static TMVA::RuleFitAPI::EModelkRfRules; static TMVA::RuleFitAPI::ERFProgramkRfTrain; static TMVA::RuleFitAPI::ERFProgramkRfVarimp. private:. TMVA::MsgLoggerfLoggermessage logger; const TMVA::MethodRuleFit*fMethodRuleFitparent method - set in constructor; TStringfModelTypemodel type string; TMVA::RuleFitAPI::IntParmsfRFIntParmsinteger parameters; vector<int>fRFLxvariable selector; TMVA::RuleFitAPI::ERFProgramfRFProgramwhat to run; TMVA::RuleFitAPI::RealParmsfRFRealParmsreal parameters; vector<Float_t>fRFVarImpvariable importances; vector<Int_t>fRFVarImpIndvariable index; TStringfRFWorkDirworking directory; vector<Float_t>fRFYhatscore results from test sample; TMVA::RuleFit*fRuleFitnon const ptr to RuleFit class in MethodRuleFit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RuleFitAPI(const TMVA::MethodRuleFit* rfbase, TMVA::RuleFit* rulefit, TMVA::EMsgType minType); standard constructor. ~RuleFitAPI(); destructor. void WelcomeMessage(); welcome message. void HowtoSetupRF(); howto message. void InitRuleFit(); default initialisation; SetRFWorkDir(""./rulefit"");. void ImportSetup(); import setup from MethodRuleFit. void SetRFWorkDir(const char* wdir); set the directory containing rf_go.exe. void CheckRFWorkDir(); check if the rulefit work dir is properly setup.; it aborts (kFATAL) if not. Check existance of directory. void SetTrainParms(); set the training parameters. void Se",MatchSource.WIKI,root/html604/TMVA__RuleFitAPI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RuleFitAPI.html
https://root.cern/root/html604/TMVA__RuleFitAPI.html:3151,Testability,test,test,3151,"l_tWriteLx(); Bool_tWriteProgram(); Bool_tWriteRealParms(); Bool_tWriteRealVarImp(); Bool_tWriteRfOut(); Bool_tWriteRfStatus(); Bool_tWriteRuleFitMod(); Bool_tWriteRuleFitSum(); Bool_tWriteTest(); Bool_tWriteTrain(); Bool_tWriteVarImp(); Bool_tWriteVarNames(); Bool_tWriteYhat(). private:. TMVA::RuleFitAPIRuleFitAPI(). Data Members; protected:. static TMVA::RuleFitAPI::EModelkRfBoth; static TMVA::RuleFitAPI::ERFModekRfClass; static TMVA::RuleFitAPI::EModelkRfLinear; static TMVA::RuleFitAPI::ERFProgramkRfPredict; static TMVA::RuleFitAPI::ERFModekRfRegress; static TMVA::RuleFitAPI::EModelkRfRules; static TMVA::RuleFitAPI::ERFProgramkRfTrain; static TMVA::RuleFitAPI::ERFProgramkRfVarimp. private:. TMVA::MsgLoggerfLoggermessage logger; const TMVA::MethodRuleFit*fMethodRuleFitparent method - set in constructor; TStringfModelTypemodel type string; TMVA::RuleFitAPI::IntParmsfRFIntParmsinteger parameters; vector<int>fRFLxvariable selector; TMVA::RuleFitAPI::ERFProgramfRFProgramwhat to run; TMVA::RuleFitAPI::RealParmsfRFRealParmsreal parameters; vector<Float_t>fRFVarImpvariable importances; vector<Int_t>fRFVarImpIndvariable index; TStringfRFWorkDirworking directory; vector<Float_t>fRFYhatscore results from test sample; TMVA::RuleFit*fRuleFitnon const ptr to RuleFit class in MethodRuleFit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RuleFitAPI(const TMVA::MethodRuleFit* rfbase, TMVA::RuleFit* rulefit, TMVA::EMsgType minType); standard constructor. ~RuleFitAPI(); destructor. void WelcomeMessage(); welcome message. void HowtoSetupRF(); howto message. void InitRuleFit(); default initialisation; SetRFWorkDir(""./rulefit"");. void ImportSetup(); import setup from MethodRuleFit. void SetRFWorkDir(const char* wdir); set the directory containing rf_go.exe. void CheckRFWorkDir(); check if the rulefit work dir is properly setup.; it aborts (kFATAL) if not. Check existance of directory. void SetTrainParms(); set the training parameters. void Se",MatchSource.WIKI,root/html604/TMVA__RuleFitAPI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RuleFitAPI.html
https://root.cern/root/html604/TMVA__RuleFitAPI.html:3958,Testability,test,test,3958,"RealParmsfRFRealParmsreal parameters; vector<Float_t>fRFVarImpvariable importances; vector<Int_t>fRFVarImpIndvariable index; TStringfRFWorkDirworking directory; vector<Float_t>fRFYhatscore results from test sample; TMVA::RuleFit*fRuleFitnon const ptr to RuleFit class in MethodRuleFit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RuleFitAPI(const TMVA::MethodRuleFit* rfbase, TMVA::RuleFit* rulefit, TMVA::EMsgType minType); standard constructor. ~RuleFitAPI(); destructor. void WelcomeMessage(); welcome message. void HowtoSetupRF(); howto message. void InitRuleFit(); default initialisation; SetRFWorkDir(""./rulefit"");. void ImportSetup(); import setup from MethodRuleFit. void SetRFWorkDir(const char* wdir); set the directory containing rf_go.exe. void CheckRFWorkDir(); check if the rulefit work dir is properly setup.; it aborts (kFATAL) if not. Check existance of directory. void SetTrainParms(); set the training parameters. void SetTestParms(); set the test params. void FillRealParmsDef(); set default real params. void FillIntParmsDef(); set default int params. Bool_t WriteAll(); write all files read by rf_go.exe. Bool_t WriteIntParms(); write int params file. Bool_t WriteRealParms(); write int params file. Bool_t WriteLx(); Save input variable mask. If the lx vector size is not the same as inputVars,; resize it and fill it with 1; NOTE: Always set all to 1; if (fRFLx.size() != m_inputVars->size()) {. Bool_t WriteProgram(); write command to rf_go.exe. Bool_t WriteRealVarImp(); write the minimum importance to be considered. Bool_t WriteRfOut(); written by rf_go.exe; write rulefit output (rfout). Bool_t WriteRfStatus(); written by rf_go.exe; write rulefit status. Bool_t WriteRuleFitMod(); written by rf_go.exe (NOTE:Format unknown!). Bool_t WriteRuleFitSum(); written by rf_go.exe (NOTE: format unknown!). Bool_t WriteTrain(); write training data, columnwise. Bool_t WriteTest(); Write test data. Bool_t WriteVarNames(); write vari",MatchSource.WIKI,root/html604/TMVA__RuleFitAPI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RuleFitAPI.html
https://root.cern/root/html604/TMVA__RuleFitAPI.html:4904,Testability,test,test,4904,"s(); set the training parameters. void SetTestParms(); set the test params. void FillRealParmsDef(); set default real params. void FillIntParmsDef(); set default int params. Bool_t WriteAll(); write all files read by rf_go.exe. Bool_t WriteIntParms(); write int params file. Bool_t WriteRealParms(); write int params file. Bool_t WriteLx(); Save input variable mask. If the lx vector size is not the same as inputVars,; resize it and fill it with 1; NOTE: Always set all to 1; if (fRFLx.size() != m_inputVars->size()) {. Bool_t WriteProgram(); write command to rf_go.exe. Bool_t WriteRealVarImp(); write the minimum importance to be considered. Bool_t WriteRfOut(); written by rf_go.exe; write rulefit output (rfout). Bool_t WriteRfStatus(); written by rf_go.exe; write rulefit status. Bool_t WriteRuleFitMod(); written by rf_go.exe (NOTE:Format unknown!). Bool_t WriteRuleFitSum(); written by rf_go.exe (NOTE: format unknown!). Bool_t WriteTrain(); write training data, columnwise. Bool_t WriteTest(); Write test data. Bool_t WriteVarNames(); write variable names, ascii. Bool_t WriteVarImp(); written by rf_go.exe. Bool_t WriteYhat(); written by rf_go.exe. Bool_t ReadYhat(); read the score. Bool_t ReadVarImp(); read variable importance. Bool_t ReadModelSum(); read model from rulefit.sum. Int_t RunRuleFit(); execute rf_go.exe. void TrainRuleFit(). void TestRuleFit(). void VarImp(). TString GetRFName(TString name). Bool_t OpenRFile(TString name, ofstream& f). Bool_t OpenRFile(TString name, ifstream& f). Bool_t WriteInt(ofstream& f, const Int_t* v, Int_t n = 1). Bool_t WriteFloat(ofstream& f, const Float_t* v, Int_t n = 1). Int_t ReadInt(ifstream& f, Int_t* v, Int_t n = 1) const. Int_t ReadFloat(ifstream& f, Float_t* v, Int_t n = 1) const. RuleFitAPI(const TMVA::MethodRuleFit* rfbase, TMVA::RuleFit* rulefit, TMVA::EMsgType minType). const TString GetRFWorkDir() const; Get working directory. { return fRFWorkDir; }. void SetRFTrain(); set rf_go.exe running mode. { fRFProgram = kRfTrain; ",MatchSource.WIKI,root/html604/TMVA__RuleFitAPI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__RuleFitAPI.html
https://root.cern/root/html604/TMVA__SdivSqrtSplusB.html:1910,Performance,optimiz,optimized,1910,"onst Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::SdivSqrtSplusB&operator=(const TMVA::SdivSqrtSplusB&); TMVA::SdivSqrtSplusBSdivSqrtSplusB(); TMVA::SdivSqrtSplusBSdivSqrtSplusB(const TMVA::SdivSqrtSplusB& g); TMVA::SeparationBaseTMVA::SeparationBase::SeparationBase(); TMVA::SeparationBaseTMVA::SeparationBase::SeparationBase(const TMVA::SeparationBase& s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringTMVA::SeparationBase::fNamename of the concrete Separation Index impementation; Double_tTMVA::SeparationBase::fPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Index = S/sqrt(S+B) (statistical significance). Double_t GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system (making the best selection. SdivSqrtSplusB(); constructor for the ""statistical significance"" index. { fName = ""StatSig""; }. SdivSqrtSplusB(const TMVA::SdivSqrtSplusB& g); copy constructor. {}. virtual ~SdivSqrtSplusB(); destructor. {}. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__SdivSqrtSplusB.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SdivSqrtSplusB.html
https://root.cern/root/html604/TMVA__SeparationBase.html:439,Availability,avail,available,439,". TMVA::SeparationBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::SeparationBase. class TMVA::SeparationBase. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~SeparationBase(); static TClass*Class(); const TString&GetName(); virtual Double_tGetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::SeparationBase&operator=(const TMVA::SeparationBase&); TMVA::SeparationBaseSeparationBase(); TMVA::SeparationBaseSeparationBase(const TMVA::SeparationBase& s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation; Double_tfPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SeparationBase(); default constructor. SeparationBase(const TMVA::SeparationBase& s); copy constructor. Double_t GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system (making the best selection. virtual ~SeparationBase(); destructor. {}. Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Return t",MatchSource.WIKI,root/html604/TMVA__SeparationBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SeparationBase.html
https://root.cern/root/html604/TMVA__SeparationBase.html:1786,Performance,optimiz,optimized,1786,". virtual~SeparationBase(); static TClass*Class(); const TString&GetName(); virtual Double_tGetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::SeparationBase&operator=(const TMVA::SeparationBase&); TMVA::SeparationBaseSeparationBase(); TMVA::SeparationBaseSeparationBase(const TMVA::SeparationBase& s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation; Double_tfPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SeparationBase(); default constructor. SeparationBase(const TMVA::SeparationBase& s); copy constructor. Double_t GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system (making the best selection. virtual ~SeparationBase(); destructor. {}. Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Return the separation index (a measure for ""purity"" of the sample""). const TString& GetName(); Return the name of the concrete Index implementation. { return fName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__SeparationBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SeparationBase.html
https://root.cern/root/html604/TMVA__SimulatedAnnealing.html:917,Energy Efficiency,adapt,adaptiveSpeed,917,". TMVA::SimulatedAnnealing. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::SimulatedAnnealing. class TMVA::SimulatedAnnealing. Implementation of Simulated Annealing fitter. Function Members (Methods); public:. virtual~SimulatedAnnealing(); static TClass*Class(); virtual TClass*IsA() const; Double_tMinimize(vector<Double_t>& parameters); TMVA::SimulatedAnnealing&operator=(const TMVA::SimulatedAnnealing&); voidSetAccuracy(Double_t eps); voidSetAdaptiveSpeed(Double_t speed); voidSetInitTemp(Double_t it); voidSetMaxCalls(Int_t mc); voidSetMinTemp(Double_t min); voidSetOptions(Int_t maxCalls, Double_t initialTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Double_t temperatureAdaptiveStep, Bool_t useDefaultScale, Bool_t useDefaultTemperature); voidSetTemperatureScale(Double_t scale); virtual voidShowMembers(TMemberInspector& insp) const; TMVA::SimulatedAnnealingSimulatedAnnealing(const TMVA::SimulatedAnnealing&); TMVA::SimulatedAnnealingSimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. voidFillWithRandomValues(vector<Double_t>& parameters); Double_tGenerateMaxTemperature(vector<Double_t>& parameters); vector<Double_t>GenerateNeighbour(vector<Double_t>& parameters, Double_t currentTemperature); voidGenerateNeighbour(vector<Double_t>& parameters, vector<Double_t>& oldParameters, Double_t currentTemperature); voidGenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); TMVA::MsgLogger&Log() const; voidReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); voidSetDefaultScale(); Bool_tShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTe",MatchSource.WIKI,root/html604/TMVA__SimulatedAnnealing.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SimulatedAnnealing.html
https://root.cern/root/html604/TMVA__SimulatedAnnealing.html:2090,Energy Efficiency,adapt,adaptive,2090,"rameters, vector<Double_t>& oldParameters, Double_t currentTemperature); voidGenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); TMVA::MsgLogger&Log() const; voidReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); voidSetDefaultScale(); Bool_tShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTemperature). Data Members; private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsepsilon; TMVA::IFitterTarget&fFitterTargetthe fitter target; Double_tfInitialTemperatureinitial temperature; enum EKernelTemperaturefKernelTemperature; TMVA::MsgLogger*fLoggermessage logger; Int_tfMaxCallsmaximum number of minimisation calls; Double_tfMinTemperaturemimimum temperature; Double_tfProgress; TRandom*fRandomrandom generator; const vector<TMVA::Interval*>&fRangesparameter ranges; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre); static TMVA::SimulatedAnnealing::EKernelTemperaturekDecreasingAdaptive; static TMVA::SimulatedAnnealing::EKernelTemperaturekGeo; static TMVA::SimulatedAnnealing::EKernelTemperaturekHomo; static TMVA::SimulatedAnnealing::EKernelTemperaturekIncreasingAdaptive; static TMVA::SimulatedAnnealing::EKernelTemperaturekLog; static TMVA::SimulatedAnnealing::EKernelTemperaturekSin; static TMVA::SimulatedAnnealing::EKernelTemperaturekSqrt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges); constructor. void SetOptions(Int_t maxCalls, Double_t initialTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Do",MatchSource.WIKI,root/html604/TMVA__SimulatedAnnealing.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SimulatedAnnealing.html
https://root.cern/root/html604/TMVA__SimulatedAnnealing.html:2103,Energy Efficiency,adapt,adaptive,2103,"rameters, vector<Double_t>& oldParameters, Double_t currentTemperature); voidGenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); TMVA::MsgLogger&Log() const; voidReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); voidSetDefaultScale(); Bool_tShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTemperature). Data Members; private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsepsilon; TMVA::IFitterTarget&fFitterTargetthe fitter target; Double_tfInitialTemperatureinitial temperature; enum EKernelTemperaturefKernelTemperature; TMVA::MsgLogger*fLoggermessage logger; Int_tfMaxCallsmaximum number of minimisation calls; Double_tfMinTemperaturemimimum temperature; Double_tfProgress; TRandom*fRandomrandom generator; const vector<TMVA::Interval*>&fRangesparameter ranges; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre); static TMVA::SimulatedAnnealing::EKernelTemperaturekDecreasingAdaptive; static TMVA::SimulatedAnnealing::EKernelTemperaturekGeo; static TMVA::SimulatedAnnealing::EKernelTemperaturekHomo; static TMVA::SimulatedAnnealing::EKernelTemperaturekIncreasingAdaptive; static TMVA::SimulatedAnnealing::EKernelTemperaturekLog; static TMVA::SimulatedAnnealing::EKernelTemperaturekSin; static TMVA::SimulatedAnnealing::EKernelTemperaturekSqrt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges); constructor. void SetOptions(Int_t maxCalls, Double_t initialTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Do",MatchSource.WIKI,root/html604/TMVA__SimulatedAnnealing.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SimulatedAnnealing.html
https://root.cern/root/html604/TMVA__SimulatedAnnealing.html:3646,Energy Efficiency,adapt,adaptiveSpeed,3646,"ultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre); static TMVA::SimulatedAnnealing::EKernelTemperaturekDecreasingAdaptive; static TMVA::SimulatedAnnealing::EKernelTemperaturekGeo; static TMVA::SimulatedAnnealing::EKernelTemperaturekHomo; static TMVA::SimulatedAnnealing::EKernelTemperaturekIncreasingAdaptive; static TMVA::SimulatedAnnealing::EKernelTemperaturekLog; static TMVA::SimulatedAnnealing::EKernelTemperaturekSin; static TMVA::SimulatedAnnealing::EKernelTemperaturekSqrt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges); constructor. void SetOptions(Int_t maxCalls, Double_t initialTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Double_t temperatureAdaptiveStep, Bool_t useDefaultScale, Bool_t useDefaultTemperature); option setter. ~SimulatedAnnealing(); destructor. void FillWithRandomValues(vector<Double_t>& parameters); random starting parameters. void ReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); copy parameters. void GenerateNeighbour(vector<Double_t>& parameters, vector<Double_t>& oldParameters, Double_t currentTemperature); generate adjacent parameters. std::vector<Double_t> GenerateNeighbour(vector<Double_t>& parameters, Double_t currentTemperature); generate adjacent parameters. void GenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); generate new temperature. Bool_t ShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTemperature); result checker. void SetDefaultScale(); setting of default scale. Double_t GenerateMaxTemperature(vector<Double_t>& parameters); maximum temperature. Double_t Minimize(vector<Double_t>& para",MatchSource.WIKI,root/html604/TMVA__SimulatedAnnealing.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SimulatedAnnealing.html
https://root.cern/root/html604/TMVA__SimulatedAnnealing.html:917,Modifiability,adapt,adaptiveSpeed,917,". TMVA::SimulatedAnnealing. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::SimulatedAnnealing. class TMVA::SimulatedAnnealing. Implementation of Simulated Annealing fitter. Function Members (Methods); public:. virtual~SimulatedAnnealing(); static TClass*Class(); virtual TClass*IsA() const; Double_tMinimize(vector<Double_t>& parameters); TMVA::SimulatedAnnealing&operator=(const TMVA::SimulatedAnnealing&); voidSetAccuracy(Double_t eps); voidSetAdaptiveSpeed(Double_t speed); voidSetInitTemp(Double_t it); voidSetMaxCalls(Int_t mc); voidSetMinTemp(Double_t min); voidSetOptions(Int_t maxCalls, Double_t initialTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Double_t temperatureAdaptiveStep, Bool_t useDefaultScale, Bool_t useDefaultTemperature); voidSetTemperatureScale(Double_t scale); virtual voidShowMembers(TMemberInspector& insp) const; TMVA::SimulatedAnnealingSimulatedAnnealing(const TMVA::SimulatedAnnealing&); TMVA::SimulatedAnnealingSimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. voidFillWithRandomValues(vector<Double_t>& parameters); Double_tGenerateMaxTemperature(vector<Double_t>& parameters); vector<Double_t>GenerateNeighbour(vector<Double_t>& parameters, Double_t currentTemperature); voidGenerateNeighbour(vector<Double_t>& parameters, vector<Double_t>& oldParameters, Double_t currentTemperature); voidGenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); TMVA::MsgLogger&Log() const; voidReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); voidSetDefaultScale(); Bool_tShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTe",MatchSource.WIKI,root/html604/TMVA__SimulatedAnnealing.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SimulatedAnnealing.html
https://root.cern/root/html604/TMVA__SimulatedAnnealing.html:2090,Modifiability,adapt,adaptive,2090,"rameters, vector<Double_t>& oldParameters, Double_t currentTemperature); voidGenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); TMVA::MsgLogger&Log() const; voidReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); voidSetDefaultScale(); Bool_tShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTemperature). Data Members; private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsepsilon; TMVA::IFitterTarget&fFitterTargetthe fitter target; Double_tfInitialTemperatureinitial temperature; enum EKernelTemperaturefKernelTemperature; TMVA::MsgLogger*fLoggermessage logger; Int_tfMaxCallsmaximum number of minimisation calls; Double_tfMinTemperaturemimimum temperature; Double_tfProgress; TRandom*fRandomrandom generator; const vector<TMVA::Interval*>&fRangesparameter ranges; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre); static TMVA::SimulatedAnnealing::EKernelTemperaturekDecreasingAdaptive; static TMVA::SimulatedAnnealing::EKernelTemperaturekGeo; static TMVA::SimulatedAnnealing::EKernelTemperaturekHomo; static TMVA::SimulatedAnnealing::EKernelTemperaturekIncreasingAdaptive; static TMVA::SimulatedAnnealing::EKernelTemperaturekLog; static TMVA::SimulatedAnnealing::EKernelTemperaturekSin; static TMVA::SimulatedAnnealing::EKernelTemperaturekSqrt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges); constructor. void SetOptions(Int_t maxCalls, Double_t initialTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Do",MatchSource.WIKI,root/html604/TMVA__SimulatedAnnealing.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SimulatedAnnealing.html
https://root.cern/root/html604/TMVA__SimulatedAnnealing.html:2103,Modifiability,adapt,adaptive,2103,"rameters, vector<Double_t>& oldParameters, Double_t currentTemperature); voidGenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); TMVA::MsgLogger&Log() const; voidReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); voidSetDefaultScale(); Bool_tShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTemperature). Data Members; private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsepsilon; TMVA::IFitterTarget&fFitterTargetthe fitter target; Double_tfInitialTemperatureinitial temperature; enum EKernelTemperaturefKernelTemperature; TMVA::MsgLogger*fLoggermessage logger; Int_tfMaxCallsmaximum number of minimisation calls; Double_tfMinTemperaturemimimum temperature; Double_tfProgress; TRandom*fRandomrandom generator; const vector<TMVA::Interval*>&fRangesparameter ranges; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre); static TMVA::SimulatedAnnealing::EKernelTemperaturekDecreasingAdaptive; static TMVA::SimulatedAnnealing::EKernelTemperaturekGeo; static TMVA::SimulatedAnnealing::EKernelTemperaturekHomo; static TMVA::SimulatedAnnealing::EKernelTemperaturekIncreasingAdaptive; static TMVA::SimulatedAnnealing::EKernelTemperaturekLog; static TMVA::SimulatedAnnealing::EKernelTemperaturekSin; static TMVA::SimulatedAnnealing::EKernelTemperaturekSqrt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges); constructor. void SetOptions(Int_t maxCalls, Double_t initialTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Do",MatchSource.WIKI,root/html604/TMVA__SimulatedAnnealing.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SimulatedAnnealing.html
https://root.cern/root/html604/TMVA__SimulatedAnnealing.html:2116,Modifiability,variab,variables,2116,"rameters, vector<Double_t>& oldParameters, Double_t currentTemperature); voidGenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); TMVA::MsgLogger&Log() const; voidReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); voidSetDefaultScale(); Bool_tShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTemperature). Data Members; private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsepsilon; TMVA::IFitterTarget&fFitterTargetthe fitter target; Double_tfInitialTemperatureinitial temperature; enum EKernelTemperaturefKernelTemperature; TMVA::MsgLogger*fLoggermessage logger; Int_tfMaxCallsmaximum number of minimisation calls; Double_tfMinTemperaturemimimum temperature; Double_tfProgress; TRandom*fRandomrandom generator; const vector<TMVA::Interval*>&fRangesparameter ranges; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre); static TMVA::SimulatedAnnealing::EKernelTemperaturekDecreasingAdaptive; static TMVA::SimulatedAnnealing::EKernelTemperaturekGeo; static TMVA::SimulatedAnnealing::EKernelTemperaturekHomo; static TMVA::SimulatedAnnealing::EKernelTemperaturekIncreasingAdaptive; static TMVA::SimulatedAnnealing::EKernelTemperaturekLog; static TMVA::SimulatedAnnealing::EKernelTemperaturekSin; static TMVA::SimulatedAnnealing::EKernelTemperaturekSqrt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges); constructor. void SetOptions(Int_t maxCalls, Double_t initialTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Do",MatchSource.WIKI,root/html604/TMVA__SimulatedAnnealing.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SimulatedAnnealing.html
https://root.cern/root/html604/TMVA__SimulatedAnnealing.html:3646,Modifiability,adapt,adaptiveSpeed,3646,"ultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre); static TMVA::SimulatedAnnealing::EKernelTemperaturekDecreasingAdaptive; static TMVA::SimulatedAnnealing::EKernelTemperaturekGeo; static TMVA::SimulatedAnnealing::EKernelTemperaturekHomo; static TMVA::SimulatedAnnealing::EKernelTemperaturekIncreasingAdaptive; static TMVA::SimulatedAnnealing::EKernelTemperaturekLog; static TMVA::SimulatedAnnealing::EKernelTemperaturekSin; static TMVA::SimulatedAnnealing::EKernelTemperaturekSqrt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges); constructor. void SetOptions(Int_t maxCalls, Double_t initialTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Double_t temperatureAdaptiveStep, Bool_t useDefaultScale, Bool_t useDefaultTemperature); option setter. ~SimulatedAnnealing(); destructor. void FillWithRandomValues(vector<Double_t>& parameters); random starting parameters. void ReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); copy parameters. void GenerateNeighbour(vector<Double_t>& parameters, vector<Double_t>& oldParameters, Double_t currentTemperature); generate adjacent parameters. std::vector<Double_t> GenerateNeighbour(vector<Double_t>& parameters, Double_t currentTemperature); generate adjacent parameters. void GenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); generate new temperature. Bool_t ShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTemperature); result checker. void SetDefaultScale(); setting of default scale. Double_t GenerateMaxTemperature(vector<Double_t>& parameters); maximum temperature. Double_t Minimize(vector<Double_t>& para",MatchSource.WIKI,root/html604/TMVA__SimulatedAnnealing.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SimulatedAnnealing.html
https://root.cern/root/html604/TMVA__SimulatedAnnealing.html:4772,Security,access,accessors,4772,"onstructor. void SetOptions(Int_t maxCalls, Double_t initialTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Double_t temperatureAdaptiveStep, Bool_t useDefaultScale, Bool_t useDefaultTemperature); option setter. ~SimulatedAnnealing(); destructor. void FillWithRandomValues(vector<Double_t>& parameters); random starting parameters. void ReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); copy parameters. void GenerateNeighbour(vector<Double_t>& parameters, vector<Double_t>& oldParameters, Double_t currentTemperature); generate adjacent parameters. std::vector<Double_t> GenerateNeighbour(vector<Double_t>& parameters, Double_t currentTemperature); generate adjacent parameters. void GenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); generate new temperature. Bool_t ShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTemperature); result checker. void SetDefaultScale(); setting of default scale. Double_t GenerateMaxTemperature(vector<Double_t>& parameters); maximum temperature. Double_t Minimize(vector<Double_t>& parameters); minimisation algorithm. SimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges). void SetMaxCalls(Int_t mc); accessors. { fMaxCalls = mc; }. void SetInitTemp(Double_t it); { fInitialTemperature = it; }. void SetMinTemp(Double_t min); { fMinTemperature = min; }. void SetAccuracy(Double_t eps); { fEps = eps; }. void SetTemperatureScale(Double_t scale); { fTemperatureScale = scale; }. void SetAdaptiveSpeed(Double_t speed); { fAdaptiveSpeed = speed; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Krzysztof Danielowski, Kamil Kraszewski, Maciej Kruk » Copyright (c) 2008: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__SimulatedAnnealing.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SimulatedAnnealing.html
https://root.cern/root/html604/TMVA__SimulatedAnnealing.html:2331,Testability,log,logger,2331,"rameters, vector<Double_t>& oldParameters, Double_t currentTemperature); voidGenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); TMVA::MsgLogger&Log() const; voidReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); voidSetDefaultScale(); Bool_tShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTemperature). Data Members; private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsepsilon; TMVA::IFitterTarget&fFitterTargetthe fitter target; Double_tfInitialTemperatureinitial temperature; enum EKernelTemperaturefKernelTemperature; TMVA::MsgLogger*fLoggermessage logger; Int_tfMaxCallsmaximum number of minimisation calls; Double_tfMinTemperaturemimimum temperature; Double_tfProgress; TRandom*fRandomrandom generator; const vector<TMVA::Interval*>&fRangesparameter ranges; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre); static TMVA::SimulatedAnnealing::EKernelTemperaturekDecreasingAdaptive; static TMVA::SimulatedAnnealing::EKernelTemperaturekGeo; static TMVA::SimulatedAnnealing::EKernelTemperaturekHomo; static TMVA::SimulatedAnnealing::EKernelTemperaturekIncreasingAdaptive; static TMVA::SimulatedAnnealing::EKernelTemperaturekLog; static TMVA::SimulatedAnnealing::EKernelTemperaturekSin; static TMVA::SimulatedAnnealing::EKernelTemperaturekSqrt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges); constructor. void SetOptions(Int_t maxCalls, Double_t initialTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Do",MatchSource.WIKI,root/html604/TMVA__SimulatedAnnealing.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SimulatedAnnealing.html
https://root.cern/root/html604/TMVA__SimulatedAnnealingFitter.html:1744,Availability,error,error,1744,"static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tTMVA::FitterBase::EstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::FitterBaseTMVA::FitterBase::FitterBase(const TMVA::FitterBase&); TMVA::FitterBaseTMVA::FitterBase::FitterBase(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*> ranges, const TString& theOption); const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TMVA::IFitterTarget&TMVA::FitterBase::GetFitterTarget() const; virtual const char*TObject::GetIconName() const; virtual const char*TMVA::FitterBase::GetName() const; Int_tTMVA::FitterBase::GetNpars() const; vi",MatchSource.WIKI,root/html604/TMVA__SimulatedAnnealingFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SimulatedAnnealingFitter.html
https://root.cern/root/html604/TMVA__SimulatedAnnealingFitter.html:1828,Availability,error,error,1828,"bject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tTMVA::FitterBase::EstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::FitterBaseTMVA::FitterBase::FitterBase(const TMVA::FitterBase&); TMVA::FitterBaseTMVA::FitterBase::FitterBase(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*> ranges, const TString& theOption); const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TMVA::IFitterTarget&TMVA::FitterBase::GetFitterTarget() const; virtual const char*TObject::GetIconName() const; virtual const char*TMVA::FitterBase::GetName() const; Int_tTMVA::FitterBase::GetNpars() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::G",MatchSource.WIKI,root/html604/TMVA__SimulatedAnnealingFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SimulatedAnnealingFitter.html
https://root.cern/root/html604/TMVA__SimulatedAnnealingFitter.html:9589,Deployability,configurat,configuration,9589,"dure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsrelative required FCN accuracy at minimum; Double_tfInitialTemperatureinitial temperature (depends on FCN); TStringfKernelTemperatureSstring just to set fKernelTemperature; Int_tfMaxCallsmax number of FCN calls; Double_tfMinTemperatureminimum temperature before SA quit; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealingFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); declare SA options. void SetParameters(Int_t fMaxCalls, Double_t fInitialTemperature, Double_t fMinTemperature, Double_t fEps, TString fKernelTemperatureS, Double_t fTemperatureScale, Double_t fTemperatureAdaptiveStep, Bool_t fUseDefaultScale, Bool_t fUseDefaultTemperature); set SA configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. SimulatedAnnealingFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); {}. » Author: Andreas Hoecker, Krzysztof Danielowski, Kamil Kraszewski, Maciej Kruk » Copyright (c) 2008: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__SimulatedAnnealingFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SimulatedAnnealingFitter.html
https://root.cern/root/html604/TMVA__SimulatedAnnealingFitter.html:8392,Energy Efficiency,adapt,adaptive,8392,"static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsrelative required FCN accuracy at minimum; Double_tfInitialTemperatureinitial temperature (depends on FCN); TStringfKernelTemperatureSstring just to set fKernelTemperature; Int_tfMaxCallsmax number of FCN calls; Double_tfMinTemperatureminimum temperature before SA quit; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealingFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); declare SA options. void SetParameters(Int_t fMaxCalls, Double_t fInitialTemperature, Double_t fMinTemperature, Double_t fEps, TString fKernelTemperatureS, Double_t fTemperatureScale, Double_t fTemperatureAdaptiveStep, Bool_t fUseDefaultScale, Bool_t fUseDefaultTemperature); set SA configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. SimulatedAnnealing",MatchSource.WIKI,root/html604/TMVA__SimulatedAnnealingFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SimulatedAnnealingFitter.html
https://root.cern/root/html604/TMVA__SimulatedAnnealingFitter.html:8405,Energy Efficiency,adapt,adaptive,8405,"static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsrelative required FCN accuracy at minimum; Double_tfInitialTemperatureinitial temperature (depends on FCN); TStringfKernelTemperatureSstring just to set fKernelTemperature; Int_tfMaxCallsmax number of FCN calls; Double_tfMinTemperatureminimum temperature before SA quit; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealingFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); declare SA options. void SetParameters(Int_t fMaxCalls, Double_t fInitialTemperature, Double_t fMinTemperature, Double_t fEps, TString fKernelTemperatureS, Double_t fTemperatureScale, Double_t fTemperatureAdaptiveStep, Bool_t fUseDefaultScale, Bool_t fUseDefaultTemperature); set SA configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. SimulatedAnnealing",MatchSource.WIKI,root/html604/TMVA__SimulatedAnnealingFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SimulatedAnnealingFitter.html
https://root.cern/root/html604/TMVA__SimulatedAnnealingFitter.html:8541,Integrability,depend,depends,8541,"static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsrelative required FCN accuracy at minimum; Double_tfInitialTemperatureinitial temperature (depends on FCN); TStringfKernelTemperatureSstring just to set fKernelTemperature; Int_tfMaxCallsmax number of FCN calls; Double_tfMinTemperatureminimum temperature before SA quit; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealingFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); declare SA options. void SetParameters(Int_t fMaxCalls, Double_t fInitialTemperature, Double_t fMinTemperature, Double_t fEps, TString fKernelTemperatureS, Double_t fTemperatureScale, Double_t fTemperatureAdaptiveStep, Bool_t fUseDefaultScale, Bool_t fUseDefaultTemperature); set SA configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. SimulatedAnnealing",MatchSource.WIKI,root/html604/TMVA__SimulatedAnnealingFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SimulatedAnnealingFitter.html
https://root.cern/root/html604/TMVA__SimulatedAnnealingFitter.html:8392,Modifiability,adapt,adaptive,8392,"static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsrelative required FCN accuracy at minimum; Double_tfInitialTemperatureinitial temperature (depends on FCN); TStringfKernelTemperatureSstring just to set fKernelTemperature; Int_tfMaxCallsmax number of FCN calls; Double_tfMinTemperatureminimum temperature before SA quit; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealingFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); declare SA options. void SetParameters(Int_t fMaxCalls, Double_t fInitialTemperature, Double_t fMinTemperature, Double_t fEps, TString fKernelTemperatureS, Double_t fTemperatureScale, Double_t fTemperatureAdaptiveStep, Bool_t fUseDefaultScale, Bool_t fUseDefaultTemperature); set SA configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. SimulatedAnnealing",MatchSource.WIKI,root/html604/TMVA__SimulatedAnnealingFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SimulatedAnnealingFitter.html
https://root.cern/root/html604/TMVA__SimulatedAnnealingFitter.html:8405,Modifiability,adapt,adaptive,8405,"static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsrelative required FCN accuracy at minimum; Double_tfInitialTemperatureinitial temperature (depends on FCN); TStringfKernelTemperatureSstring just to set fKernelTemperature; Int_tfMaxCallsmax number of FCN calls; Double_tfMinTemperatureminimum temperature before SA quit; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealingFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); declare SA options. void SetParameters(Int_t fMaxCalls, Double_t fInitialTemperature, Double_t fMinTemperature, Double_t fEps, TString fKernelTemperatureS, Double_t fTemperatureScale, Double_t fTemperatureAdaptiveStep, Bool_t fUseDefaultScale, Bool_t fUseDefaultTemperature); set SA configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. SimulatedAnnealing",MatchSource.WIKI,root/html604/TMVA__SimulatedAnnealingFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SimulatedAnnealingFitter.html
https://root.cern/root/html604/TMVA__SimulatedAnnealingFitter.html:8418,Modifiability,variab,variables,8418,"static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsrelative required FCN accuracy at minimum; Double_tfInitialTemperatureinitial temperature (depends on FCN); TStringfKernelTemperatureSstring just to set fKernelTemperature; Int_tfMaxCallsmax number of FCN calls; Double_tfMinTemperatureminimum temperature before SA quit; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealingFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); declare SA options. void SetParameters(Int_t fMaxCalls, Double_t fInitialTemperature, Double_t fMinTemperature, Double_t fEps, TString fKernelTemperatureS, Double_t fTemperatureScale, Double_t fTemperatureAdaptiveStep, Bool_t fUseDefaultScale, Bool_t fUseDefaultTemperature); set SA configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. SimulatedAnnealing",MatchSource.WIKI,root/html604/TMVA__SimulatedAnnealingFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SimulatedAnnealingFitter.html
https://root.cern/root/html604/TMVA__SimulatedAnnealingFitter.html:9589,Modifiability,config,configuration,9589,"dure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsrelative required FCN accuracy at minimum; Double_tfInitialTemperatureinitial temperature (depends on FCN); TStringfKernelTemperatureSstring just to set fKernelTemperature; Int_tfMaxCallsmax number of FCN calls; Double_tfMinTemperatureminimum temperature before SA quit; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealingFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); declare SA options. void SetParameters(Int_t fMaxCalls, Double_t fInitialTemperature, Double_t fMinTemperature, Double_t fEps, TString fKernelTemperatureS, Double_t fTemperatureScale, Double_t fTemperatureAdaptiveStep, Bool_t fUseDefaultScale, Bool_t fUseDefaultTemperature); set SA configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. SimulatedAnnealingFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); {}. » Author: Andreas Hoecker, Krzysztof Danielowski, Kamil Kraszewski, Maciej Kruk » Copyright (c) 2008: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__SimulatedAnnealingFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SimulatedAnnealingFitter.html
https://root.cern/root/html604/TMVA__SimulatedAnnealingFitter.html:8197,Testability,log,logger,8197,"ptionsReferenceToFile(). private:. virtual voidDeclareOptions(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsrelative required FCN accuracy at minimum; Double_tfInitialTemperatureinitial temperature (depends on FCN); TStringfKernelTemperatureSstring just to set fKernelTemperature; Int_tfMaxCallsmax number of FCN calls; Double_tfMinTemperatureminimum temperature before SA quit; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealingFitter(TMVA",MatchSource.WIKI,root/html604/TMVA__SimulatedAnnealingFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SimulatedAnnealingFitter.html
https://root.cern/root/html604/TMVA__StatDialogMVAEffs.html:2815,Modifiability,variab,variables,2815,"am); voidEmit(const char* signal, Float_t param); TStringGetFormula(); TStringGetFormulaString(); TStringGetLatexFormula(); TList*GetListOfSignals() const; voidHighPriority(const char* signal_name, const char* slot_name = 0); voidLowPriority(const char* signal_name, const char* slot_name = 0); voidMessage(const char* msg); TMVA::StatDialogMVAEffs&operator=(const TMVA::StatDialogMVAEffs&); voidPrintResults(const TMVA::MethodInfo* info); voidRaiseDialog(); voidReadHistograms(TFile* file); voidRedraw()SIGNAL ; voidSetFormula(const TString& f); voidSetNBackground()SIGNAL ; voidSetNSignal()SIGNAL ; TMVA::StatDialogMVAEffsStatDialogMVAEffs(const TMVA::StatDialogMVAEffs&); TMVA::StatDialogMVAEffsStatDialogMVAEffs(const TGWindow* p, Float_t ns, Float_t nb); voidUpdateSignificanceHists(). private:. voidUpdateCanvases(). Data Members; private:. TGNumberEntry*fBkgInput; TGHorizontalFrame*fButtons; TGTextButton*fCloseButton; TGTextButton*fDrawButton; TStringfFormula; TList*fInfoList; TGMainFrame*fMain; Float_tfNBackground; Float_tfNSignal; TQObjSenderfQObject; TGNumberEntry*fSigInput; Int_tmaxLenTitle. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetNSignal(). void SetNBackground(). TString GetFormula(). TString GetLatexFormula(). void Redraw(). void Close(). ~StatDialogMVAEffs(). StatDialogMVAEffs(const TGWindow* p, Float_t ns, Float_t nb). void UpdateCanvases(). void UpdateSignificanceHists(). void ReadHistograms(TFile* file). void DrawHistograms(); counter variables. void PrintResults(const TMVA::MethodInfo* info). StatDialogMVAEffs(const TGWindow* p, Float_t ns, Float_t nb). void SetFormula(const TString& f); { fFormula = f; }. TString GetFormulaString(); { return fFormula; }. void RaiseDialog(). » Last changed: Tue Sep 8 17:46:05 2015 » Last generated: 2015-09-08 17:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__StatDialogMVAEffs.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__StatDialogMVAEffs.html
https://root.cern/root/html604/TMVA__SVEvent.html:2007,Modifiability,variab,variables,2007,"intData(); voidSetAlpha(Float_t alpha); voidSetAlpha_p(Float_t alpha); voidSetErrorCache(Float_t err_cache); voidSetIdx(Int_t idx); voidSetIsShrinked(Int_t isshrinked); voidSetLine(Float_t* line); voidSetNs(UInt_t ns); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMVA::SVEventSVEvent(); TMVA::SVEventSVEvent(const TMVA::SVEvent&); TMVA::SVEventSVEvent(const TMVA::Event*, Float_t, Bool_t isSignal = kFALSE); TMVA::SVEventSVEvent(const vector<Float_t>*, Float_t alpha, Int_t typeFlag, UInt_t ns); TMVA::SVEventSVEvent(const vector<Float_t>* svector, Float_t alpha, Float_t alpha_p, Int_t typeFlag); voidUpdateErrorCache(Float_t upercache). Data Members; private:. Float_tfAlphalagrange multiplier; Float_tfAlpha_plagrange multiplier; const Float_tfCweightsvm cost weight; vector<Float_t>fDataVector; Float_tfErrorCacheoptimization parameter; Int_tfIdxindex flag; Int_tfIsShrinkedshrinking flag, see documentation; Float_t*fLinepointer to column of kerenl matrix; UInt_tfNVarnumber of variables; UInt_tfNsdocumentation; const Float_tfTargetregression target; const Int_tfTypeFlagis sig or bkg - svm requieres 1 for sig and -1 for bkg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVEvent(). SVEvent(const TMVA::Event* , Float_t , Bool_t isSignal = kFALSE); constructor. SVEvent(const vector<Float_t>* , Float_t alpha, Int_t typeFlag, UInt_t ns); constructor. SVEvent(const vector<Float_t>* svector, Float_t alpha, Float_t alpha_p, Int_t typeFlag); constructor. ~SVEvent(); destructor. void Print(ostream& os) const; printout. void PrintData(); printout. SVEvent(). void SetAlpha(Float_t alpha); { fAlpha = alpha; }. void SetAlpha_p(Float_t alpha); { fAlpha_p = alpha; }. void SetErrorCache(Float_t err_cache); { fErrorCache = err_cache; }. void SetIsShrinked(Int_t isshrinked); { fIsShrinked = isshrinked; }. void SetLine(Float_t* line); { fLine = line;",MatchSource.WIKI,root/html604/TMVA__SVEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__SVEvent.html
https://root.cern/root/html604/TMVA__TActivation.html:430,Availability,avail,available,430,". TMVA::TActivation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::TActivation. class TMVA::TActivation. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TActivation(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivation&operator=(const TMVA::TActivation&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMVA::TActivationTActivation(); TMVA::TActivationTActivation(const TMVA::TActivation&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivation(); {}. virtual ~TActivation(); {}. Double_t Eval(Double_t arg); evaluate the activation function. Double_t EvalDerivative(Double_t arg); evaulate the derivative of the activation function. Double_t GetMin(); minimum of the range of activation function. Double_t GetMax(); maximum of the range of the activation function. TString GetExpression(); expression for activation function. void MakeFunction(ostream& fout, const TString& fncName); writer of function code. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__TActivation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TActivation.html
https://root.cern/root/html604/TMVA__TActivationChooser.html:1461,Integrability,message,message,1461,s*Class(); TMVA::TActivation*CreateActivation(TMVA::TActivationChooser::EActivationType type) const; TMVA::TActivation*CreateActivation(const TString& type) const; vector<TString>*GetAllActivationNames() const; virtual TClass*IsA() const; TMVA::TActivationChooser&operator=(const TMVA::TActivationChooser&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMVA::TActivationChooserTActivationChooser(); TMVA::TActivationChooserTActivationChooser(const TMVA::TActivationChooser&). private:. TMVA::MsgLogger&Log() const. Data Members; public:. static TMVA::TActivationChooser::EActivationTypekLinear; static TMVA::TActivationChooser::EActivationTypekRadial; static TMVA::TActivationChooser::EActivationTypekReLU; static TMVA::TActivationChooser::EActivationTypekSigmoid; static TMVA::TActivationChooser::EActivationTypekTanh. private:. TStringfLINEARactivation function name; TMVA::MsgLogger*fLogger! message logger; TStringfRADIALactivation function name; TStringfRELUactivation function name; TStringfSIGMOIDactivation function name; TStringfTANHactivation function name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivationChooser(); defaut constructor. ~TActivationChooser(); destructor. CreateActivation(EActivationType type); instantiate the correct activation object according to the; type choosen (given as the enumeration type). CreateActivation(const TString& type) const; instantiate the correct activation object according to the; type choosen (given by a TString). GetAllActivationNames() const; retuns the names of all know activation functions. TActivationChooser(). » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-09-08 17:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root/html604/TMVA__TActivationChooser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TActivationChooser.html
https://root.cern/root/html604/TMVA__TActivationChooser.html:1469,Testability,log,logger,1469,s*Class(); TMVA::TActivation*CreateActivation(TMVA::TActivationChooser::EActivationType type) const; TMVA::TActivation*CreateActivation(const TString& type) const; vector<TString>*GetAllActivationNames() const; virtual TClass*IsA() const; TMVA::TActivationChooser&operator=(const TMVA::TActivationChooser&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMVA::TActivationChooserTActivationChooser(); TMVA::TActivationChooserTActivationChooser(const TMVA::TActivationChooser&). private:. TMVA::MsgLogger&Log() const. Data Members; public:. static TMVA::TActivationChooser::EActivationTypekLinear; static TMVA::TActivationChooser::EActivationTypekRadial; static TMVA::TActivationChooser::EActivationTypekReLU; static TMVA::TActivationChooser::EActivationTypekSigmoid; static TMVA::TActivationChooser::EActivationTypekTanh. private:. TStringfLINEARactivation function name; TMVA::MsgLogger*fLogger! message logger; TStringfRADIALactivation function name; TStringfRELUactivation function name; TStringfSIGMOIDactivation function name; TStringfTANHactivation function name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivationChooser(); defaut constructor. ~TActivationChooser(); destructor. CreateActivation(EActivationType type); instantiate the correct activation object according to the; type choosen (given as the enumeration type). CreateActivation(const TString& type) const; instantiate the correct activation object according to the; type choosen (given by a TString). GetAllActivationNames() const; retuns the names of all know activation functions. TActivationChooser(). » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-09-08 17:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root/html604/TMVA__TActivationChooser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TActivationChooser.html
https://root.cern/root/html604/TMVA__TActivationRadial.html:485,Energy Efficiency,efficient,efficient,485,". TMVA::TActivationRadial. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::TActivationRadial. class TMVA::TActivationRadial: public TMVA::TActivation. Radial basis activation function for ANN. This really simple implementation; uses TFormulas and should probably be replaced with something more; efficient later. Function Members (Methods); public:. virtual~TActivationRadial(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivationRadial&operator=(const TMVA::TActivationRadial&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMVA::TActivationTMVA::TActivation::TActivation(); TMVA::TActivationTMVA::TActivation::TActivation(const TMVA::TActivation&); TMVA::TActivationRadialTActivationRadial(); TMVA::TActivationRadialTActivationRadial(const TMVA::TActivationRadial&). Data Members; private:. TFormula*fEqnequation of radial basis function; TFormula*fEqnDerivativeequation of derivative. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivationRadial(); constructor for gaussian with center 0, width 1. ~TActivationRadial(); destructor. Double_t Eval(Double_t arg); evaluate gaussian. Double_t EvalDerivative(Double_t arg); evaluate derivative. TString GetExpression(); get expressions for the gaussian and its derivatives. void MakeFunction(ostream& fout, const TString& fncName); writes the sigmoid activation function source code. TActivationRadial(). Double_t GetMin(); minimum of the range of the activation fun",MatchSource.WIKI,root/html604/TMVA__TActivationRadial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TActivationRadial.html
https://root.cern/root/html604/TMVA__TActivationRadial.html:394,Usability,simpl,simple,394,". TMVA::TActivationRadial. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::TActivationRadial. class TMVA::TActivationRadial: public TMVA::TActivation. Radial basis activation function for ANN. This really simple implementation; uses TFormulas and should probably be replaced with something more; efficient later. Function Members (Methods); public:. virtual~TActivationRadial(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivationRadial&operator=(const TMVA::TActivationRadial&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMVA::TActivationTMVA::TActivation::TActivation(); TMVA::TActivationTMVA::TActivation::TActivation(const TMVA::TActivation&); TMVA::TActivationRadialTActivationRadial(); TMVA::TActivationRadialTActivationRadial(const TMVA::TActivationRadial&). Data Members; private:. TFormula*fEqnequation of radial basis function; TFormula*fEqnDerivativeequation of derivative. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivationRadial(); constructor for gaussian with center 0, width 1. ~TActivationRadial(); destructor. Double_t Eval(Double_t arg); evaluate gaussian. Double_t EvalDerivative(Double_t arg); evaluate derivative. TString GetExpression(); get expressions for the gaussian and its derivatives. void MakeFunction(ostream& fout, const TString& fncName); writes the sigmoid activation function source code. TActivationRadial(). Double_t GetMin(); minimum of the range of the activation fun",MatchSource.WIKI,root/html604/TMVA__TActivationRadial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TActivationRadial.html
https://root.cern/root/html604/TMVA__TActivationSigmoid.html:487,Energy Efficiency,efficient,efficient,487,". TMVA::TActivationSigmoid. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::TActivationSigmoid. class TMVA::TActivationSigmoid: public TMVA::TActivation. Sigmoid activation function for TNeuron. This really simple implementation; uses TFormulas and should probably be replaced with something more; efficient later. Function Members (Methods); public:. virtual~TActivationSigmoid(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivationSigmoid&operator=(const TMVA::TActivationSigmoid&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMVA::TActivationTMVA::TActivation::TActivation(); TMVA::TActivationTMVA::TActivation::TActivation(const TMVA::TActivation&); TMVA::TActivationSigmoidTActivationSigmoid(); TMVA::TActivationSigmoidTActivationSigmoid(const TMVA::TActivationSigmoid&). Data Members; private:. TFormula*fEqnequation of sigmoid; TFormula*fEqnDerivativeequation of sigmoid derivative. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivationSigmoid(); constructor for sigmoid normalized in [0,1]. ~TActivationSigmoid(); destructor. Double_t Eval(Double_t arg); evaluate the sigmoid. Double_t EvalDerivative(Double_t arg); evaluate the derivative of the sigmoid. TString GetExpression(); get expressions for the sigmoid and its derivatives. void MakeFunction(ostream& fout, const TString& fncName); writes the sigmoid activation function source code. TActivationSigmoid(). Double_t GetMin(); minimum of the ran",MatchSource.WIKI,root/html604/TMVA__TActivationSigmoid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TActivationSigmoid.html
https://root.cern/root/html604/TMVA__TActivationSigmoid.html:396,Usability,simpl,simple,396,". TMVA::TActivationSigmoid. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::TActivationSigmoid. class TMVA::TActivationSigmoid: public TMVA::TActivation. Sigmoid activation function for TNeuron. This really simple implementation; uses TFormulas and should probably be replaced with something more; efficient later. Function Members (Methods); public:. virtual~TActivationSigmoid(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivationSigmoid&operator=(const TMVA::TActivationSigmoid&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMVA::TActivationTMVA::TActivation::TActivation(); TMVA::TActivationTMVA::TActivation::TActivation(const TMVA::TActivation&); TMVA::TActivationSigmoidTActivationSigmoid(); TMVA::TActivationSigmoidTActivationSigmoid(const TMVA::TActivationSigmoid&). Data Members; private:. TFormula*fEqnequation of sigmoid; TFormula*fEqnDerivativeequation of sigmoid derivative. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivationSigmoid(); constructor for sigmoid normalized in [0,1]. ~TActivationSigmoid(); destructor. Double_t Eval(Double_t arg); evaluate the sigmoid. Double_t EvalDerivative(Double_t arg); evaluate the derivative of the sigmoid. TString GetExpression(); get expressions for the sigmoid and its derivatives. void MakeFunction(ostream& fout, const TString& fncName); writes the sigmoid activation function source code. TActivationSigmoid(). Double_t GetMin(); minimum of the ran",MatchSource.WIKI,root/html604/TMVA__TActivationSigmoid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TActivationSigmoid.html
https://root.cern/root/html604/TMVA__TActivationTanh.html:471,Energy Efficiency,efficient,efficient,471,". TMVA::TActivationTanh. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::TActivationTanh. class TMVA::TActivationTanh: public TMVA::TActivation. Tanh activation function for ANN. This really simple implementation; uses TFormulas and should probably be replaced with something more; efficient later. Function Members (Methods); public:. virtual~TActivationTanh(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivationTanh&operator=(const TMVA::TActivationTanh&); voidSetSlow(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMVA::TActivationTMVA::TActivation::TActivation(); TMVA::TActivationTMVA::TActivation::TActivation(const TMVA::TActivation&); TMVA::TActivationTanhTActivationTanh(); TMVA::TActivationTanhTActivationTanh(const TMVA::TActivationTanh&). private:. Double_tfast_tanh(Double_t arg). Data Members; private:. Bool_tfFAST. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivationTanh(); constructor for tanh sigmoid (normalized in [-1,1]). ~TActivationTanh(); destructor. Double_t fast_tanh(Double_t arg); a fast tanh approximation. Double_t Eval(Double_t arg); evaluate the tanh. Double_t EvalDerivative(Double_t arg); evaluate the derivative. TString GetExpression(); get expressions for the tanh and its derivative; whatever that may be good for ... void MakeFunction(ostream& fout, const TString& fncName); writes the sigmoid activation function source code. TActivationTanh(). Double_t GetMin(); mini",MatchSource.WIKI,root/html604/TMVA__TActivationTanh.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TActivationTanh.html
https://root.cern/root/html604/TMVA__TActivationTanh.html:380,Usability,simpl,simple,380,". TMVA::TActivationTanh. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::TActivationTanh. class TMVA::TActivationTanh: public TMVA::TActivation. Tanh activation function for ANN. This really simple implementation; uses TFormulas and should probably be replaced with something more; efficient later. Function Members (Methods); public:. virtual~TActivationTanh(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivationTanh&operator=(const TMVA::TActivationTanh&); voidSetSlow(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMVA::TActivationTMVA::TActivation::TActivation(); TMVA::TActivationTMVA::TActivation::TActivation(const TMVA::TActivation&); TMVA::TActivationTanhTActivationTanh(); TMVA::TActivationTanhTActivationTanh(const TMVA::TActivationTanh&). private:. Double_tfast_tanh(Double_t arg). Data Members; private:. Bool_tfFAST. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivationTanh(); constructor for tanh sigmoid (normalized in [-1,1]). ~TActivationTanh(); destructor. Double_t fast_tanh(Double_t arg); a fast tanh approximation. Double_t Eval(Double_t arg); evaluate the tanh. Double_t EvalDerivative(Double_t arg); evaluate the derivative. TString GetExpression(); get expressions for the tanh and its derivative; whatever that may be good for ... void MakeFunction(ostream& fout, const TString& fncName); writes the sigmoid activation function source code. TActivationTanh(). Double_t GetMin(); mini",MatchSource.WIKI,root/html604/TMVA__TActivationTanh.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TActivationTanh.html
https://root.cern/root/html604/TMVA__Timer.html:2016,Availability,error,error,2016,"er* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidTStopwatch::Continue(); virtual voidTObject::Copy(TObject& object) const; Int_tTStopwatch::Counter() const; Double_tTStopwatch::CpuTime(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawProgressBar(); voidDrawProgressBar(TString); voidDrawProgressBar(Int_t, const TString& comment = """"); virtual voidTObject::Dump() constMENU ; Double_tElapsedSeconds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringGetElapsedTime(Bool_t Scientific = kTRUE); virtual const char*TObject::GetIconName() const; TStringGetLeftTime(Int_t icounts); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, cons",MatchSource.WIKI,root/html604/TMVA__Timer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Timer.html
https://root.cern/root/html604/TMVA__Timer.html:2100,Availability,error,error,2100,"l voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidTStopwatch::Continue(); virtual voidTObject::Copy(TObject& object) const; Int_tTStopwatch::Counter() const; Double_tTStopwatch::CpuTime(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawProgressBar(); voidDrawProgressBar(TString); voidDrawProgressBar(Int_t, const TString& comment = """"); virtual voidTObject::Dump() constMENU ; Double_tElapsedSeconds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringGetElapsedTime(Bool_t Scientific = kTRUE); virtual const char*TObject::GetIconName() const; TStringGetLeftTime(Int_t icounts); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) co",MatchSource.WIKI,root/html604/TMVA__Timer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Timer.html
https://root.cern/root/html604/TMVA__Timer.html:6944,Testability,log,logger,6944,"bject::MakeZombie(). private:. TMVA::MsgLogger&Log() const; TStringSecToText(Double_t, Bool_t) const. Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Bool_tfColourfulOutputflag for use of colors; TMVA::MsgLogger*fLoggerthe output logger; Int_tfNcountsreference number of ""counts""; TStringfPrefixprefix for outputs; static const TStringfgClassNameused for output; static const Int_tfgNbinsnumber of bins in progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Timer(const char* prefix = """", Bool_t colourfulOutput = kTRUE); constructor. Timer(Int_t ncounts, const char* prefix = """", Bool_t colourfulOutput = kTRUE); standard constructor: ncounts gives the total number of counts that; the loop will iterate through. At each call of the timer, the current; number of counts is provided by the user, so that the timer can obtain; the due time from linearly interpolating the spent time. ~Timer( void ); destructor. void Init(Int_t ncounts); timer initialisation. void Reset( void ); resets timer. Double_t ElapsedSeconds( void ); computes elapsed tim in seconds. TString GetElapsedTime(Bool_t Scientific = kTRUE); returns pretty string with elaplsed time. TString GetLeftTime(Int_t icounts); returns pretty string with time left. void ",MatchSource.WIKI,root/html604/TMVA__Timer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Timer.html
https://root.cern/root/html604/TMVA__Timer.html:479,Usability,progress bar,progress bar,479,". TMVA::Timer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::Timer. class TMVA::Timer: public TStopwatch. Timing information for training and evaluation of MVA methods. Usage:. TMVA::Timer timer( Nloops, ""MyClassName"" );; for (Int_t i=0; i<Nloops; i++) {; ... // some code. // now, print progress bar:; timer.DrawProgressBar( i );. // **OR** text output of left time (never both !); fLogger << "" time left: "" << timer.GetLeftTime( i ) << Endl;. }; fLogger << ""MyClassName"" << "": elapsed time: "" << timer.GetElapsedTime(); << Endl;. Remark: in batch mode, the progress bar is quite ugly; you may; want to use the text output then. Function Members (Methods); public:. virtual~Timer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidTStopwatch::Continue(); virtual voidTObject::Copy(TObject& object) const; Int_tTStopwatch::Counter() const; Double_tTStopwatch::CpuTime(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawProgressBar(); voidDrawProgressBar(TString); voidDrawProgressBar(Int_t, const TString& comment = """"); virtual voidTObject::Dump() constMENU ; Double_tElapsedSeconds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* ",MatchSource.WIKI,root/html604/TMVA__Timer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Timer.html
https://root.cern/root/html604/TMVA__Timer.html:750,Usability,progress bar,progress bar,750,". TMVA::Timer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::Timer. class TMVA::Timer: public TStopwatch. Timing information for training and evaluation of MVA methods. Usage:. TMVA::Timer timer( Nloops, ""MyClassName"" );; for (Int_t i=0; i<Nloops; i++) {; ... // some code. // now, print progress bar:; timer.DrawProgressBar( i );. // **OR** text output of left time (never both !); fLogger << "" time left: "" << timer.GetLeftTime( i ) << Endl;. }; fLogger << ""MyClassName"" << "": elapsed time: "" << timer.GetElapsedTime(); << Endl;. Remark: in batch mode, the progress bar is quite ugly; you may; want to use the text output then. Function Members (Methods); public:. virtual~Timer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidTStopwatch::Continue(); virtual voidTObject::Copy(TObject& object) const; Int_tTStopwatch::Counter() const; Double_tTStopwatch::CpuTime(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawProgressBar(); voidDrawProgressBar(TString); voidDrawProgressBar(Int_t, const TString& comment = """"); virtual voidTObject::Dump() constMENU ; Double_tElapsedSeconds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* ",MatchSource.WIKI,root/html604/TMVA__Timer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Timer.html
https://root.cern/root/html604/TMVA__Timer.html:7120,Usability,progress bar,progress bar,7120,"bject::MakeZombie(). private:. TMVA::MsgLogger&Log() const; TStringSecToText(Double_t, Bool_t) const. Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Bool_tfColourfulOutputflag for use of colors; TMVA::MsgLogger*fLoggerthe output logger; Int_tfNcountsreference number of ""counts""; TStringfPrefixprefix for outputs; static const TStringfgClassNameused for output; static const Int_tfgNbinsnumber of bins in progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Timer(const char* prefix = """", Bool_t colourfulOutput = kTRUE); constructor. Timer(Int_t ncounts, const char* prefix = """", Bool_t colourfulOutput = kTRUE); standard constructor: ncounts gives the total number of counts that; the loop will iterate through. At each call of the timer, the current; number of counts is provided by the user, so that the timer can obtain; the due time from linearly interpolating the spent time. ~Timer( void ); destructor. void Init(Int_t ncounts); timer initialisation. void Reset( void ); resets timer. Double_t ElapsedSeconds( void ); computes elapsed tim in seconds. TString GetElapsedTime(Bool_t Scientific = kTRUE); returns pretty string with elaplsed time. TString GetLeftTime(Int_t icounts); returns pretty string with time left. void ",MatchSource.WIKI,root/html604/TMVA__Timer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Timer.html
https://root.cern/root/html604/TMVA__Timer.html:8094,Usability,progress bar,progress bar,8094,"ect::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Bool_tfColourfulOutputflag for use of colors; TMVA::MsgLogger*fLoggerthe output logger; Int_tfNcountsreference number of ""counts""; TStringfPrefixprefix for outputs; static const TStringfgClassNameused for output; static const Int_tfgNbinsnumber of bins in progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Timer(const char* prefix = """", Bool_t colourfulOutput = kTRUE); constructor. Timer(Int_t ncounts, const char* prefix = """", Bool_t colourfulOutput = kTRUE); standard constructor: ncounts gives the total number of counts that; the loop will iterate through. At each call of the timer, the current; number of counts is provided by the user, so that the timer can obtain; the due time from linearly interpolating the spent time. ~Timer( void ); destructor. void Init(Int_t ncounts); timer initialisation. void Reset( void ); resets timer. Double_t ElapsedSeconds( void ); computes elapsed tim in seconds. TString GetElapsedTime(Bool_t Scientific = kTRUE); returns pretty string with elaplsed time. TString GetLeftTime(Int_t icounts); returns pretty string with time left. void DrawProgressBar(); draws the progressbar. void DrawProgressBar(TString ); draws a string in the progress bar. void DrawProgressBar(Int_t , const TString& comment = """"); draws progress bar in color or B&W; caution:. TString SecToText(Double_t , Bool_t ) const; pretty string output. Timer(const char* prefix = """", Bool_t colourfulOutput = kTRUE). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2006: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__Timer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Timer.html
https://root.cern/root/html604/TMVA__Timer.html:8173,Usability,progress bar,progress bar,8173,"ect::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Bool_tfColourfulOutputflag for use of colors; TMVA::MsgLogger*fLoggerthe output logger; Int_tfNcountsreference number of ""counts""; TStringfPrefixprefix for outputs; static const TStringfgClassNameused for output; static const Int_tfgNbinsnumber of bins in progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Timer(const char* prefix = """", Bool_t colourfulOutput = kTRUE); constructor. Timer(Int_t ncounts, const char* prefix = """", Bool_t colourfulOutput = kTRUE); standard constructor: ncounts gives the total number of counts that; the loop will iterate through. At each call of the timer, the current; number of counts is provided by the user, so that the timer can obtain; the due time from linearly interpolating the spent time. ~Timer( void ); destructor. void Init(Int_t ncounts); timer initialisation. void Reset( void ); resets timer. Double_t ElapsedSeconds( void ); computes elapsed tim in seconds. TString GetElapsedTime(Bool_t Scientific = kTRUE); returns pretty string with elaplsed time. TString GetLeftTime(Int_t icounts); returns pretty string with time left. void DrawProgressBar(); draws the progressbar. void DrawProgressBar(TString ); draws a string in the progress bar. void DrawProgressBar(Int_t , const TString& comment = """"); draws progress bar in color or B&W; caution:. TString SecToText(Double_t , Bool_t ) const; pretty string output. Timer(const char* prefix = """", Bool_t colourfulOutput = kTRUE). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2006: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__Timer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Timer.html
https://root.cern/root/html604/TMVA__TNeuron.html:2199,Availability,error,error,2199,"ynapse* pre); voidAdjustSynapseWeights(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalculateActivationValue(); voidCalculateDelta(); voidCalculateValue(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeletePreLinks(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidForceValue(Double_t value); Double_tGetActivationValue() const; Double_tGetDEDw() const; Double_tGetDelta() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetValue() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash",MatchSource.WIKI,root/html604/TMVA__TNeuron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TNeuron.html
https://root.cern/root/html604/TMVA__TNeuron.html:2283,Availability,error,error,2283,"ption = """"); virtual voidTObject::Browse(TBrowser* b); voidCalculateActivationValue(); voidCalculateDelta(); voidCalculateValue(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeletePreLinks(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidForceValue(Double_t value); Double_tGetActivationValue() const; Double_tGetDEDw() const; Double_tGetDelta() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetValue() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; v",MatchSource.WIKI,root/html604/TMVA__TNeuron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TNeuron.html
https://root.cern/root/html604/TMVA__TNeuron.html:5406,Availability,error,error,5406,"ct::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::TNeuron&operator=(const TMVA::TNeuron&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); TMVA::TSynapse*PostLinkAt(Int_t index) const; TMVA::TSynapse*PreLinkAt(Int_t index) const; virtual voidPrint(Option_t* = """") const; voidPrintActivationEqn(); voidPrintPostLinks() const; voidPrintPreLinks() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetActivationEqn(TMVA::TActivation* activation); voidSetBiasNeuron(); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetDEDw(Double_t DEDw); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetError(Double_t error); voidSetInputCalculator(TMVA::TNeuronInput* calculator); voidSetInputNeuron(); static voidTObject::SetObjectStat(Bool_t stat); voidSetOutputNeuron(); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMVA::TNeuronTNeuron(); TMVA::TNeuronTNeuron(const TMVA::TNeuron&); voidUpdateSynapsesBatch(); voidUpdateSynapsesSequential(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TMVA__TNeuron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TNeuron.html
https://root.cern/root/html604/TMVA__TNeuron.html:8461,Availability,error,error,8461,"sOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TMVA::TActivation*fActivationactivation equation; Double_tfActivationValueactivation/output value; Double_tfDEDwsum of all deltas; Double_tfDeltaerror field of neuron; Double_tfErrorerror, only set for output neurons; Bool_tfForcedValueflag for forced input value; TMVA::TNeuronInput*fInputCalculatorinput calculator; TObjArray*fLinksInarray of input synapses; TObjArray*fLinksOutarray of output synapses; Double_tfValueinput value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNeuron(TNeuron::ENeuronType type /*= kSigmoid*/, const char* name /*= """"*/, const char* title /*= """"*/, const char* extF /*= """"*/, const char* extD /*= """"*/ ); Usual constructor. Double_t GetValue() const; Computes the output using the appropriate function and all; the weighted inputs, or uses the branch as input.; In that case, the branch normalisation is also used. void SetDEDw(Double_t DEDw); Sets the derivative of the total error wrt the neuron weight. TNeuron(ENeuronType type = kSigmoid, const char* name = """", const char* title = """", const char* extF = """", const char* extD = """" ); {}. Double_t GetDEDw() const; { return fDEDw; }. TNeuron& operator=(const TMVA::TNeuron& ). » Author: Christophe.Delaere@cern.ch 20/07/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/mlp:$Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__TNeuron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TNeuron.html
https://root.cern/root/html604/TMVA__TNeuron.html:6730,Integrability,message,message,6730,"rtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMVA::TNeuronTNeuron(); TMVA::TNeuronTNeuron(const TMVA::TNeuron&); voidUpdateSynapsesBatch(); voidUpdateSynapsesSequential(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. voidDeleteLinksArray(TObjArray*& links); voidInitNeuron(); TMVA::MsgLogger&Log() const; voidNullifyLinks(TObjArray*& links); Int_tNumLinks(TObjArray* links) const; voidPrintLinks(TObjArray* links) const; voidPrintMessage(TMVA::EMsgType, TString message). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TMVA::TActivation*fActivationactivation equation; Double_tfActivationValueactivation/output value; Double_tf",MatchSource.WIKI,root/html604/TMVA__TNeuron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TNeuron.html
https://root.cern/root/html604/TMVA__TNeuronInput.html:433,Availability,avail,available,433,". TMVA::TNeuronInput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::TNeuronInput. class TMVA::TNeuronInput. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TNeuronInput(); static TClass*Class(); virtual Double_tGetInput(const TMVA::TNeuron* neuron) const; virtual TStringGetName(); virtual TClass*IsA() const; TMVA::TNeuronInput&operator=(const TMVA::TNeuronInput&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMVA::TNeuronInputTNeuronInput(); TMVA::TNeuronInputTNeuronInput(const TMVA::TNeuronInput&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNeuronInput(); {}. virtual ~TNeuronInput(); {}. Double_t GetInput(const TMVA::TNeuron* neuron) const; calculate input value for neuron. TString GetName(); name of class. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__TNeuronInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TNeuronInput.html
https://root.cern/root/html604/TMVA__Tools.html:10802,Availability,avail,available,10802,"egular expressions; helper function to remove all occurences ""$!%^&()'<>?= "" from a string; and replace all ::,$,*,/,+,- with _M_,_S_,_T_,_D_,_P_,_M_ respectively. const TString& Color(const TString& ); human readable color strings. void FormattedOutput(const vector<Double_t>& , const vector<TString>& , const TString titleVars, const TString titleValues, TMVA::MsgLogger& logger, TString format = ""%+1.3f""); formatted output of simple table. void FormattedOutput(const TMatrixD& , const vector<TString>& , TMVA::MsgLogger& logger); formatted output of matrix (with labels). void FormattedOutput(const TMatrixD& , const vector<TString>& vert, const vector<TString>& horiz, TMVA::MsgLogger& logger); formatted output of matrix (with labels). TString GetXTitleWithUnit(const TString& title, const TString& unit); histogramming utility. TString GetYTitleWithUnit(const TH1& h, const TString& unit, Bool_t normalised); histogramming utility. void WriteFloatArbitraryPrecision(Float_t val, ostream& os); writes a float value with the available precision to a stream. void ReadFloatArbitraryPrecision(Float_t& val, istream& is); reads a float value with the available precision from a stream. Bool_t HasAttr(void* node, const char* attrname); add attribute from xml. void ReadAttr(void* node, const char* attrname, TString& value); add attribute from xml. void AddAttr(void* node, const char* attrname, const char* value); add attribute to node. void* AddChild(void* parent, const char* childname, const char* content = 0, bool isRootNode = false); add child node. Bool_t AddComment(void* node, const char* comment). void* GetParent(void* child); get parent node. void* GetChild(void* parent, const char* childname = 0); get child node. void* GetNextChild(void* prevchild, const char* childname = 0); XML helpers. const char* GetContent(void* node); XML helpers. const char* GetName(void* node); XML helpers. Bool_t AddRawLine(void* node, const char* raw); XML helpers. std::vector<TString> SplitString(co",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:10925,Availability,avail,available,10925,"h _M_,_S_,_T_,_D_,_P_,_M_ respectively. const TString& Color(const TString& ); human readable color strings. void FormattedOutput(const vector<Double_t>& , const vector<TString>& , const TString titleVars, const TString titleValues, TMVA::MsgLogger& logger, TString format = ""%+1.3f""); formatted output of simple table. void FormattedOutput(const TMatrixD& , const vector<TString>& , TMVA::MsgLogger& logger); formatted output of matrix (with labels). void FormattedOutput(const TMatrixD& , const vector<TString>& vert, const vector<TString>& horiz, TMVA::MsgLogger& logger); formatted output of matrix (with labels). TString GetXTitleWithUnit(const TString& title, const TString& unit); histogramming utility. TString GetYTitleWithUnit(const TH1& h, const TString& unit, Bool_t normalised); histogramming utility. void WriteFloatArbitraryPrecision(Float_t val, ostream& os); writes a float value with the available precision to a stream. void ReadFloatArbitraryPrecision(Float_t& val, istream& is); reads a float value with the available precision from a stream. Bool_t HasAttr(void* node, const char* attrname); add attribute from xml. void ReadAttr(void* node, const char* attrname, TString& value); add attribute from xml. void AddAttr(void* node, const char* attrname, const char* value); add attribute to node. void* AddChild(void* parent, const char* childname, const char* content = 0, bool isRootNode = false); add child node. Bool_t AddComment(void* node, const char* comment). void* GetParent(void* child); get parent node. void* GetChild(void* parent, const char* childname = 0); get child node. void* GetNextChild(void* prevchild, const char* childname = 0); XML helpers. const char* GetContent(void* node); XML helpers. const char* GetName(void* node); XML helpers. Bool_t AddRawLine(void* node, const char* raw); XML helpers. std::vector<TString> SplitString(const TString& theOpt, const char separator) const; splits the option string at 'separator' and fills the list; 'splitV' with t",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:9131,Deployability,configurat,configuration,9131,"ecessary to have the first vector sorted.; I.e. the correlation between the elements is kept. void UsefulSortDescending(vector<vector<Double_t> >& , vector<TString>* vs = 0); sort 2D vector (AND in parallel a TString vector) in such a way; that the ""first vector is sorted"" and the other vectors are reshuffled; in the same way as necessary to have the first vector sorted.; I.e. the correlation between the elements is kept. Double_t GetMutualInformation(const TH2F& ); Mutual Information method for non-linear correlations estimates in 2D histogram; Author: Moritz Backes, Geneva (2009). Double_t GetCorrelationRatio(const TH2F& ); Compute Correlation Ratio of 2D histogram to estimate functional dependency between two variables; Author: Moritz Backes, Geneva (2009). Double_t GetYMean_binX(const TH2& , Int_t bin_x); Compute the mean in Y for a given bin X of a 2D histogram. TH2F* TransposeHist(const TH2F& ); Transpose quadratic histogram. Bool_t CheckForSilentOption(const TString& ) const; check for ""silence"" option in configuration option string. Bool_t CheckForVerboseOption(const TString& ) const; check if verbosity ""V"" set in option. void UsefulSortDescending(vector<Double_t>& ); sort vector. void UsefulSortAscending(vector<Double_t>& ); sort vector. Int_t GetIndexMaxElement(vector<Double_t>& ); find index of maximum entry in vector. Int_t GetIndexMinElement(vector<Double_t>& ); find index of minimum entry in vector. Bool_t ContainsRegularExpression(const TString& s); check if regular expression; helper function to search for ""$!%^&()'<>?= "" in a string. TString ReplaceRegularExpressions(const TString& s, const TString& replace = ""+""); replace regular expressions; helper function to remove all occurences ""$!%^&()'<>?= "" from a string; and replace all ::,$,*,/,+,- with _M_,_S_,_T_,_D_,_P_,_M_ respectively. const TString& Color(const TString& ); human readable color strings. void FormattedOutput(const vector<Double_t>& , const vector<TString>& , const TString titleVars, co",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:12478,Deployability,release,release,12478,"nt, const char* childname = 0); get child node. void* GetNextChild(void* prevchild, const char* childname = 0); XML helpers. const char* GetContent(void* node); XML helpers. const char* GetName(void* node); XML helpers. Bool_t AddRawLine(void* node, const char* raw); XML helpers. std::vector<TString> SplitString(const TString& theOpt, const char separator) const; splits the option string at 'separator' and fills the list; 'splitV' with the primitive strings. TString StringFromInt(Long_t i); string tools. TString StringFromDouble(Double_t d); string tools. void WriteTMatrixDToXML(void* node, const char* name, TMatrixD* mat); XML helpers. void WriteTVectorDToXML(void* node, const char* name, TVectorD* vec). void ReadTVectorDFromXML(void* node, const char* name, TVectorD* vec). void ReadTMatrixDFromXML(void* node, const char* name, TMatrixD* mat). void TMVAWelcomeMessage(); direct output, eg, when starting ROOT session -> no use of Logger here. void TMVAVersionMessage(TMVA::MsgLogger& logger); prints the TMVA release number and date. void ROOTVersionMessage(TMVA::MsgLogger& logger); prints the ROOT release number and date. void TMVAWelcomeMessage(TMVA::MsgLogger& logger, TMVA::Tools::EWelcomeMessage m = kStandardWelcomeMsg); various kinds of welcome messages; ASCII text generated by this site: http://www.network-science.de/ascii. void TMVACitation(TMVA::MsgLogger& logger, TMVA::Tools::ECitation citType = kPlainText); kinds of TMVA citation. Bool_t HistoHasEquidistantBins(const TH1& h). CalcCovarianceMatrices( const std::vector<const Event*>& events, Int_t maxCls, VariableTransformBase* transformBase ). CalcCovarianceMatrices( const std::vector<Event*>& events, Int_t maxCls, VariableTransformBase* transformBase ); compute covariance matrices. TH1* GetCumulativeDist(TH1* h); get the cumulative distribution of a histogram. Double_t ComputeVariance(Double_t sumx2, Double_t sumx, Int_t nx). Tools(). TXMLEngine& xmlengine(); { return *fXMLEngine; }. int xmlenginebuffersize();",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:12569,Deployability,release,release,12569,"har* childname = 0); XML helpers. const char* GetContent(void* node); XML helpers. const char* GetName(void* node); XML helpers. Bool_t AddRawLine(void* node, const char* raw); XML helpers. std::vector<TString> SplitString(const TString& theOpt, const char separator) const; splits the option string at 'separator' and fills the list; 'splitV' with the primitive strings. TString StringFromInt(Long_t i); string tools. TString StringFromDouble(Double_t d); string tools. void WriteTMatrixDToXML(void* node, const char* name, TMatrixD* mat); XML helpers. void WriteTVectorDToXML(void* node, const char* name, TVectorD* vec). void ReadTVectorDFromXML(void* node, const char* name, TVectorD* vec). void ReadTMatrixDFromXML(void* node, const char* name, TMatrixD* mat). void TMVAWelcomeMessage(); direct output, eg, when starting ROOT session -> no use of Logger here. void TMVAVersionMessage(TMVA::MsgLogger& logger); prints the TMVA release number and date. void ROOTVersionMessage(TMVA::MsgLogger& logger); prints the ROOT release number and date. void TMVAWelcomeMessage(TMVA::MsgLogger& logger, TMVA::Tools::EWelcomeMessage m = kStandardWelcomeMsg); various kinds of welcome messages; ASCII text generated by this site: http://www.network-science.de/ascii. void TMVACitation(TMVA::MsgLogger& logger, TMVA::Tools::ECitation citType = kPlainText); kinds of TMVA citation. Bool_t HistoHasEquidistantBins(const TH1& h). CalcCovarianceMatrices( const std::vector<const Event*>& events, Int_t maxCls, VariableTransformBase* transformBase ). CalcCovarianceMatrices( const std::vector<Event*>& events, Int_t maxCls, VariableTransformBase* transformBase ); compute covariance matrices. TH1* GetCumulativeDist(TH1* h); get the cumulative distribution of a histogram. Double_t ComputeVariance(Double_t sumx2, Double_t sumx, Int_t nx). Tools(). TXMLEngine& xmlengine(); { return *fXMLEngine; }. int xmlenginebuffersize(); { return 10000000; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Cop",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:8802,Integrability,depend,dependency,8802,"scales double vector. void Scale(vector<Float_t>& , Float_t ); scales float vector. void UsefulSortAscending(vector<vector<Double_t> >& , vector<TString>* vs = 0); sort 2D vector (AND in parallel a TString vector) in such a way; that the ""first vector is sorted"" and the other vectors are reshuffled; in the same way as necessary to have the first vector sorted.; I.e. the correlation between the elements is kept. void UsefulSortDescending(vector<vector<Double_t> >& , vector<TString>* vs = 0); sort 2D vector (AND in parallel a TString vector) in such a way; that the ""first vector is sorted"" and the other vectors are reshuffled; in the same way as necessary to have the first vector sorted.; I.e. the correlation between the elements is kept. Double_t GetMutualInformation(const TH2F& ); Mutual Information method for non-linear correlations estimates in 2D histogram; Author: Moritz Backes, Geneva (2009). Double_t GetCorrelationRatio(const TH2F& ); Compute Correlation Ratio of 2D histogram to estimate functional dependency between two variables; Author: Moritz Backes, Geneva (2009). Double_t GetYMean_binX(const TH2& , Int_t bin_x); Compute the mean in Y for a given bin X of a 2D histogram. TH2F* TransposeHist(const TH2F& ); Transpose quadratic histogram. Bool_t CheckForSilentOption(const TString& ) const; check for ""silence"" option in configuration option string. Bool_t CheckForVerboseOption(const TString& ) const; check if verbosity ""V"" set in option. void UsefulSortDescending(vector<Double_t>& ); sort vector. void UsefulSortAscending(vector<Double_t>& ); sort vector. Int_t GetIndexMaxElement(vector<Double_t>& ); find index of maximum entry in vector. Int_t GetIndexMinElement(vector<Double_t>& ); find index of minimum entry in vector. Bool_t ContainsRegularExpression(const TString& s); check if regular expression; helper function to search for ""$!%^&()'<>?= "" in a string. TString ReplaceRegularExpressions(const TString& s, const TString& replace = ""+""); replace regular expr",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:12723,Integrability,message,messages,12723,"RawLine(void* node, const char* raw); XML helpers. std::vector<TString> SplitString(const TString& theOpt, const char separator) const; splits the option string at 'separator' and fills the list; 'splitV' with the primitive strings. TString StringFromInt(Long_t i); string tools. TString StringFromDouble(Double_t d); string tools. void WriteTMatrixDToXML(void* node, const char* name, TMatrixD* mat); XML helpers. void WriteTVectorDToXML(void* node, const char* name, TVectorD* vec). void ReadTVectorDFromXML(void* node, const char* name, TVectorD* vec). void ReadTMatrixDFromXML(void* node, const char* name, TMatrixD* mat). void TMVAWelcomeMessage(); direct output, eg, when starting ROOT session -> no use of Logger here. void TMVAVersionMessage(TMVA::MsgLogger& logger); prints the TMVA release number and date. void ROOTVersionMessage(TMVA::MsgLogger& logger); prints the ROOT release number and date. void TMVAWelcomeMessage(TMVA::MsgLogger& logger, TMVA::Tools::EWelcomeMessage m = kStandardWelcomeMsg); various kinds of welcome messages; ASCII text generated by this site: http://www.network-science.de/ascii. void TMVACitation(TMVA::MsgLogger& logger, TMVA::Tools::ECitation citType = kPlainText); kinds of TMVA citation. Bool_t HistoHasEquidistantBins(const TH1& h). CalcCovarianceMatrices( const std::vector<const Event*>& events, Int_t maxCls, VariableTransformBase* transformBase ). CalcCovarianceMatrices( const std::vector<Event*>& events, Int_t maxCls, VariableTransformBase* transformBase ); compute covariance matrices. TH1* GetCumulativeDist(TH1* h); get the cumulative distribution of a histogram. Double_t ComputeVariance(Double_t sumx2, Double_t sumx, Int_t nx). Tools(). TXMLEngine& xmlengine(); { return *fXMLEngine; }. int xmlenginebuffersize(); { return 10000000; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-09-08 17:46; This page has been automatically generated. For com",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:7073,Modifiability,variab,variable,7073,"tor. Double_t NormVariable(Double_t x, Double_t xmin, Double_t xmax); normalise to output range: [-1, 1]. Double_t GetSeparation(TH1* S, TH1* B) const; compute ""separation"" defined as; <s2> = (1/2) Int_-oo..+oo { (S(x) - B(x))^2/(S(x) + B(x)) dx }. Double_t GetSeparation(const TMVA::PDF& pdfS, const TMVA::PDF& pdfB) const; compute ""separation"" defined as; <s2> = (1/2) Int_-oo..+oo { (S(x) - B(x))2/(S(x) + B(x)) dx }. void ComputeStat(const vector<TMVA::Event*>& , vector<Float_t>* , Double_t& , Double_t& , Double_t& , Double_t& , Double_t& , Double_t& , Int_t signalClass, Bool_t norm = kFALSE); sanity check. TMatrixD* GetSQRootMatrix(TMatrixDSym* symMat); square-root of symmetric matrix; of course the resulting sqrtMat is also symmetric, but it's easier to; treat it as a general matrix. const TMatrixD* GetCorrelationMatrix(const TMatrixD* covMat); turns covariance into correlation matrix. TH1* projNormTH1F(TTree* theTree, const TString& theVarName, const TString& name, Int_t nbins, Double_t xmin, Double_t xmax, const TString& cut); projects variable from tree into normalised histogram. Double_t NormHist(TH1* theHist, Double_t norm = 1.); normalises histogram. TList* ParseFormatLine(TString theString, const char* sep = "":""); Parse the string and cut into labels separated by "":"". vector<Int_t>* ParseANNOptionString(TString theOptions, Int_t nvar, vector<Int_t>* nodes); parse option string for ANN methods; default settings (should be defined in theOption string). Bool_t CheckSplines(const TH1* , const TSpline* ); check quality of splining by comparing splines and histograms in each bin. std::vector<Double_t> MVADiff(vector<Double_t>& , vector<Double_t>& ); computes difference between two vectors. void Scale(vector<Double_t>& , Double_t ); scales double vector. void Scale(vector<Float_t>& , Float_t ); scales float vector. void UsefulSortAscending(vector<vector<Double_t> >& , vector<TString>* vs = 0); sort 2D vector (AND in parallel a TString vector) in such a way; that th",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:8825,Modifiability,variab,variables,8825,"scales double vector. void Scale(vector<Float_t>& , Float_t ); scales float vector. void UsefulSortAscending(vector<vector<Double_t> >& , vector<TString>* vs = 0); sort 2D vector (AND in parallel a TString vector) in such a way; that the ""first vector is sorted"" and the other vectors are reshuffled; in the same way as necessary to have the first vector sorted.; I.e. the correlation between the elements is kept. void UsefulSortDescending(vector<vector<Double_t> >& , vector<TString>* vs = 0); sort 2D vector (AND in parallel a TString vector) in such a way; that the ""first vector is sorted"" and the other vectors are reshuffled; in the same way as necessary to have the first vector sorted.; I.e. the correlation between the elements is kept. Double_t GetMutualInformation(const TH2F& ); Mutual Information method for non-linear correlations estimates in 2D histogram; Author: Moritz Backes, Geneva (2009). Double_t GetCorrelationRatio(const TH2F& ); Compute Correlation Ratio of 2D histogram to estimate functional dependency between two variables; Author: Moritz Backes, Geneva (2009). Double_t GetYMean_binX(const TH2& , Int_t bin_x); Compute the mean in Y for a given bin X of a 2D histogram. TH2F* TransposeHist(const TH2F& ); Transpose quadratic histogram. Bool_t CheckForSilentOption(const TString& ) const; check for ""silence"" option in configuration option string. Bool_t CheckForVerboseOption(const TString& ) const; check if verbosity ""V"" set in option. void UsefulSortDescending(vector<Double_t>& ); sort vector. void UsefulSortAscending(vector<Double_t>& ); sort vector. Int_t GetIndexMaxElement(vector<Double_t>& ); find index of maximum entry in vector. Int_t GetIndexMinElement(vector<Double_t>& ); find index of minimum entry in vector. Bool_t ContainsRegularExpression(const TString& s); check if regular expression; helper function to search for ""$!%^&()'<>?= "" in a string. TString ReplaceRegularExpressions(const TString& s, const TString& replace = ""+""); replace regular expr",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:9131,Modifiability,config,configuration,9131,"ecessary to have the first vector sorted.; I.e. the correlation between the elements is kept. void UsefulSortDescending(vector<vector<Double_t> >& , vector<TString>* vs = 0); sort 2D vector (AND in parallel a TString vector) in such a way; that the ""first vector is sorted"" and the other vectors are reshuffled; in the same way as necessary to have the first vector sorted.; I.e. the correlation between the elements is kept. Double_t GetMutualInformation(const TH2F& ); Mutual Information method for non-linear correlations estimates in 2D histogram; Author: Moritz Backes, Geneva (2009). Double_t GetCorrelationRatio(const TH2F& ); Compute Correlation Ratio of 2D histogram to estimate functional dependency between two variables; Author: Moritz Backes, Geneva (2009). Double_t GetYMean_binX(const TH2& , Int_t bin_x); Compute the mean in Y for a given bin X of a 2D histogram. TH2F* TransposeHist(const TH2F& ); Transpose quadratic histogram. Bool_t CheckForSilentOption(const TString& ) const; check for ""silence"" option in configuration option string. Bool_t CheckForVerboseOption(const TString& ) const; check if verbosity ""V"" set in option. void UsefulSortDescending(vector<Double_t>& ); sort vector. void UsefulSortAscending(vector<Double_t>& ); sort vector. Int_t GetIndexMaxElement(vector<Double_t>& ); find index of maximum entry in vector. Int_t GetIndexMinElement(vector<Double_t>& ); find index of minimum entry in vector. Bool_t ContainsRegularExpression(const TString& s); check if regular expression; helper function to search for ""$!%^&()'<>?= "" in a string. TString ReplaceRegularExpressions(const TString& s, const TString& replace = ""+""); replace regular expressions; helper function to remove all occurences ""$!%^&()'<>?= "" from a string; and replace all ::,$,*,/,+,- with _M_,_S_,_T_,_D_,_P_,_M_ respectively. const TString& Color(const TString& ); human readable color strings. void FormattedOutput(const vector<Double_t>& , const vector<TString>& , const TString titleVars, co",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:5900,Safety,safe,safe,5900,"TH2&, Int_t bin_x); TMVA::ToolsTools(). Data Members; public:. TMVA::MsgLogger*fLogger; const TStringfRegexp; TXMLEngine*fXMLEngine; static atomic<TMVA::Tools*>fgTools; static TMVA::Tools::ECitationkBibTeX; static TMVA::Tools::EWelcomeMessagekBlockWelcomeMsg; static TMVA::Tools::ECitationkHtmlLink; static TMVA::Tools::EWelcomeMessagekIsometricWelcomeMsg; static TMVA::Tools::ECitationkLaTeX; static TMVA::Tools::EWelcomeMessagekLeanWelcomeMsg; static TMVA::Tools::EWelcomeMessagekLogoWelcomeMsg; static TMVA::Tools::EWelcomeMessagekOriginalWelcomeMsgBW; static TMVA::Tools::EWelcomeMessagekOriginalWelcomeMsgColor; static TMVA::Tools::ECitationkPlainText; static TMVA::Tools::EWelcomeMessagekSmall1WelcomeMsg; static TMVA::Tools::EWelcomeMessagekSmall2WelcomeMsg; static TMVA::Tools::EWelcomeMessagekStandardWelcomeMsg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMVA::Tools& Instance(). void DestroyInstance(); NOTE: there is no thread safe way to do this so; one must only call this method ones in an executable. Tools(); constructor. ~Tools(); destructor. Double_t NormVariable(Double_t x, Double_t xmin, Double_t xmax); normalise to output range: [-1, 1]. Double_t GetSeparation(TH1* S, TH1* B) const; compute ""separation"" defined as; <s2> = (1/2) Int_-oo..+oo { (S(x) - B(x))^2/(S(x) + B(x)) dx }. Double_t GetSeparation(const TMVA::PDF& pdfS, const TMVA::PDF& pdfB) const; compute ""separation"" defined as; <s2> = (1/2) Int_-oo..+oo { (S(x) - B(x))2/(S(x) + B(x)) dx }. void ComputeStat(const vector<TMVA::Event*>& , vector<Float_t>* , Double_t& , Double_t& , Double_t& , Double_t& , Double_t& , Double_t& , Int_t signalClass, Bool_t norm = kFALSE); sanity check. TMatrixD* GetSQRootMatrix(TMatrixDSym* symMat); square-root of symmetric matrix; of course the resulting sqrtMat is also symmetric, but it's easier to; treat it as a general matrix. const TMatrixD* GetCorrelationMatrix(const TMatrixD* covMat); turns covariance into correlation matr",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:6618,Safety,sanity check,sanity check,6618,"ic TMVA::Tools::ECitationkPlainText; static TMVA::Tools::EWelcomeMessagekSmall1WelcomeMsg; static TMVA::Tools::EWelcomeMessagekSmall2WelcomeMsg; static TMVA::Tools::EWelcomeMessagekStandardWelcomeMsg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMVA::Tools& Instance(). void DestroyInstance(); NOTE: there is no thread safe way to do this so; one must only call this method ones in an executable. Tools(); constructor. ~Tools(); destructor. Double_t NormVariable(Double_t x, Double_t xmin, Double_t xmax); normalise to output range: [-1, 1]. Double_t GetSeparation(TH1* S, TH1* B) const; compute ""separation"" defined as; <s2> = (1/2) Int_-oo..+oo { (S(x) - B(x))^2/(S(x) + B(x)) dx }. Double_t GetSeparation(const TMVA::PDF& pdfS, const TMVA::PDF& pdfB) const; compute ""separation"" defined as; <s2> = (1/2) Int_-oo..+oo { (S(x) - B(x))2/(S(x) + B(x)) dx }. void ComputeStat(const vector<TMVA::Event*>& , vector<Float_t>* , Double_t& , Double_t& , Double_t& , Double_t& , Double_t& , Double_t& , Int_t signalClass, Bool_t norm = kFALSE); sanity check. TMatrixD* GetSQRootMatrix(TMatrixDSym* symMat); square-root of symmetric matrix; of course the resulting sqrtMat is also symmetric, but it's easier to; treat it as a general matrix. const TMatrixD* GetCorrelationMatrix(const TMatrixD* covMat); turns covariance into correlation matrix. TH1* projNormTH1F(TTree* theTree, const TString& theVarName, const TString& name, Int_t nbins, Double_t xmin, Double_t xmax, const TString& cut); projects variable from tree into normalised histogram. Double_t NormHist(TH1* theHist, Double_t norm = 1.); normalises histogram. TList* ParseFormatLine(TString theString, const char* sep = "":""); Parse the string and cut into labels separated by "":"". vector<Int_t>* ParseANNOptionString(TString theOptions, Int_t nvar, vector<Int_t>* nodes); parse option string for ANN methods; default settings (should be defined in theOption string). Bool_t CheckSplines(const TH1* , ",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:1573,Testability,log,logger,1573,"ader file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::Tools. class TMVA::Tools. Function Members (Methods); public:. ~Tools(); voidAddAttr(void* node, const char* attrname, const char* value); voidAddAttr<const char *>(void* node, const char* attrname, const char*const& value, Int_t precision = 16); void*AddChild(void* parent, const char* childname, const char* content = 0, bool isRootNode = false); Bool_tAddComment(void* node, const char* comment); Bool_tAddRawLine(void* node, const char* raw); vector<TMatrixDSym*>*CalcCovarianceMatrices(const vector<TMVA::Event*>& events, Int_t maxCls, TMVA::VariableTransformBase* transformBase = 0); vector<TMatrixDSym*>*CalcCovarianceMatrices(const vector<const TMVA::Event*>& events, Int_t maxCls, TMVA::VariableTransformBase* transformBase = 0); Bool_tCheckForSilentOption(const TString&) const; Bool_tCheckForVerboseOption(const TString&) const; Bool_tCheckSplines(const TH1*, const TSpline*); const TString&Color(const TString&); voidComputeStat(const vector<TMVA::Event*>&, vector<Float_t>*, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Int_t signalClass, Bool_t norm = kFALSE); Double_tComputeVariance(Double_t sumx2, Double_t sumx, Int_t nx); Bool_tContainsRegularExpression(const TString& s); static voidDestroyInstance(); voidFormattedOutput(const TMatrixD&, const vector<TString>&, TMVA::MsgLogger& logger); voidFormattedOutput(const TMatrixD&, const vector<TString>& vert, const vector<TString>& horiz, TMVA::MsgLogger& logger); voidFormattedOutput(const vector<Double_t>&, const vector<TString>&, const TString titleVars, const TString titleValues, TMVA::MsgLogger& logger, TString format = ""%+1.3f""); void*GetChild(void* parent, const char* childname = 0); const char*GetContent(void* node); const TMatrixD*GetCorrelationMatrix(const TMatrixD* covMat); Double_tGetCorrelationRatio(const TH2F&); TH1*GetCumulativeDist",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:1695,Testability,log,logger,1695,"ader file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::Tools. class TMVA::Tools. Function Members (Methods); public:. ~Tools(); voidAddAttr(void* node, const char* attrname, const char* value); voidAddAttr<const char *>(void* node, const char* attrname, const char*const& value, Int_t precision = 16); void*AddChild(void* parent, const char* childname, const char* content = 0, bool isRootNode = false); Bool_tAddComment(void* node, const char* comment); Bool_tAddRawLine(void* node, const char* raw); vector<TMatrixDSym*>*CalcCovarianceMatrices(const vector<TMVA::Event*>& events, Int_t maxCls, TMVA::VariableTransformBase* transformBase = 0); vector<TMatrixDSym*>*CalcCovarianceMatrices(const vector<const TMVA::Event*>& events, Int_t maxCls, TMVA::VariableTransformBase* transformBase = 0); Bool_tCheckForSilentOption(const TString&) const; Bool_tCheckForVerboseOption(const TString&) const; Bool_tCheckSplines(const TH1*, const TSpline*); const TString&Color(const TString&); voidComputeStat(const vector<TMVA::Event*>&, vector<Float_t>*, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Int_t signalClass, Bool_t norm = kFALSE); Double_tComputeVariance(Double_t sumx2, Double_t sumx, Int_t nx); Bool_tContainsRegularExpression(const TString& s); static voidDestroyInstance(); voidFormattedOutput(const TMatrixD&, const vector<TString>&, TMVA::MsgLogger& logger); voidFormattedOutput(const TMatrixD&, const vector<TString>& vert, const vector<TString>& horiz, TMVA::MsgLogger& logger); voidFormattedOutput(const vector<Double_t>&, const vector<TString>&, const TString titleVars, const TString titleValues, TMVA::MsgLogger& logger, TString format = ""%+1.3f""); void*GetChild(void* parent, const char* childname = 0); const char*GetContent(void* node); const TMatrixD*GetCorrelationMatrix(const TMatrixD* covMat); Double_tGetCorrelationRatio(const TH2F&); TH1*GetCumulativeDist",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:1842,Testability,log,logger,1842,"ader file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::Tools. class TMVA::Tools. Function Members (Methods); public:. ~Tools(); voidAddAttr(void* node, const char* attrname, const char* value); voidAddAttr<const char *>(void* node, const char* attrname, const char*const& value, Int_t precision = 16); void*AddChild(void* parent, const char* childname, const char* content = 0, bool isRootNode = false); Bool_tAddComment(void* node, const char* comment); Bool_tAddRawLine(void* node, const char* raw); vector<TMatrixDSym*>*CalcCovarianceMatrices(const vector<TMVA::Event*>& events, Int_t maxCls, TMVA::VariableTransformBase* transformBase = 0); vector<TMatrixDSym*>*CalcCovarianceMatrices(const vector<const TMVA::Event*>& events, Int_t maxCls, TMVA::VariableTransformBase* transformBase = 0); Bool_tCheckForSilentOption(const TString&) const; Bool_tCheckForVerboseOption(const TString&) const; Bool_tCheckSplines(const TH1*, const TSpline*); const TString&Color(const TString&); voidComputeStat(const vector<TMVA::Event*>&, vector<Float_t>*, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Int_t signalClass, Bool_t norm = kFALSE); Double_tComputeVariance(Double_t sumx2, Double_t sumx, Int_t nx); Bool_tContainsRegularExpression(const TString& s); static voidDestroyInstance(); voidFormattedOutput(const TMatrixD&, const vector<TString>&, TMVA::MsgLogger& logger); voidFormattedOutput(const TMatrixD&, const vector<TString>& vert, const vector<TString>& horiz, TMVA::MsgLogger& logger); voidFormattedOutput(const vector<Double_t>&, const vector<TString>&, const TString titleVars, const TString titleValues, TMVA::MsgLogger& logger, TString format = ""%+1.3f""); void*GetChild(void* parent, const char* childname = 0); const char*GetContent(void* node); const TMatrixD*GetCorrelationMatrix(const TMatrixD* covMat); Double_tGetCorrelationRatio(const TH2F&); TH1*GetCumulativeDist",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:3809,Testability,log,logger,3809,"(TH1* theHist, Double_t norm = 1.); Double_tNormVariable(Double_t x, Double_t xmin, Double_t xmax); TMVA::Tools&operator=(const TMVA::Tools&); vector<Int_t>*ParseANNOptionString(TString theOptions, Int_t nvar, vector<Int_t>* nodes); TList*ParseFormatLine(TString theString, const char* sep = "":""); TH1*projNormTH1F(TTree* theTree, const TString& theVarName, const TString& name, Int_t nbins, Double_t xmin, Double_t xmax, const TString& cut); voidReadAttr(void* node, const char* attrname, TString& value); voidReadAttr<TString>(void* node, const char* attrname, TString& value); voidReadFloatArbitraryPrecision(Float_t& val, istream& is); voidReadTMatrixDFromXML(void* node, const char* name, TMatrixD* mat); voidReadTVectorDFromXML(void* node, const char* name, TVectorD* vec); TStringReplaceRegularExpressions(const TString& s, const TString& replace = ""+""); voidROOTVersionMessage(TMVA::MsgLogger& logger); voidScale(vector<Double_t>&, Double_t); voidScale(vector<Float_t>&, Float_t); vector<TString>SplitString(const TString& theOpt, const char separator) const; TStringStringFromDouble(Double_t d); TStringStringFromInt(Long_t i); voidTMVACitation(TMVA::MsgLogger& logger, TMVA::Tools::ECitation citType = kPlainText); voidTMVAVersionMessage(TMVA::MsgLogger& logger); voidTMVAWelcomeMessage(); voidTMVAWelcomeMessage(TMVA::MsgLogger& logger, TMVA::Tools::EWelcomeMessage m = kStandardWelcomeMsg); TMVA::ToolsTools(const TMVA::Tools&); TH2F*TransposeHist(const TH2F&); voidUsefulSortAscending(vector<Double_t>&); voidUsefulSortAscending(vector<vector<Double_t> >&, vector<TString>* vs = 0); voidUsefulSortDescending(vector<Double_t>&); voidUsefulSortDescending(vector<vector<Double_t> >&, vector<TString>* vs = 0); voidWriteFloatArbitraryPrecision(Float_t val, ostream& os); voidWriteTMatrixDToXML(void* node, const char* name, TMatrixD* mat); voidWriteTVectorDToXML(void* node, const char* name, TVectorD* vec); TXMLEngine&xmlengine(); intxmlenginebuffersize(). private:. Double_tGetYMean_binX(",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:4078,Testability,log,logger,4078,"(TH1* theHist, Double_t norm = 1.); Double_tNormVariable(Double_t x, Double_t xmin, Double_t xmax); TMVA::Tools&operator=(const TMVA::Tools&); vector<Int_t>*ParseANNOptionString(TString theOptions, Int_t nvar, vector<Int_t>* nodes); TList*ParseFormatLine(TString theString, const char* sep = "":""); TH1*projNormTH1F(TTree* theTree, const TString& theVarName, const TString& name, Int_t nbins, Double_t xmin, Double_t xmax, const TString& cut); voidReadAttr(void* node, const char* attrname, TString& value); voidReadAttr<TString>(void* node, const char* attrname, TString& value); voidReadFloatArbitraryPrecision(Float_t& val, istream& is); voidReadTMatrixDFromXML(void* node, const char* name, TMatrixD* mat); voidReadTVectorDFromXML(void* node, const char* name, TVectorD* vec); TStringReplaceRegularExpressions(const TString& s, const TString& replace = ""+""); voidROOTVersionMessage(TMVA::MsgLogger& logger); voidScale(vector<Double_t>&, Double_t); voidScale(vector<Float_t>&, Float_t); vector<TString>SplitString(const TString& theOpt, const char separator) const; TStringStringFromDouble(Double_t d); TStringStringFromInt(Long_t i); voidTMVACitation(TMVA::MsgLogger& logger, TMVA::Tools::ECitation citType = kPlainText); voidTMVAVersionMessage(TMVA::MsgLogger& logger); voidTMVAWelcomeMessage(); voidTMVAWelcomeMessage(TMVA::MsgLogger& logger, TMVA::Tools::EWelcomeMessage m = kStandardWelcomeMsg); TMVA::ToolsTools(const TMVA::Tools&); TH2F*TransposeHist(const TH2F&); voidUsefulSortAscending(vector<Double_t>&); voidUsefulSortAscending(vector<vector<Double_t> >&, vector<TString>* vs = 0); voidUsefulSortDescending(vector<Double_t>&); voidUsefulSortDescending(vector<vector<Double_t> >&, vector<TString>* vs = 0); voidWriteFloatArbitraryPrecision(Float_t val, ostream& os); voidWriteTMatrixDToXML(void* node, const char* name, TMatrixD* mat); voidWriteTVectorDToXML(void* node, const char* name, TVectorD* vec); TXMLEngine&xmlengine(); intxmlenginebuffersize(). private:. Double_tGetYMean_binX(",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:4172,Testability,log,logger,4172,"(TH1* theHist, Double_t norm = 1.); Double_tNormVariable(Double_t x, Double_t xmin, Double_t xmax); TMVA::Tools&operator=(const TMVA::Tools&); vector<Int_t>*ParseANNOptionString(TString theOptions, Int_t nvar, vector<Int_t>* nodes); TList*ParseFormatLine(TString theString, const char* sep = "":""); TH1*projNormTH1F(TTree* theTree, const TString& theVarName, const TString& name, Int_t nbins, Double_t xmin, Double_t xmax, const TString& cut); voidReadAttr(void* node, const char* attrname, TString& value); voidReadAttr<TString>(void* node, const char* attrname, TString& value); voidReadFloatArbitraryPrecision(Float_t& val, istream& is); voidReadTMatrixDFromXML(void* node, const char* name, TMatrixD* mat); voidReadTVectorDFromXML(void* node, const char* name, TVectorD* vec); TStringReplaceRegularExpressions(const TString& s, const TString& replace = ""+""); voidROOTVersionMessage(TMVA::MsgLogger& logger); voidScale(vector<Double_t>&, Double_t); voidScale(vector<Float_t>&, Float_t); vector<TString>SplitString(const TString& theOpt, const char separator) const; TStringStringFromDouble(Double_t d); TStringStringFromInt(Long_t i); voidTMVACitation(TMVA::MsgLogger& logger, TMVA::Tools::ECitation citType = kPlainText); voidTMVAVersionMessage(TMVA::MsgLogger& logger); voidTMVAWelcomeMessage(); voidTMVAWelcomeMessage(TMVA::MsgLogger& logger, TMVA::Tools::EWelcomeMessage m = kStandardWelcomeMsg); TMVA::ToolsTools(const TMVA::Tools&); TH2F*TransposeHist(const TH2F&); voidUsefulSortAscending(vector<Double_t>&); voidUsefulSortAscending(vector<vector<Double_t> >&, vector<TString>* vs = 0); voidUsefulSortDescending(vector<Double_t>&); voidUsefulSortDescending(vector<vector<Double_t> >&, vector<TString>* vs = 0); voidWriteFloatArbitraryPrecision(Float_t val, ostream& os); voidWriteTMatrixDToXML(void* node, const char* name, TMatrixD* mat); voidWriteTVectorDToXML(void* node, const char* name, TVectorD* vec); TXMLEngine&xmlengine(); intxmlenginebuffersize(). private:. Double_tGetYMean_binX(",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:4247,Testability,log,logger,4247,"(TH1* theHist, Double_t norm = 1.); Double_tNormVariable(Double_t x, Double_t xmin, Double_t xmax); TMVA::Tools&operator=(const TMVA::Tools&); vector<Int_t>*ParseANNOptionString(TString theOptions, Int_t nvar, vector<Int_t>* nodes); TList*ParseFormatLine(TString theString, const char* sep = "":""); TH1*projNormTH1F(TTree* theTree, const TString& theVarName, const TString& name, Int_t nbins, Double_t xmin, Double_t xmax, const TString& cut); voidReadAttr(void* node, const char* attrname, TString& value); voidReadAttr<TString>(void* node, const char* attrname, TString& value); voidReadFloatArbitraryPrecision(Float_t& val, istream& is); voidReadTMatrixDFromXML(void* node, const char* name, TMatrixD* mat); voidReadTVectorDFromXML(void* node, const char* name, TVectorD* vec); TStringReplaceRegularExpressions(const TString& s, const TString& replace = ""+""); voidROOTVersionMessage(TMVA::MsgLogger& logger); voidScale(vector<Double_t>&, Double_t); voidScale(vector<Float_t>&, Float_t); vector<TString>SplitString(const TString& theOpt, const char separator) const; TStringStringFromDouble(Double_t d); TStringStringFromInt(Long_t i); voidTMVACitation(TMVA::MsgLogger& logger, TMVA::Tools::ECitation citType = kPlainText); voidTMVAVersionMessage(TMVA::MsgLogger& logger); voidTMVAWelcomeMessage(); voidTMVAWelcomeMessage(TMVA::MsgLogger& logger, TMVA::Tools::EWelcomeMessage m = kStandardWelcomeMsg); TMVA::ToolsTools(const TMVA::Tools&); TH2F*TransposeHist(const TH2F&); voidUsefulSortAscending(vector<Double_t>&); voidUsefulSortAscending(vector<vector<Double_t> >&, vector<TString>* vs = 0); voidUsefulSortDescending(vector<Double_t>&); voidUsefulSortDescending(vector<vector<Double_t> >&, vector<TString>* vs = 0); voidWriteFloatArbitraryPrecision(Float_t val, ostream& os); voidWriteTMatrixDToXML(void* node, const char* name, TMatrixD* mat); voidWriteTVectorDToXML(void* node, const char* name, TVectorD* vec); TXMLEngine&xmlengine(); intxmlenginebuffersize(). private:. Double_tGetYMean_binX(",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:10146,Testability,log,logger,10146,"& ) const; check for ""silence"" option in configuration option string. Bool_t CheckForVerboseOption(const TString& ) const; check if verbosity ""V"" set in option. void UsefulSortDescending(vector<Double_t>& ); sort vector. void UsefulSortAscending(vector<Double_t>& ); sort vector. Int_t GetIndexMaxElement(vector<Double_t>& ); find index of maximum entry in vector. Int_t GetIndexMinElement(vector<Double_t>& ); find index of minimum entry in vector. Bool_t ContainsRegularExpression(const TString& s); check if regular expression; helper function to search for ""$!%^&()'<>?= "" in a string. TString ReplaceRegularExpressions(const TString& s, const TString& replace = ""+""); replace regular expressions; helper function to remove all occurences ""$!%^&()'<>?= "" from a string; and replace all ::,$,*,/,+,- with _M_,_S_,_T_,_D_,_P_,_M_ respectively. const TString& Color(const TString& ); human readable color strings. void FormattedOutput(const vector<Double_t>& , const vector<TString>& , const TString titleVars, const TString titleValues, TMVA::MsgLogger& logger, TString format = ""%+1.3f""); formatted output of simple table. void FormattedOutput(const TMatrixD& , const vector<TString>& , TMVA::MsgLogger& logger); formatted output of matrix (with labels). void FormattedOutput(const TMatrixD& , const vector<TString>& vert, const vector<TString>& horiz, TMVA::MsgLogger& logger); formatted output of matrix (with labels). TString GetXTitleWithUnit(const TString& title, const TString& unit); histogramming utility. TString GetYTitleWithUnit(const TH1& h, const TString& unit, Bool_t normalised); histogramming utility. void WriteFloatArbitraryPrecision(Float_t val, ostream& os); writes a float value with the available precision to a stream. void ReadFloatArbitraryPrecision(Float_t& val, istream& is); reads a float value with the available precision from a stream. Bool_t HasAttr(void* node, const char* attrname); add attribute from xml. void ReadAttr(void* node, const char* attrname, TString&",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:10297,Testability,log,logger,10297,"or<Double_t>& ); sort vector. void UsefulSortAscending(vector<Double_t>& ); sort vector. Int_t GetIndexMaxElement(vector<Double_t>& ); find index of maximum entry in vector. Int_t GetIndexMinElement(vector<Double_t>& ); find index of minimum entry in vector. Bool_t ContainsRegularExpression(const TString& s); check if regular expression; helper function to search for ""$!%^&()'<>?= "" in a string. TString ReplaceRegularExpressions(const TString& s, const TString& replace = ""+""); replace regular expressions; helper function to remove all occurences ""$!%^&()'<>?= "" from a string; and replace all ::,$,*,/,+,- with _M_,_S_,_T_,_D_,_P_,_M_ respectively. const TString& Color(const TString& ); human readable color strings. void FormattedOutput(const vector<Double_t>& , const vector<TString>& , const TString titleVars, const TString titleValues, TMVA::MsgLogger& logger, TString format = ""%+1.3f""); formatted output of simple table. void FormattedOutput(const TMatrixD& , const vector<TString>& , TMVA::MsgLogger& logger); formatted output of matrix (with labels). void FormattedOutput(const TMatrixD& , const vector<TString>& vert, const vector<TString>& horiz, TMVA::MsgLogger& logger); formatted output of matrix (with labels). TString GetXTitleWithUnit(const TString& title, const TString& unit); histogramming utility. TString GetYTitleWithUnit(const TH1& h, const TString& unit, Bool_t normalised); histogramming utility. void WriteFloatArbitraryPrecision(Float_t val, ostream& os); writes a float value with the available precision to a stream. void ReadFloatArbitraryPrecision(Float_t& val, istream& is); reads a float value with the available precision from a stream. Bool_t HasAttr(void* node, const char* attrname); add attribute from xml. void ReadAttr(void* node, const char* attrname, TString& value); add attribute from xml. void AddAttr(void* node, const char* attrname, const char* value); add attribute to node. void* AddChild(void* parent, const char* childname, const char* cont",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:10463,Testability,log,logger,10463,"maximum entry in vector. Int_t GetIndexMinElement(vector<Double_t>& ); find index of minimum entry in vector. Bool_t ContainsRegularExpression(const TString& s); check if regular expression; helper function to search for ""$!%^&()'<>?= "" in a string. TString ReplaceRegularExpressions(const TString& s, const TString& replace = ""+""); replace regular expressions; helper function to remove all occurences ""$!%^&()'<>?= "" from a string; and replace all ::,$,*,/,+,- with _M_,_S_,_T_,_D_,_P_,_M_ respectively. const TString& Color(const TString& ); human readable color strings. void FormattedOutput(const vector<Double_t>& , const vector<TString>& , const TString titleVars, const TString titleValues, TMVA::MsgLogger& logger, TString format = ""%+1.3f""); formatted output of simple table. void FormattedOutput(const TMatrixD& , const vector<TString>& , TMVA::MsgLogger& logger); formatted output of matrix (with labels). void FormattedOutput(const TMatrixD& , const vector<TString>& vert, const vector<TString>& horiz, TMVA::MsgLogger& logger); formatted output of matrix (with labels). TString GetXTitleWithUnit(const TString& title, const TString& unit); histogramming utility. TString GetYTitleWithUnit(const TH1& h, const TString& unit, Bool_t normalised); histogramming utility. void WriteFloatArbitraryPrecision(Float_t val, ostream& os); writes a float value with the available precision to a stream. void ReadFloatArbitraryPrecision(Float_t& val, istream& is); reads a float value with the available precision from a stream. Bool_t HasAttr(void* node, const char* attrname); add attribute from xml. void ReadAttr(void* node, const char* attrname, TString& value); add attribute from xml. void AddAttr(void* node, const char* attrname, const char* value); add attribute to node. void* AddChild(void* parent, const char* childname, const char* content = 0, bool isRootNode = false); add child node. Bool_t AddComment(void* node, const char* comment). void* GetParent(void* child); get parent node.",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:12453,Testability,log,logger,12453,"nt, const char* childname = 0); get child node. void* GetNextChild(void* prevchild, const char* childname = 0); XML helpers. const char* GetContent(void* node); XML helpers. const char* GetName(void* node); XML helpers. Bool_t AddRawLine(void* node, const char* raw); XML helpers. std::vector<TString> SplitString(const TString& theOpt, const char separator) const; splits the option string at 'separator' and fills the list; 'splitV' with the primitive strings. TString StringFromInt(Long_t i); string tools. TString StringFromDouble(Double_t d); string tools. void WriteTMatrixDToXML(void* node, const char* name, TMatrixD* mat); XML helpers. void WriteTVectorDToXML(void* node, const char* name, TVectorD* vec). void ReadTVectorDFromXML(void* node, const char* name, TVectorD* vec). void ReadTMatrixDFromXML(void* node, const char* name, TMatrixD* mat). void TMVAWelcomeMessage(); direct output, eg, when starting ROOT session -> no use of Logger here. void TMVAVersionMessage(TMVA::MsgLogger& logger); prints the TMVA release number and date. void ROOTVersionMessage(TMVA::MsgLogger& logger); prints the ROOT release number and date. void TMVAWelcomeMessage(TMVA::MsgLogger& logger, TMVA::Tools::EWelcomeMessage m = kStandardWelcomeMsg); various kinds of welcome messages; ASCII text generated by this site: http://www.network-science.de/ascii. void TMVACitation(TMVA::MsgLogger& logger, TMVA::Tools::ECitation citType = kPlainText); kinds of TMVA citation. Bool_t HistoHasEquidistantBins(const TH1& h). CalcCovarianceMatrices( const std::vector<const Event*>& events, Int_t maxCls, VariableTransformBase* transformBase ). CalcCovarianceMatrices( const std::vector<Event*>& events, Int_t maxCls, VariableTransformBase* transformBase ); compute covariance matrices. TH1* GetCumulativeDist(TH1* h); get the cumulative distribution of a histogram. Double_t ComputeVariance(Double_t sumx2, Double_t sumx, Int_t nx). Tools(). TXMLEngine& xmlengine(); { return *fXMLEngine; }. int xmlenginebuffersize();",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:12544,Testability,log,logger,12544,"har* childname = 0); XML helpers. const char* GetContent(void* node); XML helpers. const char* GetName(void* node); XML helpers. Bool_t AddRawLine(void* node, const char* raw); XML helpers. std::vector<TString> SplitString(const TString& theOpt, const char separator) const; splits the option string at 'separator' and fills the list; 'splitV' with the primitive strings. TString StringFromInt(Long_t i); string tools. TString StringFromDouble(Double_t d); string tools. void WriteTMatrixDToXML(void* node, const char* name, TMatrixD* mat); XML helpers. void WriteTVectorDToXML(void* node, const char* name, TVectorD* vec). void ReadTVectorDFromXML(void* node, const char* name, TVectorD* vec). void ReadTMatrixDFromXML(void* node, const char* name, TMatrixD* mat). void TMVAWelcomeMessage(); direct output, eg, when starting ROOT session -> no use of Logger here. void TMVAVersionMessage(TMVA::MsgLogger& logger); prints the TMVA release number and date. void ROOTVersionMessage(TMVA::MsgLogger& logger); prints the ROOT release number and date. void TMVAWelcomeMessage(TMVA::MsgLogger& logger, TMVA::Tools::EWelcomeMessage m = kStandardWelcomeMsg); various kinds of welcome messages; ASCII text generated by this site: http://www.network-science.de/ascii. void TMVACitation(TMVA::MsgLogger& logger, TMVA::Tools::ECitation citType = kPlainText); kinds of TMVA citation. Bool_t HistoHasEquidistantBins(const TH1& h). CalcCovarianceMatrices( const std::vector<const Event*>& events, Int_t maxCls, VariableTransformBase* transformBase ). CalcCovarianceMatrices( const std::vector<Event*>& events, Int_t maxCls, VariableTransformBase* transformBase ); compute covariance matrices. TH1* GetCumulativeDist(TH1* h); get the cumulative distribution of a histogram. Double_t ComputeVariance(Double_t sumx2, Double_t sumx, Int_t nx). Tools(). TXMLEngine& xmlengine(); { return *fXMLEngine; }. int xmlenginebuffersize(); { return 10000000; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Cop",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:12635,Testability,log,logger,12635,"RawLine(void* node, const char* raw); XML helpers. std::vector<TString> SplitString(const TString& theOpt, const char separator) const; splits the option string at 'separator' and fills the list; 'splitV' with the primitive strings. TString StringFromInt(Long_t i); string tools. TString StringFromDouble(Double_t d); string tools. void WriteTMatrixDToXML(void* node, const char* name, TMatrixD* mat); XML helpers. void WriteTVectorDToXML(void* node, const char* name, TVectorD* vec). void ReadTVectorDFromXML(void* node, const char* name, TVectorD* vec). void ReadTMatrixDFromXML(void* node, const char* name, TMatrixD* mat). void TMVAWelcomeMessage(); direct output, eg, when starting ROOT session -> no use of Logger here. void TMVAVersionMessage(TMVA::MsgLogger& logger); prints the TMVA release number and date. void ROOTVersionMessage(TMVA::MsgLogger& logger); prints the ROOT release number and date. void TMVAWelcomeMessage(TMVA::MsgLogger& logger, TMVA::Tools::EWelcomeMessage m = kStandardWelcomeMsg); various kinds of welcome messages; ASCII text generated by this site: http://www.network-science.de/ascii. void TMVACitation(TMVA::MsgLogger& logger, TMVA::Tools::ECitation citType = kPlainText); kinds of TMVA citation. Bool_t HistoHasEquidistantBins(const TH1& h). CalcCovarianceMatrices( const std::vector<const Event*>& events, Int_t maxCls, VariableTransformBase* transformBase ). CalcCovarianceMatrices( const std::vector<Event*>& events, Int_t maxCls, VariableTransformBase* transformBase ); compute covariance matrices. TH1* GetCumulativeDist(TH1* h); get the cumulative distribution of a histogram. Double_t ComputeVariance(Double_t sumx2, Double_t sumx, Int_t nx). Tools(). TXMLEngine& xmlengine(); { return *fXMLEngine; }. int xmlenginebuffersize(); { return 10000000; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-09-08 17:46; This page has been automatically generated. For com",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:12840,Testability,log,logger,12840,"t, const char separator) const; splits the option string at 'separator' and fills the list; 'splitV' with the primitive strings. TString StringFromInt(Long_t i); string tools. TString StringFromDouble(Double_t d); string tools. void WriteTMatrixDToXML(void* node, const char* name, TMatrixD* mat); XML helpers. void WriteTVectorDToXML(void* node, const char* name, TVectorD* vec). void ReadTVectorDFromXML(void* node, const char* name, TVectorD* vec). void ReadTMatrixDFromXML(void* node, const char* name, TMatrixD* mat). void TMVAWelcomeMessage(); direct output, eg, when starting ROOT session -> no use of Logger here. void TMVAVersionMessage(TMVA::MsgLogger& logger); prints the TMVA release number and date. void ROOTVersionMessage(TMVA::MsgLogger& logger); prints the ROOT release number and date. void TMVAWelcomeMessage(TMVA::MsgLogger& logger, TMVA::Tools::EWelcomeMessage m = kStandardWelcomeMsg); various kinds of welcome messages; ASCII text generated by this site: http://www.network-science.de/ascii. void TMVACitation(TMVA::MsgLogger& logger, TMVA::Tools::ECitation citType = kPlainText); kinds of TMVA citation. Bool_t HistoHasEquidistantBins(const TH1& h). CalcCovarianceMatrices( const std::vector<const Event*>& events, Int_t maxCls, VariableTransformBase* transformBase ). CalcCovarianceMatrices( const std::vector<Event*>& events, Int_t maxCls, VariableTransformBase* transformBase ); compute covariance matrices. TH1* GetCumulativeDist(TH1* h); get the cumulative distribution of a histogram. Double_t ComputeVariance(Double_t sumx2, Double_t sumx, Int_t nx). Tools(). TXMLEngine& xmlengine(); { return *fXMLEngine; }. int xmlenginebuffersize(); { return 10000000; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-09-08 17:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__Tools.html:10202,Usability,simpl,simple,10202,"TString& ) const; check if verbosity ""V"" set in option. void UsefulSortDescending(vector<Double_t>& ); sort vector. void UsefulSortAscending(vector<Double_t>& ); sort vector. Int_t GetIndexMaxElement(vector<Double_t>& ); find index of maximum entry in vector. Int_t GetIndexMinElement(vector<Double_t>& ); find index of minimum entry in vector. Bool_t ContainsRegularExpression(const TString& s); check if regular expression; helper function to search for ""$!%^&()'<>?= "" in a string. TString ReplaceRegularExpressions(const TString& s, const TString& replace = ""+""); replace regular expressions; helper function to remove all occurences ""$!%^&()'<>?= "" from a string; and replace all ::,$,*,/,+,- with _M_,_S_,_T_,_D_,_P_,_M_ respectively. const TString& Color(const TString& ); human readable color strings. void FormattedOutput(const vector<Double_t>& , const vector<TString>& , const TString titleVars, const TString titleValues, TMVA::MsgLogger& logger, TString format = ""%+1.3f""); formatted output of simple table. void FormattedOutput(const TMatrixD& , const vector<TString>& , TMVA::MsgLogger& logger); formatted output of matrix (with labels). void FormattedOutput(const TMatrixD& , const vector<TString>& vert, const vector<TString>& horiz, TMVA::MsgLogger& logger); formatted output of matrix (with labels). TString GetXTitleWithUnit(const TString& title, const TString& unit); histogramming utility. TString GetYTitleWithUnit(const TH1& h, const TString& unit, Bool_t normalised); histogramming utility. void WriteFloatArbitraryPrecision(Float_t val, ostream& os); writes a float value with the available precision to a stream. void ReadFloatArbitraryPrecision(Float_t& val, istream& is); reads a float value with the available precision from a stream. Bool_t HasAttr(void* node, const char* attrname); add attribute from xml. void ReadAttr(void* node, const char* attrname, TString& value); add attribute from xml. void AddAttr(void* node, const char* attrname, const char* value); add at",MatchSource.WIKI,root/html604/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Tools.html
https://root.cern/root/html604/TMVA__TSpline1.html:1479,Availability,error,error,1479,"on_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildCoeff(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTSpline::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTSpline::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t x) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTSpline::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tTSpline::GetDelta() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; const TGraph*GetGraph() const; TH1F*TSpline::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual voidGetKnot(Int_t i, Double_t& x, Double_t& y) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; v",MatchSource.WIKI,root/html604/TMVA__TSpline1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TSpline1.html
https://root.cern/root/html604/TMVA__TSpline1.html:1563,Availability,error,error,1563,"(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTSpline::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTSpline::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t x) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTSpline::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tTSpline::GetDelta() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; const TGraph*GetGraph() const; TH1F*TSpline::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual voidGetKnot(Int_t i, Double_t& x, Double_t& y) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarker",MatchSource.WIKI,root/html604/TMVA__TSpline1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TSpline1.html
https://root.cern/root/html604/TMVA__TSpline2.html:1482,Availability,error,error,1482,"on_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildCoeff(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTSpline::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTSpline::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t x) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTSpline::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tTSpline::GetDelta() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1F*TSpline::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual voidGetKnot(Int_t i, Double_t& x, Double_t& y) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMar",MatchSource.WIKI,root/html604/TMVA__TSpline2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TSpline2.html
https://root.cern/root/html604/TMVA__TSpline2.html:1566,Availability,error,error,1566,"(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTSpline::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTSpline::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t x) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTSpline::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tTSpline::GetDelta() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1F*TSpline::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual voidGetKnot(Int_t i, Double_t& x, Double_t& y) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const ch",MatchSource.WIKI,root/html604/TMVA__TSpline2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TSpline2.html
https://root.cern/root/html604/TMVA__TSpline2.html:9934,Integrability,rout,routine,9934,"ombie. protected:. Double_tTSpline::fDeltaDistance between equidistant knots; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TGraph*TSpline::fGraphGraph for drawing the knots; TH1F*TSpline::fHistogramTemporary histogram; Bool_tTSpline::fKstepTrue of equidistant knots; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; TStringTNamed::fNameobject identifier; Int_tTSpline::fNpNumber of knots; Int_tTSpline::fNpxNumber of points used for graphical representation; TStringTNamed::fTitleobject title; Double_tTSpline::fXmaxMaximum value of abscissa; Double_tTSpline::fXminMinimum value of abscissa. private:. TGraph*fGraphgraph that is splined. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSpline2(const TString& title, TGraph* theGraph); constructor from TGraph; TSpline is a TNamed object. ~TSpline2( void ); destructor. Double_t Eval(Double_t x) const; returns quadratically interpolated TGraph entry around x. void BuildCoeff( void ); no coefficients to precompute. void GetKnot(Int_t i, Double_t& x, Double_t& y) const; no knots. Double_t Quadrax(Float_t dm, Float_t dm1, Float_t dm2, Float_t dm3, Float_t cos1, Float_t cos2, Float_t cos3) const; quadratic interpolation; Revised and checked by Francois Nov, 16th, 2000; Note the beautiful non-spontaneous symmetry breaking ...; It was checked that the old routine gave exactly the same answers. TSpline2(const TString& title, TGraph* theGraph). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__TSpline2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TSpline2.html
https://root.cern/root/html604/TMVA__TSynapse.html:1552,Availability,error,error,1552,"e(); voidTObject::AbstractMethod(const char* method) const; voidAdjustWeight(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalculateDelta(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidDecayLearningRate(Double_t rate); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetDEDw(); Double_tGetDelta(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Double_tGetLearningRate(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetWeight(); Double_tGetWeightedDelta(); Double_tGetWeightedValue(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash()",MatchSource.WIKI,root/html604/TMVA__TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TSynapse.html
https://root.cern/root/html604/TMVA__TSynapse.html:1636,Availability,error,error,1636,"ual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalculateDelta(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidDecayLearningRate(Double_t rate); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetDEDw(); Double_tGetDelta(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Double_tGetLearningRate(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetWeight(); Double_tGetWeightedDelta(); Double_tGetWeightedValue(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; vir",MatchSource.WIKI,root/html604/TMVA__TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TSynapse.html
https://root.cern/root/html604/TMVA__TSynapse.html:6287,Availability,error,error,6287,"mt, va_list va) const; voidTObject::MakeZombie(). private:. TMVA::MsgLogger&Log() const. Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCountnumber of updates contributing to error field; Double_tfDEDwsum of deltas; Double_tfDeltalocal error field; Double_tfLearnRatelearning rate parameter; TMVA::TNeuron*fPostNeuronpointer to post-neuron; TMVA::TNeuron*fPreNeuronpointer to pre-neuron; Double_tfWeightweight of the synapse. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSynapse(); Default constructor. TSynapse(TNeuron * pre, TNeuron * post, Double_t w); Constructor that connects two neurons. void SetWeight(Double_t weight); Sets the weight of the synapse.; This weight is the multiplying factor applied on the; output of a neuron in the linear combination given as input; of another neuron. void SetDEDw(Double_t DEDw); Sets the derivative of the total error wrt the synapse weight. virtual ~TSynapse(); {}. Double_t GetWeight(); { return fweight; }. Double_t GetDEDw(); { return fDEDw; }. » Author: Christophe.Delaere@cern.ch 20/07/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/mlp:$Id$ » Last generated: 2015-06-02 16:19; This page has been automatically generated. For comments or s",MatchSource.WIKI,root/html604/TMVA__TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TSynapse.html
https://root.cern/root/html604/TMVA__TSynapse.html:6348,Availability,error,error,6348,"mt, va_list va) const; voidTObject::MakeZombie(). private:. TMVA::MsgLogger&Log() const. Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCountnumber of updates contributing to error field; Double_tfDEDwsum of deltas; Double_tfDeltalocal error field; Double_tfLearnRatelearning rate parameter; TMVA::TNeuron*fPostNeuronpointer to post-neuron; TMVA::TNeuron*fPreNeuronpointer to pre-neuron; Double_tfWeightweight of the synapse. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSynapse(); Default constructor. TSynapse(TNeuron * pre, TNeuron * post, Double_t w); Constructor that connects two neurons. void SetWeight(Double_t weight); Sets the weight of the synapse.; This weight is the multiplying factor applied on the; output of a neuron in the linear combination given as input; of another neuron. void SetDEDw(Double_t DEDw); Sets the derivative of the total error wrt the synapse weight. virtual ~TSynapse(); {}. Double_t GetWeight(); { return fweight; }. Double_t GetDEDw(); { return fDEDw; }. » Author: Christophe.Delaere@cern.ch 20/07/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/mlp:$Id$ » Last generated: 2015-06-02 16:19; This page has been automatically generated. For comments or s",MatchSource.WIKI,root/html604/TMVA__TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TSynapse.html
https://root.cern/root/html604/TMVA__TSynapse.html:7016,Availability,error,error,7016,"Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCountnumber of updates contributing to error field; Double_tfDEDwsum of deltas; Double_tfDeltalocal error field; Double_tfLearnRatelearning rate parameter; TMVA::TNeuron*fPostNeuronpointer to post-neuron; TMVA::TNeuron*fPreNeuronpointer to pre-neuron; Double_tfWeightweight of the synapse. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSynapse(); Default constructor. TSynapse(TNeuron * pre, TNeuron * post, Double_t w); Constructor that connects two neurons. void SetWeight(Double_t weight); Sets the weight of the synapse.; This weight is the multiplying factor applied on the; output of a neuron in the linear combination given as input; of another neuron. void SetDEDw(Double_t DEDw); Sets the derivative of the total error wrt the synapse weight. virtual ~TSynapse(); {}. Double_t GetWeight(); { return fweight; }. Double_t GetDEDw(); { return fDEDw; }. » Author: Christophe.Delaere@cern.ch 20/07/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/mlp:$Id$ » Last generated: 2015-06-02 16:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TSynapse.html
https://root.cern/root/html604/TMVA__TSynapse.html:6263,Deployability,update,updates,6263,"mt, va_list va) const; voidTObject::MakeZombie(). private:. TMVA::MsgLogger&Log() const. Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCountnumber of updates contributing to error field; Double_tfDEDwsum of deltas; Double_tfDeltalocal error field; Double_tfLearnRatelearning rate parameter; TMVA::TNeuron*fPostNeuronpointer to post-neuron; TMVA::TNeuron*fPreNeuronpointer to pre-neuron; Double_tfWeightweight of the synapse. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSynapse(); Default constructor. TSynapse(TNeuron * pre, TNeuron * post, Double_t w); Constructor that connects two neurons. void SetWeight(Double_t weight); Sets the weight of the synapse.; This weight is the multiplying factor applied on the; output of a neuron in the linear combination given as input; of another neuron. void SetDEDw(Double_t DEDw); Sets the derivative of the total error wrt the synapse weight. virtual ~TSynapse(); {}. Double_t GetWeight(); { return fweight; }. Double_t GetDEDw(); { return fDEDw; }. » Author: Christophe.Delaere@cern.ch 20/07/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/mlp:$Id$ » Last generated: 2015-06-02 16:19; This page has been automatically generated. For comments or s",MatchSource.WIKI,root/html604/TMVA__TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TSynapse.html
https://root.cern/root/html604/TMVA__TSynapse.html:322,Usability,simpl,simple,322,". TMVA::TSynapse. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MLP; » TMVA::TSynapse. class TMVA::TSynapse: public TObject. TSynapse. This is a simple weighted bidirectionnal connection between; two neurons.; A network is built connecting two neurons by a synapse.; In addition to the value, the synapse can return the DeDw. Function Members (Methods); public:. virtual~TSynapse(); voidTObject::AbstractMethod(const char* method) const; voidAdjustWeight(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalculateDelta(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidDecayLearningRate(Double_t rate); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetDEDw(); Double_tGetDelta(); virtual Option_t*TObject::GetDrawOption() const;",MatchSource.WIKI,root/html604/TMVA__TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__TSynapse.html
https://root.cern/root/html604/TMVA__Types.html:2790,Testability,log,logger,2790,"nalysisTypekMaxAnalysisType; static TMVA::Types::EMVAkMaxMethod; static TMVA::Types::ESBTypekMaxSBType; static TMVA::Types::ETreeTypekMaxTreeType; static TMVA::Types::EVariableTransformkMaxVariableTransform; static TMVA::Types::EAnalysisTypekMulticlass; static TMVA::Types::EAnalysisTypekNoAnalysisType; static TMVA::Types::EVariableTransformkNormalized; static TMVA::Types::EVariableTransformkPCA; static TMVA::Types::EMVAkPDEFoam; static TMVA::Types::EMVAkPDERS; static TMVA::Types::EMVAkPlugins; static TMVA::Types::EVariableTransformkRearranged; static TMVA::Types::EAnalysisTypekRegression; static TMVA::Types::EMVAkRuleFit; static TMVA::Types::ESBTypekSBBoth; static TMVA::Types::EMVAkSVM; static TMVA::Types::ESBTypekSignal; static TMVA::Types::EMVAkTMlpANN; static TMVA::Types::ETreeTypekTesting; static TMVA::Types::ETreeTypekTraining; static TMVA::Types::ETreeTypekTrainingOriginal; static TMVA::Types::ESBTypekTrueType; static TMVA::Types::EVariableTransformkUniform; static TMVA::Types::ETreeTypekValidation; static TMVA::Types::EMVAkVariable. private:. TMVA::MsgLogger*fLoggermessage logger; map<TString,TMVA::Types::EMVA>fStr2typetypes-to-text map; static atomic<TMVA::Types*>fgTypesPtr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Types(); constructor. ~Types(); destructor. TMVA::Types& Instance(); the the single instance of ""Types"" if existin already, or create it (Signleton). void DestroyInstance(); ""destructor"" of the single instance. Bool_t AddTypeMapping(TMVA::Types::EMVA method, const TString& methodname). TString GetMethodName(TMVA::Types::EMVA method) const. Types::EMVA GetMethodType(const TString& method) const. Types(). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-09-08 17:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__Types.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__Types.html
https://root.cern/root/html604/TMVA__VariableDecorrTransform.html:1504,Availability,error,error,1504,"TObject::AppendPad(Option_t* option = """"); virtual voidAttachXMLTo(void* parent); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTMVA::VariableTransformBase::CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tTMVA::VariableTransformBase::GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringTMVA::VariableTransformBase::GetShortName() const; virtual const char*TObject::GetTitle() const; virtual vector<TString>*GetT",MatchSource.WIKI,root/html604/TMVA__VariableDecorrTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableDecorrTransform.html
https://root.cern/root/html604/TMVA__VariableDecorrTransform.html:1588,Availability,error,error,1588,"rtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTMVA::VariableTransformBase::CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tTMVA::VariableTransformBase::GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringTMVA::VariableTransformBase::GetShortName() const; virtual const char*TObject::GetTitle() const; virtual vector<TString>*GetTransformationStrings(Int_t cls) const; virtual UInt_tTObject::GetUniqueID() const; T",MatchSource.WIKI,root/html604/TMVA__VariableDecorrTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableDecorrTransform.html
https://root.cern/root/html604/TMVA__VariableDecorrTransform.html:2119,Availability,mask,mask,2119,"mitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tTMVA::VariableTransformBase::GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringTMVA::VariableTransformBase::GetShortName() const; virtual const char*TObject::GetTitle() const; virtual vector<TString>*GetTransformationStrings(Int_t cls) const; virtual UInt_tTObject::GetUniqueID() const; TMVA::Types::EVariableTransformTMVA::VariableTransformBase::GetVariableTransform() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitialize(); virtual voidTObject::Inspect() constMENU ; virtual const TMVA::Event*InverseTransform(const TMVA::Event*const, Int_t cls) const",MatchSource.WIKI,root/html604/TMVA__VariableDecorrTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableDecorrTransform.html
https://root.cern/root/html604/TMVA__VariableDecorrTransform.html:5629,Availability,mask,mask,5629,"formation(ostream& o); virtual Int_tTObject::Read(const char* name); virtual voidReadFromXML(void* trfnode); virtual voidReadTransformationFromStream(istream&, const TString&); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTMVA::VariableTransformBase::SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::VariableTransformBase::SetEnabled(Bool_t e); voidTMVA::VariableTransformBase::SetNormalise(Bool_t n); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTMVA::VariableTransformBase::SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; voidTMVA::VariableTransformBase::SetOutputDataSetInfo(TMVA::DataSetInfo* outputDsi); voidTMVA::VariableTransformBase::SetTMVAVersion(TMVA::TMVAVersion_t v); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::VariableTransformBase::SetUseSignalTransform(Bool_t e = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; const vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Spectators() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; const vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Targets() const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTMVA::VariableTransformBase::ToggleInputSortOrder(Bool_t sortOrder); virtual const TMVA::Event*Transform(const TMVA::Event*const, Int_t cls) const; virtual voidTObject::UseCurrentS",MatchSource.WIKI,root/html604/TMVA__VariableDecorrTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableDecorrTransform.html
https://root.cern/root/html604/TMVA__VariableDecorrTransform.html:9698,Integrability,message,message,9698,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<TMatrixD*>fDecorrMatrices! Decorrelation matrix [class0/class1/.../all classes]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableDecorrTransform( DataSetInfo& dsi ); constructor. ~VariableDecorrTransform(); destructor. void Initialize(); initialisation. Bool_t PrepareTransformation(const vector<TMVA::Event*>& ); calculate the decorrelation matrix and the normalization. std::vector<TString>* GetTransformationStrings(Int_t cls) const; creates string with variable transformations applied. const TMVA::Event* Transform(const TMVA::Event*const , Int_t cls) const; apply the decorrelation transfor",MatchSource.WIKI,root/html604/TMVA__VariableDecorrTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableDecorrTransform.html
https://root.cern/root/html604/TMVA__VariableDecorrTransform.html:9614,Modifiability,variab,variables,9614,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<TMatrixD*>fDecorrMatrices! Decorrelation matrix [class0/class1/.../all classes]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableDecorrTransform( DataSetInfo& dsi ); constructor. ~VariableDecorrTransform(); destructor. void Initialize(); initialisation. Bool_t PrepareTransformation(const vector<TMVA::Event*>& ); calculate the decorrelation matrix and the normalization. std::vector<TString>* GetTransformationStrings(Int_t cls) const; creates string with variable transformations applied. const TMVA::Event* Transform(const TMVA::Event*const , Int_t cls) const; apply the decorrelation transfor",MatchSource.WIKI,root/html604/TMVA__VariableDecorrTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableDecorrTransform.html
https://root.cern/root/html604/TMVA__VariableDecorrTransform.html:9798,Modifiability,variab,variables,9798,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<TMatrixD*>fDecorrMatrices! Decorrelation matrix [class0/class1/.../all classes]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableDecorrTransform( DataSetInfo& dsi ); constructor. ~VariableDecorrTransform(); destructor. void Initialize(); initialisation. Bool_t PrepareTransformation(const vector<TMVA::Event*>& ); calculate the decorrelation matrix and the normalization. std::vector<TString>* GetTransformationStrings(Int_t cls) const; creates string with variable transformations applied. const TMVA::Event* Transform(const TMVA::Event*const , Int_t cls) const; apply the decorrelation transfor",MatchSource.WIKI,root/html604/TMVA__VariableDecorrTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableDecorrTransform.html
https://root.cern/root/html604/TMVA__VariableDecorrTransform.html:10510,Modifiability,variab,variable,10510,"tInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<TMatrixD*>fDecorrMatrices! Decorrelation matrix [class0/class1/.../all classes]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableDecorrTransform( DataSetInfo& dsi ); constructor. ~VariableDecorrTransform(); destructor. void Initialize(); initialisation. Bool_t PrepareTransformation(const vector<TMVA::Event*>& ); calculate the decorrelation matrix and the normalization. std::vector<TString>* GetTransformationStrings(Int_t cls) const; creates string with variable transformations applied. const TMVA::Event* Transform(const TMVA::Event*const , Int_t cls) const; apply the decorrelation transformation. const TMVA::Event* InverseTransform(const TMVA::Event*const , Int_t cls) const; apply the inverse decorrelation transformation ...; TODO : ... build the inverse transformation. void CalcSQRMats(const vector<TMVA::Event*>& , Int_t maxCls); compute square-root matrices for signal and background. void WriteTransformationToStream(ostream& ) const; write the decorrelation matrix to the stream. void AttachXMLTo(void* parent); node attachment to parent. void ReadFromXML(void* trfnode); Read the transformation matrices from the xml node. void ReadTransformationFromStream(istream& , const TString& ); Read the decorellation matrix from an input stream. void PrintTransformation(ostream& o); prints the transformation matrix. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); creat",MatchSource.WIKI,root/html604/TMVA__VariableDecorrTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableDecorrTransform.html
https://root.cern/root/html604/TMVA__VariableDecorrTransform.html:9706,Testability,log,logger,9706,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<TMatrixD*>fDecorrMatrices! Decorrelation matrix [class0/class1/.../all classes]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableDecorrTransform( DataSetInfo& dsi ); constructor. ~VariableDecorrTransform(); destructor. void Initialize(); initialisation. Bool_t PrepareTransformation(const vector<TMVA::Event*>& ); calculate the decorrelation matrix and the normalization. std::vector<TString>* GetTransformationStrings(Int_t cls) const; creates string with variable transformations applied. const TMVA::Event* Transform(const TMVA::Event*const , Int_t cls) const; apply the decorrelation transfor",MatchSource.WIKI,root/html604/TMVA__VariableDecorrTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableDecorrTransform.html
https://root.cern/root/html604/TMVA__VariableGaussTransform.html:1544,Availability,error,error,1544,"TObject::AppendPad(Option_t* option = """"); virtual voidAttachXMLTo(void* parent); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTMVA::VariableTransformBase::CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tTMVA::VariableTransformBase::GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringTMVA::VariableTransformBase::GetShortName() const; virtual const char*TObject::GetTitle() const; virtual vector<TString>*TMVA",MatchSource.WIKI,root/html604/TMVA__VariableGaussTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableGaussTransform.html
https://root.cern/root/html604/TMVA__VariableGaussTransform.html:1628,Availability,error,error,1628,"rtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTMVA::VariableTransformBase::CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tTMVA::VariableTransformBase::GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringTMVA::VariableTransformBase::GetShortName() const; virtual const char*TObject::GetTitle() const; virtual vector<TString>*TMVA::VariableTransformBase::GetTransformationStrings(Int_t cls) const; virtual UInt_tTO",MatchSource.WIKI,root/html604/TMVA__VariableGaussTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableGaussTransform.html
https://root.cern/root/html604/TMVA__VariableGaussTransform.html:2159,Availability,mask,mask,2159,"mitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tTMVA::VariableTransformBase::GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringTMVA::VariableTransformBase::GetShortName() const; virtual const char*TObject::GetTitle() const; virtual vector<TString>*TMVA::VariableTransformBase::GetTransformationStrings(Int_t cls) const; virtual UInt_tTObject::GetUniqueID() const; TMVA::Types::EVariableTransformTMVA::VariableTransformBase::GetVariableTransform() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitialize(); virtual voidTObject::Inspect() constMENU ; virtual const TMVA::Event*InverseTransform(const TMVA::",MatchSource.WIKI,root/html604/TMVA__VariableGaussTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableGaussTransform.html
https://root.cern/root/html604/TMVA__VariableGaussTransform.html:5696,Availability,mask,mask,5696,"formation(ostream& o); virtual Int_tTObject::Read(const char* name); virtual voidReadFromXML(void* trfnode); virtual voidReadTransformationFromStream(istream&, const TString&); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTMVA::VariableTransformBase::SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::VariableTransformBase::SetEnabled(Bool_t e); voidTMVA::VariableTransformBase::SetNormalise(Bool_t n); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTMVA::VariableTransformBase::SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; voidTMVA::VariableTransformBase::SetOutputDataSetInfo(TMVA::DataSetInfo* outputDsi); voidTMVA::VariableTransformBase::SetTMVAVersion(TMVA::TMVAVersion_t v); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::VariableTransformBase::SetUseSignalTransform(Bool_t e = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; const vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Spectators() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; const vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Targets() const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTMVA::VariableTransformBase::ToggleInputSortOrder(Bool_t sortOrder); virtual const TMVA::Event*Transform(const TMVA::Event*const, Int_t cls) const; virtual voidTObject::UseCurrentS",MatchSource.WIKI,root/html604/TMVA__VariableGaussTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableGaussTransform.html
https://root.cern/root/html604/TMVA__VariableGaussTransform.html:9768,Integrability,message,message,9768,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<vector<TH1F*> >fCumulativeDist! The Cummulative distributions; vector<vector<TMVA::PDF*> >fCumulativePDFThe cumulative PDF; UInt_tfElementsperbinav number of events stored per bin in cum dist; Bool_tfFlatNotGauss; Int_tfPdfMaxSmooth; Int_tfPdfMinSmooth. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableGaussTransform(TMVA::DataSetInfo& dsi, TString strcor = """"); constructor; can only be applied one after the other when they are created. But in order to; determine the Gauss transformation. ~VariableGaussTransform( void ); destructor. void Initialize(). Bool_t PrepareTransformation(const vecto",MatchSource.WIKI,root/html604/TMVA__VariableGaussTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableGaussTransform.html
https://root.cern/root/html604/TMVA__VariableGaussTransform.html:398,Modifiability,variab,variables,398,". TMVA::VariableGaussTransform. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::VariableGaussTransform. class TMVA::VariableGaussTransform: public TMVA::VariableTransformBase. Gaussian Transformation of input variables. Function Members (Methods); public:. virtual~VariableGaussTransform(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAttachXMLTo(void* parent); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTMVA::VariableTransformBase::CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual c",MatchSource.WIKI,root/html604/TMVA__VariableGaussTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableGaussTransform.html
https://root.cern/root/html604/TMVA__VariableGaussTransform.html:9684,Modifiability,variab,variables,9684,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<vector<TH1F*> >fCumulativeDist! The Cummulative distributions; vector<vector<TMVA::PDF*> >fCumulativePDFThe cumulative PDF; UInt_tfElementsperbinav number of events stored per bin in cum dist; Bool_tfFlatNotGauss; Int_tfPdfMaxSmooth; Int_tfPdfMinSmooth. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableGaussTransform(TMVA::DataSetInfo& dsi, TString strcor = """"); constructor; can only be applied one after the other when they are created. But in order to; determine the Gauss transformation. ~VariableGaussTransform( void ); destructor. void Initialize(). Bool_t PrepareTransformation(const vecto",MatchSource.WIKI,root/html604/TMVA__VariableGaussTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableGaussTransform.html
https://root.cern/root/html604/TMVA__VariableGaussTransform.html:9868,Modifiability,variab,variables,9868,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<vector<TH1F*> >fCumulativeDist! The Cummulative distributions; vector<vector<TMVA::PDF*> >fCumulativePDFThe cumulative PDF; UInt_tfElementsperbinav number of events stored per bin in cum dist; Bool_tfFlatNotGauss; Int_tfPdfMaxSmooth; Int_tfPdfMinSmooth. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableGaussTransform(TMVA::DataSetInfo& dsi, TString strcor = """"); constructor; can only be applied one after the other when they are created. But in order to; determine the Gauss transformation. ~VariableGaussTransform( void ); destructor. void Initialize(). Bool_t PrepareTransformation(const vecto",MatchSource.WIKI,root/html604/TMVA__VariableGaussTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableGaussTransform.html
https://root.cern/root/html604/TMVA__VariableGaussTransform.html:9776,Testability,log,logger,9776,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<vector<TH1F*> >fCumulativeDist! The Cummulative distributions; vector<vector<TMVA::PDF*> >fCumulativePDFThe cumulative PDF; UInt_tfElementsperbinav number of events stored per bin in cum dist; Bool_tfFlatNotGauss; Int_tfPdfMaxSmooth; Int_tfPdfMinSmooth. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableGaussTransform(TMVA::DataSetInfo& dsi, TString strcor = """"); constructor; can only be applied one after the other when they are created. But in order to; determine the Gauss transformation. ~VariableGaussTransform( void ); destructor. void Initialize(). Bool_t PrepareTransformation(const vecto",MatchSource.WIKI,root/html604/TMVA__VariableGaussTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableGaussTransform.html
https://root.cern/root/html604/TMVA__VariableIdentityTransform.html:1512,Availability,error,error,1512,"TObject::AppendPad(Option_t* option = """"); virtual voidAttachXMLTo(void* parent); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTMVA::VariableTransformBase::CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tTMVA::VariableTransformBase::GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringTMVA::VariableTransformBase::GetShortName() const; virtual const char*TObject::GetTitle() const; virtual vector<TString>*TMVA",MatchSource.WIKI,root/html604/TMVA__VariableIdentityTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableIdentityTransform.html
https://root.cern/root/html604/TMVA__VariableIdentityTransform.html:1596,Availability,error,error,1596,"rtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTMVA::VariableTransformBase::CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tTMVA::VariableTransformBase::GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringTMVA::VariableTransformBase::GetShortName() const; virtual const char*TObject::GetTitle() const; virtual vector<TString>*TMVA::VariableTransformBase::GetTransformationStrings(Int_t cls) const; virtual UInt_tTO",MatchSource.WIKI,root/html604/TMVA__VariableIdentityTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableIdentityTransform.html
https://root.cern/root/html604/TMVA__VariableIdentityTransform.html:2127,Availability,mask,mask,2127,"mitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tTMVA::VariableTransformBase::GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringTMVA::VariableTransformBase::GetShortName() const; virtual const char*TObject::GetTitle() const; virtual vector<TString>*TMVA::VariableTransformBase::GetTransformationStrings(Int_t cls) const; virtual UInt_tTObject::GetUniqueID() const; TMVA::Types::EVariableTransformTMVA::VariableTransformBase::GetVariableTransform() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitialize(); virtual voidTObject::Inspect() constMENU ; virtual const TMVA::Event*InverseTransform(const TMVA::",MatchSource.WIKI,root/html604/TMVA__VariableIdentityTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableIdentityTransform.html
https://root.cern/root/html604/TMVA__VariableIdentityTransform.html:5700,Availability,mask,mask,5700,"nsformation(ostream&); virtual Int_tTObject::Read(const char* name); virtual voidReadFromXML(void* trfnode); virtual voidReadTransformationFromStream(istream&, const TString&); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTMVA::VariableTransformBase::SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::VariableTransformBase::SetEnabled(Bool_t e); voidTMVA::VariableTransformBase::SetNormalise(Bool_t n); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTMVA::VariableTransformBase::SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; voidTMVA::VariableTransformBase::SetOutputDataSetInfo(TMVA::DataSetInfo* outputDsi); voidTMVA::VariableTransformBase::SetTMVAVersion(TMVA::TMVAVersion_t v); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::VariableTransformBase::SetUseSignalTransform(Bool_t e = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; const vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Spectators() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; const vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Targets() const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTMVA::VariableTransformBase::ToggleInputSortOrder(Bool_t sortOrder); virtual const TMVA::Event*Transform(const TMVA::Event*const, Int_t cls) const; virtual voidTObject::UseCurrentS",MatchSource.WIKI,root/html604/TMVA__VariableIdentityTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableIdentityTransform.html
https://root.cern/root/html604/TMVA__VariableIdentityTransform.html:9608,Integrability,message,message,9608,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableIdentityTransform( DataSetInfo& dsi ); constructor. void Initialize(); nothing to initialize. Bool_t PrepareTransformation(const vector<TMVA::Event*>& ); the identity does not need to be prepared, only calculate the normalization. void AttachXMLTo(void* parent); identity transformation to write to XML; Log() << kFATAL << ""Please implement writing of transformation as XML"" << Endl;. void ReadFromXML(void* trfnode); reding the identity transformation from XML. const TMVA::Event* Transform(const TMVA::Event*const , Int_t cls) const; identity transform returns sa",MatchSource.WIKI,root/html604/TMVA__VariableIdentityTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableIdentityTransform.html
https://root.cern/root/html604/TMVA__VariableIdentityTransform.html:9524,Modifiability,variab,variables,9524,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableIdentityTransform( DataSetInfo& dsi ); constructor. void Initialize(); nothing to initialize. Bool_t PrepareTransformation(const vector<TMVA::Event*>& ); the identity does not need to be prepared, only calculate the normalization. void AttachXMLTo(void* parent); identity transformation to write to XML; Log() << kFATAL << ""Please implement writing of transformation as XML"" << Endl;. void ReadFromXML(void* trfnode); reding the identity transformation from XML. const TMVA::Event* Transform(const TMVA::Event*const , Int_t cls) const; identity transform returns sa",MatchSource.WIKI,root/html604/TMVA__VariableIdentityTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableIdentityTransform.html
https://root.cern/root/html604/TMVA__VariableIdentityTransform.html:9708,Modifiability,variab,variables,9708,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableIdentityTransform( DataSetInfo& dsi ); constructor. void Initialize(); nothing to initialize. Bool_t PrepareTransformation(const vector<TMVA::Event*>& ); the identity does not need to be prepared, only calculate the normalization. void AttachXMLTo(void* parent); identity transformation to write to XML; Log() << kFATAL << ""Please implement writing of transformation as XML"" << Endl;. void ReadFromXML(void* trfnode); reding the identity transformation from XML. const TMVA::Event* Transform(const TMVA::Event*const , Int_t cls) const; identity transform returns sa",MatchSource.WIKI,root/html604/TMVA__VariableIdentityTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableIdentityTransform.html
https://root.cern/root/html604/TMVA__VariableIdentityTransform.html:9616,Testability,log,logger,9616,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableIdentityTransform( DataSetInfo& dsi ); constructor. void Initialize(); nothing to initialize. Bool_t PrepareTransformation(const vector<TMVA::Event*>& ); the identity does not need to be prepared, only calculate the normalization. void AttachXMLTo(void* parent); identity transformation to write to XML; Log() << kFATAL << ""Please implement writing of transformation as XML"" << Endl;. void ReadFromXML(void* trfnode); reding the identity transformation from XML. const TMVA::Event* Transform(const TMVA::Event*const , Int_t cls) const; identity transform returns sa",MatchSource.WIKI,root/html604/TMVA__VariableIdentityTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableIdentityTransform.html
https://root.cern/root/html604/TMVA__VariableNormalizeTransform.html:1591,Availability,error,error,1591,"rent); virtual voidTObject::Browse(TBrowser* b); voidBuildTransformationFromVarInfo(const vector<TMVA::VariableInfo>& var); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTMVA::VariableTransformBase::CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tTMVA::VariableTransformBase::GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringTMVA::VariableTransformBase::GetShortName() const; virtual const char*TObject::GetTitle() const; virtual vector<TString>*GetT",MatchSource.WIKI,root/html604/TMVA__VariableNormalizeTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableNormalizeTransform.html
https://root.cern/root/html604/TMVA__VariableNormalizeTransform.html:1675,Availability,error,error,1675,"const vector<TMVA::VariableInfo>& var); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTMVA::VariableTransformBase::CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tTMVA::VariableTransformBase::GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringTMVA::VariableTransformBase::GetShortName() const; virtual const char*TObject::GetTitle() const; virtual vector<TString>*GetTransformationStrings(Int_t cls) const; virtual UInt_tTObject::GetUniqueID() const; T",MatchSource.WIKI,root/html604/TMVA__VariableNormalizeTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableNormalizeTransform.html
https://root.cern/root/html604/TMVA__VariableNormalizeTransform.html:2206,Availability,mask,mask,2206,"mitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tTMVA::VariableTransformBase::GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringTMVA::VariableTransformBase::GetShortName() const; virtual const char*TObject::GetTitle() const; virtual vector<TString>*GetTransformationStrings(Int_t cls) const; virtual UInt_tTObject::GetUniqueID() const; TMVA::Types::EVariableTransformTMVA::VariableTransformBase::GetVariableTransform() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitialize(); virtual voidTObject::Inspect() constMENU ; virtual const TMVA::Event*InverseTransform(const TMVA::Event*const, Int_t cls) const",MatchSource.WIKI,root/html604/TMVA__VariableNormalizeTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableNormalizeTransform.html
https://root.cern/root/html604/TMVA__VariableNormalizeTransform.html:5722,Availability,mask,mask,5722,"formation(ostream& o); virtual Int_tTObject::Read(const char* name); virtual voidReadFromXML(void* trfnode); virtual voidReadTransformationFromStream(istream&, const TString&); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTMVA::VariableTransformBase::SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::VariableTransformBase::SetEnabled(Bool_t e); voidTMVA::VariableTransformBase::SetNormalise(Bool_t n); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTMVA::VariableTransformBase::SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; voidTMVA::VariableTransformBase::SetOutputDataSetInfo(TMVA::DataSetInfo* outputDsi); voidTMVA::VariableTransformBase::SetTMVAVersion(TMVA::TMVAVersion_t v); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::VariableTransformBase::SetUseSignalTransform(Bool_t e = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; const vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Spectators() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; const vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Targets() const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTMVA::VariableTransformBase::ToggleInputSortOrder(Bool_t sortOrder); virtual const TMVA::Event*Transform(const TMVA::Event*const, Int_t cls) const; virtual voidTObject::UseCurrentS",MatchSource.WIKI,root/html604/TMVA__VariableNormalizeTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableNormalizeTransform.html
https://root.cern/root/html604/TMVA__VariableNormalizeTransform.html:9710,Integrability,message,message,9710,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. TMVA::VariableNormalizeTransform::VectorOfFloatVectorsfMax! Max of source range; TMVA::VariableNormalizeTransform::VectorOfFloatVectorsfMin! Min of source range. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableNormalizeTransform( DataSetInfo& dsi ); constructor. ~VariableNormalizeTransform(). void Initialize(); initialization of the normalization transformation. Bool_t PrepareTransformation(const vector<TMVA::Event*>& ); prepare transformation. const TMVA::Event* Transform(const TMVA::Event*const , Int_t cls) const. const TMVA::Event* InverseTransform(const TMVA::Event*const , Int_t cls) const; a",MatchSource.WIKI,root/html604/TMVA__VariableNormalizeTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableNormalizeTransform.html
https://root.cern/root/html604/TMVA__VariableNormalizeTransform.html:9626,Modifiability,variab,variables,9626,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. TMVA::VariableNormalizeTransform::VectorOfFloatVectorsfMax! Max of source range; TMVA::VariableNormalizeTransform::VectorOfFloatVectorsfMin! Min of source range. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableNormalizeTransform( DataSetInfo& dsi ); constructor. ~VariableNormalizeTransform(). void Initialize(); initialization of the normalization transformation. Bool_t PrepareTransformation(const vector<TMVA::Event*>& ); prepare transformation. const TMVA::Event* Transform(const TMVA::Event*const , Int_t cls) const. const TMVA::Event* InverseTransform(const TMVA::Event*const , Int_t cls) const; a",MatchSource.WIKI,root/html604/TMVA__VariableNormalizeTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableNormalizeTransform.html
https://root.cern/root/html604/TMVA__VariableNormalizeTransform.html:9810,Modifiability,variab,variables,9810,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. TMVA::VariableNormalizeTransform::VectorOfFloatVectorsfMax! Max of source range; TMVA::VariableNormalizeTransform::VectorOfFloatVectorsfMin! Min of source range. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableNormalizeTransform( DataSetInfo& dsi ); constructor. ~VariableNormalizeTransform(). void Initialize(); initialization of the normalization transformation. Bool_t PrepareTransformation(const vector<TMVA::Event*>& ); prepare transformation. const TMVA::Event* Transform(const TMVA::Event*const , Int_t cls) const. const TMVA::Event* InverseTransform(const TMVA::Event*const , Int_t cls) const; a",MatchSource.WIKI,root/html604/TMVA__VariableNormalizeTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableNormalizeTransform.html
https://root.cern/root/html604/TMVA__VariableNormalizeTransform.html:10888,Modifiability,variab,variable,10888,"VA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. TMVA::VariableNormalizeTransform::VectorOfFloatVectorsfMax! Max of source range; TMVA::VariableNormalizeTransform::VectorOfFloatVectorsfMin! Min of source range. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableNormalizeTransform( DataSetInfo& dsi ); constructor. ~VariableNormalizeTransform(). void Initialize(); initialization of the normalization transformation. Bool_t PrepareTransformation(const vector<TMVA::Event*>& ); prepare transformation. const TMVA::Event* Transform(const TMVA::Event*const , Int_t cls) const. const TMVA::Event* InverseTransform(const TMVA::Event*const , Int_t cls) const; apply the inverse transformation. void CalcNormalizationParams(const vector<TMVA::Event*>& events); compute offset and scale from min and max. std::vector<TString>* GetTransformationStrings(Int_t cls) const; creates string with variable transformations applied. void WriteTransformationToStream(ostream& ) const; write the transformation to the stream. void AttachXMLTo(void* parent); create XML description of Normalize transformation. void ReadFromXML(void* trfnode); Read the transformation matrices from the xml node. void BuildTransformationFromVarInfo(const vector<TMVA::VariableInfo>& var); this method is only used when building a normalization transformation; from old text files; in this case regression didn't exist and there were no targets. void ReadTransformationFromStream(istream& , const TString& ); Read the variable ranges from an input stream. void PrintTransformation(ostream& o); prints the transformation ranges. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); creates a normalizing function; TODO include target-transformation into makefunction. VariableNormalizeTransform( DataSetInfo& dsi ). » Author: Andreas Hoecker, Joerg ",MatchSource.WIKI,root/html604/TMVA__VariableNormalizeTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableNormalizeTransform.html
https://root.cern/root/html604/TMVA__VariableNormalizeTransform.html:11486,Modifiability,variab,variable,11486,"fFloatVectorsfMin! Min of source range. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableNormalizeTransform( DataSetInfo& dsi ); constructor. ~VariableNormalizeTransform(). void Initialize(); initialization of the normalization transformation. Bool_t PrepareTransformation(const vector<TMVA::Event*>& ); prepare transformation. const TMVA::Event* Transform(const TMVA::Event*const , Int_t cls) const. const TMVA::Event* InverseTransform(const TMVA::Event*const , Int_t cls) const; apply the inverse transformation. void CalcNormalizationParams(const vector<TMVA::Event*>& events); compute offset and scale from min and max. std::vector<TString>* GetTransformationStrings(Int_t cls) const; creates string with variable transformations applied. void WriteTransformationToStream(ostream& ) const; write the transformation to the stream. void AttachXMLTo(void* parent); create XML description of Normalize transformation. void ReadFromXML(void* trfnode); Read the transformation matrices from the xml node. void BuildTransformationFromVarInfo(const vector<TMVA::VariableInfo>& var); this method is only used when building a normalization transformation; from old text files; in this case regression didn't exist and there were no targets. void ReadTransformationFromStream(istream& , const TString& ); Read the variable ranges from an input stream. void PrintTransformation(ostream& o); prints the transformation ranges. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); creates a normalizing function; TODO include target-transformation into makefunction. VariableNormalizeTransform( DataSetInfo& dsi ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__VariableNormalizeTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableNormalizeTransform.html
https://root.cern/root/html604/TMVA__VariableNormalizeTransform.html:9718,Testability,log,logger,9718,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. TMVA::VariableNormalizeTransform::VectorOfFloatVectorsfMax! Max of source range; TMVA::VariableNormalizeTransform::VectorOfFloatVectorsfMin! Min of source range. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableNormalizeTransform( DataSetInfo& dsi ); constructor. ~VariableNormalizeTransform(). void Initialize(); initialization of the normalization transformation. Bool_t PrepareTransformation(const vector<TMVA::Event*>& ); prepare transformation. const TMVA::Event* Transform(const TMVA::Event*const , Int_t cls) const. const TMVA::Event* InverseTransform(const TMVA::Event*const , Int_t cls) const; a",MatchSource.WIKI,root/html604/TMVA__VariableNormalizeTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableNormalizeTransform.html
https://root.cern/root/html604/TMVA__VariablePCATransform.html:1492,Availability,error,error,1492,"TObject::AppendPad(Option_t* option = """"); virtual voidAttachXMLTo(void* parent); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTMVA::VariableTransformBase::CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tTMVA::VariableTransformBase::GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringTMVA::VariableTransformBase::GetShortName() const; virtual const char*TObject::GetTitle() const; virtual vector<TString>*TMVA",MatchSource.WIKI,root/html604/TMVA__VariablePCATransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariablePCATransform.html
https://root.cern/root/html604/TMVA__VariablePCATransform.html:1576,Availability,error,error,1576,"rtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTMVA::VariableTransformBase::CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tTMVA::VariableTransformBase::GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringTMVA::VariableTransformBase::GetShortName() const; virtual const char*TObject::GetTitle() const; virtual vector<TString>*TMVA::VariableTransformBase::GetTransformationStrings(Int_t cls) const; virtual UInt_tTO",MatchSource.WIKI,root/html604/TMVA__VariablePCATransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariablePCATransform.html
https://root.cern/root/html604/TMVA__VariablePCATransform.html:2107,Availability,mask,mask,2107,"mitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tTMVA::VariableTransformBase::GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringTMVA::VariableTransformBase::GetShortName() const; virtual const char*TObject::GetTitle() const; virtual vector<TString>*TMVA::VariableTransformBase::GetTransformationStrings(Int_t cls) const; virtual UInt_tTObject::GetUniqueID() const; TMVA::Types::EVariableTransformTMVA::VariableTransformBase::GetVariableTransform() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitialize(); virtual voidTObject::Inspect() constMENU ; virtual const TMVA::Event*InverseTransform(const TMVA::",MatchSource.WIKI,root/html604/TMVA__VariablePCATransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariablePCATransform.html
https://root.cern/root/html604/TMVA__VariablePCATransform.html:5667,Availability,mask,mask,5667,"nsformation(ostream&); virtual Int_tTObject::Read(const char* name); virtual voidReadFromXML(void* trfnode); virtual voidReadTransformationFromStream(istream&, const TString&); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTMVA::VariableTransformBase::SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::VariableTransformBase::SetEnabled(Bool_t e); voidTMVA::VariableTransformBase::SetNormalise(Bool_t n); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTMVA::VariableTransformBase::SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; voidTMVA::VariableTransformBase::SetOutputDataSetInfo(TMVA::DataSetInfo* outputDsi); voidTMVA::VariableTransformBase::SetTMVAVersion(TMVA::TMVAVersion_t v); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::VariableTransformBase::SetUseSignalTransform(Bool_t e = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; const vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Spectators() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; const vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Targets() const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTMVA::VariableTransformBase::ToggleInputSortOrder(Bool_t sortOrder); virtual const TMVA::Event*Transform(const TMVA::Event*const, Int_t cls) const; virtual voidTObject::UseCurrentS",MatchSource.WIKI,root/html604/TMVA__VariablePCATransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariablePCATransform.html
https://root.cern/root/html604/TMVA__VariablePCATransform.html:11722,Energy Efficiency,allocate,allocated,11722,"const TMVA::Event* Transform(const TMVA::Event*const , Int_t cls) const; apply the principal component analysis. const TMVA::Event* InverseTransform(const TMVA::Event*const , Int_t cls) const; apply the principal component analysis; TODO: implementation of inverse transformation; Log() << kFATAL << ""Inverse transformation for PCA transformation not yet implemented. Hence, this transformation cannot be applied together with regression. Please contact the authors if necessary."" << Endl;. void CalculatePrincipalComponents(const vector<TMVA::Event*>& ); calculate the principal components for the signal and the background data; it uses the MakePrincipal method of ROOT's TPrincipal class. void X2P(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Calculate the principal components from the original data vector; x, and return it in p (function extracted from TPrincipal::X2P); It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). void P2X(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Perform the back-transformation from the principal components; pc, and return x; It's the users responsibility to make sure that both x and pc are; of the right size (i.e., memory must be allocated for p). void WriteTransformationToStream(ostream& ) const; write mean values to stream. void AttachXMLTo(void* parent); create XML description of PCA transformation. void ReadFromXML(void* trfnode); Read the transformation matrices from the xml node. void ReadTransformationFromStream(istream& , const TString& ); Read mean values from input stream. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); creates C++ code fragment of the PCA transform for inclusion in standalone C++ class. VariablePCATransform( DataSetInfo& dsi ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-0",MatchSource.WIKI,root/html604/TMVA__VariablePCATransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariablePCATransform.html
https://root.cern/root/html604/TMVA__VariablePCATransform.html:11999,Energy Efficiency,allocate,allocated,11999,"nt*const , Int_t cls) const; apply the principal component analysis; TODO: implementation of inverse transformation; Log() << kFATAL << ""Inverse transformation for PCA transformation not yet implemented. Hence, this transformation cannot be applied together with regression. Please contact the authors if necessary."" << Endl;. void CalculatePrincipalComponents(const vector<TMVA::Event*>& ); calculate the principal components for the signal and the background data; it uses the MakePrincipal method of ROOT's TPrincipal class. void X2P(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Calculate the principal components from the original data vector; x, and return it in p (function extracted from TPrincipal::X2P); It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). void P2X(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Perform the back-transformation from the principal components; pc, and return x; It's the users responsibility to make sure that both x and pc are; of the right size (i.e., memory must be allocated for p). void WriteTransformationToStream(ostream& ) const; write mean values to stream. void AttachXMLTo(void* parent); create XML description of PCA transformation. void ReadFromXML(void* trfnode); Read the transformation matrices from the xml node. void ReadTransformationFromStream(istream& , const TString& ); Read mean values from input stream. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); creates C++ code fragment of the PCA transform for inclusion in standalone C++ class. VariablePCATransform( DataSetInfo& dsi ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__VariablePCATransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariablePCATransform.html
https://root.cern/root/html604/TMVA__VariablePCATransform.html:9759,Integrability,message,message,9759,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<TMatrixD*>fEigenVectorseigenvectors; vector<TVectorD*>fMeanValuesmean values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariablePCATransform( DataSetInfo& dsi ); constructor. ~VariablePCATransform(); destructor. void Initialize(); initialization of the transformation.; Has to be called in the preparation and not in the constructor,; since the number of classes it not known at construction, but; only after the creation of the DataSet which might be later. Bool_t PrepareTransformation(const vector<TMVA::Event*>& ); calculate the principal components using the ROOT class TPrincipal; and the nor",MatchSource.WIKI,root/html604/TMVA__VariablePCATransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariablePCATransform.html
https://root.cern/root/html604/TMVA__VariablePCATransform.html:9675,Modifiability,variab,variables,9675,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<TMatrixD*>fEigenVectorseigenvectors; vector<TVectorD*>fMeanValuesmean values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariablePCATransform( DataSetInfo& dsi ); constructor. ~VariablePCATransform(); destructor. void Initialize(); initialization of the transformation.; Has to be called in the preparation and not in the constructor,; since the number of classes it not known at construction, but; only after the creation of the DataSet which might be later. Bool_t PrepareTransformation(const vector<TMVA::Event*>& ); calculate the principal components using the ROOT class TPrincipal; and the nor",MatchSource.WIKI,root/html604/TMVA__VariablePCATransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariablePCATransform.html
https://root.cern/root/html604/TMVA__VariablePCATransform.html:9859,Modifiability,variab,variables,9859,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<TMatrixD*>fEigenVectorseigenvectors; vector<TVectorD*>fMeanValuesmean values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariablePCATransform( DataSetInfo& dsi ); constructor. ~VariablePCATransform(); destructor. void Initialize(); initialization of the transformation.; Has to be called in the preparation and not in the constructor,; since the number of classes it not known at construction, but; only after the creation of the DataSet which might be later. Bool_t PrepareTransformation(const vector<TMVA::Event*>& ); calculate the principal components using the ROOT class TPrincipal; and the nor",MatchSource.WIKI,root/html604/TMVA__VariablePCATransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariablePCATransform.html
https://root.cern/root/html604/TMVA__VariablePCATransform.html:9767,Testability,log,logger,9767,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<TMatrixD*>fEigenVectorseigenvectors; vector<TVectorD*>fMeanValuesmean values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariablePCATransform( DataSetInfo& dsi ); constructor. ~VariablePCATransform(); destructor. void Initialize(); initialization of the transformation.; Has to be called in the preparation and not in the constructor,; since the number of classes it not known at construction, but; only after the creation of the DataSet which might be later. Bool_t PrepareTransformation(const vector<TMVA::Event*>& ); calculate the principal components using the ROOT class TPrincipal; and the nor",MatchSource.WIKI,root/html604/TMVA__VariablePCATransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariablePCATransform.html
https://root.cern/root/html604/TMVA__VariableRearrangeTransform.html:1516,Availability,error,error,1516,"TObject::AppendPad(Option_t* option = """"); virtual voidAttachXMLTo(void* parent); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTMVA::VariableTransformBase::CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tTMVA::VariableTransformBase::GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringTMVA::VariableTransformBase::GetShortName() const; virtual const char*TObject::GetTitle() const; virtual vector<TString>*GetT",MatchSource.WIKI,root/html604/TMVA__VariableRearrangeTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableRearrangeTransform.html
https://root.cern/root/html604/TMVA__VariableRearrangeTransform.html:1600,Availability,error,error,1600,"rtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTMVA::VariableTransformBase::CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tTMVA::VariableTransformBase::GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringTMVA::VariableTransformBase::GetShortName() const; virtual const char*TObject::GetTitle() const; virtual vector<TString>*GetTransformationStrings(Int_t cls) const; virtual UInt_tTObject::GetUniqueID() const; T",MatchSource.WIKI,root/html604/TMVA__VariableRearrangeTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableRearrangeTransform.html
https://root.cern/root/html604/TMVA__VariableRearrangeTransform.html:2131,Availability,mask,mask,2131,"mitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tTMVA::VariableTransformBase::GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringTMVA::VariableTransformBase::GetShortName() const; virtual const char*TObject::GetTitle() const; virtual vector<TString>*GetTransformationStrings(Int_t cls) const; virtual UInt_tTObject::GetUniqueID() const; TMVA::Types::EVariableTransformTMVA::VariableTransformBase::GetVariableTransform() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitialize(); virtual voidTObject::Inspect() constMENU ; virtual const TMVA::Event*InverseTransform(const TMVA::Event*const, Int_t cls) const",MatchSource.WIKI,root/html604/TMVA__VariableRearrangeTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableRearrangeTransform.html
https://root.cern/root/html604/TMVA__VariableRearrangeTransform.html:5647,Availability,mask,mask,5647,"formation(ostream& o); virtual Int_tTObject::Read(const char* name); virtual voidReadFromXML(void* trfnode); virtual voidReadTransformationFromStream(istream&, const TString&); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTMVA::VariableTransformBase::SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::VariableTransformBase::SetEnabled(Bool_t e); voidTMVA::VariableTransformBase::SetNormalise(Bool_t n); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTMVA::VariableTransformBase::SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; voidTMVA::VariableTransformBase::SetOutputDataSetInfo(TMVA::DataSetInfo* outputDsi); voidTMVA::VariableTransformBase::SetTMVAVersion(TMVA::TMVAVersion_t v); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::VariableTransformBase::SetUseSignalTransform(Bool_t e = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; const vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Spectators() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; const vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Targets() const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTMVA::VariableTransformBase::ToggleInputSortOrder(Bool_t sortOrder); virtual const TMVA::Event*Transform(const TMVA::Event*const, Int_t cls) const; virtual voidTObject::UseCurrentS",MatchSource.WIKI,root/html604/TMVA__VariableRearrangeTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableRearrangeTransform.html
https://root.cern/root/html604/TMVA__VariableRearrangeTransform.html:9560,Integrability,message,message,9560,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableRearrangeTransform( DataSetInfo& dsi ); constructor. ~VariableRearrangeTransform(). void Initialize(); initialization of the rearrangement transformation; (nothing to do). Bool_t PrepareTransformation(const vector<TMVA::Event*>& ); prepare transformation --> (nothing to do). const TMVA::Event* Transform(const TMVA::Event*const , Int_t cls) const. const TMVA::Event* InverseTransform(const TMVA::Event*const , Int_t cls) const. std::vector<TString>* GetTransformationStrings(Int_t cls) const; creates string with variable transformations applied. void AttachXMLTo(",MatchSource.WIKI,root/html604/TMVA__VariableRearrangeTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableRearrangeTransform.html
https://root.cern/root/html604/TMVA__VariableRearrangeTransform.html:9476,Modifiability,variab,variables,9476,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableRearrangeTransform( DataSetInfo& dsi ); constructor. ~VariableRearrangeTransform(). void Initialize(); initialization of the rearrangement transformation; (nothing to do). Bool_t PrepareTransformation(const vector<TMVA::Event*>& ); prepare transformation --> (nothing to do). const TMVA::Event* Transform(const TMVA::Event*const , Int_t cls) const. const TMVA::Event* InverseTransform(const TMVA::Event*const , Int_t cls) const. std::vector<TString>* GetTransformationStrings(Int_t cls) const; creates string with variable transformations applied. void AttachXMLTo(",MatchSource.WIKI,root/html604/TMVA__VariableRearrangeTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableRearrangeTransform.html
https://root.cern/root/html604/TMVA__VariableRearrangeTransform.html:9660,Modifiability,variab,variables,9660,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableRearrangeTransform( DataSetInfo& dsi ); constructor. ~VariableRearrangeTransform(). void Initialize(); initialization of the rearrangement transformation; (nothing to do). Bool_t PrepareTransformation(const vector<TMVA::Event*>& ); prepare transformation --> (nothing to do). const TMVA::Event* Transform(const TMVA::Event*const , Int_t cls) const. const TMVA::Event* InverseTransform(const TMVA::Event*const , Int_t cls) const. std::vector<TString>* GetTransformationStrings(Int_t cls) const; creates string with variable transformations applied. void AttachXMLTo(",MatchSource.WIKI,root/html604/TMVA__VariableRearrangeTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableRearrangeTransform.html
https://root.cern/root/html604/TMVA__VariableRearrangeTransform.html:10460,Modifiability,variab,variable,10460,"VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableRearrangeTransform( DataSetInfo& dsi ); constructor. ~VariableRearrangeTransform(). void Initialize(); initialization of the rearrangement transformation; (nothing to do). Bool_t PrepareTransformation(const vector<TMVA::Event*>& ); prepare transformation --> (nothing to do). const TMVA::Event* Transform(const TMVA::Event*const , Int_t cls) const. const TMVA::Event* InverseTransform(const TMVA::Event*const , Int_t cls) const. std::vector<TString>* GetTransformationStrings(Int_t cls) const; creates string with variable transformations applied. void AttachXMLTo(void* parent); // create XML description of Rearrange transformation. void ReadFromXML(void* trfnode); // Read the transformation matrices from the xml node. void PrintTransformation(ostream& o); prints the transformation ranges. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); creates a normalizing function. VariableRearrangeTransform( DataSetInfo& dsi ). void WriteTransformationToStream(ostream& ) const; {}. void ReadTransformationFromStream(istream& , const TString& ); { SetCreated(); }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMVA__VariableRearrangeTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableRearrangeTransform.html
https://root.cern/root/html604/TMVA__VariableRearrangeTransform.html:9568,Testability,log,logger,9568,"ect::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableRearrangeTransform( DataSetInfo& dsi ); constructor. ~VariableRearrangeTransform(). void Initialize(); initialization of the rearrangement transformation; (nothing to do). Bool_t PrepareTransformation(const vector<TMVA::Event*>& ); prepare transformation --> (nothing to do). const TMVA::Event* Transform(const TMVA::Event*const , Int_t cls) const. const TMVA::Event* InverseTransform(const TMVA::Event*const , Int_t cls) const. std::vector<TString>* GetTransformationStrings(Int_t cls) const; creates string with variable transformations applied. void AttachXMLTo(",MatchSource.WIKI,root/html604/TMVA__VariableRearrangeTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableRearrangeTransform.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:476,Availability,avail,available,476,". TMVA::VariableTransformBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::VariableTransformBase. class TMVA::VariableTransformBase: public TObject. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VariableTransformBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAttachXMLTo(void* parent); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:1578,Availability,error,error,1578,"* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAttachXMLTo(void* parent); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tGetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringGetShortName() const; virtual const char*TObject::GetTitle() const; virtual vector<TString>*GetTransformationStrings(Int_t cls) const; virtual UInt_tTObject::GetUniqueID() const; TMVA",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:1662,Availability,error,error,1662,"AttachXMLTo(void* parent); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tGetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringGetShortName() const; virtual const char*TObject::GetTitle() const; virtual vector<TString>*GetTransformationStrings(Int_t cls) const; virtual UInt_tTObject::GetUniqueID() const; TMVA::Types::EVariableTransformGetVariableTransform() const; virtual Bool_tTObject::Hand",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:2164,Availability,mask,mask,2164,"l Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tGetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringGetShortName() const; virtual const char*TObject::GetTitle() const; virtual vector<TString>*GetTransformationStrings(Int_t cls) const; virtual UInt_tTObject::GetUniqueID() const; TMVA::Types::EVariableTransformGetVariableTransform() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitialize(); virtual voidTObject::Inspect() constMENU ; virtual const TMVA::Event*InverseTransform(const TMVA::Event*const, Int_t cls) const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsCreated() const",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:5369,Availability,mask,mask,5369,"r<TMVA::Event*>&); virtual voidTObject::Print(Option_t* option = """") const; virtual voidPrintTransformation(ostream&); virtual Int_tTObject::Read(const char* name); virtual voidReadFromXML(void* trfnode); virtual voidReadTransformationFromStream(istream& istr, const TString& classname = """"); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEnabled(Bool_t e); voidSetNormalise(Bool_t n); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; voidSetOutputDataSetInfo(TMVA::DataSetInfo* outputDsi); voidSetTMVAVersion(TMVA::TMVAVersion_t v); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUseSignalTransform(Bool_t e = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; const vector<TMVA::VariableInfo>&Spectators() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; const vector<TMVA::VariableInfo>&Targets() const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidToggleInputSortOrder(Bool_t sortOrder); virtual const TMVA::Event*Transform(const TMVA::Event*const, Int_t cls) const; virtual voidTObject::UseCurrentStyle(); Bool_tUseSignalTransform() const; const vector<TMVA::VariableInfo>&Variables() const; TMVA::VariableTransformBaseVariableTransformBase(const TMVA::VariableTransformBa",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:10025,Availability,mask,mask,10025,"MVA::VariableInfo>fSpectatorsevent spectators [saved to weight file --> TODO ]; vector<TMVA::VariableInfo>fTargetsevent targets [saved to weight file --> TODO ]; TStringfTransformNamename of transformation; Bool_tfUseSignalTransformtrue if transformation bases on signal data; TMVA::Types::EVariableTransformfVariableTransformDecorrelation, PCA, etc.; Bool_tfVariableTypesAreCountedtrue if variable types have been counted already; vector<TMVA::VariableInfo>fVariablesevent variables [saved to weight file]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName); standard constructor. ~VariableTransformBase(). void SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); select the variables/targets/spectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Event*>& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:10179,Availability,mask,mask,10179,"nsformNamename of transformation; Bool_tfUseSignalTransformtrue if transformation bases on signal data; TMVA::Types::EVariableTransformfVariableTransformDecorrelation, PCA, etc.; Bool_tfVariableTypesAreCountedtrue if variable types have been counted already; vector<TMVA::VariableInfo>fVariablesevent variables [saved to weight file]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName); standard constructor. ~VariableTransformBase(). void SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); select the variables/targets/spectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Event*>& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:10897,Deployability,update,update,10897,"pectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Event*>& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName). void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*>& ). const Event* Transform(const TMVA::Event*const , Int_t cls) const. const Event* InverseTransform(const TMVA::Event*const , Int_t cls) const. void SetEnabled(Bool_t e); accessors. { fEnabled = e; }. void SetNormalise(Bool_t n); { fNormalise = n; }. Bool_t IsEnabled() const; { return fEnabled; }. Bool_t IsCreated() const; { return fCreated; }. Bool_t IsNormalised() const; { return fNormalise; }. vo",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:10468,Energy Efficiency,adapt,adapt,10468,"s [saved to weight file]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName); standard constructor. ~VariableTransformBase(). void SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); select the variables/targets/spectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Event*>& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName). void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*>& ). const Event* ",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:10676,Energy Efficiency,adapt,adapt,10676,"f, const TString& trfName); standard constructor. ~VariableTransformBase(). void SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); select the variables/targets/spectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Event*>& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName). void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*>& ). const Event* Transform(const TMVA::Event*const , Int_t cls) const. const Event* InverseTransform(const TMVA::Event*const , Int_t cls) const. void SetEnabled(Bool_t e); accessors. { fEnabled = e; }. void SetNorm",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:10851,Energy Efficiency,adapt,adapt,10851,"pectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Event*>& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName). void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*>& ). const Event* Transform(const TMVA::Event*const , Int_t cls) const. const Event* InverseTransform(const TMVA::Event*const , Int_t cls) const. void SetEnabled(Bool_t e); accessors. { fEnabled = e; }. void SetNormalise(Bool_t n); { fNormalise = n; }. Bool_t IsEnabled() const; { return fEnabled; }. Bool_t IsCreated() const; { return fCreated; }. Bool_t IsNormalised() const; { return fNormalise; }. vo",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:8395,Integrability,message,message,8395,"r, Double_t x). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&fDsi; TMVA::DataSetInfo*fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntfGetget variables/targets/spectators; TMVA::MsgLogger*fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntfPutput variables/targets/spectators; TMVA::TMVAVersion_tfTMVAVersion; TMVA::Event*fTransformedEventholds the current transformed event. private:. Bool_tfCreatedhas been created; Bool_tfEnabledhas been enabled; UInt_tfNSpectatorsnumber of spectators to be transformed; UInt_tfNTargetsnumber of targets to be transformed; UInt_tfNVariablesnumber of variables to be transformed; UInt_tfNVarsnumber of variables; Bool_tfNormalisenormalise input variables; Bool_tfSortGetif true, sort the variables into the order as defined by the user at the var definition; vector<TMVA::VariableInfo>fSpectatorsevent spectators [saved to weight file --> TODO ]; vector<TMVA::VariableInfo>fTargetsevent targets [saved to weight file --> TODO ]; TStringfTransformNamename of transformation; Bool_tfUseSignalTransformtrue if transformation bases on signal data; TMVA::Types::EVariableTransformfVariableTransformDecorrelation, PCA, etc.; B",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:8340,Modifiability,variab,variables,8340,"r, Double_t x). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&fDsi; TMVA::DataSetInfo*fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntfGetget variables/targets/spectators; TMVA::MsgLogger*fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntfPutput variables/targets/spectators; TMVA::TMVAVersion_tfTMVAVersion; TMVA::Event*fTransformedEventholds the current transformed event. private:. Bool_tfCreatedhas been created; Bool_tfEnabledhas been enabled; UInt_tfNSpectatorsnumber of spectators to be transformed; UInt_tfNTargetsnumber of targets to be transformed; UInt_tfNVariablesnumber of variables to be transformed; UInt_tfNVarsnumber of variables; Bool_tfNormalisenormalise input variables; Bool_tfSortGetif true, sort the variables into the order as defined by the user at the var definition; vector<TMVA::VariableInfo>fSpectatorsevent spectators [saved to weight file --> TODO ]; vector<TMVA::VariableInfo>fTargetsevent targets [saved to weight file --> TODO ]; TStringfTransformNamename of transformation; Bool_tfUseSignalTransformtrue if transformation bases on signal data; TMVA::Types::EVariableTransformfVariableTransformDecorrelation, PCA, etc.; B",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:8466,Modifiability,variab,variables,8466,"r, Double_t x). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&fDsi; TMVA::DataSetInfo*fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntfGetget variables/targets/spectators; TMVA::MsgLogger*fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntfPutput variables/targets/spectators; TMVA::TMVAVersion_tfTMVAVersion; TMVA::Event*fTransformedEventholds the current transformed event. private:. Bool_tfCreatedhas been created; Bool_tfEnabledhas been enabled; UInt_tfNSpectatorsnumber of spectators to be transformed; UInt_tfNTargetsnumber of targets to be transformed; UInt_tfNVariablesnumber of variables to be transformed; UInt_tfNVarsnumber of variables; Bool_tfNormalisenormalise input variables; Bool_tfSortGetif true, sort the variables into the order as defined by the user at the var definition; vector<TMVA::VariableInfo>fSpectatorsevent spectators [saved to weight file --> TODO ]; vector<TMVA::VariableInfo>fTargetsevent targets [saved to weight file --> TODO ]; TStringfTransformNamename of transformation; Bool_tfUseSignalTransformtrue if transformation bases on signal data; TMVA::Types::EVariableTransformfVariableTransformDecorrelation, PCA, etc.; B",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:8806,Modifiability,variab,variables,8806,":kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&fDsi; TMVA::DataSetInfo*fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntfGetget variables/targets/spectators; TMVA::MsgLogger*fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntfPutput variables/targets/spectators; TMVA::TMVAVersion_tfTMVAVersion; TMVA::Event*fTransformedEventholds the current transformed event. private:. Bool_tfCreatedhas been created; Bool_tfEnabledhas been enabled; UInt_tfNSpectatorsnumber of spectators to be transformed; UInt_tfNTargetsnumber of targets to be transformed; UInt_tfNVariablesnumber of variables to be transformed; UInt_tfNVarsnumber of variables; Bool_tfNormalisenormalise input variables; Bool_tfSortGetif true, sort the variables into the order as defined by the user at the var definition; vector<TMVA::VariableInfo>fSpectatorsevent spectators [saved to weight file --> TODO ]; vector<TMVA::VariableInfo>fTargetsevent targets [saved to weight file --> TODO ]; TStringfTransformNamename of transformation; Bool_tfUseSignalTransformtrue if transformation bases on signal data; TMVA::Types::EVariableTransformfVariableTransformDecorrelation, PCA, etc.; Bool_tfVariableTypesAreCountedtrue if variable types have been counted already; vector<TMVA::VariableInfo>fVariablesevent variables [saved to weight file]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName); standard constructor. ~VariableTransformBase(). void SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); select the variables/targets/spectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vec",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:8857,Modifiability,variab,variables,8857,":kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&fDsi; TMVA::DataSetInfo*fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntfGetget variables/targets/spectators; TMVA::MsgLogger*fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntfPutput variables/targets/spectators; TMVA::TMVAVersion_tfTMVAVersion; TMVA::Event*fTransformedEventholds the current transformed event. private:. Bool_tfCreatedhas been created; Bool_tfEnabledhas been enabled; UInt_tfNSpectatorsnumber of spectators to be transformed; UInt_tfNTargetsnumber of targets to be transformed; UInt_tfNVariablesnumber of variables to be transformed; UInt_tfNVarsnumber of variables; Bool_tfNormalisenormalise input variables; Bool_tfSortGetif true, sort the variables into the order as defined by the user at the var definition; vector<TMVA::VariableInfo>fSpectatorsevent spectators [saved to weight file --> TODO ]; vector<TMVA::VariableInfo>fTargetsevent targets [saved to weight file --> TODO ]; TStringfTransformNamename of transformation; Bool_tfUseSignalTransformtrue if transformation bases on signal data; TMVA::Types::EVariableTransformfVariableTransformDecorrelation, PCA, etc.; Bool_tfVariableTypesAreCountedtrue if variable types have been counted already; vector<TMVA::VariableInfo>fVariablesevent variables [saved to weight file]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName); standard constructor. ~VariableTransformBase(). void SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); select the variables/targets/spectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vec",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:8900,Modifiability,variab,variables,8900,":kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&fDsi; TMVA::DataSetInfo*fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntfGetget variables/targets/spectators; TMVA::MsgLogger*fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntfPutput variables/targets/spectators; TMVA::TMVAVersion_tfTMVAVersion; TMVA::Event*fTransformedEventholds the current transformed event. private:. Bool_tfCreatedhas been created; Bool_tfEnabledhas been enabled; UInt_tfNSpectatorsnumber of spectators to be transformed; UInt_tfNTargetsnumber of targets to be transformed; UInt_tfNVariablesnumber of variables to be transformed; UInt_tfNVarsnumber of variables; Bool_tfNormalisenormalise input variables; Bool_tfSortGetif true, sort the variables into the order as defined by the user at the var definition; vector<TMVA::VariableInfo>fSpectatorsevent spectators [saved to weight file --> TODO ]; vector<TMVA::VariableInfo>fTargetsevent targets [saved to weight file --> TODO ]; TStringfTransformNamename of transformation; Bool_tfUseSignalTransformtrue if transformation bases on signal data; TMVA::Types::EVariableTransformfVariableTransformDecorrelation, PCA, etc.; Bool_tfVariableTypesAreCountedtrue if variable types have been counted already; vector<TMVA::VariableInfo>fVariablesevent variables [saved to weight file]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName); standard constructor. ~VariableTransformBase(). void SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); select the variables/targets/spectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vec",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:8943,Modifiability,variab,variables,8943,":kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&fDsi; TMVA::DataSetInfo*fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntfGetget variables/targets/spectators; TMVA::MsgLogger*fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntfPutput variables/targets/spectators; TMVA::TMVAVersion_tfTMVAVersion; TMVA::Event*fTransformedEventholds the current transformed event. private:. Bool_tfCreatedhas been created; Bool_tfEnabledhas been enabled; UInt_tfNSpectatorsnumber of spectators to be transformed; UInt_tfNTargetsnumber of targets to be transformed; UInt_tfNVariablesnumber of variables to be transformed; UInt_tfNVarsnumber of variables; Bool_tfNormalisenormalise input variables; Bool_tfSortGetif true, sort the variables into the order as defined by the user at the var definition; vector<TMVA::VariableInfo>fSpectatorsevent spectators [saved to weight file --> TODO ]; vector<TMVA::VariableInfo>fTargetsevent targets [saved to weight file --> TODO ]; TStringfTransformNamename of transformation; Bool_tfUseSignalTransformtrue if transformation bases on signal data; TMVA::Types::EVariableTransformfVariableTransformDecorrelation, PCA, etc.; Bool_tfVariableTypesAreCountedtrue if variable types have been counted already; vector<TMVA::VariableInfo>fVariablesevent variables [saved to weight file]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName); standard constructor. ~VariableTransformBase(). void SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); select the variables/targets/spectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vec",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:9412,Modifiability,variab,variable,9412,"arAndIntfPutput variables/targets/spectators; TMVA::TMVAVersion_tfTMVAVersion; TMVA::Event*fTransformedEventholds the current transformed event. private:. Bool_tfCreatedhas been created; Bool_tfEnabledhas been enabled; UInt_tfNSpectatorsnumber of spectators to be transformed; UInt_tfNTargetsnumber of targets to be transformed; UInt_tfNVariablesnumber of variables to be transformed; UInt_tfNVarsnumber of variables; Bool_tfNormalisenormalise input variables; Bool_tfSortGetif true, sort the variables into the order as defined by the user at the var definition; vector<TMVA::VariableInfo>fSpectatorsevent spectators [saved to weight file --> TODO ]; vector<TMVA::VariableInfo>fTargetsevent targets [saved to weight file --> TODO ]; TStringfTransformNamename of transformation; Bool_tfUseSignalTransformtrue if transformation bases on signal data; TMVA::Types::EVariableTransformfVariableTransformDecorrelation, PCA, etc.; Bool_tfVariableTypesAreCountedtrue if variable types have been counted already; vector<TMVA::VariableInfo>fVariablesevent variables [saved to weight file]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName); standard constructor. ~VariableTransformBase(). void SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); select the variables/targets/spectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Even",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:9496,Modifiability,variab,variables,9496,"arAndIntfPutput variables/targets/spectators; TMVA::TMVAVersion_tfTMVAVersion; TMVA::Event*fTransformedEventholds the current transformed event. private:. Bool_tfCreatedhas been created; Bool_tfEnabledhas been enabled; UInt_tfNSpectatorsnumber of spectators to be transformed; UInt_tfNTargetsnumber of targets to be transformed; UInt_tfNVariablesnumber of variables to be transformed; UInt_tfNVarsnumber of variables; Bool_tfNormalisenormalise input variables; Bool_tfSortGetif true, sort the variables into the order as defined by the user at the var definition; vector<TMVA::VariableInfo>fSpectatorsevent spectators [saved to weight file --> TODO ]; vector<TMVA::VariableInfo>fTargetsevent targets [saved to weight file --> TODO ]; TStringfTransformNamename of transformation; Bool_tfUseSignalTransformtrue if transformation bases on signal data; TMVA::Types::EVariableTransformfVariableTransformDecorrelation, PCA, etc.; Bool_tfVariableTypesAreCountedtrue if variable types have been counted already; vector<TMVA::VariableInfo>fVariablesevent variables [saved to weight file]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName); standard constructor. ~VariableTransformBase(). void SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); select the variables/targets/spectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Even",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:9870,Modifiability,variab,variables,9870,"ariables; Bool_tfNormalisenormalise input variables; Bool_tfSortGetif true, sort the variables into the order as defined by the user at the var definition; vector<TMVA::VariableInfo>fSpectatorsevent spectators [saved to weight file --> TODO ]; vector<TMVA::VariableInfo>fTargetsevent targets [saved to weight file --> TODO ]; TStringfTransformNamename of transformation; Bool_tfUseSignalTransformtrue if transformation bases on signal data; TMVA::Types::EVariableTransformfVariableTransformDecorrelation, PCA, etc.; Bool_tfVariableTypesAreCountedtrue if variable types have been counted already; vector<TMVA::VariableInfo>fVariablesevent variables [saved to weight file]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName); standard constructor. ~VariableTransformBase(). void SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); select the variables/targets/spectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Event*>& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:10373,Modifiability,variab,variables,10373,"Decorrelation, PCA, etc.; Bool_tfVariableTypesAreCountedtrue if variable types have been counted already; vector<TMVA::VariableInfo>fVariablesevent variables [saved to weight file]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName); standard constructor. ~VariableTransformBase(). void SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); select the variables/targets/spectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Event*>& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. VariableTransformBase(TMVA::DataSetInfo& ds",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:10468,Modifiability,adapt,adapt,10468,"s [saved to weight file]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName); standard constructor. ~VariableTransformBase(). void SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); select the variables/targets/spectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Event*>& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName). void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*>& ). const Event* ",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:10477,Modifiability,variab,variable,10477,"s [saved to weight file]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName); standard constructor. ~VariableTransformBase(). void SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); select the variables/targets/spectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Event*>& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName). void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*>& ). const Event* ",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:10575,Modifiability,variab,variables,10575,"s [saved to weight file]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName); standard constructor. ~VariableTransformBase(). void SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); select the variables/targets/spectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Event*>& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName). void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*>& ). const Event* ",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:10676,Modifiability,adapt,adapt,10676,"f, const TString& trfName); standard constructor. ~VariableTransformBase(). void SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); select the variables/targets/spectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Event*>& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName). void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*>& ). const Event* Transform(const TMVA::Event*const , Int_t cls) const. const Event* InverseTransform(const TMVA::Event*const , Int_t cls) const. void SetEnabled(Bool_t e); accessors. { fEnabled = e; }. void SetNorm",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:10685,Modifiability,variab,variable,10685,"f, const TString& trfName); standard constructor. ~VariableTransformBase(). void SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); select the variables/targets/spectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Event*>& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName). void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*>& ). const Event* Transform(const TMVA::Event*const , Int_t cls) const. const Event* InverseTransform(const TMVA::Event*const , Int_t cls) const. void SetEnabled(Bool_t e); accessors. { fEnabled = e; }. void SetNorm",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:10851,Modifiability,adapt,adapt,10851,"pectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Event*>& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName). void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*>& ). const Event* Transform(const TMVA::Event*const , Int_t cls) const. const Event* InverseTransform(const TMVA::Event*const , Int_t cls) const. void SetEnabled(Bool_t e); accessors. { fEnabled = e; }. void SetNormalise(Bool_t n); { fNormalise = n; }. Bool_t IsEnabled() const; { return fEnabled; }. Bool_t IsCreated() const; { return fCreated; }. Bool_t IsNormalised() const; { return fNormalise; }. vo",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:10860,Modifiability,variab,variable,10860,"pectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Event*>& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName). void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*>& ). const Event* Transform(const TMVA::Event*const , Int_t cls) const. const Event* InverseTransform(const TMVA::Event*const , Int_t cls) const. void SetEnabled(Bool_t e); accessors. { fEnabled = e; }. void SetNormalise(Bool_t n); { fNormalise = n; }. Bool_t IsEnabled() const; { return fEnabled; }. Bool_t IsCreated() const; { return fCreated; }. Bool_t IsNormalised() const; { return fNormalise; }. vo",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:10927,Modifiability,variab,variable,10927,"pectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Event*>& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName). void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*>& ). const Event* Transform(const TMVA::Event*const , Int_t cls) const. const Event* InverseTransform(const TMVA::Event*const , Int_t cls) const. void SetEnabled(Bool_t e); accessors. { fEnabled = e; }. void SetNormalise(Bool_t n); { fNormalise = n; }. Bool_t IsEnabled() const; { return fEnabled; }. Bool_t IsCreated() const; { return fCreated; }. Bool_t IsNormalised() const; { return fNormalise; }. vo",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:11082,Modifiability,variab,variables,11082,"t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Event*>& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName). void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*>& ). const Event* Transform(const TMVA::Event*const , Int_t cls) const. const Event* InverseTransform(const TMVA::Event*const , Int_t cls) const. void SetEnabled(Bool_t e); accessors. { fEnabled = e; }. void SetNormalise(Bool_t n); { fNormalise = n; }. Bool_t IsEnabled() const; { return fEnabled; }. Bool_t IsCreated() const; { return fCreated; }. Bool_t IsNormalised() const; { return fNormalise; }. void ToggleInputSortOrder(Bool_t sortOrder); { fSortGet = sortOrder; }. void SetOutputDataSetInfo(TMVA::DataSetInfo* outputDsi); { fDsiOutput = outp",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:11142,Modifiability,variab,variables,11142,"event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Event*>& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName). void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*>& ). const Event* Transform(const TMVA::Event*const , Int_t cls) const. const Event* InverseTransform(const TMVA::Event*const , Int_t cls) const. void SetEnabled(Bool_t e); accessors. { fEnabled = e; }. void SetNormalise(Bool_t n); { fNormalise = n; }. Bool_t IsEnabled() const; { return fEnabled; }. Bool_t IsCreated() const; { return fCreated; }. Bool_t IsNormalised() const; { return fNormalise; }. void ToggleInputSortOrder(Bool_t sortOrder); { fSortGet = sortOrder; }. void SetOutputDataSetInfo(TMVA::DataSetInfo* outputDsi); { fDsiOutput = outputDsi; }. void SetUseSignalTransform(Bool_t e = kTRUE); { fUseSignalTransform = e; }. Bool_t Use",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:11659,Security,access,accessors,11659,"nt_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. VariableTransformBase(TMVA::DataSetInfo& dsi, TMVA::Types::EVariableTransform tf, const TString& trfName). void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*>& ). const Event* Transform(const TMVA::Event*const , Int_t cls) const. const Event* InverseTransform(const TMVA::Event*const , Int_t cls) const. void SetEnabled(Bool_t e); accessors. { fEnabled = e; }. void SetNormalise(Bool_t n); { fNormalise = n; }. Bool_t IsEnabled() const; { return fEnabled; }. Bool_t IsCreated() const; { return fCreated; }. Bool_t IsNormalised() const; { return fNormalise; }. void ToggleInputSortOrder(Bool_t sortOrder); { fSortGet = sortOrder; }. void SetOutputDataSetInfo(TMVA::DataSetInfo* outputDsi); { fDsiOutput = outputDsi; }. void SetUseSignalTransform(Bool_t e = kTRUE); { fUseSignalTransform = e; }. Bool_t UseSignalTransform() const; { return fUseSignalTransform; }. const char* GetName() const; { return fTransformName.Data(); }. TString GetShortName() const; { TString a(fTransformName); a.ReplaceAll(""Transform"",""""); return a; }. void WriteTransformationToStream(ostream& o) const. void ReadTransformationFromStream(istream& istr, const TString& classname = """"). Types::EVariableTransform GetVariableTransform() const; { return fVariableTransform; }. void PrintTransformation(ostream& ); {}. const std::vector<TMVA::Variable",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMVA__VariableTransformBase.html:8403,Testability,log,logger,8403,"r, Double_t x). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::Event*fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&fDsi; TMVA::DataSetInfo*fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntfGetget variables/targets/spectators; TMVA::MsgLogger*fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntfPutput variables/targets/spectators; TMVA::TMVAVersion_tfTMVAVersion; TMVA::Event*fTransformedEventholds the current transformed event. private:. Bool_tfCreatedhas been created; Bool_tfEnabledhas been enabled; UInt_tfNSpectatorsnumber of spectators to be transformed; UInt_tfNTargetsnumber of targets to be transformed; UInt_tfNVariablesnumber of variables to be transformed; UInt_tfNVarsnumber of variables; Bool_tfNormalisenormalise input variables; Bool_tfSortGetif true, sort the variables into the order as defined by the user at the var definition; vector<TMVA::VariableInfo>fSpectatorsevent spectators [saved to weight file --> TODO ]; vector<TMVA::VariableInfo>fTargetsevent targets [saved to weight file --> TODO ]; TStringfTransformNamename of transformation; Bool_tfUseSignalTransformtrue if transformation bases on signal data; TMVA::Types::EVariableTransformfVariableTransformDecorrelation, PCA, etc.; B",MatchSource.WIKI,root/html604/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html
https://root.cern/root/html604/TMySQLResult.html:1312,Availability,error,error,1312," virtual~TMySQLResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFieldCount(); virtual const char*GetFieldName(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static B",MatchSource.WIKI,root/html604/TMySQLResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLResult.html
https://root.cern/root/html604/TMySQLResult.html:1396,Availability,error,error,1396,"* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFieldCount(); virtual const char*GetFieldName(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTSQLResult::GetRowCount() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::I",MatchSource.WIKI,root/html604/TMySQLResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLResult.html
https://root.cern/root/html604/TMySQLRow.html:1297,Availability,error,error,1297," virtual~TMySQLRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetField(Int_t field); virtual ULong_tGetFieldLength(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_t",MatchSource.WIKI,root/html604/TMySQLRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLRow.html
https://root.cern/root/html604/TMySQLRow.html:1381,Availability,error,error,1381,"* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetField(Int_t field); virtual ULong_tGetFieldLength(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) c",MatchSource.WIKI,root/html604/TMySQLRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLRow.html
https://root.cern/root/html604/TMySQLServer.html:2659,Availability,error,error,2659,"""""); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tDropDataBase(const char* dbname); virtual voidTObject::Dump() constMENU ; virtual voidTSQLServer::EnableErrorOutput(Bool_t on = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Bool_tExec(const char* sql); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSQLResult*GetColumns(const char* dbname, const char* table, const char* wild = 0); virtual TSQLResult*GetDataBases(const char* wild = 0); const char*TSQLServer::GetDB() const; const char*TSQLServer::GetDBMS() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSQLServer::GetErrorCode() const; virtual const char*TSQLServer::GetErrorMsg() const; static const char*TSQLServer::GetFloatFormat(); const char*TSQLServer::GetHost() const; virtual const char*TObject::GetIconName() const; virtual Int_tGetMaxIdentifierLength(); virtual const char*TObject::GetName() const; virtual ch",MatchSource.WIKI,root/html604/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLServer.html
https://root.cern/root/html604/TMySQLServer.html:2743,Availability,error,error,2743,"se(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tDropDataBase(const char* dbname); virtual voidTObject::Dump() constMENU ; virtual voidTSQLServer::EnableErrorOutput(Bool_t on = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Bool_tExec(const char* sql); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSQLResult*GetColumns(const char* dbname, const char* table, const char* wild = 0); virtual TSQLResult*GetDataBases(const char* wild = 0); const char*TSQLServer::GetDB() const; const char*TSQLServer::GetDBMS() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSQLServer::GetErrorCode() const; virtual const char*TSQLServer::GetErrorMsg() const; static const char*TSQLServer::GetFloatFormat(); const char*TSQLServer::GetHost() const; virtual const char*TObject::GetIconName() const; virtual Int_tGetMaxIdentifierLength(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObject",MatchSource.WIKI,root/html604/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLServer.html
https://root.cern/root/html604/TMySQLServer.html:9079,Availability,error,error,9079,"eted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TSQLServer::ESQLDataTypesTSQLServer::kSQL_BINARY; static TSQLServer::ESQLDataTypesTSQLServer::kSQL_CHAR; static TSQLServer::ESQLDataTypesTSQLServer::kSQL_DOUBLE; static TSQLServer::ESQLDataTypesTSQLServer::kSQL_FLOAT; static TSQLServer::ESQLDataTypesTSQLServer::kSQL_INTEGER; static TSQLServer::ESQLDataTypesTSQLServer::kSQL_NONE; static TSQLServer::ESQLDataTypesTSQLServer::kSQL_NUMERIC; static TSQLServer::ESQLDataTypesTSQLServer::kSQL_TIMESTAMP; static TSQLServer::ESQLDataTypesTSQLServer::kSQL_VARCHAR; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTSQLServer::fDBcurrently selected DB; Int_tTSQLServer::fErrorCodeerror code of last operation; TStringTSQLServer::fErrorMsgerror message of last operation; Bool_tTSQLServer::fErrorOutenable error output; TStringTSQLServer::fHosthost to which we are connected; TStringfInfoserver info string; MYSQL*fMySQLconnection to MySQL server; Int_tTSQLServer::fPortport to which we are connected; TStringTSQLServer::fTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*TSQLServer::fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMySQLServer(const char* db, const char* uid, const char* pw); Open a connection to a MySQL DB server. The db arguments should be; of the form ""mysql://<host>[:<port>][/<database>]"", e.g.:; ""mysql://pcroot.cern.ch:3456/test"". The uid is the username and pw; the password that should be used for the connection. In addition, several parameters can be specified in url after ""?"" symbol:; timeout=N n is connect timeout is seconds; socket=socketname socketname should be name of Unix socket, used; for connection; multi_statements tell the server that the ",MatchSource.WIKI,root/html604/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLServer.html
https://root.cern/root/html604/TMySQLServer.html:11498,Availability,avail,available,11498,"r protocol; cnf_file=filename Read options from the named option file instead of; from my.cnf; cnf_group=groupname Read options from the named group from my.cnf or the; file specified with cnf_file option; If several parameters are specified, they should be separated by ""&"" symbol; Example of connection argument:; TSQLServer::Connect(""mysql://host.domain/test?timeout=10&multi_statements"");. ~TMySQLServer(); Close connection to MySQL DB server. void Close(Option_t* opt = """"); Close connection to MySQL DB server. TSQLResult * Query(const char* sql); Execute SQL command. Result object must be deleted by the user.; Returns a pointer to a TSQLResult object if successful, 0 otherwise.; The result object must be deleted by the user. Bool_t Exec(const char* sql); Execute SQL command which does not produce any result sets.; Returns kTRUE if successful. Int_t SelectDataBase(const char* dbname); Select a database. Returns 0 if successful, non-zero otherwise. TSQLResult * GetDataBases(const char* wild = 0); List all available databases. Wild is for wildcarding ""t%"" list all; databases starting with ""t"".; Returns a pointer to a TSQLResult object if successful, 0 otherwise.; The result object must be deleted by the user. TSQLResult * GetTables(const char* dbname, const char* wild = 0); List all tables in the specified database. Wild is for wildcarding; ""t%"" list all tables starting with ""t"".; Returns a pointer to a TSQLResult object if successful, 0 otherwise.; The result object must be deleted by the user. TList* GetTablesList(const char* wild = 0); Return list of tables with specified wildcard. TSQLTableInfo * GetTableInfo(const char* tablename); Produces SQL table info.; Object must be deleted by user. TSQLResult * GetColumns(const char* dbname, const char* table, const char* wild = 0); List all columns in specified table in the specified database.; Wild is for wildcarding ""t%"" list all columns starting with ""t"".; Returns a pointer to a TSQLResult object if successful, 0 otherw",MatchSource.WIKI,root/html604/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLServer.html
https://root.cern/root/html604/TMySQLServer.html:13689,Availability,error,error,13689,"me); Produces SQL table info.; Object must be deleted by user. TSQLResult * GetColumns(const char* dbname, const char* table, const char* wild = 0); List all columns in specified table in the specified database.; Wild is for wildcarding ""t%"" list all columns starting with ""t"".; Returns a pointer to a TSQLResult object if successful, 0 otherwise.; The result object must be deleted by the user. Int_t CreateDataBase(const char* dbname); Create a database. Returns 0 if successful, non-zero otherwise. Int_t DropDataBase(const char* dbname); Drop (i.e. delete) a database. Returns 0 if successful, non-zero; otherwise. Int_t Reload(); Reload permission tables. Returns 0 if successful, non-zero; otherwise. User must have reload permissions. Int_t Shutdown(); Shutdown the database server. Returns 0 if successful, non-zero; otherwise. User must have shutdown permissions. const char * ServerInfo(); Return server info in form ""MySQL <vesrion>"". Bool_t HasStatement() const; Return kTRUE if TSQLStatement class is supported.; Starts from MySQL 4.1. TSQLStatement * Statement(const char* sql, Int_t = 100); Produce TMySQLStatement. Bool_t StartTransaction(); Start transaction. Bool_t Commit(); Commit changes. Bool_t Rollback(); Rollback changes. Bool_t PingVerify(); Execute Ping to SQL Connection.; Since mysql_ping tries to reconnect by itself,; a double call to the mysql function is implemented.; Returns kTRUE if successful. Int_t Ping(); Execute Ping to SQL Connection using the mysql_ping function.; Returns 0 if successful, non-zero in case an error occured. TMySQLServer(const char* db, const char* uid, const char* pw). Int_t GetMaxIdentifierLength(); { return 64; }. » Author: Fons Rademakers 15/02/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/mysql:$Id$ » Last generated: 2015-06-02 16:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLServer.html
https://root.cern/root/html604/TMySQLServer.html:362,Integrability,interface,interface,362,". TMySQLServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » SQL; » MYSQL; » TMySQLServer. class TMySQLServer: public TSQLServer. TMySQLServer. MySQL server plugin implementing the TSQLServer interface. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; mysql://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test. As an example of connecting to mysql we assume that the server is; running on the local host and that you have access to a database; named ""test"" by connecting using an account that has a username and; password of ""tuser"" and ""tpass"". You can set up this account; by using the ""mysql"" program to connect to the server as the MySQL; root user and issuing the following statement:. mysql> GRANT ALL ON test.* TO 'tuser'@'localhost' IDENTIFIED BY 'tpass';. If the test database does not exist, create it with this statement:. mysql> CREATE DATABASE test;. If you want to use a different server host, username, password,; or database name, just substitute the appropriate values.; To connect do:. TSQLServer *db = TSQLServer::Connect(""mysql://localhost/test"", ""tuser"", ""tpass"");. Function Members (Methods); public:. virtual~TMySQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_",MatchSource.WIKI,root/html604/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLServer.html
https://root.cern/root/html604/TMySQLServer.html:9018,Integrability,message,message,9018,"eted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TSQLServer::ESQLDataTypesTSQLServer::kSQL_BINARY; static TSQLServer::ESQLDataTypesTSQLServer::kSQL_CHAR; static TSQLServer::ESQLDataTypesTSQLServer::kSQL_DOUBLE; static TSQLServer::ESQLDataTypesTSQLServer::kSQL_FLOAT; static TSQLServer::ESQLDataTypesTSQLServer::kSQL_INTEGER; static TSQLServer::ESQLDataTypesTSQLServer::kSQL_NONE; static TSQLServer::ESQLDataTypesTSQLServer::kSQL_NUMERIC; static TSQLServer::ESQLDataTypesTSQLServer::kSQL_TIMESTAMP; static TSQLServer::ESQLDataTypesTSQLServer::kSQL_VARCHAR; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTSQLServer::fDBcurrently selected DB; Int_tTSQLServer::fErrorCodeerror code of last operation; TStringTSQLServer::fErrorMsgerror message of last operation; Bool_tTSQLServer::fErrorOutenable error output; TStringTSQLServer::fHosthost to which we are connected; TStringfInfoserver info string; MYSQL*fMySQLconnection to MySQL server; Int_tTSQLServer::fPortport to which we are connected; TStringTSQLServer::fTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*TSQLServer::fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMySQLServer(const char* db, const char* uid, const char* pw); Open a connection to a MySQL DB server. The db arguments should be; of the form ""mysql://<host>[:<port>][/<database>]"", e.g.:; ""mysql://pcroot.cern.ch:3456/test"". The uid is the username and pw; the password that should be used for the connection. In addition, several parameters can be specified in url after ""?"" symbol:; timeout=N n is connect timeout is seconds; socket=socketname socketname should be name of Unix socket, used; for connection; multi_statements tell the server that the ",MatchSource.WIKI,root/html604/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLServer.html
https://root.cern/root/html604/TMySQLServer.html:10480,Integrability,protocol,protocol,10480,"er; Int_tTSQLServer::fPortport to which we are connected; TStringTSQLServer::fTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*TSQLServer::fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMySQLServer(const char* db, const char* uid, const char* pw); Open a connection to a MySQL DB server. The db arguments should be; of the form ""mysql://<host>[:<port>][/<database>]"", e.g.:; ""mysql://pcroot.cern.ch:3456/test"". The uid is the username and pw; the password that should be used for the connection. In addition, several parameters can be specified in url after ""?"" symbol:; timeout=N n is connect timeout is seconds; socket=socketname socketname should be name of Unix socket, used; for connection; multi_statements tell the server that the client may send multiple; statements in a single string (separated by ;);; multi_results tell the server that the client can handle multiple; result sets from multiple-statement executions or; stored procedures; reconnect=0|1 enable or disable automatic reconnection to the server; if the connection is found to have been lost; compress use the compressed client/server protocol; cnf_file=filename Read options from the named option file instead of; from my.cnf; cnf_group=groupname Read options from the named group from my.cnf or the; file specified with cnf_file option; If several parameters are specified, they should be separated by ""&"" symbol; Example of connection argument:; TSQLServer::Connect(""mysql://host.domain/test?timeout=10&multi_statements"");. ~TMySQLServer(); Close connection to MySQL DB server. void Close(Option_t* opt = """"); Close connection to MySQL DB server. TSQLResult * Query(const char* sql); Execute SQL command. Result object must be deleted by the user.; Returns a pointer to a TSQLResult object if successful, 0 otherwise.; The result object must be deleted by the user. Bool",MatchSource.WIKI,root/html604/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLServer.html
https://root.cern/root/html604/TMySQLServer.html:327,Modifiability,plugin,plugin,327,". TMySQLServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » SQL; » MYSQL; » TMySQLServer. class TMySQLServer: public TSQLServer. TMySQLServer. MySQL server plugin implementing the TSQLServer interface. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; mysql://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test. As an example of connecting to mysql we assume that the server is; running on the local host and that you have access to a database; named ""test"" by connecting using an account that has a username and; password of ""tuser"" and ""tpass"". You can set up this account; by using the ""mysql"" program to connect to the server as the MySQL; root user and issuing the following statement:. mysql> GRANT ALL ON test.* TO 'tuser'@'localhost' IDENTIFIED BY 'tpass';. If the test database does not exist, create it with this statement:. mysql> CREATE DATABASE test;. If you want to use a different server host, username, password,; or database name, just substitute the appropriate values.; To connect do:. TSQLServer *db = TSQLServer::Connect(""mysql://localhost/test"", ""tuser"", ""tpass"");. Function Members (Methods); public:. virtual~TMySQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_",MatchSource.WIKI,root/html604/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLServer.html
https://root.cern/root/html604/TMySQLServer.html:9943,Safety,timeout,timeout,9943,"er; Int_tTSQLServer::fPortport to which we are connected; TStringTSQLServer::fTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*TSQLServer::fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMySQLServer(const char* db, const char* uid, const char* pw); Open a connection to a MySQL DB server. The db arguments should be; of the form ""mysql://<host>[:<port>][/<database>]"", e.g.:; ""mysql://pcroot.cern.ch:3456/test"". The uid is the username and pw; the password that should be used for the connection. In addition, several parameters can be specified in url after ""?"" symbol:; timeout=N n is connect timeout is seconds; socket=socketname socketname should be name of Unix socket, used; for connection; multi_statements tell the server that the client may send multiple; statements in a single string (separated by ;);; multi_results tell the server that the client can handle multiple; result sets from multiple-statement executions or; stored procedures; reconnect=0|1 enable or disable automatic reconnection to the server; if the connection is found to have been lost; compress use the compressed client/server protocol; cnf_file=filename Read options from the named option file instead of; from my.cnf; cnf_group=groupname Read options from the named group from my.cnf or the; file specified with cnf_file option; If several parameters are specified, they should be separated by ""&"" symbol; Example of connection argument:; TSQLServer::Connect(""mysql://host.domain/test?timeout=10&multi_statements"");. ~TMySQLServer(); Close connection to MySQL DB server. void Close(Option_t* opt = """"); Close connection to MySQL DB server. TSQLResult * Query(const char* sql); Execute SQL command. Result object must be deleted by the user.; Returns a pointer to a TSQLResult object if successful, 0 otherwise.; The result object must be deleted by the user. Bool",MatchSource.WIKI,root/html604/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLServer.html
https://root.cern/root/html604/TMySQLServer.html:9966,Safety,timeout,timeout,9966,"er; Int_tTSQLServer::fPortport to which we are connected; TStringTSQLServer::fTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*TSQLServer::fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMySQLServer(const char* db, const char* uid, const char* pw); Open a connection to a MySQL DB server. The db arguments should be; of the form ""mysql://<host>[:<port>][/<database>]"", e.g.:; ""mysql://pcroot.cern.ch:3456/test"". The uid is the username and pw; the password that should be used for the connection. In addition, several parameters can be specified in url after ""?"" symbol:; timeout=N n is connect timeout is seconds; socket=socketname socketname should be name of Unix socket, used; for connection; multi_statements tell the server that the client may send multiple; statements in a single string (separated by ;);; multi_results tell the server that the client can handle multiple; result sets from multiple-statement executions or; stored procedures; reconnect=0|1 enable or disable automatic reconnection to the server; if the connection is found to have been lost; compress use the compressed client/server protocol; cnf_file=filename Read options from the named option file instead of; from my.cnf; cnf_group=groupname Read options from the named group from my.cnf or the; file specified with cnf_file option; If several parameters are specified, they should be separated by ""&"" symbol; Example of connection argument:; TSQLServer::Connect(""mysql://host.domain/test?timeout=10&multi_statements"");. ~TMySQLServer(); Close connection to MySQL DB server. void Close(Option_t* opt = """"); Close connection to MySQL DB server. TSQLResult * Query(const char* sql); Execute SQL command. Result object must be deleted by the user.; Returns a pointer to a TSQLResult object if successful, 0 otherwise.; The result object must be deleted by the user. Bool",MatchSource.WIKI,root/html604/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLServer.html
https://root.cern/root/html604/TMySQLServer.html:10840,Safety,timeout,timeout,10840,"or the connection. In addition, several parameters can be specified in url after ""?"" symbol:; timeout=N n is connect timeout is seconds; socket=socketname socketname should be name of Unix socket, used; for connection; multi_statements tell the server that the client may send multiple; statements in a single string (separated by ;);; multi_results tell the server that the client can handle multiple; result sets from multiple-statement executions or; stored procedures; reconnect=0|1 enable or disable automatic reconnection to the server; if the connection is found to have been lost; compress use the compressed client/server protocol; cnf_file=filename Read options from the named option file instead of; from my.cnf; cnf_group=groupname Read options from the named group from my.cnf or the; file specified with cnf_file option; If several parameters are specified, they should be separated by ""&"" symbol; Example of connection argument:; TSQLServer::Connect(""mysql://host.domain/test?timeout=10&multi_statements"");. ~TMySQLServer(); Close connection to MySQL DB server. void Close(Option_t* opt = """"); Close connection to MySQL DB server. TSQLResult * Query(const char* sql); Execute SQL command. Result object must be deleted by the user.; Returns a pointer to a TSQLResult object if successful, 0 otherwise.; The result object must be deleted by the user. Bool_t Exec(const char* sql); Execute SQL command which does not produce any result sets.; Returns kTRUE if successful. Int_t SelectDataBase(const char* dbname); Select a database. Returns 0 if successful, non-zero otherwise. TSQLResult * GetDataBases(const char* wild = 0); List all available databases. Wild is for wildcarding ""t%"" list all; databases starting with ""t"".; Returns a pointer to a TSQLResult object if successful, 0 otherwise.; The result object must be deleted by the user. TSQLResult * GetTables(const char* dbname, const char* wild = 0); List all tables in the specified database. Wild is for wildcarding; ""t%"" list a",MatchSource.WIKI,root/html604/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLServer.html
https://root.cern/root/html604/TMySQLServer.html:675,Security,access,access,675,". TMySQLServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » SQL; » MYSQL; » TMySQLServer. class TMySQLServer: public TSQLServer. TMySQLServer. MySQL server plugin implementing the TSQLServer interface. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; mysql://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test. As an example of connecting to mysql we assume that the server is; running on the local host and that you have access to a database; named ""test"" by connecting using an account that has a username and; password of ""tuser"" and ""tpass"". You can set up this account; by using the ""mysql"" program to connect to the server as the MySQL; root user and issuing the following statement:. mysql> GRANT ALL ON test.* TO 'tuser'@'localhost' IDENTIFIED BY 'tpass';. If the test database does not exist, create it with this statement:. mysql> CREATE DATABASE test;. If you want to use a different server host, username, password,; or database name, just substitute the appropriate values.; To connect do:. TSQLServer *db = TSQLServer::Connect(""mysql://localhost/test"", ""tuser"", ""tpass"");. Function Members (Methods); public:. virtual~TMySQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_",MatchSource.WIKI,root/html604/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLServer.html
https://root.cern/root/html604/TMySQLServer.html:766,Security,password,password,766,". TMySQLServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » SQL; » MYSQL; » TMySQLServer. class TMySQLServer: public TSQLServer. TMySQLServer. MySQL server plugin implementing the TSQLServer interface. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; mysql://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test. As an example of connecting to mysql we assume that the server is; running on the local host and that you have access to a database; named ""test"" by connecting using an account that has a username and; password of ""tuser"" and ""tpass"". You can set up this account; by using the ""mysql"" program to connect to the server as the MySQL; root user and issuing the following statement:. mysql> GRANT ALL ON test.* TO 'tuser'@'localhost' IDENTIFIED BY 'tpass';. If the test database does not exist, create it with this statement:. mysql> CREATE DATABASE test;. If you want to use a different server host, username, password,; or database name, just substitute the appropriate values.; To connect do:. TSQLServer *db = TSQLServer::Connect(""mysql://localhost/test"", ""tuser"", ""tpass"");. Function Members (Methods); public:. virtual~TMySQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_",MatchSource.WIKI,root/html604/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLServer.html
https://root.cern/root/html604/TMySQLServer.html:1171,Security,password,password,1171,"function members; data members; class charts. ROOT; » SQL; » MYSQL; » TMySQLServer. class TMySQLServer: public TSQLServer. TMySQLServer. MySQL server plugin implementing the TSQLServer interface. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; mysql://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test. As an example of connecting to mysql we assume that the server is; running on the local host and that you have access to a database; named ""test"" by connecting using an account that has a username and; password of ""tuser"" and ""tpass"". You can set up this account; by using the ""mysql"" program to connect to the server as the MySQL; root user and issuing the following statement:. mysql> GRANT ALL ON test.* TO 'tuser'@'localhost' IDENTIFIED BY 'tpass';. If the test database does not exist, create it with this statement:. mysql> CREATE DATABASE test;. If you want to use a different server host, username, password,; or database name, just substitute the appropriate values.; To connect do:. TSQLServer *db = TSQLServer::Connect(""mysql://localhost/test"", ""tuser"", ""tpass"");. Function Members (Methods); public:. virtual~TMySQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject:",MatchSource.WIKI,root/html604/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLServer.html
https://root.cern/root/html604/TMySQLServer.html:9819,Security,password,password,9819," static TObject::(anonymous)TObject::kZombie. protected:. TStringTSQLServer::fDBcurrently selected DB; Int_tTSQLServer::fErrorCodeerror code of last operation; TStringTSQLServer::fErrorMsgerror message of last operation; Bool_tTSQLServer::fErrorOutenable error output; TStringTSQLServer::fHosthost to which we are connected; TStringfInfoserver info string; MYSQL*fMySQLconnection to MySQL server; Int_tTSQLServer::fPortport to which we are connected; TStringTSQLServer::fTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*TSQLServer::fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMySQLServer(const char* db, const char* uid, const char* pw); Open a connection to a MySQL DB server. The db arguments should be; of the form ""mysql://<host>[:<port>][/<database>]"", e.g.:; ""mysql://pcroot.cern.ch:3456/test"". The uid is the username and pw; the password that should be used for the connection. In addition, several parameters can be specified in url after ""?"" symbol:; timeout=N n is connect timeout is seconds; socket=socketname socketname should be name of Unix socket, used; for connection; multi_statements tell the server that the client may send multiple; statements in a single string (separated by ;);; multi_results tell the server that the client can handle multiple; result sets from multiple-statement executions or; stored procedures; reconnect=0|1 enable or disable automatic reconnection to the server; if the connection is found to have been lost; compress use the compressed client/server protocol; cnf_file=filename Read options from the named option file instead of; from my.cnf; cnf_group=groupname Read options from the named group from my.cnf or the; file specified with cnf_file option; If several parameters are specified, they should be separated by ""&"" symbol; Example of connection argument:; TSQLServer::Connect(""mysql://ho",MatchSource.WIKI,root/html604/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLServer.html
https://root.cern/root/html604/TMySQLServer.html:558,Testability,test,test,558,". TMySQLServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » SQL; » MYSQL; » TMySQLServer. class TMySQLServer: public TSQLServer. TMySQLServer. MySQL server plugin implementing the TSQLServer interface. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; mysql://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test. As an example of connecting to mysql we assume that the server is; running on the local host and that you have access to a database; named ""test"" by connecting using an account that has a username and; password of ""tuser"" and ""tpass"". You can set up this account; by using the ""mysql"" program to connect to the server as the MySQL; root user and issuing the following statement:. mysql> GRANT ALL ON test.* TO 'tuser'@'localhost' IDENTIFIED BY 'tpass';. If the test database does not exist, create it with this statement:. mysql> CREATE DATABASE test;. If you want to use a different server host, username, password,; or database name, just substitute the appropriate values.; To connect do:. TSQLServer *db = TSQLServer::Connect(""mysql://localhost/test"", ""tuser"", ""tpass"");. Function Members (Methods); public:. virtual~TMySQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_",MatchSource.WIKI,root/html604/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLServer.html
https://root.cern/root/html604/TMySQLServer.html:704,Testability,test,test,704,". TMySQLServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » SQL; » MYSQL; » TMySQLServer. class TMySQLServer: public TSQLServer. TMySQLServer. MySQL server plugin implementing the TSQLServer interface. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; mysql://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test. As an example of connecting to mysql we assume that the server is; running on the local host and that you have access to a database; named ""test"" by connecting using an account that has a username and; password of ""tuser"" and ""tpass"". You can set up this account; by using the ""mysql"" program to connect to the server as the MySQL; root user and issuing the following statement:. mysql> GRANT ALL ON test.* TO 'tuser'@'localhost' IDENTIFIED BY 'tpass';. If the test database does not exist, create it with this statement:. mysql> CREATE DATABASE test;. If you want to use a different server host, username, password,; or database name, just substitute the appropriate values.; To connect do:. TSQLServer *db = TSQLServer::Connect(""mysql://localhost/test"", ""tuser"", ""tpass"");. Function Members (Methods); public:. virtual~TMySQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_",MatchSource.WIKI,root/html604/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLServer.html
https://root.cern/root/html604/TMySQLServer.html:964,Testability,test,test,964,". TMySQLServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » SQL; » MYSQL; » TMySQLServer. class TMySQLServer: public TSQLServer. TMySQLServer. MySQL server plugin implementing the TSQLServer interface. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; mysql://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test. As an example of connecting to mysql we assume that the server is; running on the local host and that you have access to a database; named ""test"" by connecting using an account that has a username and; password of ""tuser"" and ""tpass"". You can set up this account; by using the ""mysql"" program to connect to the server as the MySQL; root user and issuing the following statement:. mysql> GRANT ALL ON test.* TO 'tuser'@'localhost' IDENTIFIED BY 'tpass';. If the test database does not exist, create it with this statement:. mysql> CREATE DATABASE test;. If you want to use a different server host, username, password,; or database name, just substitute the appropriate values.; To connect do:. TSQLServer *db = TSQLServer::Connect(""mysql://localhost/test"", ""tuser"", ""tpass"");. Function Members (Methods); public:. virtual~TMySQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_",MatchSource.WIKI,root/html604/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLServer.html
https://root.cern/root/html604/TMySQLServer.html:1025,Testability,test,test,1025,"Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » SQL; » MYSQL; » TMySQLServer. class TMySQLServer: public TSQLServer. TMySQLServer. MySQL server plugin implementing the TSQLServer interface. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; mysql://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test. As an example of connecting to mysql we assume that the server is; running on the local host and that you have access to a database; named ""test"" by connecting using an account that has a username and; password of ""tuser"" and ""tpass"". You can set up this account; by using the ""mysql"" program to connect to the server as the MySQL; root user and issuing the following statement:. mysql> GRANT ALL ON test.* TO 'tuser'@'localhost' IDENTIFIED BY 'tpass';. If the test database does not exist, create it with this statement:. mysql> CREATE DATABASE test;. If you want to use a different server host, username, password,; or database name, just substitute the appropriate values.; To connect do:. TSQLServer *db = TSQLServer::Connect(""mysql://localhost/test"", ""tuser"", ""tpass"");. Function Members (Methods); public:. virtual~TMySQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTO",MatchSource.WIKI,root/html604/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLServer.html
https://root.cern/root/html604/TMySQLServer.html:1110,Testability,test,test,1110,"le; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » SQL; » MYSQL; » TMySQLServer. class TMySQLServer: public TSQLServer. TMySQLServer. MySQL server plugin implementing the TSQLServer interface. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; mysql://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test. As an example of connecting to mysql we assume that the server is; running on the local host and that you have access to a database; named ""test"" by connecting using an account that has a username and; password of ""tuser"" and ""tpass"". You can set up this account; by using the ""mysql"" program to connect to the server as the MySQL; root user and issuing the following statement:. mysql> GRANT ALL ON test.* TO 'tuser'@'localhost' IDENTIFIED BY 'tpass';. If the test database does not exist, create it with this statement:. mysql> CREATE DATABASE test;. If you want to use a different server host, username, password,; or database name, just substitute the appropriate values.; To connect do:. TSQLServer *db = TSQLServer::Connect(""mysql://localhost/test"", ""tuser"", ""tpass"");. Function Members (Methods); public:. virtual~TMySQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtua",MatchSource.WIKI,root/html604/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLServer.html
https://root.cern/root/html604/TMySQLServer.html:1313,Testability,test,test,1313,"r. TMySQLServer. MySQL server plugin implementing the TSQLServer interface. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; mysql://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test. As an example of connecting to mysql we assume that the server is; running on the local host and that you have access to a database; named ""test"" by connecting using an account that has a username and; password of ""tuser"" and ""tpass"". You can set up this account; by using the ""mysql"" program to connect to the server as the MySQL; root user and issuing the following statement:. mysql> GRANT ALL ON test.* TO 'tuser'@'localhost' IDENTIFIED BY 'tpass';. If the test database does not exist, create it with this statement:. mysql> CREATE DATABASE test;. If you want to use a different server host, username, password,; or database name, just substitute the appropriate values.; To connect do:. TSQLServer *db = TSQLServer::Connect(""mysql://localhost/test"", ""tuser"", ""tpass"");. Function Members (Methods); public:. virtual~TMySQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* ",MatchSource.WIKI,root/html604/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLServer.html
https://root.cern/root/html604/TMySQLServer.html:9776,Testability,test,test,9776,"static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTSQLServer::fDBcurrently selected DB; Int_tTSQLServer::fErrorCodeerror code of last operation; TStringTSQLServer::fErrorMsgerror message of last operation; Bool_tTSQLServer::fErrorOutenable error output; TStringTSQLServer::fHosthost to which we are connected; TStringfInfoserver info string; MYSQL*fMySQLconnection to MySQL server; Int_tTSQLServer::fPortport to which we are connected; TStringTSQLServer::fTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*TSQLServer::fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMySQLServer(const char* db, const char* uid, const char* pw); Open a connection to a MySQL DB server. The db arguments should be; of the form ""mysql://<host>[:<port>][/<database>]"", e.g.:; ""mysql://pcroot.cern.ch:3456/test"". The uid is the username and pw; the password that should be used for the connection. In addition, several parameters can be specified in url after ""?"" symbol:; timeout=N n is connect timeout is seconds; socket=socketname socketname should be name of Unix socket, used; for connection; multi_statements tell the server that the client may send multiple; statements in a single string (separated by ;);; multi_results tell the server that the client can handle multiple; result sets from multiple-statement executions or; stored procedures; reconnect=0|1 enable or disable automatic reconnection to the server; if the connection is found to have been lost; compress use the compressed client/server protocol; cnf_file=filename Read options from the named option file instead of; from my.cnf; cnf_group=groupname Read options from the named group from my.cnf or the; file specified with cnf_file option; If several parameters are specified, they should be separated by ""&"" symbol; Example of con",MatchSource.WIKI,root/html604/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLServer.html
https://root.cern/root/html604/TMySQLServer.html:10835,Testability,test,test,10835,"or the connection. In addition, several parameters can be specified in url after ""?"" symbol:; timeout=N n is connect timeout is seconds; socket=socketname socketname should be name of Unix socket, used; for connection; multi_statements tell the server that the client may send multiple; statements in a single string (separated by ;);; multi_results tell the server that the client can handle multiple; result sets from multiple-statement executions or; stored procedures; reconnect=0|1 enable or disable automatic reconnection to the server; if the connection is found to have been lost; compress use the compressed client/server protocol; cnf_file=filename Read options from the named option file instead of; from my.cnf; cnf_group=groupname Read options from the named group from my.cnf or the; file specified with cnf_file option; If several parameters are specified, they should be separated by ""&"" symbol; Example of connection argument:; TSQLServer::Connect(""mysql://host.domain/test?timeout=10&multi_statements"");. ~TMySQLServer(); Close connection to MySQL DB server. void Close(Option_t* opt = """"); Close connection to MySQL DB server. TSQLResult * Query(const char* sql); Execute SQL command. Result object must be deleted by the user.; Returns a pointer to a TSQLResult object if successful, 0 otherwise.; The result object must be deleted by the user. Bool_t Exec(const char* sql); Execute SQL command which does not produce any result sets.; Returns kTRUE if successful. Int_t SelectDataBase(const char* dbname); Select a database. Returns 0 if successful, non-zero otherwise. TSQLResult * GetDataBases(const char* wild = 0); List all available databases. Wild is for wildcarding ""t%"" list all; databases starting with ""t"".; Returns a pointer to a TSQLResult object if successful, 0 otherwise.; The result object must be deleted by the user. TSQLResult * GetTables(const char* dbname, const char* wild = 0); List all tables in the specified database. Wild is for wildcarding; ""t%"" list a",MatchSource.WIKI,root/html604/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLServer.html
https://root.cern/root/html604/TMySQLStatement.html:1475,Availability,error,error,1475,"stractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTSQLStatement::EnableErrorOutput(Bool_t on = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static ULong_tGetAllocSizeLimit(); virtual Bool_tGetBinary(Int_t npar, void*& mem, Long_t& size); virtual Int_tGetBufferLength() const; virtual Bool_tGetDate(Int_t npar, Int_t& year, Int_t& month, Int_t& day); virtual Bool_tGetDatime(Int_t npar, Int_t& year, Int_t& month, Int_t& day, Int_t& hour, Int_t& min, Int_t& sec); Int_tTSQLStatement::GetDay(Int_t); virtual Double_tGetDouble(Int_t npar); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSQLStatement::GetErrorCode() const; virtual const char*TSQLStatement::GetErrorMsg() const; virtual const char*GetFieldName(Int_t nfield); Int_tT",MatchSource.WIKI,root/html604/TMySQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLStatement.html
https://root.cern/root/html604/TMySQLStatement.html:1559,Availability,error,error,1559,"ion = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTSQLStatement::EnableErrorOutput(Bool_t on = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static ULong_tGetAllocSizeLimit(); virtual Bool_tGetBinary(Int_t npar, void*& mem, Long_t& size); virtual Int_tGetBufferLength() const; virtual Bool_tGetDate(Int_t npar, Int_t& year, Int_t& month, Int_t& day); virtual Bool_tGetDatime(Int_t npar, Int_t& year, Int_t& month, Int_t& day, Int_t& hour, Int_t& min, Int_t& sec); Int_tTSQLStatement::GetDay(Int_t); virtual Double_tGetDouble(Int_t npar); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSQLStatement::GetErrorCode() const; virtual const char*TSQLStatement::GetErrorMsg() const; virtual const char*GetFieldName(Int_t nfield); Int_tTSQLStatement::GetHour(Int_t); virtual const char*TObject::GetIconName() const; virtu",MatchSource.WIKI,root/html604/TMySQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLStatement.html
https://root.cern/root/html604/TMySQLStatement.html:10224,Availability,error,error,10224,"::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. MYSQL_BIND*fBind! array of bind data; TMySQLStatement::TParamData*fBuffer! parameter definition structures; Int_tTSQLStatement::fErrorCodeerror code of last operation; TStringTSQLStatement::fErrorMsgerror message of last operation; Bool_tTSQLStatement::fErrorOutenable error output; Int_tfIterationCount! number of iteration; Bool_tfNeedParBind! indicates when parameters bind should be called; Int_tfNumBuffers! number of statement parameters; MYSQL_STMT*fStmt! executed statement; Int_tfWorkingMode! 1 - setting parameters, 2 - retrieving results; static ULong64_tfgAllocSizeLimit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMySQLStatement(MYSQL_STMT* stmt, Bool_t errout = kTRUE); Normal constructor.; Checks if statement contains parameters tags. ~TMySQLStatement(); Destructor. void Close(Option_t* = """"); Close statement. Bool_t Process(); Process statement. Int_t GetNumAffectedRows(); Return number of affected rows after statement is processed. Int_t GetNumParameters(); Return number of statement parameters. Bool_t StoreResult(); Store result of statement processing to access them; via GetInt(), GetDouble() and so on methods. Int_t GetNumFields(); Return number of fields in result set. const char* GetFieldName(Int_t nfield); Re",MatchSource.WIKI,root/html604/TMySQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLStatement.html
https://root.cern/root/html604/TMySQLStatement.html:13166,Energy Efficiency,allocate,allocate,13166,"ULong64(Int_t npar); Return field value as unsigned 64-bit integer. Double_t GetDouble(Int_t npar); Return field value as double. const char * GetString(Int_t npar); Return field value as string. Bool_t GetBinary(Int_t npar, void*& mem, Long_t& size); Return field value as binary array. Bool_t GetDate(Int_t npar, Int_t& year, Int_t& month, Int_t& day); Return field value as date. Bool_t GetTime(Int_t npar, Int_t& hour, Int_t& min, Int_t& sec); Return field value as time. Bool_t GetDatime(Int_t npar, Int_t& year, Int_t& month, Int_t& day, Int_t& hour, Int_t& min, Int_t& sec); Return field value as date & time. Bool_t GetTimestamp(Int_t npar, Int_t& year, Int_t& month, Int_t& day, Int_t& hour, Int_t& min, Int_t& sec, Int_t& ); Return field value as time stamp. Bool_t SetSQLParamType(Int_t npar, int sqltype, Bool_t sig, ULong_t sqlsize = 0); Set parameter type to be used as buffer.; Used in both setting data to database and retriving data from data base.; Initialize proper MYSQL_BIND structure and allocate required buffers. void * BeforeSet(const char* method, Int_t npar, Int_t sqltype, Bool_t sig = kTRUE, ULong_t size = 0); Check boundary condition before setting value of parameter.; Return address of parameter buffer. Bool_t SetNull(Int_t npar); Set NULL as parameter value.; If NULL should be set for statement parameter during first iteration,; one should call before proper Set... method to identify type of argument for; the future. For instance, if one suppose to have double as type of parameter,; code should look like:; stmt->SetDouble(2, 0.);; stmt->SetNull(2);. Bool_t SetInt(Int_t npar, Int_t value); Set parameter value as integer. Bool_t SetUInt(Int_t npar, UInt_t value); Set parameter value as unsigned integer. Bool_t SetLong(Int_t npar, Long_t value); Set parameter value as long integer. Bool_t SetLong64(Int_t npar, Long64_t value); Set parameter value as 64-bit integer. Bool_t SetULong64(Int_t npar, ULong64_t value); Set parameter value as unsigned 64-bit inte",MatchSource.WIKI,root/html604/TMySQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLStatement.html
https://root.cern/root/html604/TMySQLStatement.html:10160,Integrability,message,message,10160,"::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. MYSQL_BIND*fBind! array of bind data; TMySQLStatement::TParamData*fBuffer! parameter definition structures; Int_tTSQLStatement::fErrorCodeerror code of last operation; TStringTSQLStatement::fErrorMsgerror message of last operation; Bool_tTSQLStatement::fErrorOutenable error output; Int_tfIterationCount! number of iteration; Bool_tfNeedParBind! indicates when parameters bind should be called; Int_tfNumBuffers! number of statement parameters; MYSQL_STMT*fStmt! executed statement; Int_tfWorkingMode! 1 - setting parameters, 2 - retrieving results; static ULong64_tfgAllocSizeLimit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMySQLStatement(MYSQL_STMT* stmt, Bool_t errout = kTRUE); Normal constructor.; Checks if statement contains parameters tags. ~TMySQLStatement(); Destructor. void Close(Option_t* = """"); Close statement. Bool_t Process(); Process statement. Int_t GetNumAffectedRows(); Return number of affected rows after statement is processed. Int_t GetNumParameters(); Return number of statement parameters. Bool_t StoreResult(); Store result of statement processing to access them; via GetInt(), GetDouble() and so on methods. Int_t GetNumFields(); Return number of fields in result set. const char* GetFieldName(Int_t nfield); Re",MatchSource.WIKI,root/html604/TMySQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLStatement.html
https://root.cern/root/html604/TMySQLStatement.html:11085,Security,access,access,11085,":fErrorCodeerror code of last operation; TStringTSQLStatement::fErrorMsgerror message of last operation; Bool_tTSQLStatement::fErrorOutenable error output; Int_tfIterationCount! number of iteration; Bool_tfNeedParBind! indicates when parameters bind should be called; Int_tfNumBuffers! number of statement parameters; MYSQL_STMT*fStmt! executed statement; Int_tfWorkingMode! 1 - setting parameters, 2 - retrieving results; static ULong64_tfgAllocSizeLimit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMySQLStatement(MYSQL_STMT* stmt, Bool_t errout = kTRUE); Normal constructor.; Checks if statement contains parameters tags. ~TMySQLStatement(); Destructor. void Close(Option_t* = """"); Close statement. Bool_t Process(); Process statement. Int_t GetNumAffectedRows(); Return number of affected rows after statement is processed. Int_t GetNumParameters(); Return number of statement parameters. Bool_t StoreResult(); Store result of statement processing to access them; via GetInt(), GetDouble() and so on methods. Int_t GetNumFields(); Return number of fields in result set. const char* GetFieldName(Int_t nfield); Returns field name in result set. Bool_t NextResultRow(); Shift cursor to nect row in result set. Bool_t NextIteration(); Increment iteration counter for statement, where parameter can be set.; Statement with parameters of previous iteration; automatically will be applied to database. void FreeBuffers(); Release all buffers, used by statement. void SetBuffersNumber(Int_t n); Allocate buffers for statement parameters/ result fields. const char* ConvertToString(Int_t npar); Convert field value to string. long double ConvertToNumeric(Int_t npar); Convert field to numeric value. Bool_t IsNull(Int_t npar); Checks if field value is null. Int_t GetInt(Int_t npar); Return field value as integer. UInt_t GetUInt(Int_t npar); Return field value as unsigned integer. Long_t GetLong(Int_t npar); Return field value as long integer. Long64_t ",MatchSource.WIKI,root/html604/TMySQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TMySQLStatement.html
https://root.cern/root/html604/TNamed.html:1511,Availability,error,error,1511," virtual~TNamed(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidCopy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); vir",MatchSource.WIKI,root/html604/TNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNamed.html
https://root.cern/root/html604/TNamed.html:1595,Availability,error,error,1595," virtual~TNamed(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidCopy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); vir",MatchSource.WIKI,root/html604/TNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNamed.html
https://root.cern/root/html604/TNDArray.html:921,Availability,avail,available,921,". TNDArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArray. class TNDArray: public TObject. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TNDArray(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0",MatchSource.WIKI,root/html604/TNDArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArray.html
https://root.cern/root/html604/TNDArray.html:1992,Availability,error,error,1992,"tMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tGetBin(const Int_t* idx) const; Long64_tGetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tGetNbins() const; Int_tGetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; vi",MatchSource.WIKI,root/html604/TNDArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArray.html
https://root.cern/root/html604/TNDArray.html:2076,Availability,error,error,2076,"e); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tGetBin(const Int_t* idx) const; Long64_tGetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tGetNbins() const; Int_tGetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_",MatchSource.WIKI,root/html604/TNDArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArray.html
https://root.cern/root/html604/TNDArray.html:548,Energy Efficiency,allocate,allocated,548,". TNDArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArray. class TNDArray: public TObject. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TNDArray(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0",MatchSource.WIKI,root/html604/TNDArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArray.html
https://root.cern/root/html604/TNDArray.html:624,Security,access,access,624,". TNDArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArray. class TNDArray: public TObject. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TNDArray(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0",MatchSource.WIKI,root/html604/TNDArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArray.html
https://root.cern/root/html604/TNDArrayRef_char_.html:559,Energy Efficiency,allocate,allocated,559,". TNDArrayRef<char>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayRef<char>. class TNDArrayRef<char>. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. ~TNDArrayRef<char>(); static TClass*Class(); TClass*IsA() const; charoperator char() const; TNDArrayRef<char>&operator=(const TNDArrayRef<char>&); TNDArrayRef<char>&operator=(TNDArrayRef<char>&&); TNDArrayRef<char>operator[](Int_t idx) const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TNDArrayRef<char>(const TNDArrayRef<char>&); TNDArrayRef<char>(TNDArrayRef<char>&&); TNDArrayRef<char>(const char* data, const Long64_t* sizes). Data Members; private:. const char*fDatapointer into TNDArray's fData; const Long64_t*fSizespointer into TNDArray's fSizes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNDArray& operator=(const TNDArray&). TNDArrayRef<T> operator[](Int_t idx) const. » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNDArrayRef_char_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayRef_char_.html
https://root.cern/root/html604/TNDArrayRef_char_.html:635,Security,access,access,635,". TNDArrayRef<char>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayRef<char>. class TNDArrayRef<char>. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. ~TNDArrayRef<char>(); static TClass*Class(); TClass*IsA() const; charoperator char() const; TNDArrayRef<char>&operator=(const TNDArrayRef<char>&); TNDArrayRef<char>&operator=(TNDArrayRef<char>&&); TNDArrayRef<char>operator[](Int_t idx) const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TNDArrayRef<char>(const TNDArrayRef<char>&); TNDArrayRef<char>(TNDArrayRef<char>&&); TNDArrayRef<char>(const char* data, const Long64_t* sizes). Data Members; private:. const char*fDatapointer into TNDArray's fData; const Long64_t*fSizespointer into TNDArray's fSizes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNDArray& operator=(const TNDArray&). TNDArrayRef<T> operator[](Int_t idx) const. » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNDArrayRef_char_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayRef_char_.html
https://root.cern/root/html604/TNDArrayRef_double_.html:565,Energy Efficiency,allocate,allocated,565,". TNDArrayRef<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayRef<double>. class TNDArrayRef<double>. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. ~TNDArrayRef<double>(); static TClass*Class(); TClass*IsA() const; doubleoperator double() const; TNDArrayRef<double>&operator=(const TNDArrayRef<double>&); TNDArrayRef<double>&operator=(TNDArrayRef<double>&&); TNDArrayRef<double>operator[](Int_t idx) const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TNDArrayRef<double>(const TNDArrayRef<double>&); TNDArrayRef<double>(TNDArrayRef<double>&&); TNDArrayRef<double>(const double* data, const Long64_t* sizes). Data Members; private:. const double*fDatapointer into TNDArray's fData; const Long64_t*fSizespointer into TNDArray's fSizes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNDArray& operator=(const TNDArray&). TNDArrayRef<T> operator[](Int_t idx) const. » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support",MatchSource.WIKI,root/html604/TNDArrayRef_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayRef_double_.html
https://root.cern/root/html604/TNDArrayRef_double_.html:641,Security,access,access,641,". TNDArrayRef<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayRef<double>. class TNDArrayRef<double>. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. ~TNDArrayRef<double>(); static TClass*Class(); TClass*IsA() const; doubleoperator double() const; TNDArrayRef<double>&operator=(const TNDArrayRef<double>&); TNDArrayRef<double>&operator=(TNDArrayRef<double>&&); TNDArrayRef<double>operator[](Int_t idx) const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TNDArrayRef<double>(const TNDArrayRef<double>&); TNDArrayRef<double>(TNDArrayRef<double>&&); TNDArrayRef<double>(const double* data, const Long64_t* sizes). Data Members; private:. const double*fDatapointer into TNDArray's fData; const Long64_t*fSizespointer into TNDArray's fSizes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNDArray& operator=(const TNDArray&). TNDArrayRef<T> operator[](Int_t idx) const. » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support",MatchSource.WIKI,root/html604/TNDArrayRef_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayRef_double_.html
https://root.cern/root/html604/TNDArrayRef_float_.html:562,Energy Efficiency,allocate,allocated,562,". TNDArrayRef<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayRef<float>. class TNDArrayRef<float>. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. ~TNDArrayRef<float>(); static TClass*Class(); TClass*IsA() const; floatoperator float() const; TNDArrayRef<float>&operator=(const TNDArrayRef<float>&); TNDArrayRef<float>&operator=(TNDArrayRef<float>&&); TNDArrayRef<float>operator[](Int_t idx) const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TNDArrayRef<float>(const TNDArrayRef<float>&); TNDArrayRef<float>(TNDArrayRef<float>&&); TNDArrayRef<float>(const float* data, const Long64_t* sizes). Data Members; private:. const float*fDatapointer into TNDArray's fData; const Long64_t*fSizespointer into TNDArray's fSizes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNDArray& operator=(const TNDArray&). TNDArrayRef<T> operator[](Int_t idx) const. » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNDArrayRef_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayRef_float_.html
https://root.cern/root/html604/TNDArrayRef_float_.html:638,Security,access,access,638,". TNDArrayRef<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayRef<float>. class TNDArrayRef<float>. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. ~TNDArrayRef<float>(); static TClass*Class(); TClass*IsA() const; floatoperator float() const; TNDArrayRef<float>&operator=(const TNDArrayRef<float>&); TNDArrayRef<float>&operator=(TNDArrayRef<float>&&); TNDArrayRef<float>operator[](Int_t idx) const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TNDArrayRef<float>(const TNDArrayRef<float>&); TNDArrayRef<float>(TNDArrayRef<float>&&); TNDArrayRef<float>(const float* data, const Long64_t* sizes). Data Members; private:. const float*fDatapointer into TNDArray's fData; const Long64_t*fSizespointer into TNDArray's fSizes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNDArray& operator=(const TNDArray&). TNDArrayRef<T> operator[](Int_t idx) const. » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNDArrayRef_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayRef_float_.html
https://root.cern/root/html604/TNDArrayRef_int_.html:556,Energy Efficiency,allocate,allocated,556,". TNDArrayRef<int>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayRef<int>. class TNDArrayRef<int>. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. ~TNDArrayRef<int>(); static TClass*Class(); TClass*IsA() const; intoperator int() const; TNDArrayRef<int>&operator=(const TNDArrayRef<int>&); TNDArrayRef<int>&operator=(TNDArrayRef<int>&&); TNDArrayRef<int>operator[](Int_t idx) const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TNDArrayRef<int>(const TNDArrayRef<int>&); TNDArrayRef<int>(TNDArrayRef<int>&&); TNDArrayRef<int>(const int* data, const Long64_t* sizes). Data Members; private:. const int*fDatapointer into TNDArray's fData; const Long64_t*fSizespointer into TNDArray's fSizes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNDArray& operator=(const TNDArray&). TNDArrayRef<T> operator[](Int_t idx) const. » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNDArrayRef_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayRef_int_.html
https://root.cern/root/html604/TNDArrayRef_int_.html:632,Security,access,access,632,". TNDArrayRef<int>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayRef<int>. class TNDArrayRef<int>. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. ~TNDArrayRef<int>(); static TClass*Class(); TClass*IsA() const; intoperator int() const; TNDArrayRef<int>&operator=(const TNDArrayRef<int>&); TNDArrayRef<int>&operator=(TNDArrayRef<int>&&); TNDArrayRef<int>operator[](Int_t idx) const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TNDArrayRef<int>(const TNDArrayRef<int>&); TNDArrayRef<int>(TNDArrayRef<int>&&); TNDArrayRef<int>(const int* data, const Long64_t* sizes). Data Members; private:. const int*fDatapointer into TNDArray's fData; const Long64_t*fSizespointer into TNDArray's fSizes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNDArray& operator=(const TNDArray&). TNDArrayRef<T> operator[](Int_t idx) const. » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNDArrayRef_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayRef_int_.html
https://root.cern/root/html604/TNDArrayRef_Long64_t_.html:571,Energy Efficiency,allocate,allocated,571,". TNDArrayRef<Long64_t>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayRef<Long64_t>. class TNDArrayRef<Long64_t>. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. ~TNDArrayRef<Long64_t>(); static TClass*Class(); TClass*IsA() const; Long64_toperator long long() const; TNDArrayRef<Long64_t>&operator=(const TNDArrayRef<Long64_t>&); TNDArrayRef<Long64_t>&operator=(TNDArrayRef<Long64_t>&&); TNDArrayRef<Long64_t>operator[](Int_t idx) const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TNDArrayRef<Long64_t>(const TNDArrayRef<Long64_t>&); TNDArrayRef<Long64_t>(TNDArrayRef<Long64_t>&&); TNDArrayRef<Long64_t>(const Long64_t* data, const Long64_t* sizes). Data Members; private:. Long64_t*fDatapointer into TNDArray's fData; const Long64_t*fSizespointer into TNDArray's fSizes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNDArray& operator=(const TNDArray&). TNDArrayRef<T> operator[](Int_t idx) const. » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general ple",MatchSource.WIKI,root/html604/TNDArrayRef_Long64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayRef_Long64_t_.html
https://root.cern/root/html604/TNDArrayRef_Long64_t_.html:647,Security,access,access,647,". TNDArrayRef<Long64_t>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayRef<Long64_t>. class TNDArrayRef<Long64_t>. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. ~TNDArrayRef<Long64_t>(); static TClass*Class(); TClass*IsA() const; Long64_toperator long long() const; TNDArrayRef<Long64_t>&operator=(const TNDArrayRef<Long64_t>&); TNDArrayRef<Long64_t>&operator=(TNDArrayRef<Long64_t>&&); TNDArrayRef<Long64_t>operator[](Int_t idx) const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TNDArrayRef<Long64_t>(const TNDArrayRef<Long64_t>&); TNDArrayRef<Long64_t>(TNDArrayRef<Long64_t>&&); TNDArrayRef<Long64_t>(const Long64_t* data, const Long64_t* sizes). Data Members; private:. Long64_t*fDatapointer into TNDArray's fData; const Long64_t*fSizespointer into TNDArray's fSizes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNDArray& operator=(const TNDArray&). TNDArrayRef<T> operator[](Int_t idx) const. » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general ple",MatchSource.WIKI,root/html604/TNDArrayRef_Long64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayRef_Long64_t_.html
https://root.cern/root/html604/TNDArrayRef_long_.html:559,Energy Efficiency,allocate,allocated,559,". TNDArrayRef<long>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayRef<long>. class TNDArrayRef<long>. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. ~TNDArrayRef<long>(); static TClass*Class(); TClass*IsA() const; longoperator long() const; TNDArrayRef<long>&operator=(const TNDArrayRef<long>&); TNDArrayRef<long>&operator=(TNDArrayRef<long>&&); TNDArrayRef<long>operator[](Int_t idx) const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TNDArrayRef<long>(const TNDArrayRef<long>&); TNDArrayRef<long>(TNDArrayRef<long>&&); TNDArrayRef<long>(const long* data, const Long64_t* sizes). Data Members; private:. const long*fDatapointer into TNDArray's fData; const Long64_t*fSizespointer into TNDArray's fSizes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNDArray& operator=(const TNDArray&). TNDArrayRef<T> operator[](Int_t idx) const. » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNDArrayRef_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayRef_long_.html
https://root.cern/root/html604/TNDArrayRef_long_.html:635,Security,access,access,635,". TNDArrayRef<long>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayRef<long>. class TNDArrayRef<long>. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. ~TNDArrayRef<long>(); static TClass*Class(); TClass*IsA() const; longoperator long() const; TNDArrayRef<long>&operator=(const TNDArrayRef<long>&); TNDArrayRef<long>&operator=(TNDArrayRef<long>&&); TNDArrayRef<long>operator[](Int_t idx) const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TNDArrayRef<long>(const TNDArrayRef<long>&); TNDArrayRef<long>(TNDArrayRef<long>&&); TNDArrayRef<long>(const long* data, const Long64_t* sizes). Data Members; private:. const long*fDatapointer into TNDArray's fData; const Long64_t*fSizespointer into TNDArray's fSizes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNDArray& operator=(const TNDArray&). TNDArrayRef<T> operator[](Int_t idx) const. » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNDArrayRef_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayRef_long_.html
https://root.cern/root/html604/TNDArrayRef_short_.html:562,Energy Efficiency,allocate,allocated,562,". TNDArrayRef<short>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayRef<short>. class TNDArrayRef<short>. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. ~TNDArrayRef<short>(); static TClass*Class(); TClass*IsA() const; shortoperator short() const; TNDArrayRef<short>&operator=(const TNDArrayRef<short>&); TNDArrayRef<short>&operator=(TNDArrayRef<short>&&); TNDArrayRef<short>operator[](Int_t idx) const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TNDArrayRef<short>(const TNDArrayRef<short>&); TNDArrayRef<short>(TNDArrayRef<short>&&); TNDArrayRef<short>(const short* data, const Long64_t* sizes). Data Members; private:. const short*fDatapointer into TNDArray's fData; const Long64_t*fSizespointer into TNDArray's fSizes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNDArray& operator=(const TNDArray&). TNDArrayRef<T> operator[](Int_t idx) const. » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNDArrayRef_short_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayRef_short_.html
https://root.cern/root/html604/TNDArrayRef_short_.html:638,Security,access,access,638,". TNDArrayRef<short>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayRef<short>. class TNDArrayRef<short>. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. ~TNDArrayRef<short>(); static TClass*Class(); TClass*IsA() const; shortoperator short() const; TNDArrayRef<short>&operator=(const TNDArrayRef<short>&); TNDArrayRef<short>&operator=(TNDArrayRef<short>&&); TNDArrayRef<short>operator[](Int_t idx) const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TNDArrayRef<short>(const TNDArrayRef<short>&); TNDArrayRef<short>(TNDArrayRef<short>&&); TNDArrayRef<short>(const short* data, const Long64_t* sizes). Data Members; private:. const short*fDatapointer into TNDArray's fData; const Long64_t*fSizespointer into TNDArray's fSizes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNDArray& operator=(const TNDArray&). TNDArrayRef<T> operator[](Int_t idx) const. » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNDArrayRef_short_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayRef_short_.html
https://root.cern/root/html604/TNDArrayRef_ULong64_t_.html:574,Energy Efficiency,allocate,allocated,574,". TNDArrayRef<ULong64_t>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayRef<ULong64_t>. class TNDArrayRef<ULong64_t>. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. ~TNDArrayRef<ULong64_t>(); static TClass*Class(); TClass*IsA() const; ULong64_toperator unsigned long long() const; TNDArrayRef<ULong64_t>&operator=(const TNDArrayRef<ULong64_t>&); TNDArrayRef<ULong64_t>&operator=(TNDArrayRef<ULong64_t>&&); TNDArrayRef<ULong64_t>operator[](Int_t idx) const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TNDArrayRef<ULong64_t>(const TNDArrayRef<ULong64_t>&); TNDArrayRef<ULong64_t>(TNDArrayRef<ULong64_t>&&); TNDArrayRef<ULong64_t>(const ULong64_t* data, const Long64_t* sizes). Data Members; private:. ULong64_t*fDatapointer into TNDArray's fData; const Long64_t*fSizespointer into TNDArray's fSizes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNDArray& operator=(const TNDArray&). TNDArrayRef<T> operator[](Int_t idx) const. » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:47; This page has been automatically generated. For comments or suggestions regarding the documentat",MatchSource.WIKI,root/html604/TNDArrayRef_ULong64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayRef_ULong64_t_.html
https://root.cern/root/html604/TNDArrayRef_ULong64_t_.html:650,Security,access,access,650,". TNDArrayRef<ULong64_t>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayRef<ULong64_t>. class TNDArrayRef<ULong64_t>. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. ~TNDArrayRef<ULong64_t>(); static TClass*Class(); TClass*IsA() const; ULong64_toperator unsigned long long() const; TNDArrayRef<ULong64_t>&operator=(const TNDArrayRef<ULong64_t>&); TNDArrayRef<ULong64_t>&operator=(TNDArrayRef<ULong64_t>&&); TNDArrayRef<ULong64_t>operator[](Int_t idx) const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TNDArrayRef<ULong64_t>(const TNDArrayRef<ULong64_t>&); TNDArrayRef<ULong64_t>(TNDArrayRef<ULong64_t>&&); TNDArrayRef<ULong64_t>(const ULong64_t* data, const Long64_t* sizes). Data Members; private:. ULong64_t*fDatapointer into TNDArray's fData; const Long64_t*fSizespointer into TNDArray's fSizes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNDArray& operator=(const TNDArray&). TNDArrayRef<T> operator[](Int_t idx) const. » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:47; This page has been automatically generated. For comments or suggestions regarding the documentat",MatchSource.WIKI,root/html604/TNDArrayRef_ULong64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayRef_ULong64_t_.html
https://root.cern/root/html604/TNDArrayRef_unsigned_int_.html:583,Energy Efficiency,allocate,allocated,583,". TNDArrayRef<unsigned int>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayRef<unsigned int>. class TNDArrayRef<unsigned int>. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. ~TNDArrayRef<unsigned int>(); static TClass*Class(); TClass*IsA() const; unsigned intoperator unsigned int() const; TNDArrayRef<unsigned int>&operator=(const TNDArrayRef<unsigned int>&); TNDArrayRef<unsigned int>&operator=(TNDArrayRef<unsigned int>&&); TNDArrayRef<unsigned int>operator[](Int_t idx) const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TNDArrayRef<unsigned int>(const TNDArrayRef<unsigned int>&); TNDArrayRef<unsigned int>(TNDArrayRef<unsigned int>&&); TNDArrayRef<unsigned int>(const unsigned int* data, const Long64_t* sizes). Data Members; private:. const unsigned int*fDatapointer into TNDArray's fData; const Long64_t*fSizespointer into TNDArray's fSizes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNDArray& operator=(const TNDArray&). TNDArrayRef<T> operator[](Int_t idx) const. » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:47; This page has been automatically generated. F",MatchSource.WIKI,root/html604/TNDArrayRef_unsigned_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayRef_unsigned_int_.html
https://root.cern/root/html604/TNDArrayRef_unsigned_int_.html:659,Security,access,access,659,". TNDArrayRef<unsigned int>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayRef<unsigned int>. class TNDArrayRef<unsigned int>. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. ~TNDArrayRef<unsigned int>(); static TClass*Class(); TClass*IsA() const; unsigned intoperator unsigned int() const; TNDArrayRef<unsigned int>&operator=(const TNDArrayRef<unsigned int>&); TNDArrayRef<unsigned int>&operator=(TNDArrayRef<unsigned int>&&); TNDArrayRef<unsigned int>operator[](Int_t idx) const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TNDArrayRef<unsigned int>(const TNDArrayRef<unsigned int>&); TNDArrayRef<unsigned int>(TNDArrayRef<unsigned int>&&); TNDArrayRef<unsigned int>(const unsigned int* data, const Long64_t* sizes). Data Members; private:. const unsigned int*fDatapointer into TNDArray's fData; const Long64_t*fSizespointer into TNDArray's fSizes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNDArray& operator=(const TNDArray&). TNDArrayRef<T> operator[](Int_t idx) const. » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:47; This page has been automatically generated. F",MatchSource.WIKI,root/html604/TNDArrayRef_unsigned_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayRef_unsigned_int_.html
https://root.cern/root/html604/TNDArrayRef_unsigned_long_.html:586,Energy Efficiency,allocate,allocated,586,". TNDArrayRef<unsigned long>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayRef<unsigned long>. class TNDArrayRef<unsigned long>. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. ~TNDArrayRef<unsigned long>(); static TClass*Class(); TClass*IsA() const; unsigned longoperator unsigned long() const; TNDArrayRef<unsigned long>&operator=(const TNDArrayRef<unsigned long>&); TNDArrayRef<unsigned long>&operator=(TNDArrayRef<unsigned long>&&); TNDArrayRef<unsigned long>operator[](Int_t idx) const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TNDArrayRef<unsigned long>(const TNDArrayRef<unsigned long>&); TNDArrayRef<unsigned long>(TNDArrayRef<unsigned long>&&); TNDArrayRef<unsigned long>(const unsigned long* data, const Long64_t* sizes). Data Members; private:. const unsigned long*fDatapointer into TNDArray's fData; const Long64_t*fSizespointer into TNDArray's fSizes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNDArray& operator=(const TNDArray&). TNDArrayRef<T> operator[](Int_t idx) const. » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:47; This page has been automati",MatchSource.WIKI,root/html604/TNDArrayRef_unsigned_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayRef_unsigned_long_.html
https://root.cern/root/html604/TNDArrayRef_unsigned_long_.html:662,Security,access,access,662,". TNDArrayRef<unsigned long>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayRef<unsigned long>. class TNDArrayRef<unsigned long>. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. ~TNDArrayRef<unsigned long>(); static TClass*Class(); TClass*IsA() const; unsigned longoperator unsigned long() const; TNDArrayRef<unsigned long>&operator=(const TNDArrayRef<unsigned long>&); TNDArrayRef<unsigned long>&operator=(TNDArrayRef<unsigned long>&&); TNDArrayRef<unsigned long>operator[](Int_t idx) const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TNDArrayRef<unsigned long>(const TNDArrayRef<unsigned long>&); TNDArrayRef<unsigned long>(TNDArrayRef<unsigned long>&&); TNDArrayRef<unsigned long>(const unsigned long* data, const Long64_t* sizes). Data Members; private:. const unsigned long*fDatapointer into TNDArray's fData; const Long64_t*fSizespointer into TNDArray's fSizes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNDArray& operator=(const TNDArray&). TNDArrayRef<T> operator[](Int_t idx) const. » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:47; This page has been automati",MatchSource.WIKI,root/html604/TNDArrayRef_unsigned_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayRef_unsigned_long_.html
https://root.cern/root/html604/TNDArrayRef_unsigned_short_.html:589,Energy Efficiency,allocate,allocated,589,". TNDArrayRef<unsigned short>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayRef<unsigned short>. class TNDArrayRef<unsigned short>. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. ~TNDArrayRef<unsigned short>(); static TClass*Class(); TClass*IsA() const; unsigned shortoperator unsigned short() const; TNDArrayRef<unsigned short>&operator=(const TNDArrayRef<unsigned short>&); TNDArrayRef<unsigned short>&operator=(TNDArrayRef<unsigned short>&&); TNDArrayRef<unsigned short>operator[](Int_t idx) const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TNDArrayRef<unsigned short>(const TNDArrayRef<unsigned short>&); TNDArrayRef<unsigned short>(TNDArrayRef<unsigned short>&&); TNDArrayRef<unsigned short>(const unsigned short* data, const Long64_t* sizes). Data Members; private:. const unsigned short*fDatapointer into TNDArray's fData; const Long64_t*fSizespointer into TNDArray's fSizes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNDArray& operator=(const TNDArray&). TNDArrayRef<T> operator[](Int_t idx) const. » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:47; This page",MatchSource.WIKI,root/html604/TNDArrayRef_unsigned_short_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayRef_unsigned_short_.html
https://root.cern/root/html604/TNDArrayRef_unsigned_short_.html:665,Security,access,access,665,". TNDArrayRef<unsigned short>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayRef<unsigned short>. class TNDArrayRef<unsigned short>. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. ~TNDArrayRef<unsigned short>(); static TClass*Class(); TClass*IsA() const; unsigned shortoperator unsigned short() const; TNDArrayRef<unsigned short>&operator=(const TNDArrayRef<unsigned short>&); TNDArrayRef<unsigned short>&operator=(TNDArrayRef<unsigned short>&&); TNDArrayRef<unsigned short>operator[](Int_t idx) const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TNDArrayRef<unsigned short>(const TNDArrayRef<unsigned short>&); TNDArrayRef<unsigned short>(TNDArrayRef<unsigned short>&&); TNDArrayRef<unsigned short>(const unsigned short* data, const Long64_t* sizes). Data Members; private:. const unsigned short*fDatapointer into TNDArray's fData; const Long64_t*fSizespointer into TNDArray's fSizes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNDArray& operator=(const TNDArray&). TNDArrayRef<T> operator[](Int_t idx) const. » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:47; This page",MatchSource.WIKI,root/html604/TNDArrayRef_unsigned_short_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayRef_unsigned_short_.html
https://root.cern/root/html604/TNDArrayT_char_.html:2008,Availability,error,error,2008,"(Option_t* option = """"); charAt(const Int_t* idx) const; char&At(const Int_t* idx); charAt(ULong64_t linidx) const; char&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTNDArray::GetBin(const Int_t* idx) const; Long64_tTNDArray::GetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tTNDArray::GetNbins() const; Int_tTNDArray::GetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); ",MatchSource.WIKI,root/html604/TNDArrayT_char_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_char_.html
https://root.cern/root/html604/TNDArrayT_char_.html:2092,Availability,error,error,2092,"charAt(ULong64_t linidx) const; char&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTNDArray::GetBin(const Int_t* idx) const; Long64_tTNDArray::GetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tTNDArray::GetNbins() const; Int_tTNDArray::GetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, ",MatchSource.WIKI,root/html604/TNDArrayT_char_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_char_.html
https://root.cern/root/html604/TNDArrayT_char_.html:570,Energy Efficiency,allocate,allocated,570,". TNDArrayT<char>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayT<char>. class TNDArrayT<char>: public TNDArray. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. virtual~TNDArrayT<char>(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); charAt(const Int_t* idx) const; char&At(const Int_t* idx); charAt(ULong64_t linidx) const; char&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, ",MatchSource.WIKI,root/html604/TNDArrayT_char_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_char_.html
https://root.cern/root/html604/TNDArrayT_char_.html:646,Security,access,access,646,". TNDArrayT<char>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayT<char>. class TNDArrayT<char>: public TNDArray. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. virtual~TNDArrayT<char>(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); charAt(const Int_t* idx) const; char&At(const Int_t* idx); charAt(ULong64_t linidx) const; char&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, ",MatchSource.WIKI,root/html604/TNDArrayT_char_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_char_.html
https://root.cern/root/html604/TNDArrayT_double_.html:2024,Availability,error,error,2024,"t* option = """"); doubleAt(const Int_t* idx) const; double&At(const Int_t* idx); doubleAt(ULong64_t linidx) const; double&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTNDArray::GetBin(const Int_t* idx) const; Long64_tTNDArray::GetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tTNDArray::GetNbins() const; Int_tTNDArray::GetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); ",MatchSource.WIKI,root/html604/TNDArrayT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_double_.html
https://root.cern/root/html604/TNDArrayT_double_.html:2108,Availability,error,error,2108,"leAt(ULong64_t linidx) const; double&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTNDArray::GetBin(const Int_t* idx) const; Long64_tTNDArray::GetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tTNDArray::GetNbins() const; Int_tTNDArray::GetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, ",MatchSource.WIKI,root/html604/TNDArrayT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_double_.html
https://root.cern/root/html604/TNDArrayT_double_.html:576,Energy Efficiency,allocate,allocated,576,". TNDArrayT<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayT<double>. class TNDArrayT<double>: public TNDArray. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. virtual~TNDArrayT<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); doubleAt(const Int_t* idx) const; double&At(const Int_t* idx); doubleAt(ULong64_t linidx) const; double&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, cons",MatchSource.WIKI,root/html604/TNDArrayT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_double_.html
https://root.cern/root/html604/TNDArrayT_double_.html:652,Security,access,access,652,". TNDArrayT<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayT<double>. class TNDArrayT<double>: public TNDArray. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. virtual~TNDArrayT<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); doubleAt(const Int_t* idx) const; double&At(const Int_t* idx); doubleAt(ULong64_t linidx) const; double&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, cons",MatchSource.WIKI,root/html604/TNDArrayT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_double_.html
https://root.cern/root/html604/TNDArrayT_float_.html:2016,Availability,error,error,2016,"ion_t* option = """"); floatAt(const Int_t* idx) const; float&At(const Int_t* idx); floatAt(ULong64_t linidx) const; float&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTNDArray::GetBin(const Int_t* idx) const; Long64_tTNDArray::GetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tTNDArray::GetNbins() const; Int_tTNDArray::GetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); ",MatchSource.WIKI,root/html604/TNDArrayT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_float_.html
https://root.cern/root/html604/TNDArrayT_float_.html:2100,Availability,error,error,2100,"oatAt(ULong64_t linidx) const; float&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTNDArray::GetBin(const Int_t* idx) const; Long64_tTNDArray::GetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tTNDArray::GetNbins() const; Int_tTNDArray::GetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, ",MatchSource.WIKI,root/html604/TNDArrayT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_float_.html
https://root.cern/root/html604/TNDArrayT_float_.html:573,Energy Efficiency,allocate,allocated,573,". TNDArrayT<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayT<float>. class TNDArrayT<float>: public TNDArray. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. virtual~TNDArrayT<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); floatAt(const Int_t* idx) const; float&At(const Int_t* idx); floatAt(ULong64_t linidx) const; float&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* ",MatchSource.WIKI,root/html604/TNDArrayT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_float_.html
https://root.cern/root/html604/TNDArrayT_float_.html:649,Security,access,access,649,". TNDArrayT<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayT<float>. class TNDArrayT<float>: public TNDArray. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. virtual~TNDArrayT<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); floatAt(const Int_t* idx) const; float&At(const Int_t* idx); floatAt(ULong64_t linidx) const; float&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* ",MatchSource.WIKI,root/html604/TNDArrayT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_float_.html
https://root.cern/root/html604/TNDArrayT_int_.html:2000,Availability,error,error,2000,"dPad(Option_t* option = """"); intAt(const Int_t* idx) const; int&At(const Int_t* idx); intAt(ULong64_t linidx) const; int&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTNDArray::GetBin(const Int_t* idx) const; Long64_tTNDArray::GetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tTNDArray::GetNbins() const; Int_tTNDArray::GetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); ",MatchSource.WIKI,root/html604/TNDArrayT_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_int_.html
https://root.cern/root/html604/TNDArrayT_int_.html:2084,Availability,error,error,2084,"; intAt(ULong64_t linidx) const; int&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTNDArray::GetBin(const Int_t* idx) const; Long64_tTNDArray::GetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tTNDArray::GetNbins() const; Int_tTNDArray::GetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, ",MatchSource.WIKI,root/html604/TNDArrayT_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_int_.html
https://root.cern/root/html604/TNDArrayT_int_.html:567,Energy Efficiency,allocate,allocated,567,". TNDArrayT<int>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayT<int>. class TNDArrayT<int>: public TNDArray. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. virtual~TNDArrayT<int>(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); intAt(const Int_t* idx) const; int&At(const Int_t* idx); intAt(ULong64_t linidx) const; int&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* e",MatchSource.WIKI,root/html604/TNDArrayT_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_int_.html
https://root.cern/root/html604/TNDArrayT_int_.html:643,Security,access,access,643,". TNDArrayT<int>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayT<int>. class TNDArrayT<int>: public TNDArray. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. virtual~TNDArrayT<int>(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); intAt(const Int_t* idx) const; int&At(const Int_t* idx); intAt(ULong64_t linidx) const; int&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* e",MatchSource.WIKI,root/html604/TNDArrayT_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_int_.html
https://root.cern/root/html604/TNDArrayT_Long64_t_.html:2040,Availability,error,error,2040,"n = """"); Long64_tAt(const Int_t* idx) const; Long64_t&At(const Int_t* idx); Long64_tAt(ULong64_t linidx) const; Long64_t&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTNDArray::GetBin(const Int_t* idx) const; Long64_tTNDArray::GetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tTNDArray::GetNbins() const; Int_tTNDArray::GetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); ",MatchSource.WIKI,root/html604/TNDArrayT_Long64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_Long64_t_.html
https://root.cern/root/html604/TNDArrayT_Long64_t_.html:2124,Availability,error,error,2124,"At(ULong64_t linidx) const; Long64_t&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTNDArray::GetBin(const Int_t* idx) const; Long64_tTNDArray::GetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tTNDArray::GetNbins() const; Int_tTNDArray::GetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, ",MatchSource.WIKI,root/html604/TNDArrayT_Long64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_Long64_t_.html
https://root.cern/root/html604/TNDArrayT_Long64_t_.html:582,Energy Efficiency,allocate,allocated,582,". TNDArrayT<Long64_t>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayT<Long64_t>. class TNDArrayT<Long64_t>: public TNDArray. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. virtual~TNDArrayT<Long64_t>(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); Long64_tAt(const Int_t* idx) const; Long64_t&At(const Int_t* idx); Long64_tAt(ULong64_t linidx) const; Long64_t&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const ch",MatchSource.WIKI,root/html604/TNDArrayT_Long64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_Long64_t_.html
https://root.cern/root/html604/TNDArrayT_Long64_t_.html:658,Security,access,access,658,". TNDArrayT<Long64_t>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayT<Long64_t>. class TNDArrayT<Long64_t>: public TNDArray. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. virtual~TNDArrayT<Long64_t>(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); Long64_tAt(const Int_t* idx) const; Long64_t&At(const Int_t* idx); Long64_tAt(ULong64_t linidx) const; Long64_t&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const ch",MatchSource.WIKI,root/html604/TNDArrayT_Long64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_Long64_t_.html
https://root.cern/root/html604/TNDArrayT_long_.html:2008,Availability,error,error,2008,"(Option_t* option = """"); longAt(const Int_t* idx) const; long&At(const Int_t* idx); longAt(ULong64_t linidx) const; long&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTNDArray::GetBin(const Int_t* idx) const; Long64_tTNDArray::GetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tTNDArray::GetNbins() const; Int_tTNDArray::GetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); ",MatchSource.WIKI,root/html604/TNDArrayT_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_long_.html
https://root.cern/root/html604/TNDArrayT_long_.html:2092,Availability,error,error,2092,"longAt(ULong64_t linidx) const; long&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTNDArray::GetBin(const Int_t* idx) const; Long64_tTNDArray::GetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tTNDArray::GetNbins() const; Int_tTNDArray::GetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, ",MatchSource.WIKI,root/html604/TNDArrayT_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_long_.html
https://root.cern/root/html604/TNDArrayT_long_.html:570,Energy Efficiency,allocate,allocated,570,". TNDArrayT<long>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayT<long>. class TNDArrayT<long>: public TNDArray. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. virtual~TNDArrayT<long>(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); longAt(const Int_t* idx) const; long&At(const Int_t* idx); longAt(ULong64_t linidx) const; long&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, ",MatchSource.WIKI,root/html604/TNDArrayT_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_long_.html
https://root.cern/root/html604/TNDArrayT_long_.html:646,Security,access,access,646,". TNDArrayT<long>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayT<long>. class TNDArrayT<long>: public TNDArray. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. virtual~TNDArrayT<long>(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); longAt(const Int_t* idx) const; long&At(const Int_t* idx); longAt(ULong64_t linidx) const; long&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, ",MatchSource.WIKI,root/html604/TNDArrayT_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_long_.html
https://root.cern/root/html604/TNDArrayT_short_.html:2016,Availability,error,error,2016,"ion_t* option = """"); shortAt(const Int_t* idx) const; short&At(const Int_t* idx); shortAt(ULong64_t linidx) const; short&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTNDArray::GetBin(const Int_t* idx) const; Long64_tTNDArray::GetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tTNDArray::GetNbins() const; Int_tTNDArray::GetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); ",MatchSource.WIKI,root/html604/TNDArrayT_short_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_short_.html
https://root.cern/root/html604/TNDArrayT_short_.html:2100,Availability,error,error,2100,"ortAt(ULong64_t linidx) const; short&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTNDArray::GetBin(const Int_t* idx) const; Long64_tTNDArray::GetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tTNDArray::GetNbins() const; Int_tTNDArray::GetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, ",MatchSource.WIKI,root/html604/TNDArrayT_short_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_short_.html
https://root.cern/root/html604/TNDArrayT_short_.html:573,Energy Efficiency,allocate,allocated,573,". TNDArrayT<short>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayT<short>. class TNDArrayT<short>: public TNDArray. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. virtual~TNDArrayT<short>(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); shortAt(const Int_t* idx) const; short&At(const Int_t* idx); shortAt(ULong64_t linidx) const; short&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* ",MatchSource.WIKI,root/html604/TNDArrayT_short_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_short_.html
https://root.cern/root/html604/TNDArrayT_short_.html:649,Security,access,access,649,". TNDArrayT<short>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayT<short>. class TNDArrayT<short>: public TNDArray. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. virtual~TNDArrayT<short>(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); shortAt(const Int_t* idx) const; short&At(const Int_t* idx); shortAt(ULong64_t linidx) const; short&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* ",MatchSource.WIKI,root/html604/TNDArrayT_short_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_short_.html
https://root.cern/root/html604/TNDArrayT_ULong64_t_.html:2048,Availability,error,error,2048,"""""); ULong64_tAt(const Int_t* idx) const; ULong64_t&At(const Int_t* idx); ULong64_tAt(ULong64_t linidx) const; ULong64_t&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTNDArray::GetBin(const Int_t* idx) const; Long64_tTNDArray::GetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tTNDArray::GetNbins() const; Int_tTNDArray::GetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); ",MatchSource.WIKI,root/html604/TNDArrayT_ULong64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_ULong64_t_.html
https://root.cern/root/html604/TNDArrayT_ULong64_t_.html:2132,Availability,error,error,2132,"t(ULong64_t linidx) const; ULong64_t&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTNDArray::GetBin(const Int_t* idx) const; Long64_tTNDArray::GetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tTNDArray::GetNbins() const; Int_tTNDArray::GetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, ",MatchSource.WIKI,root/html604/TNDArrayT_ULong64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_ULong64_t_.html
https://root.cern/root/html604/TNDArrayT_ULong64_t_.html:585,Energy Efficiency,allocate,allocated,585,". TNDArrayT<ULong64_t>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayT<ULong64_t>. class TNDArrayT<ULong64_t>: public TNDArray. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. virtual~TNDArrayT<ULong64_t>(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); ULong64_tAt(const Int_t* idx) const; ULong64_t&At(const Int_t* idx); ULong64_tAt(ULong64_t linidx) const; ULong64_t&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(",MatchSource.WIKI,root/html604/TNDArrayT_ULong64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_ULong64_t_.html
https://root.cern/root/html604/TNDArrayT_ULong64_t_.html:661,Security,access,access,661,". TNDArrayT<ULong64_t>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayT<ULong64_t>. class TNDArrayT<ULong64_t>: public TNDArray. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. virtual~TNDArrayT<ULong64_t>(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); ULong64_tAt(const Int_t* idx) const; ULong64_t&At(const Int_t* idx); ULong64_tAt(ULong64_t linidx) const; ULong64_t&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(",MatchSource.WIKI,root/html604/TNDArrayT_ULong64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_ULong64_t_.html
https://root.cern/root/html604/TNDArrayT_unsigned_int_.html:2072,Availability,error,error,2072,"d intAt(const Int_t* idx) const; unsigned int&At(const Int_t* idx); unsigned intAt(ULong64_t linidx) const; unsigned int&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTNDArray::GetBin(const Int_t* idx) const; Long64_tTNDArray::GetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tTNDArray::GetNbins() const; Int_tTNDArray::GetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); ",MatchSource.WIKI,root/html604/TNDArrayT_unsigned_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_unsigned_int_.html
https://root.cern/root/html604/TNDArrayT_unsigned_int_.html:2156,Availability,error,error,2156,"Long64_t linidx) const; unsigned int&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTNDArray::GetBin(const Int_t* idx) const; Long64_tTNDArray::GetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tTNDArray::GetNbins() const; Int_tTNDArray::GetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, ",MatchSource.WIKI,root/html604/TNDArrayT_unsigned_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_unsigned_int_.html
https://root.cern/root/html604/TNDArrayT_unsigned_int_.html:594,Energy Efficiency,allocate,allocated,594,". TNDArrayT<unsigned int>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayT<unsigned int>. class TNDArrayT<unsigned int>: public TNDArray. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. virtual~TNDArrayT<unsigned int>(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); unsigned intAt(const Int_t* idx) const; unsigned int&At(const Int_t* idx); unsigned intAt(ULong64_t linidx) const; unsigned int&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtu",MatchSource.WIKI,root/html604/TNDArrayT_unsigned_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_unsigned_int_.html
https://root.cern/root/html604/TNDArrayT_unsigned_int_.html:670,Security,access,access,670,". TNDArrayT<unsigned int>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayT<unsigned int>. class TNDArrayT<unsigned int>: public TNDArray. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. virtual~TNDArrayT<unsigned int>(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); unsigned intAt(const Int_t* idx) const; unsigned int&At(const Int_t* idx); unsigned intAt(ULong64_t linidx) const; unsigned int&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtu",MatchSource.WIKI,root/html604/TNDArrayT_unsigned_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_unsigned_int_.html
https://root.cern/root/html604/TNDArrayT_unsigned_long_.html:2080,Availability,error,error,2080,"ngAt(const Int_t* idx) const; unsigned long&At(const Int_t* idx); unsigned longAt(ULong64_t linidx) const; unsigned long&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTNDArray::GetBin(const Int_t* idx) const; Long64_tTNDArray::GetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tTNDArray::GetNbins() const; Int_tTNDArray::GetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); ",MatchSource.WIKI,root/html604/TNDArrayT_unsigned_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_unsigned_long_.html
https://root.cern/root/html604/TNDArrayT_unsigned_long_.html:2164,Availability,error,error,2164,"ong64_t linidx) const; unsigned long&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTNDArray::GetBin(const Int_t* idx) const; Long64_tTNDArray::GetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tTNDArray::GetNbins() const; Int_tTNDArray::GetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, ",MatchSource.WIKI,root/html604/TNDArrayT_unsigned_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_unsigned_long_.html
https://root.cern/root/html604/TNDArrayT_unsigned_long_.html:597,Energy Efficiency,allocate,allocated,597,". TNDArrayT<unsigned long>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayT<unsigned long>. class TNDArrayT<unsigned long>: public TNDArray. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. virtual~TNDArrayT<unsigned long>(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); unsigned longAt(const Int_t* idx) const; unsigned long&At(const Int_t* idx); unsigned longAt(ULong64_t linidx) const; unsigned long&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) cons",MatchSource.WIKI,root/html604/TNDArrayT_unsigned_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_unsigned_long_.html
https://root.cern/root/html604/TNDArrayT_unsigned_long_.html:673,Security,access,access,673,". TNDArrayT<unsigned long>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayT<unsigned long>. class TNDArrayT<unsigned long>: public TNDArray. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. virtual~TNDArrayT<unsigned long>(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); unsigned longAt(const Int_t* idx) const; unsigned long&At(const Int_t* idx); unsigned longAt(ULong64_t linidx) const; unsigned long&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) cons",MatchSource.WIKI,root/html604/TNDArrayT_unsigned_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_unsigned_long_.html
https://root.cern/root/html604/TNDArrayT_unsigned_short_.html:2088,Availability,error,error,2088,"t(const Int_t* idx) const; unsigned short&At(const Int_t* idx); unsigned shortAt(ULong64_t linidx) const; unsigned short&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTNDArray::GetBin(const Int_t* idx) const; Long64_tTNDArray::GetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tTNDArray::GetNbins() const; Int_tTNDArray::GetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); ",MatchSource.WIKI,root/html604/TNDArrayT_unsigned_short_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_unsigned_short_.html
https://root.cern/root/html604/TNDArrayT_unsigned_short_.html:2172,Availability,error,error,2172,"ng64_t linidx) const; unsigned short&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTNDArray::GetBin(const Int_t* idx) const; Long64_tTNDArray::GetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tTNDArray::GetNbins() const; Int_tTNDArray::GetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, ",MatchSource.WIKI,root/html604/TNDArrayT_unsigned_short_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_unsigned_short_.html
https://root.cern/root/html604/TNDArrayT_unsigned_short_.html:600,Energy Efficiency,allocate,allocated,600,". TNDArrayT<unsigned short>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayT<unsigned short>. class TNDArrayT<unsigned short>: public TNDArray. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. virtual~TNDArrayT<unsigned short>(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); unsigned shortAt(const Int_t* idx) const; unsigned short&At(const Int_t* idx); unsigned shortAt(ULong64_t linidx) const; unsigned short&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgf",MatchSource.WIKI,root/html604/TNDArrayT_unsigned_short_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_unsigned_short_.html
https://root.cern/root/html604/TNDArrayT_unsigned_short_.html:676,Security,access,access,676,". TNDArrayT<unsigned short>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArrayT<unsigned short>. class TNDArrayT<unsigned short>: public TNDArray. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods); public:. virtual~TNDArrayT<unsigned short>(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); unsigned shortAt(const Int_t* idx) const; unsigned short&At(const Int_t* idx); unsigned shortAt(ULong64_t linidx) const; unsigned short&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgf",MatchSource.WIKI,root/html604/TNDArrayT_unsigned_short_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNDArrayT_unsigned_short_.html
https://root.cern/root/html604/TNetFile.html:4891,Availability,error,error,4891,"ateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle, const size_t namesize = 0); virtual voidTFile::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTFile::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTFile::DrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTFile::FillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidFlush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*TFile::GetArchive() const; Long64_tTFile::GetArchiveOffset() const; static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(TFileOpenHandle* ",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:4975,Availability,error,error,4975,"t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle, const size_t namesize = 0); virtual voidTFile::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTFile::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTFile::DrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTFile::FillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidFlush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*TFile::GetArchive() const; Long64_tTFile::GetArchiveOffset() const; static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(TFileOpenHandle* handle); Int_tTFile::GetBestBuffer() const; virtual Int_tTDirectoryFile::GetBufferSi",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:27306,Availability,error,error,27306," created via TFile::Open(). TNetFile(const char* url, const char* ftitle, Int_t comp, Bool_t ); Create a TNetFile object. To be used by derived classes, that need; to initialize the TFile base class but not open a connection at this; moment. ~TNetFile(); TNetFile dtor. Send close message and close socket. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Open a remote file. Requires fOption to be set correctly. Int_t SysClose(Int_t fd); Close currently open file. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Return file stat information. The interface and return value is; identical to TSystem::GetPathInfo(). void Close(Option_t* option = """"); Close remote file. void Flush(); Flush file to disk. void Init(Bool_t create); Initialize a TNetFile object. Bool_t IsOpen() const; Retruns kTRUE if file is open, kFALSE otherwise. void Print(Option_t* option) const; Print some info about the net file. void PrintError(const char* where, Int_t err); Print error string depending on error code. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read a list of buffers given in pos[] and len[] and return it in a single; buffer.; Returns kTRUE in case of error. Bool_t WriteBuffer(const char* buf, Int_t len); Wr",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:27332,Availability,error,error,27332," created via TFile::Open(). TNetFile(const char* url, const char* ftitle, Int_t comp, Bool_t ); Create a TNetFile object. To be used by derived classes, that need; to initialize the TFile base class but not open a connection at this; moment. ~TNetFile(); TNetFile dtor. Send close message and close socket. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Open a remote file. Requires fOption to be set correctly. Int_t SysClose(Int_t fd); Close currently open file. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Return file stat information. The interface and return value is; identical to TSystem::GetPathInfo(). void Close(Option_t* option = """"); Close remote file. void Flush(); Flush file to disk. void Init(Bool_t create); Initialize a TNetFile object. Bool_t IsOpen() const; Retruns kTRUE if file is open, kFALSE otherwise. void Print(Option_t* option) const; Print some info about the net file. void PrintError(const char* where, Int_t err); Print error string depending on error code. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read a list of buffers given in pos[] and len[] and return it in a single; buffer.; Returns kTRUE in case of error. Bool_t WriteBuffer(const char* buf, Int_t len); Wr",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:27721,Availability,failure,failure,27721,"de); Open a remote file. Requires fOption to be set correctly. Int_t SysClose(Int_t fd); Close currently open file. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Return file stat information. The interface and return value is; identical to TSystem::GetPathInfo(). void Close(Option_t* option = """"); Close remote file. void Flush(); Flush file to disk. void Init(Bool_t create); Initialize a TNetFile object. Bool_t IsOpen() const; Retruns kTRUE if file is open, kFALSE otherwise. void Print(Option_t* option) const; Print some info about the net file. void PrintError(const char* where, Int_t err); Print error string depending on error code. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read a list of buffers given in pos[] and len[] and return it in a single; buffer.; Returns kTRUE in case of error. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. Int_t Recv(Int_t& status, EMessageTypes& kind); Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading.",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:27906,Availability,error,error,27906,"e interface and return value is; identical to TSystem::GetPathInfo(). void Close(Option_t* option = """"); Close remote file. void Flush(); Flush file to disk. void Init(Bool_t create); Initialize a TNetFile object. Bool_t IsOpen() const; Retruns kTRUE if file is open, kFALSE otherwise. void Print(Option_t* option) const; Print some info about the net file. void PrintError(const char* where, Int_t err); Print error string depending on error code. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read a list of buffers given in pos[] and len[] and return it in a single; buffer.; Returns kTRUE in case of error. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. Int_t Recv(Int_t& status, EMessageTypes& kind); Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server. void Create(const char* url, Option_t* option, Int_t netopt); Create a NetF",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:28055,Availability,error,error,28055,"to disk. void Init(Bool_t create); Initialize a TNetFile object. Bool_t IsOpen() const; Retruns kTRUE if file is open, kFALSE otherwise. void Print(Option_t* option) const; Print some info about the net file. void PrintError(const char* where, Int_t err); Print error string depending on error code. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read a list of buffers given in pos[] and len[] and return it in a single; buffer.; Returns kTRUE in case of error. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. Int_t Recv(Int_t& status, EMessageTypes& kind); Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server. void Create(const char* url, Option_t* option, Int_t netopt); Create a NetFile object. A net file is the same as a TFile; except that it is being accessed via a rootd server. The url; argument must be of the form: root[s|k]:",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:28241,Availability,error,error,28241,"fo about the net file. void PrintError(const char* where, Int_t err); Print error string depending on error code. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read a list of buffers given in pos[] and len[] and return it in a single; buffer.; Returns kTRUE in case of error. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. Int_t Recv(Int_t& status, EMessageTypes& kind); Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server. void Create(const char* url, Option_t* option, Int_t netopt); Create a NetFile object. A net file is the same as a TFile; except that it is being accessed via a rootd server. The url; argument must be of the form: root[s|k]://host.dom.ain/file.root.; When protocol is ""roots"" try using SRP authentication.; When protocol is ""rootk"" try using kerberos5 authentication.; If the file specified in the URL does not",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:28382,Availability,error,error,28382,"); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read a list of buffers given in pos[] and len[] and return it in a single; buffer.; Returns kTRUE in case of error. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. Int_t Recv(Int_t& status, EMessageTypes& kind); Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server. void Create(const char* url, Option_t* option, Int_t netopt); Create a NetFile object. A net file is the same as a TFile; except that it is being accessed via a rootd server. The url; argument must be of the form: root[s|k]://host.dom.ain/file.root.; When protocol is ""roots"" try using SRP authentication.; When protocol is ""rootk"" try using kerberos5 authentication.; If the file specified in the URL does not exist, is not accessable; or can not be created the kZombie bit will be set in the TNetFile; object. Use IsZombie() to see if the file is ac",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:28510,Availability,error,error,28510,"ther ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read a list of buffers given in pos[] and len[] and return it in a single; buffer.; Returns kTRUE in case of error. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. Int_t Recv(Int_t& status, EMessageTypes& kind); Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server. void Create(const char* url, Option_t* option, Int_t netopt); Create a NetFile object. A net file is the same as a TFile; except that it is being accessed via a rootd server. The url; argument must be of the form: root[s|k]://host.dom.ain/file.root.; When protocol is ""roots"" try using SRP authentication.; When protocol is ""rootk"" try using kerberos5 authentication.; If the file specified in the URL does not exist, is not accessable; or can not be created the kZombie bit will be set in the TNetFile; object. Use IsZombie() to see if the file is accessable.; If the remote daemon thinks the file is still connected, while you are; sure this is not the case you can force open the file by preceding th",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:514,Integrability,protocol,protocol,514,". TNetFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TNetFile. class TNetFile: public TFile. TNetFile. A TNetFile is like a normal TFile except that it reads and writes; its data via a rootd server (for more on the rootd daemon see the; source files root/rootd/src/*.cxx). TNetFile file names are in; standard URL format with protocol ""root"" or ""roots"". The following; are valid TNetFile URL's:. roots://hpsalo/files/aap.root; root://hpbrun.cern.ch/root/hsimple.root; root://pcna49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:1632,Integrability,protocol,protocol,1632,"a49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirector",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:1827,Integrability,protocol,protocol,1827,"te file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", ",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:1897,Integrability,protocol,protocol,1897,"/ after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual voidTDirectory",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:1990,Integrability,protocol,protocol,1990,"ll; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual voidTDirectoryFile::Browse(TBrowser* b); virtual voidTDirectoryFile::Build(TFile* motherFile = 0, TDirectory* m",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:23733,Integrability,protocol,protocol,23733,ryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Int_tfNetoptinitial network options (used for ReOpen()); Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; Int_tfProtocolrootd protocol level; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; TSocket*fSocketconnection to rootd server; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; TStringfUserremote user name; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrit,MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:26578,Integrability,message,message,26578,"e open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static atomic<Int_t>TFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNetFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Create a TNetFile object. This is actually done inside Create(), so; for a description of the options and other arguments see Create().; Normally a TNetFile is created via TFile::Open(). TNetFile(const char* url, const char* ftitle, Int_t comp, Bool_t ); Create a TNetFile object. To be used by derived classes, that need; to initialize the TFile base class but not open a connection at this; moment. ~TNetFile(); TNetFile dtor. Send close message and close socket. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Open a remote file. Requires fOption to be set correctly. Int_t SysClose(Int_t fd); Close currently open file. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Return file stat information. The interface and return value is; identical to TSystem::GetPathInfo(). void Close(Option_t* option = """"); Close remote file. void Flush(); Flush file to disk. void Init(Bool_t create); Initialize a TNetFile object. Bool_t IsOpen() const; Retruns kTRUE if file is open, kFALSE otherwise. void Print(Option_t* option) const; Print some info about the net file. void PrintError(const char* where, Int_t err); Print error string depending on error code. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mo",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:26897,Integrability,interface,interface,26897,"size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNetFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Create a TNetFile object. This is actually done inside Create(), so; for a description of the options and other arguments see Create().; Normally a TNetFile is created via TFile::Open(). TNetFile(const char* url, const char* ftitle, Int_t comp, Bool_t ); Create a TNetFile object. To be used by derived classes, that need; to initialize the TFile base class but not open a connection at this; moment. ~TNetFile(); TNetFile dtor. Send close message and close socket. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Open a remote file. Requires fOption to be set correctly. Int_t SysClose(Int_t fd); Close currently open file. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Return file stat information. The interface and return value is; identical to TSystem::GetPathInfo(). void Close(Option_t* option = """"); Close remote file. void Flush(); Flush file to disk. void Init(Bool_t create); Initialize a TNetFile object. Bool_t IsOpen() const; Retruns kTRUE if file is open, kFALSE otherwise. void Print(Option_t* option) const; Print some info about the net file. void PrintError(const char* where, Int_t err); Print error string depending on error code. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuff",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:27319,Integrability,depend,depending,27319," created via TFile::Open(). TNetFile(const char* url, const char* ftitle, Int_t comp, Bool_t ); Create a TNetFile object. To be used by derived classes, that need; to initialize the TFile base class but not open a connection at this; moment. ~TNetFile(); TNetFile dtor. Send close message and close socket. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Open a remote file. Requires fOption to be set correctly. Int_t SysClose(Int_t fd); Close currently open file. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Return file stat information. The interface and return value is; identical to TSystem::GetPathInfo(). void Close(Option_t* option = """"); Close remote file. void Flush(); Flush file to disk. void Init(Bool_t create); Initialize a TNetFile object. Bool_t IsOpen() const; Retruns kTRUE if file is open, kFALSE otherwise. void Print(Option_t* option) const; Print some info about the net file. void PrintError(const char* where, Int_t err); Print error string depending on error code. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read a list of buffers given in pos[] and len[] and return it in a single; buffer.; Returns kTRUE in case of error. Bool_t WriteBuffer(const char* buf, Int_t len); Wr",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:28473,Integrability,message,message,28473,"UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read a list of buffers given in pos[] and len[] and return it in a single; buffer.; Returns kTRUE in case of error. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. Int_t Recv(Int_t& status, EMessageTypes& kind); Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server. void Create(const char* url, Option_t* option, Int_t netopt); Create a NetFile object. A net file is the same as a TFile; except that it is being accessed via a rootd server. The url; argument must be of the form: root[s|k]://host.dom.ain/file.root.; When protocol is ""roots"" try using SRP authentication.; When protocol is ""rootk"" try using kerberos5 authentication.; If the file specified in the URL does not exist, is not accessable; or can not be created the kZombie bit will be set in the TNetFile; object. Use IsZombie() to see if the file is accessable.; If the remote daemon thinks the file is still connecte",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:29077,Integrability,protocol,protocol,29077,"_t* pos, Int_t* len, Int_t nbuf); Read a list of buffers given in pos[] and len[] and return it in a single; buffer.; Returns kTRUE in case of error. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. Int_t Recv(Int_t& status, EMessageTypes& kind); Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server. void Create(const char* url, Option_t* option, Int_t netopt); Create a NetFile object. A net file is the same as a TFile; except that it is being accessed via a rootd server. The url; argument must be of the form: root[s|k]://host.dom.ain/file.root.; When protocol is ""roots"" try using SRP authentication.; When protocol is ""rootk"" try using kerberos5 authentication.; If the file specified in the URL does not exist, is not accessable; or can not be created the kZombie bit will be set in the TNetFile; object. Use IsZombie() to see if the file is accessable.; If the remote daemon thinks the file is still connected, while you are; sure this is not the case you can force open the file by preceding the; option argument with an ""-"", e.g.: ""-recreate"". Do this only; in cases when you are very sure nobody else is using the file.; To bypass the writelock on a file, to allow the reading of a file; that is being written by another process, explicitly specify the; ""+read"" option (""read"" being the default option).; The netopt argument can be used to specify the size of the tcp window in; bytes (for more info see: http://www.psc.edu/networking/perf_tune.html).; The default and minimum tcp window size is 65535 bytes.; If netopt < -1 then |netopt| is the number of parallel s",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:29133,Integrability,protocol,protocol,29133,"ven in pos[] and len[] and return it in a single; buffer.; Returns kTRUE in case of error. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. Int_t Recv(Int_t& status, EMessageTypes& kind); Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server. void Create(const char* url, Option_t* option, Int_t netopt); Create a NetFile object. A net file is the same as a TFile; except that it is being accessed via a rootd server. The url; argument must be of the form: root[s|k]://host.dom.ain/file.root.; When protocol is ""roots"" try using SRP authentication.; When protocol is ""rootk"" try using kerberos5 authentication.; If the file specified in the URL does not exist, is not accessable; or can not be created the kZombie bit will be set in the TNetFile; object. Use IsZombie() to see if the file is accessable.; If the remote daemon thinks the file is still connected, while you are; sure this is not the case you can force open the file by preceding the; option argument with an ""-"", e.g.: ""-recreate"". Do this only; in cases when you are very sure nobody else is using the file.; To bypass the writelock on a file, to allow the reading of a file; that is being written by another process, explicitly specify the; ""+read"" option (""read"" being the default option).; The netopt argument can be used to specify the size of the tcp window in; bytes (for more info see: http://www.psc.edu/networking/perf_tune.html).; The default and minimum tcp window size is 65535 bytes.; If netopt < -1 then |netopt| is the number of parallel sockets that will; be used to connect to rootd. This option ",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:30267,Integrability,depend,depends,30267,"t be created the kZombie bit will be set in the TNetFile; object. Use IsZombie() to see if the file is accessable.; If the remote daemon thinks the file is still connected, while you are; sure this is not the case you can force open the file by preceding the; option argument with an ""-"", e.g.: ""-recreate"". Do this only; in cases when you are very sure nobody else is using the file.; To bypass the writelock on a file, to allow the reading of a file; that is being written by another process, explicitly specify the; ""+read"" option (""read"" being the default option).; The netopt argument can be used to specify the size of the tcp window in; bytes (for more info see: http://www.psc.edu/networking/perf_tune.html).; The default and minimum tcp window size is 65535 bytes.; If netopt < -1 then |netopt| is the number of parallel sockets that will; be used to connect to rootd. This option should be used on fat pipes; (i.e. high bandwidth, high latency links). The ideal number of parallel; sockets depends on the bandwidth*delay product. Generally 5-7 is a good; number.; For a description of the option and other arguments see the TFile ctor.; The preferred interface to this constructor is via TFile::Open(). void Create(TSocket* s, Option_t* option, Int_t netopt); Create a NetFile object using an existing connection (socket s).; Provided for use in TXNetFile.; See:; TNetFile::Create(const char *url, Option_t *option, Int_t netopt); for details about the arguments. Bool_t Matches(const char* url); Return kTRUE if 'url' matches the coordinates of this file.; Check the full URL, including port and FQDN. TNetFile(const TNetFile& ). TNetFile& operator=(const TNetFile& ). TNetFile(const char* url, const char* ftitle, Int_t comp, Bool_t ). Int_t GetErrorCode() const; { return fErrorCode; }. const TUrl * GetEndpointUrl() const; { return &fEndpointUrl; }. » Author: Fons Rademakers 14/08/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last gen",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:30428,Integrability,interface,interface,30428," you are; sure this is not the case you can force open the file by preceding the; option argument with an ""-"", e.g.: ""-recreate"". Do this only; in cases when you are very sure nobody else is using the file.; To bypass the writelock on a file, to allow the reading of a file; that is being written by another process, explicitly specify the; ""+read"" option (""read"" being the default option).; The netopt argument can be used to specify the size of the tcp window in; bytes (for more info see: http://www.psc.edu/networking/perf_tune.html).; The default and minimum tcp window size is 65535 bytes.; If netopt < -1 then |netopt| is the number of parallel sockets that will; be used to connect to rootd. This option should be used on fat pipes; (i.e. high bandwidth, high latency links). The ideal number of parallel; sockets depends on the bandwidth*delay product. Generally 5-7 is a good; number.; For a description of the option and other arguments see the TFile ctor.; The preferred interface to this constructor is via TFile::Open(). void Create(TSocket* s, Option_t* option, Int_t netopt); Create a NetFile object using an existing connection (socket s).; Provided for use in TXNetFile.; See:; TNetFile::Create(const char *url, Option_t *option, Int_t netopt); for details about the arguments. Bool_t Matches(const char* url); Return kTRUE if 'url' matches the coordinates of this file.; Check the full URL, including port and FQDN. TNetFile(const TNetFile& ). TNetFile& operator=(const TNetFile& ). TNetFile(const char* url, const char* ftitle, Int_t comp, Bool_t ). Int_t GetErrorCode() const; { return fErrorCode; }. const TUrl * GetEndpointUrl() const; { return &fEndpointUrl; }. » Author: Fons Rademakers 14/08/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-02 16:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:13483,Performance,cache,cacheDir,13483,"har* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetO",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:13610,Performance,cache,cache,13610,"y::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::Set",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:13729,Performance,cache,cache,13729," voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:21434,Performance,cache,cache,21434,"te; static TFile::EStatusBitsTFile::kWriteError; static TObject::(anonymous)TObject::kZombie. protected:. TArchiveFile*TFile::fArchive!Archive file from which we read this file; Long64_tTFile::fArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*TFile::fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusTFile::fAsyncOpenStatus!Status of an asynchronous open request; Long64_tTFile::fBEGINFirst used byte in file; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tTFile::fBytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TUrlfEndpointUrlURL of realfile (after possible redirection); Int_tfErrorCodeerror code returned by rootd (matching gRootdErrStr); TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsPcmFile!True if the file is a ROOT pcm file.; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPo",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:21496,Performance,cache,cache,21496,"te; static TFile::EStatusBitsTFile::kWriteError; static TObject::(anonymous)TObject::kZombie. protected:. TArchiveFile*TFile::fArchive!Archive file from which we read this file; Long64_tTFile::fArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*TFile::fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusTFile::fAsyncOpenStatus!Status of an asynchronous open request; Long64_tTFile::fBEGINFirst used byte in file; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tTFile::fBytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TUrlfEndpointUrlURL of realfile (after possible redirection); Int_tfErrorCodeerror code returned by rootd (matching gRootdErrStr); TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsPcmFile!True if the file is a ROOT pcm file.; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPo",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:21568,Performance,cache,cache,21568,"te; static TFile::EStatusBitsTFile::kWriteError; static TObject::(anonymous)TObject::kZombie. protected:. TArchiveFile*TFile::fArchive!Archive file from which we read this file; Long64_tTFile::fArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*TFile::fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusTFile::fAsyncOpenStatus!Status of an asynchronous open request; Long64_tTFile::fBEGINFirst used byte in file; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tTFile::fBytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TUrlfEndpointUrlURL of realfile (after possible redirection); Int_tfErrorCodeerror code returned by rootd (matching gRootdErrStr); TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsPcmFile!True if the file is a ROOT pcm file.; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPo",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:23492,Performance,cache,cache,23492,,MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:23811,Performance,cache,cache,23811,therpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Int_tfNetoptinitial network options (used for ReOpen()); Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; Int_tfProtocolrootd protocol level; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; TSocket*fSocketconnection to rootd server; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; TStringfUserremote user name; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory,MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:25280,Performance,cache,cache,25280,"on of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; TSocket*fSocketconnection to rootd server; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; TStringfUserremote user name; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static atomic<Long64_t>TFile::fgBytesReadNumber of bytes read by all TFile objects; static atomic<Long64_t>TFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static atomic<Long64_t>TFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static atomic<Int_t>TFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:25310,Performance,cache,cached,25310,"on of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; TSocket*fSocketconnection to rootd server; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; TStringfUserremote user name; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static atomic<Long64_t>TFile::fgBytesReadNumber of bytes read by all TFile objects; static atomic<Long64_t>TFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static atomic<Long64_t>TFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static atomic<Int_t>TFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:30213,Performance,latency,latency,30213,"ed in the URL does not exist, is not accessable; or can not be created the kZombie bit will be set in the TNetFile; object. Use IsZombie() to see if the file is accessable.; If the remote daemon thinks the file is still connected, while you are; sure this is not the case you can force open the file by preceding the; option argument with an ""-"", e.g.: ""-recreate"". Do this only; in cases when you are very sure nobody else is using the file.; To bypass the writelock on a file, to allow the reading of a file; that is being written by another process, explicitly specify the; ""+read"" option (""read"" being the default option).; The netopt argument can be used to specify the size of the tcp window in; bytes (for more info see: http://www.psc.edu/networking/perf_tune.html).; The default and minimum tcp window size is 65535 bytes.; If netopt < -1 then |netopt| is the number of parallel sockets that will; be used to connect to rootd. This option should be used on fat pipes; (i.e. high bandwidth, high latency links). The ideal number of parallel; sockets depends on the bandwidth*delay product. Generally 5-7 is a good; number.; For a description of the option and other arguments see the TFile ctor.; The preferred interface to this constructor is via TFile::Open(). void Create(TSocket* s, Option_t* option, Int_t netopt); Create a NetFile object using an existing connection (socket s).; Provided for use in TXNetFile.; See:; TNetFile::Create(const char *url, Option_t *option, Int_t netopt); for details about the arguments. Bool_t Matches(const char* url); Return kTRUE if 'url' matches the coordinates of this file.; Check the full URL, including port and FQDN. TNetFile(const TNetFile& ). TNetFile& operator=(const TNetFile& ). TNetFile(const char* url, const char* ftitle, Int_t comp, Bool_t ). Int_t GetErrorCode() const; { return fErrorCode; }. const TUrl * GetEndpointUrl() const; { return &fEndpointUrl; }. » Author: Fons Rademakers 14/08/97 » Copyright (C) 1995-2000, Rene Brun and Fon",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:1909,Safety,safe,safe,1909,"/ after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual voidTDirectory",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:14686,Safety,timeout,timeout,14686,"dTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tTFile::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTFile::SumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; I",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:1188,Security,password,password,1188,"iption; function members; data members; class charts. ROOT; » NET; » NET; » TNetFile. class TNetFile: public TFile. TNetFile. A TNetFile is like a normal TFile except that it reads and writes; its data via a rootd server (for more on the rootd daemon see the; source files root/rootd/src/*.cxx). TNetFile file names are in; standard URL format with protocol ""root"" or ""roots"". The following; are valid TNetFile URL's:. roots://hpsalo/files/aap.root; root://hpbrun.cern.ch/root/hsimple.root; root://pcna49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by ha",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:1562,Security,authenticat,authenticate,1562,"URL's:. roots://hpsalo/files/aap.root; root://hpbrun.cern.ch/root/hsimple.root; root://pcna49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtua",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:1667,Security,secur,secure,1667,"a49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirector",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:1714,Security,secur,secure,1714,"0.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:1849,Security,password,passwords,1849,"te file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", ",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:1932,Security,secur,security,1932,"/ after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual voidTDirectory",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:1941,Security,attack,attacks,1941,"/ after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual voidTDirectory",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:2051,Security,authenticat,authentication,2051,"ll; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual voidTDirectoryFile::Browse(TBrowser* b); virtual voidTDirectoryFile::Build(TFile* motherFile = 0, TDirectory* m",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:27405,Security,access,access,27405,"t. To be used by derived classes, that need; to initialize the TFile base class but not open a connection at this; moment. ~TNetFile(); TNetFile dtor. Send close message and close socket. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Open a remote file. Requires fOption to be set correctly. Int_t SysClose(Int_t fd); Close currently open file. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Return file stat information. The interface and return value is; identical to TSystem::GetPathInfo(). void Close(Option_t* option = """"); Close remote file. void Flush(); Flush file to disk. void Init(Bool_t create); Initialize a TNetFile object. Bool_t IsOpen() const; Retruns kTRUE if file is open, kFALSE otherwise. void Print(Option_t* option) const; Print some info about the net file. void PrintError(const char* where, Int_t err); Print error string depending on error code. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read a list of buffers given in pos[] and len[] and return it in a single; buffer.; Returns kTRUE in case of error. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. Int_t Recv(Int_t& status, EM",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:28967,Security,access,accessed,28967,"pos, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read a list of buffers given in pos[] and len[] and return it in a single; buffer.; Returns kTRUE in case of error. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. Int_t Recv(Int_t& status, EMessageTypes& kind); Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server. void Create(const char* url, Option_t* option, Int_t netopt); Create a NetFile object. A net file is the same as a TFile; except that it is being accessed via a rootd server. The url; argument must be of the form: root[s|k]://host.dom.ain/file.root.; When protocol is ""roots"" try using SRP authentication.; When protocol is ""rootk"" try using kerberos5 authentication.; If the file specified in the URL does not exist, is not accessable; or can not be created the kZombie bit will be set in the TNetFile; object. Use IsZombie() to see if the file is accessable.; If the remote daemon thinks the file is still connected, while you are; sure this is not the case you can force open the file by preceding the; option argument with an ""-"", e.g.: ""-recreate"". Do this only; in cases when you are very sure nobody else is using the file.; To bypass the writelock on a file, to allow the reading of a file; that is being written by another process, explicitly specify the; ""+read"" option (""read"" being the default option).; The netopt argument can be used to specify the size of the tcp window in; bytes (for more info see: http://www.psc",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:29111,Security,authenticat,authentication,29111,"_t* pos, Int_t* len, Int_t nbuf); Read a list of buffers given in pos[] and len[] and return it in a single; buffer.; Returns kTRUE in case of error. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. Int_t Recv(Int_t& status, EMessageTypes& kind); Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server. void Create(const char* url, Option_t* option, Int_t netopt); Create a NetFile object. A net file is the same as a TFile; except that it is being accessed via a rootd server. The url; argument must be of the form: root[s|k]://host.dom.ain/file.root.; When protocol is ""roots"" try using SRP authentication.; When protocol is ""rootk"" try using kerberos5 authentication.; If the file specified in the URL does not exist, is not accessable; or can not be created the kZombie bit will be set in the TNetFile; object. Use IsZombie() to see if the file is accessable.; If the remote daemon thinks the file is still connected, while you are; sure this is not the case you can force open the file by preceding the; option argument with an ""-"", e.g.: ""-recreate"". Do this only; in cases when you are very sure nobody else is using the file.; To bypass the writelock on a file, to allow the reading of a file; that is being written by another process, explicitly specify the; ""+read"" option (""read"" being the default option).; The netopt argument can be used to specify the size of the tcp window in; bytes (for more info see: http://www.psc.edu/networking/perf_tune.html).; The default and minimum tcp window size is 65535 bytes.; If netopt < -1 then |netopt| is the number of parallel s",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:29173,Security,authenticat,authentication,29173,"ven in pos[] and len[] and return it in a single; buffer.; Returns kTRUE in case of error. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. Int_t Recv(Int_t& status, EMessageTypes& kind); Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server. void Create(const char* url, Option_t* option, Int_t netopt); Create a NetFile object. A net file is the same as a TFile; except that it is being accessed via a rootd server. The url; argument must be of the form: root[s|k]://host.dom.ain/file.root.; When protocol is ""roots"" try using SRP authentication.; When protocol is ""rootk"" try using kerberos5 authentication.; If the file specified in the URL does not exist, is not accessable; or can not be created the kZombie bit will be set in the TNetFile; object. Use IsZombie() to see if the file is accessable.; If the remote daemon thinks the file is still connected, while you are; sure this is not the case you can force open the file by preceding the; option argument with an ""-"", e.g.: ""-recreate"". Do this only; in cases when you are very sure nobody else is using the file.; To bypass the writelock on a file, to allow the reading of a file; that is being written by another process, explicitly specify the; ""+read"" option (""read"" being the default option).; The netopt argument can be used to specify the size of the tcp window in; bytes (for more info see: http://www.psc.edu/networking/perf_tune.html).; The default and minimum tcp window size is 65535 bytes.; If netopt < -1 then |netopt| is the number of parallel sockets that will; be used to connect to rootd. This option ",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:29246,Security,access,accessable,29246,"Buffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. Int_t Recv(Int_t& status, EMessageTypes& kind); Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server. void Create(const char* url, Option_t* option, Int_t netopt); Create a NetFile object. A net file is the same as a TFile; except that it is being accessed via a rootd server. The url; argument must be of the form: root[s|k]://host.dom.ain/file.root.; When protocol is ""roots"" try using SRP authentication.; When protocol is ""rootk"" try using kerberos5 authentication.; If the file specified in the URL does not exist, is not accessable; or can not be created the kZombie bit will be set in the TNetFile; object. Use IsZombie() to see if the file is accessable.; If the remote daemon thinks the file is still connected, while you are; sure this is not the case you can force open the file by preceding the; option argument with an ""-"", e.g.: ""-recreate"". Do this only; in cases when you are very sure nobody else is using the file.; To bypass the writelock on a file, to allow the reading of a file; that is being written by another process, explicitly specify the; ""+read"" option (""read"" being the default option).; The netopt argument can be used to specify the size of the tcp window in; bytes (for more info see: http://www.psc.edu/networking/perf_tune.html).; The default and minimum tcp window size is 65535 bytes.; If netopt < -1 then |netopt| is the number of parallel sockets that will; be used to connect to rootd. This option should be used on fat pipes; (i.e. high bandwidth, high latency links). The ideal number of parallel; s",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:29370,Security,access,accessable,29370," Returns kTRUE in case of error. Int_t Recv(Int_t& status, EMessageTypes& kind); Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server. void Create(const char* url, Option_t* option, Int_t netopt); Create a NetFile object. A net file is the same as a TFile; except that it is being accessed via a rootd server. The url; argument must be of the form: root[s|k]://host.dom.ain/file.root.; When protocol is ""roots"" try using SRP authentication.; When protocol is ""rootk"" try using kerberos5 authentication.; If the file specified in the URL does not exist, is not accessable; or can not be created the kZombie bit will be set in the TNetFile; object. Use IsZombie() to see if the file is accessable.; If the remote daemon thinks the file is still connected, while you are; sure this is not the case you can force open the file by preceding the; option argument with an ""-"", e.g.: ""-recreate"". Do this only; in cases when you are very sure nobody else is using the file.; To bypass the writelock on a file, to allow the reading of a file; that is being written by another process, explicitly specify the; ""+read"" option (""read"" being the default option).; The netopt argument can be used to specify the size of the tcp window in; bytes (for more info see: http://www.psc.edu/networking/perf_tune.html).; The default and minimum tcp window size is 65535 bytes.; If netopt < -1 then |netopt| is the number of parallel sockets that will; be used to connect to rootd. This option should be used on fat pipes; (i.e. high bandwidth, high latency links). The ideal number of parallel; sockets depends on the bandwidth*delay product. Generally 5-7 is a good; number.; For a descriptio",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFile.html:1250,Testability,log,login,1250,"e is like a normal TFile except that it reads and writes; its data via a rootd server (for more on the rootd daemon see the; source files root/rootd/src/*.cxx). TNetFile file names are in; standard URL format with protocol ""root"" or ""roots"". The following; are valid TNetFile URL's:. roots://hpsalo/files/aap.root; root://hpbrun.cern.ch/root/hsimple.root; root://pcna49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (M",MatchSource.WIKI,root/html604/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFile.html
https://root.cern/root/html604/TNetFileStager.html:1348,Availability,error,error,1348," virtual~TNetFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; st",MatchSource.WIKI,root/html604/TNetFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFileStager.html
https://root.cern/root/html604/TNetFileStager.html:1432,Availability,error,error,1432,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TStringTFileStager::GetPathName(TObject* o); virtual TList*TFileStager::GetStaged(TCollection* pathlist); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgf",MatchSource.WIKI,root/html604/TNetFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFileStager.html
https://root.cern/root/html604/TNetFileStager.html:7332,Availability,error,error,7332,"tatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TStringfPrefixprefix to prepend to requests; TNetSystem*fSysteminstance of the admin interface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNetFileStager(const char* stager = """"); Constructor. Init a TNetSystem instance to the remote rootd. ~TNetFileStager(); Destructor. Bool_t IsStaged(const char* path); Check if the file defined by 'path' is ready to be used. void GetPrefix(const char* url, TString& pfx); Isolate prefix in url. void Print(Option_t* option = """") const; Print basic info about this stager. Int_t Locate(const char* path, TString& endpath); Get actual end-point url for a path; Returns 0 in case of success and 1 if any error occured. Bool_t Matches(const char* s); Returns kTRUE if stager 's' is compatible with current stager.; Avoids multiple instantiations of the potentially the same TNetSystem. TNetFileStager(const char* stager = """"). Bool_t IsValid() const; { return (fSystem ? kTRUE : kFALSE); }. » Author: G. Ganis Feb 2011 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/netx:$Id$ » Last generated: 2015-09-08 17:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNetFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFileStager.html
https://root.cern/root/html604/TNetFileStager.html:6729,Integrability,interface,interface,6729,"t va) const; voidTObject::MakeZombie(). private:. static voidGetPrefix(const char* url, TString& pfx). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TStringfPrefixprefix to prepend to requests; TNetSystem*fSysteminstance of the admin interface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNetFileStager(const char* stager = """"); Constructor. Init a TNetSystem instance to the remote rootd. ~TNetFileStager(); Destructor. Bool_t IsStaged(const char* path); Check if the file defined by 'path' is ready to be used. void GetPrefix(const char* url, TString& pfx); Isolate prefix in url. void Print(Option_t* option = """") const; Print basic info about this stager. Int_t Locate(const char* path, TString& endpath); Get actual end-point url for a path; Returns 0 in case of success and 1 if any error occured. Bool_t Matches(const char* s); Returns kTRUE if stager 's' is compatible with current stager.; Avoids multiple instantiations of the potentially the same TNetSystem. TNetFileStager(const char* stager = """"). Bool_t IsValid() const; { return (fSystem ? kTRUE : kFALSE); }. » Author: G. Ganis Feb 2011 » Copyright (C) 1995-2002, Rene Brun and Fons",MatchSource.WIKI,root/html604/TNetFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetFileStager.html
https://root.cern/root/html604/TNetSystem.html:5325,Availability,error,error,5325,"ual Bool_tConsistentWith(const char* path, void* dirptr); virtual voidTNamed::Copy(TObject& named) const; virtual intTSystem::CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidTSystem::DispatchOneEvent(Bool_t pendingOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; char*TSystem::DynamicPathName(const char* lib, Bool_t quiet = kFALSE); virtual Func_tTSystem::DynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tTSystem::Exec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTSystem::Exit(int code, Bool_t mode = kTRUE); virtual voidTSystem::ExitLoop(); virtual Bool_tTSystem::ExpandPathName(TString& path); virtual char*TSystem::ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*TSystem::FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); virtual const char*TSystem::FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp = 0); virtual TSystem::EAclicModeTSystem::GetAclicMode() const; virtual Int_tTSystem::GetAclicProperties() const; voidTSystem::GetBeepDefaults(Int_t& freq, Int_t& dur",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:5409,Availability,error,error,5409,"Object& named) const; virtual intTSystem::CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidTSystem::DispatchOneEvent(Bool_t pendingOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; char*TSystem::DynamicPathName(const char* lib, Bool_t quiet = kFALSE); virtual Func_tTSystem::DynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tTSystem::Exec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTSystem::Exit(int code, Bool_t mode = kTRUE); virtual voidTSystem::ExitLoop(); virtual Bool_tTSystem::ExpandPathName(TString& path); virtual char*TSystem::ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*TSystem::FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); virtual const char*TSystem::FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp = 0); virtual TSystem::EAclicModeTSystem::GetAclicMode() const; virtual Int_tTSystem::GetAclicProperties() const; voidTSystem::GetBeepDefaults(Int_t& freq, Int_t& duration) const; virtual const char*TSystem::GetBuildArch() const; virtual const char*T",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:14408,Availability,mask,mask,14408,"ct::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSystem::Select(TList* active, Long_t timeout); virtual Int_tTSystem::Select(TFileHandler* fh, Long_t timeout); virtual intTSystem::SendBuf(int sock, const void* buffer, int length); virtual intTSystem::SendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidTSystem::SetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTSystem::SetDynamicPath(const char* pathname); virtual voidTSystem::Setenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tTSystem::SetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs(const char* linkedLibs); virtual voidTSystem::SetMakeExe(const char* directives); virtual voidTSystem::SetMakeSharedLib(const char* directives); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTSystem::SetObjExt(const char* objExt); virtual voidTSystem::SetProgname(const char* name); virtual intTSystem::SetSockOpt(int sock, int kind, int val); virtual voidTSystem::SetSoExt(const char* soExt); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTSystem::ShowOutput(RedirectHandle_t* h); virtual Int_tTNamed::Sizeof() const; virtual voidTSystem::Sleep(UInt_t milliSec)",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:16181,Availability,mask,mask,16181,"voidTSystem::SetObjExt(const char* objExt); virtual voidTSystem::SetProgname(const char* name); virtual intTSystem::SetSockOpt(int sock, int kind, int val); virtual voidTSystem::SetSoExt(const char* soExt); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTSystem::ShowOutput(RedirectHandle_t* h); virtual Int_tTNamed::Sizeof() const; virtual voidTSystem::Sleep(UInt_t milliSec); virtual TStringTSystem::SplitAclicMode(const char* filename, TString& mode, TString& args, TString& io) const; virtual voidTSystem::StackTrace(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual intTSystem::Symlink(const char* from, const char* to); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTSystem::Syslog(ELogLevel level, const char* mess); virtual const char*TSystem::TempDirectory() const; virtual FILE*TSystem::TempFileName(TString& base, const char* dir = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TNetSystem(Bool_t ftpowner = kTRUE); TNetSystem(const char* url, Bool_t ftpowner = kTRUE); virtual intTSystem::Umask(Int_t mask); virtual const char*TSystem::UnixPathName(const char* unixpathname); virtual intUnlink(const char* path); virtual voidTSystem::Unload(const char* module); virtual voidTSystem::Unsetenv(const char* name); virtual voidTObject::UseCurrentStyle(); virtual intTSystem::Utime(const char* file, Long_t modtime, Long_t actime); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual char*TSystem::Which(const char* search, const char* file, EAccessMode mode = kFileExists); virtual const char*TSystem::WorkingDirectory(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:20733,Availability,mask,mask,20733," alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Bool_tfIsLocalTRUE if the path points to this host; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfLocalPrefixif fIsLocal, prefix to be prepend locally; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with wr",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:20780,Availability,mask,mask,20780," alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Bool_tfIsLocalTRUE if the path points to this host; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfLocalPrefixif fIsLocal, prefix to be prepend locally; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with wr",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:20861,Availability,mask,masks,20861," alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Bool_tfIsLocalTRUE if the path points to this host; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfLocalPrefixif fIsLocal, prefix to be prepend locally; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with wr",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:23022,Availability,error,error,23022,"unction documentation; TNetSystem(Bool_t ftpowner = kTRUE); Create helper class that allows directory access via rootd.; Use ftpowner = TRUE (default) if this instance is responsible; for cleaning of the underlying TFTP connection; this allows; to have control on the order of the final cleaning. TNetSystem(const char* url, Bool_t ftpowner = kTRUE); Create helper class that allows directory access via rootd.; Use ftpowner = TRUE (default) if this instance is responsible; for cleaning of the underlying TFTP connection; this allows; to have control on the order of the final cleaning. void InitRemoteEntity(const char* url); Parse and save coordinates of the remote entity (user, host, port, ...). void Create(const char* url, TSocket* sock = 0); Create a TNetSystem object. ~TNetSystem(); Destructor. Int_t MakeDirectory(const char* name); Make a directory via rootd. void * OpenDirectory(const char* name); Open a directory via rfiod. Returns an opaque pointer to a dir; structure. Returns 0 in case of error. void FreeDirectory(void* dirp = 0); Free directory via rootd. const char * GetDirEntry(void* dirp = 0); Get directory entry via rootd. Returns 0 in case no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. Bool_t ConsistentWith(const char* path, void* dirptr); Check consistency of this helper with the one required; by 'path' or 'dirptr'. Int_t Unlink(const char* path); Remove a path. TNetFile& operator=(const TNetSystem& ). TNetSystem(const TNetSystem& ). void * GetDirPtr() const; { return fDirp; }. » Author: Fons Rademakers 14/08/97 » Copyright ",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:522,Integrability,protocol,protocol,522,". TNetSystem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TNetSystem. class TNetSystem: public TSystem. TNetFile. A TNetFile is like a normal TFile except that it reads and writes; its data via a rootd server (for more on the rootd daemon see the; source files root/rootd/src/*.cxx). TNetFile file names are in; standard URL format with protocol ""root"" or ""roots"". The following; are valid TNetFile URL's:. roots://hpsalo/files/aap.root; root://hpbrun.cern.ch/root/hsimple.root; root://pcna49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the pro",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:1640,Integrability,protocol,protocol,1640,"a49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); v",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:1835,Integrability,protocol,protocol,1835,"te file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignal",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:1905,Integrability,protocol,protocol,1905,"/ after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); v",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:1998,Integrability,protocol,protocol,1998,"ll; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t ",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:11465,Integrability,protocol,protocol,11465,"al Bool_tTSystem::IsPathLocal(const char* path); virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual intTSystem::Link(const char* from, const char* to); virtual voidTSystem::ListLibraries(const char* regexp = """"); virtual voidTSystem::ListSymbols(const char* module, const char* re = """"); virtual intTSystem::Load(const char* module, const char* entry = """", Bool_t system = kFALSE); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tMakeDirectory(const char* name); voidTObject::MayNotUse(const char* method) const; virtual intTSystem::mkdir(const char* name, Bool_t recursive = kFALSE); virtual Long_tTSystem::NextTimeOut(Bool_t mode); virtual Bool_tTObject::Notify(); virtual voidTSystem::NotifyApplicationCreated(); virtual TTimeTSystem::Now(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual intTSystem::OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); virtual void*OpenDirectory(const char* name); virtual voidTSystem::Openlog(const char* name, Int_t options, ELogFacility facility); virtual FILE*TSystem::OpenPipe(const char* command, const char* mode); voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual const char*TSystem::PrependPathName(const char* dir, TString& name); virtual voidTNamed::Print(Option_t* option = """") const; virtual Bool_tTSystem::ProcessEvents(); const char*TSystem::pwd(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual intTSystem::RecvBuf(int sock, ",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:18994,Modifiability,config,configure,18994,t; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TSystem::EAclicModeTSystem::kOpt; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TSystem::EAclicModeTSystem::fAclicModeWhether the compilation should be done debug or opt; Int_tTSystem::fAclicPropertiesVarious boolean flag for change ACLiC's behavior.; Int_tTSystem::fBeepDurationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Bool_tfIsLocalTRUE if the path points to this host; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault ,MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:19611,Performance,optimiz,optimized,19611,"pDurationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Bool_tfIsLocalTRUE if the path points to this host; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfLocalPrefixif fIsLocal, prefix to be prepend locally; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of f",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:20349,Performance,cache,cache,20349,"pDurationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Bool_tfIsLocalTRUE if the path points to this host; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfLocalPrefixif fIsLocal, prefix to be prepend locally; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of f",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:1917,Safety,safe,safe,1917,"/ after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); v",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:13517,Safety,timeout,timeout,13517,"Raw(int sock, void* buffer, int length, int flag); virtual Int_tTSystem::RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*TSystem::RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*TSystem::RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*TSystem::RemoveTimer(TTimer* t); virtual intTSystem::Rename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidTSystem::ResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidTSystem::ResetSignals(); virtual voidTSystem::ResetTimer(TTimer*); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSystem::Select(TList* active, Long_t timeout); virtual Int_tTSystem::Select(TFileHandler* fh, Long_t timeout); virtual intTSystem::SendBuf(int sock, const void* buffer, int length); virtual intTSystem::SendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidTSystem::SetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTSystem::SetDynamicPath(const char* pathname); virtual voidTSystem::Setenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tTSystem::SetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkd",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:13581,Safety,timeout,timeout,13581,"TSystem::RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*TSystem::RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*TSystem::RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*TSystem::RemoveTimer(TTimer* t); virtual intTSystem::Rename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidTSystem::ResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidTSystem::ResetSignals(); virtual voidTSystem::ResetTimer(TTimer*); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSystem::Select(TList* active, Long_t timeout); virtual Int_tTSystem::Select(TFileHandler* fh, Long_t timeout); virtual intTSystem::SendBuf(int sock, const void* buffer, int length); virtual intTSystem::SendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidTSystem::SetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTSystem::SetDynamicPath(const char* pathname); virtual voidTSystem::Setenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tTSystem::SetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:1196,Security,password,password,1196,"; function members; data members; class charts. ROOT; » NET; » NET; » TNetSystem. class TNetSystem: public TSystem. TNetFile. A TNetFile is like a normal TFile except that it reads and writes; its data via a rootd server (for more on the rootd daemon see the; source files root/rootd/src/*.cxx). TNetFile file names are in; standard URL format with protocol ""root"" or ""roots"". The following; are valid TNetFile URL's:. roots://hpsalo/files/aap.root; root://hpbrun.cern.ch/root/hsimple.root; root://pcna49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by ha",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:1570,Security,authenticat,authenticate,1570,"URL's:. roots://hpsalo/files/aap.root; root://hpbrun.cern.ch/root/hsimple.root; root://pcna49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::Add",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:1675,Security,secur,secure,1675,"a49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); v",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:1722,Security,secur,secure,1722,"0.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSy",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:1857,Security,password,passwords,1857,"te file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignal",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:1940,Security,secur,security,1940,"/ after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); v",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:1949,Security,attack,attacks,1949,"/ after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); v",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:2059,Security,authenticat,authentication,2059,"ll; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t ",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:19720,Security,access,access,19720,"pDurationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Bool_tfIsLocalTRUE if the path points to this host; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfLocalPrefixif fIsLocal, prefix to be prepend locally; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of f",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:22116,Security,access,access,22116,"d events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. private:. Bool_tfDirtrue if a directory is open remotely; void*fDirpdirectory handler; TFTP*fFTPConnection to rootd; Bool_tfFTPOwnerTrue if owner of the FTP instance; TStringfHostRemote host; Int_tfPortRemote port; TStringfUserRemote user. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNetSystem(Bool_t ftpowner = kTRUE); Create helper class that allows directory access via rootd.; Use ftpowner = TRUE (default) if this instance is responsible; for cleaning of the underlying TFTP connection; this allows; to have control on the order of the final cleaning. TNetSystem(const char* url, Bool_t ftpowner = kTRUE); Create helper class that allows directory access via rootd.; Use ftpowner = TRUE (default) if this instance is responsible; for cleaning of the underlying TFTP connection; this allows; to have control on the order of the final cleaning. void InitRemoteEntity(const char* url); Parse and save coordinates of the remote entity (user, host, port, ...). void Create(const char* url, TSocket* sock = 0); Create a TNetSystem object. ~TNetSystem(); Destructor. Int_t MakeDirectory(const char* name); Make a directory via rootd. void * OpenDirectory(const char* name); Open a directory via rfiod. Returns an opaque pointer to a dir; structure. Returns 0 in case of error. void FreeDirectory(void* dirp = 0); Free dir",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:22407,Security,access,access,22407,", etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. private:. Bool_tfDirtrue if a directory is open remotely; void*fDirpdirectory handler; TFTP*fFTPConnection to rootd; Bool_tfFTPOwnerTrue if owner of the FTP instance; TStringfHostRemote host; Int_tfPortRemote port; TStringfUserRemote user. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNetSystem(Bool_t ftpowner = kTRUE); Create helper class that allows directory access via rootd.; Use ftpowner = TRUE (default) if this instance is responsible; for cleaning of the underlying TFTP connection; this allows; to have control on the order of the final cleaning. TNetSystem(const char* url, Bool_t ftpowner = kTRUE); Create helper class that allows directory access via rootd.; Use ftpowner = TRUE (default) if this instance is responsible; for cleaning of the underlying TFTP connection; this allows; to have control on the order of the final cleaning. void InitRemoteEntity(const char* url); Parse and save coordinates of the remote entity (user, host, port, ...). void Create(const char* url, TSocket* sock = 0); Create a TNetSystem object. ~TNetSystem(); Destructor. Int_t MakeDirectory(const char* name); Make a directory via rootd. void * OpenDirectory(const char* name); Open a directory via rfiod. Returns an opaque pointer to a dir; structure. Returns 0 in case of error. void FreeDirectory(void* dirp = 0); Free directory via rootd. const char * GetDirEntry(void* dirp = 0); Get directory entry via rootd. Returns 0 in case no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function retu",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:23517,Security,access,access,23517,"der of the final cleaning. TNetSystem(const char* url, Bool_t ftpowner = kTRUE); Create helper class that allows directory access via rootd.; Use ftpowner = TRUE (default) if this instance is responsible; for cleaning of the underlying TFTP connection; this allows; to have control on the order of the final cleaning. void InitRemoteEntity(const char* url); Parse and save coordinates of the remote entity (user, host, port, ...). void Create(const char* url, TSocket* sock = 0); Create a TNetSystem object. ~TNetSystem(); Destructor. Int_t MakeDirectory(const char* name); Make a directory via rootd. void * OpenDirectory(const char* name); Open a directory via rfiod. Returns an opaque pointer to a dir; structure. Returns 0 in case of error. void FreeDirectory(void* dirp = 0); Free directory via rootd. const char * GetDirEntry(void* dirp = 0); Get directory entry via rootd. Returns 0 in case no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. Bool_t ConsistentWith(const char* path, void* dirptr); Check consistency of this helper with the one required; by 'path' or 'dirptr'. Int_t Unlink(const char* path); Remove a path. TNetFile& operator=(const TNetSystem& ). TNetSystem(const TNetSystem& ). void * GetDirPtr() const; { return fDirp; }. » Author: Fons Rademakers 14/08/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-02 16:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:23551,Security,access,access,23551,"der of the final cleaning. TNetSystem(const char* url, Bool_t ftpowner = kTRUE); Create helper class that allows directory access via rootd.; Use ftpowner = TRUE (default) if this instance is responsible; for cleaning of the underlying TFTP connection; this allows; to have control on the order of the final cleaning. void InitRemoteEntity(const char* url); Parse and save coordinates of the remote entity (user, host, port, ...). void Create(const char* url, TSocket* sock = 0); Create a TNetSystem object. ~TNetSystem(); Destructor. Int_t MakeDirectory(const char* name); Make a directory via rootd. void * OpenDirectory(const char* name); Open a directory via rfiod. Returns an opaque pointer to a dir; structure. Returns 0 in case of error. void FreeDirectory(void* dirp = 0); Free directory via rootd. const char * GetDirEntry(void* dirp = 0); Get directory entry via rootd. Returns 0 in case no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. Bool_t ConsistentWith(const char* path, void* dirptr); Check consistency of this helper with the one required; by 'path' or 'dirptr'. Int_t Unlink(const char* path); Remove a path. TNetFile& operator=(const TNetSystem& ). TNetSystem(const TNetSystem& ). void * GetDirPtr() const; { return fDirp; }. » Author: Fons Rademakers 14/08/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-02 16:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:23598,Security,access,access,23598,"der of the final cleaning. TNetSystem(const char* url, Bool_t ftpowner = kTRUE); Create helper class that allows directory access via rootd.; Use ftpowner = TRUE (default) if this instance is responsible; for cleaning of the underlying TFTP connection; this allows; to have control on the order of the final cleaning. void InitRemoteEntity(const char* url); Parse and save coordinates of the remote entity (user, host, port, ...). void Create(const char* url, TSocket* sock = 0); Create a TNetSystem object. ~TNetSystem(); Destructor. Int_t MakeDirectory(const char* name); Make a directory via rootd. void * OpenDirectory(const char* name); Open a directory via rfiod. Returns an opaque pointer to a dir; structure. Returns 0 in case of error. void FreeDirectory(void* dirp = 0); Free directory via rootd. const char * GetDirEntry(void* dirp = 0); Get directory entry via rootd. Returns 0 in case no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. Bool_t ConsistentWith(const char* path, void* dirptr); Check consistency of this helper with the one required; by 'path' or 'dirptr'. Int_t Unlink(const char* path); Remove a path. TNetFile& operator=(const TNetSystem& ). TNetSystem(const TNetSystem& ). void * GetDirPtr() const; { return fDirp; }. » Author: Fons Rademakers 14/08/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-02 16:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetSystem.html:1258,Testability,log,login,1258,"e is like a normal TFile except that it reads and writes; its data via a rootd server (for more on the rootd daemon see the; source files root/rootd/src/*.cxx). TNetFile file names are in; standard URL format with protocol ""root"" or ""roots"". The following; are valid TNetFile URL's:. roots://hpsalo/files/aap.root; root://hpbrun.cern.ch/root/hsimple.root; root://pcna49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (M",MatchSource.WIKI,root/html604/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetSystem.html
https://root.cern/root/html604/TNetXNGFile.html:3023,Availability,error,error,3023,"ateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle, const size_t namesize = 0); virtual voidTFile::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTFile::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTFile::DrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTFile::FillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidFlush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*TFile::GetArchive() const; Long64_tTFile::GetArchiveOffset() const; static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(TFileOpenHandle* ",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:3107,Availability,error,error,3107,"t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle, const size_t namesize = 0); virtual voidTFile::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTFile::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTFile::DrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTFile::FillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidFlush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*TFile::GetArchive() const; Long64_tTFile::GetArchiveOffset() const; static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(TFileOpenHandle* handle); Int_tTFile::GetBestBuffer() const; virtual Int_tTDirectoryFile::GetBufferSi",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:25521,Availability,failure,failure,25521,"l file access mode; param title: title of the file (shown by ROOT browser); param compress: compression level and algorithm; param netopt: TCP window size in bytes (unused); param parallelopen: open asynchronously. ~TNetXNGFile(); Destructor. void Init(Bool_t create); Initialize the file. Makes sure that the file is really open before; calling TFile::Init. It may block. Long64_t GetSize() const; Get the file size. Returns -1 in the case that the file could not be; stat'ed. Bool_t IsOpen() const; Check if the file is open. void SetAsyncOpenStatus(TFile::EAsyncOpenStatus status); Set the status of an asynchronous file open. void Close(const Option_t* option = """"); Close the file. param option: if == ""R"", all TProcessIDs referenced by this file are; deleted (is this valid in xrootd context?). Int_t ReOpen(Option_t* modestr); Reopen the file with the new access mode. param mode: the new access mode; returns: 0 in case the mode was successfully modified, 1 in case; the mode did not change (was already as requested or wrong; input arguments) and -1 in case of failure, in which case; the file cannot be used anymore. Bool_t ReadBuffer(char* buffer, Int_t length); Read a data chunk of the given size. param buffer: a pointer to a buffer big enough to hold the data; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffer(char* buffer, Long64_t position, Int_t length); Read a data chunk of the given size, starting from the given offset. param buffer: a pointer to a buffer big enough to hold the data; param position: offset from the beginning of the file; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffers(char* buffer, Long64_t* position, Int_t* length, Int_t nbuffs); Read scattered data chunks in one operation. param buffer: a pointer to a buffer big enough to hold all of the; requested data; param position: position[i] is the seek position of chunk i of len; length[i]; param length: length[i] is",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:25795,Availability,failure,failure,25795,"he file. Makes sure that the file is really open before; calling TFile::Init. It may block. Long64_t GetSize() const; Get the file size. Returns -1 in the case that the file could not be; stat'ed. Bool_t IsOpen() const; Check if the file is open. void SetAsyncOpenStatus(TFile::EAsyncOpenStatus status); Set the status of an asynchronous file open. void Close(const Option_t* option = """"); Close the file. param option: if == ""R"", all TProcessIDs referenced by this file are; deleted (is this valid in xrootd context?). Int_t ReOpen(Option_t* modestr); Reopen the file with the new access mode. param mode: the new access mode; returns: 0 in case the mode was successfully modified, 1 in case; the mode did not change (was already as requested or wrong; input arguments) and -1 in case of failure, in which case; the file cannot be used anymore. Bool_t ReadBuffer(char* buffer, Int_t length); Read a data chunk of the given size. param buffer: a pointer to a buffer big enough to hold the data; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffer(char* buffer, Long64_t position, Int_t length); Read a data chunk of the given size, starting from the given offset. param buffer: a pointer to a buffer big enough to hold the data; param position: offset from the beginning of the file; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffers(char* buffer, Long64_t* position, Int_t* length, Int_t nbuffs); Read scattered data chunks in one operation. param buffer: a pointer to a buffer big enough to hold all of the; requested data; param position: position[i] is the seek position of chunk i of len; length[i]; param length: length[i] is the length of the chunk at offset; position[i]; param nbuffs: number of chunks; returns: kTRUE in case of failure. Bool_t WriteBuffer(const char* buffer, Int_t length); Write a data chunk. param buffer: the data to be written; param length: the size of the buffer; returns: kTRUE",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:26127,Availability,failure,failure,26127,"Set the status of an asynchronous file open. void Close(const Option_t* option = """"); Close the file. param option: if == ""R"", all TProcessIDs referenced by this file are; deleted (is this valid in xrootd context?). Int_t ReOpen(Option_t* modestr); Reopen the file with the new access mode. param mode: the new access mode; returns: 0 in case the mode was successfully modified, 1 in case; the mode did not change (was already as requested or wrong; input arguments) and -1 in case of failure, in which case; the file cannot be used anymore. Bool_t ReadBuffer(char* buffer, Int_t length); Read a data chunk of the given size. param buffer: a pointer to a buffer big enough to hold the data; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffer(char* buffer, Long64_t position, Int_t length); Read a data chunk of the given size, starting from the given offset. param buffer: a pointer to a buffer big enough to hold the data; param position: offset from the beginning of the file; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffers(char* buffer, Long64_t* position, Int_t* length, Int_t nbuffs); Read scattered data chunks in one operation. param buffer: a pointer to a buffer big enough to hold all of the; requested data; param position: position[i] is the seek position of chunk i of len; length[i]; param length: length[i] is the length of the chunk at offset; position[i]; param nbuffs: number of chunks; returns: kTRUE in case of failure. Bool_t WriteBuffer(const char* buffer, Int_t length); Write a data chunk. param buffer: the data to be written; param length: the size of the buffer; returns: kTRUE in case of failure. void Flush(). void Seek(Long64_t offset, TFile::ERelativeTo position = kBeg); Set the position within the file. param offset: the new offset relative to position; param position: the relative position, either kBeg, kCur or kEnd. Int_t ParseOpenMode(Option_t* in, TString& modestr, Xrd",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:26559,Availability,failure,failure,26559,"1 in case; the mode did not change (was already as requested or wrong; input arguments) and -1 in case of failure, in which case; the file cannot be used anymore. Bool_t ReadBuffer(char* buffer, Int_t length); Read a data chunk of the given size. param buffer: a pointer to a buffer big enough to hold the data; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffer(char* buffer, Long64_t position, Int_t length); Read a data chunk of the given size, starting from the given offset. param buffer: a pointer to a buffer big enough to hold the data; param position: offset from the beginning of the file; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffers(char* buffer, Long64_t* position, Int_t* length, Int_t nbuffs); Read scattered data chunks in one operation. param buffer: a pointer to a buffer big enough to hold all of the; requested data; param position: position[i] is the seek position of chunk i of len; length[i]; param length: length[i] is the length of the chunk at offset; position[i]; param nbuffs: number of chunks; returns: kTRUE in case of failure. Bool_t WriteBuffer(const char* buffer, Int_t length); Write a data chunk. param buffer: the data to be written; param length: the size of the buffer; returns: kTRUE in case of failure. void Flush(). void Seek(Long64_t offset, TFile::ERelativeTo position = kBeg); Set the position within the file. param offset: the new offset relative to position; param position: the relative position, either kBeg, kCur or kEnd. Int_t ParseOpenMode(Option_t* in, TString& modestr, XrdCl::OpenFlags::Flags& mode, Bool_t assumeRead); Parse a file open mode given as a string into a canonically formatted; output mode string and an integer code that the xroot client can use. param in: the file open mode as a string (in); modestr: open mode string after parsing (out); mode: correctly parsed option mode code (out); assumeRead: if the open mode is not recognised a",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:26744,Availability,failure,failure,26744,"r big enough to hold the data; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffer(char* buffer, Long64_t position, Int_t length); Read a data chunk of the given size, starting from the given offset. param buffer: a pointer to a buffer big enough to hold the data; param position: offset from the beginning of the file; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffers(char* buffer, Long64_t* position, Int_t* length, Int_t nbuffs); Read scattered data chunks in one operation. param buffer: a pointer to a buffer big enough to hold all of the; requested data; param position: position[i] is the seek position of chunk i of len; length[i]; param length: length[i] is the length of the chunk at offset; position[i]; param nbuffs: number of chunks; returns: kTRUE in case of failure. Bool_t WriteBuffer(const char* buffer, Int_t length); Write a data chunk. param buffer: the data to be written; param length: the size of the buffer; returns: kTRUE in case of failure. void Flush(). void Seek(Long64_t offset, TFile::ERelativeTo position = kBeg); Set the position within the file. param offset: the new offset relative to position; param position: the relative position, either kBeg, kCur or kEnd. Int_t ParseOpenMode(Option_t* in, TString& modestr, XrdCl::OpenFlags::Flags& mode, Bool_t assumeRead); Parse a file open mode given as a string into a canonically formatted; output mode string and an integer code that the xroot client can use. param in: the file open mode as a string (in); modestr: open mode string after parsing (out); mode: correctly parsed option mode code (out); assumeRead: if the open mode is not recognised assume read (in); returns: 0 in case the mode was successfully parsed,; -1 in case of failure. Bool_t IsUseable() const; Check the file is open and isn't a zombie. Bool_t GetVectorReadLimits(); Find the server-specific readv config params. Returns kFALSE in case of; error, kTRUE oth",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:27500,Availability,failure,failure,27500,"t_t* length, Int_t nbuffs); Read scattered data chunks in one operation. param buffer: a pointer to a buffer big enough to hold all of the; requested data; param position: position[i] is the seek position of chunk i of len; length[i]; param length: length[i] is the length of the chunk at offset; position[i]; param nbuffs: number of chunks; returns: kTRUE in case of failure. Bool_t WriteBuffer(const char* buffer, Int_t length); Write a data chunk. param buffer: the data to be written; param length: the size of the buffer; returns: kTRUE in case of failure. void Flush(). void Seek(Long64_t offset, TFile::ERelativeTo position = kBeg); Set the position within the file. param offset: the new offset relative to position; param position: the relative position, either kBeg, kCur or kEnd. Int_t ParseOpenMode(Option_t* in, TString& modestr, XrdCl::OpenFlags::Flags& mode, Bool_t assumeRead); Parse a file open mode given as a string into a canonically formatted; output mode string and an integer code that the xroot client can use. param in: the file open mode as a string (in); modestr: open mode string after parsing (out); mode: correctly parsed option mode code (out); assumeRead: if the open mode is not recognised assume read (in); returns: 0 in case the mode was successfully parsed,; -1 in case of failure. Bool_t IsUseable() const; Check the file is open and isn't a zombie. Bool_t GetVectorReadLimits(); Find the server-specific readv config params. Returns kFALSE in case of; error, kTRUE otherwise. void SetEnv(); Map ROOT and xrootd environment variables. TNetXNGFile(); {}. TNetXNGFile(const char* url, Option_t* mode = """", const char* title = """", Int_t compress = 1, Int_t netopt = 0, Bool_t parallelopen = kFALSE). TString GetNewUrl(); { return fNewUrl; }. » Last changed: root/netxng:$Id$ » Last generated: 2015-07-10 18:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:27681,Availability,error,error,27681,"t_t* length, Int_t nbuffs); Read scattered data chunks in one operation. param buffer: a pointer to a buffer big enough to hold all of the; requested data; param position: position[i] is the seek position of chunk i of len; length[i]; param length: length[i] is the length of the chunk at offset; position[i]; param nbuffs: number of chunks; returns: kTRUE in case of failure. Bool_t WriteBuffer(const char* buffer, Int_t length); Write a data chunk. param buffer: the data to be written; param length: the size of the buffer; returns: kTRUE in case of failure. void Flush(). void Seek(Long64_t offset, TFile::ERelativeTo position = kBeg); Set the position within the file. param offset: the new offset relative to position; param position: the relative position, either kBeg, kCur or kEnd. Int_t ParseOpenMode(Option_t* in, TString& modestr, XrdCl::OpenFlags::Flags& mode, Bool_t assumeRead); Parse a file open mode given as a string into a canonically formatted; output mode string and an integer code that the xroot client can use. param in: the file open mode as a string (in); modestr: open mode string after parsing (out); mode: correctly parsed option mode code (out); assumeRead: if the open mode is not recognised assume read (in); returns: 0 in case the mode was successfully parsed,; -1 in case of failure. Bool_t IsUseable() const; Check the file is open and isn't a zombie. Bool_t GetVectorReadLimits(); Find the server-specific readv config params. Returns kFALSE in case of; error, kTRUE otherwise. void SetEnv(); Map ROOT and xrootd environment variables. TNetXNGFile(); {}. TNetXNGFile(const char* url, Option_t* mode = """", const char* title = """", Int_t compress = 1, Int_t netopt = 0, Bool_t parallelopen = kFALSE). TString GetNewUrl(); { return fNewUrl; }. » Last changed: root/netxng:$Id$ » Last generated: 2015-07-10 18:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:27639,Modifiability,config,config,27639,"t_t* length, Int_t nbuffs); Read scattered data chunks in one operation. param buffer: a pointer to a buffer big enough to hold all of the; requested data; param position: position[i] is the seek position of chunk i of len; length[i]; param length: length[i] is the length of the chunk at offset; position[i]; param nbuffs: number of chunks; returns: kTRUE in case of failure. Bool_t WriteBuffer(const char* buffer, Int_t length); Write a data chunk. param buffer: the data to be written; param length: the size of the buffer; returns: kTRUE in case of failure. void Flush(). void Seek(Long64_t offset, TFile::ERelativeTo position = kBeg); Set the position within the file. param offset: the new offset relative to position; param position: the relative position, either kBeg, kCur or kEnd. Int_t ParseOpenMode(Option_t* in, TString& modestr, XrdCl::OpenFlags::Flags& mode, Bool_t assumeRead); Parse a file open mode given as a string into a canonically formatted; output mode string and an integer code that the xroot client can use. param in: the file open mode as a string (in); modestr: open mode string after parsing (out); mode: correctly parsed option mode code (out); assumeRead: if the open mode is not recognised assume read (in); returns: 0 in case the mode was successfully parsed,; -1 in case of failure. Bool_t IsUseable() const; Check the file is open and isn't a zombie. Bool_t GetVectorReadLimits(); Find the server-specific readv config params. Returns kFALSE in case of; error, kTRUE otherwise. void SetEnv(); Map ROOT and xrootd environment variables. TNetXNGFile(); {}. TNetXNGFile(const char* url, Option_t* mode = """", const char* title = """", Int_t compress = 1, Int_t netopt = 0, Bool_t parallelopen = kFALSE). TString GetNewUrl(); { return fNewUrl; }. » Last changed: root/netxng:$Id$ » Last generated: 2015-07-10 18:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:27752,Modifiability,variab,variables,27752,"t_t* length, Int_t nbuffs); Read scattered data chunks in one operation. param buffer: a pointer to a buffer big enough to hold all of the; requested data; param position: position[i] is the seek position of chunk i of len; length[i]; param length: length[i] is the length of the chunk at offset; position[i]; param nbuffs: number of chunks; returns: kTRUE in case of failure. Bool_t WriteBuffer(const char* buffer, Int_t length); Write a data chunk. param buffer: the data to be written; param length: the size of the buffer; returns: kTRUE in case of failure. void Flush(). void Seek(Long64_t offset, TFile::ERelativeTo position = kBeg); Set the position within the file. param offset: the new offset relative to position; param position: the relative position, either kBeg, kCur or kEnd. Int_t ParseOpenMode(Option_t* in, TString& modestr, XrdCl::OpenFlags::Flags& mode, Bool_t assumeRead); Parse a file open mode given as a string into a canonically formatted; output mode string and an integer code that the xroot client can use. param in: the file open mode as a string (in); modestr: open mode string after parsing (out); mode: correctly parsed option mode code (out); assumeRead: if the open mode is not recognised assume read (in); returns: 0 in case the mode was successfully parsed,; -1 in case of failure. Bool_t IsUseable() const; Check the file is open and isn't a zombie. Bool_t GetVectorReadLimits(); Find the server-specific readv config params. Returns kFALSE in case of; error, kTRUE otherwise. void SetEnv(); Map ROOT and xrootd environment variables. TNetXNGFile(); {}. TNetXNGFile(const char* url, Option_t* mode = """", const char* title = """", Int_t compress = 1, Int_t netopt = 0, Bool_t parallelopen = kFALSE). TString GetNewUrl(); { return fNewUrl; }. » Last changed: root/netxng:$Id$ » Last generated: 2015-07-10 18:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:11838,Performance,cache,cacheDir,11838,"cursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* modestr); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo position = kBeg); virtual voidSetAsyncOpenStatus(TFile::EAsyncOpenStatus status); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetO",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:11965,Performance,cache,cache,11965,"dTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo position = kBeg); virtual voidSetAsyncOpenStatus(TFile::EAsyncOpenStatus status); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::Set",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:12084,Performance,cache,cache,12084,"st; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo position = kBeg); virtual voidSetAsyncOpenStatus(TFile::EAsyncOpenStatus status); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:19576,Performance,cache,cache,19576,"leTypeTFile::kWeb; static TObject::(anonymous)TObject::kWriteDelete; static TFile::EStatusBitsTFile::kWriteError; static TObject::(anonymous)TObject::kZombie. protected:. TArchiveFile*TFile::fArchive!Archive file from which we read this file; Long64_tTFile::fArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*TFile::fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusTFile::fAsyncOpenStatus!Status of an asynchronous open request; Long64_tTFile::fBEGINFirst used byte in file; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tTFile::fBytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsPcmFile!True if the file is a ROOT pcm file.; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of obje",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:19638,Performance,cache,cache,19638,"leTypeTFile::kWeb; static TObject::(anonymous)TObject::kWriteDelete; static TFile::EStatusBitsTFile::kWriteError; static TObject::(anonymous)TObject::kZombie. protected:. TArchiveFile*TFile::fArchive!Archive file from which we read this file; Long64_tTFile::fArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*TFile::fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusTFile::fAsyncOpenStatus!Status of an asynchronous open request; Long64_tTFile::fBEGINFirst used byte in file; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tTFile::fBytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsPcmFile!True if the file is a ROOT pcm file.; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of obje",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:19710,Performance,cache,cache,19710,"leTypeTFile::kWeb; static TObject::(anonymous)TObject::kWriteDelete; static TFile::EStatusBitsTFile::kWriteError; static TObject::(anonymous)TObject::kZombie. protected:. TArchiveFile*TFile::fArchive!Archive file from which we read this file; Long64_tTFile::fArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*TFile::fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusTFile::fAsyncOpenStatus!Status of an asynchronous open request; Long64_tTFile::fBEGINFirst used byte in file; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tTFile::fBytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsPcmFile!True if the file is a ROOT pcm file.; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of obje",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:21446,Performance,cache,cache,21446,,MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:21729,Performance,cache,cache,21729,"; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile:",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:23125,Performance,cache,cache,23125,"real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static atomic<Long64_t>TFile::fgBytesReadNumber of bytes read by all TFile objects; static atomic<Long64_t>TFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static atomic<Long64_t>TFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static atomic<Int_t>TFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:23155,Performance,cache,cached,23155,"real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static atomic<Long64_t>TFile::fgBytesReadNumber of bytes read by all TFile objects; static atomic<Long64_t>TFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static atomic<Long64_t>TFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static atomic<Int_t>TFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:13041,Safety,timeout,timeout,13041,"dTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tTFile::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTFile::SumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; I",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:365,Security,access,access,365,". TNetXNGFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NETXNG; » TNetXNGFile. class TNetXNGFile: public TFile. TNetXNGFile. Authors: Justin Salmon, Lukasz Janyst; CERN, 2013. Enables access to XRootD files using the new client. Function Members (Methods); public:. virtual~TNetXNGFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual voidTDirectoryFile::Browse(TBrowser* b); virtual voidTDirectoryFile::Build(TFile* motherFile = 0, TDirectory* motherDir = 0); virtual Bool_tTDirectoryFile::cd(const char* path = 0); static Bool_tTDirectory::Cd(const char* path); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTDirectory::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TObject*TDirectoryFile::CloneObject(const TObject* obj, Bool_t autoadd = kTRUE); virtual voidClose(const Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTFile::Copy(TObject&) const; virtual Bool_tTFile::Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); static Bool_tTFile::Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); virtual TKey*TFile::CreateKey(TDirectory* mother, const TObject* obj, const char* name, Int_t bufsize)",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:24458,Security,access,access,24458,"sponds to blocking i/o; static atomic<Int_t>TFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. private:. XrdCl::File*fFileUnderlying XRootD file; XrdSysCondVar*fInitCondVarUsed to block an async open request; XrdCl::OpenFlags::FlagsfModeOpen mode of the current file; TStringfNewUrl; Int_tfQueryReadVParams; Int_tfReadvIorMaxMax size of a single readv chunk; Int_tfReadvIovMaxMax number of readv chunks; XrdCl::URL*fUrlURL of the current file. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNetXNGFile(const char* url, Option_t* mode = """", const char* title = """", Int_t compress = 1, Int_t netopt = 0, Bool_t parallelopen = kFALSE); Constructor. param url: URL of the entry-point server to be contacted; param mode: initial file access mode; param title: title of the file (shown by ROOT browser); param compress: compression level and algorithm; param netopt: TCP window size in bytes (unused); param parallelopen: open asynchronously. ~TNetXNGFile(); Destructor. void Init(Bool_t create); Initialize the file. Makes sure that the file is really open before; calling TFile::Init. It may block. Long64_t GetSize() const; Get the file size. Returns -1 in the case that the file could not be; stat'ed. Bool_t IsOpen() const; Check if the file is open. void SetAsyncOpenStatus(TFile::EAsyncOpenStatus status); Set the status of an asynchronous file open. void Close(const Option_t* option = """"); Close the file. param option: if == ""R"", all TProcessIDs referenced by this file are; deleted (is this valid in xrootd context?). Int_t ReOpen(Option_t* modestr); Reopen the file with the new access mode. param mode: the new access mode; returns: 0 in case the mode was successfully modified, 1 in case; the mode did not change (was already as requested or wrong; input arguments) and -1 in case of",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:25314,Security,access,access,25314," """", Int_t compress = 1, Int_t netopt = 0, Bool_t parallelopen = kFALSE); Constructor. param url: URL of the entry-point server to be contacted; param mode: initial file access mode; param title: title of the file (shown by ROOT browser); param compress: compression level and algorithm; param netopt: TCP window size in bytes (unused); param parallelopen: open asynchronously. ~TNetXNGFile(); Destructor. void Init(Bool_t create); Initialize the file. Makes sure that the file is really open before; calling TFile::Init. It may block. Long64_t GetSize() const; Get the file size. Returns -1 in the case that the file could not be; stat'ed. Bool_t IsOpen() const; Check if the file is open. void SetAsyncOpenStatus(TFile::EAsyncOpenStatus status); Set the status of an asynchronous file open. void Close(const Option_t* option = """"); Close the file. param option: if == ""R"", all TProcessIDs referenced by this file are; deleted (is this valid in xrootd context?). Int_t ReOpen(Option_t* modestr); Reopen the file with the new access mode. param mode: the new access mode; returns: 0 in case the mode was successfully modified, 1 in case; the mode did not change (was already as requested or wrong; input arguments) and -1 in case of failure, in which case; the file cannot be used anymore. Bool_t ReadBuffer(char* buffer, Int_t length); Read a data chunk of the given size. param buffer: a pointer to a buffer big enough to hold the data; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffer(char* buffer, Long64_t position, Int_t length); Read a data chunk of the given size, starting from the given offset. param buffer: a pointer to a buffer big enough to hold the data; param position: offset from the beginning of the file; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffers(char* buffer, Long64_t* position, Int_t* length, Int_t nbuffs); Read scattered data chunks in one operation. param buffer: a pointer t",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFile.html:25347,Security,access,access,25347,"l file access mode; param title: title of the file (shown by ROOT browser); param compress: compression level and algorithm; param netopt: TCP window size in bytes (unused); param parallelopen: open asynchronously. ~TNetXNGFile(); Destructor. void Init(Bool_t create); Initialize the file. Makes sure that the file is really open before; calling TFile::Init. It may block. Long64_t GetSize() const; Get the file size. Returns -1 in the case that the file could not be; stat'ed. Bool_t IsOpen() const; Check if the file is open. void SetAsyncOpenStatus(TFile::EAsyncOpenStatus status); Set the status of an asynchronous file open. void Close(const Option_t* option = """"); Close the file. param option: if == ""R"", all TProcessIDs referenced by this file are; deleted (is this valid in xrootd context?). Int_t ReOpen(Option_t* modestr); Reopen the file with the new access mode. param mode: the new access mode; returns: 0 in case the mode was successfully modified, 1 in case; the mode did not change (was already as requested or wrong; input arguments) and -1 in case of failure, in which case; the file cannot be used anymore. Bool_t ReadBuffer(char* buffer, Int_t length); Read a data chunk of the given size. param buffer: a pointer to a buffer big enough to hold the data; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffer(char* buffer, Long64_t position, Int_t length); Read a data chunk of the given size, starting from the given offset. param buffer: a pointer to a buffer big enough to hold the data; param position: offset from the beginning of the file; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffers(char* buffer, Long64_t* position, Int_t* length, Int_t nbuffs); Read scattered data chunks in one operation. param buffer: a pointer to a buffer big enough to hold all of the; requested data; param position: position[i] is the seek position of chunk i of len; length[i]; param length: length[i] is",MatchSource.WIKI,root/html604/TNetXNGFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFile.html
https://root.cern/root/html604/TNetXNGFileStager.html:1435,Availability,error,error,1435," virtual~TNetXNGFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNa",MatchSource.WIKI,root/html604/TNetXNGFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFileStager.html
https://root.cern/root/html604/TNetXNGFileStager.html:1519,Availability,error,error,1519,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TStringTFileStager::GetPathName(TObject* o); virtual TList*TFileStager::GetStaged(TCollection* pathlist); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgf",MatchSource.WIKI,root/html604/TNetXNGFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFileStager.html
https://root.cern/root/html604/TNetXNGFileStager.html:7283,Availability,error,error,7283,"Object::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TNetXNGSystem*fSystemUsed to access filesystem interface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNetXNGFileStager(const char* url = """"); Constructor. param url: the URL of the entry-point server. ~TNetXNGFileStager(); Destructor. Bool_t IsStaged(const char* path); Check if a file is staged. param path: the URL of the file. Int_t Locate(const char* path, TString& endpath); Get actual endpoint URL. param path: the entry-point URL; param endpath: the actual endpoint URL; returns: 0 in the case of success and 1 if any error occurred. Int_t LocateCollection(TFileCollection* fc, Bool_t addDummyUrl = kFALSE); Bulk locate request for a collection of files. param fc: collection of files to be located; param addDummyUrl: append a dummy noop URL if the file is not staged or; redirector == endpoint; returns: < 0 in case of errors, number of files processed; otherwise. Bool_t Matches(const char* s); Returns kTRUE if stager 's' is compatible with current stager. Avoids; multiple instantiations of the potentially the same TNetXNGFileStager. Bool_t Stage(const char* path, Option_t* opt = 0); Issue a stage request for a single file. param path: the path of the file to stage; param opt: defines 'option' and 'priority' for 'Prepare': the format is; opt = ""option=o priority=p"". Bool_t Stage(TCollection* pathlist, Option_t* opt = 0); Issue stage requests for multiple files. param pathlist: list of paths of files to stage; param opt: defines 'option' and 'priority'",MatchSource.WIKI,root/html604/TNetXNGFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFileStager.html
https://root.cern/root/html604/TNetXNGFileStager.html:7586,Availability,error,errors,7586," TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TNetXNGSystem*fSystemUsed to access filesystem interface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNetXNGFileStager(const char* url = """"); Constructor. param url: the URL of the entry-point server. ~TNetXNGFileStager(); Destructor. Bool_t IsStaged(const char* path); Check if a file is staged. param path: the URL of the file. Int_t Locate(const char* path, TString& endpath); Get actual endpoint URL. param path: the entry-point URL; param endpath: the actual endpoint URL; returns: 0 in the case of success and 1 if any error occurred. Int_t LocateCollection(TFileCollection* fc, Bool_t addDummyUrl = kFALSE); Bulk locate request for a collection of files. param fc: collection of files to be located; param addDummyUrl: append a dummy noop URL if the file is not staged or; redirector == endpoint; returns: < 0 in case of errors, number of files processed; otherwise. Bool_t Matches(const char* s); Returns kTRUE if stager 's' is compatible with current stager. Avoids; multiple instantiations of the potentially the same TNetXNGFileStager. Bool_t Stage(const char* path, Option_t* opt = 0); Issue a stage request for a single file. param path: the path of the file to stage; param opt: defines 'option' and 'priority' for 'Prepare': the format is; opt = ""option=o priority=p"". Bool_t Stage(TCollection* pathlist, Option_t* opt = 0); Issue stage requests for multiple files. param pathlist: list of paths of files to stage; param opt: defines 'option' and 'priority' for 'Prepare': the; format is opt = ""option=o priority=p"". UChar_t ParseStagePriority(Option_t* opt); Get a staging priority value from an option string. TNetXNGFileStager(const char* url = """"). Bool_t IsValid() const; { return (fSystem ? kTRUE : kFALSE); }. » Last changed: root/netxng:$Id$ » ",MatchSource.WIKI,root/html604/TNetXNGFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFileStager.html
https://root.cern/root/html604/TNetXNGFileStager.html:6757,Integrability,interface,interface,6757,"ation, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. UChar_tParseStagePriority(Option_t* opt). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TNetXNGSystem*fSystemUsed to access filesystem interface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNetXNGFileStager(const char* url = """"); Constructor. param url: the URL of the entry-point server. ~TNetXNGFileStager(); Destructor. Bool_t IsStaged(const char* path); Check if a file is staged. param path: the URL of the file. Int_t Locate(const char* path, TString& endpath); Get actual endpoint URL. param path: the entry-point URL; param endpath: the actual endpoint URL; returns: 0 in the case of success and 1 if any error occurred. Int_t LocateCollection(TFileCollection* fc, Bool_t addDummyUrl = kFALSE); Bulk locate request for a collection of files. param fc: collection of files to be located; param addDummyUrl: append a dummy noop URL if the file is not staged or; redirector == endpoint; returns: < 0 in case of errors, number of files processed; otherwise. Bool_t Matches(const char* s); Returns kTRUE if stager 's' is compatible with current stager. Avoids; mult",MatchSource.WIKI,root/html604/TNetXNGFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFileStager.html
https://root.cern/root/html604/TNetXNGFileStager.html:395,Security,access,access,395,". TNetXNGFileStager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NETXNG; » TNetXNGFileStager. class TNetXNGFileStager: public TFileStager. TNetXNGFileStager. Authors: Justin Salmon, Lukasz Janyst; CERN, 2013. Enables access to XRootD staging capabilities using the new client. Function Members (Methods); public:. virtual~TNetXNGFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNa",MatchSource.WIKI,root/html604/TNetXNGFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFileStager.html
https://root.cern/root/html604/TNetXNGFileStager.html:6739,Security,access,access,6739,"ation, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. UChar_tParseStagePriority(Option_t* opt). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TNetXNGSystem*fSystemUsed to access filesystem interface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNetXNGFileStager(const char* url = """"); Constructor. param url: the URL of the entry-point server. ~TNetXNGFileStager(); Destructor. Bool_t IsStaged(const char* path); Check if a file is staged. param path: the URL of the file. Int_t Locate(const char* path, TString& endpath); Get actual endpoint URL. param path: the entry-point URL; param endpath: the actual endpoint URL; returns: 0 in the case of success and 1 if any error occurred. Int_t LocateCollection(TFileCollection* fc, Bool_t addDummyUrl = kFALSE); Bulk locate request for a collection of files. param fc: collection of files to be located; param addDummyUrl: append a dummy noop URL if the file is not staged or; redirector == endpoint; returns: < 0 in case of errors, number of files processed; otherwise. Bool_t Matches(const char* s); Returns kTRUE if stager 's' is compatible with current stager. Avoids; mult",MatchSource.WIKI,root/html604/TNetXNGFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGFileStager.html
https://root.cern/root/html604/TNetXNGSystem.html:3496,Availability,error,error,3496,"ual Bool_tConsistentWith(const char* path, void* dirptr); virtual voidTNamed::Copy(TObject& named) const; virtual intTSystem::CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidTSystem::DispatchOneEvent(Bool_t pendingOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; char*TSystem::DynamicPathName(const char* lib, Bool_t quiet = kFALSE); virtual Func_tTSystem::DynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tTSystem::Exec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTSystem::Exit(int code, Bool_t mode = kTRUE); virtual voidTSystem::ExitLoop(); virtual Bool_tTSystem::ExpandPathName(TString& path); virtual char*TSystem::ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*TSystem::FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); virtual const char*TSystem::FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp); virtual TSystem::EAclicModeTSystem::GetAclicMode() const; virtual Int_tTSystem::GetAclicProperties() const; voidTSystem::GetBeepDefaults(Int_t& freq, Int_t& duratio",MatchSource.WIKI,root/html604/TNetXNGSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGSystem.html
https://root.cern/root/html604/TNetXNGSystem.html:3580,Availability,error,error,3580,"Object& named) const; virtual intTSystem::CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidTSystem::DispatchOneEvent(Bool_t pendingOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; char*TSystem::DynamicPathName(const char* lib, Bool_t quiet = kFALSE); virtual Func_tTSystem::DynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tTSystem::Exec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTSystem::Exit(int code, Bool_t mode = kTRUE); virtual voidTSystem::ExitLoop(); virtual Bool_tTSystem::ExpandPathName(TString& path); virtual char*TSystem::ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*TSystem::FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); virtual const char*TSystem::FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp); virtual TSystem::EAclicModeTSystem::GetAclicMode() const; virtual Int_tTSystem::GetAclicProperties() const; voidTSystem::GetBeepDefaults(Int_t& freq, Int_t& duration) const; virtual const char*TSystem::GetBuildArch() const; virtual const char*TSyst",MatchSource.WIKI,root/html604/TNetXNGSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGSystem.html
https://root.cern/root/html604/TNetXNGSystem.html:12704,Availability,mask,mask,12704,"ct::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSystem::Select(TList* active, Long_t timeout); virtual Int_tTSystem::Select(TFileHandler* fh, Long_t timeout); virtual intTSystem::SendBuf(int sock, const void* buffer, int length); virtual intTSystem::SendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidTSystem::SetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTSystem::SetDynamicPath(const char* pathname); virtual voidTSystem::Setenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tTSystem::SetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs(const char* linkedLibs); virtual voidTSystem::SetMakeExe(const char* directives); virtual voidTSystem::SetMakeSharedLib(const char* directives); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTSystem::SetObjExt(const char* objExt); virtual voidTSystem::SetProgname(const char* name); virtual intTSystem::SetSockOpt(int sock, int kind, int val); virtual voidTSystem::SetSoExt(const char* soExt); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTSystem::ShowOutput(RedirectHandle_t* h); virtual Int_tTNamed::Sizeof() const; virtual voidTSystem::Sleep(UInt_t milliSec)",MatchSource.WIKI,root/html604/TNetXNGSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGSystem.html
https://root.cern/root/html604/TNetXNGSystem.html:14628,Availability,mask,mask,14628,"val); virtual voidTSystem::SetSoExt(const char* soExt); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTSystem::ShowOutput(RedirectHandle_t* h); virtual Int_tTNamed::Sizeof() const; virtual voidTSystem::Sleep(UInt_t milliSec); virtual TStringTSystem::SplitAclicMode(const char* filename, TString& mode, TString& args, TString& io) const; virtual voidTSystem::StackTrace(); virtual Int_tStage(const char* path, UChar_t priority); virtual Int_tStage(TCollection* files, UChar_t priority); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual intTSystem::Symlink(const char* from, const char* to); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTSystem::Syslog(ELogLevel level, const char* mess); virtual const char*TSystem::TempDirectory() const; virtual FILE*TSystem::TempFileName(TString& base, const char* dir = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TNetXNGSystem(Bool_t owner = kTRUE); TNetXNGSystem(const TNetXNGSystem&); TNetXNGSystem(const char* url, Bool_t owner = kTRUE); virtual intTSystem::Umask(Int_t mask); virtual const char*TSystem::UnixPathName(const char* unixpathname); virtual intUnlink(const char* path); virtual voidTSystem::Unload(const char* module); virtual voidTSystem::Unsetenv(const char* name); virtual voidTObject::UseCurrentStyle(); virtual intTSystem::Utime(const char* file, Long_t modtime, Long_t actime); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual char*TSystem::Which(const char* search, const char* file, EAccessMode mode = kFileExists); virtual const char*TSystem::WorkingDirectory(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TNetXNGSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGSystem.html
https://root.cern/root/html604/TNetXNGSystem.html:18865,Availability,mask,mask,18865,"r optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. private:. set<voi",MatchSource.WIKI,root/html604/TNetXNGSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGSystem.html
https://root.cern/root/html604/TNetXNGSystem.html:18912,Availability,mask,mask,18912,"r optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. private:. set<voi",MatchSource.WIKI,root/html604/TNetXNGSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGSystem.html
https://root.cern/root/html604/TNetXNGSystem.html:18993,Availability,mask,masks,18993,"r optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. private:. set<voi",MatchSource.WIKI,root/html604/TNetXNGSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGSystem.html
https://root.cern/root/html604/TNetXNGSystem.html:20582,Availability,error,error,20582,"ction*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. private:. set<void*>fDirPtrs; XrdCl::FileSystem*fFileSystemCached for convenience; XrdCl::URL*fUrlURL of this TSystem. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNetXNGSystem(Bool_t owner = kTRUE); Constructor: Create system class without connecting to server. param owner: (unused). TNetXNGSystem(const char* url, Bool_t owner = kTRUE); Constructor: Create system class and connect to server. param url: URL of the entry-point server to be contacted; param owner: (unused). ~TNetXNGSystem(); Destructor. void* OpenDirectory(const char* dir); Open a directory. param dir: the name of the directory to open; returns: a non-zero pointer (with no special purpose) in case of; success, 0 in case of error. Int_t MakeDirectory(const char* dir); Create a directory. param dir: the directory name; returns: 0 on success, -1 otherwise. void FreeDirectory(void* dirp); Free a directory. param dirp: the pointer to the directory to be freed. const char* GetDirEntry(void* dirp); Get a directory entry. param dirp: the directory pointer; returns: 0 in case there are no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file (stat). param path: the path of the file to stat (in); param buf: structure that will hold the stat info (out); returns: 0 if success, 1 if the file could not be stat'ed. Bool_t ConsistentWith(const char* path, void* dirptr); Check consistency of this helper with the one required by 'path' or; 'dirptr'. param path: the path to check; param dirptr: the directory pointer to check. int Unlink(const char* path); Unlink a file on the remote server. param path: the path of the file t",MatchSource.WIKI,root/html604/TNetXNGSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGSystem.html
https://root.cern/root/html604/TNetXNGSystem.html:22246,Availability,error,error,22246," directory to be freed. const char* GetDirEntry(void* dirp); Get a directory entry. param dirp: the directory pointer; returns: 0 in case there are no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file (stat). param path: the path of the file to stat (in); param buf: structure that will hold the stat info (out); returns: 0 if success, 1 if the file could not be stat'ed. Bool_t ConsistentWith(const char* path, void* dirptr); Check consistency of this helper with the one required by 'path' or; 'dirptr'. param path: the path to check; param dirptr: the directory pointer to check. int Unlink(const char* path); Unlink a file on the remote server. param path: the path of the file to unlink; returns: 0 on success, -1 otherwise. Bool_t IsPathLocal(const char* path); Is this path a local path?. param path: the URL of the path to check; returns: kTRUE if the path is local, kFALSE otherwise. Int_t Locate(const char* path, TString& endurl); Get the endpoint URL of a file. param path: the entry-point URL of the file (in); param endurl: the endpoint URL of the file (out); returns: 0 in case of success and 1 if the file could not be; stat'ed. Int_t Stage(const char* path, UChar_t priority); Issue a stage request for a single file. param path: the path of the file to stage; param opt: defines 'option' and 'priority' for 'Prepare': the format is; opt = ""option=o priority=p""; returns: 0 for success, -1 for error. Int_t Stage(TCollection* files, UChar_t priority); Issue stage requests for multiple files. param pathlist: list of paths of files to stage; param opt: defines 'option' and 'priority' for 'Prepare': the; format is opt = ""option=o priority=p""; returns: 0 for success, -1 for error. TNetXNGSystem(Bool_t owner = kTRUE). » Last changed: root/netxng:$Id$ » Last generated: 2015-06-02 16:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNetXNGSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGSystem.html
https://root.cern/root/html604/TNetXNGSystem.html:22527,Availability,error,error,22527," directory to be freed. const char* GetDirEntry(void* dirp); Get a directory entry. param dirp: the directory pointer; returns: 0 in case there are no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file (stat). param path: the path of the file to stat (in); param buf: structure that will hold the stat info (out); returns: 0 if success, 1 if the file could not be stat'ed. Bool_t ConsistentWith(const char* path, void* dirptr); Check consistency of this helper with the one required by 'path' or; 'dirptr'. param path: the path to check; param dirptr: the directory pointer to check. int Unlink(const char* path); Unlink a file on the remote server. param path: the path of the file to unlink; returns: 0 on success, -1 otherwise. Bool_t IsPathLocal(const char* path); Is this path a local path?. param path: the URL of the path to check; returns: kTRUE if the path is local, kFALSE otherwise. Int_t Locate(const char* path, TString& endurl); Get the endpoint URL of a file. param path: the entry-point URL of the file (in); param endurl: the endpoint URL of the file (out); returns: 0 in case of success and 1 if the file could not be; stat'ed. Int_t Stage(const char* path, UChar_t priority); Issue a stage request for a single file. param path: the path of the file to stage; param opt: defines 'option' and 'priority' for 'Prepare': the format is; opt = ""option=o priority=p""; returns: 0 for success, -1 for error. Int_t Stage(TCollection* files, UChar_t priority); Issue stage requests for multiple files. param pathlist: list of paths of files to stage; param opt: defines 'option' and 'priority' for 'Prepare': the; format is opt = ""option=o priority=p""; returns: 0 for success, -1 for error. TNetXNGSystem(Bool_t owner = kTRUE). » Last changed: root/netxng:$Id$ » Last generated: 2015-06-02 16:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNetXNGSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGSystem.html
https://root.cern/root/html604/TNetXNGSystem.html:403,Integrability,interface,interface,403,". TNetXNGSystem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NETXNG; » TNetXNGSystem. class TNetXNGSystem: public TSystem. TNetXNGSystem. Authors: Justin Salmon, Lukasz Janyst; CERN, 2013. Enables access to XRootD filesystem interface using the new client. Function Members (Methods); public:. virtual~TNetXNGSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tTSystem::AccessPathName(const char* path, EAccessMode mode = kFileExists); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intTSystem::AnnounceUdpService(int port, int backlog); virtual intTSystem::AnnounceUnixService(int port, int backlog); virtual intTSystem::AnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tTSystem::ChangeDirectory(const char* path); virtual intTSystem::Chmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanCompiledMacros(); virtual voidTNamed::Clear(Option_t* option = """"); ",MatchSource.WIKI,root/html604/TNetXNGSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGSystem.html
https://root.cern/root/html604/TNetXNGSystem.html:9715,Integrability,protocol,protocol,9715,"l Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual intTSystem::Link(const char* from, const char* to); virtual voidTSystem::ListLibraries(const char* regexp = """"); virtual voidTSystem::ListSymbols(const char* module, const char* re = """"); virtual intTSystem::Load(const char* module, const char* entry = """", Bool_t system = kFALSE); virtual Int_tLocate(const char* path, TString& endurl); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tMakeDirectory(const char* dir); voidTObject::MayNotUse(const char* method) const; virtual intTSystem::mkdir(const char* name, Bool_t recursive = kFALSE); virtual Long_tTSystem::NextTimeOut(Bool_t mode); virtual Bool_tTObject::Notify(); virtual voidTSystem::NotifyApplicationCreated(); virtual TTimeTSystem::Now(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual intTSystem::OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); virtual void*OpenDirectory(const char* dir); virtual voidTSystem::Openlog(const char* name, Int_t options, ELogFacility facility); virtual FILE*TSystem::OpenPipe(const char* command, const char* mode); voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNetXNGSystem&operator=(const TNetXNGSystem&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual const char*TSystem::PrependPathName(const char* dir, TString& name); virtual voidTNamed::Print(Option_t* option = """") const; virtual Bool_tTSystem::ProcessEvents(); const char*TSystem::pwd(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject",MatchSource.WIKI,root/html604/TNetXNGSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGSystem.html
https://root.cern/root/html604/TNetXNGSystem.html:17240,Modifiability,config,configure,17240,t; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TSystem::EAclicModeTSystem::kOpt; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TSystem::EAclicModeTSystem::fAclicModeWhether the compilation should be done debug or opt; Int_tTSystem::fAclicPropertiesVarious boolean flag for change ACLiC's behavior.; Int_tTSystem::fBeepDurationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EA,MatchSource.WIKI,root/html604/TNetXNGSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGSystem.html
https://root.cern/root/html604/TNetXNGSystem.html:17857,Performance,optimiz,optimized,17857,"avior.; Int_tTSystem::fBeepDurationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCol",MatchSource.WIKI,root/html604/TNetXNGSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGSystem.html
https://root.cern/root/html604/TNetXNGSystem.html:18543,Performance,cache,cache,18543,"avior.; Int_tTSystem::fBeepDurationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCol",MatchSource.WIKI,root/html604/TNetXNGSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGSystem.html
https://root.cern/root/html604/TNetXNGSystem.html:11813,Safety,timeout,timeout,11813,"Raw(int sock, void* buffer, int length, int flag); virtual Int_tTSystem::RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*TSystem::RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*TSystem::RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*TSystem::RemoveTimer(TTimer* t); virtual intTSystem::Rename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidTSystem::ResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidTSystem::ResetSignals(); virtual voidTSystem::ResetTimer(TTimer*); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSystem::Select(TList* active, Long_t timeout); virtual Int_tTSystem::Select(TFileHandler* fh, Long_t timeout); virtual intTSystem::SendBuf(int sock, const void* buffer, int length); virtual intTSystem::SendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidTSystem::SetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTSystem::SetDynamicPath(const char* pathname); virtual voidTSystem::Setenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tTSystem::SetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkd",MatchSource.WIKI,root/html604/TNetXNGSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGSystem.html
https://root.cern/root/html604/TNetXNGSystem.html:11877,Safety,timeout,timeout,11877,"TSystem::RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*TSystem::RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*TSystem::RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*TSystem::RemoveTimer(TTimer* t); virtual intTSystem::Rename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidTSystem::ResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidTSystem::ResetSignals(); virtual voidTSystem::ResetTimer(TTimer*); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSystem::Select(TList* active, Long_t timeout); virtual Int_tTSystem::Select(TFileHandler* fh, Long_t timeout); virtual intTSystem::SendBuf(int sock, const void* buffer, int length); virtual intTSystem::SendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidTSystem::SetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTSystem::SetDynamicPath(const char* pathname); virtual voidTSystem::Setenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tTSystem::SetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs",MatchSource.WIKI,root/html604/TNetXNGSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGSystem.html
https://root.cern/root/html604/TNetXNGSystem.html:375,Security,access,access,375,". TNetXNGSystem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NETXNG; » TNetXNGSystem. class TNetXNGSystem: public TSystem. TNetXNGSystem. Authors: Justin Salmon, Lukasz Janyst; CERN, 2013. Enables access to XRootD filesystem interface using the new client. Function Members (Methods); public:. virtual~TNetXNGSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tTSystem::AccessPathName(const char* path, EAccessMode mode = kFileExists); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intTSystem::AnnounceUdpService(int port, int backlog); virtual intTSystem::AnnounceUnixService(int port, int backlog); virtual intTSystem::AnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tTSystem::ChangeDirectory(const char* path); virtual intTSystem::Chmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanCompiledMacros(); virtual voidTNamed::Clear(Option_t* option = """"); ",MatchSource.WIKI,root/html604/TNetXNGSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGSystem.html
https://root.cern/root/html604/TNetXNGSystem.html:17966,Security,access,access,17966,"avior.; Int_tTSystem::fBeepDurationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCol",MatchSource.WIKI,root/html604/TNetXNGSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNetXNGSystem.html
https://root.cern/root/html604/TNeuron.html:2006,Availability,error,error,2006," virtual~TNeuron(); voidTObject::AbstractMethod(const char* method) const; voidAddInLayer(TNeuron*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, In",MatchSource.WIKI,root/html604/TNeuron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNeuron.html
https://root.cern/root/html604/TNeuron.html:2090,Availability,error,error,2090,"(const char* method) const; voidAddInLayer(TNeuron*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidForceExternalValue(Double_t value); Double_tGetBranch() const; Double_tGetDeDw() const; Double_tGetDEDw() const; Double_tGetDerivative() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetError() const; virtual const char*TObject::GetIconName() const; TNeuron*GetInLayer(Int_t n) const; Double_tGetInput() const; virtual const char*TNamed::GetName() const; const Double_t*GetNormalisation() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TSynapse*GetPost(Int_t n) const; TSynapse*GetPre(Int_t n) const; Double_tGet",MatchSource.WIKI,root/html604/TNeuron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNeuron.html
https://root.cern/root/html604/TNeuron.html:7885,Availability,error,error,7885,"ronTypekLinear; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TNeuron::ENeuronTypekOff; static TObject::(anonymous)TObject::kOverwrite; static TNeuron::ENeuronTypekSigmoid; static TObject::(anonymous)TObject::kSingleKey; static TNeuron::ENeuronTypekSoftmax; static TNeuron::ENeuronTypekTanh; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfDEDw! buffer containing the sum over all examples of DeDw; Double_tfDeDw! buffer containing the last derivative of the error; Double_tfDerivative! buffer containing the last neuron derivative; TFormula*fExtDderivative (external mode); TFormula*fExtFfunction (external mode); TTreeFormula*fFormula! formula to be used for inputs and outputs; Int_tfIndex! index in the formula; Double_tfInput! buffer containing the last neuron input; Bool_tfNewDeDw! do we need to compute fDeDw again ?; Bool_tfNewDeriv! do we need to compute fDerivative again ?; Bool_tfNewInput! do we need to compute fInput again ?; Bool_tfNewValue! do we need to compute fValue again ?; Double_tfNorm[2]normalisation to mean=0, RMS=1.; TNeuron::ENeuronTypefTypeneuron type; Double_tfValue! buffer containing the last neuron output; Double_tfWeightweight used for computation; TObjArrayflayerpointers to the current level in a network (neurons, not synapses); TObjArrayfpostpointers to the next level in a network; TObjArrayfprepointers to the previous level in a network. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNeuron(TNeuron::ENeuronType type = kSigmoid, const char* name = """", const char* title = """", const char* extF = """", const char* extD = """"); Usual constructor. Double_t Sigmoid(Double_t x) const; The Sigmoid.; Fast c",MatchSource.WIKI,root/html604/TNeuron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNeuron.html
https://root.cern/root/html604/TNeuron.html:10709,Availability,error,error,10709,"g two neurons. void AddPost(TSynapse* ); Adds a synapse to the neuron as an output; This method is used by the TSynapse while; connecting two neurons. void AddInLayer(TNeuron* ); Tells a neuron which neurons form its layer (including itself).; This is needed for self-normalizing functions, like Softmax. TTreeFormula* UseBranch(TTree* , const char* ); Sets a formula that can be used to make the neuron an input.; The formula is automatically normalized to mean=0, RMS=1.; This normalisation is used by GetValue() (input neurons); and GetError() (output neurons). Double_t GetBranch() const; Returns the formula value. Double_t GetInput() const; Returns neuron input. Double_t GetValue() const; Computes the output using the appropriate function and all; the weighted inputs, or uses the branch as input.; In that case, the branch normalisation is also used. Double_t GetDerivative() const; computes the derivative for the appropriate function; at the working point. Double_t GetError() const; Computes the error for output neurons.; Returns 0 for other neurons. Double_t GetTarget() const; Computes the normalized target pattern for output neurons.; Returns 0 for other neurons. Double_t GetDeDw() const; Computes the derivative of the error wrt the neuron weight. void ForceExternalValue(Double_t value); Uses the branch type to force an external value. void SetNormalisation(Double_t mean, Double_t RMS); Sets the normalization variables.; Any input neuron will return (branch-mean)/RMS.; When UseBranch is called, mean and RMS are automatically set; to the actual branch mean and RMS. void SetWeight(Double_t w); Sets the neuron weight to w.; The neuron weight corresponds to the bias in the; linear combination of the inputs. void SetNewEvent() const; Inform the neuron that inputs of the network have changed,; so that the buffered values have to be recomputed. void SetDEDw(Double_t in); Sets the derivative of the total error wrt the neuron weight. TNeuron(TNeuron::ENeuronType type = kSigmo",MatchSource.WIKI,root/html604/TNeuron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNeuron.html
https://root.cern/root/html604/TNeuron.html:10939,Availability,error,error,10939,"(including itself).; This is needed for self-normalizing functions, like Softmax. TTreeFormula* UseBranch(TTree* , const char* ); Sets a formula that can be used to make the neuron an input.; The formula is automatically normalized to mean=0, RMS=1.; This normalisation is used by GetValue() (input neurons); and GetError() (output neurons). Double_t GetBranch() const; Returns the formula value. Double_t GetInput() const; Returns neuron input. Double_t GetValue() const; Computes the output using the appropriate function and all; the weighted inputs, or uses the branch as input.; In that case, the branch normalisation is also used. Double_t GetDerivative() const; computes the derivative for the appropriate function; at the working point. Double_t GetError() const; Computes the error for output neurons.; Returns 0 for other neurons. Double_t GetTarget() const; Computes the normalized target pattern for output neurons.; Returns 0 for other neurons. Double_t GetDeDw() const; Computes the derivative of the error wrt the neuron weight. void ForceExternalValue(Double_t value); Uses the branch type to force an external value. void SetNormalisation(Double_t mean, Double_t RMS); Sets the normalization variables.; Any input neuron will return (branch-mean)/RMS.; When UseBranch is called, mean and RMS are automatically set; to the actual branch mean and RMS. void SetWeight(Double_t w); Sets the neuron weight to w.; The neuron weight corresponds to the bias in the; linear combination of the inputs. void SetNewEvent() const; Inform the neuron that inputs of the network have changed,; so that the buffered values have to be recomputed. void SetDEDw(Double_t in); Sets the derivative of the total error wrt the neuron weight. TNeuron(TNeuron::ENeuronType type = kSigmoid, const char* name = """", const char* title = """", const char* extF = """", const char* extD = """"); {}. TSynapse* GetPre(Int_t n) const; { return (TSynapse*) fpre.At(n); }. TSynapse* GetPost(Int_t n) const; { return (TSynapse",MatchSource.WIKI,root/html604/TNeuron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNeuron.html
https://root.cern/root/html604/TNeuron.html:11630,Availability,error,error,11630,"le_t GetDerivative() const; computes the derivative for the appropriate function; at the working point. Double_t GetError() const; Computes the error for output neurons.; Returns 0 for other neurons. Double_t GetTarget() const; Computes the normalized target pattern for output neurons.; Returns 0 for other neurons. Double_t GetDeDw() const; Computes the derivative of the error wrt the neuron weight. void ForceExternalValue(Double_t value); Uses the branch type to force an external value. void SetNormalisation(Double_t mean, Double_t RMS); Sets the normalization variables.; Any input neuron will return (branch-mean)/RMS.; When UseBranch is called, mean and RMS are automatically set; to the actual branch mean and RMS. void SetWeight(Double_t w); Sets the neuron weight to w.; The neuron weight corresponds to the bias in the; linear combination of the inputs. void SetNewEvent() const; Inform the neuron that inputs of the network have changed,; so that the buffered values have to be recomputed. void SetDEDw(Double_t in); Sets the derivative of the total error wrt the neuron weight. TNeuron(TNeuron::ENeuronType type = kSigmoid, const char* name = """", const char* title = """", const char* extF = """", const char* extD = """"); {}. TSynapse* GetPre(Int_t n) const; { return (TSynapse*) fpre.At(n); }. TSynapse* GetPost(Int_t n) const; { return (TSynapse*) fpost.At(n); }. TNeuron* GetInLayer(Int_t n) const; { return (TNeuron*) flayer.At(n); }. ENeuronType GetType() const. Double_t GetWeight() const; { return fWeight; }. const Double_t* GetNormalisation() const; { return fNorm; }. Double_t GetDEDw() const; { return fDEDw; }. TNeuron& operator=(const TNeuron& ). » Author: Christophe.Delaere@cern.ch 20/07/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/mlp:$Id$ » Last generated: 2015-06-02 16:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNeuron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNeuron.html
https://root.cern/root/html604/TNeuron.html:11133,Modifiability,variab,variables,11133,"uron an input.; The formula is automatically normalized to mean=0, RMS=1.; This normalisation is used by GetValue() (input neurons); and GetError() (output neurons). Double_t GetBranch() const; Returns the formula value. Double_t GetInput() const; Returns neuron input. Double_t GetValue() const; Computes the output using the appropriate function and all; the weighted inputs, or uses the branch as input.; In that case, the branch normalisation is also used. Double_t GetDerivative() const; computes the derivative for the appropriate function; at the working point. Double_t GetError() const; Computes the error for output neurons.; Returns 0 for other neurons. Double_t GetTarget() const; Computes the normalized target pattern for output neurons.; Returns 0 for other neurons. Double_t GetDeDw() const; Computes the derivative of the error wrt the neuron weight. void ForceExternalValue(Double_t value); Uses the branch type to force an external value. void SetNormalisation(Double_t mean, Double_t RMS); Sets the normalization variables.; Any input neuron will return (branch-mean)/RMS.; When UseBranch is called, mean and RMS are automatically set; to the actual branch mean and RMS. void SetWeight(Double_t w); Sets the neuron weight to w.; The neuron weight corresponds to the bias in the; linear combination of the inputs. void SetNewEvent() const; Inform the neuron that inputs of the network have changed,; so that the buffered values have to be recomputed. void SetDEDw(Double_t in); Sets the derivative of the total error wrt the neuron weight. TNeuron(TNeuron::ENeuronType type = kSigmoid, const char* name = """", const char* title = """", const char* extF = """", const char* extD = """"); {}. TSynapse* GetPre(Int_t n) const; { return (TSynapse*) fpre.At(n); }. TSynapse* GetPost(Int_t n) const; { return (TSynapse*) fpost.At(n); }. TNeuron* GetInLayer(Int_t n) const; { return (TNeuron*) flayer.At(n); }. ENeuronType GetType() const. Double_t GetWeight() const; { return fWeight; }. const ",MatchSource.WIKI,root/html604/TNeuron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNeuron.html
https://root.cern/root/html604/TNewChainDlg.html:425,Availability,avail,available,425,". TNewChainDlg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TNewChainDlg. class TNewChainDlg: public TGTransientFrame. TSessionDialogs. This file defines several dialogs that are used by TSessionViewer.; The following dialogs are available: TNewChainDlg and TNewQueryDlg. Function Members (Methods); public:. virtual~TNewChainDlg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal",MatchSource.WIKI,root/html604/TNewChainDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNewChainDlg.html
https://root.cern/root/html604/TNewChainDlg.html:4507,Availability,error,error,4507," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html604/TNewChainDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNewChainDlg.html
https://root.cern/root/html604/TNewChainDlg.html:4591,Availability,error,error,4591,"(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html604/TNewChainDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNewChainDlg.html
https://root.cern/root/html604/TNewChainDlg.html:20285,Availability,mask,mask,20285,,MatchSource.WIKI,root/html604/TNewChainDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNewChainDlg.html
https://root.cern/root/html604/TNewChainDlg.html:24584,Integrability,message,messages,24584,"Int_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGTextButton*fCancelButtoncancel button; TObject*fChainactual TDSet or TChain; TSeqCollection*fChainscollection of datasets; TGFileContainer*fContentsmacro files container; TGLVContainer*fLVContainerand its container; TGListView*fListViewmemory objects list view; TGTextEntry*fNamedataset name text entry; TGTextBuffer*fNameBufbuffer for dataset name; TGTextButton*fOkButtonok button. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNewChainDlg(const TGWindow* p = 0, const TGWindow* main = 0); Create a new chain dialog box. Used to list chains present in memory; and offers the possibility to create new ones by executing macros; directly from the associate file container. ~TNewChainDlg(); Delete chain dialog. void OnElementSelected(TObject* obj); Emits OnElementSelected signal if dset is not zero. void OnElementClicked(TGLVEntry* entry, Int_t btn); Handle click in the Memory list view and put the type; and name of selected object in the text entry. void UpdateList(); Update Memory list view. void DisplayDirectory(const TString& fname); Display content of directory. void OnDoubleClick(TGLVEntry* , Int_t ); Handle double click in the File container. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for new chain dialog. void CloseWindow(); Close file dialog. TNewChainDlg(const TGWindow* p = 0, const TGWindow* main = 0). » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-06-02 16:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNewChainDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNewChainDlg.html
https://root.cern/root/html604/TNewQueryDlg.html:425,Availability,avail,available,425,". TNewQueryDlg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TNewQueryDlg. class TNewQueryDlg: public TGTransientFrame. TSessionDialogs. This file defines several dialogs that are used by TSessionViewer.; The following dialogs are available: TNewChainDlg and TNewQueryDlg. Function Members (Methods); public:. virtual~TNewQueryDlg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBuild(TSessionViewer* gui); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQOb",MatchSource.WIKI,root/html604/TNewQueryDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNewQueryDlg.html
https://root.cern/root/html604/TNewQueryDlg.html:4487,Availability,error,error,4487," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html604/TNewQueryDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNewQueryDlg.html
https://root.cern/root/html604/TNewQueryDlg.html:4571,Availability,error,error,4571,"(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html604/TNewQueryDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNewQueryDlg.html
https://root.cern/root/html604/TNewQueryDlg.html:20444,Availability,mask,mask,20444,,MatchSource.WIKI,root/html604/TNewQueryDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNewQueryDlg.html
https://root.cern/root/html604/TNewQueryDlg.html:24850,Deployability,update,update,24850," changed; TGNumberEntry*fNumEntriesnumber of entries selector; TGNumberEntry*fNumFirstEntryfirst entry selector; TQueryDescription*fQueryquery description class; TGTextEntry*fTxtChainchain name text entry; TGTextEntry*fTxtEventListevent list text entry; TGTextEntry*fTxtOptionsoptions text entry; TGTextEntry*fTxtQueryNamequery name text entry; TGTextEntry*fTxtSelectorselector name text entry; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNewQueryDlg(TSessionViewer* gui, Int_t Width, Int_t Height, TQueryDescription* query = 0, Bool_t editmode = kFALSE); Create a new Query dialog, used by the Session Viewer, to Edit a Query if; the editmode flag is set, or to create a new one if not set. ~TNewQueryDlg(); Delete query dialog. void Build(TSessionViewer* gui); Build the ""new query"" dialog. void CloseWindow(); Called when window is closed via the window manager. void OnNewQueryMore(); Show/hide options frame and update button text accordingly. void OnBrowseChain(); Call new chain dialog. void OnElementSelected(TObject* obj); Handle OnElementSelected signal coming from new chain dialog. void OnBrowseSelector(); Open file browser to choose selector macro. void OnBrowseEventList(); Browse event list. void OnBtnSaveClicked(); Save current settings in main session viewer. void OnBtnSubmitClicked(); Save and submit query description. void OnBtnCloseClicked(); Close dialog. void Popup(); Display dialog and set focus to query name text entry. void SettingsChanged(); Settings have changed, update GUI accordingly. void UpdateFields(TQueryDescription* desc); Update entry fields with query description values. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for new query dialog.; Essentially used to navigate between text entry fields. TNewQueryDlg(TSessionViewer* gui, Int_t Width, Int_t Height, TQueryDescription* query = 0, Bool_t editmode = kFALSE). » Author: Mare",MatchSource.WIKI,root/html604/TNewQueryDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNewQueryDlg.html
https://root.cern/root/html604/TNewQueryDlg.html:25430,Deployability,update,update,25430,"xtEntry*fTxtSelectorselector name text entry; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNewQueryDlg(TSessionViewer* gui, Int_t Width, Int_t Height, TQueryDescription* query = 0, Bool_t editmode = kFALSE); Create a new Query dialog, used by the Session Viewer, to Edit a Query if; the editmode flag is set, or to create a new one if not set. ~TNewQueryDlg(); Delete query dialog. void Build(TSessionViewer* gui); Build the ""new query"" dialog. void CloseWindow(); Called when window is closed via the window manager. void OnNewQueryMore(); Show/hide options frame and update button text accordingly. void OnBrowseChain(); Call new chain dialog. void OnElementSelected(TObject* obj); Handle OnElementSelected signal coming from new chain dialog. void OnBrowseSelector(); Open file browser to choose selector macro. void OnBrowseEventList(); Browse event list. void OnBtnSaveClicked(); Save current settings in main session viewer. void OnBtnSubmitClicked(); Save and submit query description. void OnBtnCloseClicked(); Close dialog. void Popup(); Display dialog and set focus to query name text entry. void SettingsChanged(); Settings have changed, update GUI accordingly. void UpdateFields(TQueryDescription* desc); Update entry fields with query description values. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for new query dialog.; Essentially used to navigate between text entry fields. TNewQueryDlg(TSessionViewer* gui, Int_t Width, Int_t Height, TQueryDescription* query = 0, Bool_t editmode = kFALSE). » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-06-02 16:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNewQueryDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNewQueryDlg.html
https://root.cern/root/html604/TNewQueryDlg.html:25620,Integrability,message,messages,25620,"xtEntry*fTxtSelectorselector name text entry; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNewQueryDlg(TSessionViewer* gui, Int_t Width, Int_t Height, TQueryDescription* query = 0, Bool_t editmode = kFALSE); Create a new Query dialog, used by the Session Viewer, to Edit a Query if; the editmode flag is set, or to create a new one if not set. ~TNewQueryDlg(); Delete query dialog. void Build(TSessionViewer* gui); Build the ""new query"" dialog. void CloseWindow(); Called when window is closed via the window manager. void OnNewQueryMore(); Show/hide options frame and update button text accordingly. void OnBrowseChain(); Call new chain dialog. void OnElementSelected(TObject* obj); Handle OnElementSelected signal coming from new chain dialog. void OnBrowseSelector(); Open file browser to choose selector macro. void OnBrowseEventList(); Browse event list. void OnBtnSaveClicked(); Save current settings in main session viewer. void OnBtnSubmitClicked(); Save and submit query description. void OnBtnCloseClicked(); Close dialog. void Popup(); Display dialog and set focus to query name text entry. void SettingsChanged(); Settings have changed, update GUI accordingly. void UpdateFields(TQueryDescription* desc); Update entry fields with query description values. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for new query dialog.; Essentially used to navigate between text entry fields. TNewQueryDlg(TSessionViewer* gui, Int_t Width, Int_t Height, TQueryDescription* query = 0, Bool_t editmode = kFALSE). » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-06-02 16:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNewQueryDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNewQueryDlg.html
https://root.cern/root/html604/TNode.html:1847,Availability,error,error,1847,"Browse(TBrowser* b); virtual voidBuildListOfNodes(); virtual voidcd(const char* path = 0)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOnly(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TList*GetListOfNodes() const; virtual TRotMatrix*GetMatrix() const; virtual const char*TNamed::GetName() const; virtual TNode*GetNode(const char* name) const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject",MatchSource.WIKI,root/html604/TNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNode.html
https://root.cern/root/html604/TNode.html:1931,Availability,error,error,1931," = 0)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOnly(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TList*GetListOfNodes() const; virtual TRotMatrix*GetMatrix() const; virtual const char*TNamed::GetName() const; virtual TNode*GetNode(const char* name) const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const Option_t*GetOption() const; virtual TNode*GetParent",MatchSource.WIKI,root/html604/TNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNode.html
https://root.cern/root/html604/TNodeDiv.html:1572,Availability,error,error,1572,"rtual voidTNode::BuildListOfNodes(); virtual voidTNode::cd(const char* path = 0)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTNode::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTNode::DrawOnly(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTNode::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TList*TNode::GetListOfNodes() const; virtual TRotMatrix*TNode::GetMatrix() const; virtual const char*TNamed::GetName() const; virtual TNode*TNode::GetNode(const char* name) const; virtual char*TNode::GetObjectInfo(Int_t px, In",MatchSource.WIKI,root/html604/TNodeDiv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNodeDiv.html
https://root.cern/root/html604/TNodeDiv.html:1656,Availability,error,error,1656," ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTNode::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTNode::DrawOnly(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTNode::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TList*TNode::GetListOfNodes() const; virtual TRotMatrix*TNode::GetMatrix() const; virtual const char*TNamed::GetName() const; virtual TNode*TNode::GetNode(const char* name) const; virtual char*TNode::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const Option_t*TNode::",MatchSource.WIKI,root/html604/TNodeDiv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNodeDiv.html
https://root.cern/root/html604/TNonSplitBrowsable.html:3170,Availability,error,error,3170,,MatchSource.WIKI,root/html604/TNonSplitBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNonSplitBrowsable.html
https://root.cern/root/html604/TNonSplitBrowsable.html:3254,Availability,error,error,3254,"ractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static Int_tTVirtualBranchBrowsable::FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TBranch*TVirtualBranchBrowsable::GetBranch() const; static Int_tGetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); TClass*TVirtualBranchBrowsable::GetClassType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TVirtualBranchBrowsable::GetIconName() const; TList*TVirtualBranchBrowsable::GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tT",MatchSource.WIKI,root/html604/TNonSplitBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNonSplitBrowsable.html
https://root.cern/root/html604/TNonSplitBrowsable.html:10005,Integrability,depend,depending,10005,"Heap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNonSplitBrowsable(const TStreamerElement* element, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); Constructor. Creates a TNonSplitBrowsable from a TStreamerElement, containing branch; and (if applicable) parent TVirtualBranchBrowsable. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); Given either a branch ""branch"" or a ""parent"" TVirtualBranchBrowsable, we fill; ""list"" with objects of type TNonSplitBrowsable which represent the members; of class ""cl"" (and its base classes' members). void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TNonSplitBrowsable(); {}. TNonSplitBrowsable(const TStreamerElement* element, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNonSplitBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNonSplitBrowsable.html
https://root.cern/root/html604/TNonSplitBrowsable.html:10182,Integrability,depend,depending,10182,"Heap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNonSplitBrowsable(const TStreamerElement* element, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); Constructor. Creates a TNonSplitBrowsable from a TStreamerElement, containing branch; and (if applicable) parent TVirtualBranchBrowsable. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); Given either a branch ""branch"" or a ""parent"" TVirtualBranchBrowsable, we fill; ""list"" with objects of type TNonSplitBrowsable which represent the members; of class ""cl"" (and its base classes' members). void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TNonSplitBrowsable(); {}. TNonSplitBrowsable(const TStreamerElement* element, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNonSplitBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNonSplitBrowsable.html
https://root.cern/root/html604/TNonSplitBrowsable.html:441,Modifiability,extend,extend,441,". TNonSplitBrowsable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TNonSplitBrowsable. class TNonSplitBrowsable: public TVirtualBranchBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* bra",MatchSource.WIKI,root/html604/TNonSplitBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNonSplitBrowsable.html
https://root.cern/root/html604/TNonSplitBrowsable.html:1168,Performance,cache,cached,1168,"; » TREE; » TREE; » TNonSplitBrowsable. class TNonSplitBrowsable: public TVirtualBranchBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TNonSplitBrowsa",MatchSource.WIKI,root/html604/TNonSplitBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNonSplitBrowsable.html
https://root.cern/root/html604/TNonSplitBrowsable.html:1229,Performance,cache,cached,1229,"; » TREE; » TREE; » TNonSplitBrowsable. class TNonSplitBrowsable: public TVirtualBranchBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TNonSplitBrowsa",MatchSource.WIKI,root/html604/TNonSplitBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNonSplitBrowsable.html
https://root.cern/root/html604/TNonSplitBrowsable.html:1416,Usability,simpl,simple,1416,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TNonSplitBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable::Browse(TBrowser* b); static TClass*Class(); v",MatchSource.WIKI,root/html604/TNonSplitBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNonSplitBrowsable.html
https://root.cern/root/html604/TNtuple.html:4826,Availability,error,error,4826,"e_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual Int_tTTree::DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tTTree::DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(const Float_t* x); Int_tFill(Int_t x0); Int_tFill(Double_t x0); virtual Int_tFill(Float_t x0, Float_t x1 = 0, Float_t x2 = 0, Float_t x3 = 0, Float_t x4 = 0, Float_t x5 = 0, Float_t x6 = 0, Float_t x7 = 0, Float_t x8 = 0, Float_t x9 = 0, Float_t x10 = 0, Float_t x11 = 0, Float_t x12 = 0, Float_t x13 = 0, Float_t x14 = 0); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TTree::FindBranch(const char* name); virtual TLeaf*TTree::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t ",MatchSource.WIKI,root/html604/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtuple.html
https://root.cern/root/html604/TNtuple.html:4910,Availability,error,error,4910,"); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual Int_tTTree::DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tTTree::DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(const Float_t* x); Int_tFill(Int_t x0); Int_tFill(Double_t x0); virtual Int_tFill(Float_t x0, Float_t x1 = 0, Float_t x2 = 0, Float_t x3 = 0, Float_t x4 = 0, Float_t x5 = 0, Float_t x6 = 0, Float_t x7 = 0, Float_t x8 = 0, Float_t x9 = 0, Float_t x10 = 0, Float_t x11 = 0, Float_t x12 = 0, Float_t x13 = 0, Float_t x14 = 0); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TTree::FindBranch(const char* name); virtual TLeaf*TTree::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tTTree::FlushBaske",MatchSource.WIKI,root/html604/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtuple.html
https://root.cern/root/html604/TNtuple.html:16530,Deployability,update,updateExisting,16530,"t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTTree::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual Int_tTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual Int_tTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTTree::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidTTree::SetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidTTree::SetEventList(TEventList* list); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTTree::SetMakeClass(Int",MatchSource.WIKI,root/html604/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtuple.html
https://root.cern/root/html604/TNtuple.html:25592,Energy Efficiency,allocate,allocated,25592,n a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList*TTree::fEventList! Pointer to event selection list (if one); Int_tTTree::fFileNumber! current file number (if file extensions); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tTTree::fFlushedBytesNumber of autoflushed bytes; UInt_tTTree::fFriendLockStatus! Record which method is locking the friend recursion; TList*TTree::fFriendspointer to list of friend elements; TArrayITTree::fIndexIndex of sorted values; TArrayDTTree::fIndexValuesSorted index values; TObjArrayTTree::fLeavesDirect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of,MatchSource.WIKI,root/html604/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtuple.html
https://root.cern/root/html604/TNtuple.html:28374,Energy Efficiency,energy,energy,28374,"a file containg a Tree; static TTree::ELockStatusBitsTTree::kFindBranch; static TTree::ELockStatusBitsTTree::kFindLeaf; static TTree::ELockStatusBitsTTree::kGetAlias; static TTree::ELockStatusBitsTTree::kGetBranch; static TTree::ELockStatusBitsTTree::kGetEntry; static TTree::ELockStatusBitsTTree::kGetEntryWithIndex; static TTree::ELockStatusBitsTTree::kGetFriend; static TTree::ELockStatusBitsTTree::kGetFriendAlias; static TTree::ELockStatusBitsTTree::kGetLeaf; static TTree::ELockStatusBitsTTree::kLoadTree; static TTree::ELockStatusBitsTTree::kPrint; static TTree::ELockStatusBitsTTree::kRemoveFriend; static TTree::ELockStatusBitsTTree::kSetBranchStatus. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNtuple(); Default constructor for Ntuple*-*-*-*-*-*-*-*-; *-* ==============================. TNtuple(const char* name, const char* title, const char* varlist, Int_t bufsize = 32000); Create an Ntuple*-*-; *-* ================; The parameter varlist describes the list of the ntuple variables; separated by a colon:; example: ""x:y:z:energy""; For each variable in the list a separate branch is created. NOTE:; -Use TTree to create branches with variables of different data types.; -Use TTree when the number of branches is large (> 100).; -. ~TNtuple(); Default destructor for an Ntuple*-*-*-*-*-*-; *-* ================================. TTree* CloneTree(Long64_t nentries = -1, Option_t* option = """"); Create a clone of this tree and copy nentries. By default copy all entries.; Note that only active branches are copied.; The compression level of the cloned tree is set to the destination file's; compression level. See TTree::CloneTree for more details. void ResetBranchAddress(TBranch* ); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void ResetBranchAddresses(); Reset the branch addresses to the internal fArgs array. Use this; method when the addres",MatchSource.WIKI,root/html604/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtuple.html
https://root.cern/root/html604/TNtuple.html:333,Modifiability,variab,variables,333,". TNtuple. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TNtuple. class TNtuple: public TTree. TNtuple. A simple tree restricted to a list of float variables only. Each variable goes to a separate branch. A Ntuple is created via; TNtuple(name,title,varlist,bufsize); It is filled via:; TNtuple::Fill(*x) or; TNtuple::Fill(v1,v2,v3.....). Function Members (Methods); public:. virtual~TNtuple(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTTree::AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tTTree::AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*TTree::AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*TTree::AddFriend(const char* treename, TFile* file); virtual TFriendElement*TTree::AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidTTree::AddTotBytes(Int_t tot); virtual voidTTree::AddZipBytes(Int_t zip); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long64_tTTree::AutoSave(Option_t* option = """"); virtual Int_tTTree::Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tTTree::Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tTTree::Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); virtual TBranch*TTree::Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, char* address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, Long_t address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, int address, const char* leaflist, Int_t bufsize = 32000); virtual TBranch*TTree::Bra",MatchSource.WIKI,root/html604/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtuple.html
https://root.cern/root/html604/TNtuple.html:354,Modifiability,variab,variable,354,". TNtuple. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TNtuple. class TNtuple: public TTree. TNtuple. A simple tree restricted to a list of float variables only. Each variable goes to a separate branch. A Ntuple is created via; TNtuple(name,title,varlist,bufsize); It is filled via:; TNtuple::Fill(*x) or; TNtuple::Fill(v1,v2,v3.....). Function Members (Methods); public:. virtual~TNtuple(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTTree::AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tTTree::AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*TTree::AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*TTree::AddFriend(const char* treename, TFile* file); virtual TFriendElement*TTree::AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidTTree::AddTotBytes(Int_t tot); virtual voidTTree::AddZipBytes(Int_t zip); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long64_tTTree::AutoSave(Option_t* option = """"); virtual Int_tTTree::Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tTTree::Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tTTree::Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); virtual TBranch*TTree::Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, char* address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, Long_t address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, int address, const char* leaflist, Int_t bufsize = 32000); virtual TBranch*TTree::Bra",MatchSource.WIKI,root/html604/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtuple.html
https://root.cern/root/html604/TNtuple.html:23241,Modifiability,variab,variables,23241,anchAddressStatusTTree::kNoCheck; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)TTree::kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatusTTree::kVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Float_t*fArgs! [fNvar] Array of variables; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogr,MatchSource.WIKI,root/html604/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtuple.html
https://root.cern/root/html604/TNtuple.html:28324,Modifiability,variab,variables,28324,"a file containg a Tree; static TTree::ELockStatusBitsTTree::kFindBranch; static TTree::ELockStatusBitsTTree::kFindLeaf; static TTree::ELockStatusBitsTTree::kGetAlias; static TTree::ELockStatusBitsTTree::kGetBranch; static TTree::ELockStatusBitsTTree::kGetEntry; static TTree::ELockStatusBitsTTree::kGetEntryWithIndex; static TTree::ELockStatusBitsTTree::kGetFriend; static TTree::ELockStatusBitsTTree::kGetFriendAlias; static TTree::ELockStatusBitsTTree::kGetLeaf; static TTree::ELockStatusBitsTTree::kLoadTree; static TTree::ELockStatusBitsTTree::kPrint; static TTree::ELockStatusBitsTTree::kRemoveFriend; static TTree::ELockStatusBitsTTree::kSetBranchStatus. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNtuple(); Default constructor for Ntuple*-*-*-*-*-*-*-*-; *-* ==============================. TNtuple(const char* name, const char* title, const char* varlist, Int_t bufsize = 32000); Create an Ntuple*-*-; *-* ================; The parameter varlist describes the list of the ntuple variables; separated by a colon:; example: ""x:y:z:energy""; For each variable in the list a separate branch is created. NOTE:; -Use TTree to create branches with variables of different data types.; -Use TTree when the number of branches is large (> 100).; -. ~TNtuple(); Default destructor for an Ntuple*-*-*-*-*-*-; *-* ================================. TTree* CloneTree(Long64_t nentries = -1, Option_t* option = """"); Create a clone of this tree and copy nentries. By default copy all entries.; Note that only active branches are copied.; The compression level of the cloned tree is set to the destination file's; compression level. See TTree::CloneTree for more details. void ResetBranchAddress(TBranch* ); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void ResetBranchAddresses(); Reset the branch addresses to the internal fArgs array. Use this; method when the addres",MatchSource.WIKI,root/html604/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtuple.html
https://root.cern/root/html604/TNtuple.html:28392,Modifiability,variab,variable,28392,"a file containg a Tree; static TTree::ELockStatusBitsTTree::kFindBranch; static TTree::ELockStatusBitsTTree::kFindLeaf; static TTree::ELockStatusBitsTTree::kGetAlias; static TTree::ELockStatusBitsTTree::kGetBranch; static TTree::ELockStatusBitsTTree::kGetEntry; static TTree::ELockStatusBitsTTree::kGetEntryWithIndex; static TTree::ELockStatusBitsTTree::kGetFriend; static TTree::ELockStatusBitsTTree::kGetFriendAlias; static TTree::ELockStatusBitsTTree::kGetLeaf; static TTree::ELockStatusBitsTTree::kLoadTree; static TTree::ELockStatusBitsTTree::kPrint; static TTree::ELockStatusBitsTTree::kRemoveFriend; static TTree::ELockStatusBitsTTree::kSetBranchStatus. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNtuple(); Default constructor for Ntuple*-*-*-*-*-*-*-*-; *-* ==============================. TNtuple(const char* name, const char* title, const char* varlist, Int_t bufsize = 32000); Create an Ntuple*-*-; *-* ================; The parameter varlist describes the list of the ntuple variables; separated by a colon:; example: ""x:y:z:energy""; For each variable in the list a separate branch is created. NOTE:; -Use TTree to create branches with variables of different data types.; -Use TTree when the number of branches is large (> 100).; -. ~TNtuple(); Default destructor for an Ntuple*-*-*-*-*-*-; *-* ================================. TTree* CloneTree(Long64_t nentries = -1, Option_t* option = """"); Create a clone of this tree and copy nentries. By default copy all entries.; Note that only active branches are copied.; The compression level of the cloned tree is set to the destination file's; compression level. See TTree::CloneTree for more details. void ResetBranchAddress(TBranch* ); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void ResetBranchAddresses(); Reset the branch addresses to the internal fArgs array. Use this; method when the addres",MatchSource.WIKI,root/html604/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtuple.html
https://root.cern/root/html604/TNtuple.html:28485,Modifiability,variab,variables,28485,"BitsTTree::kGetBranch; static TTree::ELockStatusBitsTTree::kGetEntry; static TTree::ELockStatusBitsTTree::kGetEntryWithIndex; static TTree::ELockStatusBitsTTree::kGetFriend; static TTree::ELockStatusBitsTTree::kGetFriendAlias; static TTree::ELockStatusBitsTTree::kGetLeaf; static TTree::ELockStatusBitsTTree::kLoadTree; static TTree::ELockStatusBitsTTree::kPrint; static TTree::ELockStatusBitsTTree::kRemoveFriend; static TTree::ELockStatusBitsTTree::kSetBranchStatus. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNtuple(); Default constructor for Ntuple*-*-*-*-*-*-*-*-; *-* ==============================. TNtuple(const char* name, const char* title, const char* varlist, Int_t bufsize = 32000); Create an Ntuple*-*-; *-* ================; The parameter varlist describes the list of the ntuple variables; separated by a colon:; example: ""x:y:z:energy""; For each variable in the list a separate branch is created. NOTE:; -Use TTree to create branches with variables of different data types.; -Use TTree when the number of branches is large (> 100).; -. ~TNtuple(); Default destructor for an Ntuple*-*-*-*-*-*-; *-* ================================. TTree* CloneTree(Long64_t nentries = -1, Option_t* option = """"); Create a clone of this tree and copy nentries. By default copy all entries.; Note that only active branches are copied.; The compression level of the cloned tree is set to the destination file's; compression level. See TTree::CloneTree for more details. void ResetBranchAddress(TBranch* ); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void ResetBranchAddresses(); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void Browse(TBrowser* b); Browse content of the ntuple. Int_t Fill(); -*-*Fill a Ntuple with current values in fArgs; *-* =====================",MatchSource.WIKI,root/html604/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtuple.html
https://root.cern/root/html604/TNtuple.html:30091,Modifiability,variab,variables,30091,"t to the destination file's; compression level. See TTree::CloneTree for more details. void ResetBranchAddress(TBranch* ); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void ResetBranchAddresses(); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void Browse(TBrowser* b); Browse content of the ntuple. Int_t Fill(); -*-*Fill a Ntuple with current values in fArgs; *-* ==========================================; Note that this function is protected.; Currently called only by TChain::Merge. Int_t Fill(const Float_t* x); Fill a Ntuple with an array of floats. Int_t Fill(Float_t x0, Float_t x1 = 0, Float_t x2 = 0, Float_t x3 = 0, Float_t x4 = 0, Float_t x5 = 0, Float_t x6 = 0, Float_t x7 = 0, Float_t x8 = 0, Float_t x9 = 0, Float_t x10 = 0, Float_t x11 = 0, Float_t x12 = 0, Float_t x13 = 0, Float_t x14 = 0); Fill a Ntuple: Each Ntuple item is an argument. Long64_t ReadStream(istream& inputStream, const char* branchDescriptor = """", char delimiter = ' '); Read from filename as many columns as variables in the ntuple; the function returns the number of rows found in the file; The second argument ""branchDescriptor"" is currently not used.; Lines in the input file starting with ""#"" are ignored. void Streamer(TBuffer& ); Stream a class object*-*-*-*-*-*-*-; *-* =========================================. Int_t Fill(). TNtuple(const TNtuple& ). TNtuple& operator=(const TNtuple& ). Int_t Fill(const Float_t* x). Int_t GetNvar() const; { return fNvar; }. Float_t * GetArgs() const; { return fArgs; }. » Author: Rene Brun 06/04/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtuple.html
https://root.cern/root/html604/TNtuple.html:16242,Performance,cache,cachesize,16242,"TTree::SetAlias(const char* aliasName, const char* aliasFormula); virtual voidTTree::SetAutoFlush(Long64_t autof = -30000000); virtual voidTTree::SetAutoSave(Long64_t autos = -300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTTree::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual Int_tTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual Int_tTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTTree::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidTTree::SetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidTTree::SetEventList(TEventList* list); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine:",MatchSource.WIKI,root/html604/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtuple.html
https://root.cern/root/html604/TNtuple.html:21466,Performance,cache,cacheSize,21466,"method, const char* msgfmt) const; virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTTree::AddClone(TTree*); virtual TBranch*TTree::BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); virtual Int_tTTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Int_tFill(); Long64_tTTree::GetCacheAutoSize(Bool_t withDefault = kFALSE) const; virtual TLeaf*TTree::GetLeafImpl(const char* branchname, const char* leafname); charTTree::GetNewlineValue(istream& inputStream); TTreeCache*TTree::GetReadCache(TFile* file, Bool_t create = kFALSE); voidTTree::ImportClusterRanges(TTree* fromtree); virtual voidTTree::KeepCircular(); voidTObject::MakeZombie(); voidTTree::MoveReadCache(TFile* src, TDirectory* dir); Int_tTTree::SetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); Int_tTTree::SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). private:. TNtuple&operator=(const TNtuple&); TNtuple(const TNtuple&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::",MatchSource.WIKI,root/html604/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtuple.html
https://root.cern/root/html604/TNtuple.html:23632,Performance,cache,cache,23632,anchAddressStatusTTree::kNoCheck; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)TTree::kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatusTTree::kVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Float_t*fArgs! [fNvar] Array of variables; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogr,MatchSource.WIKI,root/html604/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtuple.html
https://root.cern/root/html604/TNtuple.html:23776,Performance,cache,cache,23776,anchAddressStatusTTree::kNoCheck; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)TTree::kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatusTTree::kVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Float_t*fArgs! [fNvar] Array of variables; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogr,MatchSource.WIKI,root/html604/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtuple.html
https://root.cern/root/html604/TNtuple.html:26077,Performance,load,loading,26077,Line::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tfNvarNumber of columns; Int_tTTree::fPacketSize! Number of entries in one packet for parallel root; TVirtualPerfStats*TTree::fPerfStats! pointer to the current perf stats object; TVirtualTreePlayer*TTree::fPlayer! Pointer to current Tree player; Long64_tTTree::fReadEntry! Number of the entry being processed; Long64_tTTree::fSavedBytesNumber of autosaved bytes; Int_tTTree::fScanFieldNumber of runs before prompting in Scan; Int_tTTree::fTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TBuffer*TTree::fTransientBuffer! Pointer to the current transient buffer.; TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tTTree::fUpdateUpdate frequency for EntryLoop; TList*TTree::fUserInfopointer to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBranchStyleOld/New branch styl,MatchSource.WIKI,root/html604/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtuple.html
https://root.cern/root/html604/TNtuple.html:291,Usability,simpl,simple,291,". TNtuple. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TNtuple. class TNtuple: public TTree. TNtuple. A simple tree restricted to a list of float variables only. Each variable goes to a separate branch. A Ntuple is created via; TNtuple(name,title,varlist,bufsize); It is filled via:; TNtuple::Fill(*x) or; TNtuple::Fill(v1,v2,v3.....). Function Members (Methods); public:. virtual~TNtuple(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTTree::AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tTTree::AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*TTree::AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*TTree::AddFriend(const char* treename, TFile* file); virtual TFriendElement*TTree::AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidTTree::AddTotBytes(Int_t tot); virtual voidTTree::AddZipBytes(Int_t zip); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long64_tTTree::AutoSave(Option_t* option = """"); virtual Int_tTTree::Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tTTree::Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tTTree::Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); virtual TBranch*TTree::Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, char* address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, Long_t address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, int address, const char* leaflist, Int_t bufsize = 32000); virtual TBranch*TTree::Bra",MatchSource.WIKI,root/html604/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtuple.html
https://root.cern/root/html604/TNtuple.html:3321,Usability,undo,undo,3321,"0, Int_t splitlevel = 99); virtual TBranch*TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser* b); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObjec",MatchSource.WIKI,root/html604/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtuple.html
https://root.cern/root/html604/TNtupleD.html:4842,Availability,error,error,4842,"e_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual Int_tTTree::DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tTTree::DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(const Double_t* x); virtual Int_tFill(Double_t x0, Double_t x1, Double_t x2 = 0, Double_t x3 = 0, Double_t x4 = 0, Double_t x5 = 0, Double_t x6 = 0, Double_t x7 = 0, Double_t x8 = 0, Double_t x9 = 0, Double_t x10 = 0, Double_t x11 = 0, Double_t x12 = 0, Double_t x13 = 0, Double_t x14 = 0); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TTree::FindBranch(const char* name); virtual TLeaf*TTree::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t f",MatchSource.WIKI,root/html604/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtupleD.html
https://root.cern/root/html604/TNtupleD.html:4926,Availability,error,error,4926,"); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual Int_tTTree::DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tTTree::DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(const Double_t* x); virtual Int_tFill(Double_t x0, Double_t x1, Double_t x2 = 0, Double_t x3 = 0, Double_t x4 = 0, Double_t x5 = 0, Double_t x6 = 0, Double_t x7 = 0, Double_t x8 = 0, Double_t x9 = 0, Double_t x10 = 0, Double_t x11 = 0, Double_t x12 = 0, Double_t x13 = 0, Double_t x14 = 0); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TTree::FindBranch(const char* name); virtual TLeaf*TTree::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tTTree::FlushBaskets() const; virtual const char*TT",MatchSource.WIKI,root/html604/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtupleD.html
https://root.cern/root/html604/TNtupleD.html:16514,Deployability,update,updateExisting,16514,"t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTTree::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual Int_tTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual Int_tTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTTree::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidTTree::SetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidTTree::SetEventList(TEventList* list); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTTree::SetMakeClass(Int",MatchSource.WIKI,root/html604/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtupleD.html
https://root.cern/root/html604/TNtupleD.html:25583,Energy Efficiency,allocate,allocated,25583,n a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList*TTree::fEventList! Pointer to event selection list (if one); Int_tTTree::fFileNumber! current file number (if file extensions); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tTTree::fFlushedBytesNumber of autoflushed bytes; UInt_tTTree::fFriendLockStatus! Record which method is locking the friend recursion; TList*TTree::fFriendspointer to list of friend elements; TArrayITTree::fIndexIndex of sorted values; TArrayDTTree::fIndexValuesSorted index values; TObjArrayTTree::fLeavesDirect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of,MatchSource.WIKI,root/html604/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtupleD.html
https://root.cern/root/html604/TNtupleD.html:28367,Energy Efficiency,energy,energy,28367," file containg a Tree; static TTree::ELockStatusBitsTTree::kFindBranch; static TTree::ELockStatusBitsTTree::kFindLeaf; static TTree::ELockStatusBitsTTree::kGetAlias; static TTree::ELockStatusBitsTTree::kGetBranch; static TTree::ELockStatusBitsTTree::kGetEntry; static TTree::ELockStatusBitsTTree::kGetEntryWithIndex; static TTree::ELockStatusBitsTTree::kGetFriend; static TTree::ELockStatusBitsTTree::kGetFriendAlias; static TTree::ELockStatusBitsTTree::kGetLeaf; static TTree::ELockStatusBitsTTree::kLoadTree; static TTree::ELockStatusBitsTTree::kPrint; static TTree::ELockStatusBitsTTree::kRemoveFriend; static TTree::ELockStatusBitsTTree::kSetBranchStatus. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNtupleD(); Default constructor for Ntuple*-*-*-*-*-*-*-*-; *-* ==============================. TNtupleD(const char* name, const char* title, const char* varlist, Int_t bufsize = 32000); Create an Ntuple*-*-; *-* ================; The parameter varlist describes the list of the ntuple variables; separated by a colon:; example: ""x:y:z:energy""; For each variable in the list a separate branch is created. NOTE:; -Use TTree to create branches with variables of different data types.; -Use TTree when the number of branches is large (> 100).; -. ~TNtupleD(); Default destructor for an Ntuple*-*-*-*-*-*-; *-* ================================. void ResetBranchAddress(TBranch* ); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void ResetBranchAddresses(); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void Browse(TBrowser* b); Browse content. Int_t Fill(); -*-*Fill a Ntuple with current values in fArgs; *-* ==========================================; Note that this function is protected.; Currently called only by TChain::Merge. Int_t Fill(const Double_t* x); Fill a",MatchSource.WIKI,root/html604/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtupleD.html
https://root.cern/root/html604/TNtupleD.html:338,Modifiability,variab,variables,338,". TNtupleD. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TNtupleD. class TNtupleD: public TTree. TNtupleD. A simple tree restricted to a list of double variables only. Each variable goes to a separate branch. A Ntuple is created via; TNtupleD(name,title,varlist,bufsize); It is filled via:; TNtupleD::Fill(*x) or; TNtupleD::Fill(v1,v2,v3.....). Function Members (Methods); public:. virtual~TNtupleD(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTTree::AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tTTree::AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*TTree::AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*TTree::AddFriend(const char* treename, TFile* file); virtual TFriendElement*TTree::AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidTTree::AddTotBytes(Int_t tot); virtual voidTTree::AddZipBytes(Int_t zip); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long64_tTTree::AutoSave(Option_t* option = """"); virtual Int_tTTree::Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tTTree::Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tTTree::Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); virtual TBranch*TTree::Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, char* address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, Long_t address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, int address, const char* leaflist, Int_t bufsize = 32000); virtual TBranch*T",MatchSource.WIKI,root/html604/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtupleD.html
https://root.cern/root/html604/TNtupleD.html:359,Modifiability,variab,variable,359,". TNtupleD. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TNtupleD. class TNtupleD: public TTree. TNtupleD. A simple tree restricted to a list of double variables only. Each variable goes to a separate branch. A Ntuple is created via; TNtupleD(name,title,varlist,bufsize); It is filled via:; TNtupleD::Fill(*x) or; TNtupleD::Fill(v1,v2,v3.....). Function Members (Methods); public:. virtual~TNtupleD(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTTree::AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tTTree::AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*TTree::AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*TTree::AddFriend(const char* treename, TFile* file); virtual TFriendElement*TTree::AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidTTree::AddTotBytes(Int_t tot); virtual voidTTree::AddZipBytes(Int_t zip); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long64_tTTree::AutoSave(Option_t* option = """"); virtual Int_tTTree::Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tTTree::Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tTTree::Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); virtual TBranch*TTree::Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, char* address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, Long_t address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, int address, const char* leaflist, Int_t bufsize = 32000); virtual TBranch*T",MatchSource.WIKI,root/html604/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtupleD.html
https://root.cern/root/html604/TNtupleD.html:23232,Modifiability,variab,variables,23232,nchAddressStatusTTree::kNoCheck; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)TTree::kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatusTTree::kVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Double_t*fArgs! [fNvar] Array of variables; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histog,MatchSource.WIKI,root/html604/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtupleD.html
https://root.cern/root/html604/TNtupleD.html:28317,Modifiability,variab,variables,28317," file containg a Tree; static TTree::ELockStatusBitsTTree::kFindBranch; static TTree::ELockStatusBitsTTree::kFindLeaf; static TTree::ELockStatusBitsTTree::kGetAlias; static TTree::ELockStatusBitsTTree::kGetBranch; static TTree::ELockStatusBitsTTree::kGetEntry; static TTree::ELockStatusBitsTTree::kGetEntryWithIndex; static TTree::ELockStatusBitsTTree::kGetFriend; static TTree::ELockStatusBitsTTree::kGetFriendAlias; static TTree::ELockStatusBitsTTree::kGetLeaf; static TTree::ELockStatusBitsTTree::kLoadTree; static TTree::ELockStatusBitsTTree::kPrint; static TTree::ELockStatusBitsTTree::kRemoveFriend; static TTree::ELockStatusBitsTTree::kSetBranchStatus. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNtupleD(); Default constructor for Ntuple*-*-*-*-*-*-*-*-; *-* ==============================. TNtupleD(const char* name, const char* title, const char* varlist, Int_t bufsize = 32000); Create an Ntuple*-*-; *-* ================; The parameter varlist describes the list of the ntuple variables; separated by a colon:; example: ""x:y:z:energy""; For each variable in the list a separate branch is created. NOTE:; -Use TTree to create branches with variables of different data types.; -Use TTree when the number of branches is large (> 100).; -. ~TNtupleD(); Default destructor for an Ntuple*-*-*-*-*-*-; *-* ================================. void ResetBranchAddress(TBranch* ); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void ResetBranchAddresses(); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void Browse(TBrowser* b); Browse content. Int_t Fill(); -*-*Fill a Ntuple with current values in fArgs; *-* ==========================================; Note that this function is protected.; Currently called only by TChain::Merge. Int_t Fill(const Double_t* x); Fill a",MatchSource.WIKI,root/html604/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtupleD.html
https://root.cern/root/html604/TNtupleD.html:28385,Modifiability,variab,variable,28385," file containg a Tree; static TTree::ELockStatusBitsTTree::kFindBranch; static TTree::ELockStatusBitsTTree::kFindLeaf; static TTree::ELockStatusBitsTTree::kGetAlias; static TTree::ELockStatusBitsTTree::kGetBranch; static TTree::ELockStatusBitsTTree::kGetEntry; static TTree::ELockStatusBitsTTree::kGetEntryWithIndex; static TTree::ELockStatusBitsTTree::kGetFriend; static TTree::ELockStatusBitsTTree::kGetFriendAlias; static TTree::ELockStatusBitsTTree::kGetLeaf; static TTree::ELockStatusBitsTTree::kLoadTree; static TTree::ELockStatusBitsTTree::kPrint; static TTree::ELockStatusBitsTTree::kRemoveFriend; static TTree::ELockStatusBitsTTree::kSetBranchStatus. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNtupleD(); Default constructor for Ntuple*-*-*-*-*-*-*-*-; *-* ==============================. TNtupleD(const char* name, const char* title, const char* varlist, Int_t bufsize = 32000); Create an Ntuple*-*-; *-* ================; The parameter varlist describes the list of the ntuple variables; separated by a colon:; example: ""x:y:z:energy""; For each variable in the list a separate branch is created. NOTE:; -Use TTree to create branches with variables of different data types.; -Use TTree when the number of branches is large (> 100).; -. ~TNtupleD(); Default destructor for an Ntuple*-*-*-*-*-*-; *-* ================================. void ResetBranchAddress(TBranch* ); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void ResetBranchAddresses(); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void Browse(TBrowser* b); Browse content. Int_t Fill(); -*-*Fill a Ntuple with current values in fArgs; *-* ==========================================; Note that this function is protected.; Currently called only by TChain::Merge. Int_t Fill(const Double_t* x); Fill a",MatchSource.WIKI,root/html604/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtupleD.html
https://root.cern/root/html604/TNtupleD.html:28478,Modifiability,variab,variables,28478,"tsTTree::kGetBranch; static TTree::ELockStatusBitsTTree::kGetEntry; static TTree::ELockStatusBitsTTree::kGetEntryWithIndex; static TTree::ELockStatusBitsTTree::kGetFriend; static TTree::ELockStatusBitsTTree::kGetFriendAlias; static TTree::ELockStatusBitsTTree::kGetLeaf; static TTree::ELockStatusBitsTTree::kLoadTree; static TTree::ELockStatusBitsTTree::kPrint; static TTree::ELockStatusBitsTTree::kRemoveFriend; static TTree::ELockStatusBitsTTree::kSetBranchStatus. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNtupleD(); Default constructor for Ntuple*-*-*-*-*-*-*-*-; *-* ==============================. TNtupleD(const char* name, const char* title, const char* varlist, Int_t bufsize = 32000); Create an Ntuple*-*-; *-* ================; The parameter varlist describes the list of the ntuple variables; separated by a colon:; example: ""x:y:z:energy""; For each variable in the list a separate branch is created. NOTE:; -Use TTree to create branches with variables of different data types.; -Use TTree when the number of branches is large (> 100).; -. ~TNtupleD(); Default destructor for an Ntuple*-*-*-*-*-*-; *-* ================================. void ResetBranchAddress(TBranch* ); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void ResetBranchAddresses(); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void Browse(TBrowser* b); Browse content. Int_t Fill(); -*-*Fill a Ntuple with current values in fArgs; *-* ==========================================; Note that this function is protected.; Currently called only by TChain::Merge. Int_t Fill(const Double_t* x); Fill a Ntuple with an array of floats*-; *-* =====================================. Int_t Fill(Double_t x0, Double_t x1, Double_t x2 = 0, Double_t x3 = 0, Double_t x4 = 0, Double_t x5 = 0, Double_t x",MatchSource.WIKI,root/html604/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtupleD.html
https://root.cern/root/html604/TNtupleD.html:29865,Modifiability,variab,variables,29865,"=========================. void ResetBranchAddress(TBranch* ); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void ResetBranchAddresses(); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void Browse(TBrowser* b); Browse content. Int_t Fill(); -*-*Fill a Ntuple with current values in fArgs; *-* ==========================================; Note that this function is protected.; Currently called only by TChain::Merge. Int_t Fill(const Double_t* x); Fill a Ntuple with an array of floats*-; *-* =====================================. Int_t Fill(Double_t x0, Double_t x1, Double_t x2 = 0, Double_t x3 = 0, Double_t x4 = 0, Double_t x5 = 0, Double_t x6 = 0, Double_t x7 = 0, Double_t x8 = 0, Double_t x9 = 0, Double_t x10 = 0, Double_t x11 = 0, Double_t x12 = 0, Double_t x13 = 0, Double_t x14 = 0); -*-*Fill a Ntuple: Each Ntuple item is an argument; *-* ==============================================. Long64_t ReadStream(istream& inputstream, const char* branchDescriptor = """", char delimiter = ' '); read from filename as many columns as variables in the ntuple; the function returns the number of rows found in the file; The second argument ""branchDescriptor"" is currently not used.; Lines in the input file starting with ""#"" are ignored. void Streamer(TBuffer& ); Stream a class object*-*-*-*-*-*-*-; *-* =========================================. TNtupleD(const TNtupleD& ). TNtupleD& operator=(const TNtupleD& ). Int_t GetNvar() const; { return fNvar; }. Double_t * GetArgs() const; { return fArgs; }. » Author: Rene Brun 06/04/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtupleD.html
https://root.cern/root/html604/TNtupleD.html:16226,Performance,cache,cachesize,16226,"TTree::SetAlias(const char* aliasName, const char* aliasFormula); virtual voidTTree::SetAutoFlush(Long64_t autof = -30000000); virtual voidTTree::SetAutoSave(Long64_t autos = -300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTTree::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual Int_tTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual Int_tTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTTree::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidTTree::SetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidTTree::SetEventList(TEventList* list); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine:",MatchSource.WIKI,root/html604/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtupleD.html
https://root.cern/root/html604/TNtupleD.html:21452,Performance,cache,cacheSize,21452,"method, const char* msgfmt) const; virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTTree::AddClone(TTree*); virtual TBranch*TTree::BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); virtual Int_tTTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Int_tFill(); Long64_tTTree::GetCacheAutoSize(Bool_t withDefault = kFALSE) const; virtual TLeaf*TTree::GetLeafImpl(const char* branchname, const char* leafname); charTTree::GetNewlineValue(istream& inputStream); TTreeCache*TTree::GetReadCache(TFile* file, Bool_t create = kFALSE); voidTTree::ImportClusterRanges(TTree* fromtree); virtual voidTTree::KeepCircular(); voidTObject::MakeZombie(); voidTTree::MoveReadCache(TFile* src, TDirectory* dir); Int_tTTree::SetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); Int_tTTree::SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). private:. TNtupleD&operator=(const TNtupleD&); TNtupleD(const TNtupleD&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObje",MatchSource.WIKI,root/html604/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtupleD.html
https://root.cern/root/html604/TNtupleD.html:23623,Performance,cache,cache,23623,nchAddressStatusTTree::kNoCheck; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)TTree::kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatusTTree::kVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Double_t*fArgs! [fNvar] Array of variables; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histog,MatchSource.WIKI,root/html604/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtupleD.html
https://root.cern/root/html604/TNtupleD.html:23767,Performance,cache,cache,23767,nchAddressStatusTTree::kNoCheck; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)TTree::kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatusTTree::kVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Double_t*fArgs! [fNvar] Array of variables; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histog,MatchSource.WIKI,root/html604/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtupleD.html
https://root.cern/root/html604/TNtupleD.html:26068,Performance,load,loading,26068,Line::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tfNvarNumber of columns; Int_tTTree::fPacketSize! Number of entries in one packet for parallel root; TVirtualPerfStats*TTree::fPerfStats! pointer to the current perf stats object; TVirtualTreePlayer*TTree::fPlayer! Pointer to current Tree player; Long64_tTTree::fReadEntry! Number of the entry being processed; Long64_tTTree::fSavedBytesNumber of autosaved bytes; Int_tTTree::fScanFieldNumber of runs before prompting in Scan; Int_tTTree::fTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TBuffer*TTree::fTransientBuffer! Pointer to the current transient buffer.; TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tTTree::fUpdateUpdate frequency for EntryLoop; TList*TTree::fUserInfopointer to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBranchStyleOld/New branch styl,MatchSource.WIKI,root/html604/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtupleD.html
https://root.cern/root/html604/TNtupleD.html:295,Usability,simpl,simple,295,". TNtupleD. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TNtupleD. class TNtupleD: public TTree. TNtupleD. A simple tree restricted to a list of double variables only. Each variable goes to a separate branch. A Ntuple is created via; TNtupleD(name,title,varlist,bufsize); It is filled via:; TNtupleD::Fill(*x) or; TNtupleD::Fill(v1,v2,v3.....). Function Members (Methods); public:. virtual~TNtupleD(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTTree::AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tTTree::AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*TTree::AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*TTree::AddFriend(const char* treename, TFile* file); virtual TFriendElement*TTree::AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidTTree::AddTotBytes(Int_t tot); virtual voidTTree::AddZipBytes(Int_t zip); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long64_tTTree::AutoSave(Option_t* option = """"); virtual Int_tTTree::Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tTTree::Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tTTree::Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); virtual TBranch*TTree::Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, char* address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, Long_t address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, int address, const char* leaflist, Int_t bufsize = 32000); virtual TBranch*T",MatchSource.WIKI,root/html604/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtupleD.html
https://root.cern/root/html604/TNtupleD.html:3337,Usability,undo,undo,3337,"t splitlevel = 99); virtual TBranch*TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser* b); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObjec",MatchSource.WIKI,root/html604/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TNtupleD.html
https://root.cern/root/html604/TObjArray.html:3570,Availability,error,error,3570,"ollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidCompress(); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExpand(Int_t newSize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEntries() const; Int_tGetEntriesFast() const; virtual const char*TObject::GetIconName() const; virtual Int_tGetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TObject**GetObjectRef() const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*",MatchSource.WIKI,root/html604/TObjArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjArray.html
https://root.cern/root/html604/TObjArray.html:3654,Availability,error,error,3654,"sName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidCompress(); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExpand(Int_t newSize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEntries() const; Int_tGetEntriesFast() const; virtual const char*TObject::GetIconName() const; virtual Int_tGetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TObject**GetObjectRef() const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; virtual const",MatchSource.WIKI,root/html604/TObjArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjArray.html
https://root.cern/root/html604/TObjArray.html:13336,Availability,error,error,13336,"nsertion semantics; use either a TList or a TOrdCollection. void AddLast(TObject* obj); Add object in the next empty slot in the array. Expand the array; if necessary. void AddBefore(const TObject* before, TObject* obj); Add object in the slot before object before. If before=0 add object; in the first slot. Note that this will overwrite any object that; might have already been in this slot. For insertion semantics use; either a TList or a TOrdCollection. void AddAfter(const TObject* after, TObject* obj); Add object in the slot after object after. If after=0 add object in; the last empty slot. Note that this will overwrite any object that; might have already been in this slot. For insertion semantics use; either a TList or a TOrdCollection. void AddAtAndExpand(TObject* obj, Int_t idx); Add object at position idx. If idx is larger than the current size; of the array, expand the array (double its size). void AddAt(TObject* obj, Int_t idx); Add object at position ids. Give an error when idx is out of bounds; (i.e. the array is not expanded). Int_t AddAtFree(TObject* obj); Return the position of the new object.; Find the first empty cell or AddLast if there is no empty cell. TObject * After(const TObject* obj) const; Return the object after obj. Returns 0 if obj is last object. TObject * Before(const TObject* obj) const; Return the object before obj. Returns 0 if obj is first object. void Clear(Option_t* option = """"); Remove all objects from the array. Does not delete the objects; unless the TObjArray is the owner (set via SetOwner()). void Compress(); Remove empty slots from array. void Delete(Option_t* option = """"); Remove all objects from the array AND delete all heap based objects. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. TObject * FindObject(const char* name) const; Find an object in this collection using its name. Requires a sequential; scan till the object has been found. Returns 0 if object with specified; name is not found. TObj",MatchSource.WIKI,root/html604/TObjArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjArray.html
https://root.cern/root/html604/TObjArray.html:16137,Availability,error,error,16137,"mpty slots. This function loops over the complete array and; is therefore very slow when applied in a loop. Most of the time you; better use GetEntriesFast() (only in case when there are no empty slots). Int_t GetAbsLast() const; Return absolute index to last object in array. Returns -1 in case; array is empty. Int_t GetLast() const; Return index of last object in array. Returns lowerBound-1 in case; array is empty. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer obj. If obj is 0 returns address of container. Int_t IndexOf(const TObject* obj) const; obj != 0 Return index of object in array.; Returns lowerBound-1 in case array doesn't contain the obj. obj == 0 Return the index of the first empty slot.; Returns lowerBound-1 in case array doesn't contain any empty slot. void Init(Int_t s, Int_t lowerBound); Initialize a TObjArray. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns an array iterator. Bool_t OutOfBoundsError(const char* where, Int_t i) const; Generate an out-of-bounds error. Always returns false. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections). TObject * RemoveAt(Int_t idx); Remove object at index idx. TObject * Remove(TObject* obj); Remove object from array. void RemoveRange(Int_t idx1, Int_t idx2); Remove objects from index idx1 to idx2 included. void SetLast(Int_t last); Set index of last object in array, effectively truncating the; array. Use carefully since whenever last position has to be; recalculated, e.g. after a Remove() or Sort() it will be reset; to the last non-empty slot. If last is -2 this will force the; recalculation of the last used slot.; If last is -1, this effectively truncate the array completely. void Randomize(Int_t ntimes = 1); Randomize objects inside the array, i.e. permute randomly objects.; With fLast being the index of the last entry in the array, the following; algorithm is applied ",MatchSource.WIKI,root/html604/TObjArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjArray.html
https://root.cern/root/html604/TObjArray.html:14618,Energy Efficiency,efficient,efficient,14618," if obj is last object. TObject * Before(const TObject* obj) const; Return the object before obj. Returns 0 if obj is first object. void Clear(Option_t* option = """"); Remove all objects from the array. Does not delete the objects; unless the TObjArray is the owner (set via SetOwner()). void Compress(); Remove empty slots from array. void Delete(Option_t* option = """"); Remove all objects from the array AND delete all heap based objects. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. TObject * FindObject(const char* name) const; Find an object in this collection using its name. Requires a sequential; scan till the object has been found. Returns 0 if object with specified; name is not found. TObject * FindObject(const TObject* obj) const; Find an object in this collection using the object's IsEqual(); member function. Requires a sequential scan till the object has; been found. Returns 0 if object is not found.; Typically this function is overridden by a more efficient version; in concrete collection classes (e.g. THashTable). void Streamer(TBuffer& ); Stream all objects in the array to or from the I/O buffer. TObject * First() const; Return the object in the first slot. TObject * Last() const; Return the object in the last filled slot. Returns 0 if no entries. Int_t GetEntries() const; Return the number of objects in array (i.e. number of non-empty slots).; Attention: use this method ONLY if you want to know the number of; non-empty slots. This function loops over the complete array and; is therefore very slow when applied in a loop. Most of the time you; better use GetEntriesFast() (only in case when there are no empty slots). Int_t GetAbsLast() const; Return absolute index to last object in array. Returns -1 in case; array is empty. Int_t GetLast() const; Return index of last object in array. Returns lowerBound-1 in case; array is empty. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer obj. If obj is 0 returns a",MatchSource.WIKI,root/html604/TObjArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjArray.html
https://root.cern/root/html604/TObject.html:436,Availability,error,error,436,". TObject. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObject. class TObject. TObject. Mother of all ROOT objects. The TObject class provides default behaviour and protocol for all; objects in the ROOT system. It provides protocol for object I/O,; error handling, sorting, inspection, printing, drawing, etc.; Every object which inherits from TObject can be stored in the; ROOT collection classes.; TObject's bits can be used as flags, bits 0 - 13 and 24-31 are; reserved as global bits while bits 14 - 23 can be used in different; class hierarchies (watch out for overlaps). Function Members (Methods); public:. virtual~TObject(); voidAbstractMethod(const char* method) const; virtual voidAppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidCopy(TObject& object) const; virtual voidDelete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidDrawClass() constMENU ; virtual TObject*DrawClone(Option_t* option = """") constMENU ; virtual voidDump() constMENU ; virtual voidError(const char* method, const char* msgfmt) const; virtual voidExecute(const char* method, const char* params, Int_t* error = 0); virtual voidExecute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual Option_t*GetDrawOption() const; static Long_tGetDtorOnly(); virtual const char*GetIconNa",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:1588,Availability,error,error,1588," virtual~TObject(); voidAbstractMethod(const char* method) const; virtual voidAppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidCopy(TObject& object) const; virtual voidDelete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidDrawClass() constMENU ; virtual TObject*DrawClone(Option_t* option = """") constMENU ; virtual voidDump() constMENU ; virtual voidError(const char* method, const char* msgfmt) const; virtual voidExecute(const char* method, const char* params, Int_t* error = 0); virtual voidExecute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual Option_t*GetDrawOption() const; static Long_tGetDtorOnly(); virtual const char*GetIconNa",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:1663,Availability,error,error,1663," virtual~TObject(); voidAbstractMethod(const char* method) const; virtual voidAppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidCopy(TObject& object) const; virtual voidDelete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidDrawClass() constMENU ; virtual TObject*DrawClone(Option_t* option = """") constMENU ; virtual voidDump() constMENU ; virtual voidError(const char* method, const char* msgfmt) const; virtual voidExecute(const char* method, const char* params, Int_t* error = 0); virtual voidExecute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual Option_t*GetDrawOption() const; static Long_tGetDtorOnly(); virtual const char*GetIconNa",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:8951,Availability,error,error,8951,"e shown in class A with a blue line; crossing-out the corresponding member function.; The following picture is the class inheritance tree of class TPaveLabel:. /*; ; */. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this object in the current pad. void Dump() const; Dump contents of object on stdout.; Using the information in the object dictionary (class TClass); each data member is interpreted.; If a data member is a pointer, the pointer value is printed. The following output is the Dump of a TArrow object:; fAngle 0 Arrow opening angle (degrees); fArrowSize 0.2 Arrow Size; fOption.*fData; fX1 0.1 X of 1st point; fY1 0.15 Y of 1st point; fX2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; fFillStyle 1001 fill area style. void Execute(const char* method, const char* params, Int_t* error = 0); Execute method on this object with the given parameter string, e.g.; ""3.14,1,\""text\"""". void Execute(TMethod* method, TObjArray* params, Int_t* error = 0); Execute method on this object with parameters stored in the TObjArray.; The TObjArray should contain an argv vector like:. argv[0] ... argv[n] = the list of TObjString parameters. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to an event at (px,py). This method; must be overridden if an object can react to graphics events. TObject * FindObject(const char* name) const; Must be redefined in derived classes.; This function is typycally used with TCollections, but can also be used; to find an object by name inside this object. TObject * FindObject(const TObject* obj) const; Must be redefined in derived classes.; This function is typycally used with TCollections, but can also be used; to find an object inside this object. Option_t * GetDrawOption() const; Get option used by the graphics system to dr",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:9107,Availability,error,error,9107,"/*; ; */. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this object in the current pad. void Dump() const; Dump contents of object on stdout.; Using the information in the object dictionary (class TClass); each data member is interpreted.; If a data member is a pointer, the pointer value is printed. The following output is the Dump of a TArrow object:; fAngle 0 Arrow opening angle (degrees); fArrowSize 0.2 Arrow Size; fOption.*fData; fX1 0.1 X of 1st point; fY1 0.15 Y of 1st point; fX2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; fFillStyle 1001 fill area style. void Execute(const char* method, const char* params, Int_t* error = 0); Execute method on this object with the given parameter string, e.g.; ""3.14,1,\""text\"""". void Execute(TMethod* method, TObjArray* params, Int_t* error = 0); Execute method on this object with parameters stored in the TObjArray.; The TObjArray should contain an argv vector like:. argv[0] ... argv[n] = the list of TObjString parameters. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to an event at (px,py). This method; must be overridden if an object can react to graphics events. TObject * FindObject(const char* name) const; Must be redefined in derived classes.; This function is typycally used with TCollections, but can also be used; to find an object by name inside this object. TObject * FindObject(const TObject* obj) const; Must be redefined in derived classes.; This function is typycally used with TCollections, but can also be used; to find an object inside this object. Option_t * GetDrawOption() const; Get option used by the graphics system to draw this object.; Note that before calling object.GetDrawOption(), you must; have called object.Draw(..) before in the current pad. const char * GetName() const; ",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:14191,Availability,avail,available,14191,"ely remove this object from a list. Typically implemented; by classes that can contain mulitple references to a same object. void SaveAs(const char* filename = """", Option_t* option = """") const; Save this object in the file specified by filename. - if ""filename"" contains "".root"" the object is saved in filename as root; binary file. - if ""filename"" contains "".xml"" the object is saved in filename as a xml; ascii file. - if ""filename"" contains "".cc"" the object is saved in filename as C code; independant from ROOT. The code is generated via SavePrimitive().; Specific code should be implemented in each object to handle this; option. Like in TF1::SavePrimitive(). - otherwise the object is written to filename as a CINT/C++ script. The; C++ code to rebuild this object is generated via SavePrimitive(). The; ""option"" parameter is passed to SavePrimitive. By default it is an empty; string. It can be used to specify the Draw option in the code generated; by SavePrimitive. The function is available via the object context menu. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDrawOption(Option_t* option = """"); Set drawing option for object. This option only affects; the drawing style and is stored in the option field of the; TObjOptLink supporting a TPad's primitive list (TList).; Note that it does not make sense to call object.SetDrawOption(option); before having called object.Draw(). void SetBit(UInt_t f, Bool_t set); Set or unset the user status bits as specified in f. void SetUniqueID(UInt_t uid); Set the unique object id. void UseCurrentStyle(); Set current style settings in this object; This function is called when either TCanvas::UseCurrentStyle; or TROOT::ForceStyle have been invoked. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Write this object to the current directory.; The data structure corresponding to this object is serialized.; The corresponding buffer is ",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:17637,Availability,error,error,17637,"bject is read from the file into memory via TKey::Read() or; via TObject::Read(). The function returns the total number of bytes written to the file.; It returns 0 if the object cannot be written. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write this object to the current directory. For more see the; const version of this method. void Streamer(TBuffer& ); Stream an object of class TObject. void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). void Info(const char *location, const char *va_(fmt), ...); Issue info message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Warning(const char *location, const char *va_(fmt), ...); Issue warning message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Error(const char *location, const char *va_(fmt), ...); Issue error message. Use ""location"" to specify the method where the; error occured. Accepts standard printf formatting arguments. void SysError(const char *location, const char *va_(fmt), ...); Issue system error message. Use ""location"" to specify the method where; the system error occured. Accepts standard printf formatting arguments. void Fatal(const char *location, const char *va_(fmt), ...); Issue fatal error message. Use ""location"" to specify the method where the; fatal error occured. Accepts standard printf formatting arguments. void AbstractMethod(const char* method) const; Use this method to implement an ""abstract"" method that you don't; want to leave purely abstract. void MayNotUse(const char* method) const; Use this method to signal that a method (defined in a base class); may not be called in a derived class (in principle against good; design since a child class should not provide less functionality; than its parent, however, sometimes it is necessary). void Obsolete(const char* meth",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:17700,Availability,error,error,17700," TKey::Read() or; via TObject::Read(). The function returns the total number of bytes written to the file.; It returns 0 if the object cannot be written. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write this object to the current directory. For more see the; const version of this method. void Streamer(TBuffer& ); Stream an object of class TObject. void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). void Info(const char *location, const char *va_(fmt), ...); Issue info message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Warning(const char *location, const char *va_(fmt), ...); Issue warning message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Error(const char *location, const char *va_(fmt), ...); Issue error message. Use ""location"" to specify the method where the; error occured. Accepts standard printf formatting arguments. void SysError(const char *location, const char *va_(fmt), ...); Issue system error message. Use ""location"" to specify the method where; the system error occured. Accepts standard printf formatting arguments. void Fatal(const char *location, const char *va_(fmt), ...); Issue fatal error message. Use ""location"" to specify the method where the; fatal error occured. Accepts standard printf formatting arguments. void AbstractMethod(const char* method) const; Use this method to implement an ""abstract"" method that you don't; want to leave purely abstract. void MayNotUse(const char* method) const; Use this method to signal that a method (defined in a base class); may not be called in a derived class (in principle against good; design since a child class should not provide less functionality; than its parent, however, sometimes it is necessary). void Obsolete(const char* method, const char* asOfVers, const char* remov",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:17838,Availability,error,error,17838,"nt_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write this object to the current directory. For more see the; const version of this method. void Streamer(TBuffer& ); Stream an object of class TObject. void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). void Info(const char *location, const char *va_(fmt), ...); Issue info message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Warning(const char *location, const char *va_(fmt), ...); Issue warning message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Error(const char *location, const char *va_(fmt), ...); Issue error message. Use ""location"" to specify the method where the; error occured. Accepts standard printf formatting arguments. void SysError(const char *location, const char *va_(fmt), ...); Issue system error message. Use ""location"" to specify the method where; the system error occured. Accepts standard printf formatting arguments. void Fatal(const char *location, const char *va_(fmt), ...); Issue fatal error message. Use ""location"" to specify the method where the; fatal error occured. Accepts standard printf formatting arguments. void AbstractMethod(const char* method) const; Use this method to implement an ""abstract"" method that you don't; want to leave purely abstract. void MayNotUse(const char* method) const; Use this method to signal that a method (defined in a base class); may not be called in a derived class (in principle against good; design since a child class should not provide less functionality; than its parent, however, sometimes it is necessary). void Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; Use this method to declare a method obsolete. Specify as of which version; the method is obsolete and as from which version it will be ",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:17908,Availability,error,error,17908," Int_t bufsize = 0); Write this object to the current directory. For more see the; const version of this method. void Streamer(TBuffer& ); Stream an object of class TObject. void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). void Info(const char *location, const char *va_(fmt), ...); Issue info message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Warning(const char *location, const char *va_(fmt), ...); Issue warning message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Error(const char *location, const char *va_(fmt), ...); Issue error message. Use ""location"" to specify the method where the; error occured. Accepts standard printf formatting arguments. void SysError(const char *location, const char *va_(fmt), ...); Issue system error message. Use ""location"" to specify the method where; the system error occured. Accepts standard printf formatting arguments. void Fatal(const char *location, const char *va_(fmt), ...); Issue fatal error message. Use ""location"" to specify the method where the; fatal error occured. Accepts standard printf formatting arguments. void AbstractMethod(const char* method) const; Use this method to implement an ""abstract"" method that you don't; want to leave purely abstract. void MayNotUse(const char* method) const; Use this method to signal that a method (defined in a base class); may not be called in a derived class (in principle against good; design since a child class should not provide less functionality; than its parent, however, sometimes it is necessary). void Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; Use this method to declare a method obsolete. Specify as of which version; the method is obsolete and as from which version it will be removed. Bool_t GetObjectStat(); Get status of obj",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:18042,Availability,error,error,18042,"t of class TObject. void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). void Info(const char *location, const char *va_(fmt), ...); Issue info message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Warning(const char *location, const char *va_(fmt), ...); Issue warning message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Error(const char *location, const char *va_(fmt), ...); Issue error message. Use ""location"" to specify the method where the; error occured. Accepts standard printf formatting arguments. void SysError(const char *location, const char *va_(fmt), ...); Issue system error message. Use ""location"" to specify the method where; the system error occured. Accepts standard printf formatting arguments. void Fatal(const char *location, const char *va_(fmt), ...); Issue fatal error message. Use ""location"" to specify the method where the; fatal error occured. Accepts standard printf formatting arguments. void AbstractMethod(const char* method) const; Use this method to implement an ""abstract"" method that you don't; want to leave purely abstract. void MayNotUse(const char* method) const; Use this method to signal that a method (defined in a base class); may not be called in a derived class (in principle against good; design since a child class should not provide less functionality; than its parent, however, sometimes it is necessary). void Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; Use this method to declare a method obsolete. Specify as of which version; the method is obsolete and as from which version it will be removed. Bool_t GetObjectStat(); Get status of object stat flag. void SetObjectStat(Bool_t stat); Turn on/off tracking of objects in the TObjectTable. Long_t GetDtorOnly(); return destructor only flag. voi",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:18111,Availability,error,error,18111," char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). void Info(const char *location, const char *va_(fmt), ...); Issue info message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Warning(const char *location, const char *va_(fmt), ...); Issue warning message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Error(const char *location, const char *va_(fmt), ...); Issue error message. Use ""location"" to specify the method where the; error occured. Accepts standard printf formatting arguments. void SysError(const char *location, const char *va_(fmt), ...); Issue system error message. Use ""location"" to specify the method where; the system error occured. Accepts standard printf formatting arguments. void Fatal(const char *location, const char *va_(fmt), ...); Issue fatal error message. Use ""location"" to specify the method where the; fatal error occured. Accepts standard printf formatting arguments. void AbstractMethod(const char* method) const; Use this method to implement an ""abstract"" method that you don't; want to leave purely abstract. void MayNotUse(const char* method) const; Use this method to signal that a method (defined in a base class); may not be called in a derived class (in principle against good; design since a child class should not provide less functionality; than its parent, however, sometimes it is necessary). void Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; Use this method to declare a method obsolete. Specify as of which version; the method is obsolete and as from which version it will be removed. Bool_t GetObjectStat(); Get status of object stat flag. void SetObjectStat(Bool_t stat); Turn on/off tracking of objects in the TObjectTable. Long_t GetDtorOnly(); return destructor only flag. void SetDtorOnly(void* obj); set destructor only fla",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:5696,Energy Efficiency,allocate,allocated,5696,"tic TObject::EStatusBitskCannotPick; static TObject::EStatusBitskHasUUID; static TObject::EStatusBitskInvalidObject; static TObject::(anonymous)kIsOnHeap; static TObject::EStatusBitskIsReferenced; static TObject::EStatusBitskMustCleanup; static TObject::EStatusBitskNoContextMenu; static TObject::(anonymous)kNotDeleted; static TObject::EStatusBitskObjInCanvas; static TObject::(anonymous)kOverwrite; static TObject::(anonymous)kSingleKey; static TObject::(anonymous)kWriteDelete; static TObject::(anonymous)kZombie. private:. UInt_tfBitsbit field status word; UInt_tfUniqueIDobject unique identifier; static Long_tfgDtorOnlyobject for which to call dtor only (i.e. no delete); static Bool_tfgObjectStatif true keep track of objects in TObjectTable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TObject(); TObject constructor. It sets the two data words of TObject to their; initial values. The unique ID is set to 0 and the status word is; set depending if the object is created on the stack or allocated; on the heap. Depending on the ROOT environment variable ""Root.MemStat""; (see TEnv) the object is added to the global TObjectTable for; bookkeeping. TObject(const TObject& object); TObject copy ctor. TObject& operator=(const TObject& rhs); TObject assignment operator. void Copy(TObject& object) const; Copy this to obj. ~TObject(); TObject destructor. Removes object from all canvases and object browsers; if observer bit is on and remove from the global object table. void AppendPad(Option_t* option = """"); Append graphics object to current pad. In case no current pad is set; yet, create a default canvas with the name ""c1"". void Browse(TBrowser* b); Browse object. May be overridden for another default action. const char * ClassName() const; Returns name of class to which the object belongs. TObject * Clone(const char* newname = """") const; Make a clone of an object using the Streamer facility.; If the object derives from TNamed, this functi",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:7405,Energy Efficiency,allocate,allocated,7405,"den for another default action. const char * ClassName() const; Returns name of class to which the object belongs. TObject * Clone(const char* newname = """") const; Make a clone of an object using the Streamer facility.; If the object derives from TNamed, this function is called; by TNamed::Clone. TNamed::Clone uses the optional argument to set; a new name to the newly created object. If the object class has a DirectoryAutoAdd function, it will be; called at the end of the function with the parameter gDirectory.; This usually means that the object will be appended to the current; ROOT directory. Int_t Compare(const TObject* obj) const; Compare abstract method. Must be overridden if a class wants to be able; to compare itself with other objects. Must return -1 if this is smaller; than obj, 0 if objects are equal and 1 if this is larger than obj. void Delete(Option_t* option = """"); Delete this object. Typically called as a command via the interpreter.; Normally use ""delete"" operator when object has been allocated on the heap. Int_t DistancetoPrimitive(Int_t px, Int_t py); Computes distance from point (px,py) to the object.; This member function must be implemented for each graphics primitive.; This default function returns a big number (999999). void Draw(Option_t* option = """"); Default Draw method for all objects. void DrawClass() const; Draw class inheritance tree of the class to which this object belongs.; If a class B inherits from a class A, description of B is drawn; on the right side of description of A.; Member functions overridden by B are shown in class A with a blue line; crossing-out the corresponding member function.; The following picture is the class inheritance tree of class TPaveLabel:. /*; ; */. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this object in the current pad. void Dump() const; Dump contents of object on stdout.; Using the information in the object dictionary (class TClass); each data member is interpreted.; If a data ",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:352,Integrability,protocol,protocol,352,". TObject. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObject. class TObject. TObject. Mother of all ROOT objects. The TObject class provides default behaviour and protocol for all; objects in the ROOT system. It provides protocol for object I/O,; error handling, sorting, inspection, printing, drawing, etc.; Every object which inherits from TObject can be stored in the; ROOT collection classes.; TObject's bits can be used as flags, bits 0 - 13 and 24-31 are; reserved as global bits while bits 14 - 23 can be used in different; class hierarchies (watch out for overlaps). Function Members (Methods); public:. virtual~TObject(); voidAbstractMethod(const char* method) const; virtual voidAppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidCopy(TObject& object) const; virtual voidDelete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidDrawClass() constMENU ; virtual TObject*DrawClone(Option_t* option = """") constMENU ; virtual voidDump() constMENU ; virtual voidError(const char* method, const char* msgfmt) const; virtual voidExecute(const char* method, const char* params, Int_t* error = 0); virtual voidExecute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual Option_t*GetDrawOption() const; static Long_tGetDtorOnly(); virtual const char*GetIconNa",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:410,Integrability,protocol,protocol,410,". TObject. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObject. class TObject. TObject. Mother of all ROOT objects. The TObject class provides default behaviour and protocol for all; objects in the ROOT system. It provides protocol for object I/O,; error handling, sorting, inspection, printing, drawing, etc.; Every object which inherits from TObject can be stored in the; ROOT collection classes.; TObject's bits can be used as flags, bits 0 - 13 and 24-31 are; reserved as global bits while bits 14 - 23 can be used in different; class hierarchies (watch out for overlaps). Function Members (Methods); public:. virtual~TObject(); voidAbstractMethod(const char* method) const; virtual voidAppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidCopy(TObject& object) const; virtual voidDelete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidDrawClass() constMENU ; virtual TObject*DrawClone(Option_t* option = """") constMENU ; virtual voidDump() constMENU ; virtual voidError(const char* method, const char* msgfmt) const; virtual voidExecute(const char* method, const char* params, Int_t* error = 0); virtual voidExecute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual Option_t*GetDrawOption() const; static Long_tGetDtorOnly(); virtual const char*GetIconNa",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:5645,Integrability,depend,depending,5645,"tic TObject::EStatusBitskCannotPick; static TObject::EStatusBitskHasUUID; static TObject::EStatusBitskInvalidObject; static TObject::(anonymous)kIsOnHeap; static TObject::EStatusBitskIsReferenced; static TObject::EStatusBitskMustCleanup; static TObject::EStatusBitskNoContextMenu; static TObject::(anonymous)kNotDeleted; static TObject::EStatusBitskObjInCanvas; static TObject::(anonymous)kOverwrite; static TObject::(anonymous)kSingleKey; static TObject::(anonymous)kWriteDelete; static TObject::(anonymous)kZombie. private:. UInt_tfBitsbit field status word; UInt_tfUniqueIDobject unique identifier; static Long_tfgDtorOnlyobject for which to call dtor only (i.e. no delete); static Bool_tfgObjectStatif true keep track of objects in TObjectTable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TObject(); TObject constructor. It sets the two data words of TObject to their; initial values. The unique ID is set to 0 and the status word is; set depending if the object is created on the stack or allocated; on the heap. Depending on the ROOT environment variable ""Root.MemStat""; (see TEnv) the object is added to the global TObjectTable for; bookkeeping. TObject(const TObject& object); TObject copy ctor. TObject& operator=(const TObject& rhs); TObject assignment operator. void Copy(TObject& object) const; Copy this to obj. ~TObject(); TObject destructor. Removes object from all canvases and object browsers; if observer bit is on and remove from the global object table. void AppendPad(Option_t* option = """"); Append graphics object to current pad. In case no current pad is set; yet, create a default canvas with the name ""c1"". void Browse(TBrowser* b); Browse object. May be overridden for another default action. const char * ClassName() const; Returns name of class to which the object belongs. TObject * Clone(const char* newname = """") const; Make a clone of an object using the Streamer facility.; If the object derives from TNamed, this functi",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:17253,Integrability,message,message,17253,"us key is deleted before writing the new object.; Using the kWriteDelete option a previous key with the same name is; deleted only after the new object has been written. This option; is safer than kOverwrite but it is slower.; The kSingleKey option is only used by TCollection::Write() to write; a container with a single key instead of each object in the container; with its own key. An object is read from the file into memory via TKey::Read() or; via TObject::Read(). The function returns the total number of bytes written to the file.; It returns 0 if the object cannot be written. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write this object to the current directory. For more see the; const version of this method. void Streamer(TBuffer& ); Stream an object of class TObject. void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). void Info(const char *location, const char *va_(fmt), ...); Issue info message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Warning(const char *location, const char *va_(fmt), ...); Issue warning message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Error(const char *location, const char *va_(fmt), ...); Issue error message. Use ""location"" to specify the method where the; error occured. Accepts standard printf formatting arguments. void SysError(const char *location, const char *va_(fmt), ...); Issue system error message. Use ""location"" to specify the method where; the system error occured. Accepts standard printf formatting arguments. void Fatal(const char *location, const char *va_(fmt), ...); Issue fatal error message. Use ""location"" to specify the method where the; fatal error occured. Accepts standard printf formatting arguments. void AbstractMethod(const char* method) const; Use this method to implement an",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:17450,Integrability,message,message,17450,"n kOverwrite but it is slower.; The kSingleKey option is only used by TCollection::Write() to write; a container with a single key instead of each object in the container; with its own key. An object is read from the file into memory via TKey::Read() or; via TObject::Read(). The function returns the total number of bytes written to the file.; It returns 0 if the object cannot be written. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write this object to the current directory. For more see the; const version of this method. void Streamer(TBuffer& ); Stream an object of class TObject. void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). void Info(const char *location, const char *va_(fmt), ...); Issue info message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Warning(const char *location, const char *va_(fmt), ...); Issue warning message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Error(const char *location, const char *va_(fmt), ...); Issue error message. Use ""location"" to specify the method where the; error occured. Accepts standard printf formatting arguments. void SysError(const char *location, const char *va_(fmt), ...); Issue system error message. Use ""location"" to specify the method where; the system error occured. Accepts standard printf formatting arguments. void Fatal(const char *location, const char *va_(fmt), ...); Issue fatal error message. Use ""location"" to specify the method where the; fatal error occured. Accepts standard printf formatting arguments. void AbstractMethod(const char* method) const; Use this method to implement an ""abstract"" method that you don't; want to leave purely abstract. void MayNotUse(const char* method) const; Use this method to signal that a method (defined in a base class); may not be called in ",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:17643,Integrability,message,message,17643,"bject is read from the file into memory via TKey::Read() or; via TObject::Read(). The function returns the total number of bytes written to the file.; It returns 0 if the object cannot be written. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write this object to the current directory. For more see the; const version of this method. void Streamer(TBuffer& ); Stream an object of class TObject. void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). void Info(const char *location, const char *va_(fmt), ...); Issue info message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Warning(const char *location, const char *va_(fmt), ...); Issue warning message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Error(const char *location, const char *va_(fmt), ...); Issue error message. Use ""location"" to specify the method where the; error occured. Accepts standard printf formatting arguments. void SysError(const char *location, const char *va_(fmt), ...); Issue system error message. Use ""location"" to specify the method where; the system error occured. Accepts standard printf formatting arguments. void Fatal(const char *location, const char *va_(fmt), ...); Issue fatal error message. Use ""location"" to specify the method where the; fatal error occured. Accepts standard printf formatting arguments. void AbstractMethod(const char* method) const; Use this method to implement an ""abstract"" method that you don't; want to leave purely abstract. void MayNotUse(const char* method) const; Use this method to signal that a method (defined in a base class); may not be called in a derived class (in principle against good; design since a child class should not provide less functionality; than its parent, however, sometimes it is necessary). void Obsolete(const char* meth",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:17844,Integrability,message,message,17844,"nt_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write this object to the current directory. For more see the; const version of this method. void Streamer(TBuffer& ); Stream an object of class TObject. void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). void Info(const char *location, const char *va_(fmt), ...); Issue info message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Warning(const char *location, const char *va_(fmt), ...); Issue warning message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Error(const char *location, const char *va_(fmt), ...); Issue error message. Use ""location"" to specify the method where the; error occured. Accepts standard printf formatting arguments. void SysError(const char *location, const char *va_(fmt), ...); Issue system error message. Use ""location"" to specify the method where; the system error occured. Accepts standard printf formatting arguments. void Fatal(const char *location, const char *va_(fmt), ...); Issue fatal error message. Use ""location"" to specify the method where the; fatal error occured. Accepts standard printf formatting arguments. void AbstractMethod(const char* method) const; Use this method to implement an ""abstract"" method that you don't; want to leave purely abstract. void MayNotUse(const char* method) const; Use this method to signal that a method (defined in a base class); may not be called in a derived class (in principle against good; design since a child class should not provide less functionality; than its parent, however, sometimes it is necessary). void Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; Use this method to declare a method obsolete. Specify as of which version; the method is obsolete and as from which version it will be ",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:18048,Integrability,message,message,18048,"t of class TObject. void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). void Info(const char *location, const char *va_(fmt), ...); Issue info message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Warning(const char *location, const char *va_(fmt), ...); Issue warning message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Error(const char *location, const char *va_(fmt), ...); Issue error message. Use ""location"" to specify the method where the; error occured. Accepts standard printf formatting arguments. void SysError(const char *location, const char *va_(fmt), ...); Issue system error message. Use ""location"" to specify the method where; the system error occured. Accepts standard printf formatting arguments. void Fatal(const char *location, const char *va_(fmt), ...); Issue fatal error message. Use ""location"" to specify the method where the; fatal error occured. Accepts standard printf formatting arguments. void AbstractMethod(const char* method) const; Use this method to implement an ""abstract"" method that you don't; want to leave purely abstract. void MayNotUse(const char* method) const; Use this method to signal that a method (defined in a base class); may not be called in a derived class (in principle against good; design since a child class should not provide less functionality; than its parent, however, sometimes it is necessary). void Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; Use this method to declare a method obsolete. Specify as of which version; the method is obsolete and as from which version it will be removed. Bool_t GetObjectStat(); Get status of object stat flag. void SetObjectStat(Bool_t stat); Turn on/off tracking of objects in the TObjectTable. Long_t GetDtorOnly(); return destructor only flag. voi",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:517,Modifiability,inherit,inherits,517,". TObject. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObject. class TObject. TObject. Mother of all ROOT objects. The TObject class provides default behaviour and protocol for all; objects in the ROOT system. It provides protocol for object I/O,; error handling, sorting, inspection, printing, drawing, etc.; Every object which inherits from TObject can be stored in the; ROOT collection classes.; TObject's bits can be used as flags, bits 0 - 13 and 24-31 are; reserved as global bits while bits 14 - 23 can be used in different; class hierarchies (watch out for overlaps). Function Members (Methods); public:. virtual~TObject(); voidAbstractMethod(const char* method) const; virtual voidAppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidCopy(TObject& object) const; virtual voidDelete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidDrawClass() constMENU ; virtual TObject*DrawClone(Option_t* option = """") constMENU ; virtual voidDump() constMENU ; virtual voidError(const char* method, const char* msgfmt) const; virtual voidExecute(const char* method, const char* params, Int_t* error = 0); virtual voidExecute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual Option_t*GetDrawOption() const; static Long_tGetDtorOnly(); virtual const char*GetIconNa",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:5754,Modifiability,variab,variable,5754,"EStatusBitskInvalidObject; static TObject::(anonymous)kIsOnHeap; static TObject::EStatusBitskIsReferenced; static TObject::EStatusBitskMustCleanup; static TObject::EStatusBitskNoContextMenu; static TObject::(anonymous)kNotDeleted; static TObject::EStatusBitskObjInCanvas; static TObject::(anonymous)kOverwrite; static TObject::(anonymous)kSingleKey; static TObject::(anonymous)kWriteDelete; static TObject::(anonymous)kZombie. private:. UInt_tfBitsbit field status word; UInt_tfUniqueIDobject unique identifier; static Long_tfgDtorOnlyobject for which to call dtor only (i.e. no delete); static Bool_tfgObjectStatif true keep track of objects in TObjectTable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TObject(); TObject constructor. It sets the two data words of TObject to their; initial values. The unique ID is set to 0 and the status word is; set depending if the object is created on the stack or allocated; on the heap. Depending on the ROOT environment variable ""Root.MemStat""; (see TEnv) the object is added to the global TObjectTable for; bookkeeping. TObject(const TObject& object); TObject copy ctor. TObject& operator=(const TObject& rhs); TObject assignment operator. void Copy(TObject& object) const; Copy this to obj. ~TObject(); TObject destructor. Removes object from all canvases and object browsers; if observer bit is on and remove from the global object table. void AppendPad(Option_t* option = """"); Append graphics object to current pad. In case no current pad is set; yet, create a default canvas with the name ""c1"". void Browse(TBrowser* b); Browse object. May be overridden for another default action. const char * ClassName() const; Returns name of class to which the object belongs. TObject * Clone(const char* newname = """") const; Make a clone of an object using the Streamer facility.; If the object derives from TNamed, this function is called; by TNamed::Clone. TNamed::Clone uses the optional argument to set; a new na",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:7758,Modifiability,inherit,inheritance,7758,"bject. If the object class has a DirectoryAutoAdd function, it will be; called at the end of the function with the parameter gDirectory.; This usually means that the object will be appended to the current; ROOT directory. Int_t Compare(const TObject* obj) const; Compare abstract method. Must be overridden if a class wants to be able; to compare itself with other objects. Must return -1 if this is smaller; than obj, 0 if objects are equal and 1 if this is larger than obj. void Delete(Option_t* option = """"); Delete this object. Typically called as a command via the interpreter.; Normally use ""delete"" operator when object has been allocated on the heap. Int_t DistancetoPrimitive(Int_t px, Int_t py); Computes distance from point (px,py) to the object.; This member function must be implemented for each graphics primitive.; This default function returns a big number (999999). void Draw(Option_t* option = """"); Default Draw method for all objects. void DrawClass() const; Draw class inheritance tree of the class to which this object belongs.; If a class B inherits from a class A, description of B is drawn; on the right side of description of A.; Member functions overridden by B are shown in class A with a blue line; crossing-out the corresponding member function.; The following picture is the class inheritance tree of class TPaveLabel:. /*; ; */. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this object in the current pad. void Dump() const; Dump contents of object on stdout.; Using the information in the object dictionary (class TClass); each data member is interpreted.; If a data member is a pointer, the pointer value is printed. The following output is the Dump of a TArrow object:; fAngle 0 Arrow opening angle (degrees); fArrowSize 0.2 Arrow Size; fOption.*fData; fX1 0.1 X of 1st point; fY1 0.15 Y of 1st point; fX2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line ",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:7832,Modifiability,inherit,inherits,7832,"ction with the parameter gDirectory.; This usually means that the object will be appended to the current; ROOT directory. Int_t Compare(const TObject* obj) const; Compare abstract method. Must be overridden if a class wants to be able; to compare itself with other objects. Must return -1 if this is smaller; than obj, 0 if objects are equal and 1 if this is larger than obj. void Delete(Option_t* option = """"); Delete this object. Typically called as a command via the interpreter.; Normally use ""delete"" operator when object has been allocated on the heap. Int_t DistancetoPrimitive(Int_t px, Int_t py); Computes distance from point (px,py) to the object.; This member function must be implemented for each graphics primitive.; This default function returns a big number (999999). void Draw(Option_t* option = """"); Default Draw method for all objects. void DrawClass() const; Draw class inheritance tree of the class to which this object belongs.; If a class B inherits from a class A, description of B is drawn; on the right side of description of A.; Member functions overridden by B are shown in class A with a blue line; crossing-out the corresponding member function.; The following picture is the class inheritance tree of class TPaveLabel:. /*; ; */. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this object in the current pad. void Dump() const; Dump contents of object on stdout.; Using the information in the object dictionary (class TClass); each data member is interpreted.; If a data member is a pointer, the pointer value is printed. The following output is the Dump of a TArrow object:; fAngle 0 Arrow opening angle (degrees); fArrowSize 0.2 Arrow Size; fOption.*fData; fX1 0.1 X of 1st point; fY1 0.15 Y of 1st point; fX2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; fFillStyle 1",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:8080,Modifiability,inherit,inheritance,8080," class wants to be able; to compare itself with other objects. Must return -1 if this is smaller; than obj, 0 if objects are equal and 1 if this is larger than obj. void Delete(Option_t* option = """"); Delete this object. Typically called as a command via the interpreter.; Normally use ""delete"" operator when object has been allocated on the heap. Int_t DistancetoPrimitive(Int_t px, Int_t py); Computes distance from point (px,py) to the object.; This member function must be implemented for each graphics primitive.; This default function returns a big number (999999). void Draw(Option_t* option = """"); Default Draw method for all objects. void DrawClass() const; Draw class inheritance tree of the class to which this object belongs.; If a class B inherits from a class A, description of B is drawn; on the right side of description of A.; Member functions overridden by B are shown in class A with a blue line; crossing-out the corresponding member function.; The following picture is the class inheritance tree of class TPaveLabel:. /*; ; */. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this object in the current pad. void Dump() const; Dump contents of object on stdout.; Using the information in the object dictionary (class TClass); each data member is interpreted.; If a data member is a pointer, the pointer value is printed. The following output is the Dump of a TArrow object:; fAngle 0 Arrow opening angle (degrees); fArrowSize 0.2 Arrow Size; fOption.*fData; fX1 0.1 X of 1st point; fY1 0.15 Y of 1st point; fX2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; fFillStyle 1001 fill area style. void Execute(const char* method, const char* params, Int_t* error = 0); Execute method on this object with the given parameter string, e.g.; ""3.14,1,\""text\"""". void Execute(TMethod* method, ",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:11288,Modifiability,inherit,inherits,11288,"tIconName() const; Returns mime type name of object. Used by the TBrowser (via TGMimeTypes; class). Override for class of which you would like to have different; icons for objects of the same class. UInt_t GetUniqueID() const; Return the unique object id. char * GetObjectInfo(Int_t px, Int_t py) const; Returns string containing info about the object at position (px,py).; This method is typically overridden by classes of which the objects; can report peculiarities for different positions.; Returned string will be re-used (lock in MT environment). const char * GetTitle() const; Returns title of object. This default method returns the class title; (i.e. description). Classes that give objects a title should override; this method. Bool_t HandleTimer(TTimer* timer); Execute action in response of a timer timing out. This method; must be overridden if an object has to react to timers. ULong_t Hash() const; Return hash value for this object. Bool_t InheritsFrom(const char* classname) const; Returns kTRUE if object inherits from class ""classname"". Bool_t InheritsFrom(const TClass* cl) const; Returns kTRUE if object inherits from TClass cl. void Inspect() const; Dump contents of this object in a graphics canvas.; Same action as Dump but in a graphical form.; In addition pointers to other objects can be followed. The following picture is the Inspect of a histogram object:. /*; ; */. Bool_t IsFolder() const; Returns kTRUE in case object contains browsable objects (like containers; or lists of other objects). Bool_t IsEqual(const TObject* obj) const; Default equal comparison (objects are equal if they have the same; address in memory). More complicated classes might want to override; this function. void ls(Option_t* option = """") const; The ls function lists the contents of a class on stdout. Ls output; is typically much less verbose then Dump(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Paint(Option_t* option = """"); This method must be ove",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:11390,Modifiability,inherit,inherits,11390,"verride for class of which you would like to have different; icons for objects of the same class. UInt_t GetUniqueID() const; Return the unique object id. char * GetObjectInfo(Int_t px, Int_t py) const; Returns string containing info about the object at position (px,py).; This method is typically overridden by classes of which the objects; can report peculiarities for different positions.; Returned string will be re-used (lock in MT environment). const char * GetTitle() const; Returns title of object. This default method returns the class title; (i.e. description). Classes that give objects a title should override; this method. Bool_t HandleTimer(TTimer* timer); Execute action in response of a timer timing out. This method; must be overridden if an object has to react to timers. ULong_t Hash() const; Return hash value for this object. Bool_t InheritsFrom(const char* classname) const; Returns kTRUE if object inherits from class ""classname"". Bool_t InheritsFrom(const TClass* cl) const; Returns kTRUE if object inherits from TClass cl. void Inspect() const; Dump contents of this object in a graphics canvas.; Same action as Dump but in a graphical form.; In addition pointers to other objects can be followed. The following picture is the Inspect of a histogram object:. /*; ; */. Bool_t IsFolder() const; Returns kTRUE in case object contains browsable objects (like containers; or lists of other objects). Bool_t IsEqual(const TObject* obj) const; Default equal comparison (objects are equal if they have the same; address in memory). More complicated classes might want to override; this function. void ls(Option_t* option = """") const; The ls function lists the contents of a class on stdout. Ls output; is typically much less verbose then Dump(). Bool_t Notify(); This method must be overridden to handle object notifcation. void Paint(Option_t* option = """"); This method must be overridden if a class wants to paint itself.; The difference between Paint() and Draw() is that when a ",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:16436,Safety,safe,safer,16436,"uffer object is filled via the class::Streamer function. -If the file is compressed (default) a second buffer is created to; hold the compressed buffer. -Reservation of the corresponding space in the file by looking; in the TFree list of free blocks of the file. -The buffer is written to the file. Bufsize can be given to force a given buffer size to write this object.; By default, the buffersize will be taken from the average buffer size; of all objects written to the current file so far. If a name is specified, it will be the name of the key.; If name is not given, the name of the key will be the name as returned; by GetName(). The option can be a combination of:; kSingleKey, kOverwrite or kWriteDelete; Using the kOverwrite option a previous key with the same name is; overwritten. The previous key is deleted before writing the new object.; Using the kWriteDelete option a previous key with the same name is; deleted only after the new object has been written. This option; is safer than kOverwrite but it is slower.; The kSingleKey option is only used by TCollection::Write() to write; a container with a single key instead of each object in the container; with its own key. An object is read from the file into memory via TKey::Read() or; via TObject::Read(). The function returns the total number of bytes written to the file.; It returns 0 if the object cannot be written. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write this object to the current directory. For more see the; const version of this method. void Streamer(TBuffer& ); Stream an object of class TObject. void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). void Info(const char *location, const char *va_(fmt), ...); Issue info message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Warning(const char *location, const char *va_(fmt), ...); Issue warni",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObject.html:11186,Security,hash,hash,11186,"me.; Classes that give objects a name should override this method. const char * GetIconName() const; Returns mime type name of object. Used by the TBrowser (via TGMimeTypes; class). Override for class of which you would like to have different; icons for objects of the same class. UInt_t GetUniqueID() const; Return the unique object id. char * GetObjectInfo(Int_t px, Int_t py) const; Returns string containing info about the object at position (px,py).; This method is typically overridden by classes of which the objects; can report peculiarities for different positions.; Returned string will be re-used (lock in MT environment). const char * GetTitle() const; Returns title of object. This default method returns the class title; (i.e. description). Classes that give objects a title should override; this method. Bool_t HandleTimer(TTimer* timer); Execute action in response of a timer timing out. This method; must be overridden if an object has to react to timers. ULong_t Hash() const; Return hash value for this object. Bool_t InheritsFrom(const char* classname) const; Returns kTRUE if object inherits from class ""classname"". Bool_t InheritsFrom(const TClass* cl) const; Returns kTRUE if object inherits from TClass cl. void Inspect() const; Dump contents of this object in a graphics canvas.; Same action as Dump but in a graphical form.; In addition pointers to other objects can be followed. The following picture is the Inspect of a histogram object:. /*; ; */. Bool_t IsFolder() const; Returns kTRUE in case object contains browsable objects (like containers; or lists of other objects). Bool_t IsEqual(const TObject* obj) const; Default equal comparison (objects are equal if they have the same; address in memory). More complicated classes might want to override; this function. void ls(Option_t* option = """") const; The ls function lists the contents of a class on stdout. Ls output; is typically much less verbose then Dump(). Bool_t Notify(); This method must be overridden to han",MatchSource.WIKI,root/html604/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObject.html
https://root.cern/root/html604/TObjectRefSpy.html:621,Availability,error,error,621,". TObjectRefSpy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObjectRefSpy. class TObjectRefSpy: public TObject. TObjectSpy, TObjectRefSpy. Monitors objects for deletion and reflects the deletion by reverting; the internal pointer to zero. When this pointer is zero we know the; object has been deleted. This avoids the unsafe TestBit(kNotDeleted); hack. The spied object must have the kMustCleanup bit set otherwise; you will get an error. Function Members (Methods); public:. virtual~TObjectRefSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOpti",MatchSource.WIKI,root/html604/TObjectRefSpy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjectRefSpy.html
https://root.cern/root/html604/TObjectRefSpy.html:1602,Availability,error,error,1602," virtual~TObjectRefSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOpti",MatchSource.WIKI,root/html604/TObjectRefSpy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjectRefSpy.html
https://root.cern/root/html604/TObjectRefSpy.html:1686,Availability,error,error,1686," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; TObject*GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl)",MatchSource.WIKI,root/html604/TObjectRefSpy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjectRefSpy.html
https://root.cern/root/html604/TObjectRefSpy.html:496,Safety,avoid,avoids,496,". TObjectRefSpy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObjectRefSpy. class TObjectRefSpy: public TObject. TObjectSpy, TObjectRefSpy. Monitors objects for deletion and reflects the deletion by reverting; the internal pointer to zero. When this pointer is zero we know the; object has been deleted. This avoids the unsafe TestBit(kNotDeleted); hack. The spied object must have the kMustCleanup bit set otherwise; you will get an error. Function Members (Methods); public:. virtual~TObjectRefSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOpti",MatchSource.WIKI,root/html604/TObjectRefSpy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjectRefSpy.html
https://root.cern/root/html604/TObjectRefSpy.html:507,Safety,unsafe,unsafe,507,". TObjectRefSpy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObjectRefSpy. class TObjectRefSpy: public TObject. TObjectSpy, TObjectRefSpy. Monitors objects for deletion and reflects the deletion by reverting; the internal pointer to zero. When this pointer is zero we know the; object has been deleted. This avoids the unsafe TestBit(kNotDeleted); hack. The spied object must have the kMustCleanup bit set otherwise; you will get an error. Function Members (Methods); public:. virtual~TObjectRefSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOpti",MatchSource.WIKI,root/html604/TObjectRefSpy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjectRefSpy.html
https://root.cern/root/html604/TObjectSet.html:1957,Availability,error,error,1957," dataset); virtual TObject*AddObject(TObject* obj, Bool_t makeOwner = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); TDataSet*TDataSet::At(Int_t idx) const; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tDoOwner(Bool_t done = kTRUE); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TDataSet::GetList() c",MatchSource.WIKI,root/html604/TObjectSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjectSet.html
https://root.cern/root/html604/TObjectSet.html:2041,Availability,error,error,2041,"l voidTObject::AppendPad(Option_t* option = """"); TDataSet*TDataSet::At(Int_t idx) const; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tDoOwner(Bool_t done = kTRUE); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TDataSet::GetList() const; virtual Int_tTDataSet::GetListSize() const; static TDataSet*TDataSet::GetMainS",MatchSource.WIKI,root/html604/TObjectSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjectSet.html
https://root.cern/root/html604/TObjectSpy.html:612,Availability,error,error,612,". TObjectSpy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObjectSpy. class TObjectSpy: public TObject. TObjectSpy, TObjectRefSpy. Monitors objects for deletion and reflects the deletion by reverting; the internal pointer to zero. When this pointer is zero we know the; object has been deleted. This avoids the unsafe TestBit(kNotDeleted); hack. The spied object must have the kMustCleanup bit set otherwise; you will get an error. Function Members (Methods); public:. virtual~TObjectSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; ",MatchSource.WIKI,root/html604/TObjectSpy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjectSpy.html
https://root.cern/root/html604/TObjectSpy.html:1590,Availability,error,error,1590," virtual~TObjectSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; ",MatchSource.WIKI,root/html604/TObjectSpy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjectSpy.html
https://root.cern/root/html604/TObjectSpy.html:1674,Availability,error,error,1674," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; TObject*GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl)",MatchSource.WIKI,root/html604/TObjectSpy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjectSpy.html
https://root.cern/root/html604/TObjectSpy.html:487,Safety,avoid,avoids,487,". TObjectSpy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObjectSpy. class TObjectSpy: public TObject. TObjectSpy, TObjectRefSpy. Monitors objects for deletion and reflects the deletion by reverting; the internal pointer to zero. When this pointer is zero we know the; object has been deleted. This avoids the unsafe TestBit(kNotDeleted); hack. The spied object must have the kMustCleanup bit set otherwise; you will get an error. Function Members (Methods); public:. virtual~TObjectSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; ",MatchSource.WIKI,root/html604/TObjectSpy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjectSpy.html
https://root.cern/root/html604/TObjectSpy.html:498,Safety,unsafe,unsafe,498,". TObjectSpy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObjectSpy. class TObjectSpy: public TObject. TObjectSpy, TObjectRefSpy. Monitors objects for deletion and reflects the deletion by reverting; the internal pointer to zero. When this pointer is zero we know the; object has been deleted. This avoids the unsafe TestBit(kNotDeleted); hack. The spied object must have the kMustCleanup bit set otherwise; you will get an error. Function Members (Methods); public:. virtual~TObjectSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; ",MatchSource.WIKI,root/html604/TObjectSpy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjectSpy.html
https://root.cern/root/html604/TObjectTable.html:3323,Availability,error,error,3323,"dTObject::AbstractMethod(const char* method) const; voidAdd(TObject* obj); static voidAddObj(TObject* obj); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); void*CheckPtrAndWarn(const char* msg, void* vp); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(cons",MatchSource.WIKI,root/html604/TObjectTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjectTable.html
https://root.cern/root/html604/TObjectTable.html:3407,Availability,error,error,3407,"idAddObj(TObject* obj); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); void*CheckPtrAndWarn(const char* msg, void* vp); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) cons",MatchSource.WIKI,root/html604/TObjectTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjectTable.html
https://root.cern/root/html604/TObjectTable.html:613,Deployability,toggle,toggle,613,". TObjectTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TObjectTable. class TObjectTable: public TObject. This class registers all instances of TObject and its derived; classes in a hash table. The Add() and Remove() members are called; from the TObject ctor and dtor, repectively. Using the Print(); member one can see all currently active objects in the system.; Using the resource (in .rootrc): Root.ObjectStat one can toggle this; feature on or off.; Using the compile option R__NOSTATS one can de-active this feature; for the entire system (for maximum performance in highly time; critical applications). The following output has been produced in a ROOT interactive session; via the command gObjectTable->Print(); class cnt on heap size total size heap size. TKey 4 4 72 288 288; TClass 84 84 80 6720 6720; TDataMember 276 276 24 6624 6624; TObject 11 11 12 132 132; TMethod 1974 1974 64 126336 126336; TDataType 34 34 56 1904 1904; TList 2328 2328 36 83808 83808; TH1F 1 1 448 448 448; TText 2688 2688 56 150528 150528; TGaxis 1 0 120 120 0; TAxis 6 3 88 528 264; TBox 57 57 52 2964 2964; TLine 118 118 40 4720 4720; TWbox 1 1 56 56 56; TArrow 1 1 64 64 64; TPaveText 59 59 124 7316 7316; TPave 1 1 92 92 92; TFile 1 1 136 136 136; TCanvas 3 3 444 1332 1332; TPad 1 1 312 312 312; TContextMenu 3 3 48 144 144; TMethodArg 2166 2166 44 95304 95304; TPaveLabel 1 1 120 120 120; THtml 1 1 32 32 32; TROOT 1 0 208 208 0; TApplication 1 1 28 28 28; TFileHandler 1 1 20 20 20; TColor 163 163 40 6520 6520; TStyle 1 1 364 364 364; TRealData 117 117 28 3276 3276; TBaseClass 88 88 36 3168 3168; THashList 5 5 40 200 200; THashTable 5 5 36 180 180; TGeometry 1 1 64 64 64; TLink 7 7 60 420 420; TPostScript 1 1 764 764 764; TMinuit 1 1 792 792 792; TStopwatch 1 0 56 56 0; TRootGuiFactory 1 1 28 28 28; TGX11 1 1 1",MatchSource.WIKI,root/html604/TObjectTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjectTable.html
https://root.cern/root/html604/TObjectTable.html:749,Performance,perform,performance,749,". TObjectTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TObjectTable. class TObjectTable: public TObject. This class registers all instances of TObject and its derived; classes in a hash table. The Add() and Remove() members are called; from the TObject ctor and dtor, repectively. Using the Print(); member one can see all currently active objects in the system.; Using the resource (in .rootrc): Root.ObjectStat one can toggle this; feature on or off.; Using the compile option R__NOSTATS one can de-active this feature; for the entire system (for maximum performance in highly time; critical applications). The following output has been produced in a ROOT interactive session; via the command gObjectTable->Print(); class cnt on heap size total size heap size. TKey 4 4 72 288 288; TClass 84 84 80 6720 6720; TDataMember 276 276 24 6624 6624; TObject 11 11 12 132 132; TMethod 1974 1974 64 126336 126336; TDataType 34 34 56 1904 1904; TList 2328 2328 36 83808 83808; TH1F 1 1 448 448 448; TText 2688 2688 56 150528 150528; TGaxis 1 0 120 120 0; TAxis 6 3 88 528 264; TBox 57 57 52 2964 2964; TLine 118 118 40 4720 4720; TWbox 1 1 56 56 56; TArrow 1 1 64 64 64; TPaveText 59 59 124 7316 7316; TPave 1 1 92 92 92; TFile 1 1 136 136 136; TCanvas 3 3 444 1332 1332; TPad 1 1 312 312 312; TContextMenu 3 3 48 144 144; TMethodArg 2166 2166 44 95304 95304; TPaveLabel 1 1 120 120 120; THtml 1 1 32 32 32; TROOT 1 0 208 208 0; TApplication 1 1 28 28 28; TFileHandler 1 1 20 20 20; TColor 163 163 40 6520 6520; TStyle 1 1 364 364 364; TRealData 117 117 28 3276 3276; TBaseClass 88 88 36 3168 3168; THashList 5 5 40 200 200; THashTable 5 5 36 180 180; TGeometry 1 1 64 64 64; TLink 7 7 60 420 420; TPostScript 1 1 764 764 764; TMinuit 1 1 792 792 792; TStopwatch 1 0 56 56 0; TRootGuiFactory 1 1 28 28 28; TGX11 1 1 1",MatchSource.WIKI,root/html604/TObjectTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjectTable.html
https://root.cern/root/html604/TObjectTable.html:9160,Performance,perform,performed,9160,"tion; TObjectTable(Int_t tableSize = 100); Create an object table. ~TObjectTable(); Delete TObjectTable. void Print(Option_t* option = """") const; Print the object table.; If option =""all"" prints the list of all objects with the format; object number, pointer, class name, object name. void Add(TObject* obj); Add an object to the object table. void AddObj(TObject* obj); Add an object to the global object table gObjectTable. If the global; table does not exist create it first. This member function may only; be used by TObject::TObject. Use Add() to add objects to any other; TObjectTable object. This is a static function. void Delete(Option_t* opt = """"); Delete all objects stored in the TObjectTable. void Remove(TObject* obj); Remove an object from the object table. void RemoveQuietly(TObject* obj); Remove an object from the object table. If op is 0 or not in the table; don't complain. Currently only used by the TClonesArray dtor. Should not; be used anywhere else, except in places where ""special"" allocation and; de-allocation tricks are performed. void Terminate(); Deletes the object table (this static class function calls the dtor). Int_t FindElement(TObject* obj); Find an object in the object table. Returns the slot where to put; the object. To test if the object is actually already in the table; use PtrIsValid(). void FixCollisions(Int_t index); Rehash the object table in case an object has been removed. void Expand(Int_t newsize); Expand the object table. void InstanceStatistics() const; Print the object table. void UpdateInstCount() const; Histogram all objects according to their classes. void * CheckPtrAndWarn(const char* msg, void* vp); Issue a warning in case an object still appears in the table; while it should not. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. Bool_t PtrIsValid(TObject* obj); { return fTable[FindElement(op)] != 0; }. TObjectTable(const TObjectTable& ). TObjectTable& operator=(const TObjectTable& ). Int_t GetSize() co",MatchSource.WIKI,root/html604/TObjectTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjectTable.html
https://root.cern/root/html604/TObjectTable.html:373,Security,hash,hash,373,". TObjectTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TObjectTable. class TObjectTable: public TObject. This class registers all instances of TObject and its derived; classes in a hash table. The Add() and Remove() members are called; from the TObject ctor and dtor, repectively. Using the Print(); member one can see all currently active objects in the system.; Using the resource (in .rootrc): Root.ObjectStat one can toggle this; feature on or off.; Using the compile option R__NOSTATS one can de-active this feature; for the entire system (for maximum performance in highly time; critical applications). The following output has been produced in a ROOT interactive session; via the command gObjectTable->Print(); class cnt on heap size total size heap size. TKey 4 4 72 288 288; TClass 84 84 80 6720 6720; TDataMember 276 276 24 6624 6624; TObject 11 11 12 132 132; TMethod 1974 1974 64 126336 126336; TDataType 34 34 56 1904 1904; TList 2328 2328 36 83808 83808; TH1F 1 1 448 448 448; TText 2688 2688 56 150528 150528; TGaxis 1 0 120 120 0; TAxis 6 3 88 528 264; TBox 57 57 52 2964 2964; TLine 118 118 40 4720 4720; TWbox 1 1 56 56 56; TArrow 1 1 64 64 64; TPaveText 59 59 124 7316 7316; TPave 1 1 92 92 92; TFile 1 1 136 136 136; TCanvas 3 3 444 1332 1332; TPad 1 1 312 312 312; TContextMenu 3 3 48 144 144; TMethodArg 2166 2166 44 95304 95304; TPaveLabel 1 1 120 120 120; THtml 1 1 32 32 32; TROOT 1 0 208 208 0; TApplication 1 1 28 28 28; TFileHandler 1 1 20 20 20; TColor 163 163 40 6520 6520; TStyle 1 1 364 364 364; TRealData 117 117 28 3276 3276; TBaseClass 88 88 36 3168 3168; THashList 5 5 40 200 200; THashTable 5 5 36 180 180; TGeometry 1 1 64 64 64; TLink 7 7 60 420 420; TPostScript 1 1 764 764 764; TMinuit 1 1 792 792 792; TStopwatch 1 0 56 56 0; TRootGuiFactory 1 1 28 28 28; TGX11 1 1 1",MatchSource.WIKI,root/html604/TObjectTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjectTable.html
https://root.cern/root/html604/TObjectTable.html:9374,Testability,test,test,9374,"ject* obj); Add an object to the object table. void AddObj(TObject* obj); Add an object to the global object table gObjectTable. If the global; table does not exist create it first. This member function may only; be used by TObject::TObject. Use Add() to add objects to any other; TObjectTable object. This is a static function. void Delete(Option_t* opt = """"); Delete all objects stored in the TObjectTable. void Remove(TObject* obj); Remove an object from the object table. void RemoveQuietly(TObject* obj); Remove an object from the object table. If op is 0 or not in the table; don't complain. Currently only used by the TClonesArray dtor. Should not; be used anywhere else, except in places where ""special"" allocation and; de-allocation tricks are performed. void Terminate(); Deletes the object table (this static class function calls the dtor). Int_t FindElement(TObject* obj); Find an object in the object table. Returns the slot where to put; the object. To test if the object is actually already in the table; use PtrIsValid(). void FixCollisions(Int_t index); Rehash the object table in case an object has been removed. void Expand(Int_t newsize); Expand the object table. void InstanceStatistics() const; Print the object table. void UpdateInstCount() const; Histogram all objects according to their classes. void * CheckPtrAndWarn(const char* msg, void* vp); Issue a warning in case an object still appears in the table; while it should not. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. Bool_t PtrIsValid(TObject* obj); { return fTable[FindElement(op)] != 0; }. TObjectTable(const TObjectTable& ). TObjectTable& operator=(const TObjectTable& ). Int_t GetSize() const; { return fSize; }. Int_t Instances() const; { return fTally; }. void Statistics(); { Print(); }. » Author: Fons Rademakers 11/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-06-02 16:25; This page has been automatically",MatchSource.WIKI,root/html604/TObjectTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjectTable.html
https://root.cern/root/html604/TObjString.html:1331,Availability,error,error,1331," virtual~TObjString(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virt",MatchSource.WIKI,root/html604/TObjString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjString.html
https://root.cern/root/html604/TObjString.html:1415,Availability,error,error,1415,"String(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringGetString() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tHash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const",MatchSource.WIKI,root/html604/TObjString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TObjString.html
https://root.cern/root/html604/TOptionListItem.html:6235,Availability,error,error,6235,,MatchSource.WIKI,root/html604/TOptionListItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TOptionListItem.html
https://root.cern/root/html604/TOptionListItem.html:6319,Availability,error,error,6319," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html604/TOptionListItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TOptionListItem.html
https://root.cern/root/html604/TOptionListItem.html:10368,Deployability,toggle,toggle,10368,"ar* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. TDataMember*fDataMember!Data member to which this option belongs; TStringfOptLabelText (or enum) value assigned to option.; TStringfOptNameText assigned to option which appears in option menu; Long_tfToggleMaskBitNot used yet: bitmask used when toggling value; Long_tfValueNumerical value assigned to option; Long_tfValueMaskBitNot used yet: bitmask used when option is a toggle group; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TOptionListItem(TDataMember* m, Long_t val, Long_t valmask, Long_t tglmask, const char* name, const char* label); Constuctor. TDataMember& operator=(const TDataMember&). TOptionListItem(); {}. TOptionListItem(TDataMember* m, Long_t val, Long_t valmask, Long_t tglmask, const char* name, const char* label). » Author: Fons Rademakers 04/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last c",MatchSource.WIKI,root/html604/TOptionListItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TOptionListItem.html
https://root.cern/root/html604/TOptionListItem.html:2866,Integrability,rout,routines,2866,"now,; that names that are automatically recognized may be also:; for data fields: either fXXX or fIsXXX; and for getter function; GetXXX() or IsXXX() [where XXX is base name]. As an example of using it let's analyse a few lines which get and set; a fEditable field in TCanvas:. ; /*; TCanvas *c = new TCanvas(""c""); // create a canvas; TClass *cl = c->IsA(); // get its class description object.; TDataMember *dm = cl->GetDataMember(""fEditable""); //This is our data member; TMethodCall *getter = dm->GetterMethod(c); //find a method that gets value!; Long_t l; // declare a storage for this value;; getter->Execute(c,"""",l); // Get this Value !!!! It will appear in l !!!; TMethodCall *setter = dm->SetterMethod(c);; setter->Execute(c,""0"",); // Set Value 0 !!!; */. This trick is widely used in ROOT TContextMenu and dialogs for obtaining; current values and put them as initial values in dialog fields. If you don't want to follow the convention of naming used by ROOT; you still could benefit from Getter/Setter method support: the solution; is to instruct ROOT what the names of these routines are.; The way to do it is putting this information in a comment string to a data; field in your class declaration:. ; /*; class MyClass{; Int_t mydata; // *OPTIONS={GetMethod=""Get"";SetMethod=""Set""} ; ...; Int_t Get() const { return mydata;};; void Set(Int_t i) {mydata=i;};; }; */. However, this getting/setting functions are not the only feature of; this class. The next point is providing lists of possible settings; for the concerned data member. The idea is to have a list of possible; options for this data member, with strings identifying them. This; is used in dialogs with parameters to set - for details see; TMethodArg, TRootContextMenu, TContextMenu. This list not only specifies; the allowed value, but also provides strings naming the options.; Options are managed via TList of TOptionListItem objects. This list; is also created automatically: if a data type is an enum tynpe,; the list will",MatchSource.WIKI,root/html604/TOptionListItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TOptionListItem.html
https://root.cern/root/html604/TOptionListItem.html:971,Security,access,access,971,". TOptionListItem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TOptionListItem. class TOptionListItem: public TObject. TDataMember. All ROOT classes may have RTTI (run time type identification) support; added. The data is stored in so called DICTIONARY (look at TDictionary).; Information about a class is stored in TClass.; This information may be obtained via the cling api - see class TCling.; TClass has a list of TDataMember objects providing information about all; data members of described class. /*. */. TDataMember provides information about name of data member, its type,; and comment field string. It also tries to find the TMethodCall objects; responsible for getting/setting a value of it, and gives you pointers; to these methods. This gives you a unique possibility to access; protected and private (!) data members if only methods for doing that; are defined.; These methods could either be specified in a comment field, or found; out automatically by ROOT: here's an example:; suppose you have a class definition:. ; /*; class MyClass{; private:; Float_t fX1;; ...; public:; void SetX1(Float_t x) {fX1 = x;};; Float_t GetX1() {return fX1;};; ...; }; */. Look at the data member name and method names: a data member name has; a prefix letter (f) and has a base name X1 . The methods for getting and; setting this value have names which consist of string Get/Set and the; same base name. This convention of naming data fields and methods which; access them allows TDataMember find this methods by itself completely; automatically. To make this description complete, one should know,; that names that are automatically recognized may be also:; for data fields: either fXXX or fIsXXX; and for getter function; GetXXX() or IsXXX() [where XXX is base name]. As an example of using it let's analyse a few",MatchSource.WIKI,root/html604/TOptionListItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TOptionListItem.html
https://root.cern/root/html604/TOptionListItem.html:1647,Security,access,access,1647,"ta members of described class. /*. */. TDataMember provides information about name of data member, its type,; and comment field string. It also tries to find the TMethodCall objects; responsible for getting/setting a value of it, and gives you pointers; to these methods. This gives you a unique possibility to access; protected and private (!) data members if only methods for doing that; are defined.; These methods could either be specified in a comment field, or found; out automatically by ROOT: here's an example:; suppose you have a class definition:. ; /*; class MyClass{; private:; Float_t fX1;; ...; public:; void SetX1(Float_t x) {fX1 = x;};; Float_t GetX1() {return fX1;};; ...; }; */. Look at the data member name and method names: a data member name has; a prefix letter (f) and has a base name X1 . The methods for getting and; setting this value have names which consist of string Get/Set and the; same base name. This convention of naming data fields and methods which; access them allows TDataMember find this methods by itself completely; automatically. To make this description complete, one should know,; that names that are automatically recognized may be also:; for data fields: either fXXX or fIsXXX; and for getter function; GetXXX() or IsXXX() [where XXX is base name]. As an example of using it let's analyse a few lines which get and set; a fEditable field in TCanvas:. ; /*; TCanvas *c = new TCanvas(""c""); // create a canvas; TClass *cl = c->IsA(); // get its class description object.; TDataMember *dm = cl->GetDataMember(""fEditable""); //This is our data member; TMethodCall *getter = dm->GetterMethod(c); //find a method that gets value!; Long_t l; // declare a storage for this value;; getter->Execute(c,"""",l); // Get this Value !!!! It will appear in l !!!; TMethodCall *setter = dm->SetterMethod(c);; setter->Execute(c,""0"",); // Set Value 0 !!!; */. This trick is widely used in ROOT TContextMenu and dialogs for obtaining; current values and put them as initial valu",MatchSource.WIKI,root/html604/TOptionListItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TOptionListItem.html
https://root.cern/root/html604/TOrdCollection.html:2608,Availability,error,error,2608,"se(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TCollection::FindObject(const char* name) const; virtual TObject*TCollection::FindObject(const TObject* obj) const; virtual TObject*First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_",MatchSource.WIKI,root/html604/TOrdCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TOrdCollection.html
https://root.cern/root/html604/TOrdCollection.html:2692,Availability,error,error,2692,"const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TCollection::FindObject(const char* name) const; virtual TObject*TCollection::FindObject(const TObject* obj) const; virtual TObject*First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; virtual const char*TObject::GetTitle() const; virtual",MatchSource.WIKI,root/html604/TOrdCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TOrdCollection.html
https://root.cern/root/html604/TOrdCollection.html:12011,Availability,error,error,12011,"er object after in the collection. TObject * After(const TObject* obj) const; Return the object after object obj. Returns 0 if obj is last; in collection. TObject * At(Int_t idx) const; Returns the object at position idx. Returns 0 if idx is out of range. TObject * Before(const TObject* obj) const; Returns the object before object obj. Returns 0 if obj is first; in collection. void Clear(Option_t* option = """"); Remove all objects from the collection. Does not delete the objects; unless the TOrdCollection is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from the collection AND delete all heap based objects. TObject * First() const; Return the first object in the collection. Returns 0 when collection; is empty. TObject ** GetObjectRef(const TObject* obj) const; return address of pointer obj. TObject * Last() const; Return the last object in the collection. Returns 0 when collection; is empty. Bool_t IllegalIndex(const char* method, Int_t idx) const; Return true when index out of bounds and print error. Int_t IndexOf(const TObject* obj) const; Return index of object in collection. Returns -1 when object not found.; Uses member IsEqual() to find object. void Init(Int_t capacity); Initialize ordered collection. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Return an ordered collection iterator. void MoveGapTo(Int_t newGapStart); Move gap to new position. Gap needs to be moved when objects are; inserted not at the end. void PutAt(TObject* obj, Int_t idx); Put object at index idx. Overwrites what was at idx before. TObject * RemoveAt(Int_t idx); Remove object at index idx. TObject * Remove(TObject* obj); Remove object from collection. void SetCapacity(Int_t newCapacity); Set/change ordered collection capacity. void Sort(); If objects in collection are sortable (i.e. IsSortable() returns true; for all objects) then sort collection. Int_t BinarySearch(TObject* obj); Find object using a binary search. Collection must first",MatchSource.WIKI,root/html604/TOrdCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TOrdCollection.html
https://root.cern/root/html604/TOutputListSelectorDataMap.html:1445,Availability,error,error,1445," virtual~TOutputListSelectorDataMap(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static TOutputListSelectorDataMap*FindInList(TCollection* coll); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() c",MatchSource.WIKI,root/html604/TOutputListSelectorDataMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TOutputListSelectorDataMap.html
https://root.cern/root/html604/TOutputListSelectorDataMap.html:1529,Availability,error,error,1529," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static TOutputListSelectorDataMap*FindInList(TCollection* coll); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TCollection*GetMap() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html604/TOutputListSelectorDataMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TOutputListSelectorDataMap.html
https://root.cern/root/html604/TPackageDescription.html:1432,Availability,error,error,1432," virtual~TPackageDescription(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(",MatchSource.WIKI,root/html604/TPackageDescription.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPackageDescription.html
https://root.cern/root/html604/TPackageDescription.html:1516,Availability,error,error,1516," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect",MatchSource.WIKI,root/html604/TPackageDescription.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPackageDescription.html
https://root.cern/root/html604/TPacketizer.html:1950,Availability,error,error,1950,"tus*, Double_t, TList**); virtual Int_tAddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTVirtualPacketizer::AssignWork(TDSet*, Long64_t, Long64_t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tTVirtualPacketizer::GetBytesRead() const; TList*TVirtualPacketizer::GetConfigParams(Bool_t steal = kFALSE); Double_tTVirtualPacketizer::GetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntriesProcessed(TSlave* sl) const; virtual Int_tTVirtualPacketizer::GetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*TVirtualPacketizer::GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tTVirtualPacketizer::GetInitTime() const; virtu",MatchSource.WIKI,root/html604/TPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizer.html
https://root.cern/root/html604/TPacketizer.html:2034,Availability,error,error,2034,"ct::AppendPad(Option_t* option = """"); virtual Int_tTVirtualPacketizer::AssignWork(TDSet*, Long64_t, Long64_t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tTVirtualPacketizer::GetBytesRead() const; TList*TVirtualPacketizer::GetConfigParams(Bool_t steal = kFALSE); Double_tTVirtualPacketizer::GetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntriesProcessed(TSlave* sl) const; virtual Int_tTVirtualPacketizer::GetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*TVirtualPacketizer::GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tTVirtualPacketizer::GetInitTime() const; virtual const char*TObject::GetName() const; virtual TDSetElement*GetNextPacket(TSlave* s",MatchSource.WIKI,root/html604/TPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizer.html
https://root.cern/root/html604/TPacketizer.html:11605,Availability,failure,failure,11605,"lPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. TList*fActivenodes with unfinished files; Bool_tfDefMaxWrkNodeWhether the default is used for the max workers per node; TList*fFileNodesnodes with files; Bool_tfHeuristicPSizWhether the packet size is calculated heuristically; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Int_tfPacketAsAFractionused to calculate the packet size; Long64_tfPacketSizeglobal base packet size; TList*fPacketsall processed packets; TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizer(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizer(); Destructor. Int_t AddWorkers(TList* workers); Adds new workers. Returns the number of workers added, or -1 on failure. void RemoveUnAllocNode(TPacketizer::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizer::TFileStat* file); Remove file from the list of actives. void RemoveActiveNode(TPacketizer::TFileNode* ); Remove node from the list of actives. void Reset(); Reset the internal datastructure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t maxent = -1, Bool_t byfile = kFALSE); Check existence of file/dir/tree an get number of entries.; Assumes the files have been setup. Long64_t GetEntriesProcessed(TSlave* sl) const; Get entries processed by the specified slave. Float_t GetCurrentRate(Bool_t& all); Get Estimation of the current rate; just summing the current rates of; the active workers. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet. Int_t GetActiveWorkers(); Return the number of workers still processing. TPacketizer(). TPacketizer(const TPacketizer& ). void operator=(const TPacketizer& ). TFileNode",MatchSource.WIKI,root/html604/TPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizer.html
https://root.cern/root/html604/TPacketizer.html:8821,Deployability,configurat,configuration,8821,"ontextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; TList*TVirtualPacketizer::fInputInput list; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_",MatchSource.WIKI,root/html604/TPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizer.html
https://root.cern/root/html604/TPacketizer.html:9664,Deployability,update,updates,9664,"ontextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; TList*TVirtualPacketizer::fInputInput list; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_",MatchSource.WIKI,root/html604/TPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizer.html
https://root.cern/root/html604/TPacketizer.html:10235,Deployability,update,updates,10235,"at_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::fTimeUpdttime between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. TList*fActivenodes with unfinished files; Bool_tfDefMaxWrkNodeWhether the default is used for the max workers per node; TList*fFileNodesnodes with files; Bool_tfHeuristicPSizWhether the packet size is calculated heuristically; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Int_tfPacketAsAFractionused to calculate the packet size; Long64_tfPacketSizeglobal base packet size; TList*fPacketsall processed packets; TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; In",MatchSource.WIKI,root/html604/TPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizer.html
https://root.cern/root/html604/TPacketizer.html:8821,Modifiability,config,configuration,8821,"ontextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; TList*TVirtualPacketizer::fInputInput list; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_",MatchSource.WIKI,root/html604/TPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizer.html
https://root.cern/root/html604/TPacketizer.html:619,Performance,perform,performance,619,". TPacketizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPacketizer. class TPacketizer: public TVirtualPacketizer. TPacketizer. This class generates packets to be processed on PROOF worker servers.; A packet is an event range (begin entry and number of entries) or; object range (first object and number of objects) in a TTree; (entries) or a directory (objects) in a file.; Packets are generated taking into account the performance of the; remote machine, the time it took to process a previous packet on; the remote machine, the locality of the database files, etc. Function Members (Methods); public:. virtual~TPacketizer(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTVirtualPacketizer::AddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual Int_tAddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTVirtualPacketizer::AssignWork(TDSet*, Long64_t, Long64_t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* m",MatchSource.WIKI,root/html604/TPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizer.html
https://root.cern/root/html604/TPacketizer.html:10983,Performance,perform,performance,10983," TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::fTimeUpdttime between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. TList*fActivenodes with unfinished files; Bool_tfDefMaxWrkNodeWhether the default is used for the max workers per node; TList*fFileNodesnodes with files; Bool_tfHeuristicPSizWhether the packet size is calculated heuristically; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Int_tfPacketAsAFractionused to calculate the packet size; Long64_tfPacketSizeglobal base packet size; TList*fPacketsall processed packets; TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizer(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizer(); Destructor. Int_t AddWorkers(TList* workers); Adds new workers. Returns the number of workers added, or -1 on failure. void RemoveUnAllocNode(TPacketizer::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizer::TFileStat* file); Remove file from the list of actives. void RemoveActiveNode(TPacketizer::TFileNode* ); Remove node from the list of actives. void Reset(); Reset the internal datastructure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t",MatchSource.WIKI,root/html604/TPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizer.html
https://root.cern/root/html604/TPacketizer.html:5931,Safety,abort,abort,5931,"Object::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTVirtualPacketizer::SetFailedPackets(TList* list); virtual voidTVirtualPacketizer::SetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidTVirtualPacketizer::SetProgressStatus(TProofProgressStatus* st); voidTVirtualPacketizer::SetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTVirtualPacketizer::StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TPacketizer(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizer.html
https://root.cern/root/html604/TPacketizer.html:11070,Safety,avoid,avoid,11070," TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::fTimeUpdttime between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. TList*fActivenodes with unfinished files; Bool_tfDefMaxWrkNodeWhether the default is used for the max workers per node; TList*fFileNodesnodes with files; Bool_tfHeuristicPSizWhether the packet size is calculated heuristically; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Int_tfPacketAsAFractionused to calculate the packet size; Long64_tfPacketSizeglobal base packet size; TList*fPacketsall processed packets; TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizer(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizer(); Destructor. Int_t AddWorkers(TList* workers); Adds new workers. Returns the number of workers added, or -1 on failure. void RemoveUnAllocNode(TPacketizer::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizer::TFileStat* file); Remove file from the list of actives. void RemoveActiveNode(TPacketizer::TFileNode* ); Remove node from the list of actives. void Reset(); Reset the internal datastructure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t",MatchSource.WIKI,root/html604/TPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizer.html
https://root.cern/root/html604/TPacketizerAdaptive.html:2495,Availability,error,error,2495,"idTObject::AppendPad(Option_t* option = """"); virtual Int_tTVirtualPacketizer::AssignWork(TDSet*, Long64_t, Long64_t); virtual voidTObject::Browse(TBrowser* b); Int_tCalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tTVirtualPacketizer::GetBytesRead() const; TList*TVirtualPacketizer::GetConfigParams(Bool_t steal = kFALSE); Double_tTVirtualPacketizer::GetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tTVirtualPacketizer::GetEntriesProcessed() const; virtual Int_tGetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*TVirtualPacketizer::GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tTVirtualPacketizer::GetInitTime() const; virtual const c",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:2579,Availability,error,error,2579,"Work(TDSet*, Long64_t, Long64_t); virtual voidTObject::Browse(TBrowser* b); Int_tCalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tTVirtualPacketizer::GetBytesRead() const; TList*TVirtualPacketizer::GetConfigParams(Bool_t steal = kFALSE); Double_tTVirtualPacketizer::GetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tTVirtualPacketizer::GetEntriesProcessed() const; virtual Int_tGetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*TVirtualPacketizer::GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tTVirtualPacketizer::GetInitTime() const; virtual const char*TObject::GetName() const; virtual TDSetElement*GetNextPacket(TSlave* sl, TMessag",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:9631,Deployability,configurat,configuration,9631,"ontextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; TList*TVirtualPacketizer::fInputInput list; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:10474,Deployability,update,updates,10474,"ontextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; TList*TVirtualPacketizer::fInputInput list; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:11045,Deployability,update,updates,11045,"at_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::fTimeUpdttime between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. TList*fActivenodes with unfinished files; Float_tfBaseLocalPreferenceindicates how much more likely the nodes will be; Bool_tfCachePacketSynccontrol synchronization of cache and packet sizes; TList*fFileNodesnodes with files; TSortedList*fFilesToProcessGlobal list of files (TFileStat) to be processed; Bool_tfForceLocalif 1 - eliminate the remote processing; Float_tfFractionOfRemoteFilesfraction of TDSetElements that are on non-workers; Double_tfMaxEntriesRatiomax file entries to avg allowed ratio for cache-to-packet sync; Int_tfMaxPerfIdxmaximum of our slaves' performan",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:12403,Energy Efficiency,adapt,adaptive,12403,"between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. TList*fActivenodes with unfinished files; Float_tfBaseLocalPreferenceindicates how much more likely the nodes will be; Bool_tfCachePacketSynccontrol synchronization of cache and packet sizes; TList*fFileNodesnodes with files; TSortedList*fFilesToProcessGlobal list of files (TFileStat) to be processed; Bool_tfForceLocalif 1 - eliminate the remote processing; Float_tfFractionOfRemoteFilesfraction of TDSetElements that are on non-workers; Double_tfMaxEntriesRatiomax file entries to avg allowed ratio for cache-to-packet sync; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Long64_tfNEventsOnRemLocnumber of events in currently; Int_tfPacketAsAFractionused to calculate the packet size; TList*fPartitionslist of partitions on nodes; Int_tfStrategy0 means the classic and 1 (default) - the adaptive strategy; Int_tfTryReassignControls attempts to reassign packets (0 == no reassignment); TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* ",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:14161,Energy Efficiency,allocate,allocates,14161,"nternal data structure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t maxent = -1, Bool_t byfile = kFALSE); Check existence of file/dir/tree an get number of entries.; Assumes the files have been setup. Int_t CalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); The result depends on the fStrategy. Int_t AddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); To be used by GetNextPacket but also in reaction to kPROOF_STOPPROCESS; message (when the worker was asked to stop processing during a packet).; returns the #entries intended in the last packet - #processed entries. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet;; A meaningfull difference to TPacketizer is the fact that this; packetizer, for each worker, tries to predict whether the worker; will finish processing it's local files before the end of the query.; If yes, it allocates, to those workers, files from non-slave filenodes; or from slaves that are overloaded. The check is done every time a new; file needs to be assigned. Int_t GetActiveWorkers(); Return the number of workers still processing. Float_t GetCurrentRate(Bool_t& all); Get Estimation of the current rate; just summing the current rates of; the active workers. Int_t GetEstEntriesProcessed(Float_t , Long64_t& ent, Long64_t& bytes, Long64_t& calls); Get estimation for the number of processed entries and bytes read at time t,; based on the numbers already processed and the latests worker measured speeds.; If t <= 0 the current time is used.; Only the estimation for the entries is currently implemented.; This is needed to smooth the instantaneous rate plot. void MarkBad(TSlave* s, TProofProgressStatus* status, TList** missingFiles); This method can be called at any time during processing; as an effect of handling kPROOF_STOPPROCESS; If the output list from this worker is going to be sent back to the master,; the 'status' includes th",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:11676,Integrability,synchroniz,synchronization,11676,"between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. TList*fActivenodes with unfinished files; Float_tfBaseLocalPreferenceindicates how much more likely the nodes will be; Bool_tfCachePacketSynccontrol synchronization of cache and packet sizes; TList*fFileNodesnodes with files; TSortedList*fFilesToProcessGlobal list of files (TFileStat) to be processed; Bool_tfForceLocalif 1 - eliminate the remote processing; Float_tfFractionOfRemoteFilesfraction of TDSetElements that are on non-workers; Double_tfMaxEntriesRatiomax file entries to avg allowed ratio for cache-to-packet sync; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Long64_tfNEventsOnRemLocnumber of events in currently; Int_tfPacketAsAFractionused to calculate the packet size; TList*fPartitionslist of partitions on nodes; Int_tfStrategy0 means the classic and 1 (default) - the adaptive strategy; Int_tfTryReassignControls attempts to reassign packets (0 == no reassignment); TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* ",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:13528,Integrability,depend,depends,13528,"ent); TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* file); Remove file from the list of actives. void RemoveActiveNode(TPacketizerAdaptive::TFileNode* ); Remove node from the list of actives. void Reset(); Reset the internal data structure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t maxent = -1, Bool_t byfile = kFALSE); Check existence of file/dir/tree an get number of entries.; Assumes the files have been setup. Int_t CalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); The result depends on the fStrategy. Int_t AddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); To be used by GetNextPacket but also in reaction to kPROOF_STOPPROCESS; message (when the worker was asked to stop processing during a packet).; returns the #entries intended in the last packet - #processed entries. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet;; A meaningfull difference to TPacketizer is the fact that this; packetizer, for each worker, tries to predict whether the worker; will finish processing it's local files before the end of the query.; If yes, it allocates, to those workers, files from non-slave filenodes; or from slaves that are overloaded. The check is done every time a new; file needs to be assigned. Int_t GetActiveWorkers(); Return the number of workers still processing. Float_t GetCurrentRate(Bool_t& all); Get Estimation of the current rate; just summing the current rate",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:13734,Integrability,message,message,13734," slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* file); Remove file from the list of actives. void RemoveActiveNode(TPacketizerAdaptive::TFileNode* ); Remove node from the list of actives. void Reset(); Reset the internal data structure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t maxent = -1, Bool_t byfile = kFALSE); Check existence of file/dir/tree an get number of entries.; Assumes the files have been setup. Int_t CalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); The result depends on the fStrategy. Int_t AddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); To be used by GetNextPacket but also in reaction to kPROOF_STOPPROCESS; message (when the worker was asked to stop processing during a packet).; returns the #entries intended in the last packet - #processed entries. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet;; A meaningfull difference to TPacketizer is the fact that this; packetizer, for each worker, tries to predict whether the worker; will finish processing it's local files before the end of the query.; If yes, it allocates, to those workers, files from non-slave filenodes; or from slaves that are overloaded. The check is done every time a new; file needs to be assigned. Int_t GetActiveWorkers(); Return the number of workers still processing. Float_t GetCurrentRate(Bool_t& all); Get Estimation of the current rate; just summing the current rates of; the active workers. Int_t GetEstEntriesProcessed(Float_t , Long64_t& ent, Long64_t& bytes, Long64_t& calls); Get estimation for the number of processed entries and bytes read at",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:9631,Modifiability,config,configuration,9631,"ontextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; TList*TVirtualPacketizer::fInputInput list; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:12403,Modifiability,adapt,adaptive,12403,"between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. TList*fActivenodes with unfinished files; Float_tfBaseLocalPreferenceindicates how much more likely the nodes will be; Bool_tfCachePacketSynccontrol synchronization of cache and packet sizes; TList*fFileNodesnodes with files; TSortedList*fFilesToProcessGlobal list of files (TFileStat) to be processed; Bool_tfForceLocalif 1 - eliminate the remote processing; Float_tfFractionOfRemoteFilesfraction of TDSetElements that are on non-workers; Double_tfMaxEntriesRatiomax file entries to avg allowed ratio for cache-to-packet sync; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Long64_tfNEventsOnRemLocnumber of events in currently; Int_tfPacketAsAFractionused to calculate the packet size; TList*fPartitionslist of partitions on nodes; Int_tfStrategy0 means the classic and 1 (default) - the adaptive strategy; Int_tfTryReassignControls attempts to reassign packets (0 == no reassignment); TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* ",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:418,Performance,load,load-balancing,418,". TPacketizerAdaptive. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPacketizerAdaptive. class TPacketizerAdaptive: public TVirtualPacketizer. TPacketizerAdaptive. This packetizer is based on TPacketizer but uses different; load-balancing algorithms and data structures.; Two main improvements in the load-balancing strategy:; - First one was to change the order in which the files are assigned; to the computing nodes in such a way that network transfers are; evenly distributed in the query time. Transfer of the remote files; was often becoming a bottleneck at the end of a query.; - The other improvement is the use of time-based packet size. We; measure the processing rate of all the nodes and calculate the; packet size, so that it takes certain amount of time. In this way; packetizer prevents the situation where the query can't finish; because of one slow node. The data structures: TFileStat, TFileNode and TSlaveStat are; enriched + changed and TFileNode::Compare method is changed. Function Members (Methods); public:. virtual~TPacketizerAdaptive(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); virtual Int_tTVirtualPacketizer::AddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTVirtualPacketizer::AssignWork(TDSet*, Long64_t, Long64_t); virtual voidTObject::Browse(TBrowser* b); Int_tCalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObje",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:495,Performance,load,load-balancing,495,". TPacketizerAdaptive. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPacketizerAdaptive. class TPacketizerAdaptive: public TVirtualPacketizer. TPacketizerAdaptive. This packetizer is based on TPacketizer but uses different; load-balancing algorithms and data structures.; Two main improvements in the load-balancing strategy:; - First one was to change the order in which the files are assigned; to the computing nodes in such a way that network transfers are; evenly distributed in the query time. Transfer of the remote files; was often becoming a bottleneck at the end of a query.; - The other improvement is the use of time-based packet size. We; measure the processing rate of all the nodes and calculate the; packet size, so that it takes certain amount of time. In this way; packetizer prevents the situation where the query can't finish; because of one slow node. The data structures: TFileStat, TFileNode and TSlaveStat are; enriched + changed and TFileNode::Compare method is changed. Function Members (Methods); public:. virtual~TPacketizerAdaptive(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); virtual Int_tTVirtualPacketizer::AddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTVirtualPacketizer::AssignWork(TDSet*, Long64_t, Long64_t); virtual voidTObject::Browse(TBrowser* b); Int_tCalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObje",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:744,Performance,bottleneck,bottleneck,744,". TPacketizerAdaptive. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPacketizerAdaptive. class TPacketizerAdaptive: public TVirtualPacketizer. TPacketizerAdaptive. This packetizer is based on TPacketizer but uses different; load-balancing algorithms and data structures.; Two main improvements in the load-balancing strategy:; - First one was to change the order in which the files are assigned; to the computing nodes in such a way that network transfers are; evenly distributed in the query time. Transfer of the remote files; was often becoming a bottleneck at the end of a query.; - The other improvement is the use of time-based packet size. We; measure the processing rate of all the nodes and calculate the; packet size, so that it takes certain amount of time. In this way; packetizer prevents the situation where the query can't finish; because of one slow node. The data structures: TFileStat, TFileNode and TSlaveStat are; enriched + changed and TFileNode::Compare method is changed. Function Members (Methods); public:. virtual~TPacketizerAdaptive(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); virtual Int_tTVirtualPacketizer::AddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTVirtualPacketizer::AssignWork(TDSet*, Long64_t, Long64_t); virtual voidTObject::Browse(TBrowser* b); Int_tCalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObje",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:1385,Performance,latency,latency,1385," virtual~TPacketizerAdaptive(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); virtual Int_tTVirtualPacketizer::AddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTVirtualPacketizer::AssignWork(TDSet*, Long64_t, Long64_t); virtual voidTObject::Browse(TBrowser* b); Int_tCalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObje",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:1709,Performance,cache,cachesz,1709," virtual~TPacketizerAdaptive(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); virtual Int_tTVirtualPacketizer::AddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTVirtualPacketizer::AssignWork(TDSet*, Long64_t, Long64_t); virtual voidTObject::Browse(TBrowser* b); Int_tCalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObje",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:11695,Performance,cache,cache,11695,"between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. TList*fActivenodes with unfinished files; Float_tfBaseLocalPreferenceindicates how much more likely the nodes will be; Bool_tfCachePacketSynccontrol synchronization of cache and packet sizes; TList*fFileNodesnodes with files; TSortedList*fFilesToProcessGlobal list of files (TFileStat) to be processed; Bool_tfForceLocalif 1 - eliminate the remote processing; Float_tfFractionOfRemoteFilesfraction of TDSetElements that are on non-workers; Double_tfMaxEntriesRatiomax file entries to avg allowed ratio for cache-to-packet sync; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Long64_tfNEventsOnRemLocnumber of events in currently; Int_tfPacketAsAFractionused to calculate the packet size; TList*fPartitionslist of partitions on nodes; Int_tfStrategy0 means the classic and 1 (default) - the adaptive strategy; Int_tfTryReassignControls attempts to reassign packets (0 == no reassignment); TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* ",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:12033,Performance,cache,cache-to-packet,12033,"between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. TList*fActivenodes with unfinished files; Float_tfBaseLocalPreferenceindicates how much more likely the nodes will be; Bool_tfCachePacketSynccontrol synchronization of cache and packet sizes; TList*fFileNodesnodes with files; TSortedList*fFilesToProcessGlobal list of files (TFileStat) to be processed; Bool_tfForceLocalif 1 - eliminate the remote processing; Float_tfFractionOfRemoteFilesfraction of TDSetElements that are on non-workers; Double_tfMaxEntriesRatiomax file entries to avg allowed ratio for cache-to-packet sync; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Long64_tfNEventsOnRemLocnumber of events in currently; Int_tfPacketAsAFractionused to calculate the packet size; TList*fPartitionslist of partitions on nodes; Int_tfStrategy0 means the classic and 1 (default) - the adaptive strategy; Int_tfTryReassignControls attempts to reassign packets (0 == no reassignment); TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* ",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:12094,Performance,perform,performance,12094,"between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. TList*fActivenodes with unfinished files; Float_tfBaseLocalPreferenceindicates how much more likely the nodes will be; Bool_tfCachePacketSynccontrol synchronization of cache and packet sizes; TList*fFileNodesnodes with files; TSortedList*fFilesToProcessGlobal list of files (TFileStat) to be processed; Bool_tfForceLocalif 1 - eliminate the remote processing; Float_tfFractionOfRemoteFilesfraction of TDSetElements that are on non-workers; Double_tfMaxEntriesRatiomax file entries to avg allowed ratio for cache-to-packet sync; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Long64_tfNEventsOnRemLocnumber of events in currently; Int_tfPacketAsAFractionused to calculate the packet size; TList*fPartitionslist of partitions on nodes; Int_tfStrategy0 means the classic and 1 (default) - the adaptive strategy; Int_tfTryReassignControls attempts to reassign packets (0 == no reassignment); TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* ",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:13491,Performance,cache,cachesz,13491,"ent); TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* file); Remove file from the list of actives. void RemoveActiveNode(TPacketizerAdaptive::TFileNode* ); Remove node from the list of actives. void Reset(); Reset the internal data structure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t maxent = -1, Bool_t byfile = kFALSE); Check existence of file/dir/tree an get number of entries.; Assumes the files have been setup. Int_t CalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); The result depends on the fStrategy. Int_t AddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); To be used by GetNextPacket but also in reaction to kPROOF_STOPPROCESS; message (when the worker was asked to stop processing during a packet).; returns the #entries intended in the last packet - #processed entries. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet;; A meaningfull difference to TPacketizer is the fact that this; packetizer, for each worker, tries to predict whether the worker; will finish processing it's local files before the end of the query.; If yes, it allocates, to those workers, files from non-slave filenodes; or from slaves that are overloaded. The check is done every time a new; file needs to be assigned. Int_t GetActiveWorkers(); Return the number of workers still processing. Float_t GetCurrentRate(Bool_t& all); Get Estimation of the current rate; just summing the current rate",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:13620,Performance,latency,latency,13620," slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* file); Remove file from the list of actives. void RemoveActiveNode(TPacketizerAdaptive::TFileNode* ); Remove node from the list of actives. void Reset(); Reset the internal data structure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t maxent = -1, Bool_t byfile = kFALSE); Check existence of file/dir/tree an get number of entries.; Assumes the files have been setup. Int_t CalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); The result depends on the fStrategy. Int_t AddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); To be used by GetNextPacket but also in reaction to kPROOF_STOPPROCESS; message (when the worker was asked to stop processing during a packet).; returns the #entries intended in the last packet - #processed entries. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet;; A meaningfull difference to TPacketizer is the fact that this; packetizer, for each worker, tries to predict whether the worker; will finish processing it's local files before the end of the query.; If yes, it allocates, to those workers, files from non-slave filenodes; or from slaves that are overloaded. The check is done every time a new; file needs to be assigned. Int_t GetActiveWorkers(); Return the number of workers still processing. Float_t GetCurrentRate(Bool_t& all); Get Estimation of the current rate; just summing the current rates of; the active workers. Int_t GetEstEntriesProcessed(Float_t , Long64_t& ent, Long64_t& bytes, Long64_t& calls); Get estimation for the number of processed entries and bytes read at",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:6468,Safety,abort,abort,6468,"operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTVirtualPacketizer::SetFailedPackets(TList* list); virtual voidTVirtualPacketizer::SetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidTVirtualPacketizer::SetProgressStatus(TProofProgressStatus* st); voidTVirtualPacketizer::SetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTVirtualPacketizer::StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:12181,Safety,avoid,avoid,12181,"between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. TList*fActivenodes with unfinished files; Float_tfBaseLocalPreferenceindicates how much more likely the nodes will be; Bool_tfCachePacketSynccontrol synchronization of cache and packet sizes; TList*fFileNodesnodes with files; TSortedList*fFilesToProcessGlobal list of files (TFileStat) to be processed; Bool_tfForceLocalif 1 - eliminate the remote processing; Float_tfFractionOfRemoteFilesfraction of TDSetElements that are on non-workers; Double_tfMaxEntriesRatiomax file entries to avg allowed ratio for cache-to-packet sync; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Long64_tfNEventsOnRemLocnumber of events in currently; Int_tfPacketAsAFractionused to calculate the packet size; TList*fPartitionslist of partitions on nodes; Int_tfStrategy0 means the classic and 1 (default) - the adaptive strategy; Int_tfTryReassignControls attempts to reassign packets (0 == no reassignment); TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* ",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:14052,Safety,predict,predict,14052,"izerAdaptive::TFileStat* file); Remove file from the list of actives. void RemoveActiveNode(TPacketizerAdaptive::TFileNode* ); Remove node from the list of actives. void Reset(); Reset the internal data structure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t maxent = -1, Bool_t byfile = kFALSE); Check existence of file/dir/tree an get number of entries.; Assumes the files have been setup. Int_t CalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); The result depends on the fStrategy. Int_t AddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); To be used by GetNextPacket but also in reaction to kPROOF_STOPPROCESS; message (when the worker was asked to stop processing during a packet).; returns the #entries intended in the last packet - #processed entries. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet;; A meaningfull difference to TPacketizer is the fact that this; packetizer, for each worker, tries to predict whether the worker; will finish processing it's local files before the end of the query.; If yes, it allocates, to those workers, files from non-slave filenodes; or from slaves that are overloaded. The check is done every time a new; file needs to be assigned. Int_t GetActiveWorkers(); Return the number of workers still processing. Float_t GetCurrentRate(Bool_t& all); Get Estimation of the current rate; just summing the current rates of; the active workers. Int_t GetEstEntriesProcessed(Float_t , Long64_t& ent, Long64_t& bytes, Long64_t& calls); Get estimation for the number of processed entries and bytes read at time t,; based on the numbers already processed and the latests worker measured speeds.; If t <= 0 the current time is used.; Only the estimation for the entries is currently implemented.; This is needed to smooth the instantaneous rate plot. void MarkBad(TSlave* s, TProofProgressStatus* status, TList** missingFiles); This method c",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:1724,Usability,learn,learnent,1724," virtual~TPacketizerAdaptive(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); virtual Int_tTVirtualPacketizer::AddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTVirtualPacketizer::AssignWork(TDSet*, Long64_t, Long64_t); virtual voidTObject::Browse(TBrowser* b); Int_tCalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObje",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerAdaptive.html:13506,Usability,learn,learnent,13506,"ent); TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* file); Remove file from the list of actives. void RemoveActiveNode(TPacketizerAdaptive::TFileNode* ); Remove node from the list of actives. void Reset(); Reset the internal data structure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t maxent = -1, Bool_t byfile = kFALSE); Check existence of file/dir/tree an get number of entries.; Assumes the files have been setup. Int_t CalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); The result depends on the fStrategy. Int_t AddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); To be used by GetNextPacket but also in reaction to kPROOF_STOPPROCESS; message (when the worker was asked to stop processing during a packet).; returns the #entries intended in the last packet - #processed entries. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet;; A meaningfull difference to TPacketizer is the fact that this; packetizer, for each worker, tries to predict whether the worker; will finish processing it's local files before the end of the query.; If yes, it allocates, to those workers, files from non-slave filenodes; or from slaves that are overloaded. The check is done every time a new; file needs to be assigned. Int_t GetActiveWorkers(); Return the number of workers still processing. Float_t GetCurrentRate(Bool_t& all); Get Estimation of the current rate; just summing the current rate",MatchSource.WIKI,root/html604/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerAdaptive.html
https://root.cern/root/html604/TPacketizerFile.html:1696,Availability,error,error,1696,"t**); virtual Int_tTVirtualPacketizer::AddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTVirtualPacketizer::AssignWork(TDSet*, Long64_t, Long64_t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tTVirtualPacketizer::GetBytesRead() const; TList*TVirtualPacketizer::GetConfigParams(Bool_t steal = kFALSE); Double_tTVirtualPacketizer::GetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); Double_tGetCurrentTime(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tTVirtualPacketizer::GetEntriesProcessed() const; virtual Int_tTVirtualPacketizer::GetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*TVirtualPacketizer::GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tTVirtualPa",MatchSource.WIKI,root/html604/TPacketizerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerFile.html
https://root.cern/root/html604/TPacketizerFile.html:1780,Availability,error,error,1780,"ct::AppendPad(Option_t* option = """"); virtual Int_tTVirtualPacketizer::AssignWork(TDSet*, Long64_t, Long64_t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tTVirtualPacketizer::GetBytesRead() const; TList*TVirtualPacketizer::GetConfigParams(Bool_t steal = kFALSE); Double_tTVirtualPacketizer::GetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); Double_tGetCurrentTime(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tTVirtualPacketizer::GetEntriesProcessed() const; virtual Int_tTVirtualPacketizer::GetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*TVirtualPacketizer::GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tTVirtualPacketizer::GetInitTime() const; virtual const char*TObject::GetName() const; virtual ",MatchSource.WIKI,root/html604/TPacketizerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerFile.html
https://root.cern/root/html604/TPacketizerFile.html:8151,Deployability,configurat,configuration,8151,"ontextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; TList*TVirtualPacketizer::fInputInput list; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_",MatchSource.WIKI,root/html604/TPacketizerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerFile.html
https://root.cern/root/html604/TPacketizerFile.html:8994,Deployability,update,updates,8994,"ontextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; TList*TVirtualPacketizer::fInputInput list; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_",MatchSource.WIKI,root/html604/TPacketizerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerFile.html
https://root.cern/root/html604/TPacketizerFile.html:9565,Deployability,update,updates,9565,"at_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::fTimeUpdttime between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. Bool_tfAddFileInfoWhether to add the TFileInfo object in the packet; Long64_tfAssignedNo.files processed or being processed.; TMap*fFilesFiles to be produced/processed per node; TList*fItersIterators on the file lists per node; TList*fNotAssignedList of files not assigned to a specific node; Bool_tfProcNotAssignedWhether to process files not asdigned to a worker; TStopwatch*fStopwatchFor measuring the start time of each packet. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerFile(TList* workers, Long64_t , TList* inp",MatchSource.WIKI,root/html604/TPacketizerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerFile.html
https://root.cern/root/html604/TPacketizerFile.html:8151,Modifiability,config,configuration,8151,"ontextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; TList*TVirtualPacketizer::fInputInput list; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_",MatchSource.WIKI,root/html604/TPacketizerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerFile.html
https://root.cern/root/html604/TPacketizerFile.html:5714,Safety,abort,abort,5714,"d* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTVirtualPacketizer::SetFailedPackets(TList* list); virtual voidTVirtualPacketizer::SetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidTVirtualPacketizer::SetProgressStatus(TProofProgressStatus* st); voidTVirtualPacketizer::SetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTVirtualPacketizer::StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TPacketizerFile(TList* workers, Long64_t, TList* input, TProofProgressStatus* st = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TPacketizerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerFile.html
https://root.cern/root/html604/TPacketizerMulti.html:1877,Availability,error,error,1877,"ing); virtual Int_tTVirtualPacketizer::AddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTVirtualPacketizer::AssignWork(TDSet*, Long64_t, Long64_t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tTVirtualPacketizer::GetBytesRead() const; TList*TVirtualPacketizer::GetConfigParams(Bool_t steal = kFALSE); Double_tTVirtualPacketizer::GetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tTVirtualPacketizer::GetEntriesProcessed() const; virtual Int_tGetEstEntriesProcessed(Float_t f, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*TVirtualPacketizer::GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tTVirtualPacketizer::GetInitTime() const; virtual const",MatchSource.WIKI,root/html604/TPacketizerMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerMulti.html
https://root.cern/root/html604/TPacketizerMulti.html:1961,Availability,error,error,1961,"ct::AppendPad(Option_t* option = """"); virtual Int_tTVirtualPacketizer::AssignWork(TDSet*, Long64_t, Long64_t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tTVirtualPacketizer::GetBytesRead() const; TList*TVirtualPacketizer::GetConfigParams(Bool_t steal = kFALSE); Double_tTVirtualPacketizer::GetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tTVirtualPacketizer::GetEntriesProcessed() const; virtual Int_tGetEstEntriesProcessed(Float_t f, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*TVirtualPacketizer::GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tTVirtualPacketizer::GetInitTime() const; virtual const char*TObject::GetName() const; virtual TDSetElement*GetNextPacket(TSlave* wrk, TMes",MatchSource.WIKI,root/html604/TPacketizerMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerMulti.html
https://root.cern/root/html604/TPacketizerMulti.html:11184,Availability,failure,failure,11184,"ucted properly?; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. TMap*fAssignedPackMap {worker,packetizer} of lat assignement; TVirtualPacketizer*fCurrentPacketizer being currently processed; TList*fPacketizersPacketizers to be processed; TIter*fPacketizersIterIterator on fPacketizers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerMulti(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerMulti(); Destructor. TDSetElement * GetNextPacket(TSlave* wrk, TMessage* r); Get next packet from the current packetizer.; If the current packetizer is done, move to next.; Retun null when all packetizers are done. TVirtualPacketizer * CreatePacketizer(TDSet* dset, TList* wrks, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Create a packetizer for dataset 'dset'; Return null on failure. TPacketizerMulti(). TPacketizerMulti(const TPacketizerMulti& ). void operator=(const TPacketizerMulti& ). Int_t GetEstEntriesProcessed(Float_t f, Long64_t& ent, Long64_t& bytes, Long64_t& calls). Float_t GetCurrentRate(Bool_t& all). void StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE). void MarkBad(TSlave* wrk, TProofProgressStatus* st, TList** missing); { if (fCurrent) fCurrent->MarkBad(wrk, st, missing); return; }. Int_t AddProcessed(TSlave* wrk, TProofProgressStatus* st, Double_t lat, TList** missing). Int_t GetActiveWorkers(); { if (fCurrent) return fCurrent->GetActiveWorkers(); return 0; }. » Author: G. Ganis Jan 2010 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Tue Jun 2 16:25:58 2015 » Last generated: 2015-06-02 16:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please s",MatchSource.WIKI,root/html604/TPacketizerMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerMulti.html
https://root.cern/root/html604/TPacketizerMulti.html:8429,Deployability,configurat,configuration,8429,"ontextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; TList*TVirtualPacketizer::fInputInput list; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_",MatchSource.WIKI,root/html604/TPacketizerMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerMulti.html
https://root.cern/root/html604/TPacketizerMulti.html:9272,Deployability,update,updates,9272,"ontextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; TList*TVirtualPacketizer::fInputInput list; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_",MatchSource.WIKI,root/html604/TPacketizerMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerMulti.html
https://root.cern/root/html604/TPacketizerMulti.html:9843,Deployability,update,updates,9843,"at_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::fTimeUpdttime between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. TMap*fAssignedPackMap {worker,packetizer} of lat assignement; TVirtualPacketizer*fCurrentPacketizer being currently processed; TList*fPacketizersPacketizers to be processed; TIter*fPacketizersIterIterator on fPacketizers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerMulti(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerMulti(); Destructor. TDSetElement * GetNextPacket(TSlave* wrk, TMessage* r); Get next packet from the current packetizer.;",MatchSource.WIKI,root/html604/TPacketizerMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerMulti.html
https://root.cern/root/html604/TPacketizerMulti.html:8429,Modifiability,config,configuration,8429,"ontextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; TList*TVirtualPacketizer::fInputInput list; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_",MatchSource.WIKI,root/html604/TPacketizerMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerMulti.html
https://root.cern/root/html604/TPacketizerMulti.html:5826,Safety,abort,abort,5826,"oid* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTVirtualPacketizer::SetFailedPackets(TList* list); virtual voidTVirtualPacketizer::SetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidTVirtualPacketizer::SetProgressStatus(TProofProgressStatus* st); voidTVirtualPacketizer::SetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TPacketizerMulti(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TPacketizerMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerMulti.html
https://root.cern/root/html604/TPacketizerMulti.html:11450,Safety,abort,abort,11450,"ualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. TMap*fAssignedPackMap {worker,packetizer} of lat assignement; TVirtualPacketizer*fCurrentPacketizer being currently processed; TList*fPacketizersPacketizers to be processed; TIter*fPacketizersIterIterator on fPacketizers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerMulti(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerMulti(); Destructor. TDSetElement * GetNextPacket(TSlave* wrk, TMessage* r); Get next packet from the current packetizer.; If the current packetizer is done, move to next.; Retun null when all packetizers are done. TVirtualPacketizer * CreatePacketizer(TDSet* dset, TList* wrks, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Create a packetizer for dataset 'dset'; Return null on failure. TPacketizerMulti(). TPacketizerMulti(const TPacketizerMulti& ). void operator=(const TPacketizerMulti& ). Int_t GetEstEntriesProcessed(Float_t f, Long64_t& ent, Long64_t& bytes, Long64_t& calls). Float_t GetCurrentRate(Bool_t& all). void StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE). void MarkBad(TSlave* wrk, TProofProgressStatus* st, TList** missing); { if (fCurrent) fCurrent->MarkBad(wrk, st, missing); return; }. Int_t AddProcessed(TSlave* wrk, TProofProgressStatus* st, Double_t lat, TList** missing). Int_t GetActiveWorkers(); { if (fCurrent) return fCurrent->GetActiveWorkers(); return 0; }. » Author: G. Ganis Jan 2010 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Tue Jun 2 16:25:58 2015 » Last generated: 2015-06-02 16:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TPacketizerMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerMulti.html
https://root.cern/root/html604/TPacketizerUnit.html:1913,Availability,error,error,1913,"ProofProgressStatus*, Double_t, TList**); virtual Int_tAddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tAssignWork(TDSet*, Long64_t, Long64_t num); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tTVirtualPacketizer::GetBytesRead() const; TList*TVirtualPacketizer::GetConfigParams(Bool_t steal = kFALSE); Double_tTVirtualPacketizer::GetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); Double_tGetCurrentTime(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tTVirtualPacketizer::GetEntriesProcessed() const; virtual Int_tTVirtualPacketizer::GetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*TVirtualPacketizer::GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tTVirtualPa",MatchSource.WIKI,root/html604/TPacketizerUnit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerUnit.html
https://root.cern/root/html604/TPacketizerUnit.html:1997,Availability,error,error,1997,"irtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tAssignWork(TDSet*, Long64_t, Long64_t num); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tTVirtualPacketizer::GetBytesRead() const; TList*TVirtualPacketizer::GetConfigParams(Bool_t steal = kFALSE); Double_tTVirtualPacketizer::GetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); Double_tGetCurrentTime(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tTVirtualPacketizer::GetEntriesProcessed() const; virtual Int_tTVirtualPacketizer::GetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*TVirtualPacketizer::GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tTVirtualPacketizer::GetInitTime() const; virtual const char*TObject::GetName() const; virtual ",MatchSource.WIKI,root/html604/TPacketizerUnit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerUnit.html
https://root.cern/root/html604/TPacketizerUnit.html:11531,Availability,failure,failure,11531,"Constructed properly?; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. Long64_tfAssignedEntries processed or being processed.; Double_tfCalibFracSize of the calibrating packet as fraction of Ntot/Nwrk; Bool_tfFixedNumWhether we must assign a fixed number of cycles per worker; Long64_tfNumPerWorkerNumber of cycles per worker, if this option; Long64_tfPacketSeqSequential number of the last packet assigned; TList*fPacketsAll processed packets; Long64_tfProcessingEvent being processed; TStopwatch*fStopwatchFor measuring the start time of each packet; TList*fWrkExcludedList of nodes excluded from distribution; TMap*fWrkStatsWorker status, keyed by correspondig TSlave. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerUnit(TList* slaves, Long64_t num, TList* input, TProofProgressStatus* st = 0); Constructor. Int_t AssignWork(TDSet* , Long64_t , Long64_t num); Assign work to be done to this packetizer. ~TPacketizerUnit(); Destructor. Double_t GetCurrentTime(); Get current time. Float_t GetCurrentRate(Bool_t& all); Get Estimation of the current rate; just summing the current rates of; the active workers. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet. Int_t AddWorkers(TList* workers); Adds new workers. Returns the number of workers added, or -1 on failure. TPacketizerUnit(). TPacketizerUnit(const TPacketizerUnit& ). void operator=(const TPacketizerUnit& ). Int_t GetActiveWorkers(); { return fWrkStats->GetSize(); }. » Author: Long Tran-Thanh 22/07/07 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-02 16:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TPacketizerUnit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerUnit.html
https://root.cern/root/html604/TPacketizerUnit.html:8370,Deployability,configurat,configuration,8370,"ontextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; TList*TVirtualPacketizer::fInputInput list; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_",MatchSource.WIKI,root/html604/TPacketizerUnit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerUnit.html
https://root.cern/root/html604/TPacketizerUnit.html:9213,Deployability,update,updates,9213,"ontextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; TList*TVirtualPacketizer::fInputInput list; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_",MatchSource.WIKI,root/html604/TPacketizerUnit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerUnit.html
https://root.cern/root/html604/TPacketizerUnit.html:9784,Deployability,update,updates,9784,"at_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::fTimeUpdttime between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. Long64_tfAssignedEntries processed or being processed.; Double_tfCalibFracSize of the calibrating packet as fraction of Ntot/Nwrk; Bool_tfFixedNumWhether we must assign a fixed number of cycles per worker; Long64_tfNumPerWorkerNumber of cycles per worker, if this option; Long64_tfPacketSeqSequential number of the last packet assigned; TList*fPacketsAll processed packets; Long64_tfProcessingEvent being processed; TStopwatch*fStopwatchFor measuring the start time of each packet; TList*fWrkExcludedList of nodes excluded from distribution; TMap*fWrkStatsWorker status, keyed",MatchSource.WIKI,root/html604/TPacketizerUnit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerUnit.html
https://root.cern/root/html604/TPacketizerUnit.html:8370,Modifiability,config,configuration,8370,"ontextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; TList*TVirtualPacketizer::fInputInput list; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_",MatchSource.WIKI,root/html604/TPacketizerUnit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerUnit.html
https://root.cern/root/html604/TPacketizerUnit.html:595,Performance,perform,performance,595,". TPacketizerUnit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPacketizerUnit. class TPacketizerUnit: public TVirtualPacketizer. TPacketizerUnit. This packetizer generates packets of generic units, representing the; number of times an operation cycle has to be repeated by the worker; node, e.g. the number of Monte carlo events to be generated.; Packets sizes are generated taking into account the performance of; worker nodes, based on the time needed to process previous packets,; with the goal of having all workers ending at the same time. Function Members (Methods); public:. virtual~TPacketizerUnit(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTVirtualPacketizer::AddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual Int_tAddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tAssignWork(TDSet*, Long64_t, Long64_t num); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* erro",MatchSource.WIKI,root/html604/TPacketizerUnit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerUnit.html
https://root.cern/root/html604/TPacketizerUnit.html:5930,Safety,abort,abort,5930,"ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTVirtualPacketizer::SetFailedPackets(TList* list); virtual voidTVirtualPacketizer::SetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidTVirtualPacketizer::SetProgressStatus(TProofProgressStatus* st); voidTVirtualPacketizer::SetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTVirtualPacketizer::StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TPacketizerUnit(TList* slaves, Long64_t num, TList* input, TProofProgressStatus* st = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TPacketizerUnit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPacketizerUnit.html
https://root.cern/root/html604/TPad.html:7219,Availability,error,error,7219,"st char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidEventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual Double_tGetAbsHNDC() const; virtual Double_tGetAbsWNDC() const; virtual Double_tGetAbsXlowNDC() const; virtual Double_tGetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tGetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Rectangle_tGetBBox(); virtual TPointGetBBoxCenter(); virtual Short_tGetBorderMode() const; virtual Short_tGetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*GetCanvas() const; virtual Int_tGetCanvasID() const; virtual TCanvasImp*GetCanvasImp() const; Int_tGetCrosshair() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtor",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:7303,Availability,error,error,7303,"m); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidEventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual Double_tGetAbsHNDC() const; virtual Double_tGetAbsWNDC() const; virtual Double_tGetAbsXlowNDC() const; virtual Double_tGetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tGetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Rectangle_tGetBBox(); virtual TPointGetBBoxCenter(); virtual Short_tGetBorderMode() const; virtual Short_tGetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*GetCanvas() const; virtual Int_tGetCanvasID() const; virtual TCanvasImp*GetCanvasImp() const; Int_tGetCrosshair() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEvent() const; virtual Int_tGetEventX() const; virtual Int_t",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:25775,Availability,down,down,25775,,MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:33664,Availability,failure,failure,33664,"); Execute the list of Execs when a pad event occurs. void Browse(TBrowser* b); Browse pad. TLegend * BuildLegend(Double_t x1 = 0.5, Double_t y1 = 0.67000000000000004, Double_t x2 = 0.88, Double_t y2 = 0.88, const char* title = """"); Build a legend from the graphical objects in the pad. A simple method to build automatically a TLegend from the; primitives in a TPad. Only those deriving from TAttLine,; TAttMarker and TAttFill are added, excluding TPave and TFrame; derived classes. x1, y1, x2, y2 are the TLegend coordinates.; title is the legend title. By default it is "" "". The caller; program owns the returned TLegend. If the pad contains some TMultiGraph or THStack the individual; graphs or histograms in them are added to the TLegend. TVirtualPad * cd(Int_t subpadnumber = 0); Set Current pad.; When a canvas/pad is divided via TPad::Divide, one can directly; set the current path to one of the subdivisions.; See TPad::Divide for the convention to number subpads.; Returns the new current pad, or 0 in case of failure.; For example:; c1.Divide(2,3); // create 6 pads (2 divisions along x, 3 along y).; To set the current pad to the bottom right pad, do; c1.cd(6);; Note1: c1.cd() is equivalent to c1.cd(0) and sets the current pad; to c1 itself.; Note2: after a statement like c1.cd(6), the global variable gPad; points to the current pad. One can use gPad to set attributes; of the current pad.; Note3: One can get a pointer to one of the sub-pads of pad with:; TPad *subpad = (TPad*)pad->GetPad(subpadnumber);. void Clear(Option_t* option = """"); Delete all pad primitives. If the bit kClearAfterCR has been set for this pad, the Clear function; will execute only after having pressed a CarriageReturn; Set the bit with mypad->SetBit(TPad::kClearAfterCR). Int_t Clip(Float_t* x, Float_t* y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt); Clipping routine: Cohen Sutherland algorithm. If Clip ==2 the segment is outside the boundary.; If Clip ==1 the segment has one point ",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:41845,Deployability,release,released,41845,"n is called when a TPad object is clicked. If the mouse is clicked in one of the 4 corners of the pad (pA,pB,pC,pD); the pad is resized with the rubber rectangle. If the mouse is clicked inside the pad, the pad is moved. If the mouse is clicked on the 4 edges (pL,pR,pTop,pBot), the pad is scaled; parallel to this edge. pA pTop pB; +--------------------------------------------+; | |; | |; | |; pL| pINSIDE |pR; | |; | |; | |; | |; +--------------------------------------------+; pD pBot pC. Note that this function duplicates on purpose the functionality; already implemented in TBox::ExecuteEvent.; If somebody modifies this function, may be similar changes should also; be applied to TBox::ExecuteEvent. void ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); Execute action corresponding to one event for a TAxis object; (called by TAxis::ExecuteEvent.); This member function is called when an axis is clicked with the locator. The axis range is set between the position where the mouse is pressed; and the position where it is released.; If the mouse position is outside the current axis range when it is released; the axis is unzoomed with the corresponding proportions.; Note that the mouse does not need to be in the pad or even canvas; when it is released. TObject * FindObject(const char* name) const; Search if object named name is inside this pad or in pads inside this pad. In case name is in several subpads the first one is returned. TObject * FindObject(const TObject* obj) const; Search if obj is in pad or in pads inside this pad. In case obj is in several subpads the first one is returned. Int_t GetCanvasID() const; Get canvas identifier. TCanvasImp * GetCanvasImp() const; Get canvas implementation pointer if any. Int_t GetEvent() const; Get Event. Int_t GetEventX() const; Get X event. Int_t GetEventY() const; Get Y event. TVirtualPad * GetVirtCanvas() const; Get virtual canvas. Color_t GetHighLightColor() const; Get highlight color. Int_t GetMaxPickDistance(",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:41923,Deployability,release,released,41923,"ad is resized with the rubber rectangle. If the mouse is clicked inside the pad, the pad is moved. If the mouse is clicked on the 4 edges (pL,pR,pTop,pBot), the pad is scaled; parallel to this edge. pA pTop pB; +--------------------------------------------+; | |; | |; | |; pL| pINSIDE |pR; | |; | |; | |; | |; +--------------------------------------------+; pD pBot pC. Note that this function duplicates on purpose the functionality; already implemented in TBox::ExecuteEvent.; If somebody modifies this function, may be similar changes should also; be applied to TBox::ExecuteEvent. void ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); Execute action corresponding to one event for a TAxis object; (called by TAxis::ExecuteEvent.); This member function is called when an axis is clicked with the locator. The axis range is set between the position where the mouse is pressed; and the position where it is released.; If the mouse position is outside the current axis range when it is released; the axis is unzoomed with the corresponding proportions.; Note that the mouse does not need to be in the pad or even canvas; when it is released. TObject * FindObject(const char* name) const; Search if object named name is inside this pad or in pads inside this pad. In case name is in several subpads the first one is returned. TObject * FindObject(const TObject* obj) const; Search if obj is in pad or in pads inside this pad. In case obj is in several subpads the first one is returned. Int_t GetCanvasID() const; Get canvas identifier. TCanvasImp * GetCanvasImp() const; Get canvas implementation pointer if any. Int_t GetEvent() const; Get Event. Int_t GetEventX() const; Get X event. Int_t GetEventY() const; Get Y event. TVirtualPad * GetVirtCanvas() const; Get virtual canvas. Color_t GetHighLightColor() const; Get highlight color. Int_t GetMaxPickDistance(); Static function (see also TPad::SetMaxPickDistance). TObject * GetSelected() const; Get selected. TVirtualPad * GetSelec",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:42069,Deployability,release,released,42069,"is clicked on the 4 edges (pL,pR,pTop,pBot), the pad is scaled; parallel to this edge. pA pTop pB; +--------------------------------------------+; | |; | |; | |; pL| pINSIDE |pR; | |; | |; | |; | |; +--------------------------------------------+; pD pBot pC. Note that this function duplicates on purpose the functionality; already implemented in TBox::ExecuteEvent.; If somebody modifies this function, may be similar changes should also; be applied to TBox::ExecuteEvent. void ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); Execute action corresponding to one event for a TAxis object; (called by TAxis::ExecuteEvent.); This member function is called when an axis is clicked with the locator. The axis range is set between the position where the mouse is pressed; and the position where it is released.; If the mouse position is outside the current axis range when it is released; the axis is unzoomed with the corresponding proportions.; Note that the mouse does not need to be in the pad or even canvas; when it is released. TObject * FindObject(const char* name) const; Search if object named name is inside this pad or in pads inside this pad. In case name is in several subpads the first one is returned. TObject * FindObject(const TObject* obj) const; Search if obj is in pad or in pads inside this pad. In case obj is in several subpads the first one is returned. Int_t GetCanvasID() const; Get canvas identifier. TCanvasImp * GetCanvasImp() const; Get canvas implementation pointer if any. Int_t GetEvent() const; Get Event. Int_t GetEventX() const; Get X event. Int_t GetEventY() const; Get Y event. TVirtualPad * GetVirtCanvas() const; Get virtual canvas. Color_t GetHighLightColor() const; Get highlight color. Int_t GetMaxPickDistance(); Static function (see also TPad::SetMaxPickDistance). TObject * GetSelected() const; Get selected. TVirtualPad * GetSelectedPad() const; Get selected pad. TVirtualPad * GetPadSave() const; Get save pad. UInt_t GetWh() const; Get Wh. ",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:32554,Energy Efficiency,power,powerful,32554,"mands; contained in the fExecs list are executed in the order found in the list.; This facility is activated by default. It can be deactivated by using; the canvas ""Option"" menu.; The following examples of TExec commands are provided in the tutorials:; macros exec1.C and exec2.C.; Example1 of use of exec1.C. Root > TFile f(""hsimple.root""); Root > hpx.Draw(); Root > c1.AddExec(""ex1"","".x exec1.C""); At this point you can use the mouse to click on the contour of; the histogram hpx. When the mouse is clicked, the bin number and its; contents are printed.; Example2 of use of exec1.C. Root > TFile f(""hsimple.root""); Root > hpxpy.Draw(); Root > c1.AddExec(""ex2"","".x exec2.C""); When moving the mouse in the canvas, a second canvas shows the; projection along X of the bin corresponding to the Y position; of the mouse. The resulting histogram is fitted with a gaussian.; A ""dynamic"" line shows the current bin position in Y.; This more elaborated example can be used as a starting point; to develop more powerful interactive applications exploiting CINT; as a development engine. void AutoExec(); Execute the list of Execs when a pad event occurs. void Browse(TBrowser* b); Browse pad. TLegend * BuildLegend(Double_t x1 = 0.5, Double_t y1 = 0.67000000000000004, Double_t x2 = 0.88, Double_t y2 = 0.88, const char* title = """"); Build a legend from the graphical objects in the pad. A simple method to build automatically a TLegend from the; primitives in a TPad. Only those deriving from TAttLine,; TAttMarker and TAttFill are added, excluding TPave and TFrame; derived classes. x1, y1, x2, y2 are the TLegend coordinates.; title is the legend title. By default it is "" "". The caller; program owns the returned TLegend. If the pad contains some TMultiGraph or THStack the individual; graphs or histograms in them are added to the TLegend. TVirtualPad * cd(Int_t subpadnumber = 0); Set Current pad.; When a canvas/pad is divided via TPad::Divide, one can directly; set the current path to one of the subd",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:36080,Energy Efficiency,allocate,allocated,36080," Clip ==1 the segment has one point outside the boundary.; If Clip ==0 the segment is inside the boundary. _Input parameters:. x[2], y[2] : Segment coordinates; xclipl, yclipb, xclipr, yclipt : Clipping boundary. _Output parameters:. x[2], y[2] : New segment coordinates. Int_t ClippingCode(Double_t x, Double_t y, Double_t xcl1, Double_t ycl1, Double_t xcl2, Double_t ycl2); Compute the endpoint codes for TPad::Clip. Int_t ClipPolygon(Int_t n, Double_t* x, Double_t* y, Int_t nn, Double_t* xc, Double_t* yc, Double_t xclipl, Double_t yclipb, Double_t xclipr, Double_t yclipt); Clip polygon using the Sutherland-Hodgman algorithm. Input parameters:. n: Number of points in the polygon to be clipped; x[n], y[n] : Polygon do be clipped vertices; xclipl, yclipb, xclipr, yclipt : Clipping boundary. Output parameters:. nn: number of points in xc and yc; xc, yc: clipped polygon vertices. The Int_t returned by this function is; the number of points in the clipped polygon. These vectors must; be allocated by the calling function. A size of 2*n for each is; enough. Sutherland and Hodgman's polygon-clipping algorithm uses a divide-and-conquer; strategy: It solves a series of simple and identical problems that, when; combined, solve the overall problem. The simple problem is to clip a polygon; against a single infinite clip edge. Four clip edges, each defining one boundary; of the clip rectangle, successively clip a polygon against a clip rectangle. Steps of Sutherland-Hodgman's polygon-clipping algorithm:. * Polygons can be clipped against each edge of the window one at a time.; Windows/edge intersections, if any, are easy to find since the X or Y coordinates; are already known.; * Vertices which are kept after clipping against one window edge are saved for; clipping against the remaining edges.; * Note that the number of vertices usually changes and will often increases. The clip boundary determines a visible and invisible region. The edges from; vertex i to vertex i+1 can be one of",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:34520,Integrability,rout,routine,34520,"ad::Divide, one can directly; set the current path to one of the subdivisions.; See TPad::Divide for the convention to number subpads.; Returns the new current pad, or 0 in case of failure.; For example:; c1.Divide(2,3); // create 6 pads (2 divisions along x, 3 along y).; To set the current pad to the bottom right pad, do; c1.cd(6);; Note1: c1.cd() is equivalent to c1.cd(0) and sets the current pad; to c1 itself.; Note2: after a statement like c1.cd(6), the global variable gPad; points to the current pad. One can use gPad to set attributes; of the current pad.; Note3: One can get a pointer to one of the sub-pads of pad with:; TPad *subpad = (TPad*)pad->GetPad(subpadnumber);. void Clear(Option_t* option = """"); Delete all pad primitives. If the bit kClearAfterCR has been set for this pad, the Clear function; will execute only after having pressed a CarriageReturn; Set the bit with mypad->SetBit(TPad::kClearAfterCR). Int_t Clip(Float_t* x, Float_t* y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt); Clipping routine: Cohen Sutherland algorithm. If Clip ==2 the segment is outside the boundary.; If Clip ==1 the segment has one point outside the boundary.; If Clip ==0 the segment is inside the boundary. _Input parameters:. x[2], y[2] : Segment coordinates; xclipl, yclipb, xclipr, yclipt : Clipping boundary. _Output parameters:. x[2], y[2] : New segment coordinates. Int_t Clip(Double_t* x, Double_t* y, Double_t xclipl, Double_t yclipb, Double_t xclipr, Double_t yclipt); Clipping routine: Cohen Sutherland algorithm. If Clip ==2 the segment is outside the boundary.; If Clip ==1 the segment has one point outside the boundary.; If Clip ==0 the segment is inside the boundary. _Input parameters:. x[2], y[2] : Segment coordinates; xclipl, yclipb, xclipr, yclipt : Clipping boundary. _Output parameters:. x[2], y[2] : New segment coordinates. Int_t ClippingCode(Double_t x, Double_t y, Double_t xcl1, Double_t ycl1, Double_t xcl2, Double_t ycl2); Compute the endpoint c",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:34996,Integrability,rout,routine,34996,"able gPad; points to the current pad. One can use gPad to set attributes; of the current pad.; Note3: One can get a pointer to one of the sub-pads of pad with:; TPad *subpad = (TPad*)pad->GetPad(subpadnumber);. void Clear(Option_t* option = """"); Delete all pad primitives. If the bit kClearAfterCR has been set for this pad, the Clear function; will execute only after having pressed a CarriageReturn; Set the bit with mypad->SetBit(TPad::kClearAfterCR). Int_t Clip(Float_t* x, Float_t* y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt); Clipping routine: Cohen Sutherland algorithm. If Clip ==2 the segment is outside the boundary.; If Clip ==1 the segment has one point outside the boundary.; If Clip ==0 the segment is inside the boundary. _Input parameters:. x[2], y[2] : Segment coordinates; xclipl, yclipb, xclipr, yclipt : Clipping boundary. _Output parameters:. x[2], y[2] : New segment coordinates. Int_t Clip(Double_t* x, Double_t* y, Double_t xclipl, Double_t yclipb, Double_t xclipr, Double_t yclipt); Clipping routine: Cohen Sutherland algorithm. If Clip ==2 the segment is outside the boundary.; If Clip ==1 the segment has one point outside the boundary.; If Clip ==0 the segment is inside the boundary. _Input parameters:. x[2], y[2] : Segment coordinates; xclipl, yclipb, xclipr, yclipt : Clipping boundary. _Output parameters:. x[2], y[2] : New segment coordinates. Int_t ClippingCode(Double_t x, Double_t y, Double_t xcl1, Double_t ycl1, Double_t xcl2, Double_t ycl2); Compute the endpoint codes for TPad::Clip. Int_t ClipPolygon(Int_t n, Double_t* x, Double_t* y, Int_t nn, Double_t* xc, Double_t* yc, Double_t xclipl, Double_t yclipb, Double_t xclipr, Double_t yclipt); Clip polygon using the Sutherland-Hodgman algorithm. Input parameters:. n: Number of points in the polygon to be clipped; x[n], y[n] : Polygon do be clipped vertices; xclipl, yclipb, xclipr, yclipt : Clipping boundary. Output parameters:. nn: number of points in xc and yc; xc, yc: clipped po",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:43109,Integrability,depend,depending,43109,"const char* name) const; Search if object named name is inside this pad or in pads inside this pad. In case name is in several subpads the first one is returned. TObject * FindObject(const TObject* obj) const; Search if obj is in pad or in pads inside this pad. In case obj is in several subpads the first one is returned. Int_t GetCanvasID() const; Get canvas identifier. TCanvasImp * GetCanvasImp() const; Get canvas implementation pointer if any. Int_t GetEvent() const; Get Event. Int_t GetEventX() const; Get X event. Int_t GetEventY() const; Get Y event. TVirtualPad * GetVirtCanvas() const; Get virtual canvas. Color_t GetHighLightColor() const; Get highlight color. Int_t GetMaxPickDistance(); Static function (see also TPad::SetMaxPickDistance). TObject * GetSelected() const; Get selected. TVirtualPad * GetSelectedPad() const; Get selected pad. TVirtualPad * GetPadSave() const; Get save pad. UInt_t GetWh() const; Get Wh. UInt_t GetWw() const; Get Ww. void HideToolTip(Int_t event); Hide tool tip depending on the event type. Typically tool tips; are hidden when event is not a kMouseEnter and not a kMouseMotion; event. Bool_t IsBatch() const; Is pad in batch mode ?. Bool_t IsRetained() const; Is pad retained ?. Bool_t OpaqueMoving() const; Is pad moving in opaque mode ?. Bool_t OpaqueResizing() const; Is pad resizing in opaque mode ?. void SetBatch(Bool_t batch = kTRUE); Set pad in batch mode. void SetCanvasSize(UInt_t ww, UInt_t wh); Set canvas size. void SetCursor(ECursor cursor); Set cursor type. void SetDoubleBuffer(Int_t mode = 1); Set double buffer mode ON or OFF. void SetSelected(TObject* obj); Set selected. void Update(); Update pad. TFrame * GetFrame(); Get frame. TObject * GetPrimitive(const char* name) const; Get primitive. TVirtualPad * GetPad(Int_t subpadnumber) const; Get a pointer to subpadnumber of this pad. void GetPadPar(Double_t& xlow, Double_t& ylow, Double_t& xup, Double_t& yup); Return lower and upper bounds of the pad in NDC coordinates. void GetR",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:46885,Integrability,rout,routine,46885,"x, Float_t* y, Option_t* option = """"); Paint fill area in CurrentPad World coordinates. void PaintFillArea(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); Paint fill area in CurrentPad World coordinates. void PaintFillAreaHatches(Int_t n, Double_t* x, Double_t* y, Int_t FillStyle); This function paints hatched fill area arcording to the FillStyle value; The convention for the Hatch is the following:. FillStyle = 3ijk. i (1-9) : specify the space between each hatch; 1 = minimum 9 = maximum; the final spacing is i*GetHatchesSpacing(). The hatches spacing; is set by SetHatchesSpacing(). j (0-9) : specify angle between 0 and 90 degrees. 0 = 0; 1 = 10; 2 = 20; 3 = 30; 4 = 45; 5 = Not drawn; 6 = 60; 7 = 70; 8 = 80; 9 = 90. k (0-9) : specify angle between 90 and 180 degrees; 0 = 180; 1 = 170; 2 = 160; 3 = 150; 4 = 135; 5 = Not drawn; 6 = 120; 7 = 110; 8 = 100; 9 = 90. void PaintHatches(Double_t dy, Double_t angle, Int_t nn, Double_t* xx, Double_t* yy); This routine draw hatches inclined with the; angle ""angle"" and spaced of ""dy"" in normalized device; coordinates in the surface defined by n,xx,yy. void PaintLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Paint line in CurrentPad World coordinates. void PaintLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2). void PaintLine3D(Float_t* p1, Float_t* p2); Paint 3-D line in the CurrentPad. void PaintLine3D(Double_t* p1, Double_t* p2); Paint 3-D line in the CurrentPad. void PaintPolyLine(Int_t n, Float_t* x, Float_t* y, Option_t* option = """"); Paint polyline in CurrentPad World coordinates. void PaintPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); Paint polyline in CurrentPad World coordinates. If option[0] == 'C' no clipping. void PaintPolyLineNDC(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); Paint polyline in CurrentPad NDC coordinates. void PaintPolyLine3D(Int_t n, Double_t* p); Paint 3-D polyline in the CurrentPad. void PaintPolyMarker(Int_t n, Float_t* x, Float_t*",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:48915,Integrability,rout,routine,48915," void PaintPolyMarker(Int_t n, Float_t* x, Float_t* y, Option_t* option = """"); Paint polymarker in CurrentPad World coordinates. void PaintPolyMarker(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); Paint polymarker in CurrentPad World coordinates. void PaintText(Double_t x, Double_t y, const char* text); Paint text in CurrentPad World coordinates. void PaintText(Double_t x, Double_t y, const wchar_t* text); Paint text in CurrentPad World coordinates. void PaintTextNDC(Double_t u, Double_t v, const char* text); Paint text in CurrentPad NDC coordinates. void PaintTextNDC(Double_t u, Double_t v, const wchar_t* text); Paint text in CurrentPad NDC coordinates. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); Search for an object at pixel position px,py. Check if point is in this pad.; If yes, check if it is in one of the subpads; If found in the pad, compute closest distance of approach; to each primitive.; If one distance of approach is found to be within the limit Distancemaximum; the corresponding primitive is selected and the routine returns. void Pop(); Pop pad to the top of the stack. void Print(const char* filename = """") const; Save Pad contents in a file in one of various formats. if filename is """", the file produced is padname.ps; if filename starts with a dot, the padname is added in front; if filename contains .eps, an Encapsulated Postscript file is produced; if filename contains .gif, a GIF file is produced; if filename contains .gif+NN, an animated GIF file is produced; See comments in TASImage::WriteImage for meaning of NN and other .gif sufix variants; if filename contains .C or .cxx, a C++ macro file is produced; if filename contains .root, a Root file is produced; if filename contains .xml, a XML file is produced. See comments in TPad::SaveAs or the TPad::Print function below. void Print(const char* filename, Option_t* option); Save Canvas contents in a file in one of various formats. if option = 0 - as ""ps""; ""ps"" - Postscript file is prod",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:33952,Modifiability,variab,variable,33952,"ically a TLegend from the; primitives in a TPad. Only those deriving from TAttLine,; TAttMarker and TAttFill are added, excluding TPave and TFrame; derived classes. x1, y1, x2, y2 are the TLegend coordinates.; title is the legend title. By default it is "" "". The caller; program owns the returned TLegend. If the pad contains some TMultiGraph or THStack the individual; graphs or histograms in them are added to the TLegend. TVirtualPad * cd(Int_t subpadnumber = 0); Set Current pad.; When a canvas/pad is divided via TPad::Divide, one can directly; set the current path to one of the subdivisions.; See TPad::Divide for the convention to number subpads.; Returns the new current pad, or 0 in case of failure.; For example:; c1.Divide(2,3); // create 6 pads (2 divisions along x, 3 along y).; To set the current pad to the bottom right pad, do; c1.cd(6);; Note1: c1.cd() is equivalent to c1.cd(0) and sets the current pad; to c1 itself.; Note2: after a statement like c1.cd(6), the global variable gPad; points to the current pad. One can use gPad to set attributes; of the current pad.; Note3: One can get a pointer to one of the sub-pads of pad with:; TPad *subpad = (TPad*)pad->GetPad(subpadnumber);. void Clear(Option_t* option = """"); Delete all pad primitives. If the bit kClearAfterCR has been set for this pad, the Clear function; will execute only after having pressed a CarriageReturn; Set the bit with mypad->SetBit(TPad::kClearAfterCR). Int_t Clip(Float_t* x, Float_t* y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt); Clipping routine: Cohen Sutherland algorithm. If Clip ==2 the segment is outside the boundary.; If Clip ==1 the segment has one point outside the boundary.; If Clip ==0 the segment is inside the boundary. _Input parameters:. x[2], y[2] : Segment coordinates; xclipl, yclipb, xclipr, yclipt : Clipping boundary. _Output parameters:. x[2], y[2] : New segment coordinates. Int_t Clip(Double_t* x, Double_t* y, Double_t xclipl, Double_t yclipb, Double_t xcl",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:39059,Modifiability,variab,variable,39059,"as is divided in nx by ny equal divisions (pads).; xmargin is the space along x between pads in percent of canvas.; ymargin is the space along y between pads in percent of canvas.; (see Note3 below for the special case xmargin <=0 and ymargin <=0); color is the color of the new pads. If 0, color is the canvas color.; Pads are automatically named canvasname_n where n is the division number; starting from top left pad.; Example if canvasname=c1 , nx=2, ny=3. . . .; . . .; . . .; . c1_1 . c1_2 .; . . .; . . .; . . . . . .; . . .; . . .; . c1_3 . c1_4 .; . . .; . . .; . . . . . .; . . .; . . .; . c1_5 . c1_6 .; . . .; . . . Once a pad is divided into subpads, one can set the current pad; to a subpad with a given division number as illustrated above; with TPad::cd(subpad_number).; For example, to set the current pad to c1_4, one can do:; c1->cd(4). Note1: c1.cd() is equivalent to c1.cd(0) and sets the current pad; to c1 itself.; Note2: after a statement like c1.cd(6), the global variable gPad; points to the current pad. One can use gPad to set attributes; of the current pad.; Note3: in case xmargin <=0 and ymargin <= 0, there is no space; between pads. The current pad margins are recomputed to; optimize the layout. void DivideSquare(Int_t n, Float_t xmargin = 0.01, Float_t ymargin = 0.01, Int_t color = 0); ""n"" is the total number of sub-pads. The number of sub-pads along the X; and Y axis are computed according to the square root of n. void Draw(Option_t* option = """"); Draw Pad in Current pad (re-parent pad if necessary). void DrawClassObject(const TObject* obj, Option_t* option = """"); Draw class inheritance tree of the class to which obj belongs.; If a class B inherits from a class A, description of B is drawn; on the right side of description of A.; Member functions overridden by B are shown in class A with a blue line; crossing-out the corresponding member function.; The following picture is the class inheritance tree of class TPaveLabel:. /*; ; */. void DrawCrosshair(",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:39689,Modifiability,inherit,inheritance,39689," c1_6 .; . . .; . . . Once a pad is divided into subpads, one can set the current pad; to a subpad with a given division number as illustrated above; with TPad::cd(subpad_number).; For example, to set the current pad to c1_4, one can do:; c1->cd(4). Note1: c1.cd() is equivalent to c1.cd(0) and sets the current pad; to c1 itself.; Note2: after a statement like c1.cd(6), the global variable gPad; points to the current pad. One can use gPad to set attributes; of the current pad.; Note3: in case xmargin <=0 and ymargin <= 0, there is no space; between pads. The current pad margins are recomputed to; optimize the layout. void DivideSquare(Int_t n, Float_t xmargin = 0.01, Float_t ymargin = 0.01, Int_t color = 0); ""n"" is the total number of sub-pads. The number of sub-pads along the X; and Y axis are computed according to the square root of n. void Draw(Option_t* option = """"); Draw Pad in Current pad (re-parent pad if necessary). void DrawClassObject(const TObject* obj, Option_t* option = """"); Draw class inheritance tree of the class to which obj belongs.; If a class B inherits from a class A, description of B is drawn; on the right side of description of A.; Member functions overridden by B are shown in class A with a blue line; crossing-out the corresponding member function.; The following picture is the class inheritance tree of class TPaveLabel:. /*; ; */. void DrawCrosshair(); Function called to draw a crosshair in the canvas. Example:; Root > TFile f(""hsimple.root"");; Root > hpxpy.Draw();; Root > c1.SetCrosshair();; When moving the mouse in the canvas, a crosshair is drawn. if the canvas fCrosshair = 1 , the crosshair spans the full canvas; if the canvas fCrosshair > 1 , the crosshair spans only the pad. TH1F * DrawFrame(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, const char* title = """"); Draw a pad frame. Compute real pad range taking into account all margins; Use services of TH1F class. void DrawColorTable(); Static function to Display Color Table i",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:39755,Modifiability,inherit,inherits,39755,"sion number as illustrated above; with TPad::cd(subpad_number).; For example, to set the current pad to c1_4, one can do:; c1->cd(4). Note1: c1.cd() is equivalent to c1.cd(0) and sets the current pad; to c1 itself.; Note2: after a statement like c1.cd(6), the global variable gPad; points to the current pad. One can use gPad to set attributes; of the current pad.; Note3: in case xmargin <=0 and ymargin <= 0, there is no space; between pads. The current pad margins are recomputed to; optimize the layout. void DivideSquare(Int_t n, Float_t xmargin = 0.01, Float_t ymargin = 0.01, Int_t color = 0); ""n"" is the total number of sub-pads. The number of sub-pads along the X; and Y axis are computed according to the square root of n. void Draw(Option_t* option = """"); Draw Pad in Current pad (re-parent pad if necessary). void DrawClassObject(const TObject* obj, Option_t* option = """"); Draw class inheritance tree of the class to which obj belongs.; If a class B inherits from a class A, description of B is drawn; on the right side of description of A.; Member functions overridden by B are shown in class A with a blue line; crossing-out the corresponding member function.; The following picture is the class inheritance tree of class TPaveLabel:. /*; ; */. void DrawCrosshair(); Function called to draw a crosshair in the canvas. Example:; Root > TFile f(""hsimple.root"");; Root > hpxpy.Draw();; Root > c1.SetCrosshair();; When moving the mouse in the canvas, a crosshair is drawn. if the canvas fCrosshair = 1 , the crosshair spans the full canvas; if the canvas fCrosshair > 1 , the crosshair spans only the pad. TH1F * DrawFrame(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, const char* title = """"); Draw a pad frame. Compute real pad range taking into account all margins; Use services of TH1F class. void DrawColorTable(); Static function to Display Color Table in a pad. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member f",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:40003,Modifiability,inherit,inheritance,40003,"lf.; Note2: after a statement like c1.cd(6), the global variable gPad; points to the current pad. One can use gPad to set attributes; of the current pad.; Note3: in case xmargin <=0 and ymargin <= 0, there is no space; between pads. The current pad margins are recomputed to; optimize the layout. void DivideSquare(Int_t n, Float_t xmargin = 0.01, Float_t ymargin = 0.01, Int_t color = 0); ""n"" is the total number of sub-pads. The number of sub-pads along the X; and Y axis are computed according to the square root of n. void Draw(Option_t* option = """"); Draw Pad in Current pad (re-parent pad if necessary). void DrawClassObject(const TObject* obj, Option_t* option = """"); Draw class inheritance tree of the class to which obj belongs.; If a class B inherits from a class A, description of B is drawn; on the right side of description of A.; Member functions overridden by B are shown in class A with a blue line; crossing-out the corresponding member function.; The following picture is the class inheritance tree of class TPaveLabel:. /*; ; */. void DrawCrosshair(); Function called to draw a crosshair in the canvas. Example:; Root > TFile f(""hsimple.root"");; Root > hpxpy.Draw();; Root > c1.SetCrosshair();; When moving the mouse in the canvas, a crosshair is drawn. if the canvas fCrosshair = 1 , the crosshair spans the full canvas; if the canvas fCrosshair > 1 , the crosshair spans only the pad. TH1F * DrawFrame(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, const char* title = """"); Draw a pad frame. Compute real pad range taking into account all margins; Use services of TH1F class. void DrawColorTable(); Static function to Display Color Table in a pad. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a TPad object is clicked. If the mouse is clicked in one of the 4 corners of the pad (pA,pB,pC,pD); the pad is resized with the rubber rectangle. If the mouse is clicked inside the pad, th",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:65962,Modifiability,plugin,plugin,65962," Set the editor in Text/Latex mode.; // Create a text object, then Set its name to ""lat"". The following macro waits for 10 primitives of any type to be created.; {; TCanvas c1(""c1"");; TObject *obj;; for (Int_t i=0;i<10;i++) {; obj = gPad->WaitPrimitive();; if (!obj) break;; printf(""Loop i=%d, found objIsA=%s, name=%s\n"",; i,obj->ClassName(),obj->GetName());; }; }. TObject * CreateToolTip(const TBox* b, const char* text, Long_t delayms); Create a tool tip and return its pointer. void DeleteToolTip(TObject* tip); Delete tool tip object. void ResetToolTip(TObject* tip); Reset tool tip, i.e. within time specified in CreateToolTip the; tool tip will pop up. void CloseToolTip(TObject* tip); Hide tool tip. void x3d(Option_t* type = """"); Depreciated: use TPad::GetViewer3D() instead. TVirtualViewer3D * GetViewer3D(Option_t* type = """"); Create/obtain handle to 3D viewer. Valid types are:; 'pad' - pad drawing via TViewer3DPad; any others registered with plugin manager supporting TVirtualViewer3D; If an invalid/null type is requested then the current viewer is returned; (if any), otherwise a default 'pad' type is returned. void ReleaseViewer3D(Option_t* type = """"); Release current (external) viewer; TODO: By type. Int_t GetGLDevice(); Get GL device. void RecordPave(const TObject* obj); Emit RecordPave() signal. void RecordLatex(const TObject* obj); Emit RecordLatex() signal. TVirtualPadPainter * GetPainter(); Get pad painter from TCanvas. Rectangle_t GetBBox(); Return the bounding Box of the Pad. TPoint GetBBoxCenter(); Return the center of the Pad as TPoint in pixels. void SetBBoxCenter(const TPoint& p); Set center of the Pad. void SetBBoxCenterX(const Int_t x); Set X coordinate of the center of the Pad. void SetBBoxCenterY(const Int_t y); Set Y coordinate of the center of the Pad. void SetBBoxX1(const Int_t x); Set lefthandside of BoundingBox to a value; (resize in x direction on left). void SetBBoxX2(const Int_t x); Set righthandside of BoundingBox to a value; (resize in x di",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:621,Performance,perform,performed,621,". TPad. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TPad. class TPad: public TVirtualPad, public TAttBBox2D. The Pad class is the most important graphics class in the ROOT system. /*. */. A Pad is contained in a Canvas.; A Pad may contain other pads (unlimited pad hierarchy).; A pad is a linked list of primitives of any type (graphics objects,; histograms, detectors, tracks, etc.).; Adding a new element into a pad is in general performed by the Draw; member function of the object classes.; It is important to realize that the pad is a linked list of references; to the original object.; For example, in case of a histogram, the histogram.Draw() operation; only stores a reference to the histogram object and not a graphical; representation of this histogram.; When the mouse is used to change (say the bin content), the bin content; of the original histogram is changed !!. The convention used in ROOT is that a Draw operation only adds; a reference to the object. The effective drawing is performed; when the canvas receives a signal to be painted.; This signal is generally sent when typing carriage return in the; command input or when a graphical operation has been performed on one; of the pads of this canvas.; When a Canvas/Pad is repainted, the member function Paint for all; objects in the Pad linked list is invoked. When the mouse is moved on the Pad, The member function DistancetoPrimitive; is called for all the elements in the pad. DistancetoPrimitive returns; the distance in pixels to this object.; when the object is within the distance window, the member function; ExecuteEvent is called for this object.; in ExecuteEvent, move, changes can be performed on the object.; For examples of DistancetoPrimitive and ExecuteEvent functions,; see classes TLine::DistancetoPrimitive, TLine::Execut",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:1184,Performance,perform,performed,1184," class charts. ROOT; » GRAF2D; » GPAD; » TPad. class TPad: public TVirtualPad, public TAttBBox2D. The Pad class is the most important graphics class in the ROOT system. /*. */. A Pad is contained in a Canvas.; A Pad may contain other pads (unlimited pad hierarchy).; A pad is a linked list of primitives of any type (graphics objects,; histograms, detectors, tracks, etc.).; Adding a new element into a pad is in general performed by the Draw; member function of the object classes.; It is important to realize that the pad is a linked list of references; to the original object.; For example, in case of a histogram, the histogram.Draw() operation; only stores a reference to the histogram object and not a graphical; representation of this histogram.; When the mouse is used to change (say the bin content), the bin content; of the original histogram is changed !!. The convention used in ROOT is that a Draw operation only adds; a reference to the object. The effective drawing is performed; when the canvas receives a signal to be painted.; This signal is generally sent when typing carriage return in the; command input or when a graphical operation has been performed on one; of the pads of this canvas.; When a Canvas/Pad is repainted, the member function Paint for all; objects in the Pad linked list is invoked. When the mouse is moved on the Pad, The member function DistancetoPrimitive; is called for all the elements in the pad. DistancetoPrimitive returns; the distance in pixels to this object.; when the object is within the distance window, the member function; ExecuteEvent is called for this object.; in ExecuteEvent, move, changes can be performed on the object.; For examples of DistancetoPrimitive and ExecuteEvent functions,; see classes TLine::DistancetoPrimitive, TLine::ExecuteEvent; TBox::DistancetoPrimitive, TBox::ExecuteEvent; TH1::DistancetoPrimitive, TH1::ExecuteEvent. A Pad supports linear and log scales coordinate systems.; The transformation coefficients are explai",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:1364,Performance,perform,performed,1364,"portant graphics class in the ROOT system. /*. */. A Pad is contained in a Canvas.; A Pad may contain other pads (unlimited pad hierarchy).; A pad is a linked list of primitives of any type (graphics objects,; histograms, detectors, tracks, etc.).; Adding a new element into a pad is in general performed by the Draw; member function of the object classes.; It is important to realize that the pad is a linked list of references; to the original object.; For example, in case of a histogram, the histogram.Draw() operation; only stores a reference to the histogram object and not a graphical; representation of this histogram.; When the mouse is used to change (say the bin content), the bin content; of the original histogram is changed !!. The convention used in ROOT is that a Draw operation only adds; a reference to the object. The effective drawing is performed; when the canvas receives a signal to be painted.; This signal is generally sent when typing carriage return in the; command input or when a graphical operation has been performed on one; of the pads of this canvas.; When a Canvas/Pad is repainted, the member function Paint for all; objects in the Pad linked list is invoked. When the mouse is moved on the Pad, The member function DistancetoPrimitive; is called for all the elements in the pad. DistancetoPrimitive returns; the distance in pixels to this object.; when the object is within the distance window, the member function; ExecuteEvent is called for this object.; in ExecuteEvent, move, changes can be performed on the object.; For examples of DistancetoPrimitive and ExecuteEvent functions,; see classes TLine::DistancetoPrimitive, TLine::ExecuteEvent; TBox::DistancetoPrimitive, TBox::ExecuteEvent; TH1::DistancetoPrimitive, TH1::ExecuteEvent. A Pad supports linear and log scales coordinate systems.; The transformation coefficients are explained in TPad::ResizePad.; An example of pads hierarchy is shown below:. /*. */. Function Members (Methods); public:. virtual~T",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:1857,Performance,perform,performed,1857," only stores a reference to the histogram object and not a graphical; representation of this histogram.; When the mouse is used to change (say the bin content), the bin content; of the original histogram is changed !!. The convention used in ROOT is that a Draw operation only adds; a reference to the object. The effective drawing is performed; when the canvas receives a signal to be painted.; This signal is generally sent when typing carriage return in the; command input or when a graphical operation has been performed on one; of the pads of this canvas.; When a Canvas/Pad is repainted, the member function Paint for all; objects in the Pad linked list is invoked. When the mouse is moved on the Pad, The member function DistancetoPrimitive; is called for all the elements in the pad. DistancetoPrimitive returns; the distance in pixels to this object.; when the object is within the distance window, the member function; ExecuteEvent is called for this object.; in ExecuteEvent, move, changes can be performed on the object.; For examples of DistancetoPrimitive and ExecuteEvent functions,; see classes TLine::DistancetoPrimitive, TLine::ExecuteEvent; TBox::DistancetoPrimitive, TBox::ExecuteEvent; TH1::DistancetoPrimitive, TH1::ExecuteEvent. A Pad supports linear and log scales coordinate systems.; The transformation coefficients are explained in TPad::ResizePad.; An example of pads hierarchy is shown below:. /*. */. Function Members (Methods); public:. virtual~TPad(); virtual voidAbsCoordinates(Bool_t set); virtual Double_tAbsPixeltoX(Int_t px); virtual voidAbsPixeltoXY(Int_t xpixel, Int_t ypixel, Double_t& x, Double_t& y); virtual Double_tAbsPixeltoY(Int_t py); voidTObject::AbstractMethod(const char* method) const; virtual voidAddExec(const char* name, const char* command); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidAutoExec(); static Bool_tTQObject::BlockAllSig",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:39279,Performance,optimiz,optimize,39279," for the special case xmargin <=0 and ymargin <=0); color is the color of the new pads. If 0, color is the canvas color.; Pads are automatically named canvasname_n where n is the division number; starting from top left pad.; Example if canvasname=c1 , nx=2, ny=3. . . .; . . .; . . .; . c1_1 . c1_2 .; . . .; . . .; . . . . . .; . . .; . . .; . c1_3 . c1_4 .; . . .; . . .; . . . . . .; . . .; . . .; . c1_5 . c1_6 .; . . .; . . . Once a pad is divided into subpads, one can set the current pad; to a subpad with a given division number as illustrated above; with TPad::cd(subpad_number).; For example, to set the current pad to c1_4, one can do:; c1->cd(4). Note1: c1.cd() is equivalent to c1.cd(0) and sets the current pad; to c1 itself.; Note2: after a statement like c1.cd(6), the global variable gPad; points to the current pad. One can use gPad to set attributes; of the current pad.; Note3: in case xmargin <=0 and ymargin <= 0, there is no space; between pads. The current pad margins are recomputed to; optimize the layout. void DivideSquare(Int_t n, Float_t xmargin = 0.01, Float_t ymargin = 0.01, Int_t color = 0); ""n"" is the total number of sub-pads. The number of sub-pads along the X; and Y axis are computed according to the square root of n. void Draw(Option_t* option = """"); Draw Pad in Current pad (re-parent pad if necessary). void DrawClassObject(const TObject* obj, Option_t* option = """"); Draw class inheritance tree of the class to which obj belongs.; If a class B inherits from a class A, description of B is drawn; on the right side of description of A.; Member functions overridden by B are shown in class A with a blue line; crossing-out the corresponding member function.; The following picture is the class inheritance tree of class TPaveLabel:. /*; ; */. void DrawCrosshair(); Function called to draw a crosshair in the canvas. Example:; Root > TFile f(""hsimple.root"");; Root > hpxpy.Draw();; Root > c1.SetCrosshair();; When moving the mouse in the canvas, a crosshair i",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:548,Safety,detect,detectors,548,". TPad. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TPad. class TPad: public TVirtualPad, public TAttBBox2D. The Pad class is the most important graphics class in the ROOT system. /*. */. A Pad is contained in a Canvas.; A Pad may contain other pads (unlimited pad hierarchy).; A pad is a linked list of primitives of any type (graphics objects,; histograms, detectors, tracks, etc.).; Adding a new element into a pad is in general performed by the Draw; member function of the object classes.; It is important to realize that the pad is a linked list of references; to the original object.; For example, in case of a histogram, the histogram.Draw() operation; only stores a reference to the histogram object and not a graphical; representation of this histogram.; When the mouse is used to change (say the bin content), the bin content; of the original histogram is changed !!. The convention used in ROOT is that a Draw operation only adds; a reference to the object. The effective drawing is performed; when the canvas receives a signal to be painted.; This signal is generally sent when typing carriage return in the; command input or when a graphical operation has been performed on one; of the pads of this canvas.; When a Canvas/Pad is repainted, the member function Paint for all; objects in the Pad linked list is invoked. When the mouse is moved on the Pad, The member function DistancetoPrimitive; is called for all the elements in the pad. DistancetoPrimitive returns; the distance in pixels to this object.; when the object is within the distance window, the member function; ExecuteEvent is called for this object.; in ExecuteEvent, move, changes can be performed on the object.; For examples of DistancetoPrimitive and ExecuteEvent functions,; see classes TLine::DistancetoPrimitive, TLine::Execut",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:53141,Safety,detect,detect,53141,"s TPostScript. Writing several canvases to the same Postscript or PDF file:. if the Postscript or PDF file name finishes with ""("", the file is not closed; if the Postscript or PDF file name finishes with "")"" and the file has been opened; with ""("", the file is closed. Example:. {; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps(""); //write canvas and keep the ps file open; h2.Draw();; c1.Print(""c1.ps""); canvas is added to ""c1.ps""; h3.Draw();; c1.Print(""c1.ps)""); canvas is added to ""c1.ps"" and ps file is closed; }. In the previous example replacing ""ps"" by ""pdf"" will create a multi-pages PDF file. Note that the following sequence writes the canvas to ""c1.ps"" and closes the ps file.:; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps"");. The TCanvas::Print(""file.ps("") mechanism is very useful, but it can be; a little inconvenient to have the action of opening/closing a file; being atomic with printing a page. Particularly if pages are being; generated in some loop one needs to detect the special cases of first; and last page and then munge the argument to Print() accordingly. The ""["" and ""]"" can be used instead of ""("" and "")"". Example:. c1.Print(""file.ps[""); // No actual print, just open file.ps; for (int i=0; i<10; ++i) {; // fill canvas for context i; // ... c1.Print(""file.ps""); // actually print canvas to file; }// end loop; c1.Print(""file.ps]""); // No actual print, just close. As before, the same macro is valid for PDF files. It is possible to print a canvas into an animated GIF file by specifying the; file name as ""myfile.gif+"" or ""myfile.gif+NN"", where NN*10ms is delay; between the subimages' display. If NN is ommitted the delay between; subimages is zero. Each picture is added in the animation thanks to a loop; similar to the following one:. for (int i=0; i<10; ++i) {; // fill canvas for context i; // ... c1.Print(""file.gif+5""); // print canvas to GIF file with 50ms delays; }// end loop. The delay between each frame must be specified in each Print() statement.; If t",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:54248,Safety,avoid,avoid,54248,"ead of ""("" and "")"". Example:. c1.Print(""file.ps[""); // No actual print, just open file.ps; for (int i=0; i<10; ++i) {; // fill canvas for context i; // ... c1.Print(""file.ps""); // actually print canvas to file; }// end loop; c1.Print(""file.ps]""); // No actual print, just close. As before, the same macro is valid for PDF files. It is possible to print a canvas into an animated GIF file by specifying the; file name as ""myfile.gif+"" or ""myfile.gif+NN"", where NN*10ms is delay; between the subimages' display. If NN is ommitted the delay between; subimages is zero. Each picture is added in the animation thanks to a loop; similar to the following one:. for (int i=0; i<10; ++i) {; // fill canvas for context i; // ... c1.Print(""file.gif+5""); // print canvas to GIF file with 50ms delays; }// end loop. The delay between each frame must be specified in each Print() statement.; If the file ""myfile.gif"" already exists, the new frame are appended at; the end of the file. To avoid this, delete it first with gSystem->Unlink(myfile.gif);; If you want the gif file to repeat or loop forever, check TASImage::WriteImage documentation. void Range(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Set world coordinate system for the pad.; Emits signal ""RangeChanged()"", in the slot get the range; via GetRange(). void RangeAxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax); Set axis coordinate system for the pad.; The axis coordinate system is a subset of the world coordinate system; xmin,ymin is the origin of the current coordinate system,; xmax is the end of the X axis, ymax is the end of the Y axis.; By default a margin of 10 per cent is left on all sides of the pad; Emits signal ""RangeAxisChanged()"", in the slot get the axis range; via GetRangeAxis(). void RecursiveRemove(TObject* obj); Recursively remove object from a pad and its subpads. void RedrawAxis(Option_t* option = """"); Redraw the frame axis; Redrawing axis may be necessary in case of superimposed histograms; whe",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:2127,Testability,log,log,2127,"ds; a reference to the object. The effective drawing is performed; when the canvas receives a signal to be painted.; This signal is generally sent when typing carriage return in the; command input or when a graphical operation has been performed on one; of the pads of this canvas.; When a Canvas/Pad is repainted, the member function Paint for all; objects in the Pad linked list is invoked. When the mouse is moved on the Pad, The member function DistancetoPrimitive; is called for all the elements in the pad. DistancetoPrimitive returns; the distance in pixels to this object.; when the object is within the distance window, the member function; ExecuteEvent is called for this object.; in ExecuteEvent, move, changes can be performed on the object.; For examples of DistancetoPrimitive and ExecuteEvent functions,; see classes TLine::DistancetoPrimitive, TLine::ExecuteEvent; TBox::DistancetoPrimitive, TBox::ExecuteEvent; TH1::DistancetoPrimitive, TH1::ExecuteEvent. A Pad supports linear and log scales coordinate systems.; The transformation coefficients are explained in TPad::ResizePad.; An example of pads hierarchy is shown below:. /*. */. Function Members (Methods); public:. virtual~TPad(); virtual voidAbsCoordinates(Bool_t set); virtual Double_tAbsPixeltoX(Int_t px); virtual voidAbsPixeltoXY(Int_t xpixel, Int_t ypixel, Double_t& x, Double_t& y); virtual Double_tAbsPixeltoY(Int_t py); voidTObject::AbstractMethod(const char* method) const; virtual voidAddExec(const char* name, const char* command); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidAutoExec(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidBrowse(TBrowser* b); virtual TLegend*BuildLegend(Double_t x1 = 0.5, Double_t y1 = 0.67000000000000004, Double_t x2 = 0.88, Double_t y2 = 0.88, const char* title = """")MENU ; virtual TVirtualPad*cd(Int_t subpadnumb",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:27265,Testability,log,log,27265,"ea style; Bool_tfFixedAspectRatioTrue if fixed aspect ratio; TFrame*fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tfGLDevice! OpenGL off-screen pixmap identifier; Bool_tfGridxSet to true if grid along X; Bool_tfGridySet to true if grid along Y; Double_tfHNDCHeight of pad along Y in NDC; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfLogx(=0 if X linear scale, =1 if log scale); Int_tfLogy(=0 if Y linear scale, =1 if log scale); Int_tfLogz(=0 if Z linear scale, =1 if log scale); Bool_tfModifiedSet to true when pad is modified; TPad*fMother! pointer to mother of the list; TStringfNamePad name; Int_tfNumberpad number identifier; Int_tfPadPaintSet to 1 while painting the pad; TObject*fPadPointer! free pointer; TObject*fPadView3D! 3D View of this TPad; Double_tfPhiphi angle to view as lego/surface; Double_tfPixeltoXxworld = fPixeltoXk + fPixeltoX*xpixel; Double_tfPixeltoXkConversion coefficient for pixel to X World; Double_tfPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixel; Double_tfPixeltoYkConversion coefficient for pixel to Y World; Int_tfPixmapID! Off-screen pixmap identifier; TList*fPrimitives->List of primitives (subpads); Bool_tTVirtualPad::fResizing!true when resizing the pad; Float_tTAttPad::fRightMarginRightMargin; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Double_tfThetatheta angle to view as lego/surface; Int_tfTickx",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:27316,Testability,log,log,27316,"ct ratio; TFrame*fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tfGLDevice! OpenGL off-screen pixmap identifier; Bool_tfGridxSet to true if grid along X; Bool_tfGridySet to true if grid along Y; Double_tfHNDCHeight of pad along Y in NDC; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfLogx(=0 if X linear scale, =1 if log scale); Int_tfLogy(=0 if Y linear scale, =1 if log scale); Int_tfLogz(=0 if Z linear scale, =1 if log scale); Bool_tfModifiedSet to true when pad is modified; TPad*fMother! pointer to mother of the list; TStringfNamePad name; Int_tfNumberpad number identifier; Int_tfPadPaintSet to 1 while painting the pad; TObject*fPadPointer! free pointer; TObject*fPadView3D! 3D View of this TPad; Double_tfPhiphi angle to view as lego/surface; Double_tfPixeltoXxworld = fPixeltoXk + fPixeltoX*xpixel; Double_tfPixeltoXkConversion coefficient for pixel to X World; Double_tfPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixel; Double_tfPixeltoYkConversion coefficient for pixel to Y World; Int_tfPixmapID! Off-screen pixmap identifier; TList*fPrimitives->List of primitives (subpads); Bool_tTVirtualPad::fResizing!true when resizing the pad; Float_tTAttPad::fRightMarginRightMargin; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Double_tfThetatheta angle to view as lego/surface; Int_tfTickxSet to 1 if tick marks along X; Int_tfTickySet to 1",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:27367,Testability,log,log,27367,"ne exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tfGLDevice! OpenGL off-screen pixmap identifier; Bool_tfGridxSet to true if grid along X; Bool_tfGridySet to true if grid along Y; Double_tfHNDCHeight of pad along Y in NDC; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfLogx(=0 if X linear scale, =1 if log scale); Int_tfLogy(=0 if Y linear scale, =1 if log scale); Int_tfLogz(=0 if Z linear scale, =1 if log scale); Bool_tfModifiedSet to true when pad is modified; TPad*fMother! pointer to mother of the list; TStringfNamePad name; Int_tfNumberpad number identifier; Int_tfPadPaintSet to 1 while painting the pad; TObject*fPadPointer! free pointer; TObject*fPadView3D! 3D View of this TPad; Double_tfPhiphi angle to view as lego/surface; Double_tfPixeltoXxworld = fPixeltoXk + fPixeltoX*xpixel; Double_tfPixeltoXkConversion coefficient for pixel to X World; Double_tfPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixel; Double_tfPixeltoYkConversion coefficient for pixel to Y World; Int_tfPixmapID! Off-screen pixmap identifier; TList*fPrimitives->List of primitives (subpads); Bool_tTVirtualPad::fResizing!true when resizing the pad; Float_tTAttPad::fRightMarginRightMargin; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Double_tfThetatheta angle to view as lego/surface; Int_tfTickxSet to 1 if tick marks along X; Int_tfTickySet to 1 if tick marks along Y; TStringfTitlePad title; Flo",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:59940,Testability,log,logarithmic,59940,"g, a JPEG file is produced; NOTE: JPEG's lossy compression will make all sharp edges fuzzy.; if filename contains .tiff, a TIFF file is produced; if filename contains .C or .cxx, a C++ macro file is produced; if filename contains .root, a Root file is produced; if filename contains .xml, a XML file is produced. See comments in TPad::Print for the Postscript formats. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitives in this pad on the C++ source file out. void SetFixedAspectRatio(Bool_t fixed = kTRUE); Fix pad aspect ratio to current value if fixed is true. void SetEditable(Bool_t mode = kTRUE); Set pad editable yes/no; If a pad is not editable:; - one cannot modify the pad and its objects via the mouse.; - one cannot add new objects to the pad. void SetFillStyle(Style_t fstyle); Overrride TAttFill::FillStyle for TPad because we want to handle style=0; as style 4000. void SetLogx(Int_t value = 1); Set Lin/Log scale for X; value = 0 X scale will be linear; value = 1 X scale will be logarithmic (base 10); value > 1 reserved for possible support of base e or other. void SetLogy(Int_t value = 1); Set Lin/Log scale for Y; value = 0 Y scale will be linear; value = 1 Y scale will be logarithmic (base 10); value > 1 reserved for possible support of base e or other. void SetLogz(Int_t value = 1); Set Lin/Log scale for Z. void SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); Set canvas range for pad and resize the pad. If the aspect ratio; was fixed before the call it will be un-fixed. void SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bordermode = -1); Set all pad parameters. void SetView(TView* view = 0); Set the current TView. Delete previous view if view=0. void SetAttFillPS(Color_t color, Style_t style); Set postscript fill area attributes. void SetAttLinePS(Color_t color, Style_t style, Width_t lwidth); Set postscript line att",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:60139,Testability,log,logarithmic,60139,"produced; if filename contains .root, a Root file is produced; if filename contains .xml, a XML file is produced. See comments in TPad::Print for the Postscript formats. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitives in this pad on the C++ source file out. void SetFixedAspectRatio(Bool_t fixed = kTRUE); Fix pad aspect ratio to current value if fixed is true. void SetEditable(Bool_t mode = kTRUE); Set pad editable yes/no; If a pad is not editable:; - one cannot modify the pad and its objects via the mouse.; - one cannot add new objects to the pad. void SetFillStyle(Style_t fstyle); Overrride TAttFill::FillStyle for TPad because we want to handle style=0; as style 4000. void SetLogx(Int_t value = 1); Set Lin/Log scale for X; value = 0 X scale will be linear; value = 1 X scale will be logarithmic (base 10); value > 1 reserved for possible support of base e or other. void SetLogy(Int_t value = 1); Set Lin/Log scale for Y; value = 0 Y scale will be linear; value = 1 Y scale will be logarithmic (base 10); value > 1 reserved for possible support of base e or other. void SetLogz(Int_t value = 1); Set Lin/Log scale for Z. void SetPad(Double_t xlow, Double_t ylow, Double_t xup, Double_t yup); Set canvas range for pad and resize the pad. If the aspect ratio; was fixed before the call it will be un-fixed. void SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bordermode = -1); Set all pad parameters. void SetView(TView* view = 0); Set the current TView. Delete previous view if view=0. void SetAttFillPS(Color_t color, Style_t style); Set postscript fill area attributes. void SetAttLinePS(Color_t color, Style_t style, Width_t lwidth); Set postscript line attributes. void SetAttMarkerPS(Color_t color, Style_t style, Size_t msize); Set postscript marker attributes. void SetAttTextPS(Int_t align, Float_t angle, Color_t color, Style_t font, Float_t tsize); ",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:32933,Usability,simpl,simple,32933,"an use the mouse to click on the contour of; the histogram hpx. When the mouse is clicked, the bin number and its; contents are printed.; Example2 of use of exec1.C. Root > TFile f(""hsimple.root""); Root > hpxpy.Draw(); Root > c1.AddExec(""ex2"","".x exec2.C""); When moving the mouse in the canvas, a second canvas shows the; projection along X of the bin corresponding to the Y position; of the mouse. The resulting histogram is fitted with a gaussian.; A ""dynamic"" line shows the current bin position in Y.; This more elaborated example can be used as a starting point; to develop more powerful interactive applications exploiting CINT; as a development engine. void AutoExec(); Execute the list of Execs when a pad event occurs. void Browse(TBrowser* b); Browse pad. TLegend * BuildLegend(Double_t x1 = 0.5, Double_t y1 = 0.67000000000000004, Double_t x2 = 0.88, Double_t y2 = 0.88, const char* title = """"); Build a legend from the graphical objects in the pad. A simple method to build automatically a TLegend from the; primitives in a TPad. Only those deriving from TAttLine,; TAttMarker and TAttFill are added, excluding TPave and TFrame; derived classes. x1, y1, x2, y2 are the TLegend coordinates.; title is the legend title. By default it is "" "". The caller; program owns the returned TLegend. If the pad contains some TMultiGraph or THStack the individual; graphs or histograms in them are added to the TLegend. TVirtualPad * cd(Int_t subpadnumber = 0); Set Current pad.; When a canvas/pad is divided via TPad::Divide, one can directly; set the current path to one of the subdivisions.; See TPad::Divide for the convention to number subpads.; Returns the new current pad, or 0 in case of failure.; For example:; c1.Divide(2,3); // create 6 pads (2 divisions along x, 3 along y).; To set the current pad to the bottom right pad, do; c1.cd(6);; Note1: c1.cd() is equivalent to c1.cd(0) and sets the current pad; to c1 itself.; Note2: after a statement like c1.cd(6), the global variable gPad; poin",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:36261,Usability,simpl,simple,36261,"; xclipl, yclipb, xclipr, yclipt : Clipping boundary. _Output parameters:. x[2], y[2] : New segment coordinates. Int_t ClippingCode(Double_t x, Double_t y, Double_t xcl1, Double_t ycl1, Double_t xcl2, Double_t ycl2); Compute the endpoint codes for TPad::Clip. Int_t ClipPolygon(Int_t n, Double_t* x, Double_t* y, Int_t nn, Double_t* xc, Double_t* yc, Double_t xclipl, Double_t yclipb, Double_t xclipr, Double_t yclipt); Clip polygon using the Sutherland-Hodgman algorithm. Input parameters:. n: Number of points in the polygon to be clipped; x[n], y[n] : Polygon do be clipped vertices; xclipl, yclipb, xclipr, yclipt : Clipping boundary. Output parameters:. nn: number of points in xc and yc; xc, yc: clipped polygon vertices. The Int_t returned by this function is; the number of points in the clipped polygon. These vectors must; be allocated by the calling function. A size of 2*n for each is; enough. Sutherland and Hodgman's polygon-clipping algorithm uses a divide-and-conquer; strategy: It solves a series of simple and identical problems that, when; combined, solve the overall problem. The simple problem is to clip a polygon; against a single infinite clip edge. Four clip edges, each defining one boundary; of the clip rectangle, successively clip a polygon against a clip rectangle. Steps of Sutherland-Hodgman's polygon-clipping algorithm:. * Polygons can be clipped against each edge of the window one at a time.; Windows/edge intersections, if any, are easy to find since the X or Y coordinates; are already known.; * Vertices which are kept after clipping against one window edge are saved for; clipping against the remaining edges.; * Note that the number of vertices usually changes and will often increases. The clip boundary determines a visible and invisible region. The edges from; vertex i to vertex i+1 can be one of four types:. * Case 1 : Wholly inside visible region - save endpoint; * Case 2 : Exit visible region - save the intersection; * Case 3 : Wholly outside visibl",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPad.html:36344,Usability,simpl,simple,36344,"uble_t x, Double_t y, Double_t xcl1, Double_t ycl1, Double_t xcl2, Double_t ycl2); Compute the endpoint codes for TPad::Clip. Int_t ClipPolygon(Int_t n, Double_t* x, Double_t* y, Int_t nn, Double_t* xc, Double_t* yc, Double_t xclipl, Double_t yclipb, Double_t xclipr, Double_t yclipt); Clip polygon using the Sutherland-Hodgman algorithm. Input parameters:. n: Number of points in the polygon to be clipped; x[n], y[n] : Polygon do be clipped vertices; xclipl, yclipb, xclipr, yclipt : Clipping boundary. Output parameters:. nn: number of points in xc and yc; xc, yc: clipped polygon vertices. The Int_t returned by this function is; the number of points in the clipped polygon. These vectors must; be allocated by the calling function. A size of 2*n for each is; enough. Sutherland and Hodgman's polygon-clipping algorithm uses a divide-and-conquer; strategy: It solves a series of simple and identical problems that, when; combined, solve the overall problem. The simple problem is to clip a polygon; against a single infinite clip edge. Four clip edges, each defining one boundary; of the clip rectangle, successively clip a polygon against a clip rectangle. Steps of Sutherland-Hodgman's polygon-clipping algorithm:. * Polygons can be clipped against each edge of the window one at a time.; Windows/edge intersections, if any, are easy to find since the X or Y coordinates; are already known.; * Vertices which are kept after clipping against one window edge are saved for; clipping against the remaining edges.; * Note that the number of vertices usually changes and will often increases. The clip boundary determines a visible and invisible region. The edges from; vertex i to vertex i+1 can be one of four types:. * Case 1 : Wholly inside visible region - save endpoint; * Case 2 : Exit visible region - save the intersection; * Case 3 : Wholly outside visible region - save nothing; * Case 4 : Enter visible region - save intersection and endpoint. void Close(Option_t* option = """"); Delete a",MatchSource.WIKI,root/html604/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPad.html
https://root.cern/root/html604/TPadEditor.html:5093,Availability,error,error,5093," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html604/TPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPadEditor.html
https://root.cern/root/html604/TPadEditor.html:5177,Availability,error,error,5177,"(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html604/TPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPadEditor.html
https://root.cern/root/html604/TPadEditor.html:19283,Availability,mask,mask,19283,,MatchSource.WIKI,root/html604/TPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPadEditor.html
https://root.cern/root/html604/TPadEditor.html:22485,Integrability,interface,interface,22485,"Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPadEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of TPad editor GUI. ~TPadEditor(); Destructor of fill editor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Pick up the used fill attributes. void ActivateBaseClassEditors(TClass* cl); Exclude TAttLineEditor from this interface. void DoEditable(Bool_t on); Slot connected to the check box 'Editable'. void DoCrosshair(Bool_t on); Slot connected to the check box 'Crosshair'. void DoFixedAspectRatio(Bool_t on); Slot connected to the check box 'Fixed aspect ratio'. void DoGridX(Bool_t on); Slot connected to the check box 'GridX'. void DoGridY(Bool_t on); Slot connected to the check box 'GridY'. void DoLogX(Bool_t on); Slot connected to the check box 'LogX'. void DoLogY(Bool_t on); Slot connected to the check box 'LogY'. void DoLogZ(Bool_t on); Slot connected to the check box 'LogZ'. void DoTickX(Bool_t on); Slot connected to the check box 'TickX'. void DoTickY(Bool_t on); Slot connected to the check box 'TickY'. void DoBorderMode(); Slot connected to the border mode settings. void DoBorderSize(Int_t size); Slot connected to the border size settings. TPadEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefa",MatchSource.WIKI,root/html604/TPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPadEditor.html
https://root.cern/root/html604/TPadEditor.html:20062,Testability,log,log,20062,"GCheckButton*fCrosshairset crosshair; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; TGCheckButton*fEditableset pad editable; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGCheckButton*fFixedARset fixed aspect ratio; TGedEditor*TGedFrame::fGedEditormanager of this frame; TGCheckButton*fGridXset grid on X; TGCheckButton*fGridYset grid on Y; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGCheckButton*fLogXset log scale on X; TGCheckButton*fLogYset log scale on Y; TGCheckButton*fLogZset log scale on Z; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TClass*TGedFrame::fModelClassclass corresponding to instantiated GedFrame; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; TPad*fPadPointerTPad object; const TGWindow*TGWindow::fParentParent window; Int_tTGedFrame::fPrioritylocation in GedEditor; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGCheckButton*fTickXset ticks on X; TGCheckButton*fTickYset ticks on Y; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::f",MatchSource.WIKI,root/html604/TPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPadEditor.html
https://root.cern/root/html604/TPadEditor.html:20101,Testability,log,log,20101,"nt_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; TGCheckButton*fEditableset pad editable; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGCheckButton*fFixedARset fixed aspect ratio; TGedEditor*TGedFrame::fGedEditormanager of this frame; TGCheckButton*fGridXset grid on X; TGCheckButton*fGridYset grid on Y; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGCheckButton*fLogXset log scale on X; TGCheckButton*fLogYset log scale on Y; TGCheckButton*fLogZset log scale on Z; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TClass*TGedFrame::fModelClassclass corresponding to instantiated GedFrame; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; TPad*fPadPointerTPad object; const TGWindow*TGWindow::fParentParent window; Int_tTGedFrame::fPrioritylocation in GedEditor; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGCheckButton*fTickXset ticks on X; TGCheckButton*fTickYset ticks on Y; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObjec",MatchSource.WIKI,root/html604/TPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPadEditor.html
https://root.cern/root/html604/TPadEditor.html:20140,Testability,log,log,20140,"TGWindow::fEditDisabledflags used for ""guibuilding""; TGCheckButton*fEditableset pad editable; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGCheckButton*fFixedARset fixed aspect ratio; TGedEditor*TGedFrame::fGedEditormanager of this frame; TGCheckButton*fGridXset grid on X; TGCheckButton*fGridYset grid on Y; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGCheckButton*fLogXset log scale on X; TGCheckButton*fLogYset log scale on Y; TGCheckButton*fLogZset log scale on Z; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TClass*TGedFrame::fModelClassclass corresponding to instantiated GedFrame; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; TPad*fPadPointerTPad object; const TGWindow*TGWindow::fParentParent window; Int_tTGedFrame::fPrioritylocation in GedEditor; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGCheckButton*fTickXset ticks on X; TGCheckButton*fTickYset ticks on Y; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for sup",MatchSource.WIKI,root/html604/TPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPadEditor.html
https://root.cern/root/html604/TPadPainter.html:5900,Usability,simpl,simple,5900,"elegate to gVirtualX. Float_t GetTextMagnitude() const; Delegate to gVirtualX. void SetTextAlign(Short_t align); Delegate to gVirtualX. void SetTextAngle(Float_t tangle); Delegate to gVirtualX. void SetTextColor(Color_t tcolor); Delegate to gVirtualX. void SetTextFont(Font_t tfont); Delegate to gVirtualX. void SetTextSize(Float_t tsize); Delegate to gVirtualX. void SetTextSizePixels(Int_t npixels); Delegate to gVirtualX. Int_t CreateDrawable(UInt_t w, UInt_t h); Create a gVirtualX Pixmap. void ClearDrawable(); Clear the current gVirtualX window. void CopyDrawable(Int_t id, Int_t px, Int_t py); Copy a gVirtualX pixmap. void DestroyDrawable(); Close the current gVirtualX pixmap. void SelectDrawable(Int_t device); Select the window in which the graphics will go. void DrawPixels(const unsigned char* pixelData, UInt_t width, UInt_t height, Int_t dstX, Int_t dstY, Bool_t enableAlphaBlending); Noop, for non-gl pad TASImage calls gVirtualX->CopyArea. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Paint a simple line. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Paint a simple line in normalized coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); Paint Polyline. void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Paint polyline. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Paint polyline in normalized coordinates. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Paint polymarker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Paint polymarker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Paint text. v",MatchSource.WIKI,root/html604/TPadPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPadPainter.html
https://root.cern/root/html604/TPadPainter.html:5991,Usability,simpl,simple,5991,"_t align); Delegate to gVirtualX. void SetTextAngle(Float_t tangle); Delegate to gVirtualX. void SetTextColor(Color_t tcolor); Delegate to gVirtualX. void SetTextFont(Font_t tfont); Delegate to gVirtualX. void SetTextSize(Float_t tsize); Delegate to gVirtualX. void SetTextSizePixels(Int_t npixels); Delegate to gVirtualX. Int_t CreateDrawable(UInt_t w, UInt_t h); Create a gVirtualX Pixmap. void ClearDrawable(); Clear the current gVirtualX window. void CopyDrawable(Int_t id, Int_t px, Int_t py); Copy a gVirtualX pixmap. void DestroyDrawable(); Close the current gVirtualX pixmap. void SelectDrawable(Int_t device); Select the window in which the graphics will go. void DrawPixels(const unsigned char* pixelData, UInt_t width, UInt_t height, Int_t dstX, Int_t dstY, Bool_t enableAlphaBlending); Noop, for non-gl pad TASImage calls gVirtualX->CopyArea. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Paint a simple line. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Paint a simple line in normalized coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); Paint Polyline. void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Paint polyline. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Paint polyline in normalized coordinates. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Paint polymarker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Paint polymarker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Paint text. void DrawText(Double_t x, Double_t y, const wchar_t* text, TVirtualPadPainter::ETextMode mode); Special ",MatchSource.WIKI,root/html604/TPadPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPadPainter.html
https://root.cern/root/html604/TPadPainter.html:6139,Usability,simpl,simple,6139,"color); Delegate to gVirtualX. void SetTextFont(Font_t tfont); Delegate to gVirtualX. void SetTextSize(Float_t tsize); Delegate to gVirtualX. void SetTextSizePixels(Int_t npixels); Delegate to gVirtualX. Int_t CreateDrawable(UInt_t w, UInt_t h); Create a gVirtualX Pixmap. void ClearDrawable(); Clear the current gVirtualX window. void CopyDrawable(Int_t id, Int_t px, Int_t py); Copy a gVirtualX pixmap. void DestroyDrawable(); Close the current gVirtualX pixmap. void SelectDrawable(Int_t device); Select the window in which the graphics will go. void DrawPixels(const unsigned char* pixelData, UInt_t width, UInt_t height, Int_t dstX, Int_t dstY, Bool_t enableAlphaBlending); Noop, for non-gl pad TASImage calls gVirtualX->CopyArea. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Paint a simple line. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Paint a simple line in normalized coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); Paint Polyline. void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Paint polyline. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Paint polyline in normalized coordinates. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Paint polymarker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Paint polymarker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Paint text. void DrawText(Double_t x, Double_t y, const wchar_t* text, TVirtualPadPainter::ETextMode mode); Special version working with wchar_t and required by TMathText. void DrawTextNDC(Double_t u, Double_t v, const char* text, TVir",MatchSource.WIKI,root/html604/TPadPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPadPainter.html
https://root.cern/root/html604/TPadPainter.html:7543,Usability,simpl,simply,7543,"a simple line in normalized coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); Paint Polyline. void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Paint polyline. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Paint polyline in normalized coordinates. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Paint polymarker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Paint polymarker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Paint text. void DrawText(Double_t x, Double_t y, const wchar_t* text, TVirtualPadPainter::ETextMode mode); Special version working with wchar_t and required by TMathText. void DrawTextNDC(Double_t u, Double_t v, const char* text, TVirtualPadPainter::ETextMode mode); Paint text in normalized coordinates. void SaveImage(TVirtualPad* pad, const char* fileName, Int_t type) const; Save the image displayed in the canvas pointed by ""pad"" into a binary file. void DrawTextNDC(Double_t u, Double_t v, const wchar_t* text, TVirtualPadPainter::ETextMode mode); Paint text in normalized coordinates. TPadPainter(); Final overriders for TVirtualPadPainter pure virtual functions.; 1. Part, which simply delegates to TVirtualX.; Line attributes. TPadPainter(const TPadPainter& rhs); Let's make this clear:. » Author: Olivier Couet, Timur Pocheptsov 06/05/2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/gpad:$Id$ » Last generated: 2015-06-02 16:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TPadPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPadPainter.html
https://root.cern/root/html604/TPadPainter.html:7645,Usability,clear,clear,7645,"a simple line in normalized coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); Paint Polyline. void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Paint polyline. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Paint polyline in normalized coordinates. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Paint polymarker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Paint polymarker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Paint text. void DrawText(Double_t x, Double_t y, const wchar_t* text, TVirtualPadPainter::ETextMode mode); Special version working with wchar_t and required by TMathText. void DrawTextNDC(Double_t u, Double_t v, const char* text, TVirtualPadPainter::ETextMode mode); Paint text in normalized coordinates. void SaveImage(TVirtualPad* pad, const char* fileName, Int_t type) const; Save the image displayed in the canvas pointed by ""pad"" into a binary file. void DrawTextNDC(Double_t u, Double_t v, const wchar_t* text, TVirtualPadPainter::ETextMode mode); Paint text in normalized coordinates. TPadPainter(); Final overriders for TVirtualPadPainter pure virtual functions.; 1. Part, which simply delegates to TVirtualX.; Line attributes. TPadPainter(const TPadPainter& rhs); Let's make this clear:. » Author: Olivier Couet, Timur Pocheptsov 06/05/2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/gpad:$Id$ » Last generated: 2015-06-02 16:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TPadPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPadPainter.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:2704,Availability,error,error,2704,"constMENU ; voidDrawFaceGouraudShaded(Int_t* icodes, Double_t[][3] xyz, Int_t np, Int_t* iface, Double_t* t); voidDrawFaceMode1(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* t); voidDrawFaceMode2(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* t); voidDrawFaceMode3(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* t); voidDrawFaceMove1(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); voidDrawFaceMove2(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); voidDrawFaceMove3(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); voidDrawFaceRaster1(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); voidDrawFaceRaster2(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillPolygon(Int_t n, Double_t* p, Double_t* f); voidFillPolygonBorder(Int_t nn, Double_t* xy); voidFindLevelLines(Int_t np, Double_t* f, Double_t* t); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindPartEdge(Double_t* p1, Double_t* p2, Double_t f1, Double_t f2, Double_t fmin, Double_t fmax, Int_t& kpp, Double_t* pp); voidFindVisibleDraw(Double_t* r1, Double_t* r2); voidFindVisibleLine(Double_t* p1, Double_t* p2, Int_t ntmax, Int_t& nt, Double_t* t); voidFrontBox(Double_t ang); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const c",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:2788,Availability,error,error,2788,"t_t* iface, Double_t* t); voidDrawFaceMode1(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* t); voidDrawFaceMode2(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* t); voidDrawFaceMode3(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* t); voidDrawFaceMove1(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); voidDrawFaceMove2(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); voidDrawFaceMove3(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); voidDrawFaceRaster1(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); voidDrawFaceRaster2(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillPolygon(Int_t n, Double_t* p, Double_t* f); voidFillPolygonBorder(Int_t nn, Double_t* xy); voidFindLevelLines(Int_t np, Double_t* f, Double_t* t); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindPartEdge(Double_t* p1, Double_t* p2, Double_t f1, Double_t f2, Double_t fmin, Double_t fmax, Int_t& kpp, Double_t* pp); voidFindVisibleDraw(Double_t* r1, Double_t* r2); voidFindVisibleLine(Double_t* p1, Double_t* p2, Int_t ntmax, Int_t& nt, Double_t* t); voidFrontBox(Double_t ang); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; vir",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:15968,Availability,error,error,15968,"lass Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPainter3dAlgorithms(); Lego default constructor. TPainter3dAlgorithms(Double_t* rmin, Double_t* rmax, Int_t system = 1); Normal default constructor. rmin[3], rmax[3] are the limits of the lego object depending on; the selected coordinate system. ~TPainter3dAlgorithms(); Lego default destructor. void BackBox(Double_t ang); Draw back surfaces of surrounding box. Input ANG - angle between X and Y axis. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. void ClearRaster(); Clear screen. void ColorFunction(Int_t nl, Double_t* fl, Int_t* icl, Int_t& irep); Set correspondance between function and color levels. Input: NL - number of levels; FL(NL) - function levels; ICL(NL+1) - colors for levels. Output: IREP - reply: 0 O.K.; -1 error in parameters:; illegal number of levels; function levels must be in increasing order; negative color index. void DefineGridLevels(Int_t ndivz); Define the grid levels drawn in the background of surface and lego plots.; The grid levels are aligned on the Z axis' main tick marks. void DrawFaceMode1(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* t); Draw face - 1st variant. Function: Draw face - 1st variant; (2 colors: 1st for external surface, 2nd for internal). References: WCtoNDC. Input: ICODES(*) - set of codes for the line (not used); ICODES(1) - IX; ICODES(2) - IY; XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; T(NP) - additional function defined on this face; (not used in this routine). void DrawFaceMode2(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* t); Draw face - 2nd option. Function: Draw face - 2nd option; (fill in correspondance with function levels). References: WCtoNDC, FillPolygon. Input: ICODES(*) - set of codes for the line (not used); ICODES(1) - IX; ICODES",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:27331,Availability,error,error,27331,"nal routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1,2,3,4 - ordinary sides; 5-bottom,6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void LightSource(Int_t nl, Double_t yl, Double_t xscr, Double_t yscr, Double_t zscr, Int_t& irep); Set light source. Input: NL - source number: -1 off all light sources; 0 set diffused light; YL - intensity of the light source; XSCR |; YSCR > direction of the light (in respect of the screen); ZSCR |. Output: IREP - reply : 0 - O.K.; -1 - error in light sources definition:; negative intensity; source number greater than max; light source is placed at origin. void Luminosity(Double_t* anorm, Double_t& flum); Find surface luminosity at given point; --; Lightness model formula: Y = YD*QA + > YLi*(QD*cosNi+QS*cosRi); --. B1 = VN(3)*VL(2) - VN(2)*VL(3); B2 = VN(1)*VL(3) - VN(3)*VL(1); B3 = VN(2)*VL(1) - VN(1)*VL(2); B4 = VN(1)*VL(1) + VN(2)*VL(2) + VN(3)*VL(3); VR(1) = VN(3)*B2 - VN(2)*B3 + VN(1)*B4; VR(2) =-VN(3)*B1 + VN(1)*B3 + VN(2)*B4; VR(3) = VN(2)*B1 - VN(1)*B2 + VN(3)*B4; S = SQRT(VR(1)*VR(1)+VR(2)*VR(2)+VR(3)*VR(3)); VR(1) = VR(1)/S; VR(2) = VR(2)/S; VR(3) = VR(3)/S; COSR = VR(1)*0. + VR(2)*0. + VR(3)*1. References: WCtoNDC. Input: ANORM(3) - surface normal at given point. Output: FLUM - luminosity. void ModifyScreen(Double_t* r1, Double_t* r2); Modify SCREEN. Input: R1(3) - 1-st point of the line; R2(3) - 2-nd point of the line. void SetDrawFace(TPainter3dAlgorithms::DrawFaceFunc_t pointer); Store pointer to current algorithm to draw faces. void SetLegoFunction(TPainter3d",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:30171,Availability,error,error,30171,"olor = 1, Style_t style = 1, Width_t width = 1, Int_t n = 0). void SideVisibilityDecode(Double_t val, Int_t& iv1, Int_t& iv2, Int_t& iv3, Int_t& iv4, Int_t& iv5, Int_t& iv6, Int_t& ir); Decode side visibilities and order along R for sector. Input: VAL - encoded value. Output: IV1 ... IV6 - visibility of the sides; IR - increment along R. void SideVisibilityEncode(Int_t iopt, Double_t phi1, Double_t phi2, Double_t& val); Encode side visibilities and order along R for sector. Input: IOPT - options: 1 - from BACK to FRONT 'BF'; 2 - from FRONT to BACK 'FB'; PHI1 - 1st phi of sector; PHI2 - 2nd phi of sector. Output: VAL - encoded value. void Spectrum(Int_t nl, Double_t fmin, Double_t fmax, Int_t ic, Int_t idc, Int_t& irep); Set Spectrum. Input: NL - number of levels; FMIN - MIN function value; FMAX - MAX function value; IC - initial color index (for 1st level); IDC - color index increment. Output: IREP - reply: 0 O.K.; -1 error in parameters; F_max less than F_min; illegal number of levels; initial color index is negative; color index increment must be positive. void SurfaceCartesian(Double_t ang, Int_t nx, Int_t ny, const char* chopt); Draw surface in cartesian coordinate system. Input: ANG - angle between X ang Y; NX - number of steps along X; NY - number of steps along Y. FUN(IX,IY,F,T) - external routine; IX - X number of the cell; IY - Y number of the cell; F(3,4) - face which corresponds to the cell; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IX; ICODES(2) - IY; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceFunction(Int_t ia, Int_t ib, Double_t* f, Double_t* t); Service function for Surfaces. void SurfacePolar(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in polar coordinates. Input: IORDR - order of variables (0 ",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:34032,Availability,error,error,34032,"nal routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceProperty(Double_t qqa, Double_t qqd, Double_t qqs, Int_t nnqs, Int_t& irep); Set surface property coefficients. Input: QQA - diffusion coefficient for diffused light [0.,1.]; QQD - diffusion coefficient for direct light [0.,1.]; QQS - diffusion coefficient for reflected light [0.,1.]; NNCS - power coefficient for reflected light (.GE.1). --; Lightness model formula: Y = YD*QA + > YLi*(QD*cosNi+QS*cosRi); --. Output: IREP - reply : 0 - O.K.; -1 - error in cooefficients. void ImplicitFunction(Double_t* rmin, Double_t* rmax, Int_t nx, Int_t ny, Int_t nz, const char* chopt); Draw implicit function FUN(X,Y,Z) = 0 in cartesian coordinates using; hidden surface removal algorithm ""Painter"". Input: FUN - external routine FUN(X,Y,Z); RMIN(3) - min scope coordinates; RMAX(3) - max scope coordinates; NX - number of steps along X; NY - number of steps along Y; NZ - number of steps along Z. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - 1; ICODES(2) - 1; ICODES(3) - 1; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function (lightness). CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void MarchingCube(Double_t fiso, Double_t[8][3] p, Double_t[8] f, Double_t[8][3] g, Int_t& nnod, Int_t& ntria, Double_t[][3] xyz, Double_t[][3] grad, Int_t[][3] itria); Topological decider for ""Marching Cubes"" algorithm Find set of triangles; aproximating the isosu",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:508,Energy Efficiency,adapt,adapted,508,". TPainter3dAlgorithms. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HISTPAINTER; » TPainter3dAlgorithms. class TPainter3dAlgorithms: public TObject, public TAttLine, public TAttFill. Legos and Surfaces package; This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet; and Evgueni Tcherniaev. This class is a subset of the original system. It has been converted to a C++; class by Rene Brun.; . Function Members (Methods); public:. virtual~TPainter3dAlgorithms(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidBackBox(Double_t ang); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearRaster(); virtual TObject*TObject::Clone(const char* newname = """") const; voidColorFunction(Int_t nl, Double_t* fl, Int_t* icl, Int_t& irep); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidDefineGridLevels(Int_t ndivz); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawFaceGouraudShaded(Int_t* icodes, Double_t[][3] xyz, Int_t np, Int_t* iface, Double_t* t); voidDrawFaceMode1(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* t); voidDrawFaceMode2(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* t); voidDrawFace",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:33875,Energy Efficiency,power,power,33875," of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceProperty(Double_t qqa, Double_t qqd, Double_t qqs, Int_t nnqs, Int_t& irep); Set surface property coefficients. Input: QQA - diffusion coefficient for diffused light [0.,1.]; QQD - diffusion coefficient for direct light [0.,1.]; QQS - diffusion coefficient for reflected light [0.,1.]; NNCS - power coefficient for reflected light (.GE.1). --; Lightness model formula: Y = YD*QA + > YLi*(QD*cosNi+QS*cosRi); --. Output: IREP - reply : 0 - O.K.; -1 - error in cooefficients. void ImplicitFunction(Double_t* rmin, Double_t* rmax, Int_t nx, Int_t ny, Int_t nz, const char* chopt); Draw implicit function FUN(X,Y,Z) = 0 in cartesian coordinates using; hidden surface removal algorithm ""Painter"". Input: FUN - external routine FUN(X,Y,Z); RMIN(3) - min scope coordinates; RMAX(3) - max scope coordinates; NX - number of steps along X; NY - number of steps along Y; NZ - number of steps along Z. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - 1; ICODES(2) - 1; ICODES(3) - 1; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function (lightness). CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void MarchingCube(Double_t fiso, Double_t[8][3] p, Double_t[8] f, Double_t[8][3] g, Int_t& nnod, Int_t& ntria, Doub",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:15313,Integrability,depend,depending,15313,"nt_tfNyrast; Double_tfP8[8][3]; Double_tfPlines[1200]; Double_tfQA; Double_tfQD; Double_tfQS; Int_t*fRasterpointer to raster buffer; Double_tfRmax[3]Upper limits of lego; Double_tfRmin[3]Lower limits of lego; TPainter3dAlgorithms::SurfaceFunc_tfSurfaceFunctionpointer to surface function; Int_tfSystemCoordinate system; Double_tfT[200]; Double_tfU[2000]; Double_tfVls[12]; Double_tfX0; Double_tfXrast; Double_tfYdl; Double_tfYls[4]; Double_tfYrast; static TF3*fgCurrentF3Pointer to the 3D function to be paint.; static Int_tfgF3ClippingClipping box is off (0) or on (1); static Double_tfgF3XClipClipping plne along X; static Double_tfgF3YClipClipping plne along Y; static Double_tfgF3ZClipClipping plne along Y. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPainter3dAlgorithms(); Lego default constructor. TPainter3dAlgorithms(Double_t* rmin, Double_t* rmax, Int_t system = 1); Normal default constructor. rmin[3], rmax[3] are the limits of the lego object depending on; the selected coordinate system. ~TPainter3dAlgorithms(); Lego default destructor. void BackBox(Double_t ang); Draw back surfaces of surrounding box. Input ANG - angle between X and Y axis. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. void ClearRaster(); Clear screen. void ColorFunction(Int_t nl, Double_t* fl, Int_t* icl, Int_t& irep); Set correspondance between function and color levels. Input: NL - number of levels; FL(NL) - function levels; ICL(NL+1) - colors for levels. Output: IREP - reply: 0 O.K.; -1 error in parameters:; illegal number of levels; function levels must be in increasing order; negative color index. void DefineGridLevels(Int_t ndivz); Define the grid levels drawn in the background of surface and lego plots.; The grid levels are aligned on the Z axis' main tick marks. void DrawFaceMode1(Int_t* icodes, Double_t* xyz, Int_t n",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:15548,Integrability,rout,routine,15548,"tfSystemCoordinate system; Double_tfT[200]; Double_tfU[2000]; Double_tfVls[12]; Double_tfX0; Double_tfXrast; Double_tfYdl; Double_tfYls[4]; Double_tfYrast; static TF3*fgCurrentF3Pointer to the 3D function to be paint.; static Int_tfgF3ClippingClipping box is off (0) or on (1); static Double_tfgF3XClipClipping plne along X; static Double_tfgF3YClipClipping plne along Y; static Double_tfgF3ZClipClipping plne along Y. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPainter3dAlgorithms(); Lego default constructor. TPainter3dAlgorithms(Double_t* rmin, Double_t* rmax, Int_t system = 1); Normal default constructor. rmin[3], rmax[3] are the limits of the lego object depending on; the selected coordinate system. ~TPainter3dAlgorithms(); Lego default destructor. void BackBox(Double_t ang); Draw back surfaces of surrounding box. Input ANG - angle between X and Y axis. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. void ClearRaster(); Clear screen. void ColorFunction(Int_t nl, Double_t* fl, Int_t* icl, Int_t& irep); Set correspondance between function and color levels. Input: NL - number of levels; FL(NL) - function levels; ICL(NL+1) - colors for levels. Output: IREP - reply: 0 O.K.; -1 error in parameters:; illegal number of levels; function levels must be in increasing order; negative color index. void DefineGridLevels(Int_t ndivz); Define the grid levels drawn in the background of surface and lego plots.; The grid levels are aligned on the Z axis' main tick marks. void DrawFaceMode1(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* t); Draw face - 1st variant. Function: Draw face - 1st variant; (2 colors: 1st for external surface, 2nd for internal). References: WCtoNDC. Input: ICODES(*) - set of codes for the line (not used); ICODES(1) - IX; ICODES(2) - IY; XYZ(3,*) - coordinates of nodes; NP ",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:16708,Integrability,rout,routine,16708,"s for this face; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. void ClearRaster(); Clear screen. void ColorFunction(Int_t nl, Double_t* fl, Int_t* icl, Int_t& irep); Set correspondance between function and color levels. Input: NL - number of levels; FL(NL) - function levels; ICL(NL+1) - colors for levels. Output: IREP - reply: 0 O.K.; -1 error in parameters:; illegal number of levels; function levels must be in increasing order; negative color index. void DefineGridLevels(Int_t ndivz); Define the grid levels drawn in the background of surface and lego plots.; The grid levels are aligned on the Z axis' main tick marks. void DrawFaceMode1(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* t); Draw face - 1st variant. Function: Draw face - 1st variant; (2 colors: 1st for external surface, 2nd for internal). References: WCtoNDC. Input: ICODES(*) - set of codes for the line (not used); ICODES(1) - IX; ICODES(2) - IY; XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; T(NP) - additional function defined on this face; (not used in this routine). void DrawFaceMode2(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* t); Draw face - 2nd option. Function: Draw face - 2nd option; (fill in correspondance with function levels). References: WCtoNDC, FillPolygon. Input: ICODES(*) - set of codes for the line (not used); ICODES(1) - IX; ICODES(2) - IY; XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; T(NP) - additional function defined on this face. void DrawFaceMode3(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* t); Draw face - 3rd option. Function: Draw face - 3rd option; (draw face for stacked lego plot). References: WCtoNDC. Input: ICODES(*) - set of codes for the line; ICODES(1) - IX coordinate of the line cell; ICODES(2) - IY coordinate of the line cell; ICODES(3) - lego number; ICODES(4) - side: 1-face,2-right,3-back,4-left,; 5-bottom, 6-top; XYZ(3,*) - coor",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:18237,Integrability,rout,routine,18237,"function defined on this face. void DrawFaceMode3(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* t); Draw face - 3rd option. Function: Draw face - 3rd option; (draw face for stacked lego plot). References: WCtoNDC. Input: ICODES(*) - set of codes for the line; ICODES(1) - IX coordinate of the line cell; ICODES(2) - IY coordinate of the line cell; ICODES(3) - lego number; ICODES(4) - side: 1-face,2-right,3-back,4-left,; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; T(*) - additional function (not used here). void DrawFaceMove1(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); Draw face - 1st variant for ""MOVING SCREEN"" algorithm. Function: Draw face - 1st variant for ""MOVING SCREEN"" algorithm; (draw face with level lines). References: FindLevelLines, WCtoNDC,; FindVisibleDraw, ModifyScreen. Input: ICODES(*) - set of codes for the line (not used); ICODES(1) - IX; ICODES(2) - IY; XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; TT(NP) - additional function defined on this face; (not used in this routine). void DrawFaceMove3(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); Draw face - 3rd variant for ""MOVING SCREEN"" algorithm. Function: Draw face - 1st variant for ""MOVING SCREEN"" algorithm; (draw level lines only). References: FindLevelLines, WCtoNDC,; FindVisibleDraw, ModifyScreen. Input: ICODES(*) - set of codes for the line (not used); ICODES(1) - IX; ICODES(2) - IY; XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; TT(NP) - additional function defined on this face; (not used in this routine). void DrawFaceMove2(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); Draw face - 2nd variant for ""MOVING SCREEN"" algorithm. Function: Draw face - 2nd variant for ""MOVING SCREEN"" algorithm; (draw face for stacked lego plot). References: FindLevelLines, WCtoNDC,; FindVisibleDraw, ModifyScreen. Input: ICODES(*) - set o",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:18780,Integrability,rout,routine,18780,"onal function (not used here). void DrawFaceMove1(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); Draw face - 1st variant for ""MOVING SCREEN"" algorithm. Function: Draw face - 1st variant for ""MOVING SCREEN"" algorithm; (draw face with level lines). References: FindLevelLines, WCtoNDC,; FindVisibleDraw, ModifyScreen. Input: ICODES(*) - set of codes for the line (not used); ICODES(1) - IX; ICODES(2) - IY; XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; TT(NP) - additional function defined on this face; (not used in this routine). void DrawFaceMove3(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); Draw face - 3rd variant for ""MOVING SCREEN"" algorithm. Function: Draw face - 1st variant for ""MOVING SCREEN"" algorithm; (draw level lines only). References: FindLevelLines, WCtoNDC,; FindVisibleDraw, ModifyScreen. Input: ICODES(*) - set of codes for the line (not used); ICODES(1) - IX; ICODES(2) - IY; XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; TT(NP) - additional function defined on this face; (not used in this routine). void DrawFaceMove2(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); Draw face - 2nd variant for ""MOVING SCREEN"" algorithm. Function: Draw face - 2nd variant for ""MOVING SCREEN"" algorithm; (draw face for stacked lego plot). References: FindLevelLines, WCtoNDC,; FindVisibleDraw, ModifyScreen. Input: ICODES(*) - set of codes for the line (not used); ICODES(1) - IX; ICODES(2) - IY; ICODES(3) - line code (N of lego); XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; TT(NP) - additional function defined on this face; (not used in this routine). void DrawFaceRaster1(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); Draw face - 1st variant for ""RASTER SCREEN"" algorithm. Function: Draw face - 1st variant for ""RASTER SCREEN"" algorithm; (draw face with level lines). References: FindLevelLines, WCtoNDC,; FindVisibleLi",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:19368,Integrability,rout,routine,19368,"utine). void DrawFaceMove3(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); Draw face - 3rd variant for ""MOVING SCREEN"" algorithm. Function: Draw face - 1st variant for ""MOVING SCREEN"" algorithm; (draw level lines only). References: FindLevelLines, WCtoNDC,; FindVisibleDraw, ModifyScreen. Input: ICODES(*) - set of codes for the line (not used); ICODES(1) - IX; ICODES(2) - IY; XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; TT(NP) - additional function defined on this face; (not used in this routine). void DrawFaceMove2(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); Draw face - 2nd variant for ""MOVING SCREEN"" algorithm. Function: Draw face - 2nd variant for ""MOVING SCREEN"" algorithm; (draw face for stacked lego plot). References: FindLevelLines, WCtoNDC,; FindVisibleDraw, ModifyScreen. Input: ICODES(*) - set of codes for the line (not used); ICODES(1) - IX; ICODES(2) - IY; ICODES(3) - line code (N of lego); XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; TT(NP) - additional function defined on this face; (not used in this routine). void DrawFaceRaster1(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); Draw face - 1st variant for ""RASTER SCREEN"" algorithm. Function: Draw face - 1st variant for ""RASTER SCREEN"" algorithm; (draw face with level lines). References: FindLevelLines, WCtoNDC,; FindVisibleLine, FillPolygonBorder. Input: ICODES(*) - set of codes for the line (not used); ICODES(1) - IX; ICODES(2) - IY; XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; TT(NP) - additional function defined on this face; (not used in this routine). void DrawFaceRaster2(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); Draw face - 2nd variant for ""RASTER SCREEN"" algorithm. Function: Draw face - 2nd variant for ""RASTER SCREEN"" algorithm; (draw face for stacked lego plot). References: WCtoNDC, FindVisibleLine, FillPolygonBorder. Inpu",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:19923,Integrability,rout,routine,19923,"t_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); Draw face - 2nd variant for ""MOVING SCREEN"" algorithm. Function: Draw face - 2nd variant for ""MOVING SCREEN"" algorithm; (draw face for stacked lego plot). References: FindLevelLines, WCtoNDC,; FindVisibleDraw, ModifyScreen. Input: ICODES(*) - set of codes for the line (not used); ICODES(1) - IX; ICODES(2) - IY; ICODES(3) - line code (N of lego); XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; TT(NP) - additional function defined on this face; (not used in this routine). void DrawFaceRaster1(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); Draw face - 1st variant for ""RASTER SCREEN"" algorithm. Function: Draw face - 1st variant for ""RASTER SCREEN"" algorithm; (draw face with level lines). References: FindLevelLines, WCtoNDC,; FindVisibleLine, FillPolygonBorder. Input: ICODES(*) - set of codes for the line (not used); ICODES(1) - IX; ICODES(2) - IY; XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; TT(NP) - additional function defined on this face; (not used in this routine). void DrawFaceRaster2(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); Draw face - 2nd variant for ""RASTER SCREEN"" algorithm. Function: Draw face - 2nd variant for ""RASTER SCREEN"" algorithm; (draw face for stacked lego plot). References: WCtoNDC, FindVisibleLine, FillPolygonBorder. Input: ICODES(*) - set of codes for the line (not used); ICODES(1) - IX; ICODES(2) - IY; ICODES(3) - line code (N of lego); XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; TT(NP) - additional function defined on this face; (not used in this routine). void FillPolygon(Int_t n, Double_t* p, Double_t* f); Fill polygon with function values at vertexes. Input: N - number of vertexes; P(3,*) - polygon; F(*) - function values at nodes. Errors: - illegal number of vertexes in polygon; - illegal call of FillPolygon: no levels. void FillPolygonBorder(Int_t",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:20501,Integrability,rout,routine,20501,"ine). void DrawFaceRaster1(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); Draw face - 1st variant for ""RASTER SCREEN"" algorithm. Function: Draw face - 1st variant for ""RASTER SCREEN"" algorithm; (draw face with level lines). References: FindLevelLines, WCtoNDC,; FindVisibleLine, FillPolygonBorder. Input: ICODES(*) - set of codes for the line (not used); ICODES(1) - IX; ICODES(2) - IY; XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; TT(NP) - additional function defined on this face; (not used in this routine). void DrawFaceRaster2(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); Draw face - 2nd variant for ""RASTER SCREEN"" algorithm. Function: Draw face - 2nd variant for ""RASTER SCREEN"" algorithm; (draw face for stacked lego plot). References: WCtoNDC, FindVisibleLine, FillPolygonBorder. Input: ICODES(*) - set of codes for the line (not used); ICODES(1) - IX; ICODES(2) - IY; ICODES(3) - line code (N of lego); XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; TT(NP) - additional function defined on this face; (not used in this routine). void FillPolygon(Int_t n, Double_t* p, Double_t* f); Fill polygon with function values at vertexes. Input: N - number of vertexes; P(3,*) - polygon; F(*) - function values at nodes. Errors: - illegal number of vertexes in polygon; - illegal call of FillPolygon: no levels. void FillPolygonBorder(Int_t nn, Double_t* xy); Fill a polygon including border (""RASTER SCREEN""). Input: NN - number of polygon nodes; XY(2,*) - polygon nodes. void FindLevelLines(Int_t np, Double_t* f, Double_t* t); Find level lines for face. Input: NP - number of nodes; F(3,NP) - face; T(NP) - additional function. Error: number of points for line not equal 2. void FindPartEdge(Double_t* p1, Double_t* p2, Double_t f1, Double_t f2, Double_t fmin, Double_t fmax, Int_t& kpp, Double_t* pp); Find part of edge. Function: Find part of edge where function defined on this edge; has value ",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:22358,Integrability,rout,routine,22358,"int; P2(3) - 2nd point; F1 - function value at 1st point; F2 - function value at 2nd point; FMIN - min value of layer; FMAX - max value of layer. Output: KPP - current number of point; PP(3,*) - coordinates of new face. void FindVisibleDraw(Double_t* r1, Double_t* r2); Find visible parts of line (draw line). Input: R1(3) - 1-st point of the line; R2(3) - 2-nd point of the line. void FindVisibleLine(Double_t* p1, Double_t* p2, Int_t ntmax, Int_t& nt, Double_t* t); Find visible part of a line (""RASTER SCREEN""). Input: P1(2) - 1st point of the line; P2(2) - 2nd point of the line; NTMAX - max allowed number of visible segments. Output: NT - number of visible segments of the line; T(2,*) - visible segments. void FrontBox(Double_t ang); Draw forward faces of surrounding box & axes. Function: Draw forward faces of surrounding box & axes. References: AxisVertex, Gaxis. Input ANG - angle between X and Y axis. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. void GouraudFunction(Int_t ia, Int_t ib, Double_t* f, Double_t* t); Find part of surface with luminosity in the corners. This routine is used for Gouraud shading. void InitMoveScreen(Double_t xmin, Double_t xmax); Initialize ""MOVING SCREEN"" method. Input: XMIN - left boundary; XMAX - right boundary. void InitRaster(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, Int_t nx, Int_t ny); Initialize hidden lines removal algorithm (RASTER SCREEN). Input: XMIN - Xmin in the normalized coordinate system; YMIN - Ymin in the normalized coordinate system; XMAX - Xmax in the normalized coordinate system; YMAX - Ymax in the normalized coordinate system; NX - number of pixels along X; NY - number of pixels along Y. void LegoFunction(Int_t ia, Int_t ib, Int_t& nv, Double_t* ab, Double_t* vv, Double_t* t); Service function for Legos. void LegoCartesian(Double_t ang, Int_t nx, Int_t ny, const char* chopt)",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:22627,Integrability,rout,routine,22627,"isibleDraw(Double_t* r1, Double_t* r2); Find visible parts of line (draw line). Input: R1(3) - 1-st point of the line; R2(3) - 2-nd point of the line. void FindVisibleLine(Double_t* p1, Double_t* p2, Int_t ntmax, Int_t& nt, Double_t* t); Find visible part of a line (""RASTER SCREEN""). Input: P1(2) - 1st point of the line; P2(2) - 2nd point of the line; NTMAX - max allowed number of visible segments. Output: NT - number of visible segments of the line; T(2,*) - visible segments. void FrontBox(Double_t ang); Draw forward faces of surrounding box & axes. Function: Draw forward faces of surrounding box & axes. References: AxisVertex, Gaxis. Input ANG - angle between X and Y axis. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. void GouraudFunction(Int_t ia, Int_t ib, Double_t* f, Double_t* t); Find part of surface with luminosity in the corners. This routine is used for Gouraud shading. void InitMoveScreen(Double_t xmin, Double_t xmax); Initialize ""MOVING SCREEN"" method. Input: XMIN - left boundary; XMAX - right boundary. void InitRaster(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, Int_t nx, Int_t ny); Initialize hidden lines removal algorithm (RASTER SCREEN). Input: XMIN - Xmin in the normalized coordinate system; YMIN - Ymin in the normalized coordinate system; XMAX - Xmax in the normalized coordinate system; YMAX - Ymax in the normalized coordinate system; NX - number of pixels along X; NY - number of pixels along Y. void LegoFunction(Int_t ia, Int_t ib, Int_t& nv, Double_t* ab, Double_t* vv, Double_t* t); Service function for Legos. void LegoCartesian(Double_t ang, Int_t nx, Int_t ny, const char* chopt); Draw stack of lego-plots in cartesian coordinates. Input: ANG - angle between X ang Y; NX - number of cells along X; NY - number of cells along Y. FUN(IX,IY,NV,XY,V,T) - external routine; IX - X number of the cell; IY - Y numbe",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:23594,Integrability,rout,routine,23594,"ble_t xmin, Double_t xmax); Initialize ""MOVING SCREEN"" method. Input: XMIN - left boundary; XMAX - right boundary. void InitRaster(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, Int_t nx, Int_t ny); Initialize hidden lines removal algorithm (RASTER SCREEN). Input: XMIN - Xmin in the normalized coordinate system; YMIN - Ymin in the normalized coordinate system; XMAX - Xmax in the normalized coordinate system; YMAX - Ymax in the normalized coordinate system; NX - number of pixels along X; NY - number of pixels along Y. void LegoFunction(Int_t ia, Int_t ib, Int_t& nv, Double_t* ab, Double_t* vv, Double_t* t); Service function for Legos. void LegoCartesian(Double_t ang, Int_t nx, Int_t ny, const char* chopt); Draw stack of lego-plots in cartesian coordinates. Input: ANG - angle between X ang Y; NX - number of cells along X; NY - number of cells along Y. FUN(IX,IY,NV,XY,V,T) - external routine; IX - X number of the cell; IY - Y number of the cell; NV - number of values for given cell; XY(2,4)- coordinates of the cell corners; V(NV) - cell values; T(4,NV)- additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this line; ICODES(1) - IX; ICODES(2) - IY; ICODES(3) - IV; ICODES(4) - side: 1-face,2-right,3-back,4-left,; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; T(4) - additional function (here Z-coordinate). CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoPolar(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in polar coordinates. Input: IORDR - order of variables (0 - R,PHI; 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cel",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:23847,Integrability,rout,routine,23847,"the normalized coordinate system; YMIN - Ymin in the normalized coordinate system; XMAX - Xmax in the normalized coordinate system; YMAX - Ymax in the normalized coordinate system; NX - number of pixels along X; NY - number of pixels along Y. void LegoFunction(Int_t ia, Int_t ib, Int_t& nv, Double_t* ab, Double_t* vv, Double_t* t); Service function for Legos. void LegoCartesian(Double_t ang, Int_t nx, Int_t ny, const char* chopt); Draw stack of lego-plots in cartesian coordinates. Input: ANG - angle between X ang Y; NX - number of cells along X; NY - number of cells along Y. FUN(IX,IY,NV,XY,V,T) - external routine; IX - X number of the cell; IY - Y number of the cell; NV - number of values for given cell; XY(2,4)- coordinates of the cell corners; V(NV) - cell values; T(4,NV)- additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this line; ICODES(1) - IX; ICODES(2) - IY; ICODES(3) - IV; ICODES(4) - side: 1-face,2-right,3-back,4-left,; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; T(4) - additional function (here Z-coordinate). CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoPolar(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in polar coordinates. Input: IORDR - order of variables (0 - R,PHI; 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1-internal,2-right,3-external,4-left; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; ",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:24517,Integrability,rout,routine,24517," - X number of the cell; IY - Y number of the cell; NV - number of values for given cell; XY(2,4)- coordinates of the cell corners; V(NV) - cell values; T(4,NV)- additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this line; ICODES(1) - IX; ICODES(2) - IY; ICODES(3) - IV; ICODES(4) - side: 1-face,2-right,3-back,4-left,; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; T(4) - additional function (here Z-coordinate). CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoPolar(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in polar coordinates. Input: IORDR - order of variables (0 - R,PHI; 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1-internal,2-right,3-external,4-left; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI; 1 - PHI,Z); NA - number of steps along 1st variable; NPHI - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV)",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:24761,Integrability,rout,routine,24761,"codes for this line; ICODES(1) - IX; ICODES(2) - IY; ICODES(3) - IV; ICODES(4) - side: 1-face,2-right,3-back,4-left,; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; T(4) - additional function (here Z-coordinate). CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoPolar(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in polar coordinates. Input: IORDR - order of variables (0 - R,PHI; 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1-internal,2-right,3-external,4-left; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI; 1 - PHI,Z); NA - number of steps along 1st variable; NPHI - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1,2,3,4 - ordinary sides; 5-bottom,6-top; XYZ(3,*) - coordinates of nodes; N",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:25441,Integrability,rout,routine,25441,"- cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1-internal,2-right,3-external,4-left; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI; 1 - PHI,Z); NA - number of steps along 1st variable; NPHI - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1,2,3,4 - ordinary sides; 5-bottom,6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:25685,Integrability,rout,routine,25685,"s for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1-internal,2-right,3-external,4-left; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI; 1 - PHI,Z); NA - number of steps along 1st variable; NPHI - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1,2,3,4 - ordinary sides; 5-bottom,6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1,2,3,4 - ordinary sides; 5-bottom,6-top; ",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:26392,Integrability,rout,routine,26392,"ble; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1,2,3,4 - ordinary sides; 5-bottom,6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1,2,3,4 - ordinary sides; 5-bottom,6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void LightSource(Int_t nl, Double_t yl, Double_t xscr, Double_t yscr, Double_t zscr, Int_t& irep); Set light source. Input: NL - source number: -1 off all light sources; 0 set diffused light; YL - intensity of the light source; XSCR |; YSCR > direction of the light (in respect of the screen); ZSCR |. Output: IREP - reply : 0 - O.K.; -1 - error in light sources definition:; negative intensity; source number greater than max; light source is placed at origin. void Luminosity(Double_t* an",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:26636,Integrability,rout,routine,26636,"- IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1,2,3,4 - ordinary sides; 5-bottom,6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1,2,3,4 - ordinary sides; 5-bottom,6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void LightSource(Int_t nl, Double_t yl, Double_t xscr, Double_t yscr, Double_t zscr, Int_t& irep); Set light source. Input: NL - source number: -1 off all light sources; 0 set diffused light; YL - intensity of the light source; XSCR |; YSCR > direction of the light (in respect of the screen); ZSCR |. Output: IREP - reply : 0 - O.K.; -1 - error in light sources definition:; negative intensity; source number greater than max; light source is placed at origin. void Luminosity(Double_t* anorm, Double_t& flum); Find surface luminosity at given point; --; Lightness model formula: Y = YD*QA + > YLi*(QD*cosNi+QS*cosRi); --. B1 = VN(3)*VL(2) - VN(2)*VL(3); B2 = VN(1)*VL(3) - VN(3)*VL(1); B3 = VN(2)*VL(1) - VN(1)*VL(2); B4 = VN(1)*VL(1) + VN(2)*VL(2) + VN(3)*VL(3); VR(1",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:30557,Integrability,rout,routine,30557,"t phi1, Double_t phi2, Double_t& val); Encode side visibilities and order along R for sector. Input: IOPT - options: 1 - from BACK to FRONT 'BF'; 2 - from FRONT to BACK 'FB'; PHI1 - 1st phi of sector; PHI2 - 2nd phi of sector. Output: VAL - encoded value. void Spectrum(Int_t nl, Double_t fmin, Double_t fmax, Int_t ic, Int_t idc, Int_t& irep); Set Spectrum. Input: NL - number of levels; FMIN - MIN function value; FMAX - MAX function value; IC - initial color index (for 1st level); IDC - color index increment. Output: IREP - reply: 0 O.K.; -1 error in parameters; F_max less than F_min; illegal number of levels; initial color index is negative; color index increment must be positive. void SurfaceCartesian(Double_t ang, Int_t nx, Int_t ny, const char* chopt); Draw surface in cartesian coordinate system. Input: ANG - angle between X ang Y; NX - number of steps along X; NY - number of steps along Y. FUN(IX,IY,F,T) - external routine; IX - X number of the cell; IY - Y number of the cell; F(3,4) - face which corresponds to the cell; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IX; ICODES(2) - IY; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceFunction(Int_t ia, Int_t ib, Double_t* f, Double_t* t); Service function for Surfaces. void SurfacePolar(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in polar coordinates. Input: IORDR - order of variables (0 - R,PHI, 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - Z; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine f",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:30752,Integrability,rout,routine,30752,"r; PHI2 - 2nd phi of sector. Output: VAL - encoded value. void Spectrum(Int_t nl, Double_t fmin, Double_t fmax, Int_t ic, Int_t idc, Int_t& irep); Set Spectrum. Input: NL - number of levels; FMIN - MIN function value; FMAX - MAX function value; IC - initial color index (for 1st level); IDC - color index increment. Output: IREP - reply: 0 O.K.; -1 error in parameters; F_max less than F_min; illegal number of levels; initial color index is negative; color index increment must be positive. void SurfaceCartesian(Double_t ang, Int_t nx, Int_t ny, const char* chopt); Draw surface in cartesian coordinate system. Input: ANG - angle between X ang Y; NX - number of steps along X; NY - number of steps along Y. FUN(IX,IY,F,T) - external routine; IX - X number of the cell; IY - Y number of the cell; F(3,4) - face which corresponds to the cell; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IX; ICODES(2) - IY; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceFunction(Int_t ia, Int_t ib, Double_t* f, Double_t* t); Service function for Surfaces. void SurfacePolar(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in polar coordinates. Input: IORDR - order of variables (0 - R,PHI, 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - Z; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function.",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:31369,Integrability,rout,routine,31369,"X ang Y; NX - number of steps along X; NY - number of steps along Y. FUN(IX,IY,F,T) - external routine; IX - X number of the cell; IY - Y number of the cell; F(3,4) - face which corresponds to the cell; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IX; ICODES(2) - IY; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceFunction(Int_t ia, Int_t ib, Double_t* f, Double_t* t); Service function for Surfaces. void SurfacePolar(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in polar coordinates. Input: IORDR - order of variables (0 - R,PHI, 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - Z; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI, 1 - PHI,Z); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) -",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:31616,Integrability,rout,routine,31616,"e: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IX; ICODES(2) - IY; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceFunction(Int_t ia, Int_t ib, Double_t* f, Double_t* t); Service function for Surfaces. void SurfacePolar(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in polar coordinates. Input: IORDR - order of variables (0 - R,PHI, 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - Z; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI, 1 - PHI,Z); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:32179,Integrability,rout,routine,32179," of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - Z; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI, 1 - PHI,Z); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void SurfaceSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:32426,Integrability,rout,routine,32426," B; F(3,*) - Z; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI, 1 - PHI,Z); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void SurfaceSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - option",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:33044,Integrability,rout,routine,33044,"g 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void SurfaceSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceProperty(Double_t qqa, Double_t qqd, Double_t qqs, Int_t nnqs, Int_t& irep); Set surface property coefficients. Input: QQA - diffusion coefficient for diffused light [0.,1.]; QQD - diffusion coefficient for direct light [0.,1.]; QQS - diffusion coefficient for reflected light [0.,1.]; NNCS - power coefficient for reflected light (.GE.1). --; Lightness model formula: Y = YD*QA + > YLi*(QD*cosNi+QS*cosRi); --. Output: IREP - reply : 0 - O.K.; -1 - error in cooefficients. void ImplicitFunction(Double_t* rmin, Double_t* rmax, Int_t nx, Int_t ny, Int_t nz",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:33291,Integrability,rout,routine,33291,": temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void SurfaceSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceProperty(Double_t qqa, Double_t qqd, Double_t qqs, Int_t nnqs, Int_t& irep); Set surface property coefficients. Input: QQA - diffusion coefficient for diffused light [0.,1.]; QQD - diffusion coefficient for direct light [0.,1.]; QQS - diffusion coefficient for reflected light [0.,1.]; NNCS - power coefficient for reflected light (.GE.1). --; Lightness model formula: Y = YD*QA + > YLi*(QD*cosNi+QS*cosRi); --. Output: IREP - reply : 0 - O.K.; -1 - error in cooefficients. void ImplicitFunction(Double_t* rmin, Double_t* rmax, Int_t nx, Int_t ny, Int_t nz, const char* chopt); Draw implicit function FUN(X,Y,Z) = 0 in cartesian coordinates using; hidden surface removal algorithm ""Painter"". Input: FUN - external routine FUN(X,Y,Z); RMIN(3) - min scope coordinates; RMAX(3) - max scope coordinat",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:34296,Integrability,rout,routine,34296," ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceProperty(Double_t qqa, Double_t qqd, Double_t qqs, Int_t nnqs, Int_t& irep); Set surface property coefficients. Input: QQA - diffusion coefficient for diffused light [0.,1.]; QQD - diffusion coefficient for direct light [0.,1.]; QQS - diffusion coefficient for reflected light [0.,1.]; NNCS - power coefficient for reflected light (.GE.1). --; Lightness model formula: Y = YD*QA + > YLi*(QD*cosNi+QS*cosRi); --. Output: IREP - reply : 0 - O.K.; -1 - error in cooefficients. void ImplicitFunction(Double_t* rmin, Double_t* rmax, Int_t nx, Int_t ny, Int_t nz, const char* chopt); Draw implicit function FUN(X,Y,Z) = 0 in cartesian coordinates using; hidden surface removal algorithm ""Painter"". Input: FUN - external routine FUN(X,Y,Z); RMIN(3) - min scope coordinates; RMAX(3) - max scope coordinates; NX - number of steps along X; NY - number of steps along Y; NZ - number of steps along Z. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - 1; ICODES(2) - 1; ICODES(3) - 1; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function (lightness). CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void MarchingCube(Double_t fiso, Double_t[8][3] p, Double_t[8] f, Double_t[8][3] g, Int_t& nnod, Int_t& ntria, Double_t[][3] xyz, Double_t[][3] grad, Int_t[][3] itria); Topological decider for ""Marching Cubes"" algorithm Find set of triangles; aproximating the isosurface F(x,y,z)=Fiso inside the cube; (improved version). Input: FISO - function value for isosurface; P(3,8) - cube vertexes; F(8) - function values at the vertexes; G(3,8) - function gradients at the vertexes. Output: NNOD - number of nodes (maximum 13); NTRIA - number of triangles (maximum 12); XYZ(3,*) - nodes; GRAD(3,*) - node",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:34504,Integrability,rout,routine,34504,"rty(Double_t qqa, Double_t qqd, Double_t qqs, Int_t nnqs, Int_t& irep); Set surface property coefficients. Input: QQA - diffusion coefficient for diffused light [0.,1.]; QQD - diffusion coefficient for direct light [0.,1.]; QQS - diffusion coefficient for reflected light [0.,1.]; NNCS - power coefficient for reflected light (.GE.1). --; Lightness model formula: Y = YD*QA + > YLi*(QD*cosNi+QS*cosRi); --. Output: IREP - reply : 0 - O.K.; -1 - error in cooefficients. void ImplicitFunction(Double_t* rmin, Double_t* rmax, Int_t nx, Int_t ny, Int_t nz, const char* chopt); Draw implicit function FUN(X,Y,Z) = 0 in cartesian coordinates using; hidden surface removal algorithm ""Painter"". Input: FUN - external routine FUN(X,Y,Z); RMIN(3) - min scope coordinates; RMAX(3) - max scope coordinates; NX - number of steps along X; NY - number of steps along Y; NZ - number of steps along Z. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - 1; ICODES(2) - 1; ICODES(3) - 1; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function (lightness). CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void MarchingCube(Double_t fiso, Double_t[8][3] p, Double_t[8] f, Double_t[8][3] g, Int_t& nnod, Int_t& ntria, Double_t[][3] xyz, Double_t[][3] grad, Int_t[][3] itria); Topological decider for ""Marching Cubes"" algorithm Find set of triangles; aproximating the isosurface F(x,y,z)=Fiso inside the cube; (improved version). Input: FISO - function value for isosurface; P(3,8) - cube vertexes; F(8) - function values at the vertexes; G(3,8) - function gradients at the vertexes. Output: NNOD - number of nodes (maximum 13); NTRIA - number of triangles (maximum 12); XYZ(3,*) - nodes; GRAD(3,*) - node normales (not normalized); ITRIA(3,*) - triangles. void MarchingCubeCase00(Int_t k1, Int_t k2, Int_t k3, Int_t k4, Int_t k5, Int_t k6, Int_t& nnod, Int_t& ntria, Double_t[52][3] xyz, Double_t[52][3] grad, Int_t[48]",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:39646,Integrability,rout,routine,39646,"pes; ABCD(4,*) - array for face plane equations. Output: IORDER(*) - face order. void TestEdge(Double_t del, Double_t[52][3] xyz, Int_t i1, Int_t i2, Int_t[3] iface, Double_t[4] abcd, Int_t& irep); Test edge against face (triangle). Input: DEL - precision; XYZ(3,*) - nodes; I1 - 1-st node of edge; I2 - 2-nd node of edge; IFACE(3) - triangular face; ABCD(4) - face plane. Output: IREP:-1 - edge under face; 0 - no decision; +1 - edge before face. void IsoSurface(Int_t ns, Double_t* s, Int_t nx, Int_t ny, Int_t nz, Double_t* x, Double_t* y, Double_t* z, const char* chopt); Draw set of isosurfaces for a scalar function defined on a grid. Input: NS - number of isosurfaces; S(*) - isosurface values; NX - number of slices along X; NY - number of slices along Y; NZ - number of slices along Z; X(*) - slices along X; Y(*) - slices along Y; Z(*) - slices along Z; F(NX,NY,NZ) - function values <- Not used, current histo used instead. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(1) - isosurface number; ICODES(2) - isosurface number; ICODES(3) - isosurface number; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function (lightness). CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void DrawFaceGouraudShaded(Int_t* icodes, Double_t[][3] xyz, Int_t np, Int_t* iface, Double_t* t); Draw the faces for the Gouraud Shaded Iso surfaces. TPainter3dAlgorithms(). void SetIsoSurfaceParameters(Double_t fmin, Double_t fmax, Int_t ncolor, Int_t ic1, Int_t ic2, Int_t ic3); {fFmin=fmin; fFmax=fmax; fNcolor=ncolor; fIc1=ic1; fIc2=ic2; fIc3=ic3;}. void SetMesh(Int_t mesh = 1); {fMesh=mesh;}. » Author: Rene Brun, Evgueni Tcherniaev, Olivier Couet 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/histpainter:$Id$ » Last generated: 2015-06-02 16:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:508,Modifiability,adapt,adapted,508,". TPainter3dAlgorithms. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HISTPAINTER; » TPainter3dAlgorithms. class TPainter3dAlgorithms: public TObject, public TAttLine, public TAttFill. Legos and Surfaces package; This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet; and Evgueni Tcherniaev. This class is a subset of the original system. It has been converted to a C++; class by Rene Brun.; . Function Members (Methods); public:. virtual~TPainter3dAlgorithms(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidBackBox(Double_t ang); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearRaster(); virtual TObject*TObject::Clone(const char* newname = """") const; voidColorFunction(Int_t nl, Double_t* fl, Int_t* icl, Int_t& irep); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidDefineGridLevels(Int_t ndivz); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawFaceGouraudShaded(Int_t* icodes, Double_t[][3] xyz, Int_t np, Int_t* iface, Double_t* t); voidDrawFaceMode1(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* t); voidDrawFaceMode2(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* t); voidDrawFace",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:24368,Modifiability,variab,variables,24368,"; Draw stack of lego-plots in cartesian coordinates. Input: ANG - angle between X ang Y; NX - number of cells along X; NY - number of cells along Y. FUN(IX,IY,NV,XY,V,T) - external routine; IX - X number of the cell; IY - Y number of the cell; NV - number of values for given cell; XY(2,4)- coordinates of the cell corners; V(NV) - cell values; T(4,NV)- additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this line; ICODES(1) - IX; ICODES(2) - IY; ICODES(3) - IV; ICODES(4) - side: 1-face,2-right,3-back,4-left,; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; T(4) - additional function (here Z-coordinate). CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoPolar(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in polar coordinates. Input: IORDR - order of variables (0 - R,PHI; 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1-internal,2-right,3-external,4-left; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI; 1 - PHI,Z); NA - number of steps along 1st variable; NPHI - number of steps along 2nd variable. FUN(I",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:24433,Modifiability,variab,variable,24433,"; Draw stack of lego-plots in cartesian coordinates. Input: ANG - angle between X ang Y; NX - number of cells along X; NY - number of cells along Y. FUN(IX,IY,NV,XY,V,T) - external routine; IX - X number of the cell; IY - Y number of the cell; NV - number of values for given cell; XY(2,4)- coordinates of the cell corners; V(NV) - cell values; T(4,NV)- additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this line; ICODES(1) - IX; ICODES(2) - IY; ICODES(3) - IV; ICODES(4) - side: 1-face,2-right,3-back,4-left,; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; T(4) - additional function (here Z-coordinate). CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoPolar(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in polar coordinates. Input: IORDR - order of variables (0 - R,PHI; 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1-internal,2-right,3-external,4-left; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI; 1 - PHI,Z); NA - number of steps along 1st variable; NPHI - number of steps along 2nd variable. FUN(I",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:24474,Modifiability,variab,variable,24474,"; Draw stack of lego-plots in cartesian coordinates. Input: ANG - angle between X ang Y; NX - number of cells along X; NY - number of cells along Y. FUN(IX,IY,NV,XY,V,T) - external routine; IX - X number of the cell; IY - Y number of the cell; NV - number of values for given cell; XY(2,4)- coordinates of the cell corners; V(NV) - cell values; T(4,NV)- additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this line; ICODES(1) - IX; ICODES(2) - IY; ICODES(3) - IV; ICODES(4) - side: 1-face,2-right,3-back,4-left,; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; T(4) - additional function (here Z-coordinate). CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoPolar(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in polar coordinates. Input: IORDR - order of variables (0 - R,PHI; 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1-internal,2-right,3-external,4-left; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI; 1 - PHI,Z); NA - number of steps along 1st variable; NPHI - number of steps along 2nd variable. FUN(I",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:24551,Modifiability,variab,variable,24551," - X number of the cell; IY - Y number of the cell; NV - number of values for given cell; XY(2,4)- coordinates of the cell corners; V(NV) - cell values; T(4,NV)- additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this line; ICODES(1) - IX; ICODES(2) - IY; ICODES(3) - IV; ICODES(4) - side: 1-face,2-right,3-back,4-left,; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; T(4) - additional function (here Z-coordinate). CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoPolar(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in polar coordinates. Input: IORDR - order of variables (0 - R,PHI; 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1-internal,2-right,3-external,4-left; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI; 1 - PHI,Z); NA - number of steps along 1st variable; NPHI - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV)",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:24586,Modifiability,variab,variable,24586," - X number of the cell; IY - Y number of the cell; NV - number of values for given cell; XY(2,4)- coordinates of the cell corners; V(NV) - cell values; T(4,NV)- additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this line; ICODES(1) - IX; ICODES(2) - IY; ICODES(3) - IV; ICODES(4) - side: 1-face,2-right,3-back,4-left,; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; T(4) - additional function (here Z-coordinate). CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoPolar(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in polar coordinates. Input: IORDR - order of variables (0 - R,PHI; 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1-internal,2-right,3-external,4-left; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI; 1 - PHI,Z); NA - number of steps along 1st variable; NPHI - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV)",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:25290,Modifiability,variab,variables,25290,"inates. Input: IORDR - order of variables (0 - R,PHI; 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1-internal,2-right,3-external,4-left; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI; 1 - PHI,Z); NA - number of steps along 1st variable; NPHI - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1,2,3,4 - ordinary sides; 5-bottom,6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of ste",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:25355,Modifiability,variab,variable,25355,"inates. Input: IORDR - order of variables (0 - R,PHI; 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1-internal,2-right,3-external,4-left; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI; 1 - PHI,Z); NA - number of steps along 1st variable; NPHI - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1,2,3,4 - ordinary sides; 5-bottom,6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of ste",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:25398,Modifiability,variab,variable,25398,"inates. Input: IORDR - order of variables (0 - R,PHI; 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1-internal,2-right,3-external,4-left; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI; 1 - PHI,Z); NA - number of steps along 1st variable; NPHI - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1,2,3,4 - ordinary sides; 5-bottom,6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of ste",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:25475,Modifiability,variab,variable,25475,"- cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1-internal,2-right,3-external,4-left; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI; 1 - PHI,Z); NA - number of steps along 1st variable; NPHI - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1,2,3,4 - ordinary sides; 5-bottom,6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:25510,Modifiability,variab,variable,25510,"- cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1-internal,2-right,3-external,4-left; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI; 1 - PHI,Z); NA - number of steps along 1st variable; NPHI - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1,2,3,4 - ordinary sides; 5-bottom,6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:26235,Modifiability,variab,variables,26235,"ut: IORDR - order of variables (0 - Z,PHI; 1 - PHI,Z); NA - number of steps along 1st variable; NPHI - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1,2,3,4 - ordinary sides; 5-bottom,6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1,2,3,4 - ordinary sides; 5-bottom,6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void LightSource(Int_t nl, Double_t yl, Double_t xscr, Double_t yscr, Double_t zscr, Int_t& irep); Set light source. Input: NL - source number: -1 off all light sources; 0 set diffused light; YL - intensity of the light source; XSCR |; YSCR > direction of the light (in respect ",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:26308,Modifiability,variab,variable,26308,"ut: IORDR - order of variables (0 - Z,PHI; 1 - PHI,Z); NA - number of steps along 1st variable; NPHI - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1,2,3,4 - ordinary sides; 5-bottom,6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1,2,3,4 - ordinary sides; 5-bottom,6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void LightSource(Int_t nl, Double_t yl, Double_t xscr, Double_t yscr, Double_t zscr, Int_t& irep); Set light source. Input: NL - source number: -1 off all light sources; 0 set diffused light; YL - intensity of the light source; XSCR |; YSCR > direction of the light (in respect ",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:26349,Modifiability,variab,variable,26349,"ut: IORDR - order of variables (0 - Z,PHI; 1 - PHI,Z); NA - number of steps along 1st variable; NPHI - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1,2,3,4 - ordinary sides; 5-bottom,6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1,2,3,4 - ordinary sides; 5-bottom,6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void LightSource(Int_t nl, Double_t yl, Double_t xscr, Double_t yscr, Double_t zscr, Int_t& irep); Set light source. Input: NL - source number: -1 off all light sources; 0 set diffused light; YL - intensity of the light source; XSCR |; YSCR > direction of the light (in respect ",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:26426,Modifiability,variab,variable,26426,"ble; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1,2,3,4 - ordinary sides; 5-bottom,6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1,2,3,4 - ordinary sides; 5-bottom,6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void LightSource(Int_t nl, Double_t yl, Double_t xscr, Double_t yscr, Double_t zscr, Int_t& irep); Set light source. Input: NL - source number: -1 off all light sources; 0 set diffused light; YL - intensity of the light source; XSCR |; YSCR > direction of the light (in respect of the screen); ZSCR |. Output: IREP - reply : 0 - O.K.; -1 - error in light sources definition:; negative intensity; source number greater than max; light source is placed at origin. void Luminosity(Double_t* an",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:26461,Modifiability,variab,variable,26461,"ble; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1,2,3,4 - ordinary sides; 5-bottom,6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1,2,3,4 - ordinary sides; 5-bottom,6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void LightSource(Int_t nl, Double_t yl, Double_t xscr, Double_t yscr, Double_t zscr, Int_t& irep); Set light source. Input: NL - source number: -1 off all light sources; 0 set diffused light; YL - intensity of the light source; XSCR |; YSCR > direction of the light (in respect of the screen); ZSCR |. Output: IREP - reply : 0 - O.K.; -1 - error in light sources definition:; negative intensity; source number greater than max; light source is placed at origin. void Luminosity(Double_t* an",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:31227,Modifiability,variab,variables,31227,"; color index increment must be positive. void SurfaceCartesian(Double_t ang, Int_t nx, Int_t ny, const char* chopt); Draw surface in cartesian coordinate system. Input: ANG - angle between X ang Y; NX - number of steps along X; NY - number of steps along Y. FUN(IX,IY,F,T) - external routine; IX - X number of the cell; IY - Y number of the cell; F(3,4) - face which corresponds to the cell; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IX; ICODES(2) - IY; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceFunction(Int_t ia, Int_t ib, Double_t* f, Double_t* t); Service function for Surfaces. void SurfacePolar(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in polar coordinates. Input: IORDR - order of variables (0 - R,PHI, 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - Z; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI, 1 - PHI,Z); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face ",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:31292,Modifiability,variab,variable,31292,"; color index increment must be positive. void SurfaceCartesian(Double_t ang, Int_t nx, Int_t ny, const char* chopt); Draw surface in cartesian coordinate system. Input: ANG - angle between X ang Y; NX - number of steps along X; NY - number of steps along Y. FUN(IX,IY,F,T) - external routine; IX - X number of the cell; IY - Y number of the cell; F(3,4) - face which corresponds to the cell; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IX; ICODES(2) - IY; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceFunction(Int_t ia, Int_t ib, Double_t* f, Double_t* t); Service function for Surfaces. void SurfacePolar(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in polar coordinates. Input: IORDR - order of variables (0 - R,PHI, 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - Z; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI, 1 - PHI,Z); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face ",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:31333,Modifiability,variab,variable,31333,"; color index increment must be positive. void SurfaceCartesian(Double_t ang, Int_t nx, Int_t ny, const char* chopt); Draw surface in cartesian coordinate system. Input: ANG - angle between X ang Y; NX - number of steps along X; NY - number of steps along Y. FUN(IX,IY,F,T) - external routine; IX - X number of the cell; IY - Y number of the cell; F(3,4) - face which corresponds to the cell; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IX; ICODES(2) - IY; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceFunction(Int_t ia, Int_t ib, Double_t* f, Double_t* t); Service function for Surfaces. void SurfacePolar(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in polar coordinates. Input: IORDR - order of variables (0 - R,PHI, 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - Z; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI, 1 - PHI,Z); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face ",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:31403,Modifiability,variab,variable,31403,"X ang Y; NX - number of steps along X; NY - number of steps along Y. FUN(IX,IY,F,T) - external routine; IX - X number of the cell; IY - Y number of the cell; F(3,4) - face which corresponds to the cell; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IX; ICODES(2) - IY; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceFunction(Int_t ia, Int_t ib, Double_t* f, Double_t* t); Service function for Surfaces. void SurfacePolar(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in polar coordinates. Input: IORDR - order of variables (0 - R,PHI, 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - Z; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI, 1 - PHI,Z); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) -",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:31438,Modifiability,variab,variable,31438,"X ang Y; NX - number of steps along X; NY - number of steps along Y. FUN(IX,IY,F,T) - external routine; IX - X number of the cell; IY - Y number of the cell; F(3,4) - face which corresponds to the cell; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IX; ICODES(2) - IY; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceFunction(Int_t ia, Int_t ib, Double_t* f, Double_t* t); Service function for Surfaces. void SurfacePolar(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in polar coordinates. Input: IORDR - order of variables (0 - R,PHI, 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - Z; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI, 1 - PHI,Z); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) -",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:32037,Modifiability,variab,variables,32037," for Surfaces. void SurfacePolar(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in polar coordinates. Input: IORDR - order of variables (0 - R,PHI, 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - Z; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI, 1 - PHI,Z); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void SurfaceSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st vari",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:32102,Modifiability,variab,variable,32102," for Surfaces. void SurfacePolar(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in polar coordinates. Input: IORDR - order of variables (0 - R,PHI, 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - Z; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI, 1 - PHI,Z); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void SurfaceSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st vari",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:32143,Modifiability,variab,variable,32143," for Surfaces. void SurfacePolar(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in polar coordinates. Input: IORDR - order of variables (0 - R,PHI, 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - Z; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI, 1 - PHI,Z); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void SurfaceSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st vari",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:32213,Modifiability,variab,variable,32213," of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - Z; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI, 1 - PHI,Z); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void SurfaceSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:32248,Modifiability,variab,variable,32248," of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - Z; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI, 1 - PHI,Z); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void SurfaceSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:32894,Modifiability,variab,variables,32894,"dr, Int_t na, Int_t nb, const char* chopt); Draw surface in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI, 1 - PHI,Z); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void SurfaceSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceProperty(Double_t qqa, Double_t qqd, Double_t qqs, Int_t nnqs, Int_t& irep); Set surface property coefficients. Input: QQA - diffusion coefficient for diffused light [0.,1.]; QQD - diffusion coefficient for direct light [0.,1.]; QQS - diffusion coefficient for reflected light [0.,1.]; NNCS - power coefficient for reflected light (.GE.1). --; Li",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:32967,Modifiability,variab,variable,32967,"dr, Int_t na, Int_t nb, const char* chopt); Draw surface in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI, 1 - PHI,Z); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void SurfaceSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceProperty(Double_t qqa, Double_t qqd, Double_t qqs, Int_t nnqs, Int_t& irep); Set surface property coefficients. Input: QQA - diffusion coefficient for diffused light [0.,1.]; QQD - diffusion coefficient for direct light [0.,1.]; QQS - diffusion coefficient for reflected light [0.,1.]; NNCS - power coefficient for reflected light (.GE.1). --; Li",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:33008,Modifiability,variab,variable,33008,"dr, Int_t na, Int_t nb, const char* chopt); Draw surface in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI, 1 - PHI,Z); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void SurfaceSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceProperty(Double_t qqa, Double_t qqd, Double_t qqs, Int_t nnqs, Int_t& irep); Set surface property coefficients. Input: QQA - diffusion coefficient for diffused light [0.,1.]; QQD - diffusion coefficient for direct light [0.,1.]; QQS - diffusion coefficient for reflected light [0.,1.]; NNCS - power coefficient for reflected light (.GE.1). --; Li",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:33078,Modifiability,variab,variable,33078,"g 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void SurfaceSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceProperty(Double_t qqa, Double_t qqd, Double_t qqs, Int_t nnqs, Int_t& irep); Set surface property coefficients. Input: QQA - diffusion coefficient for diffused light [0.,1.]; QQD - diffusion coefficient for direct light [0.,1.]; QQS - diffusion coefficient for reflected light [0.,1.]; NNCS - power coefficient for reflected light (.GE.1). --; Lightness model formula: Y = YD*QA + > YLi*(QD*cosNi+QS*cosRi); --. Output: IREP - reply : 0 - O.K.; -1 - error in cooefficients. void ImplicitFunction(Double_t* rmin, Double_t* rmax, Int_t nx, Int_t ny, Int_t nz",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPainter3dAlgorithms.html:33113,Modifiability,variab,variable,33113,"g 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void SurfaceSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceProperty(Double_t qqa, Double_t qqd, Double_t qqs, Int_t nnqs, Int_t& irep); Set surface property coefficients. Input: QQA - diffusion coefficient for diffused light [0.,1.]; QQD - diffusion coefficient for direct light [0.,1.]; QQS - diffusion coefficient for reflected light [0.,1.]; NNCS - power coefficient for reflected light (.GE.1). --; Lightness model formula: Y = YD*QA + > YLi*(QD*cosNi+QS*cosRi); --. Output: IREP - reply : 0 - O.K.; -1 - error in cooefficients. void ImplicitFunction(Double_t* rmin, Double_t* rmax, Int_t nx, Int_t ny, Int_t nz",MatchSource.WIKI,root/html604/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPainter3dAlgorithms.html
https://root.cern/root/html604/TPair.html:1601,Availability,error,error,1601," virtual~TPair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOptio",MatchSource.WIKI,root/html604/TPair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPair.html
https://root.cern/root/html604/TPair.html:1685,Availability,error,error,1685,"~TPair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tHash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voi",MatchSource.WIKI,root/html604/TPair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPair.html
https://root.cern/root/html604/TPair.html:364,Energy Efficiency,efficient,efficient,364,". TPair. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TPair. class TPair: public TObject. TMap. TMap implements an associative array of (key,value) pairs using a; THashTable for efficient retrieval (therefore TMap does not conserve; the order of the entries). The hash value is calculated; using the value returned by the keys Hash() function and the; key comparison is done via the IsEqual() function.; Both key and value must inherit from TObject. /*. */. Function Members (Methods); public:. virtual~TPair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOptio",MatchSource.WIKI,root/html604/TPair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPair.html
https://root.cern/root/html604/TPair.html:614,Modifiability,inherit,inherit,614,". TPair. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TPair. class TPair: public TObject. TMap. TMap implements an associative array of (key,value) pairs using a; THashTable for efficient retrieval (therefore TMap does not conserve; the order of the entries). The hash value is calculated; using the value returned by the keys Hash() function and the; key comparison is done via the IsEqual() function.; Both key and value must inherit from TObject. /*. */. Function Members (Methods); public:. virtual~TPair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOptio",MatchSource.WIKI,root/html604/TPair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPair.html
https://root.cern/root/html604/TPair.html:450,Security,hash,hash,450,". TPair. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TPair. class TPair: public TObject. TMap. TMap implements an associative array of (key,value) pairs using a; THashTable for efficient retrieval (therefore TMap does not conserve; the order of the entries). The hash value is calculated; using the value returned by the keys Hash() function and the; key comparison is done via the IsEqual() function.; Both key and value must inherit from TObject. /*. */. Function Members (Methods); public:. virtual~TPair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOptio",MatchSource.WIKI,root/html604/TPair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPair.html
https://root.cern/root/html604/TPaletteAxis.html:3046,Availability,error,error,3046,"Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPave::ConvertNDCtoPad(); virtual voidCopy(TObject& palette) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTPave::Draw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGaxis*GetAxis(); virtual Rectangle_tTBox::GetBBox(); virtual TPointTBox::GetBBoxCenter(); Int_tGetBinColor(Int_t i, Int_t j); Int_tTPave::GetBorderSize() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Option_t*GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t p",MatchSource.WIKI,root/html604/TPaletteAxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaletteAxis.html
https://root.cern/root/html604/TPaletteAxis.html:3130,Availability,error,error,3130,"tual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPave::ConvertNDCtoPad(); virtual voidCopy(TObject& palette) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTPave::Draw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGaxis*GetAxis(); virtual Rectangle_tTBox::GetBBox(); virtual TPointTBox::GetBBoxCenter(); Int_tGetBinColor(Int_t i, Int_t j); Int_tTPave::GetBorderSize() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Option_t*GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TPave::GetOption()",MatchSource.WIKI,root/html604/TPaletteAxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaletteAxis.html
https://root.cern/root/html604/TPaletteAxis.html:1435,Modifiability,inherit,inherits,1435,"is is automatically created drawn when drawing a 2-D; histogram when the option ""Z"" is specified. A TPaletteAxis object is added to the histogram list of functions and; can be retrieved doing:. TPaletteAxis *palette = (TPaletteAxis*)h->GetListOfFunctions()->FindObject(""palette"");. then the pointer palette can be used to change the pallette attributes. Because the palette is created at painting time only, one must issue a:. gPad->Update();. before retrieving the palette pointer in order to create the palette. The following; macro gives an example. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *h2 = new TH2F(""h2"",""Example of a resized palette "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; h2->Fill(px,5*py);; }; gStyle->SetPalette(1);; h2->Draw(""COLZ"");; gPad->Update();; TPaletteAxis *palette = (TPaletteAxis*)h2->GetListOfFunctions()->FindObject(""palette"");; palette->SetY2NDC(0.7);; return c1;; }; TPaletteAxis inherits from TBox and TPave. The methods; allowing to specify the palette position are inherited from these two classes. The palette can be interactively moved and resized. The context menu; can be used to set the axis attributes. It is possible to select a range on the axis to set the min/max in z; . Function Members (Methods); public:. virtual~TPaletteAxis(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPave::ConvertNDCtoPad(); virtual voidCopy(TObject& palette) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); vi",MatchSource.WIKI,root/html604/TPaletteAxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaletteAxis.html
https://root.cern/root/html604/TPaletteAxis.html:1523,Modifiability,inherit,inherited,1523,"on ""Z"" is specified. A TPaletteAxis object is added to the histogram list of functions and; can be retrieved doing:. TPaletteAxis *palette = (TPaletteAxis*)h->GetListOfFunctions()->FindObject(""palette"");. then the pointer palette can be used to change the pallette attributes. Because the palette is created at painting time only, one must issue a:. gPad->Update();. before retrieving the palette pointer in order to create the palette. The following; macro gives an example. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *h2 = new TH2F(""h2"",""Example of a resized palette "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; h2->Fill(px,5*py);; }; gStyle->SetPalette(1);; h2->Draw(""COLZ"");; gPad->Update();; TPaletteAxis *palette = (TPaletteAxis*)h2->GetListOfFunctions()->FindObject(""palette"");; palette->SetY2NDC(0.7);; return c1;; }; TPaletteAxis inherits from TBox and TPave. The methods; allowing to specify the palette position are inherited from these two classes. The palette can be interactively moved and resized. The context menu; can be used to set the axis attributes. It is possible to select a range on the axis to set the min/max in z; . Function Members (Methods); public:. virtual~TPaletteAxis(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPave::ConvertNDCtoPad(); virtual voidCopy(TObject& palette) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTPave::Draw(O",MatchSource.WIKI,root/html604/TPaletteAxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaletteAxis.html
https://root.cern/root/html604/TPaletteEditor.html:1401,Energy Efficiency,allocate,allocated,1401,"rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolors, Int_t *colors); if ncolors <= 0 a default palette (see below) of 50 colors; is defined. if ncolors == 1 && colors == 0, then; a Pretty Palette with a Spectrum Violet->Red is created. if ncolors > 50 and colors=0, the DeepSea palette is used.; (see TStyle::CreateGradientColorTable for more details). if ncolors > 0 and colors = 0, the default palette is used; with a maximum of ncolors. The default palette defines:; index 0->9 : ",MatchSource.WIKI,root/html604/TPaletteEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaletteEditor.html
https://root.cern/root/html604/TPaletteEditor.html:1754,Energy Efficiency,monitor,monitors,1754,"he size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolors, Int_t *colors); if ncolors <= 0 a default palette (see below) of 50 colors; is defined. if ncolors == 1 && colors == 0, then; a Pretty Palette with a Spectrum Violet->Red is created. if ncolors > 50 and colors=0, the DeepSea palette is used.; (see TStyle::CreateGradientColorTable for more details). if ncolors > 0 and colors = 0, the default palette is used; with a maximum of ncolors. The default palette defines:; index 0->9 : grey colors from light to dark grey; index 10->19 : ""brown"" colors; index 20->29 : ""blueish"" colors; index 30->39 : ""redish"" colors; index 40->49 : basic colors. TPaletteEditor. This class provides a way to edit the palette via a GUI. Function Members (Methods); public:. virtual~TPaletteEditor(); static TClass*Class(); virtual v",MatchSource.WIKI,root/html604/TPaletteEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaletteEditor.html
https://root.cern/root/html604/TPaletteEditor.html:1810,Energy Efficiency,monitor,monitors,1810,"he size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolors, Int_t *colors); if ncolors <= 0 a default palette (see below) of 50 colors; is defined. if ncolors == 1 && colors == 0, then; a Pretty Palette with a Spectrum Violet->Red is created. if ncolors > 50 and colors=0, the DeepSea palette is used.; (see TStyle::CreateGradientColorTable for more details). if ncolors > 0 and colors = 0, the default palette is used; with a maximum of ncolors. The default palette defines:; index 0->9 : grey colors from light to dark grey; index 10->19 : ""brown"" colors; index 20->29 : ""blueish"" colors; index 30->39 : ""redish"" colors; index 40->49 : basic colors. TPaletteEditor. This class provides a way to edit the palette via a GUI. Function Members (Methods); public:. virtual~TPaletteEditor(); static TClass*Class(); virtual v",MatchSource.WIKI,root/html604/TPaletteEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaletteEditor.html
https://root.cern/root/html604/TPaletteEditor.html:494,Integrability,depend,depends,494,". TPaletteEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TPaletteEditor. class TPaletteEditor. TAttImage. Image attributes are:; Image Quality (see EImageQuality for the list of qualities); Compression defines the compression rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolors, Int_t *col",MatchSource.WIKI,root/html604/TPaletteEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaletteEditor.html
https://root.cern/root/html604/TPaletteEditor.html:738,Integrability,depend,depends,738,". TPaletteEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TPaletteEditor. class TPaletteEditor. TAttImage. Image attributes are:; Image Quality (see EImageQuality for the list of qualities); Compression defines the compression rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolors, Int_t *col",MatchSource.WIKI,root/html604/TPaletteEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaletteEditor.html
https://root.cern/root/html604/TPaletteEditor.html:888,Modifiability,inherit,inheritance,888,". TPaletteEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TPaletteEditor. class TPaletteEditor. TAttImage. Image attributes are:; Image Quality (see EImageQuality for the list of qualities); Compression defines the compression rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolors, Int_t *col",MatchSource.WIKI,root/html604/TPaletteEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaletteEditor.html
https://root.cern/root/html604/TPaletteEditor.html:1228,Modifiability,variab,variables,1228," » TPaletteEditor. class TPaletteEditor. TAttImage. Image attributes are:; Image Quality (see EImageQuality for the list of qualities); Compression defines the compression rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolors, Int_t *colors); if ncolors <= 0 a default palette (see below) of 50 colors; is defined. if ncolors == 1 && colors == 0, then; a Pretty Palette with a Spectrum Violet->Red is created. if ncolors > 50 and colors=0, the DeepSea palette is used.; (see TStyle::C",MatchSource.WIKI,root/html604/TPaletteEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaletteEditor.html
https://root.cern/root/html604/TPARA.html:1847,Availability,error,error,1847,"ethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBRIK::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetAlpha() const; virtual const TBuffer3D&TBRIK::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tTBRIK::GetDx() const; Float_tTBRIK::GetDy() const; Float_tTBRIK::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() con",MatchSource.WIKI,root/html604/TPARA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPARA.html
https://root.cern/root/html604/TPARA.html:1931,Availability,error,error,1931,"""); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBRIK::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetAlpha() const; virtual const TBuffer3D&TBRIK::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tTBRIK::GetDx() const; Float_tTBRIK::GetDy() const; Float_tTBRIK::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTShape::GetNumber() con",MatchSource.WIKI,root/html604/TPARA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPARA.html
https://root.cern/root/html604/TParallelCoord.html:1277,Availability,avail,available,1277,". class TParallelCoord: public TNamed. Parallel Coordinates class. The multidimensional system of Parallel coordinates is a common way of studying high-dimensional geometry and visualizing multivariate problems. It has first been proposed by A. Inselberg in 1981. To show a set of points in an n-dimensional space, a backdrop is drawn consisting of n parallel lines. A point in n-dimensional space is represented as a polyline with vertices on the parallel axes; the position of the vertex on the i-th axis corresponds to the i-th coordinate of the point. This tool comes with a rather large gui in the editor. It is necessary to use this editor in order to explore a data set, as explained below.; Reduce cluttering:. The main issue for parallel coordinates is the very high cluttering of the output when dealing with large data set. Two techniques have been implemented to bypass that so far:. Draw doted lines instead of plain lines with an adjustable dots spacing. A slider to adjust the dots spacing is available in the editor.; Sort the entries to display with a ""weight cut"". On each axis is drawn a histogram describing the distribution of the data on the corresponding variable. The ""weight"" of an entry is the sum of the bin content of each bin the entry is going through. An entry going through the histograms peaks will have a big weight wether an entry going randomly through the histograms will have a rather small weight. Setting a cut on this weight allows to draw only the most representative entries. A slider set the cut is also available in the gui. Selections:. Selections of specific entries can be defined over the data se using parallel coordinates. With that representation, a selection is an ensemble of ranges defined on the axes. Ranges defined on the same axis are conjugated with OR (an entry must be in one or the other ranges to be selected). Ranges on different axes are are conjugated with AND (an entry must be in all the ranges to be selected). Several selections ",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:1817,Availability,avail,available,1817,"f the point. This tool comes with a rather large gui in the editor. It is necessary to use this editor in order to explore a data set, as explained below.; Reduce cluttering:. The main issue for parallel coordinates is the very high cluttering of the output when dealing with large data set. Two techniques have been implemented to bypass that so far:. Draw doted lines instead of plain lines with an adjustable dots spacing. A slider to adjust the dots spacing is available in the editor.; Sort the entries to display with a ""weight cut"". On each axis is drawn a histogram describing the distribution of the data on the corresponding variable. The ""weight"" of an entry is the sum of the bin content of each bin the entry is going through. An entry going through the histograms peaks will have a big weight wether an entry going randomly through the histograms will have a rather small weight. Setting a cut on this weight allows to draw only the most representative entries. A slider set the cut is also available in the gui. Selections:. Selections of specific entries can be defined over the data se using parallel coordinates. With that representation, a selection is an ensemble of ranges defined on the axes. Ranges defined on the same axis are conjugated with OR (an entry must be in one or the other ranges to be selected). Ranges on different axes are are conjugated with AND (an entry must be in all the ranges to be selected). Several selections can be defined with different colors. It is possible to generate an entry list from a given selection and apply it to the tree using the editor (""Apply to tree"" button).; Axes:. Options can be defined each axis separatly using the right mouse click. These options can be applied to every axes using the editor. Axis width: If set to 0, the axis is simply a line. If higher, a color histogram is drawn on the axis.; Axis histogram height: If not 0, a usual bar histogram is drawn on the plot. The order in which the variables are drawn is essent",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:2903,Availability,avail,available,2903,"er the data se using parallel coordinates. With that representation, a selection is an ensemble of ranges defined on the axes. Ranges defined on the same axis are conjugated with OR (an entry must be in one or the other ranges to be selected). Ranges on different axes are are conjugated with AND (an entry must be in all the ranges to be selected). Several selections can be defined with different colors. It is possible to generate an entry list from a given selection and apply it to the tree using the editor (""Apply to tree"" button).; Axes:. Options can be defined each axis separatly using the right mouse click. These options can be applied to every axes using the editor. Axis width: If set to 0, the axis is simply a line. If higher, a color histogram is drawn on the axis.; Axis histogram height: If not 0, a usual bar histogram is drawn on the plot. The order in which the variables are drawn is essential to see the clusters. The axes can be dragged to change their position. A zoom is also available. The logarithm scale is also available by right clicking on the axis.; Candle chart:. TParallelCoord can also be used to display a candle chart. In that mode, every variable is drawn in the same scale. The candle chart can be combined with the parallel coordinates mode, drawing the candle sticks over the axes. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = TFile::Open(""cernstaff.root"");; TTree *T = (TTree*)f->Get(""T"");; T->Draw(""Age:Grade:Step:Cost:Division:Nation"","""",""para"");; TParallelCoord* para = (TParallelCoord*)gPad->GetListOfPrimitives()->FindObject(""ParaCoord"");; TParallelCoordVar* grade = (TParallelCoordVar*)para->GetVarList()->FindObject(""Grade"");; grade->AddRange(new TParallelCoordRange(grade,11.5,14));; para->AddSelection(""less30"");; para->GetCurrentSelection()->SetLineColor(kViolet);; TParallelCoordVar* age = (TParallelCoordVar*)para->GetVarList()->FindObject(""Age"");; age->AddRange(new TParallelCoordRange(age,21,30));; return c1;; }; Some ref",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:2942,Availability,avail,available,2942," that representation, a selection is an ensemble of ranges defined on the axes. Ranges defined on the same axis are conjugated with OR (an entry must be in one or the other ranges to be selected). Ranges on different axes are are conjugated with AND (an entry must be in all the ranges to be selected). Several selections can be defined with different colors. It is possible to generate an entry list from a given selection and apply it to the tree using the editor (""Apply to tree"" button).; Axes:. Options can be defined each axis separatly using the right mouse click. These options can be applied to every axes using the editor. Axis width: If set to 0, the axis is simply a line. If higher, a color histogram is drawn on the axis.; Axis histogram height: If not 0, a usual bar histogram is drawn on the plot. The order in which the variables are drawn is essential to see the clusters. The axes can be dragged to change their position. A zoom is also available. The logarithm scale is also available by right clicking on the axis.; Candle chart:. TParallelCoord can also be used to display a candle chart. In that mode, every variable is drawn in the same scale. The candle chart can be combined with the parallel coordinates mode, drawing the candle sticks over the axes. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = TFile::Open(""cernstaff.root"");; TTree *T = (TTree*)f->Get(""T"");; T->Draw(""Age:Grade:Step:Cost:Division:Nation"","""",""para"");; TParallelCoord* para = (TParallelCoord*)gPad->GetListOfPrimitives()->FindObject(""ParaCoord"");; TParallelCoordVar* grade = (TParallelCoordVar*)para->GetVarList()->FindObject(""Grade"");; grade->AddRange(new TParallelCoordRange(grade,11.5,14));; para->AddSelection(""less30"");; para->GetCurrentSelection()->SetLineColor(kViolet);; TParallelCoordVar* age = (TParallelCoordVar*)para->GetVarList()->FindObject(""Age"");; age->AddRange(new TParallelCoordRange(age,21,30));; return c1;; }; Some references:. Alfred Inselberg's Homepage , with Vis",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:5591,Availability,error,error,5591,"= """"); voidApplySelectionToTree()MENU ; virtual voidTObject::Browse(TBrowser* b); static voidBuildParallelCoord(TSelectorDraw* selector, Bool_t candle); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanUpSelections(TParallelCoordRange* range); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteSelection(TParallelCoordSelect* sel); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* options = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t entry, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetCandleChart(); Long64_tGetCurrentFirst(); Long64_tGetCurrentN(); TParallelCoordSelect*GetCurrentSelection(); Bool_tGetCurveDisplay() const; Int_tGetDotsSpacing() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TEntryList*GetEntryList(Bool_t sel = kTRUE); Bool_tGetGlobalLogScale(); Double_tGetGlobalMax(); Double_tGetGlobalMin(); Bool_tGetGlobalScale(); virtual const char*TObject::GetIconName() const; Color_tGetLineColor(); Width_tGetLineWidth(); virtual const char*TNamed::GetName() const; Int_tGetNbins(); Long64_tGetNentries(); UInt_tGetNvar();",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:5675,Availability,error,error,5675,"atic voidBuildParallelCoord(TSelectorDraw* selector, Bool_t candle); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanUpSelections(TParallelCoordRange* range); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteSelection(TParallelCoordSelect* sel); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* options = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t entry, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetCandleChart(); Long64_tGetCurrentFirst(); Long64_tGetCurrentN(); TParallelCoordSelect*GetCurrentSelection(); Bool_tGetCurveDisplay() const; Int_tGetDotsSpacing() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TEntryList*GetEntryList(Bool_t sel = kTRUE); Bool_tGetGlobalLogScale(); Double_tGetGlobalMax(); Double_tGetGlobalMin(); Bool_tGetGlobalScale(); virtual const char*TObject::GetIconName() const; Color_tGetLineColor(); Width_tGetLineWidth(); virtual const char*TNamed::GetName() const; Int_tGetNbins(); Long64_tGetNentries(); UInt_tGetNvar(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:17762,Deployability,update,updated,17762,"xes in log scale. void SetGlobalScale(Bool_t gl); Constraint all axes to the same scale. void SetAxisHistogramLineWidth(Int_t lw = 2); Set the same histogram axis line width for all axis. void SetCandleChart(Bool_t can); Set a candle chart display. void SetCurrentFirst(Long64_t ); Set the first entry to be dispayed. void SetCurrentN(Long64_t ); Set the number of entry to be displayed. TParallelCoordSelect* SetCurrentSelection(const char* title); Set the selection beeing edited. void SetCurrentSelection(TParallelCoordSelect* sel); Set the selection beeing edited. void SetDotsSpacing(Int_t s = 0); Set dots spacing. Modify the line style 11.; If the canvas support transparency dot spacing is ignored. void SetEntryList(TParallelCoord* para, TEntryList* enlist); Set the entry lists of ""para"". void SetGlobalMax(Double_t max); Force all variables to adopt the same max. void SetGlobalMin(Double_t min); Force all variables to adopt the same min. void SetLiveRangesUpdate(Bool_t ); If true, the pad is updated while the motion of a dragged range. void SetVertDisplay(Bool_t vert = kTRUE); Set the vertical or horizontal display. void UnzoomAll(); Unzoom all variables. TParallelCoord(). Bool_t GetCandleChart(); {return TestBit(kCandleChart);}. Long64_t GetCurrentFirst(); {return fCurrentFirst;}. Long64_t GetCurrentN(); {return fCurrentN;}. Bool_t GetCurveDisplay() const; {return TestBit(kCurveDisplay);}. Int_t GetDotsSpacing() const; {return fDotsSpacing;}. Bool_t GetGlobalScale(); {return TestBit(kGlobalScale);}. Bool_t GetGlobalLogScale(); {return TestBit(kGlobalLogScale);}. Color_t GetLineColor(); {return fLineColor;}. Width_t GetLineWidth(); {return fLineWidth;}. UInt_t GetNvar(); {return fNvar;}. Long64_t GetNentries(); {return fNentries;}. TList * GetSelectList(); {return fSelectList;}. TList * GetVarList(); {return fVarList;}. Bool_t GetVertDisplay() const; {return TestBit(kVertDisplay);}. Int_t GetWeightCut() const; {return fWeightCut;}. void SetCurveDisplay(Bool_t curve =",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:1447,Modifiability,variab,variable,1447," of studying high-dimensional geometry and visualizing multivariate problems. It has first been proposed by A. Inselberg in 1981. To show a set of points in an n-dimensional space, a backdrop is drawn consisting of n parallel lines. A point in n-dimensional space is represented as a polyline with vertices on the parallel axes; the position of the vertex on the i-th axis corresponds to the i-th coordinate of the point. This tool comes with a rather large gui in the editor. It is necessary to use this editor in order to explore a data set, as explained below.; Reduce cluttering:. The main issue for parallel coordinates is the very high cluttering of the output when dealing with large data set. Two techniques have been implemented to bypass that so far:. Draw doted lines instead of plain lines with an adjustable dots spacing. A slider to adjust the dots spacing is available in the editor.; Sort the entries to display with a ""weight cut"". On each axis is drawn a histogram describing the distribution of the data on the corresponding variable. The ""weight"" of an entry is the sum of the bin content of each bin the entry is going through. An entry going through the histograms peaks will have a big weight wether an entry going randomly through the histograms will have a rather small weight. Setting a cut on this weight allows to draw only the most representative entries. A slider set the cut is also available in the gui. Selections:. Selections of specific entries can be defined over the data se using parallel coordinates. With that representation, a selection is an ensemble of ranges defined on the axes. Ranges defined on the same axis are conjugated with OR (an entry must be in one or the other ranges to be selected). Ranges on different axes are are conjugated with AND (an entry must be in all the ranges to be selected). Several selections can be defined with different colors. It is possible to generate an entry list from a given selection and apply it to the tree using th",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:2784,Modifiability,variab,variables,2784,"et the cut is also available in the gui. Selections:. Selections of specific entries can be defined over the data se using parallel coordinates. With that representation, a selection is an ensemble of ranges defined on the axes. Ranges defined on the same axis are conjugated with OR (an entry must be in one or the other ranges to be selected). Ranges on different axes are are conjugated with AND (an entry must be in all the ranges to be selected). Several selections can be defined with different colors. It is possible to generate an entry list from a given selection and apply it to the tree using the editor (""Apply to tree"" button).; Axes:. Options can be defined each axis separatly using the right mouse click. These options can be applied to every axes using the editor. Axis width: If set to 0, the axis is simply a line. If higher, a color histogram is drawn on the axis.; Axis histogram height: If not 0, a usual bar histogram is drawn on the plot. The order in which the variables are drawn is essential to see the clusters. The axes can be dragged to change their position. A zoom is also available. The logarithm scale is also available by right clicking on the axis.; Candle chart:. TParallelCoord can also be used to display a candle chart. In that mode, every variable is drawn in the same scale. The candle chart can be combined with the parallel coordinates mode, drawing the candle sticks over the axes. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = TFile::Open(""cernstaff.root"");; TTree *T = (TTree*)f->Get(""T"");; T->Draw(""Age:Grade:Step:Cost:Division:Nation"","""",""para"");; TParallelCoord* para = (TParallelCoord*)gPad->GetListOfPrimitives()->FindObject(""ParaCoord"");; TParallelCoordVar* grade = (TParallelCoordVar*)para->GetVarList()->FindObject(""Grade"");; grade->AddRange(new TParallelCoordRange(grade,11.5,14));; para->AddSelection(""less30"");; para->GetCurrentSelection()->SetLineColor(kViolet);; TParallelCoordVar* age = (TParallelCoordVar*)para->GetVarLi",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:3078,Modifiability,variab,variable,3078," entry must be in one or the other ranges to be selected). Ranges on different axes are are conjugated with AND (an entry must be in all the ranges to be selected). Several selections can be defined with different colors. It is possible to generate an entry list from a given selection and apply it to the tree using the editor (""Apply to tree"" button).; Axes:. Options can be defined each axis separatly using the right mouse click. These options can be applied to every axes using the editor. Axis width: If set to 0, the axis is simply a line. If higher, a color histogram is drawn on the axis.; Axis histogram height: If not 0, a usual bar histogram is drawn on the plot. The order in which the variables are drawn is essential to see the clusters. The axes can be dragged to change their position. A zoom is also available. The logarithm scale is also available by right clicking on the axis.; Candle chart:. TParallelCoord can also be used to display a candle chart. In that mode, every variable is drawn in the same scale. The candle chart can be combined with the parallel coordinates mode, drawing the candle sticks over the axes. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = TFile::Open(""cernstaff.root"");; TTree *T = (TTree*)f->Get(""T"");; T->Draw(""Age:Grade:Step:Cost:Division:Nation"","""",""para"");; TParallelCoord* para = (TParallelCoord*)gPad->GetListOfPrimitives()->FindObject(""ParaCoord"");; TParallelCoordVar* grade = (TParallelCoordVar*)para->GetVarList()->FindObject(""Grade"");; grade->AddRange(new TParallelCoordRange(grade,11.5,14));; para->AddSelection(""less30"");; para->GetCurrentSelection()->SetLineColor(kViolet);; TParallelCoordVar* age = (TParallelCoordVar*)para->GetVarList()->FindObject(""Age"");; age->AddRange(new TParallelCoordRange(age,21,30));; return c1;; }; Some references:. Alfred Inselberg's Homepage , with Visual Tutorial, History, Selected Publications and Applications.; A small, easy introduction by Christopher V. Jones. ; Almir Olivette Arter",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:13273,Modifiability,variab,variables,13273,"kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TParallelCoord::(anonymous)kPaintEntries; static TObject::(anonymous)TObject::kSingleKey; static TParallelCoord::(anonymous)kVertDisplay; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TGaxis*fCandleAxis! An axis used when displaying a candle chart.; TEntryList*fCurrentEntries-> Current selected entries in the tree.; Long64_tfCurrentFirstFirst entry to display.; Long64_tfCurrentNNumber of entries to display.; TParallelCoordSelect*fCurrentSelection! Current Selection being edited.; Int_tfDotsSpacingSpacing between dots to draw the entries.; TEntryList*fInitEntries-> Selected entries when TParallelCoord first initialized.; Color_tfLineColorentries line color.; Width_tfLineWidthentries line width.; Long64_tfNentriesNumber of entries;; UInt_tfNvarNumber of variables.; TList*fSelectListList of selections over the variables.; TTree*fTree! Pointer to the TTree.; TStringfTreeFileNameName of the file containing the tree.; TStringfTreeNameName of the tree.; TList*fVarListList of the variables.; Int_tfWeightCutSpecify a cut on the entries from their weight (see TParallelCoordVar::GetEvtWeight(Long64_t)). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParallelCoord(); Default constructor. TParallelCoord(Long64_t nentries); Constructor without a reference to a tree,; the datas must be added afterwards with; TParallelCoord::AddVariable(Double_t*,const char*). TParallelCoord(TTree* tree, Long64_t nentries); Normal constructor, the datas must be added afterwards; with TParallelCoord::AddVariable(Double_t*,const char*). ~TParallelCoord(); Destructor. void AddVariable(Double_t* val, const char* title = """"); Add a variable. void AddVariable(const char* varexp); Add a variable from an",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:13330,Modifiability,variab,variables,13330,"static TObject::(anonymous)TObject::kOverwrite; static TParallelCoord::(anonymous)kPaintEntries; static TObject::(anonymous)TObject::kSingleKey; static TParallelCoord::(anonymous)kVertDisplay; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TGaxis*fCandleAxis! An axis used when displaying a candle chart.; TEntryList*fCurrentEntries-> Current selected entries in the tree.; Long64_tfCurrentFirstFirst entry to display.; Long64_tfCurrentNNumber of entries to display.; TParallelCoordSelect*fCurrentSelection! Current Selection being edited.; Int_tfDotsSpacingSpacing between dots to draw the entries.; TEntryList*fInitEntries-> Selected entries when TParallelCoord first initialized.; Color_tfLineColorentries line color.; Width_tfLineWidthentries line width.; Long64_tfNentriesNumber of entries;; UInt_tfNvarNumber of variables.; TList*fSelectListList of selections over the variables.; TTree*fTree! Pointer to the TTree.; TStringfTreeFileNameName of the file containing the tree.; TStringfTreeNameName of the tree.; TList*fVarListList of the variables.; Int_tfWeightCutSpecify a cut on the entries from their weight (see TParallelCoordVar::GetEvtWeight(Long64_t)). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParallelCoord(); Default constructor. TParallelCoord(Long64_t nentries); Constructor without a reference to a tree,; the datas must be added afterwards with; TParallelCoord::AddVariable(Double_t*,const char*). TParallelCoord(TTree* tree, Long64_t nentries); Normal constructor, the datas must be added afterwards; with TParallelCoord::AddVariable(Double_t*,const char*). ~TParallelCoord(); Destructor. void AddVariable(Double_t* val, const char* title = """"); Add a variable. void AddVariable(const char* varexp); Add a variable from an expression. void AddSelection(const char* title); Add a selecti",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:13498,Modifiability,variab,variables,13498,")kVertDisplay; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TGaxis*fCandleAxis! An axis used when displaying a candle chart.; TEntryList*fCurrentEntries-> Current selected entries in the tree.; Long64_tfCurrentFirstFirst entry to display.; Long64_tfCurrentNNumber of entries to display.; TParallelCoordSelect*fCurrentSelection! Current Selection being edited.; Int_tfDotsSpacingSpacing between dots to draw the entries.; TEntryList*fInitEntries-> Selected entries when TParallelCoord first initialized.; Color_tfLineColorentries line color.; Width_tfLineWidthentries line width.; Long64_tfNentriesNumber of entries;; UInt_tfNvarNumber of variables.; TList*fSelectListList of selections over the variables.; TTree*fTree! Pointer to the TTree.; TStringfTreeFileNameName of the file containing the tree.; TStringfTreeNameName of the tree.; TList*fVarListList of the variables.; Int_tfWeightCutSpecify a cut on the entries from their weight (see TParallelCoordVar::GetEvtWeight(Long64_t)). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParallelCoord(); Default constructor. TParallelCoord(Long64_t nentries); Constructor without a reference to a tree,; the datas must be added afterwards with; TParallelCoord::AddVariable(Double_t*,const char*). TParallelCoord(TTree* tree, Long64_t nentries); Normal constructor, the datas must be added afterwards; with TParallelCoord::AddVariable(Double_t*,const char*). ~TParallelCoord(); Destructor. void AddVariable(Double_t* val, const char* title = """"); Add a variable. void AddVariable(const char* varexp); Add a variable from an expression. void AddSelection(const char* title); Add a selection. void ApplySelectionToTree(); Apply the current selection to the tree. void BuildParallelCoord(TSelectorDraw* selector, Bool_t candle); Call constructor and add the variables",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:14178,Modifiability,variab,variable,14178,"eColorentries line color.; Width_tfLineWidthentries line width.; Long64_tfNentriesNumber of entries;; UInt_tfNvarNumber of variables.; TList*fSelectListList of selections over the variables.; TTree*fTree! Pointer to the TTree.; TStringfTreeFileNameName of the file containing the tree.; TStringfTreeNameName of the tree.; TList*fVarListList of the variables.; Int_tfWeightCutSpecify a cut on the entries from their weight (see TParallelCoordVar::GetEvtWeight(Long64_t)). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParallelCoord(); Default constructor. TParallelCoord(Long64_t nentries); Constructor without a reference to a tree,; the datas must be added afterwards with; TParallelCoord::AddVariable(Double_t*,const char*). TParallelCoord(TTree* tree, Long64_t nentries); Normal constructor, the datas must be added afterwards; with TParallelCoord::AddVariable(Double_t*,const char*). ~TParallelCoord(); Destructor. void AddVariable(Double_t* val, const char* title = """"); Add a variable. void AddVariable(const char* varexp); Add a variable from an expression. void AddSelection(const char* title); Add a selection. void ApplySelectionToTree(); Apply the current selection to the tree. void BuildParallelCoord(TSelectorDraw* selector, Bool_t candle); Call constructor and add the variables. void CleanUpSelections(TParallelCoordRange* range); Clean up the selections from the ranges which could have been deleted; when a variable has been deleted. void DeleteSelection(TParallelCoordSelect* sel); Delete a selection. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute the distance from the TParallelCoord. void Draw(Option_t* options = """"); Draw the parallel coordinates graph. void ExecuteEvent(Int_t entry, Int_t px, Int_t py); Execute the corresponding entry. TParallelCoordSelect* GetCurrentSelection(); Return the selection currently being edited. TEntryList* GetEntryList(Bool_t sel = kTRUE); Get the whole entry list or one for a selection.",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:14232,Modifiability,variab,variable,14232,"fNentriesNumber of entries;; UInt_tfNvarNumber of variables.; TList*fSelectListList of selections over the variables.; TTree*fTree! Pointer to the TTree.; TStringfTreeFileNameName of the file containing the tree.; TStringfTreeNameName of the tree.; TList*fVarListList of the variables.; Int_tfWeightCutSpecify a cut on the entries from their weight (see TParallelCoordVar::GetEvtWeight(Long64_t)). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParallelCoord(); Default constructor. TParallelCoord(Long64_t nentries); Constructor without a reference to a tree,; the datas must be added afterwards with; TParallelCoord::AddVariable(Double_t*,const char*). TParallelCoord(TTree* tree, Long64_t nentries); Normal constructor, the datas must be added afterwards; with TParallelCoord::AddVariable(Double_t*,const char*). ~TParallelCoord(); Destructor. void AddVariable(Double_t* val, const char* title = """"); Add a variable. void AddVariable(const char* varexp); Add a variable from an expression. void AddSelection(const char* title); Add a selection. void ApplySelectionToTree(); Apply the current selection to the tree. void BuildParallelCoord(TSelectorDraw* selector, Bool_t candle); Call constructor and add the variables. void CleanUpSelections(TParallelCoordRange* range); Clean up the selections from the ranges which could have been deleted; when a variable has been deleted. void DeleteSelection(TParallelCoordSelect* sel); Delete a selection. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute the distance from the TParallelCoord. void Draw(Option_t* options = """"); Draw the parallel coordinates graph. void ExecuteEvent(Int_t entry, Int_t px, Int_t py); Execute the corresponding entry. TParallelCoordSelect* GetCurrentSelection(); Return the selection currently being edited. TEntryList* GetEntryList(Bool_t sel = kTRUE); Get the whole entry list or one for a selection. Double_t GetGlobalMax(); return the global maximum. Double_t GetGlobalMi",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:14480,Modifiability,variab,variables,14480,"TStringfTreeNameName of the tree.; TList*fVarListList of the variables.; Int_tfWeightCutSpecify a cut on the entries from their weight (see TParallelCoordVar::GetEvtWeight(Long64_t)). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParallelCoord(); Default constructor. TParallelCoord(Long64_t nentries); Constructor without a reference to a tree,; the datas must be added afterwards with; TParallelCoord::AddVariable(Double_t*,const char*). TParallelCoord(TTree* tree, Long64_t nentries); Normal constructor, the datas must be added afterwards; with TParallelCoord::AddVariable(Double_t*,const char*). ~TParallelCoord(); Destructor. void AddVariable(Double_t* val, const char* title = """"); Add a variable. void AddVariable(const char* varexp); Add a variable from an expression. void AddSelection(const char* title); Add a selection. void ApplySelectionToTree(); Apply the current selection to the tree. void BuildParallelCoord(TSelectorDraw* selector, Bool_t candle); Call constructor and add the variables. void CleanUpSelections(TParallelCoordRange* range); Clean up the selections from the ranges which could have been deleted; when a variable has been deleted. void DeleteSelection(TParallelCoordSelect* sel); Delete a selection. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute the distance from the TParallelCoord. void Draw(Option_t* options = """"); Draw the parallel coordinates graph. void ExecuteEvent(Int_t entry, Int_t px, Int_t py); Execute the corresponding entry. TParallelCoordSelect* GetCurrentSelection(); Return the selection currently being edited. TEntryList* GetEntryList(Bool_t sel = kTRUE); Get the whole entry list or one for a selection. Double_t GetGlobalMax(); return the global maximum. Double_t GetGlobalMin(); return the global minimum. Int_t GetNbins(); get the binning of the histograms. TParallelCoordSelect* GetSelection(const char* title); Get a selection from its title. TTree* GetTree(); return the tree if fTree",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:14621,Modifiability,variab,variable,14621,"ght (see TParallelCoordVar::GetEvtWeight(Long64_t)). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParallelCoord(); Default constructor. TParallelCoord(Long64_t nentries); Constructor without a reference to a tree,; the datas must be added afterwards with; TParallelCoord::AddVariable(Double_t*,const char*). TParallelCoord(TTree* tree, Long64_t nentries); Normal constructor, the datas must be added afterwards; with TParallelCoord::AddVariable(Double_t*,const char*). ~TParallelCoord(); Destructor. void AddVariable(Double_t* val, const char* title = """"); Add a variable. void AddVariable(const char* varexp); Add a variable from an expression. void AddSelection(const char* title); Add a selection. void ApplySelectionToTree(); Apply the current selection to the tree. void BuildParallelCoord(TSelectorDraw* selector, Bool_t candle); Call constructor and add the variables. void CleanUpSelections(TParallelCoordRange* range); Clean up the selections from the ranges which could have been deleted; when a variable has been deleted. void DeleteSelection(TParallelCoordSelect* sel); Delete a selection. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute the distance from the TParallelCoord. void Draw(Option_t* options = """"); Draw the parallel coordinates graph. void ExecuteEvent(Int_t entry, Int_t px, Int_t py); Execute the corresponding entry. TParallelCoordSelect* GetCurrentSelection(); Return the selection currently being edited. TEntryList* GetEntryList(Bool_t sel = kTRUE); Get the whole entry list or one for a selection. Double_t GetGlobalMax(); return the global maximum. Double_t GetGlobalMin(); return the global minimum. Int_t GetNbins(); get the binning of the histograms. TParallelCoordSelect* GetSelection(const char* title); Get a selection from its title. TTree* GetTree(); return the tree if fTree is defined. If not, the method try to load the tree; from fTreeFileName. Double_t* GetVariable(const char* var); Get the variables",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:15560,Modifiability,variab,variables,15560," the selections from the ranges which could have been deleted; when a variable has been deleted. void DeleteSelection(TParallelCoordSelect* sel); Delete a selection. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute the distance from the TParallelCoord. void Draw(Option_t* options = """"); Draw the parallel coordinates graph. void ExecuteEvent(Int_t entry, Int_t px, Int_t py); Execute the corresponding entry. TParallelCoordSelect* GetCurrentSelection(); Return the selection currently being edited. TEntryList* GetEntryList(Bool_t sel = kTRUE); Get the whole entry list or one for a selection. Double_t GetGlobalMax(); return the global maximum. Double_t GetGlobalMin(); return the global minimum. Int_t GetNbins(); get the binning of the histograms. TParallelCoordSelect* GetSelection(const char* title); Get a selection from its title. TTree* GetTree(); return the tree if fTree is defined. If not, the method try to load the tree; from fTreeFileName. Double_t* GetVariable(const char* var); Get the variables values from its title. Double_t* GetVariable(Int_t i); Get the variables values from its index. void Init(); Initialise the data members of TParallelCoord. void Paint(Option_t* options = """"); Paint the parallel coordinates graph. void PaintEntries(TParallelCoordSelect* sel = __null); Loop over the entries and paint them. void RemoveVariable(TParallelCoordVar* var); Delete a variable from the graph. TParallelCoordVar* RemoveVariable(const char* var); Delete the variable ""vartitle"" from the graph. void ResetTree(); Reset the tree entry list to the initial one.. void SaveEntryLists(const char* filename = """", Bool_t overwrite = kFALSE); Save the entry lists in a root file ""filename.root"". void SavePrimitive(ostream& out, Option_t* options); Save the TParallelCoord in a macro. void SaveTree(const char* filename = """", Bool_t overwrite = kFALSE); Save the tree in a file if fTreeFileName == """". void SetAxesPosition(); Update the position of the axes. void SetAxisHistogramBinn",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:15633,Modifiability,variab,variables,15633,"e has been deleted. void DeleteSelection(TParallelCoordSelect* sel); Delete a selection. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute the distance from the TParallelCoord. void Draw(Option_t* options = """"); Draw the parallel coordinates graph. void ExecuteEvent(Int_t entry, Int_t px, Int_t py); Execute the corresponding entry. TParallelCoordSelect* GetCurrentSelection(); Return the selection currently being edited. TEntryList* GetEntryList(Bool_t sel = kTRUE); Get the whole entry list or one for a selection. Double_t GetGlobalMax(); return the global maximum. Double_t GetGlobalMin(); return the global minimum. Int_t GetNbins(); get the binning of the histograms. TParallelCoordSelect* GetSelection(const char* title); Get a selection from its title. TTree* GetTree(); return the tree if fTree is defined. If not, the method try to load the tree; from fTreeFileName. Double_t* GetVariable(const char* var); Get the variables values from its title. Double_t* GetVariable(Int_t i); Get the variables values from its index. void Init(); Initialise the data members of TParallelCoord. void Paint(Option_t* options = """"); Paint the parallel coordinates graph. void PaintEntries(TParallelCoordSelect* sel = __null); Loop over the entries and paint them. void RemoveVariable(TParallelCoordVar* var); Delete a variable from the graph. TParallelCoordVar* RemoveVariable(const char* var); Delete the variable ""vartitle"" from the graph. void ResetTree(); Reset the tree entry list to the initial one.. void SaveEntryLists(const char* filename = """", Bool_t overwrite = kFALSE); Save the entry lists in a root file ""filename.root"". void SavePrimitive(ostream& out, Option_t* options); Save the TParallelCoord in a macro. void SaveTree(const char* filename = """", Bool_t overwrite = kFALSE); Save the tree in a file if fTreeFileName == """". void SetAxesPosition(); Update the position of the axes. void SetAxisHistogramBinning(Int_t n = 100); Set the same histogram axis binning for all axis. void Se",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:15947,Modifiability,variab,variable,15947,"); Execute the corresponding entry. TParallelCoordSelect* GetCurrentSelection(); Return the selection currently being edited. TEntryList* GetEntryList(Bool_t sel = kTRUE); Get the whole entry list or one for a selection. Double_t GetGlobalMax(); return the global maximum. Double_t GetGlobalMin(); return the global minimum. Int_t GetNbins(); get the binning of the histograms. TParallelCoordSelect* GetSelection(const char* title); Get a selection from its title. TTree* GetTree(); return the tree if fTree is defined. If not, the method try to load the tree; from fTreeFileName. Double_t* GetVariable(const char* var); Get the variables values from its title. Double_t* GetVariable(Int_t i); Get the variables values from its index. void Init(); Initialise the data members of TParallelCoord. void Paint(Option_t* options = """"); Paint the parallel coordinates graph. void PaintEntries(TParallelCoordSelect* sel = __null); Loop over the entries and paint them. void RemoveVariable(TParallelCoordVar* var); Delete a variable from the graph. TParallelCoordVar* RemoveVariable(const char* var); Delete the variable ""vartitle"" from the graph. void ResetTree(); Reset the tree entry list to the initial one.. void SaveEntryLists(const char* filename = """", Bool_t overwrite = kFALSE); Save the entry lists in a root file ""filename.root"". void SavePrimitive(ostream& out, Option_t* options); Save the TParallelCoord in a macro. void SaveTree(const char* filename = """", Bool_t overwrite = kFALSE); Save the tree in a file if fTreeFileName == """". void SetAxesPosition(); Update the position of the axes. void SetAxisHistogramBinning(Int_t n = 100); Set the same histogram axis binning for all axis. void SetAxisHistogramHeight(Double_t h = 0.5); Set the same histogram axis height for all axis. void SetGlobalLogScale(Bool_t ); All axes in log scale. void SetGlobalScale(Bool_t gl); Constraint all axes to the same scale. void SetAxisHistogramLineWidth(Int_t lw = 2); Set the same histogram axis line width fo",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:16035,Modifiability,variab,variable,16035,"he selection currently being edited. TEntryList* GetEntryList(Bool_t sel = kTRUE); Get the whole entry list or one for a selection. Double_t GetGlobalMax(); return the global maximum. Double_t GetGlobalMin(); return the global minimum. Int_t GetNbins(); get the binning of the histograms. TParallelCoordSelect* GetSelection(const char* title); Get a selection from its title. TTree* GetTree(); return the tree if fTree is defined. If not, the method try to load the tree; from fTreeFileName. Double_t* GetVariable(const char* var); Get the variables values from its title. Double_t* GetVariable(Int_t i); Get the variables values from its index. void Init(); Initialise the data members of TParallelCoord. void Paint(Option_t* options = """"); Paint the parallel coordinates graph. void PaintEntries(TParallelCoordSelect* sel = __null); Loop over the entries and paint them. void RemoveVariable(TParallelCoordVar* var); Delete a variable from the graph. TParallelCoordVar* RemoveVariable(const char* var); Delete the variable ""vartitle"" from the graph. void ResetTree(); Reset the tree entry list to the initial one.. void SaveEntryLists(const char* filename = """", Bool_t overwrite = kFALSE); Save the entry lists in a root file ""filename.root"". void SavePrimitive(ostream& out, Option_t* options); Save the TParallelCoord in a macro. void SaveTree(const char* filename = """", Bool_t overwrite = kFALSE); Save the tree in a file if fTreeFileName == """". void SetAxesPosition(); Update the position of the axes. void SetAxisHistogramBinning(Int_t n = 100); Set the same histogram axis binning for all axis. void SetAxisHistogramHeight(Double_t h = 0.5); Set the same histogram axis height for all axis. void SetGlobalLogScale(Bool_t ); All axes in log scale. void SetGlobalScale(Bool_t gl); Constraint all axes to the same scale. void SetAxisHistogramLineWidth(Int_t lw = 2); Set the same histogram axis line width for all axis. void SetCandleChart(Bool_t can); Set a candle chart display. void SetCurrentF",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:17598,Modifiability,variab,variables,17598,"am axis binning for all axis. void SetAxisHistogramHeight(Double_t h = 0.5); Set the same histogram axis height for all axis. void SetGlobalLogScale(Bool_t ); All axes in log scale. void SetGlobalScale(Bool_t gl); Constraint all axes to the same scale. void SetAxisHistogramLineWidth(Int_t lw = 2); Set the same histogram axis line width for all axis. void SetCandleChart(Bool_t can); Set a candle chart display. void SetCurrentFirst(Long64_t ); Set the first entry to be dispayed. void SetCurrentN(Long64_t ); Set the number of entry to be displayed. TParallelCoordSelect* SetCurrentSelection(const char* title); Set the selection beeing edited. void SetCurrentSelection(TParallelCoordSelect* sel); Set the selection beeing edited. void SetDotsSpacing(Int_t s = 0); Set dots spacing. Modify the line style 11.; If the canvas support transparency dot spacing is ignored. void SetEntryList(TParallelCoord* para, TEntryList* enlist); Set the entry lists of ""para"". void SetGlobalMax(Double_t max); Force all variables to adopt the same max. void SetGlobalMin(Double_t min); Force all variables to adopt the same min. void SetLiveRangesUpdate(Bool_t ); If true, the pad is updated while the motion of a dragged range. void SetVertDisplay(Bool_t vert = kTRUE); Set the vertical or horizontal display. void UnzoomAll(); Unzoom all variables. TParallelCoord(). Bool_t GetCandleChart(); {return TestBit(kCandleChart);}. Long64_t GetCurrentFirst(); {return fCurrentFirst;}. Long64_t GetCurrentN(); {return fCurrentN;}. Bool_t GetCurveDisplay() const; {return TestBit(kCurveDisplay);}. Int_t GetDotsSpacing() const; {return fDotsSpacing;}. Bool_t GetGlobalScale(); {return TestBit(kGlobalScale);}. Bool_t GetGlobalLogScale(); {return TestBit(kGlobalLogScale);}. Color_t GetLineColor(); {return fLineColor;}. Width_t GetLineWidth(); {return fLineWidth;}. UInt_t GetNvar(); {return fNvar;}. Long64_t GetNentries(); {return fNentries;}. TList * GetSelectList(); {return fSelectList;}. TList * GetVarList(); {retu",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:17674,Modifiability,variab,variables,17674," Set the same histogram axis height for all axis. void SetGlobalLogScale(Bool_t ); All axes in log scale. void SetGlobalScale(Bool_t gl); Constraint all axes to the same scale. void SetAxisHistogramLineWidth(Int_t lw = 2); Set the same histogram axis line width for all axis. void SetCandleChart(Bool_t can); Set a candle chart display. void SetCurrentFirst(Long64_t ); Set the first entry to be dispayed. void SetCurrentN(Long64_t ); Set the number of entry to be displayed. TParallelCoordSelect* SetCurrentSelection(const char* title); Set the selection beeing edited. void SetCurrentSelection(TParallelCoordSelect* sel); Set the selection beeing edited. void SetDotsSpacing(Int_t s = 0); Set dots spacing. Modify the line style 11.; If the canvas support transparency dot spacing is ignored. void SetEntryList(TParallelCoord* para, TEntryList* enlist); Set the entry lists of ""para"". void SetGlobalMax(Double_t max); Force all variables to adopt the same max. void SetGlobalMin(Double_t min); Force all variables to adopt the same min. void SetLiveRangesUpdate(Bool_t ); If true, the pad is updated while the motion of a dragged range. void SetVertDisplay(Bool_t vert = kTRUE); Set the vertical or horizontal display. void UnzoomAll(); Unzoom all variables. TParallelCoord(). Bool_t GetCandleChart(); {return TestBit(kCandleChart);}. Long64_t GetCurrentFirst(); {return fCurrentFirst;}. Long64_t GetCurrentN(); {return fCurrentN;}. Bool_t GetCurveDisplay() const; {return TestBit(kCurveDisplay);}. Int_t GetDotsSpacing() const; {return fDotsSpacing;}. Bool_t GetGlobalScale(); {return TestBit(kGlobalScale);}. Bool_t GetGlobalLogScale(); {return TestBit(kGlobalLogScale);}. Color_t GetLineColor(); {return fLineColor;}. Width_t GetLineWidth(); {return fLineWidth;}. UInt_t GetNvar(); {return fNvar;}. Long64_t GetNentries(); {return fNentries;}. TList * GetSelectList(); {return fSelectList;}. TList * GetVarList(); {return fVarList;}. Bool_t GetVertDisplay() const; {return TestBit(kVertDisplay);",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:17918,Modifiability,variab,variables,17918,"ogram axis line width for all axis. void SetCandleChart(Bool_t can); Set a candle chart display. void SetCurrentFirst(Long64_t ); Set the first entry to be dispayed. void SetCurrentN(Long64_t ); Set the number of entry to be displayed. TParallelCoordSelect* SetCurrentSelection(const char* title); Set the selection beeing edited. void SetCurrentSelection(TParallelCoordSelect* sel); Set the selection beeing edited. void SetDotsSpacing(Int_t s = 0); Set dots spacing. Modify the line style 11.; If the canvas support transparency dot spacing is ignored. void SetEntryList(TParallelCoord* para, TEntryList* enlist); Set the entry lists of ""para"". void SetGlobalMax(Double_t max); Force all variables to adopt the same max. void SetGlobalMin(Double_t min); Force all variables to adopt the same min. void SetLiveRangesUpdate(Bool_t ); If true, the pad is updated while the motion of a dragged range. void SetVertDisplay(Bool_t vert = kTRUE); Set the vertical or horizontal display. void UnzoomAll(); Unzoom all variables. TParallelCoord(). Bool_t GetCandleChart(); {return TestBit(kCandleChart);}. Long64_t GetCurrentFirst(); {return fCurrentFirst;}. Long64_t GetCurrentN(); {return fCurrentN;}. Bool_t GetCurveDisplay() const; {return TestBit(kCurveDisplay);}. Int_t GetDotsSpacing() const; {return fDotsSpacing;}. Bool_t GetGlobalScale(); {return TestBit(kGlobalScale);}. Bool_t GetGlobalLogScale(); {return TestBit(kGlobalLogScale);}. Color_t GetLineColor(); {return fLineColor;}. Width_t GetLineWidth(); {return fLineWidth;}. UInt_t GetNvar(); {return fNvar;}. Long64_t GetNentries(); {return fNentries;}. TList * GetSelectList(); {return fSelectList;}. TList * GetVarList(); {return fVarList;}. Bool_t GetVertDisplay() const; {return TestBit(kVertDisplay);}. Int_t GetWeightCut() const; {return fWeightCut;}. void SetCurveDisplay(Bool_t curve = 1); {SetBit(kCurveDisplay,curve);}. void SetCurrentEntries(TEntryList* entries); {fCurrentEntries = entries;}. void SetInitEntries(TEntryList* entries)",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:15477,Performance,load,load,15477,"variables. void CleanUpSelections(TParallelCoordRange* range); Clean up the selections from the ranges which could have been deleted; when a variable has been deleted. void DeleteSelection(TParallelCoordSelect* sel); Delete a selection. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute the distance from the TParallelCoord. void Draw(Option_t* options = """"); Draw the parallel coordinates graph. void ExecuteEvent(Int_t entry, Int_t px, Int_t py); Execute the corresponding entry. TParallelCoordSelect* GetCurrentSelection(); Return the selection currently being edited. TEntryList* GetEntryList(Bool_t sel = kTRUE); Get the whole entry list or one for a selection. Double_t GetGlobalMax(); return the global maximum. Double_t GetGlobalMin(); return the global minimum. Int_t GetNbins(); get the binning of the histograms. TParallelCoordSelect* GetSelection(const char* title); Get a selection from its title. TTree* GetTree(); return the tree if fTree is defined. If not, the method try to load the tree; from fTreeFileName. Double_t* GetVariable(const char* var); Get the variables values from its title. Double_t* GetVariable(Int_t i); Get the variables values from its index. void Init(); Initialise the data members of TParallelCoord. void Paint(Option_t* options = """"); Paint the parallel coordinates graph. void PaintEntries(TParallelCoordSelect* sel = __null); Loop over the entries and paint them. void RemoveVariable(TParallelCoordVar* var); Delete a variable from the graph. TParallelCoordVar* RemoveVariable(const char* var); Delete the variable ""vartitle"" from the graph. void ResetTree(); Reset the tree entry list to the initial one.. void SaveEntryLists(const char* filename = """", Bool_t overwrite = kFALSE); Save the entry lists in a root file ""filename.root"". void SavePrimitive(ostream& out, Option_t* options); Save the TParallelCoord in a macro. void SaveTree(const char* filename = """", Bool_t overwrite = kFALSE); Save the tree in a file if fTreeFileName == """". void SetAxe",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:2918,Testability,log,logarithm,2918," that representation, a selection is an ensemble of ranges defined on the axes. Ranges defined on the same axis are conjugated with OR (an entry must be in one or the other ranges to be selected). Ranges on different axes are are conjugated with AND (an entry must be in all the ranges to be selected). Several selections can be defined with different colors. It is possible to generate an entry list from a given selection and apply it to the tree using the editor (""Apply to tree"" button).; Axes:. Options can be defined each axis separatly using the right mouse click. These options can be applied to every axes using the editor. Axis width: If set to 0, the axis is simply a line. If higher, a color histogram is drawn on the axis.; Axis histogram height: If not 0, a usual bar histogram is drawn on the plot. The order in which the variables are drawn is essential to see the clusters. The axes can be dragged to change their position. A zoom is also available. The logarithm scale is also available by right clicking on the axis.; Candle chart:. TParallelCoord can also be used to display a candle chart. In that mode, every variable is drawn in the same scale. The candle chart can be combined with the parallel coordinates mode, drawing the candle sticks over the axes. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = TFile::Open(""cernstaff.root"");; TTree *T = (TTree*)f->Get(""T"");; T->Draw(""Age:Grade:Step:Cost:Division:Nation"","""",""para"");; TParallelCoord* para = (TParallelCoord*)gPad->GetListOfPrimitives()->FindObject(""ParaCoord"");; TParallelCoordVar* grade = (TParallelCoordVar*)para->GetVarList()->FindObject(""Grade"");; grade->AddRange(new TParallelCoordRange(grade,11.5,14));; para->AddSelection(""less30"");; para->GetCurrentSelection()->SetLineColor(kViolet);; TParallelCoordVar* age = (TParallelCoordVar*)para->GetVarList()->FindObject(""Age"");; age->AddRange(new TParallelCoordRange(age,21,30));; return c1;; }; Some references:. Alfred Inselberg's Homepage , with Vis",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:16763,Testability,log,log,16763,"* options = """"); Paint the parallel coordinates graph. void PaintEntries(TParallelCoordSelect* sel = __null); Loop over the entries and paint them. void RemoveVariable(TParallelCoordVar* var); Delete a variable from the graph. TParallelCoordVar* RemoveVariable(const char* var); Delete the variable ""vartitle"" from the graph. void ResetTree(); Reset the tree entry list to the initial one.. void SaveEntryLists(const char* filename = """", Bool_t overwrite = kFALSE); Save the entry lists in a root file ""filename.root"". void SavePrimitive(ostream& out, Option_t* options); Save the TParallelCoord in a macro. void SaveTree(const char* filename = """", Bool_t overwrite = kFALSE); Save the tree in a file if fTreeFileName == """". void SetAxesPosition(); Update the position of the axes. void SetAxisHistogramBinning(Int_t n = 100); Set the same histogram axis binning for all axis. void SetAxisHistogramHeight(Double_t h = 0.5); Set the same histogram axis height for all axis. void SetGlobalLogScale(Bool_t ); All axes in log scale. void SetGlobalScale(Bool_t gl); Constraint all axes to the same scale. void SetAxisHistogramLineWidth(Int_t lw = 2); Set the same histogram axis line width for all axis. void SetCandleChart(Bool_t can); Set a candle chart display. void SetCurrentFirst(Long64_t ); Set the first entry to be dispayed. void SetCurrentN(Long64_t ); Set the number of entry to be displayed. TParallelCoordSelect* SetCurrentSelection(const char* title); Set the selection beeing edited. void SetCurrentSelection(TParallelCoordSelect* sel); Set the selection beeing edited. void SetDotsSpacing(Int_t s = 0); Set dots spacing. Modify the line style 11.; If the canvas support transparency dot spacing is ignored. void SetEntryList(TParallelCoord* para, TEntryList* enlist); Set the entry lists of ""para"". void SetGlobalMax(Double_t max); Force all variables to adopt the same max. void SetGlobalMin(Double_t min); Force all variables to adopt the same min. void SetLiveRangesUpdate(Bool_t ); If ",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoord.html:2617,Usability,simpl,simply,2617," a big weight wether an entry going randomly through the histograms will have a rather small weight. Setting a cut on this weight allows to draw only the most representative entries. A slider set the cut is also available in the gui. Selections:. Selections of specific entries can be defined over the data se using parallel coordinates. With that representation, a selection is an ensemble of ranges defined on the axes. Ranges defined on the same axis are conjugated with OR (an entry must be in one or the other ranges to be selected). Ranges on different axes are are conjugated with AND (an entry must be in all the ranges to be selected). Several selections can be defined with different colors. It is possible to generate an entry list from a given selection and apply it to the tree using the editor (""Apply to tree"" button).; Axes:. Options can be defined each axis separatly using the right mouse click. These options can be applied to every axes using the editor. Axis width: If set to 0, the axis is simply a line. If higher, a color histogram is drawn on the axis.; Axis histogram height: If not 0, a usual bar histogram is drawn on the plot. The order in which the variables are drawn is essential to see the clusters. The axes can be dragged to change their position. A zoom is also available. The logarithm scale is also available by right clicking on the axis.; Candle chart:. TParallelCoord can also be used to display a candle chart. In that mode, every variable is drawn in the same scale. The candle chart can be combined with the parallel coordinates mode, drawing the candle sticks over the axes. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = TFile::Open(""cernstaff.root"");; TTree *T = (TTree*)f->Get(""T"");; T->Draw(""Age:Grade:Step:Cost:Division:Nation"","""",""para"");; TParallelCoord* para = (TParallelCoord*)gPad->GetListOfPrimitives()->FindObject(""ParaCoord"");; TParallelCoordVar* grade = (TParallelCoordVar*)para->GetVarList()->FindObject(""Grade"");; grade->",MatchSource.WIKI,root/html604/TParallelCoord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoord.html
https://root.cern/root/html604/TParallelCoordEditor.html:6264,Availability,error,error,6264," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html604/TParallelCoordEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordEditor.html
https://root.cern/root/html604/TParallelCoordEditor.html:6348,Availability,error,error,6348,"(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html604/TParallelCoordEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordEditor.html
https://root.cern/root/html604/TParallelCoordEditor.html:20621,Availability,mask,mask,20621,,MatchSource.WIKI,root/html604/TParallelCoordEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordEditor.html
https://root.cern/root/html604/TParallelCoordEditor.html:25740,Deployability,update,update,25740,"he line dotspacing from the entry field. void DoAlphaField(); Slot to set the alpha value from the entry field. void DoAlpha(); Slot to set the alpha value. void DoEntriesToDraw(); Slot to select the entries to be drawn. void DoFirstEntry(); Slot to set the first entry. void DoGlobalLineColor(Pixel_t ); Slot to set the global line color. void DoGlobalLineWidth(Int_t ); Slot to set the global line width. void DoHideAllRanges(Bool_t ); Slot to hide all the ranges. void DoHistBinning(); Slot to set the axes histogram binning. void DoHistColorSelect(Pixel_t ); Slot to set the histograms color. void DoHistShowBoxes(Bool_t ); Slot to set histogram height. void DoHistPatternSelect(Style_t ); Slot to set the histograms fill style. void DoHistWidth(); Slot to set histogram width. void DoLineType(); Slot to set the line type. void DoLiveDotsSpacing(Int_t a); Slot to set the dots spacing online. void DoLiveAlpha(Int_t a); Slot to set alpha value online. void DoLiveEntriesToDraw(); Slot to update the entries fields from the slider position. void DoLiveWeightCut(Int_t n); Slot to update the wieght cut entry field from the slider position. void DoNentries(); Slot to set the number of entries to display. void DoPaintEntries(Bool_t ); Slot to postpone the entries drawing. void DoSelectLineColor(Pixel_t ); Slot to set the line color of selection. void DoSelectLineWidth(Int_t ); Slot to set the line width of selection. void DoSelectionSelect(const char* title); Slot to set the selection beeing edited. void DoShowRanges(Bool_t s); Slot to show or not the ranges on the pad. void DoUnApply(); Slot to reset the tree entry list to the original one. void DoVariableSelect(const char* var); Slot to select a variable. void DoWeightCut(); Slot to update the weight cut. void SetModel(TObject* obj); Pick up the used parallel coordinates plot attributes. TParallelCoordEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBa",MatchSource.WIKI,root/html604/TParallelCoordEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordEditor.html
https://root.cern/root/html604/TParallelCoordEditor.html:25831,Deployability,update,update,25831,"m the entry field. void DoAlpha(); Slot to set the alpha value. void DoEntriesToDraw(); Slot to select the entries to be drawn. void DoFirstEntry(); Slot to set the first entry. void DoGlobalLineColor(Pixel_t ); Slot to set the global line color. void DoGlobalLineWidth(Int_t ); Slot to set the global line width. void DoHideAllRanges(Bool_t ); Slot to hide all the ranges. void DoHistBinning(); Slot to set the axes histogram binning. void DoHistColorSelect(Pixel_t ); Slot to set the histograms color. void DoHistShowBoxes(Bool_t ); Slot to set histogram height. void DoHistPatternSelect(Style_t ); Slot to set the histograms fill style. void DoHistWidth(); Slot to set histogram width. void DoLineType(); Slot to set the line type. void DoLiveDotsSpacing(Int_t a); Slot to set the dots spacing online. void DoLiveAlpha(Int_t a); Slot to set alpha value online. void DoLiveEntriesToDraw(); Slot to update the entries fields from the slider position. void DoLiveWeightCut(Int_t n); Slot to update the wieght cut entry field from the slider position. void DoNentries(); Slot to set the number of entries to display. void DoPaintEntries(Bool_t ); Slot to postpone the entries drawing. void DoSelectLineColor(Pixel_t ); Slot to set the line color of selection. void DoSelectLineWidth(Int_t ); Slot to set the line width of selection. void DoSelectionSelect(const char* title); Slot to set the selection beeing edited. void DoShowRanges(Bool_t s); Slot to show or not the ranges on the pad. void DoUnApply(); Slot to reset the tree entry list to the original one. void DoVariableSelect(const char* var); Slot to select a variable. void DoWeightCut(); Slot to update the weight cut. void SetModel(TObject* obj); Pick up the used parallel coordinates plot attributes. TParallelCoordEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: Bastien Dalla Piazza 02/08/2007 » Copyright (C) 1995-2007, Rene Brun an",MatchSource.WIKI,root/html604/TParallelCoordEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordEditor.html
https://root.cern/root/html604/TParallelCoordEditor.html:26496,Deployability,update,update,26496," DoGlobalLineWidth(Int_t ); Slot to set the global line width. void DoHideAllRanges(Bool_t ); Slot to hide all the ranges. void DoHistBinning(); Slot to set the axes histogram binning. void DoHistColorSelect(Pixel_t ); Slot to set the histograms color. void DoHistShowBoxes(Bool_t ); Slot to set histogram height. void DoHistPatternSelect(Style_t ); Slot to set the histograms fill style. void DoHistWidth(); Slot to set histogram width. void DoLineType(); Slot to set the line type. void DoLiveDotsSpacing(Int_t a); Slot to set the dots spacing online. void DoLiveAlpha(Int_t a); Slot to set alpha value online. void DoLiveEntriesToDraw(); Slot to update the entries fields from the slider position. void DoLiveWeightCut(Int_t n); Slot to update the wieght cut entry field from the slider position. void DoNentries(); Slot to set the number of entries to display. void DoPaintEntries(Bool_t ); Slot to postpone the entries drawing. void DoSelectLineColor(Pixel_t ); Slot to set the line color of selection. void DoSelectLineWidth(Int_t ); Slot to set the line width of selection. void DoSelectionSelect(const char* title); Slot to set the selection beeing edited. void DoShowRanges(Bool_t s); Slot to show or not the ranges on the pad. void DoUnApply(); Slot to reset the tree entry list to the original one. void DoVariableSelect(const char* var); Slot to select a variable. void DoWeightCut(); Slot to update the weight cut. void SetModel(TObject* obj); Pick up the used parallel coordinates plot attributes. TParallelCoordEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: Bastien Dalla Piazza 02/08/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/treeviewer:$Id$ » Last generated: 2015-06-02 16:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TParallelCoordEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordEditor.html
https://root.cern/root/html604/TParallelCoordEditor.html:579,Energy Efficiency,reduce,reduce,579,". TParallelCoordEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TParallelCoordEditor. class TParallelCoordEditor: public TGedFrame. The TParallelCoord editor class; This is the TParallelCoord editor. It brings tools to explore datas; Using parallel coordinates. The main tools are:. Dots spacing : Set the dots spacing with whichone the lines; must be drawn. This tool is useful to reduce the image; cluttering.; The Selections section : Set the current edited selection and; allows to apply it to the tree through a generated entry list.; The Entries section : Set how many events must be drawn.; A weight cut can be defioned here (see TParallelCoord for a; a description of the weight cut).; The Variables tab : To define the global settings to display; the axes. It is also possible to add a variable from its; expression or delete a selected one (also possible using right; click on the pad. . Function Members (Methods); public:. virtual~TParallelCoordEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual",MatchSource.WIKI,root/html604/TParallelCoordEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordEditor.html
https://root.cern/root/html604/TParallelCoordEditor.html:992,Modifiability,variab,variable,992,"ck Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TParallelCoordEditor. class TParallelCoordEditor: public TGedFrame. The TParallelCoord editor class; This is the TParallelCoord editor. It brings tools to explore datas; Using parallel coordinates. The main tools are:. Dots spacing : Set the dots spacing with whichone the lines; must be drawn. This tool is useful to reduce the image; cluttering.; The Selections section : Set the current edited selection and; allows to apply it to the tree through a generated entry list.; The Entries section : Set how many events must be drawn.; A weight cut can be defioned here (see TParallelCoord for a; a description of the weight cut).; The Variables tab : To define the global settings to display; the axes. It is also possible to add a variable from its; expression or delete a selected one (also possible using right; click on the pad. . Function Members (Methods); public:. virtual~TParallelCoordEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::Cha",MatchSource.WIKI,root/html604/TParallelCoordEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordEditor.html
https://root.cern/root/html604/TParallelCoordEditor.html:24039,Modifiability,variab,variable,24039,"ackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParallelCoordEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Normal constructor. void MakeVariablesTab(); Make the ""variable"" tab. ~TParallelCoordEditor(); Destructor. void CleanUpSelections(); Clean up the selection combo box. void CleanUpVariables(); Clean up the variables combo box. void ConnectSignals2Slots(); Connect signals to slots. void DoActivateSelection(Bool_t ); Slot to activate or not a selection. void DoAddSelection(); Slot to add a selection. void DoAddVariable(); Slot to add a variable. void DoApplySelect(); Slot to apply a selection to the tree. void DoDelayDrawing(Bool_t ); Slot to delay the drawing. void DoDeleteSelection(); Slot to delete a selection. void DoDeleteVar(); Slot to delete a variable(). void DoDotsSpacing(); Slot to set the line dotspacing. void DoDotsSpacingField(); Slot to set the line dotspacing from the entry field. void DoAlphaField(); Slot to set the alpha value from the entry field. void DoAlpha(); Slot to set the alpha value. void DoEntriesToDraw(); Slot to select the entries to be drawn. void DoFirstEntry(); Slot to set the first entry. void DoGlo",MatchSource.WIKI,root/html604/TParallelCoordEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordEditor.html
https://root.cern/root/html604/TParallelCoordEditor.html:24189,Modifiability,variab,variables,24189," Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParallelCoordEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Normal constructor. void MakeVariablesTab(); Make the ""variable"" tab. ~TParallelCoordEditor(); Destructor. void CleanUpSelections(); Clean up the selection combo box. void CleanUpVariables(); Clean up the variables combo box. void ConnectSignals2Slots(); Connect signals to slots. void DoActivateSelection(Bool_t ); Slot to activate or not a selection. void DoAddSelection(); Slot to add a selection. void DoAddVariable(); Slot to add a variable. void DoApplySelect(); Slot to apply a selection to the tree. void DoDelayDrawing(Bool_t ); Slot to delay the drawing. void DoDeleteSelection(); Slot to delete a selection. void DoDeleteVar(); Slot to delete a variable(). void DoDotsSpacing(); Slot to set the line dotspacing. void DoDotsSpacingField(); Slot to set the line dotspacing from the entry field. void DoAlphaField(); Slot to set the alpha value from the entry field. void DoAlpha(); Slot to set the alpha value. void DoEntriesToDraw(); Slot to select the entries to be drawn. void DoFirstEntry(); Slot to set the first entry. void DoGlobalLineColor(Pixel_t ); Slot to set the global line color. void DoGlobalLineWidth(Int_t ); Slot to set the global line width. void DoHideAllRanges(Bool_",MatchSource.WIKI,root/html604/TParallelCoordEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordEditor.html
https://root.cern/root/html604/TParallelCoordEditor.html:24421,Modifiability,variab,variable,24421,"TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParallelCoordEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Normal constructor. void MakeVariablesTab(); Make the ""variable"" tab. ~TParallelCoordEditor(); Destructor. void CleanUpSelections(); Clean up the selection combo box. void CleanUpVariables(); Clean up the variables combo box. void ConnectSignals2Slots(); Connect signals to slots. void DoActivateSelection(Bool_t ); Slot to activate or not a selection. void DoAddSelection(); Slot to add a selection. void DoAddVariable(); Slot to add a variable. void DoApplySelect(); Slot to apply a selection to the tree. void DoDelayDrawing(Bool_t ); Slot to delay the drawing. void DoDeleteSelection(); Slot to delete a selection. void DoDeleteVar(); Slot to delete a variable(). void DoDotsSpacing(); Slot to set the line dotspacing. void DoDotsSpacingField(); Slot to set the line dotspacing from the entry field. void DoAlphaField(); Slot to set the alpha value from the entry field. void DoAlpha(); Slot to set the alpha value. void DoEntriesToDraw(); Slot to select the entries to be drawn. void DoFirstEntry(); Slot to set the first entry. void DoGlobalLineColor(Pixel_t ); Slot to set the global line color. void DoGlobalLineWidth(Int_t ); Slot to set the global line width. void DoHideAllRanges(Bool_t ); Slot to hide all the ranges. void DoHistBinning(); Slot to set the axes histogram binning. void DoHistColorSelect(Pixel_t ); Slot to set the histograms color. void DoHistShowBoxes(Bool_t ); Slot to set histogram height. vo",MatchSource.WIKI,root/html604/TParallelCoordEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordEditor.html
https://root.cern/root/html604/TParallelCoordEditor.html:24640,Modifiability,variab,variable,24640,"ame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParallelCoordEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Normal constructor. void MakeVariablesTab(); Make the ""variable"" tab. ~TParallelCoordEditor(); Destructor. void CleanUpSelections(); Clean up the selection combo box. void CleanUpVariables(); Clean up the variables combo box. void ConnectSignals2Slots(); Connect signals to slots. void DoActivateSelection(Bool_t ); Slot to activate or not a selection. void DoAddSelection(); Slot to add a selection. void DoAddVariable(); Slot to add a variable. void DoApplySelect(); Slot to apply a selection to the tree. void DoDelayDrawing(Bool_t ); Slot to delay the drawing. void DoDeleteSelection(); Slot to delete a selection. void DoDeleteVar(); Slot to delete a variable(). void DoDotsSpacing(); Slot to set the line dotspacing. void DoDotsSpacingField(); Slot to set the line dotspacing from the entry field. void DoAlphaField(); Slot to set the alpha value from the entry field. void DoAlpha(); Slot to set the alpha value. void DoEntriesToDraw(); Slot to select the entries to be drawn. void DoFirstEntry(); Slot to set the first entry. void DoGlobalLineColor(Pixel_t ); Slot to set the global line color. void DoGlobalLineWidth(Int_t ); Slot to set the global line width. void DoHideAllRanges(Bool_t ); Slot to hide all the ranges. void DoHistBinning(); Slot to set the axes histogram binning. void DoHistColorSelect(Pixel_t ); Slot to set the histograms color. void DoHistShowBoxes(Bool_t ); Slot to set histogram height. void DoHistPatternSelect(Style_t ); Slot to set the histograms fill style. void DoHistWidth(); Slot to set histogram width. void DoLineType(); Slot to set the line type. void DoLiveDotsSpacing(Int_t a); Slot to set the dot",MatchSource.WIKI,root/html604/TParallelCoordEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordEditor.html
https://root.cern/root/html604/TParallelCoordEditor.html:26458,Modifiability,variab,variable,26458," DoGlobalLineWidth(Int_t ); Slot to set the global line width. void DoHideAllRanges(Bool_t ); Slot to hide all the ranges. void DoHistBinning(); Slot to set the axes histogram binning. void DoHistColorSelect(Pixel_t ); Slot to set the histograms color. void DoHistShowBoxes(Bool_t ); Slot to set histogram height. void DoHistPatternSelect(Style_t ); Slot to set the histograms fill style. void DoHistWidth(); Slot to set histogram width. void DoLineType(); Slot to set the line type. void DoLiveDotsSpacing(Int_t a); Slot to set the dots spacing online. void DoLiveAlpha(Int_t a); Slot to set alpha value online. void DoLiveEntriesToDraw(); Slot to update the entries fields from the slider position. void DoLiveWeightCut(Int_t n); Slot to update the wieght cut entry field from the slider position. void DoNentries(); Slot to set the number of entries to display. void DoPaintEntries(Bool_t ); Slot to postpone the entries drawing. void DoSelectLineColor(Pixel_t ); Slot to set the line color of selection. void DoSelectLineWidth(Int_t ); Slot to set the line width of selection. void DoSelectionSelect(const char* title); Slot to set the selection beeing edited. void DoShowRanges(Bool_t s); Slot to show or not the ranges on the pad. void DoUnApply(); Slot to reset the tree entry list to the original one. void DoVariableSelect(const char* var); Slot to select a variable. void DoWeightCut(); Slot to update the weight cut. void SetModel(TObject* obj); Pick up the used parallel coordinates plot attributes. TParallelCoordEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: Bastien Dalla Piazza 02/08/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/treeviewer:$Id$ » Last generated: 2015-06-02 16:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TParallelCoordEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordEditor.html
https://root.cern/root/html604/TParallelCoordRange.html:1533,Availability,error,error,1533,"ar* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBringOnTop()MENU ; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(const Option_t* options = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* options = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t entry, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Double_tGetMax(); virtual Double_tGetMin(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TParallelCoordSelect*GetSelection(); virtual const char*TNamed::GetTitle() const; vi",MatchSource.WIKI,root/html604/TParallelCoordRange.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordRange.html
https://root.cern/root/html604/TParallelCoordRange.html:1617,Availability,error,error,1617,"idBringOnTop()MENU ; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(const Option_t* options = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* options = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t entry, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Double_tGetMax(); virtual Double_tGetMin(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TParallelCoordSelect*GetSelection(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TParallelCoordVar*GetVar(); virtual Bool_t",MatchSource.WIKI,root/html604/TParallelCoordRange.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordRange.html
https://root.cern/root/html604/TParallelCoordSelect.html:2696,Availability,error,error,2696,"; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTList::Delete(Option_t* option = """"); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TList::FindObject(const char* name) const; virtual TObject*TList::FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(I",MatchSource.WIKI,root/html604/TParallelCoordSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordSelect.html
https://root.cern/root/html604/TParallelCoordSelect.html:2780,Availability,error,error,2780,"e(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTList::Delete(Option_t* option = """"); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TList::FindObject(const char* name) const; virtual TObject*TList::FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**TList::GetObjectRef(const TObject* obj) c",MatchSource.WIKI,root/html604/TParallelCoordSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordSelect.html
https://root.cern/root/html604/TParallelCoordSelect.html:11238,Performance,cache,cache,11238,"ity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TParallelCoordSelect::(anonymous)kShowRanges; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static TCollection::(anonymous)TCollection::kIsOwner. private:. TStringfTitleTitle of the selection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParallelCoordSelect(); Default constructor. TParallelCoordSelect(const char* title); Normal constructor. ~TParallelCoordSelect(); Destructor. void SetActivated(Bool_t on); Activate the selection. void SetShowRanges(Bool_t s); Show the ranges niddles. TParallelCoordSelect(). const char* GetTitle() const; {return fTitle.Data();}. void SetTitle(const char* title); {fTitle = title;}. » Author: Bastien Dalla Piazza 02/08/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/treeviewer:$Id$ » Last generated",MatchSource.WIKI,root/html604/TParallelCoordSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordSelect.html
https://root.cern/root/html604/TParallelCoordVar.html:866,Availability,avail,available,866,". TParallelCoordVar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TParallelCoordVar. class TParallelCoordVar: public TNamed, public TAttLine, public TAttFill. Axes:. Class containing a variable for the TParallelCoord. Options can be defined each axis separatly using the right mouse click. These options can be applied to every axes using the editor. Axis width: If set to 0, the axis is simply a line. If higher, a color histogram is drawn on the axis.; Axis histogram height: If not 0, a usual bar histogram is drawn on the plot. The order in which the variables are drawn is essential to see the clusters. The axes can be dragged to change their position. A zoom is also available. The logarithm scale is also available by right clicking on the axis. Function Members (Methods); public:. virtual~TParallelCoordVar(); voidTObject::AbstractMethod(const char* method) const; voidAddRange()MENU ; voidAddRange(TParallelCoordRange* range); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteVariable()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method,",MatchSource.WIKI,root/html604/TParallelCoordVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordVar.html
https://root.cern/root/html604/TParallelCoordVar.html:905,Availability,avail,available,905,". TParallelCoordVar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TParallelCoordVar. class TParallelCoordVar: public TNamed, public TAttLine, public TAttFill. Axes:. Class containing a variable for the TParallelCoord. Options can be defined each axis separatly using the right mouse click. These options can be applied to every axes using the editor. Axis width: If set to 0, the axis is simply a line. If higher, a color histogram is drawn on the axis.; Axis histogram height: If not 0, a usual bar histogram is drawn on the plot. The order in which the variables are drawn is essential to see the clusters. The axes can be dragged to change their position. A zoom is also available. The logarithm scale is also available by right clicking on the axis. Function Members (Methods); public:. virtual~TParallelCoordVar(); voidTObject::AbstractMethod(const char* method) const; voidAddRange()MENU ; voidAddRange(TParallelCoordRange* range); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteVariable()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method,",MatchSource.WIKI,root/html604/TParallelCoordVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordVar.html
https://root.cern/root/html604/TParallelCoordVar.html:2164,Availability,error,error,2164,"_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteVariable()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Bool_tEval(Long64_t evtidx, TParallelCoordSelect* select); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t entry, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetBarHisto(); Bool_tGetBoxPlot(); Double_tGetCurrentAverage() const; Double_tGetCurrentMax() const; Double_tGetCurrentMin() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntryWeight(Long64_t evtidx); voidGetEntryXY(Long64_t n, Double_t& x, Double_t& y); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; Int_tGetHistBinning() const; Double_tGetHistHeight(); Int_tGetHistLineWidth(); TH1F*GetHistogram(); virtual const char*TObject::GetIconName() const; Int_tGetId(); virtual Color_tTAttLine::GetLi",MatchSource.WIKI,root/html604/TParallelCoordVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordVar.html
https://root.cern/root/html604/TParallelCoordVar.html:2248,Availability,error,error,2248,"irtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteVariable()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Bool_tEval(Long64_t evtidx, TParallelCoordSelect* select); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t entry, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetBarHisto(); Bool_tGetBoxPlot(); Double_tGetCurrentAverage() const; Double_tGetCurrentMax() const; Double_tGetCurrentMin() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntryWeight(Long64_t evtidx); voidGetEntryXY(Long64_t n, Double_t& x, Double_t& y); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; Int_tGetHistBinning() const; Double_tGetHistHeight(); Int_tGetHistLineWidth(); TH1F*GetHistogram(); virtual const char*TObject::GetIconName() const; Int_tGetId(); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttL",MatchSource.WIKI,root/html604/TParallelCoordVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordVar.html
https://root.cern/root/html604/TParallelCoordVar.html:13656,Deployability,update,updated,13656,"aint the boxes in the case of a candle chart. void PaintHistogram(); Paint the histogram on the axis. void PaintLabels(); Paint the axis labels and titles. void Print(Option_t* option = """") const; Print the axis main datas. void SavePrimitive(ostream& out, Option_t* options); Save the TParallelCoordVar as a macro. Can be used only in the context; of TParallelCoord::SavePrimitive (pointer ""TParallelCoord* para"" is; defined in TParallelCoord::SavePrimitive) with the option ""pcalled"". void SetBoxPlot(Bool_t box); Set the axis to display a candle. void SetHistogramBinning(Int_t n = 100); Set the histogram binning. void SetHistogramHeight(Double_t h = 0); Set the height of the bar histogram. void SetCurrentMin(Double_t min); Set the current minimum of the axis. void SetCurrentMax(Double_t max); Set the current maximum of the axis. void SetCurrentLimits(Double_t min, Double_t max); Set the limits within which one the entries must be painted. void SetLiveRangesUpdate(Bool_t on); If true, the pad is updated while the motion of a dragged range. void SetLogScale(Bool_t log); Set the axis in logscale. void SetValues(Long64_t length, Double_t* val); Set the variable values. void SetX(Double_t x, Bool_t gl); Set the X position of the axis in the case of a vertical axis.; and rotate the axis if it was horizontal. void SetY(Double_t y, Bool_t gl); Set the Y position of the axis in the case of a horizontal axis.; and rotate the axis if it was vertical. TParallelCoordVar(). void AddRange(TParallelCoordRange* range). Bool_t GetBarHisto(); {return TestBit(kShowBarHisto);}. Bool_t GetBoxPlot(); {return TestBit(kShowBox);}. Int_t GetId(); {return fId;}. Bool_t GetLogScale() const; {return TestBit (kLogScale);}. Int_t GetHistBinning() const; {return fNbins;}. Double_t GetCurrentMin() const; {return fMinCurrent;}. Double_t GetCurrentMax() const; {return fMaxCurrent;}. Double_t GetCurrentAverage() const; {return fMean;}. Double_t GetHistHeight(); {return fHistoHeight;}. Int_t GetHistLineWi",MatchSource.WIKI,root/html604/TParallelCoordVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordVar.html
https://root.cern/root/html604/TParallelCoordVar.html:377,Modifiability,variab,variable,377,". TParallelCoordVar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TParallelCoordVar. class TParallelCoordVar: public TNamed, public TAttLine, public TAttFill. Axes:. Class containing a variable for the TParallelCoord. Options can be defined each axis separatly using the right mouse click. These options can be applied to every axes using the editor. Axis width: If set to 0, the axis is simply a line. If higher, a color histogram is drawn on the axis.; Axis histogram height: If not 0, a usual bar histogram is drawn on the plot. The order in which the variables are drawn is essential to see the clusters. The axes can be dragged to change their position. A zoom is also available. The logarithm scale is also available by right clicking on the axis. Function Members (Methods); public:. virtual~TParallelCoordVar(); voidTObject::AbstractMethod(const char* method) const; voidAddRange()MENU ; voidAddRange(TParallelCoordRange* range); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteVariable()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method,",MatchSource.WIKI,root/html604/TParallelCoordVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordVar.html
https://root.cern/root/html604/TParallelCoordVar.html:747,Modifiability,variab,variables,747,". TParallelCoordVar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TParallelCoordVar. class TParallelCoordVar: public TNamed, public TAttLine, public TAttFill. Axes:. Class containing a variable for the TParallelCoord. Options can be defined each axis separatly using the right mouse click. These options can be applied to every axes using the editor. Axis width: If set to 0, the axis is simply a line. If higher, a color histogram is drawn on the axis.; Axis histogram height: If not 0, a usual bar histogram is drawn on the plot. The order in which the variables are drawn is essential to see the clusters. The axes can be dragged to change their position. A zoom is also available. The logarithm scale is also available by right clicking on the axis. Function Members (Methods); public:. virtual~TParallelCoordVar(); voidTObject::AbstractMethod(const char* method) const; voidAddRange()MENU ; voidAddRange(TParallelCoordRange* range); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteVariable()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method,",MatchSource.WIKI,root/html604/TParallelCoordVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordVar.html
https://root.cern/root/html604/TParallelCoordVar.html:9879,Modifiability,variab,variable,9879,StatusBitsTObject::kIsReferenced; static TParallelCoordVar::(anonymous)kLogScale; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TParallelCoordVar::(anonymous)kShowBarHisto; static TParallelCoordVar::(anonymous)kShowBox; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfHistoHeightHistogram Height.; Int_tfHistoLWLine width used to draw the histogram line.; TH1F*fHistogram! Histogram holding the variable distribution.; Int_tfIdId identifying the variable for the editor.; Double_tfMaxCurrentCurrent used maximum.; Double_tfMaxInitMemory of the maximum when first initialized.; Double_tfMeanAverage.; Double_tfMedMedian value (Q2).; Double_tfMinCurrentCurrent used minimum.; Double_tfMinInitMemory of the minimum when first initialized.; Int_tfNbinsNumber of bins in fHistogram.; Long64_tfNentriesNumber of stored entries values.; TParallelCoord*fParallelPointer to the TParallelCoord which owns the TParallelCoordVar.; Double_tfQua1First quantile (Q1).; Double_tfQua3Third quantile (Q3).; TList*fRangesList of the TParallelRange owned by TParallelCoordVar.; Double_t*fVal![fNentries] Entries values for the variable.; Double_tfX1x1 coordinate of the axis.; Double_tfX2x2 coordinate of the axis.; Double_tfY1y1 coordinate of the axis.; Double_tfY2y2 coordinate of the axis. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParallelCoordVar(); D,MatchSource.WIKI,root/html604/TParallelCoordVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordVar.html
https://root.cern/root/html604/TParallelCoordVar.html:9930,Modifiability,variab,variable,9930,::(anonymous)kLogScale; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TParallelCoordVar::(anonymous)kShowBarHisto; static TParallelCoordVar::(anonymous)kShowBox; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfHistoHeightHistogram Height.; Int_tfHistoLWLine width used to draw the histogram line.; TH1F*fHistogram! Histogram holding the variable distribution.; Int_tfIdId identifying the variable for the editor.; Double_tfMaxCurrentCurrent used maximum.; Double_tfMaxInitMemory of the maximum when first initialized.; Double_tfMeanAverage.; Double_tfMedMedian value (Q2).; Double_tfMinCurrentCurrent used minimum.; Double_tfMinInitMemory of the minimum when first initialized.; Int_tfNbinsNumber of bins in fHistogram.; Long64_tfNentriesNumber of stored entries values.; TParallelCoord*fParallelPointer to the TParallelCoord which owns the TParallelCoordVar.; Double_tfQua1First quantile (Q1).; Double_tfQua3Third quantile (Q3).; TList*fRangesList of the TParallelRange owned by TParallelCoordVar.; Double_t*fVal![fNentries] Entries values for the variable.; Double_tfX1x1 coordinate of the axis.; Double_tfX2x2 coordinate of the axis.; Double_tfY1y1 coordinate of the axis.; Double_tfY2y2 coordinate of the axis. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParallelCoordVar(); Default constructor. ~TParallelCoordVar(); Destructor. TPar,MatchSource.WIKI,root/html604/TParallelCoordVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordVar.html
https://root.cern/root/html604/TParallelCoordVar.html:10591,Modifiability,variab,variable,10591,"ine color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfHistoHeightHistogram Height.; Int_tfHistoLWLine width used to draw the histogram line.; TH1F*fHistogram! Histogram holding the variable distribution.; Int_tfIdId identifying the variable for the editor.; Double_tfMaxCurrentCurrent used maximum.; Double_tfMaxInitMemory of the maximum when first initialized.; Double_tfMeanAverage.; Double_tfMedMedian value (Q2).; Double_tfMinCurrentCurrent used minimum.; Double_tfMinInitMemory of the minimum when first initialized.; Int_tfNbinsNumber of bins in fHistogram.; Long64_tfNentriesNumber of stored entries values.; TParallelCoord*fParallelPointer to the TParallelCoord which owns the TParallelCoordVar.; Double_tfQua1First quantile (Q1).; Double_tfQua3Third quantile (Q3).; TList*fRangesList of the TParallelRange owned by TParallelCoordVar.; Double_t*fVal![fNentries] Entries values for the variable.; Double_tfX1x1 coordinate of the axis.; Double_tfX2x2 coordinate of the axis.; Double_tfY1y1 coordinate of the axis.; Double_tfY2y2 coordinate of the axis. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParallelCoordVar(); Default constructor. ~TParallelCoordVar(); Destructor. TParallelCoordVar(Double_t* val, const char* title, Int_t id, TParallelCoord* gram); Normal constructor. By default, the title and the name are the expression given to TTree::Draw. The name; can be changed by the user (the label on the plot) but not the title. void AddRange(TParallelCoordRange* range); Add a range to the current selection on the axis. void DeleteVariable(); Delete variables. Int_t DistancetoPrimitive(Int_t px, Int_t py); Computes the distance from the axis. void Draw(Option_t* option = """"); Draw the axis. Bool_t Eval(Long64_t evtidx, TParallelCoordSelect* select); Check if the entry is within the range(s) of ""select"". Two",MatchSource.WIKI,root/html604/TParallelCoordVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordVar.html
https://root.cern/root/html604/TParallelCoordVar.html:11308,Modifiability,variab,variables,11308,"entries values.; TParallelCoord*fParallelPointer to the TParallelCoord which owns the TParallelCoordVar.; Double_tfQua1First quantile (Q1).; Double_tfQua3Third quantile (Q3).; TList*fRangesList of the TParallelRange owned by TParallelCoordVar.; Double_t*fVal![fNentries] Entries values for the variable.; Double_tfX1x1 coordinate of the axis.; Double_tfX2x2 coordinate of the axis.; Double_tfY1y1 coordinate of the axis.; Double_tfY2y2 coordinate of the axis. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParallelCoordVar(); Default constructor. ~TParallelCoordVar(); Destructor. TParallelCoordVar(Double_t* val, const char* title, Int_t id, TParallelCoord* gram); Normal constructor. By default, the title and the name are the expression given to TTree::Draw. The name; can be changed by the user (the label on the plot) but not the title. void AddRange(TParallelCoordRange* range); Add a range to the current selection on the axis. void DeleteVariable(); Delete variables. Int_t DistancetoPrimitive(Int_t px, Int_t py); Computes the distance from the axis. void Draw(Option_t* option = """"); Draw the axis. Bool_t Eval(Long64_t evtidx, TParallelCoordSelect* select); Check if the entry is within the range(s) of ""select"". Two ranges on a single; axis are conjugated as a ""or"": to be selected, the entry must be in one of; the ranges. void ExecuteEvent(Int_t entry, Int_t px, Int_t py); Execute the corresponding entry. void GetEntryXY(Long64_t n, Double_t& x, Double_t& y); Get the position of the variable on the graph for the n'th entry. Int_t GetEntryWeight(Long64_t evtidx); Get the entry weight: The weight of an entry for a given variable; is the bin content of the histogram bin the entry is going through. TH1F* GetHistogram(); Create or recreate the histogram. void GetMinMaxMean(); Get mean, min and max of thos variable. char* GetObjectInfo(Int_t px, Int_t py) const; Returns info about this axis. void GetQuantiles(); Get the box plot values",MatchSource.WIKI,root/html604/TParallelCoordVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordVar.html
https://root.cern/root/html604/TParallelCoordVar.html:11843,Modifiability,variab,variable,11843," Function documentation; TParallelCoordVar(); Default constructor. ~TParallelCoordVar(); Destructor. TParallelCoordVar(Double_t* val, const char* title, Int_t id, TParallelCoord* gram); Normal constructor. By default, the title and the name are the expression given to TTree::Draw. The name; can be changed by the user (the label on the plot) but not the title. void AddRange(TParallelCoordRange* range); Add a range to the current selection on the axis. void DeleteVariable(); Delete variables. Int_t DistancetoPrimitive(Int_t px, Int_t py); Computes the distance from the axis. void Draw(Option_t* option = """"); Draw the axis. Bool_t Eval(Long64_t evtidx, TParallelCoordSelect* select); Check if the entry is within the range(s) of ""select"". Two ranges on a single; axis are conjugated as a ""or"": to be selected, the entry must be in one of; the ranges. void ExecuteEvent(Int_t entry, Int_t px, Int_t py); Execute the corresponding entry. void GetEntryXY(Long64_t n, Double_t& x, Double_t& y); Get the position of the variable on the graph for the n'th entry. Int_t GetEntryWeight(Long64_t evtidx); Get the entry weight: The weight of an entry for a given variable; is the bin content of the histogram bin the entry is going through. TH1F* GetHistogram(); Create or recreate the histogram. void GetMinMaxMean(); Get mean, min and max of thos variable. char* GetObjectInfo(Int_t px, Int_t py) const; Returns info about this axis. void GetQuantiles(); Get the box plot values (quantiles). Double_t GetValuefromXY(Double_t x, Double_t y); Get the value corresponding to the posiiton. void GetXYfromValue(Double_t value, Double_t& x, Double_t& y); Get a position corresponding to the value on the axis. void Init(); Initialise the TParallelVar variables. void Paint(Option_t* option = """"); Paint the axis. void PaintBoxPlot(); Paint the boxes in the case of a candle chart. void PaintHistogram(); Paint the histogram on the axis. void PaintLabels(); Paint the axis labels and titles. void Print(Option_t",MatchSource.WIKI,root/html604/TParallelCoordVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordVar.html
https://root.cern/root/html604/TParallelCoordVar.html:11981,Modifiability,variab,variable,11981,"tle, Int_t id, TParallelCoord* gram); Normal constructor. By default, the title and the name are the expression given to TTree::Draw. The name; can be changed by the user (the label on the plot) but not the title. void AddRange(TParallelCoordRange* range); Add a range to the current selection on the axis. void DeleteVariable(); Delete variables. Int_t DistancetoPrimitive(Int_t px, Int_t py); Computes the distance from the axis. void Draw(Option_t* option = """"); Draw the axis. Bool_t Eval(Long64_t evtidx, TParallelCoordSelect* select); Check if the entry is within the range(s) of ""select"". Two ranges on a single; axis are conjugated as a ""or"": to be selected, the entry must be in one of; the ranges. void ExecuteEvent(Int_t entry, Int_t px, Int_t py); Execute the corresponding entry. void GetEntryXY(Long64_t n, Double_t& x, Double_t& y); Get the position of the variable on the graph for the n'th entry. Int_t GetEntryWeight(Long64_t evtidx); Get the entry weight: The weight of an entry for a given variable; is the bin content of the histogram bin the entry is going through. TH1F* GetHistogram(); Create or recreate the histogram. void GetMinMaxMean(); Get mean, min and max of thos variable. char* GetObjectInfo(Int_t px, Int_t py) const; Returns info about this axis. void GetQuantiles(); Get the box plot values (quantiles). Double_t GetValuefromXY(Double_t x, Double_t y); Get the value corresponding to the posiiton. void GetXYfromValue(Double_t value, Double_t& x, Double_t& y); Get a position corresponding to the value on the axis. void Init(); Initialise the TParallelVar variables. void Paint(Option_t* option = """"); Paint the axis. void PaintBoxPlot(); Paint the boxes in the case of a candle chart. void PaintHistogram(); Paint the histogram on the axis. void PaintLabels(); Paint the axis labels and titles. void Print(Option_t* option = """") const; Print the axis main datas. void SavePrimitive(ostream& out, Option_t* options); Save the TParallelCoordVar as a macro. Can be",MatchSource.WIKI,root/html604/TParallelCoordVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordVar.html
https://root.cern/root/html604/TParallelCoordVar.html:12167,Modifiability,variab,variable,12167,"e label on the plot) but not the title. void AddRange(TParallelCoordRange* range); Add a range to the current selection on the axis. void DeleteVariable(); Delete variables. Int_t DistancetoPrimitive(Int_t px, Int_t py); Computes the distance from the axis. void Draw(Option_t* option = """"); Draw the axis. Bool_t Eval(Long64_t evtidx, TParallelCoordSelect* select); Check if the entry is within the range(s) of ""select"". Two ranges on a single; axis are conjugated as a ""or"": to be selected, the entry must be in one of; the ranges. void ExecuteEvent(Int_t entry, Int_t px, Int_t py); Execute the corresponding entry. void GetEntryXY(Long64_t n, Double_t& x, Double_t& y); Get the position of the variable on the graph for the n'th entry. Int_t GetEntryWeight(Long64_t evtidx); Get the entry weight: The weight of an entry for a given variable; is the bin content of the histogram bin the entry is going through. TH1F* GetHistogram(); Create or recreate the histogram. void GetMinMaxMean(); Get mean, min and max of thos variable. char* GetObjectInfo(Int_t px, Int_t py) const; Returns info about this axis. void GetQuantiles(); Get the box plot values (quantiles). Double_t GetValuefromXY(Double_t x, Double_t y); Get the value corresponding to the posiiton. void GetXYfromValue(Double_t value, Double_t& x, Double_t& y); Get a position corresponding to the value on the axis. void Init(); Initialise the TParallelVar variables. void Paint(Option_t* option = """"); Paint the axis. void PaintBoxPlot(); Paint the boxes in the case of a candle chart. void PaintHistogram(); Paint the histogram on the axis. void PaintLabels(); Paint the axis labels and titles. void Print(Option_t* option = """") const; Print the axis main datas. void SavePrimitive(ostream& out, Option_t* options); Save the TParallelCoordVar as a macro. Can be used only in the context; of TParallelCoord::SavePrimitive (pointer ""TParallelCoord* para"" is; defined in TParallelCoord::SavePrimitive) with the option ""pcalled"". void SetB",MatchSource.WIKI,root/html604/TParallelCoordVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordVar.html
https://root.cern/root/html604/TParallelCoordVar.html:12565,Modifiability,variab,variables,12565,"e(s) of ""select"". Two ranges on a single; axis are conjugated as a ""or"": to be selected, the entry must be in one of; the ranges. void ExecuteEvent(Int_t entry, Int_t px, Int_t py); Execute the corresponding entry. void GetEntryXY(Long64_t n, Double_t& x, Double_t& y); Get the position of the variable on the graph for the n'th entry. Int_t GetEntryWeight(Long64_t evtidx); Get the entry weight: The weight of an entry for a given variable; is the bin content of the histogram bin the entry is going through. TH1F* GetHistogram(); Create or recreate the histogram. void GetMinMaxMean(); Get mean, min and max of thos variable. char* GetObjectInfo(Int_t px, Int_t py) const; Returns info about this axis. void GetQuantiles(); Get the box plot values (quantiles). Double_t GetValuefromXY(Double_t x, Double_t y); Get the value corresponding to the posiiton. void GetXYfromValue(Double_t value, Double_t& x, Double_t& y); Get a position corresponding to the value on the axis. void Init(); Initialise the TParallelVar variables. void Paint(Option_t* option = """"); Paint the axis. void PaintBoxPlot(); Paint the boxes in the case of a candle chart. void PaintHistogram(); Paint the histogram on the axis. void PaintLabels(); Paint the axis labels and titles. void Print(Option_t* option = """") const; Print the axis main datas. void SavePrimitive(ostream& out, Option_t* options); Save the TParallelCoordVar as a macro. Can be used only in the context; of TParallelCoord::SavePrimitive (pointer ""TParallelCoord* para"" is; defined in TParallelCoord::SavePrimitive) with the option ""pcalled"". void SetBoxPlot(Bool_t box); Set the axis to display a candle. void SetHistogramBinning(Int_t n = 100); Set the histogram binning. void SetHistogramHeight(Double_t h = 0); Set the height of the bar histogram. void SetCurrentMin(Double_t min); Set the current minimum of the axis. void SetCurrentMax(Double_t max); Set the current maximum of the axis. void SetCurrentLimits(Double_t min, Double_t max); Set the lim",MatchSource.WIKI,root/html604/TParallelCoordVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordVar.html
https://root.cern/root/html604/TParallelCoordVar.html:13813,Modifiability,variab,variable,13813," and titles. void Print(Option_t* option = """") const; Print the axis main datas. void SavePrimitive(ostream& out, Option_t* options); Save the TParallelCoordVar as a macro. Can be used only in the context; of TParallelCoord::SavePrimitive (pointer ""TParallelCoord* para"" is; defined in TParallelCoord::SavePrimitive) with the option ""pcalled"". void SetBoxPlot(Bool_t box); Set the axis to display a candle. void SetHistogramBinning(Int_t n = 100); Set the histogram binning. void SetHistogramHeight(Double_t h = 0); Set the height of the bar histogram. void SetCurrentMin(Double_t min); Set the current minimum of the axis. void SetCurrentMax(Double_t max); Set the current maximum of the axis. void SetCurrentLimits(Double_t min, Double_t max); Set the limits within which one the entries must be painted. void SetLiveRangesUpdate(Bool_t on); If true, the pad is updated while the motion of a dragged range. void SetLogScale(Bool_t log); Set the axis in logscale. void SetValues(Long64_t length, Double_t* val); Set the variable values. void SetX(Double_t x, Bool_t gl); Set the X position of the axis in the case of a vertical axis.; and rotate the axis if it was horizontal. void SetY(Double_t y, Bool_t gl); Set the Y position of the axis in the case of a horizontal axis.; and rotate the axis if it was vertical. TParallelCoordVar(). void AddRange(TParallelCoordRange* range). Bool_t GetBarHisto(); {return TestBit(kShowBarHisto);}. Bool_t GetBoxPlot(); {return TestBit(kShowBox);}. Int_t GetId(); {return fId;}. Bool_t GetLogScale() const; {return TestBit (kLogScale);}. Int_t GetHistBinning() const; {return fNbins;}. Double_t GetCurrentMin() const; {return fMinCurrent;}. Double_t GetCurrentMax() const; {return fMaxCurrent;}. Double_t GetCurrentAverage() const; {return fMean;}. Double_t GetHistHeight(); {return fHistoHeight;}. Int_t GetHistLineWidth(); {return fHistoLW;}. Double_t GetX(); {return fX1;}. Double_t GetY(); {return fY1;}. Int_t GetNbins(); {return fNbins;}. Long64_t GetNentr",MatchSource.WIKI,root/html604/TParallelCoordVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordVar.html
https://root.cern/root/html604/TParallelCoordVar.html:881,Testability,log,logarithm,881,". TParallelCoordVar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TParallelCoordVar. class TParallelCoordVar: public TNamed, public TAttLine, public TAttFill. Axes:. Class containing a variable for the TParallelCoord. Options can be defined each axis separatly using the right mouse click. These options can be applied to every axes using the editor. Axis width: If set to 0, the axis is simply a line. If higher, a color histogram is drawn on the axis.; Axis histogram height: If not 0, a usual bar histogram is drawn on the plot. The order in which the variables are drawn is essential to see the clusters. The axes can be dragged to change their position. A zoom is also available. The logarithm scale is also available by right clicking on the axis. Function Members (Methods); public:. virtual~TParallelCoordVar(); voidTObject::AbstractMethod(const char* method) const; voidAddRange()MENU ; voidAddRange(TParallelCoordRange* range); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteVariable()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method,",MatchSource.WIKI,root/html604/TParallelCoordVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordVar.html
https://root.cern/root/html604/TParallelCoordVar.html:7210,Testability,log,log,7210,"LE GETTER ; voidSetCurrentLimits(Double_t min, Double_t max)MENU ; voidSetCurrentMax(Double_t max); voidSetCurrentMin(Double_t min); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); voidSetHistogramBinning(Int_t n = 100)MENU ; voidSetHistogramHeight(Double_t h = 0)MENU ; voidSetHistogramLineWidth(Int_t lw = 2)MENU ; voidSetInitMax(Double_t max); voidSetInitMin(Double_t min); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); voidSetLiveRangesUpdate(Bool_t on); voidSetLogScale(Bool_t log)TOGGLE GETTER ; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetTitle(const char*); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetValues(Long64_t length, Double_t* val); voidSetX(Double_t x, Bool_t gl); voidSetY(Double_t y, Bool_t gl); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TParallelCoordVar(); TParallelCoordVar(const TParallelCoordVar&); TParallelCoordVar(Double_t* val, const char* title, Int_t id, TParallelCoord* gram); voidUnzoom()MENU ; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfm",MatchSource.WIKI,root/html604/TParallelCoordVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordVar.html
https://root.cern/root/html604/TParallelCoordVar.html:13725,Testability,log,log,13725,"histogram on the axis. void PaintLabels(); Paint the axis labels and titles. void Print(Option_t* option = """") const; Print the axis main datas. void SavePrimitive(ostream& out, Option_t* options); Save the TParallelCoordVar as a macro. Can be used only in the context; of TParallelCoord::SavePrimitive (pointer ""TParallelCoord* para"" is; defined in TParallelCoord::SavePrimitive) with the option ""pcalled"". void SetBoxPlot(Bool_t box); Set the axis to display a candle. void SetHistogramBinning(Int_t n = 100); Set the histogram binning. void SetHistogramHeight(Double_t h = 0); Set the height of the bar histogram. void SetCurrentMin(Double_t min); Set the current minimum of the axis. void SetCurrentMax(Double_t max); Set the current maximum of the axis. void SetCurrentLimits(Double_t min, Double_t max); Set the limits within which one the entries must be painted. void SetLiveRangesUpdate(Bool_t on); If true, the pad is updated while the motion of a dragged range. void SetLogScale(Bool_t log); Set the axis in logscale. void SetValues(Long64_t length, Double_t* val); Set the variable values. void SetX(Double_t x, Bool_t gl); Set the X position of the axis in the case of a vertical axis.; and rotate the axis if it was horizontal. void SetY(Double_t y, Bool_t gl); Set the Y position of the axis in the case of a horizontal axis.; and rotate the axis if it was vertical. TParallelCoordVar(). void AddRange(TParallelCoordRange* range). Bool_t GetBarHisto(); {return TestBit(kShowBarHisto);}. Bool_t GetBoxPlot(); {return TestBit(kShowBox);}. Int_t GetId(); {return fId;}. Bool_t GetLogScale() const; {return TestBit (kLogScale);}. Int_t GetHistBinning() const; {return fNbins;}. Double_t GetCurrentMin() const; {return fMinCurrent;}. Double_t GetCurrentMax() const; {return fMaxCurrent;}. Double_t GetCurrentAverage() const; {return fMean;}. Double_t GetHistHeight(); {return fHistoHeight;}. Int_t GetHistLineWidth(); {return fHistoLW;}. Double_t GetX(); {return fX1;}. Double_t GetY(); {re",MatchSource.WIKI,root/html604/TParallelCoordVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordVar.html
https://root.cern/root/html604/TParallelCoordVar.html:13747,Testability,log,logscale,13747,"histogram on the axis. void PaintLabels(); Paint the axis labels and titles. void Print(Option_t* option = """") const; Print the axis main datas. void SavePrimitive(ostream& out, Option_t* options); Save the TParallelCoordVar as a macro. Can be used only in the context; of TParallelCoord::SavePrimitive (pointer ""TParallelCoord* para"" is; defined in TParallelCoord::SavePrimitive) with the option ""pcalled"". void SetBoxPlot(Bool_t box); Set the axis to display a candle. void SetHistogramBinning(Int_t n = 100); Set the histogram binning. void SetHistogramHeight(Double_t h = 0); Set the height of the bar histogram. void SetCurrentMin(Double_t min); Set the current minimum of the axis. void SetCurrentMax(Double_t max); Set the current maximum of the axis. void SetCurrentLimits(Double_t min, Double_t max); Set the limits within which one the entries must be painted. void SetLiveRangesUpdate(Bool_t on); If true, the pad is updated while the motion of a dragged range. void SetLogScale(Bool_t log); Set the axis in logscale. void SetValues(Long64_t length, Double_t* val); Set the variable values. void SetX(Double_t x, Bool_t gl); Set the X position of the axis in the case of a vertical axis.; and rotate the axis if it was horizontal. void SetY(Double_t y, Bool_t gl); Set the Y position of the axis in the case of a horizontal axis.; and rotate the axis if it was vertical. TParallelCoordVar(). void AddRange(TParallelCoordRange* range). Bool_t GetBarHisto(); {return TestBit(kShowBarHisto);}. Bool_t GetBoxPlot(); {return TestBit(kShowBox);}. Int_t GetId(); {return fId;}. Bool_t GetLogScale() const; {return TestBit (kLogScale);}. Int_t GetHistBinning() const; {return fNbins;}. Double_t GetCurrentMin() const; {return fMinCurrent;}. Double_t GetCurrentMax() const; {return fMaxCurrent;}. Double_t GetCurrentAverage() const; {return fMean;}. Double_t GetHistHeight(); {return fHistoHeight;}. Int_t GetHistLineWidth(); {return fHistoLW;}. Double_t GetX(); {return fX1;}. Double_t GetY(); {re",MatchSource.WIKI,root/html604/TParallelCoordVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordVar.html
https://root.cern/root/html604/TParallelCoordVar.html:580,Usability,simpl,simply,580,". TParallelCoordVar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TParallelCoordVar. class TParallelCoordVar: public TNamed, public TAttLine, public TAttFill. Axes:. Class containing a variable for the TParallelCoord. Options can be defined each axis separatly using the right mouse click. These options can be applied to every axes using the editor. Axis width: If set to 0, the axis is simply a line. If higher, a color histogram is drawn on the axis.; Axis histogram height: If not 0, a usual bar histogram is drawn on the plot. The order in which the variables are drawn is essential to see the clusters. The axes can be dragged to change their position. A zoom is also available. The logarithm scale is also available by right clicking on the axis. Function Members (Methods); public:. virtual~TParallelCoordVar(); voidTObject::AbstractMethod(const char* method) const; voidAddRange()MENU ; voidAddRange(TParallelCoordRange* range); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteVariable()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method,",MatchSource.WIKI,root/html604/TParallelCoordVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelCoordVar.html
https://root.cern/root/html604/TParallelMergingFile.html:3486,Availability,error,error,3486,"ateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle, const size_t namesize = 0); virtual voidTFile::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTFile::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTFile::DrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTFile::FillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidTFile::Flush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*TFile::GetArchive() const; Long64_tTFile::GetArchiveOffset() const; static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(TFileOpenH",MatchSource.WIKI,root/html604/TParallelMergingFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelMergingFile.html
https://root.cern/root/html604/TParallelMergingFile.html:3570,Availability,error,error,3570,"t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle, const size_t namesize = 0); virtual voidTFile::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTFile::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTFile::DrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTFile::FillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidTFile::Flush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*TFile::GetArchive() const; Long64_tTFile::GetArchiveOffset() const; static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(TFileOpenHandle* handle); Int_tTFile::GetBestBuffer() const; virtual Int_tTDirectoryFile::GetB",MatchSource.WIKI,root/html604/TParallelMergingFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelMergingFile.html
https://root.cern/root/html604/TParallelMergingFile.html:25040,Integrability,rout,routine,25040,"ntRecord which StreamerInfo we already sent.; TMessagefMessage; Int_tfServerIdxIndex of this socket/file on the server.; TUrlfServerLocationUrl of the server.; Int_tfServerVersionProtocol version used by the server.; TSocket*fSocketSocket to the parallel file merger server. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParallelMergingFile(const char* filename, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Constructor.; We do no yet open any connection to the server. This will be done at the; time the first upload will be requested. ~TParallelMergingFile(); Destructor. void Close(Option_t* option = """"). Bool_t UploadAndReset(); Upload the current file data to the merging server.; Reset the file and return true in case of success. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file and upload them to the parallel merge server.; Then reset all the resetable object (those with a ResetAfterMerge routine,; like TTree). Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (bytes 1->fBEGIN). Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0) const; One can not save a const TDirectory object. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TParallelMergingFile(const char* filename, Option_t* option = """", const char* ftitle = """", Int_t compress = 1). » Author: Philippe Canal October 2011. » Copyright (C) 1995-2011, Rene Brun, Fons Rademakers and al. *; » Last chang",MatchSource.WIKI,root/html604/TParallelMergingFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelMergingFile.html
https://root.cern/root/html604/TParallelMergingFile.html:12293,Performance,cache,cacheDir,12293,"e); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); virtual voidTMemFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTMemFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetO",MatchSource.WIKI,root/html604/TParallelMergingFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelMergingFile.html
https://root.cern/root/html604/TParallelMergingFile.html:12420,Performance,cache,cache,12420,"Object*); virtual Int_tTFile::ReOpen(Option_t* mode); virtual voidTMemFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTMemFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::Set",MatchSource.WIKI,root/html604/TParallelMergingFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelMergingFile.html
https://root.cern/root/html604/TParallelMergingFile.html:12539,Performance,cache,cache,12539,"ct::ResetBit(UInt_t f); virtual voidTMemFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_",MatchSource.WIKI,root/html604/TParallelMergingFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelMergingFile.html
https://root.cern/root/html604/TParallelMergingFile.html:19788,Performance,cache,cache,19788,"leTypeTFile::kWeb; static TObject::(anonymous)TObject::kWriteDelete; static TFile::EStatusBitsTFile::kWriteError; static TObject::(anonymous)TObject::kZombie. protected:. TArchiveFile*TFile::fArchive!Archive file from which we read this file; Long64_tTFile::fArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*TFile::fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusTFile::fAsyncOpenStatus!Status of an asynchronous open request; Long64_tTFile::fBEGINFirst used byte in file; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tTFile::fBytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsPcmFile!True if the file is a ROOT pcm file.; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of obje",MatchSource.WIKI,root/html604/TParallelMergingFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelMergingFile.html
https://root.cern/root/html604/TParallelMergingFile.html:19850,Performance,cache,cache,19850,"leTypeTFile::kWeb; static TObject::(anonymous)TObject::kWriteDelete; static TFile::EStatusBitsTFile::kWriteError; static TObject::(anonymous)TObject::kZombie. protected:. TArchiveFile*TFile::fArchive!Archive file from which we read this file; Long64_tTFile::fArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*TFile::fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusTFile::fAsyncOpenStatus!Status of an asynchronous open request; Long64_tTFile::fBEGINFirst used byte in file; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tTFile::fBytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsPcmFile!True if the file is a ROOT pcm file.; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of obje",MatchSource.WIKI,root/html604/TParallelMergingFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelMergingFile.html
https://root.cern/root/html604/TParallelMergingFile.html:19922,Performance,cache,cache,19922,"leTypeTFile::kWeb; static TObject::(anonymous)TObject::kWriteDelete; static TFile::EStatusBitsTFile::kWriteError; static TObject::(anonymous)TObject::kZombie. protected:. TArchiveFile*TFile::fArchive!Archive file from which we read this file; Long64_tTFile::fArchiveOffset!Offset at which file starts in archive; TFileOpenHandle*TFile::fAsyncHandle!For proper automatic cleanup; TFile::EAsyncOpenStatusTFile::fAsyncOpenStatus!Status of an asynchronous open request; Long64_tTFile::fBEGINFirst used byte in file; Int_tTDirectoryFile::fBufferSizeDefault buffer size to create new TKeys; Long64_tTFile::fBytesReadNumber of bytes read from this file; Long64_tTFile::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Long64_tTFile::fBytesWriteNumber of bytes written to this file; TFileCacheRead*TFile::fCacheRead!Pointer to the read cache (if any); TMap*TFile::fCacheReadMap!Pointer to the read cache (if any); TFileCacheWrite*TFile::fCacheWrite!Pointer to the write cache (if any); TArrayC*TFile::fClassIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsPcmFile!True if the file is a ROOT pcm file.; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of obje",MatchSource.WIKI,root/html604/TParallelMergingFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelMergingFile.html
https://root.cern/root/html604/TParallelMergingFile.html:21658,Performance,cache,cache,21658,,MatchSource.WIKI,root/html604/TParallelMergingFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelMergingFile.html
https://root.cern/root/html604/TParallelMergingFile.html:21941,Performance,cache,cache,21941,"; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile:",MatchSource.WIKI,root/html604/TParallelMergingFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelMergingFile.html
https://root.cern/root/html604/TParallelMergingFile.html:23337,Performance,cache,cache,23337,"real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static atomic<Long64_t>TFile::fgBytesReadNumber of bytes read by all TFile objects; static atomic<Long64_t>TFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static atomic<Long64_t>TFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static atomic<Int_t>TFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root/html604/TParallelMergingFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelMergingFile.html
https://root.cern/root/html604/TParallelMergingFile.html:23367,Performance,cache,cached,23367,"real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static atomic<Long64_t>TFile::fgBytesReadNumber of bytes read by all TFile objects; static atomic<Long64_t>TFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static atomic<Long64_t>TFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static atomic<Int_t>TFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root/html604/TParallelMergingFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelMergingFile.html
https://root.cern/root/html604/TParallelMergingFile.html:13496,Safety,timeout,timeout,13496,"dTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tTFile::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTFile::SumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; I",MatchSource.WIKI,root/html604/TParallelMergingFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParallelMergingFile.html
https://root.cern/root/html604/TParameter_bool_.html:1343,Availability,error,error,1343," virtual~TParameter<bool>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObjec",MatchSource.WIKI,root/html604/TParameter_bool_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParameter_bool_.html
https://root.cern/root/html604/TParameter_bool_.html:1427,Availability,error,error,1427,"<bool>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const bool&GetVal() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tHash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual vo",MatchSource.WIKI,root/html604/TParameter_bool_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParameter_bool_.html
https://root.cern/root/html604/TParameter_double_.html:1351,Availability,error,error,1351," virtual~TParameter<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_",MatchSource.WIKI,root/html604/TParameter_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParameter_double_.html
https://root.cern/root/html604/TParameter_double_.html:1435,Availability,error,error,1435,"ouble>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const double&GetVal() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tHash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual ",MatchSource.WIKI,root/html604/TParameter_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParameter_double_.html
https://root.cern/root/html604/TParameter_float_.html:1347,Availability,error,error,1347," virtual~TParameter<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TO",MatchSource.WIKI,root/html604/TParameter_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParameter_float_.html
https://root.cern/root/html604/TParameter_float_.html:1431,Availability,error,error,1431,"float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const float&GetVal() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tHash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual v",MatchSource.WIKI,root/html604/TParameter_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParameter_float_.html
https://root.cern/root/html604/TParameter_int_.html:1339,Availability,error,error,1339," virtual~TParameter<int>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::G",MatchSource.WIKI,root/html604/TParameter_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParameter_int_.html
https://root.cern/root/html604/TParameter_int_.html:1423,Availability,error,error,1423,"r<int>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const int&GetVal() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tHash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voi",MatchSource.WIKI,root/html604/TParameter_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParameter_int_.html
https://root.cern/root/html604/TParameter_Long64_t_.html:1359,Availability,error,error,1359," virtual~TParameter<Long64_t>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual",MatchSource.WIKI,root/html604/TParameter_Long64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParameter_Long64_t_.html
https://root.cern/root/html604/TParameter_Long64_t_.html:1443,Availability,error,error,1443,"g64_t>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const Long64_t&GetVal() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tHash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtua",MatchSource.WIKI,root/html604/TParameter_Long64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParameter_Long64_t_.html
https://root.cern/root/html604/TParameter_long_.html:1343,Availability,error,error,1343," virtual~TParameter<long>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObjec",MatchSource.WIKI,root/html604/TParameter_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParameter_long_.html
https://root.cern/root/html604/TParameter_long_.html:1427,Availability,error,error,1427,"<long>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const long&GetVal() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tHash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual vo",MatchSource.WIKI,root/html604/TParameter_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParameter_long_.html
https://root.cern/root/html604/TParticle.html:2432,Availability,error,error,2432,"ion = """"); Int_tBeauty() const; virtual voidTObject::Browse(TBrowser* b); Int_tCharm() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; Double_tEnergy() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEta() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetCalcMass() const; Int_tGetDaughter(Int_t i) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetFirstDaughter() const; Int_tGetFirstMother() const; virtual const char*TObject::GetIconName() const; Int_tGetLastDaughter() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; Double_tGetMass() const; Int_tGetMother(Int_t i) const; virtual const char*GetName() const; Int_tGetNDaughters() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); ",MatchSource.WIKI,root/html604/TParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParticle.html
https://root.cern/root/html604/TParticle.html:2516,Availability,error,error,2516,"() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; Double_tEnergy() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEta() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetCalcMass() const; Int_tGetDaughter(Int_t i) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetFirstDaughter() const; Int_tGetFirstMother() const; virtual const char*TObject::GetIconName() const; Int_tGetLastDaughter() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; Double_tGetMass() const; Int_tGetMother(Int_t i) const; virtual const char*GetName() const; Int_tGetNDaughters() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TParticlePDG*GetPDG(Int_t mode = 0) con",MatchSource.WIKI,root/html604/TParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParticle.html
https://root.cern/root/html604/TParticle.html:413,Safety,detect,detectors,413,". TParticle. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » EG; » TParticle. class TParticle: public TObject, public TAttLine, public TAtt3D. a dynamic particle class created by event generators and used during; the propagation in detectors. The static attributes of a TParticle; are described by TParticlePDG. Int_t fPdgCode; // PDG code of the particle; Int_t fStatusCode; // generation status code; Int_t fMother[2]; // Indices of the mother particles; Int_t fDaughter[2]; // Indices of the daughter particles; Float_t fWeight; // particle weight. Double_t fCalcMass; // Calculated mass. Double_t fPx; // x component of momentum; Double_t fPy; // y component of momentum; Double_t fPz; // z component of momentum; Double_t fE; // Energy. Double_t fVx; // x of production vertex; Double_t fVy; // y of production vertex; Double_t fVz; // z of production vertex; Double_t fVt; // t of production vertex. Double_t fPolarTheta; // Polar angle of polarisation; Double_t fPolarPhi; // azymutal angle of polarisation. TParticlePDG* fParticlePDG; //! reference to the particle record in PDG database. Function Members (Methods); public:. virtual~TParticle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tBeauty() const; virtual voidTObject::Browse(TBrowser* b); Int_tCharm() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistanceto",MatchSource.WIKI,root/html604/TParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParticle.html
https://root.cern/root/html604/TParticleClassPDG.html:1362,Availability,error,error,1362," virtual~TParticleClassPDG(); voidTObject::AbstractMethod(const char* method) const; voidAddParticle(TObject* p); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TObjArray*GetListOfParticles(); virtual const char*TNamed::GetName() const; Int_tGetNParticles(",MatchSource.WIKI,root/html604/TParticleClassPDG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParticleClassPDG.html
https://root.cern/root/html604/TParticleClassPDG.html:1446,Availability,error,error,1446,"Method(const char* method) const; voidAddParticle(TObject* p); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TObjArray*GetListOfParticles(); virtual const char*TNamed::GetName() const; Int_tGetNParticles(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TParticlePDG*GetParticle(Int_t i); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_",MatchSource.WIKI,root/html604/TParticleClassPDG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParticleClassPDG.html
https://root.cern/root/html604/TParticleClassPDG.html:6686,Security,access,access,6686,"ClassPDG(const TParticleClassPDG& pcp). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TObjArray*fListOfParticleslist of (non-owned) particles; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParticleClassPDG(const char* name = 0); default constructor. ~TParticleClassPDG(); destructor, class doesn't own its particles... void Print(Option_t* opt = """") const. Print the entire information of this kind of particle. void Browse(TBrowser* b); browse this particle class. TParticleClassPDG(const TParticleClassPDG& pcp); { }. TParticleClassPDG& operator=(const TParticleClassPDG& pcp). Int_t GetNParticles(); ****** access methods. TParticlePDG* GetParticle(Int_t i). TObjArray* GetListOfParticles(); { return fListOfParticles; }. void AddParticle(TObject* p); ****** modifiers. { fListOfParticles->Add(p); }. Bool_t IsFolder() const; { return kTRUE; }. » Author: Pasha Murat 12/02/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/eg:$Id$ » Last generated: 2015-06-02 16:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TParticleClassPDG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParticleClassPDG.html
https://root.cern/root/html604/TParticlePDG.html:2539,Availability,error,error,2539,"cle() const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tBeauty() const; virtual voidTObject::Browse(TBrowser* b); Double_tCharge() const; Int_tCharm() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; TDecayChannel*DecayChannel(Int_t i); TObjArray*DecayList(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; Double_tI3() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const",MatchSource.WIKI,root/html604/TParticlePDG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParticlePDG.html
https://root.cern/root/html604/TParticlePDG.html:2623,Availability,error,error,2623,"nst; virtual voidTObject::Browse(TBrowser* b); Double_tCharge() const; Int_tCharm() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; TDecayChannel*DecayChannel(Int_t i); TObjArray*DecayList(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; Double_tI3() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTO",MatchSource.WIKI,root/html604/TParticlePDG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParticlePDG.html
https://root.cern/root/html604/TParticlePDG.html:580,Energy Efficiency,charge,charge,580,". TParticlePDG. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » EG; » TParticlePDG. class TParticlePDG: public TNamed. Description of the static properties of a particle.; The class is typically generated by the TDatabasePDG class.; It is referenced by the dynamic particle class TParticle.; Int_t fPdgCode; // PDG code of the particle; Double_t fMass; // particle mass in GeV; Double_t fCharge; // charge in units of |e|/3; Double_t fLifetime; // proper lifetime in seconds; Double_t fWidth; // total width in GeV; Int_t fParity; // parity; Double_t fSpin; // spin; Double_t fIsospin; // isospin; Double_t fI3; // i3; Int_t fStrangeness; // flavours are defined if i3 != -1; Int_t fCharm; // 1 or -1 for C-particles, 0 for others; Int_t fBeauty;; Int_t fTop;; Int_t fY; // X,Y: quantum numbers for the 4-th generation; Int_t fX;; Int_t fStable; // 1 if stable, 0 otherwise. TObjArray* fDecayList; // array of decay channels. TString fParticleClass; // lepton, meson etc. Int_t fTrackingCode; // G3 tracking code of the particle; TParticlePDG* fAntiParticle; // pointer to antiparticle. Function Members (Methods); public:. virtual~TParticlePDG(); voidTObject::AbstractMethod(const char* method) const; Int_tAddDecayChannel(Int_t Type, Double_t BranchingRatio, Int_t NDaughters, Int_t* DaughterPdgCode); TParticlePDG*AntiParticle(); const TParticlePDG*AntiParticle() const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tBeauty() const; virtual voidTObject::Browse(TBrowser* b); Double_tCharge() const; Int_tCharm() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) cons",MatchSource.WIKI,root/html604/TParticlePDG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParticlePDG.html
https://root.cern/root/html604/TParticlePDG.html:9418,Security,access,access,9418,"dthtotal width in GeV; Int_tfX; Int_tfYX,Y: quantum numbers for the 4-th generation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParticlePDG(); default constructor. TParticlePDG(const char* Name, const char* Title, Double_t Mass, Bool_t Stable, Double_t Width, Double_t Charge, const char* ParticleClass, Int_t PdgCode, Int_t Anti, Int_t TrackingCode). TParticlePDG(const TParticlePDG& ); copy constructor. TParticlePDG& operator=(const TParticlePDG& ); assignement operator. ~TParticlePDG(); destructor. Int_t AddDecayChannel(Int_t Type, Double_t BranchingRatio, Int_t NDaughters, Int_t* DaughterPdgCode); add new decay channel, Particle owns those... TDecayChannel* DecayChannel(Int_t i); return pointer to decay channel object at index i. void PrintDecayChannel(TDecayChannel* dc, Option_t* opt = """") const; print the list of decays. void Print(Option_t* opt = """") const. Print the entire information of this kind of particle. Int_t PdgCode() const; ****** access methods. { return fPdgCode; }. Double_t Mass() const; { return fMass; }. Double_t Charge() const; { return fCharge; }. Double_t Lifetime() const; { return fLifetime; }. Double_t Width() const; { return fWidth; }. Int_t Parity() const; { return fParity; }. Double_t Spin() const; { return fSpin; }. Double_t Isospin() const; { return fIsospin; }. Double_t I3() const; { return fI3; }. Int_t Strangeness() const; { return fStrangeness; }. Int_t Charm() const; { return fCharm; }. Int_t Beauty() const; { return fBeauty; }. Int_t Top() const; { return fTop; }. Int_t X() const; { return fX; }. Int_t Y() const; { return fY; }. Int_t Stable() const; { return fStable; }. const char* ParticleClass() const; { return fParticleClass.Data(); }. TObjArray* DecayList(); { return fDecayList; }. Int_t NDecayChannels() const. Int_t TrackingCode() const; { return fTrackingCode; }. TParticlePDG* AntiParticle(); { return fAntiParticle; }. const TParticlePDG* AntiParticle() const; { return fAntiPa",MatchSource.WIKI,root/html604/TParticlePDG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TParticlePDG.html
https://root.cern/root/html604/TPave.html:1739,Availability,error,error,1739,"tual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidConvertNDCtoPad(); virtual voidCopy(TObject& pave) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTBox::GetBBox(); virtual TPointTBox::GetBBoxCenter(); Int_tGetBorderSize() const; Double_tGetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Option_t*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Op",MatchSource.WIKI,root/html604/TPave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPave.html
https://root.cern/root/html604/TPave.html:1823,Availability,error,error,1823,"newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidConvertNDCtoPad(); virtual voidCopy(TObject& pave) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTBox::GetBBox(); virtual TPointTBox::GetBBoxCenter(); Int_tGetBorderSize() const; Double_tGetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Option_t*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; Int_tGetShadowColor() const; virtual const char*TObject::G",MatchSource.WIKI,root/html604/TPave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPave.html
https://root.cern/root/html604/TPaveClass.html:2173,Availability,error,error,2173,"eVar) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTPaveLabel::Draw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual voidDrawClasses(const char* classes = ""this"")MENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTPaveLabel::DrawPaveLabel(Double_t x1, Double_t y1, Double_t x2, Double_t y2, const char* label, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTBox::GetBBox(); virtual TPointTBox::GetBBoxCenter(); Int_tTPave::GetBorderSize() const; TClassTree*GetClassTree() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; const char*TPaveLabel::GetLabel() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Option_t*TPave::GetName() const; virtual ch",MatchSource.WIKI,root/html604/TPaveClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveClass.html
https://root.cern/root/html604/TPaveClass.html:2257,Availability,error,error,2257,":DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTPaveLabel::Draw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual voidDrawClasses(const char* classes = ""this"")MENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTPaveLabel::DrawPaveLabel(Double_t x1, Double_t y1, Double_t x2, Double_t y2, const char* label, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTBox::GetBBox(); virtual TPointTBox::GetBBoxCenter(); Int_tTPave::GetBorderSize() const; TClassTree*GetClassTree() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; const char*TPaveLabel::GetLabel() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Option_t*TPave::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObject",MatchSource.WIKI,root/html604/TPaveClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveClass.html
https://root.cern/root/html604/TPaveLabel.html:1814,Availability,error,error,1814,"t* obj) const; virtual voidTPave::ConvertNDCtoPad(); virtual voidCopy(TObject& pavelabel) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidDrawPaveLabel(Double_t x1, Double_t y1, Double_t x2, Double_t y2, const char* label, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTBox::GetBBox(); virtual TPointTBox::GetBBoxCenter(); Int_tTPave::GetBorderSize() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; const char*GetLabel() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Option_t*TPave::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py)",MatchSource.WIKI,root/html604/TPaveLabel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveLabel.html
https://root.cern/root/html604/TPaveLabel.html:1898,Availability,error,error,1898,"abel) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidDrawPaveLabel(Double_t x1, Double_t y1, Double_t x2, Double_t y2, const char* label, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTBox::GetBBox(); virtual TPointTBox::GetBBoxCenter(); Int_tTPave::GetBorderSize() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; const char*GetLabel() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Option_t*TPave::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TPave::GetOption() c",MatchSource.WIKI,root/html604/TPaveLabel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveLabel.html
https://root.cern/root/html604/TPaveStats.html:771,Availability,error,error,771,". TPaveStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TPaveStats. class TPaveStats: public TPaveText. The histogram statistics painter class; A PaveStats is a PaveText to draw histogram statistics and fit parameters. Statistics Display; Fit Statistics; Statistics box editing. Statistics Display; The type of information shown in the histogram statistics box can be selected; with:. gStyle->SetOptStat(mode);. The ""mode"" has up to nine digits that can be set to on (1 or 2), off (0). mode = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed. For example:. gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters kKsSiourRmMen. k : kurtosis printed; K : kurtosi",MatchSource.WIKI,root/html604/TPaveStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveStats.html
https://root.cern/root/html604/TPaveStats.html:840,Availability,error,error,840,". TPaveStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TPaveStats. class TPaveStats: public TPaveText. The histogram statistics painter class; A PaveStats is a PaveText to draw histogram statistics and fit parameters. Statistics Display; Fit Statistics; Statistics box editing. Statistics Display; The type of information shown in the histogram statistics box can be selected; with:. gStyle->SetOptStat(mode);. The ""mode"" has up to nine digits that can be set to on (1 or 2), off (0). mode = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed. For example:. gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters kKsSiourRmMen. k : kurtosis printed; K : kurtosi",MatchSource.WIKI,root/html604/TPaveStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveStats.html
https://root.cern/root/html604/TPaveStats.html:1000,Availability,error,error,1000,". TPaveStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TPaveStats. class TPaveStats: public TPaveText. The histogram statistics painter class; A PaveStats is a PaveText to draw histogram statistics and fit parameters. Statistics Display; Fit Statistics; Statistics box editing. Statistics Display; The type of information shown in the histogram statistics box can be selected; with:. gStyle->SetOptStat(mode);. The ""mode"" has up to nine digits that can be set to on (1 or 2), off (0). mode = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed. For example:. gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters kKsSiourRmMen. k : kurtosis printed; K : kurtosi",MatchSource.WIKI,root/html604/TPaveStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveStats.html
https://root.cern/root/html604/TPaveStats.html:1063,Availability,error,error,1063,". TPaveStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TPaveStats. class TPaveStats: public TPaveText. The histogram statistics painter class; A PaveStats is a PaveText to draw histogram statistics and fit parameters. Statistics Display; Fit Statistics; Statistics box editing. Statistics Display; The type of information shown in the histogram statistics box can be selected; with:. gStyle->SetOptStat(mode);. The ""mode"" has up to nine digits that can be set to on (1 or 2), off (0). mode = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed. For example:. gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters kKsSiourRmMen. k : kurtosis printed; K : kurtosi",MatchSource.WIKI,root/html604/TPaveStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveStats.html
https://root.cern/root/html604/TPaveStats.html:2016,Availability,error,error,2016,". gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters kKsSiourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the paint",MatchSource.WIKI,root/html604/TPaveStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveStats.html
https://root.cern/root/html604/TPaveStats.html:2079,Availability,error,error,2079,". gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters kKsSiourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the paint",MatchSource.WIKI,root/html604/TPaveStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveStats.html
https://root.cern/root/html604/TPaveStats.html:2224,Availability,error,error,2224,". gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters kKsSiourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the paint",MatchSource.WIKI,root/html604/TPaveStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveStats.html
https://root.cern/root/html604/TPaveStats.html:2283,Availability,error,error,2283,". gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters kKsSiourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the paint",MatchSource.WIKI,root/html604/TPaveStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveStats.html
https://root.cern/root/html604/TPaveStats.html:4544,Availability,error,errors,4544,"stics box drawing with the option; ""SAME"", the option ""SAMES"" must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (""h"" being the pointer to the histogram):. Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //new x end position. To change the type of information for an histogram with an existing; TPaveStats one should do:. st->SetOptStat(mode);. Where ""mode"" has the same meaning than when calling; gStyle->SetOptStat(mode) (see above).; One can delete the statistics box for a histogram TH1* h with:. h->SetStats(0). and activate it again with:. h->SetStats(1). Fit Statistics; The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; = pcev (default = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); Statistics box editing; The following example show how to remove and add a line in a statistics box. Picture; Source. TCanvas *statsEditing() {; // This example shows:; // - how to remove a stat element from the stat box; // - how to add a new one; //; // Author: Olivier Couet. // Create and plot a test histogram with stats; TCanvas *se = new TCanvas;; TH1F *h = new TH1F(""h"",""test"",100,-3,3);; h->FillRandom(""gaus"",3000);; gStyle->SetOptStat();; h->Draw();; se->Update();. // Retrieve the stat box; TPaveStats *ps = (TPaveStats*)se->GetPrimitive(""stats"");; ps->SetName(""mystats"");; TList *list = ps->GetListOfLines",MatchSource.WIKI,root/html604/TPaveStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveStats.html
https://root.cern/root/html604/TPaveStats.html:4700,Availability,error,errors,4700,"change; its position with these lines (""h"" being the pointer to the histogram):. Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //new x end position. To change the type of information for an histogram with an existing; TPaveStats one should do:. st->SetOptStat(mode);. Where ""mode"" has the same meaning than when calling; gStyle->SetOptStat(mode) (see above).; One can delete the statistics box for a histogram TH1* h with:. h->SetStats(0). and activate it again with:. h->SetStats(1). Fit Statistics; The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; = pcev (default = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); Statistics box editing; The following example show how to remove and add a line in a statistics box. Picture; Source. TCanvas *statsEditing() {; // This example shows:; // - how to remove a stat element from the stat box; // - how to add a new one; //; // Author: Olivier Couet. // Create and plot a test histogram with stats; TCanvas *se = new TCanvas;; TH1F *h = new TH1F(""h"",""test"",100,-3,3);; h->FillRandom(""gaus"",3000);; gStyle->SetOptStat();; h->Draw();; se->Update();. // Retrieve the stat box; TPaveStats *ps = (TPaveStats*)se->GetPrimitive(""stats"");; ps->SetName(""mystats"");; TList *list = ps->GetListOfLines();. // Remove the RMS line; TText *tconst = ps->GetLineWith(""RMS"");; list->Remove(tconst);. // Add a new line in the stat box.; // Note that ""="" ",MatchSource.WIKI,root/html604/TPaveStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveStats.html
https://root.cern/root/html604/TPaveStats.html:7688,Availability,error,error,7688,"al voidTPave::ConvertNDCtoPad(); virtual voidTPave::Copy(TObject& pave) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteText(); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTPaveText::Draw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPaveText::DrawFile(const char* filename, Option_t* option = """"); virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidEditText(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTBox::GetBBox(); virtual TPointTBox::GetBBoxCenter(); Int_tTPave::GetBorderSize() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*GetFitFormat() const; virtual const char*TObject::GetIconName() const; const char*TPaveText::GetLabel() const; virtual TText*TPaveText::GetLine(Int_t number) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth",MatchSource.WIKI,root/html604/TPaveStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveStats.html
https://root.cern/root/html604/TPaveStats.html:7772,Availability,error,error,7772,"al voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteText(); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTPaveText::Draw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPaveText::DrawFile(const char* filename, Option_t* option = """"); virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidEditText(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTBox::GetBBox(); virtual TPointTBox::GetBBoxCenter(); Int_tTPave::GetBorderSize() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*GetFitFormat() const; virtual const char*TObject::GetIconName() const; const char*TPaveText::GetLabel() const; virtual TText*TPaveText::GetLine(Int_t number) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual TText*TPaveText::GetLineWith(const char* text) const; virtual TLis",MatchSource.WIKI,root/html604/TPaveStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveStats.html
https://root.cern/root/html604/TPaveStats.html:2810,Deployability,update,updated,2810,"ow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters kKsSiourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the painting should be forced using gPad->Update(); in order to make sure the statistics box is created:. h->Draw();; gPad->Update();; TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");. Without gPad->Update() the line h->FindObject(""stats""); returns a null pointer.; When a histogram is drawn with the option ""SAME"", the statistics box; is not drawn. To force the statistics box drawing with the option; ""SAME"", the option ""SAMES"" must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (""h"" being the pointer to the histogram):. Root > TPaveStats *st ",MatchSource.WIKI,root/html604/TPaveStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveStats.html
https://root.cern/root/html604/TPaveStats.html:5875,Safety,avoid,avoid,5875," to gStyle->SetOptFit(111); Statistics box editing; The following example show how to remove and add a line in a statistics box. Picture; Source. TCanvas *statsEditing() {; // This example shows:; // - how to remove a stat element from the stat box; // - how to add a new one; //; // Author: Olivier Couet. // Create and plot a test histogram with stats; TCanvas *se = new TCanvas;; TH1F *h = new TH1F(""h"",""test"",100,-3,3);; h->FillRandom(""gaus"",3000);; gStyle->SetOptStat();; h->Draw();; se->Update();. // Retrieve the stat box; TPaveStats *ps = (TPaveStats*)se->GetPrimitive(""stats"");; ps->SetName(""mystats"");; TList *list = ps->GetListOfLines();. // Remove the RMS line; TText *tconst = ps->GetLineWith(""RMS"");; list->Remove(tconst);. // Add a new line in the stat box.; // Note that ""="" is a control character; TLatex *myt = new TLatex(0,0,""Test = 10"");; myt ->SetTextFont(42);; myt ->SetTextSize(0.04);; myt ->SetTextColor(kRed);; list->Add(myt);. // the following line is needed to avoid that the automatic redrawing of stats; h->SetStats(0);. se->Modified();; return se;; } . Function Members (Methods); public:. virtual~TPaveStats(); voidTObject::AbstractMethod(const char* method) const; virtual TBox*AddBox(Double_t, Double_t, Double_t, Double_t); virtual TLine*AddLine(Double_t, Double_t, Double_t, Double_t); virtual TText*TPaveText::AddText(const char* label); virtual TText*TPaveText::AddText(Double_t x1, Double_t y1, const char* label); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTPaveText::Clear(Option_t* option = """")MENU ; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPave::ConvertNDCtoPad(); virtual voidTPave::Copy(TObject& pave) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteText(); Int_tTAttLine::DistancetoLine(Int_t",MatchSource.WIKI,root/html604/TPaveStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveStats.html
https://root.cern/root/html604/TPaveStats.html:2913,Security,access,accessed,2913,"meter mode can be any combination of the letters kKsSiourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the painting should be forced using gPad->Update(); in order to make sure the statistics box is created:. h->Draw();; gPad->Update();; TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");. Without gPad->Update() the line h->FindObject(""stats""); returns a null pointer.; When a histogram is drawn with the option ""SAME"", the statistics box; is not drawn. To force the statistics box drawing with the option; ""SAME"", the option ""SAMES"" must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (""h"" being the pointer to the histogram):. Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //ne",MatchSource.WIKI,root/html604/TPaveStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveStats.html
https://root.cern/root/html604/TPaveStats.html:5215,Testability,test,test,5215,"mation about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; = pcev (default = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); Statistics box editing; The following example show how to remove and add a line in a statistics box. Picture; Source. TCanvas *statsEditing() {; // This example shows:; // - how to remove a stat element from the stat box; // - how to add a new one; //; // Author: Olivier Couet. // Create and plot a test histogram with stats; TCanvas *se = new TCanvas;; TH1F *h = new TH1F(""h"",""test"",100,-3,3);; h->FillRandom(""gaus"",3000);; gStyle->SetOptStat();; h->Draw();; se->Update();. // Retrieve the stat box; TPaveStats *ps = (TPaveStats*)se->GetPrimitive(""stats"");; ps->SetName(""mystats"");; TList *list = ps->GetListOfLines();. // Remove the RMS line; TText *tconst = ps->GetLineWith(""RMS"");; list->Remove(tconst);. // Add a new line in the stat box.; // Note that ""="" is a control character; TLatex *myt = new TLatex(0,0,""Test = 10"");; myt ->SetTextFont(42);; myt ->SetTextSize(0.04);; myt ->SetTextColor(kRed);; list->Add(myt);. // the following line is needed to avoid that the automatic redrawing of stats; h->SetStats(0);. se->Modified();; return se;; } . Function Members (Methods); public:. virtual~TPaveStats(); voidTObject::AbstractMethod(const char* method) const; virtual TBox*AddBox(Double_t, Double_t, Double_t, Double_t); virtual TLine*AddLine(Double_t, Double_t, Double_t, Double_t); virtual TText*TPaveText::AddText(const char* label); virtual TText*TPaveText::AddTex",MatchSource.WIKI,root/html604/TPaveStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveStats.html
https://root.cern/root/html604/TPaveStats.html:5294,Testability,test,test,5294,"mation about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; = pcev (default = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); Statistics box editing; The following example show how to remove and add a line in a statistics box. Picture; Source. TCanvas *statsEditing() {; // This example shows:; // - how to remove a stat element from the stat box; // - how to add a new one; //; // Author: Olivier Couet. // Create and plot a test histogram with stats; TCanvas *se = new TCanvas;; TH1F *h = new TH1F(""h"",""test"",100,-3,3);; h->FillRandom(""gaus"",3000);; gStyle->SetOptStat();; h->Draw();; se->Update();. // Retrieve the stat box; TPaveStats *ps = (TPaveStats*)se->GetPrimitive(""stats"");; ps->SetName(""mystats"");; TList *list = ps->GetListOfLines();. // Remove the RMS line; TText *tconst = ps->GetLineWith(""RMS"");; list->Remove(tconst);. // Add a new line in the stat box.; // Note that ""="" is a control character; TLatex *myt = new TLatex(0,0,""Test = 10"");; myt ->SetTextFont(42);; myt ->SetTextSize(0.04);; myt ->SetTextColor(kRed);; list->Add(myt);. // the following line is needed to avoid that the automatic redrawing of stats; h->SetStats(0);. se->Modified();; return se;; } . Function Members (Methods); public:. virtual~TPaveStats(); voidTObject::AbstractMethod(const char* method) const; virtual TBox*AddBox(Double_t, Double_t, Double_t, Double_t); virtual TLine*AddLine(Double_t, Double_t, Double_t, Double_t); virtual TText*TPaveText::AddText(const char* label); virtual TText*TPaveText::AddTex",MatchSource.WIKI,root/html604/TPaveStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveStats.html
https://root.cern/root/html604/TPaveStatsEditor.html:4651,Availability,error,error,4651," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html604/TPaveStatsEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveStatsEditor.html
https://root.cern/root/html604/TPaveStatsEditor.html:4735,Availability,error,error,4735,"(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html604/TPaveStatsEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveStatsEditor.html
https://root.cern/root/html604/TPaveStatsEditor.html:18665,Availability,mask,mask,18665,,MatchSource.WIKI,root/html604/TPaveStatsEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveStatsEditor.html
https://root.cern/root/html604/TPaveStatsEditor.html:20522,Availability,error,error,20522,xHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; TGCheckButton*fMeanmean value check box; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TClass*TGedFrame::fModelClassclass corresponding to instantiated GedFrame; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); TGCheckButton*fNameValuesparameters' name/values check box; Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; TGCheckButton*fOverflowoverflow number check box; const TGWindow*TGWindow::fParentParent window; TPaveStats*fPaveStatsTPaveStats object; Int_tTGedFrame::fPrioritylocation in GedEditor; TGCheckButton*fProbabilityprobability check box; TGCheckButton*fRMSRMS check box; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGCheckButton*fSkewnessskewness check box; TGCheckButton*fStatsErrorsstatistics error check box; TGCheckButton*fUnderflowunderflow number check box; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhite,MatchSource.WIKI,root/html604/TPaveStatsEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveStatsEditor.html
https://root.cern/root/html604/TPavesText.html:2174,Availability,error,error,2174,"NDCtoPad(); virtual voidTPave::Copy(TObject& pave) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTPaveText::DeleteText()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPaveText::DrawFile(const char* filename, Option_t* option = """"); virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidTPaveText::EditText()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTBox::GetBBox(); virtual TPointTBox::GetBBoxCenter(); Int_tTPave::GetBorderSize() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; const char*TPaveText::GetLabel() const; virtual TText*TPaveText::GetLine(Int_t number) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual TText*TPaveText::GetLin",MatchSource.WIKI,root/html604/TPavesText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPavesText.html
https://root.cern/root/html604/TPavesText.html:2258,Availability,error,error,2258,"e(Option_t* option = """")MENU ; virtual voidTPaveText::DeleteText()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPaveText::DrawFile(const char* filename, Option_t* option = """"); virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidTPaveText::EditText()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTBox::GetBBox(); virtual TPointTBox::GetBBoxCenter(); Int_tTPave::GetBorderSize() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; const char*TPaveText::GetLabel() const; virtual TText*TPaveText::GetLine(Int_t number) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual TText*TPaveText::GetLineWith(const char* text) const; virtual TList*TPaveText::GetListOfLines() const; Floa",MatchSource.WIKI,root/html604/TPavesText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPavesText.html
https://root.cern/root/html604/TPaveText.html:2714,Availability,error,error,2714,"const; virtual voidTPave::ConvertNDCtoPad(); virtual voidTPave::Copy(TObject& pave) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteText()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFile(const char* filename, Option_t* option = """"); virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidEditText()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTBox::GetBBox(); virtual TPointTBox::GetBBoxCenter(); Int_tTPave::GetBorderSize() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; const char*GetLabel() const; virtual TText*GetLine(Int_t number) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual TText*GetLineWith(const char* text) const; vi",MatchSource.WIKI,root/html604/TPaveText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveText.html
https://root.cern/root/html604/TPaveText.html:2798,Availability,error,error,2798,"const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteText()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFile(const char* filename, Option_t* option = """"); virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidEditText()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTBox::GetBBox(); virtual TPointTBox::GetBBoxCenter(); Int_tTPave::GetBorderSize() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; const char*GetLabel() const; virtual TText*GetLine(Int_t number) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual TText*GetLineWith(const char* text) const; virtual TList*GetListOfLines() const; Float_tGetMargin() const; virtual Option_t*TPave",MatchSource.WIKI,root/html604/TPaveText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveText.html
https://root.cern/root/html604/TPaveText.html:14208,Modifiability,inherit,inherits,14208,"Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPaveText(); pavetext default constructor. TPaveText(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Option_t* option = ""br""); PaveText normal constructor. A PaveText is a Pave with several lines of text. option = ""TR"" Top and Right shadows are drawn.; option = ""TL"" Top and Left shadows are drawn.; option = ""BR"" Bottom and Right shadows are drawn.; option = ""BL"" Bottom and Left shadows are drawn. If none of these four above options is specified the default the; option ""BR"" will be used to draw the border. To produces a pave; without any border it is enough to specify the option ""NB"" (no border). option = ""NDC"" x1,y1,x2,y2 are given in NDC; option = ""ARC"" corners are rounded. In case of option ""ARC"", the corner radius is specified; via TPave::SetCornerRadius(rad) where rad is given in percent; of the pave height (default value is 0.2). The individual text items are entered via AddText; By default, text items inherits from the default pavetext AttText.; A title can be added later to this pavetext via TPaveText::SetLabel. ~TPaveText(); pavetext default destructor. TPaveText(const TPaveText& pavetext); pavetext copy constructor. TPaveText& operator=(const TPaveText& ); assignment operator. TBox * AddBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Add a new graphics box to this pavetext. TLine * AddLine(Double_t x1 = 0, Double_t y1 = 0, Double_t x2 = 0, Double_t y2 = 0); Add a new graphics line to this pavetext. TText * AddText(Double_t x1, Double_t y1, const char* label); Add a new Text line to this pavetext at given coordinates. TText * AddText(const char* label); Add a new Text line to this pavetext. void Clear(Option_t* option = """"); Clear all lines in this pavetext. void DeleteText(); Delete text at the mouse position. void Draw(Option_t* option = """"); Draw this pavetext with its current attributes. void DrawFile(const char* filename, Option_t* option = """"); Draw ",MatchSource.WIKI,root/html604/TPaveText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPaveText.html
https://root.cern/root/html604/TPBHandleDSType.html:1336,Availability,error,error,1336," virtual~TPBHandleDSType(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetO",MatchSource.WIKI,root/html604/TPBHandleDSType.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPBHandleDSType.html
https://root.cern/root/html604/TPBHandleDSType.html:1420,Availability,error,error,1420," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; TPBHandleDSType::EHandleDSTypeGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const ",MatchSource.WIKI,root/html604/TPBHandleDSType.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPBHandleDSType.html
https://root.cern/root/html604/TPBHistType.html:1320,Availability,error,error,1320," virtual~TPBHistType(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; v",MatchSource.WIKI,root/html604/TPBHistType.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPBHistType.html
https://root.cern/root/html604/TPBHistType.html:1404,Availability,error,error,1404," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; TPBHistType::EHistTypeGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* ",MatchSource.WIKI,root/html604/TPBHistType.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPBHistType.html
https://root.cern/root/html604/TPBReadType.html:1320,Availability,error,error,1320," virtual~TPBReadType(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; v",MatchSource.WIKI,root/html604/TPBReadType.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPBReadType.html
https://root.cern/root/html604/TPBReadType.html:1404,Availability,error,error,1404," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; TPBReadType::EReadTypeGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* ",MatchSource.WIKI,root/html604/TPBReadType.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPBReadType.html
https://root.cern/root/html604/TPCON.html:2053,Availability,error,error,2053," option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDefineSection(Int_t secNum, Float_t z, Float_t rmin, Float_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Float_tGetDhi1() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_t*GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tGet",MatchSource.WIKI,root/html604/TPCON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPCON.html
https://root.cern/root/html604/TPCON.html:2137,Availability,error,error,2137,"ual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDefineSection(Int_t secNum, Float_t z, Float_t rmin, Float_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Float_tGetDhi1() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_t*GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNdiv() const; virtual Int_tTShape::GetNumber() const; virtual Int_tGetNumberOfDivisi",MatchSource.WIKI,root/html604/TPCON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPCON.html
https://root.cern/root/html604/TPCON.html:549,Modifiability,extend,extends,549,". TPCON. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TPCON. class TPCON: public TShape. . PCON is a polycone. It has the following parameters:. - name name of the shape; - title shape's title; - material (see TMaterial); - phi1 the azimuthal angle phi at which the volume begins (angles; are counted counterclockwise); - dphi opening angle of the volume, which extends from; phi1 to phi1+dphi; - nz number of planes perpendicular to the z axis where; the dimension of the section is given -- this number; should be at least 2; - rmin array of dimension nz with minimum radius at a given plane; - rmax array of dimension nz with maximum radius at a given plane; - z array of dimension nz with z position of given plane. Function Members (Methods); public:. virtual~TPCON(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDefineSection(Int_t secNum, Float_t z, Float_t rmin, Float_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Exe",MatchSource.WIKI,root/html604/TPCON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPCON.html
https://root.cern/root/html604/TPDF.html:3422,Availability,error,error,3422,"tion_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); voidDrawHatch(Float_t dy, Float_t angle, Int_t n, Float_t* x, Float_t* y); voidDrawHatch(Float_t dy, Float_t angle, Int_t n, Double_t* x, Double_t* y); voidDrawPolyLine(Int_t n, TPoints* xy); voidDrawPolyLineNDC(Int_t n, TPoints* uv); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y); virtual voidDrawPS(Int_t n, Float_t* xw, Float_t* yw); virtual voidDrawPS(Int_t n, Double_t* xw, Double_t* yw); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFontEncode(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TNamed::GetName() const; virtual cha",MatchSource.WIKI,root/html604/TPDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPDF.html
https://root.cern/root/html604/TPDF.html:3506,Availability,error,error,3506,"ble_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); voidDrawHatch(Float_t dy, Float_t angle, Int_t n, Float_t* x, Float_t* y); voidDrawHatch(Float_t dy, Float_t angle, Int_t n, Double_t* x, Double_t* y); voidDrawPolyLine(Int_t n, TPoints* xy); voidDrawPolyLineNDC(Int_t n, TPoints* uv); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y); virtual voidDrawPS(Int_t n, Float_t* xw, Float_t* yw); virtual voidDrawPS(Int_t n, Double_t* xw, Double_t* yw); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFontEncode(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectS",MatchSource.WIKI,root/html604/TPDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPDF.html
https://root.cern/root/html604/TPDF.html:12331,Energy Efficiency,green,green,12331,"ect::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_tfAlphaPer cent of transparency; vector<float>fAlphasList of alpha values used; Float_tfBluePer cent of blue; char*TVirtualPS::fBufferFile buffer; Bool_tfCompressTrue when fBuffer must be compressed; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Float_tfGreenPer cent of green; const char*TVirtualPS::fImplicitCREscEscape symbol before enforced new line; Int_tTVirtualPS::fLenBufferBuffer length; Color_tTAttLine::fLineColorline color; Float_tfLineScaleLine width scale factor; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTVirtualPS::fNByteNumber of bytes written in the file (PDF); TStringTNamed::fNameobject identifier; Int_tfNbObjNumber of objects; Int_tfNbPageNumber of pages; Int_t*fObjPosObjets position; Int_tfObjPosSizeReal size of fObjPos; Int_tfPageFormatPage format (A4, Letter etc ...); Bool_tfPageNotEmptyTrue if the current page is not empty; Int_tfPageOrientationPage orientation (Portrait, Landscape); Bool_tTVirtualPS::fPrintedTrue when a page must be printed; Bool_tfRangeTrue when a range has been defined; Float_tfRedPer cent of red; Int_tTVirtualPS::fSizBufferBuffer size; Int_tfStartStream; ofstream*TVirtualPS::fStreamFile stream identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color",MatchSource.WIKI,root/html604/TPDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPDF.html
https://root.cern/root/html604/TPDF.html:17680,Energy Efficiency,green,green,17680,"0 the line is clipped as a fill area. void FontEncode(); Font encoding. void LineTo(Double_t x, Double_t y); Draw a line to a new position. void MoveTo(Double_t x, Double_t y); Move to a new position. void NewObject(Int_t n); Create a new object in the PDF file. void NewPage(); Start a new PDF page. void Off(); Deactivate an already open PDF file. void On(); Activate an already open PDF file. void Open(const char* filename, Int_t type = -111); Open a PDF file. void PatternEncode(); Patterns encoding. void PrintStr(const char* string = """"); Output the string str in the output buffer. void PrintFast(Int_t nch, const char* string = """"); Fast version of Print. void Range(Float_t xrange, Float_t yrange); Set the range for the paper in centimetres. void SetAlpha(Float_t alpha = 1.); Set the alpha channel value. void SetColor(Int_t color = 1); Set color with its color index. void SetColor(Float_t r, Float_t g, Float_t b); Set color with its R G B components:. r: % of red in [0,1]; g: % of green in [0,1]; b: % of blue in [0,1]. void SetFillColor(Color_t cindex = 1); Set color index for fill areas. void SetFillPatterns(Int_t ipat, Int_t color); Set the fill patterns (1 to 25) for fill areas. void SetLineColor(Color_t cindex = 1); Set color index for lines. void SetLineStyle(Style_t linestyle = 1); Change the line style. linestyle = 2 dashed; = 3 dotted; = 4 dash-dotted; = else solid (1 in is used most of the time). void SetLineWidth(Width_t linewidth = 1); Change the line width. void SetMarkerColor(Color_t cindex = 1); Set color index for markers. void SetTextColor(Color_t cindex = 1); Set color index for text. void Text(Double_t x, Double_t y, const char* string); Draw text. xx: x position of the text; yy: y position of the text; chars: text to be drawn. void Text(Double_t , Double_t , const wchar_t* ). Write a string of characters. This routine writes the string chars into a PostScript file; at position xx,yy in world coordinates. void TextNDC(Double_t u, Double_t v, const ",MatchSource.WIKI,root/html604/TPDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPDF.html
https://root.cern/root/html604/TPDF.html:299,Integrability,interface,interface,299,". TPDF. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TPDF. class TPDF: public TVirtualPS. TPDF: Graphics interface to PDF; Like PostScript, PDF is a vector graphics output format allowing a very high; graphics output quality. The functionalities provided by this class are very; similar to those provided by TPostScript. Compare to PostScript output, the PDF files are usually smaller because some; parts of them can be compressed. PDF also allows to define table of contents. This facility can be used in ROOT.; The following example shows how to proceed:. {; TCanvas* canvas = new TCanvas(""canvas"");; TH1F* histo = new TH1F(""histo"",""test 1"",10,0.,10.);; histo->SetFillColor(2);; histo->Fill(2.);; histo->Draw();; canvas->Print(""plots.pdf("",""Title:One bin filled"");; histo->Fill(4.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Two bins filled"");; histo->Fill(6.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Three bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Four bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf)"",""Title:The fourth bin content is 2"");; }. Each character string following the keyword ""Title:"" makes a new entry in; the table of contents.; . Function Members (Methods); public:. virtual~TPDF(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; vir",MatchSource.WIKI,root/html604/TPDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPDF.html
https://root.cern/root/html604/TPDF.html:13958,Integrability,interface,interface,13958,"osObjets position; Int_tfObjPosSizeReal size of fObjPos; Int_tfPageFormatPage format (A4, Letter etc ...); Bool_tfPageNotEmptyTrue if the current page is not empty; Int_tfPageOrientationPage orientation (Portrait, Landscape); Bool_tTVirtualPS::fPrintedTrue when a page must be printed; Bool_tfRangeTrue when a range has been defined; Float_tfRedPer cent of red; Int_tTVirtualPS::fSizBufferBuffer size; Int_tfStartStream; ofstream*TVirtualPS::fStreamFile stream identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; Int_tfTypeWorkstation type used to know if the PDF is open; Float_tfXsizePage size along X; Float_tfYsizePage size along Y. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPDF(); Default PDF constructor. TPDF(const char* filename, Int_t type = -111); Initialize the PDF interface. fname : PDF file name; wtype : PDF workstation type. Not used in the PDF driver. But as TPDF; inherits from TVirtualPS it should be kept. Anyway it is not; necessary to specify this parameter at creation time because it; has a default value (which is ignore in the PDF case). ~TPDF(); Default PDF destructor. void CellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); Begin the Cell Array painting. void CellArrayFill(Int_t r, Int_t g, Int_t b); Paint the Cell Array. void CellArrayEnd(); End the Cell Array painting. void Close(Option_t* opt = """"); Close a PDF file. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw a Box. void DrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); Draw a Frame around a box. mode = -1 box looks as it is behind the screen; mode = 1 box looks as it is in front of the screen; border is the border size in already ",MatchSource.WIKI,root/html604/TPDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPDF.html
https://root.cern/root/html604/TPDF.html:18545,Integrability,rout,routine,18545,"Float_t g, Float_t b); Set color with its R G B components:. r: % of red in [0,1]; g: % of green in [0,1]; b: % of blue in [0,1]. void SetFillColor(Color_t cindex = 1); Set color index for fill areas. void SetFillPatterns(Int_t ipat, Int_t color); Set the fill patterns (1 to 25) for fill areas. void SetLineColor(Color_t cindex = 1); Set color index for lines. void SetLineStyle(Style_t linestyle = 1); Change the line style. linestyle = 2 dashed; = 3 dotted; = 4 dash-dotted; = else solid (1 in is used most of the time). void SetLineWidth(Width_t linewidth = 1); Change the line width. void SetMarkerColor(Color_t cindex = 1); Set color index for markers. void SetTextColor(Color_t cindex = 1); Set color index for text. void Text(Double_t x, Double_t y, const char* string); Draw text. xx: x position of the text; yy: y position of the text; chars: text to be drawn. void Text(Double_t , Double_t , const wchar_t* ). Write a string of characters. This routine writes the string chars into a PostScript file; at position xx,yy in world coordinates. void TextNDC(Double_t u, Double_t v, const char* string); Write a string of characters in NDC. void TextNDC(Double_t , Double_t , const wchar_t* ); Write a string of characters in NDC. Double_t UtoPDF(Double_t u); Convert U from NDC coordinate to PDF. Double_t VtoPDF(Double_t v); Convert V from NDC coordinate to PDF. Double_t XtoPDF(Double_t x); Convert X from world coordinate to PDF. Double_t YtoPDF(Double_t y); Convert Y from world coordinate to PDF. void WriteCompressedBuffer(); Write the buffer in a compressed way. void WriteReal(Float_t r, Bool_t space = kTRUE); Write a Real number to the file.; This method overwrites TVirtualPS::WriteReal. Some PDF reader like; Acrobat do not work when a PDF file contains reals with exponent. This; method writes the real number ""z"" using the format ""%f"" instead of the; format ""%g"" when writing it with ""%g"" generates a number with exponent. TPDF(). Double_t CMtoPDF(Double_t u); {return Int_t(0.5 +",MatchSource.WIKI,root/html604/TPDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPDF.html
https://root.cern/root/html604/TPDF.html:14063,Modifiability,inherit,inherits,14063,"ge is not empty; Int_tfPageOrientationPage orientation (Portrait, Landscape); Bool_tTVirtualPS::fPrintedTrue when a page must be printed; Bool_tfRangeTrue when a range has been defined; Float_tfRedPer cent of red; Int_tTVirtualPS::fSizBufferBuffer size; Int_tfStartStream; ofstream*TVirtualPS::fStreamFile stream identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; Int_tfTypeWorkstation type used to know if the PDF is open; Float_tfXsizePage size along X; Float_tfYsizePage size along Y. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPDF(); Default PDF constructor. TPDF(const char* filename, Int_t type = -111); Initialize the PDF interface. fname : PDF file name; wtype : PDF workstation type. Not used in the PDF driver. But as TPDF; inherits from TVirtualPS it should be kept. Anyway it is not; necessary to specify this parameter at creation time because it; has a default value (which is ignore in the PDF case). ~TPDF(); Default PDF destructor. void CellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); Begin the Cell Array painting. void CellArrayFill(Int_t r, Int_t g, Int_t b); Paint the Cell Array. void CellArrayEnd(); End the Cell Array painting. void Close(Option_t* opt = """"); Close a PDF file. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw a Box. void DrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); Draw a Frame around a box. mode = -1 box looks as it is behind the screen; mode = 1 box looks as it is in front of the screen; border is the border size in already precomputed PDF units; dark is the color for the dark part of the frame; light is the color for the light part of the frame. void DrawHatch(Float_t ",MatchSource.WIKI,root/html604/TPDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPDF.html
https://root.cern/root/html604/TPDF.html:829,Testability,test,test,829,". TPDF. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TPDF. class TPDF: public TVirtualPS. TPDF: Graphics interface to PDF; Like PostScript, PDF is a vector graphics output format allowing a very high; graphics output quality. The functionalities provided by this class are very; similar to those provided by TPostScript. Compare to PostScript output, the PDF files are usually smaller because some; parts of them can be compressed. PDF also allows to define table of contents. This facility can be used in ROOT.; The following example shows how to proceed:. {; TCanvas* canvas = new TCanvas(""canvas"");; TH1F* histo = new TH1F(""histo"",""test 1"",10,0.,10.);; histo->SetFillColor(2);; histo->Fill(2.);; histo->Draw();; canvas->Print(""plots.pdf("",""Title:One bin filled"");; histo->Fill(4.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Two bins filled"");; histo->Fill(6.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Three bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Four bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf)"",""Title:The fourth bin content is 2"");; }. Each character string following the keyword ""Title:"" makes a new entry in; the table of contents.; . Function Members (Methods); public:. virtual~TPDF(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; vir",MatchSource.WIKI,root/html604/TPDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPDF.html
https://root.cern/root/html604/TPerfEvent.html:1362,Availability,error,error,1362," virtual~TPerfEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectSta",MatchSource.WIKI,root/html604/TPerfEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPerfEvent.html
https://root.cern/root/html604/TPerfEvent.html:1446,Availability,error,error,1446,"fEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html604/TPerfEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPerfEvent.html
https://root.cern/root/html604/TPerfEvent.html:324,Integrability,interface,interface,324,". TPerfEvent. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPerfEvent. class TPerfEvent: public TObject. TPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods); public:. virtual~TPerfEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectSta",MatchSource.WIKI,root/html604/TPerfEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPerfEvent.html
https://root.cern/root/html604/TPerfEvent.html:357,Performance,perform,performance,357,". TPerfEvent. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPerfEvent. class TPerfEvent: public TObject. TPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods); public:. virtual~TPerfEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectSta",MatchSource.WIKI,root/html604/TPerfEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPerfEvent.html
https://root.cern/root/html604/TPerfStats.html:1530,Availability,error,error,1530,"oidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TVirtualPerfStats*&TVirtualPerfStats::CurrentPerfStats(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*TVirtualPerfStats::EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const char* filename, Double_t start); virtual voidFileReadEvent(TFile* file, Int_t len, Double_t start); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetBytesRead() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; static voidGetMemValues(Long_t& vmax, Long_t& rmax); virtual const char*TObject::GetName() const; virtual Long64_tGetNumEvents() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const;",MatchSource.WIKI,root/html604/TPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPerfStats.html
https://root.cern/root/html604/TPerfStats.html:1614,Availability,error,error,1614,"b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TVirtualPerfStats*&TVirtualPerfStats::CurrentPerfStats(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*TVirtualPerfStats::EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const char* filename, Double_t start); virtual voidFileReadEvent(TFile* file, Int_t len, Double_t start); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetBytesRead() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; static voidGetMemValues(Long_t& vmax, Long_t& rmax); virtual const char*TObject::GetName() const; virtual Long64_tGetNumEvents() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const;",MatchSource.WIKI,root/html604/TPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPerfStats.html
https://root.cern/root/html604/TPerfStats.html:9606,Energy Efficiency,monitor,monitoring,9606,"ng processed per slave; TH2D*fProcTimeHist!histogram of real time spent processing packets; Int_tfSlaves!number of active slaves; Long64_tfTotBytesRead!total bytes read on all slaves; Double_tfTotCpuTime!total cpu time of all slaves; Long64_tfTotEvents!total number of events processed; TTree*fTrace!TTree with trace events; TTimeStampfTzero!start time of this run; static Long_tfgResMemMax! Max resident memory used by this process; static Long_tfgVirtMemMax! Max virtual memory used by this process. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPerfStats(TList* input, TList* output); Normal constructor. ~TPerfStats(); Destructor. void SimpleEvent(TVirtualPerfStats::EEventType type); Simple event. void PacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead); Packet event.; See WriteQueryLog for the descripition of the structure sent for monitoring; when fMonitorPerPacket is kTRUE. void FileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); File event. void FileOpenEvent(TFile* file, const char* filename, Double_t start); Open file event. void FileReadEvent(TFile* file, Int_t len, Double_t start); Read file event. void UnzipEvent(TObject* tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen); Record TTree file unzip event.; start is the TimeStamp before unzip; pos is where in the file the compressed buffer came from; complen is the length of the compressed buffer; objlen is the length of the de-compressed buffer. void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); Rate event. void SetBytesRead(Long64_t num); Set number of bytes read. Long64_t GetBytesRead() const; Get number of bytes read. void WriteQueryLog(); Send to the connected monitoring servers information related to this query.; The i",MatchSource.WIKI,root/html604/TPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPerfStats.html
https://root.cern/root/html604/TPerfStats.html:10535,Energy Efficiency,monitor,monitoring,10535,"; See WriteQueryLog for the descripition of the structure sent for monitoring; when fMonitorPerPacket is kTRUE. void FileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); File event. void FileOpenEvent(TFile* file, const char* filename, Double_t start); Open file event. void FileReadEvent(TFile* file, Int_t len, Double_t start); Read file event. void UnzipEvent(TObject* tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen); Record TTree file unzip event.; start is the TimeStamp before unzip; pos is where in the file the compressed buffer came from; complen is the length of the compressed buffer; objlen is the length of the de-compressed buffer. void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); Rate event. void SetBytesRead(Long64_t num); Set number of bytes read. Long64_t GetBytesRead() const; Get number of bytes read. void WriteQueryLog(); Send to the connected monitoring servers information related to this query.; The information is of three types: 'summary', 'dataset' and 'files'.; Actual 'table' formatting is done by the relevant sender, implementation of; TProofMonSender, where the details are given. void Setup(TList* input); Setup the PROOF input list with requested statistics and tracing options. void Start(TList* input, TList* output); Initialize PROOF statistics run. void Stop(); Terminate the PROOF statistics run. void SetMemValues(); Record memory usage. void GetMemValues(Long_t& vmax, Long_t& rmax); Get memory usage. TPerfStats(TList* input, TList* output). void SetNumEvents(Long64_t num); { fNumEvents = num; }. Long64_t GetNumEvents() const; { return fNumEvents; }. » Author: Kristjan Gulbrandsen 11/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-02 16:27; This page has been automatically generated. For comments or suggestions regarding the documentation",MatchSource.WIKI,root/html604/TPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPerfStats.html
https://root.cern/root/html604/TPerfStats.html:334,Integrability,interface,interface,334,". TPerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPerfStats. class TPerfStats: public TVirtualPerfStats. TPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods); public:. virtual~TPerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TVirtualPerfStats*&TVirtualPerfStats::CurrentPerfStats(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*TVirtualPerfStats::EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const char* filename, Double_t start); virtual voidFileReadEvent(TFil",MatchSource.WIKI,root/html604/TPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPerfStats.html
https://root.cern/root/html604/TPerfStats.html:367,Performance,perform,performance,367,". TPerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPerfStats. class TPerfStats: public TVirtualPerfStats. TPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods); public:. virtual~TPerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TVirtualPerfStats*&TVirtualPerfStats::CurrentPerfStats(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*TVirtualPerfStats::EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const char* filename, Double_t start); virtual voidFileReadEvent(TFil",MatchSource.WIKI,root/html604/TPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPerfStats.html
https://root.cern/root/html604/TPerfStats.html:4079,Performance,latency,latency,4079,"Class*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TPerfStats&operator=(const TPerfStats&); virtual voidPacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidRateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBytesRead(Long64_t num); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidSetMemValues(); virtual voidSetNumEvents(Long64_t num); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); static voidSetup",MatchSource.WIKI,root/html604/TPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPerfStats.html
https://root.cern/root/html604/TPerfStats.html:8129,Performance,latency,latency,8129,":EEventTypeTVirtualPerfStats::kStop; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kUnDefined; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Long64_tfBytesRead!track bytes read of main file; TH2D*fCpuTimeHist!histogram of cpu time spent processing packets; TDSet*fDSet!Saved pointer to the TDSet object; TStringfDataSet!Dataset string; Int_tfDataSetLen!Maximum size of the dataset string fDataSet; Int_tfDataSetSize!# of files in the dataset; Bool_tfDoHist!Fill histos; Bool_tfDoQuota!Save stats on SQL server for quota management; Bool_tfDoSlaveTrace!Full tracing in workers; Bool_tfDoTrace!Trace details in master; Bool_tfDoTraceRate!Trace processing rate in master; TH1D*fEventsHist!histogram of events processed per slave; TH2D*fLatencyHist!histogram of latency due to packet requests; TObjArrayfMonSenders!Monitoring engines; Bool_tfMonitorPerPacket!Whether to send the full entry per each packet; TH1D*fNodeHist!histogram of slaves per file serving node; Long64_tfNumEvents!total number of events to be processed; TList*fOutput!Saved pointer to the output list; TH1D*fPacketsHist!histogram of packets processed per slave; TPerfEvent*fPerfEvent!TPerfEvent used to fill tree; TH1I*fProcPcktHist!histogram of packets being processed per slave; TH2D*fProcTimeHist!histogram of real time spent processing packets; Int_tfSlaves!number of active slaves; Long64_tfTotBytesRead!total bytes read on all slaves; Double_tfTotCpuTime!total cpu time of all slaves; Long64_tfTotEvents!total number of events processed; TTree*fTrace!TTree with trace events; TTimeStampfTzero!start time of this run; static Long_tfgResMemMax! Max resident memory used by this process; static Long_tfgVirtMemMax! Max virtual memory used by this process. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPerfStats(TList* input, TList* output); Normal constructor. ~TPerfStats(); Destructor. void SimpleEvent(TVirtualPer",MatchSource.WIKI,root/html604/TPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPerfStats.html
https://root.cern/root/html604/TPerfStats.html:9459,Performance,latency,latency,9459,"H1D*fPacketsHist!histogram of packets processed per slave; TPerfEvent*fPerfEvent!TPerfEvent used to fill tree; TH1I*fProcPcktHist!histogram of packets being processed per slave; TH2D*fProcTimeHist!histogram of real time spent processing packets; Int_tfSlaves!number of active slaves; Long64_tfTotBytesRead!total bytes read on all slaves; Double_tfTotCpuTime!total cpu time of all slaves; Long64_tfTotEvents!total number of events processed; TTree*fTrace!TTree with trace events; TTimeStampfTzero!start time of this run; static Long_tfgResMemMax! Max resident memory used by this process; static Long_tfgVirtMemMax! Max virtual memory used by this process. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPerfStats(TList* input, TList* output); Normal constructor. ~TPerfStats(); Destructor. void SimpleEvent(TVirtualPerfStats::EEventType type); Simple event. void PacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead); Packet event.; See WriteQueryLog for the descripition of the structure sent for monitoring; when fMonitorPerPacket is kTRUE. void FileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); File event. void FileOpenEvent(TFile* file, const char* filename, Double_t start); Open file event. void FileReadEvent(TFile* file, Int_t len, Double_t start); Read file event. void UnzipEvent(TObject* tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen); Record TTree file unzip event.; start is the TimeStamp before unzip; pos is where in the file the compressed buffer came from; complen is the length of the compressed buffer; objlen is the length of the de-compressed buffer. void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); Rate event. void SetBytesRead(Long64_t num); Set number of bytes read. Long64_",MatchSource.WIKI,root/html604/TPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPerfStats.html
https://root.cern/root/html604/TPGON.html:2142,Availability,error,error,2142," virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTPCON::DefineSection(Int_t secNum, Float_t z, Float_t rmin, Float_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPCON::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&TPCON::GetBuffer3D(Int_t reqSections) const; virtual Float_tTPCON::GetDhi1() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_t*TPCON::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() co",MatchSource.WIKI,root/html604/TPGON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPGON.html
https://root.cern/root/html604/TPGON.html:2226,Availability,error,error,2226,"*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTPCON::DefineSection(Int_t secNum, Float_t z, Float_t rmin, Float_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPCON::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&TPCON::GetBuffer3D(Int_t reqSections) const; virtual Float_tTPCON::GetDhi1() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_t*TPCON::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTPCON::GetNdiv() const; virtual Int_tTShape::GetNumber() const; vi",MatchSource.WIKI,root/html604/TPGON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPGON.html
https://root.cern/root/html604/TPGON.html:549,Modifiability,extend,extends,549,". TPGON. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TPGON. class TPGON: public TPCON. . PGON is a polygon. It has the following parameters:. - name name of the shape; - title shape's title; - material (see TMaterial); - phi1 the azimuthal angle &phi at which the volume begins (angles; are counted counterclockwise); - dphi1 opening angle of the volume, which extends from phi1 to; phi1+dphi; - npdv number of sides of the cross section between the given; phi limits; - nz number of planes perpendicular to the z axis where; the dimension of the section is given -- this number; should be at least 2; - rmin array of dimension nz with minimum radius at a given plane; - rmax array of dimension nz with maximum radius at a given plane; - z array of dimension nz with z position of given plane. Function Members (Methods); public:. virtual~TPGON(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTPCON::DefineSection(Int_t secNum, Float_t z, Float_t rmin, Float_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPCON::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual v",MatchSource.WIKI,root/html604/TPGON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPGON.html
https://root.cern/root/html604/TPie.html:1391,Availability,error,error,1391," virtual~TPie(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); Int_tDistancetoSlice(Int_t, Int_t); virtual voidDraw(Option_t* option = ""l"")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t, Int_t, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Float_tGetAngle3D(); Double_tGetAngularOffset(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntries(); Int_tGetEntryFillColor(Int_t); Int_tGetEntryFillStyle(Int_t); const ",MatchSource.WIKI,root/html604/TPie.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPie.html
https://root.cern/root/html604/TPie.html:1475,Availability,error,error,1475,"od(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); Int_tDistancetoSlice(Int_t, Int_t); virtual voidDraw(Option_t* option = ""l"")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t, Int_t, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Float_tGetAngle3D(); Double_tGetAngularOffset(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntries(); Int_tGetEntryFillColor(Int_t); Int_tGetEntryFillStyle(Int_t); const char*GetEntryLabel(Int_t); Int_tGetEntryLineColor(Int_t); Int_tGetEntryLineStyle(Int_t); Int_tGetEntryLineWidth(Int_t); Double_tGetEntryRadiusOffset(Int_t); Double_tGetEntryVal(Int_t); const char*GetFractionFormat(); Double_tGetHeight(); virtual const char*TObject::GetIconName() const; const char*GetLabelFormat(); Float_tGetLabelsOffset(); TLegend*GetLegend(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static ",MatchSource.WIKI,root/html604/TPie.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPie.html
https://root.cern/root/html604/TPie.html:10541,Energy Efficiency,allocate,allocate,10541,"ext::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; TStringfValueFormatVform numeric format for the value; Double_tfXX coordinate of the pie centre; Double_tfYY coordinate of the pie centre. private:. TLegend*fLegend!Legend for this piechart; Float_t*fSlices!Subdivisions of the slices; Float_tfSum!Sum for the slice values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPie(); Default constructor. TPie(const char* , const char* , Int_t ); This constructor creates a pie chart when only the number of; the slices is known. The number of slices is fixed. TPie(const char* , const char* , Int_t , Double_t* , Int_t* cols = 0, const char*[] lbls = 0); Normal constructor. The 1st and 2nd parameters are the name of the object; and its title. The number of points passed at this point is used to allocate the memory. Slices values are given as Double_t. The 4th elements is an array containing, in double precision format,; the value of each slice. It is also possible to specify the filled color; of each slice. If the color array is not specfied the slices are colored; using a color sequence in the standard palette. TPie(const char* , const char* , Int_t , Float_t* , Int_t* cols = 0, const char*[] lbls = 0); Normal constructor (Float_t). TPie(const TH1* h); Constructor from a TH1. TPie(const TPie& ); Copy constructor. ~TPie(); Destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Evaluate the distance to the chart in gPad. Int_t DistancetoSlice(Int_t , Int_t ); Returns the slice number at the pixel position (px,py).; Returns -1 if no slice is picked. Used by DistancetoPrimitive. void Draw(Option_t* option = ""l""); Draw the pie chart. The possible options are listed in the TPie::Paint() method. void DrawGhost(); This method is for internal use. It is used by E",MatchSource.WIKI,root/html604/TPie.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPie.html
https://root.cern/root/html604/TPie.html:12791,Energy Efficiency,allocate,allocate,12791,"ntryFillColor(Int_t ); Return the color of the slice number ""i"". Int_t GetEntryFillStyle(Int_t ); Return the style use to fill the slice number ""i"". Int_t GetEntryLineColor(Int_t ); Return the line color used to outline thi ""i"" slice. Int_t GetEntryLineStyle(Int_t ); Return the style used to outline thi ""i"" slice. Int_t GetEntryLineWidth(Int_t ); Return the line width used to outline thi ""i"" slice. Double_t GetEntryRadiusOffset(Int_t ); Return the radial offset's value for the slice number ""i"". Double_t GetEntryVal(Int_t ); Return the value associated with the slice number ""i"". TLegend* GetLegend(); If created before by Paint option or by MakeLegend method return; the pointer to the legend, otherwise return 0;. TPieSlice* GetSlice(Int_t i); Return the reference to the slice of index 'id'. There are no controls; of memory corruption, be carefull. void Init(Int_t np, Double_t ao, Double_t x, Double_t y, Double_t r); Common initialization for all constructors.; This is a private function called to allocate the memory. TLegend* MakeLegend(Double_t x1 = 0.65000000000000002, Double_t y1 = 0.65000000000000002, Double_t x2 = 0.94999999999999996, Double_t y2 = 0.94999999999999996, const char* leg_header = """"); This method create a legend that explains the contents; of the slice for this pie-chart. The parameter passed reppresents the option passed to shown the slices,; see TLegend::AddEntry() for futher details. The pointer of the TLegend is returned. void Paint(Option_t* ); Paint a Pie chart in a canvas.; The possible option are:. ""R"" Print the labels along the central ""R""adius of slices.; ""T"" Print the label in a direction ""T""angent to circle that describes; the TPie.; ""SC"" Paint the the labels with the ""S""ame ""C""olor as the slices.; ""3D"" Draw the pie-chart with a pseudo 3D effect.; ""NOL"" No OutLine: Don't draw the slices' outlines, any property over the; slices' line is ignored.; "">"" Sort the slices in increasing order.; ""<"" Sort the slices in decreasing order. After the u",MatchSource.WIKI,root/html604/TPie.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPie.html
https://root.cern/root/html604/TPieEditor.html:4538,Availability,error,error,4538," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html604/TPieEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPieEditor.html
https://root.cern/root/html604/TPieEditor.html:4622,Availability,error,error,4622,"(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html604/TPieEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPieEditor.html
https://root.cern/root/html604/TPieEditor.html:18602,Availability,mask,mask,18602,,MatchSource.WIKI,root/html604/TPieEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPieEditor.html
https://root.cern/root/html604/TPieEditor.html:21997,Integrability,interface,interface,21997,"t_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; TGButtonGroup*fgrGroup the Radiobuttons:; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPieEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of graph editor. ~TPieEditor(); Destructor of pie editor. void ConnectSignals2Slots(); Connect signals to slots. void ActivateBaseClassEditors(TClass* ); Exclude TAttTextEditor from this interface. void SetModel(TObject* ); Pick up the used values of graph attributes. void DoTitle(const char* text); Slot for setting the graph title. void DoShape(); Slot connected to the draw options. void DoMarkerOnOff(Bool_t on); Slot for setting markers as visible/invisible. void DoChange3DAngle(); Slot for setting the 3D angle. void DoGraphLineWidth(); Slot connected to the graph line width. void DoTextChange(); Change text. TGComboBox* BuildFontSizeComboBox(TGFrame* , Int_t ); Create text size combo box. TPieEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: Guido Volpi 04/10/2007 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id$ » Last generated: 2015-06-02 16:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT s",MatchSource.WIKI,root/html604/TPieEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPieEditor.html
https://root.cern/root/html604/TPieEditor.html:18474,Usability,simpl,simple,18474,,MatchSource.WIKI,root/html604/TPieEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPieEditor.html
https://root.cern/root/html604/TPieSlice.html:1474,Availability,error,error,1474,"ct::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t, Int_t); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetRadiusOffset(); virtua",MatchSource.WIKI,root/html604/TPieSlice.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPieSlice.html
https://root.cern/root/html604/TPieSlice.html:1558,Availability,error,error,1558,"t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t, Int_t); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetRadiusOffset(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; D",MatchSource.WIKI,root/html604/TPieSlice.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPieSlice.html
https://root.cern/root/html604/TPieSliceEditor.html:4341,Availability,error,error,4341," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html604/TPieSliceEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPieSliceEditor.html
https://root.cern/root/html604/TPieSliceEditor.html:4425,Availability,error,error,4425,"(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html604/TPieSliceEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPieSliceEditor.html
https://root.cern/root/html604/TPieSliceEditor.html:18170,Availability,mask,mask,18170,,MatchSource.WIKI,root/html604/TPieSliceEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPieSliceEditor.html
https://root.cern/root/html604/TPluginHandler.html:4490,Availability,error,error,4490,,MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:4574,Availability,error,error,4574,"Pad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Int_tCheckPlugin() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Long_tExecPlugin<>(int nargs); Long_tExecPluginImpl<>(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetClass() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* c",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:10705,Availability,error,error,10705,"or global function; TStringfOriginorigin of plugin handler definition; TStringfPluginplugin library which should contain fClass; TStringfRegexpregular expression which must be matched in URI. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin); Create a plugin handler. Called by TPluginManager. ~TPluginHandler(); Cleanup plugin handler object. Bool_t CanHandle(const char* base, const char* uri); Check if regular expression appears in the URI, if so return kTRUE.; If URI = 0 always return kTRUE. void SetupCallEnv(); Setup ctor or static method call environment. Int_t CheckPlugin() const; Check if the plugin library for this handler exits. Returns 0; when it exists and -1 in case the plugin does not exist. Int_t LoadPlugin(); Load the plugin library for this handler. Returns 0 on successful loading; and -1 in case the library does not exist or in case of error. Bool_t CheckForExecPlugin(Int_t nargs); Check that we can properly run ExecPlugin. void Print(Option_t* opt = """") const; Print info about the plugin handler. If option is ""a"" print; also the ctor's that will be used. TPluginHandler(); { }. TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin). TPluginHandler& operator=(const TPluginHandler& ). const char * GetBase() const; { return fBase; }. const char * GetRegexp() const; { return fRegexp; }. const char * GetPlugin() const; { return fPlugin; }. const char * GetCtor() const; { return fCtor; }. const char * GetOrigin() const; { return fOrigin; }. const char * GetClass() const; { return fClass; }. » Author: Fons Rademakers 26/1/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:27; This page has been automatically generated. For c",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:3334,Integrability,depend,dependencies,3334,"xisting definition of TSQLServer, useful when there is more than; one plugin that can extend the same base class. The ""<constructor>""; should be the constructor or a static method that generates an; instance of the specified class. Global methods should start with; ""::"" in their name, like ""::CreateFitter()"".; Instead of being a shared library a plugin can also be a CINT; script, so instead of libDialog.so one can have Dialog.C.; The * is a placeholder in case there is no need for a URI to; differentiate between different plugins for the same base class.; For the default plugins see $ROOTSYS/etc/system.rootrc. Plugin handlers can also be registered at run time, e.g.:. gPluginMgr->AddHandler(""TSQLServer"", ""^sapdb:"",; ""TSapDBServer"", ""SapDB"",; ""TSapDBServer(const char*,const char*, const char*)"");. A list of currently defined handlers can be printed using:. gPluginMgr->Print(); // use option=""a"" to see ctors. The use of the plugin library manager removes all textual references; to hard-coded class and library names and the resulting dependencies; in the base classes. The plugin manager is used to extend a.o.; TFile, TSQLServer, TGrid, etc. functionality. Function Members (Methods); public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Int_tCheckPlugin() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtu",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:343,Modifiability,plugin,plugin,343,". TPluginHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginHandler. class TPluginHandler: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:396,Modifiability,plugin,plugin,396,". TPluginHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginHandler. class TPluginHandler: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:415,Modifiability,plugin,plugin,415,". TPluginHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginHandler. class TPluginHandler: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:442,Modifiability,plugin,plugin,442,". TPluginHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginHandler. class TPluginHandler: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:506,Modifiability,extend,extend,506,". TPluginHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginHandler. class TPluginHandler: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:617,Modifiability,extend,extend,617,". TPluginHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginHandler. class TPluginHandler: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:698,Modifiability,plugin,plugin,698,". TPluginHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginHandler. class TPluginHandler: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:922,Modifiability,plugin,plugin,922,". TPluginHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginHandler. class TPluginHandler: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:961,Modifiability,plugin,plugins,961,". TPluginHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginHandler. class TPluginHandler: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:985,Modifiability,plugin,plugin,985,". TPluginHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginHandler. class TPluginHandler: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:1146,Modifiability,plugin,plugin,1146,"mbers; data members; class charts. ROOT; » CORE; » BASE; » TPluginHandler. class TPluginHandler: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: TRFIOFile RFIO ""<constructor>""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""<constructor>""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""<constructor>""; Plugin.TVirtualFitter: * TFitt",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:2273,Modifiability,extend,extends,2273," e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: TRFIOFile RFIO ""<constructor>""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""<constructor>""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""<constructor>""; Plugin.TVirtualFitter: * TFitter Minuit ""TFitter(Int_t)"". Where the + in front of Plugin.TSQLServer says that it extends the; existing definition of TSQLServer, useful when there is more than; one plugin that can extend the same base class. The ""<constructor>""; should be the constructor or a static method that generates an; instance of the specified class. Global methods should start with; ""::"" in their name, like ""::CreateFitter()"".; Instead of being a shared library a plugin can also be a CINT; script, so instead of libDialog.so one can have Dialog.C.; The * is a placeholder in case there is no need for a URI to; differentiate between different plugins for the same base class.; For the default plugins see $ROOTSYS/etc/system.rootrc. Plugin handlers can also be registered at run time, e.g.:. gPluginMgr->AddHandler(""TSQLServer"", ""^sapdb:"",; ""TSapDBServer"", ""SapDB"",; ""TSapDBServer(const char*,const char*, const char*)"");. A list of currently defined handlers can be printed using:. gPluginMgr->Print(); // use option=""a"" to see ctors. The use of the plugin library manager removes all textual references; to hard-coded class and library names and the r",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:2357,Modifiability,plugin,plugin,2357," e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: TRFIOFile RFIO ""<constructor>""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""<constructor>""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""<constructor>""; Plugin.TVirtualFitter: * TFitter Minuit ""TFitter(Int_t)"". Where the + in front of Plugin.TSQLServer says that it extends the; existing definition of TSQLServer, useful when there is more than; one plugin that can extend the same base class. The ""<constructor>""; should be the constructor or a static method that generates an; instance of the specified class. Global methods should start with; ""::"" in their name, like ""::CreateFitter()"".; Instead of being a shared library a plugin can also be a CINT; script, so instead of libDialog.so one can have Dialog.C.; The * is a placeholder in case there is no need for a URI to; differentiate between different plugins for the same base class.; For the default plugins see $ROOTSYS/etc/system.rootrc. Plugin handlers can also be registered at run time, e.g.:. gPluginMgr->AddHandler(""TSQLServer"", ""^sapdb:"",; ""TSapDBServer"", ""SapDB"",; ""TSapDBServer(const char*,const char*, const char*)"");. A list of currently defined handlers can be printed using:. gPluginMgr->Print(); // use option=""a"" to see ctors. The use of the plugin library manager removes all textual references; to hard-coded class and library names and the r",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:2373,Modifiability,extend,extend,2373," e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: TRFIOFile RFIO ""<constructor>""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""<constructor>""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""<constructor>""; Plugin.TVirtualFitter: * TFitter Minuit ""TFitter(Int_t)"". Where the + in front of Plugin.TSQLServer says that it extends the; existing definition of TSQLServer, useful when there is more than; one plugin that can extend the same base class. The ""<constructor>""; should be the constructor or a static method that generates an; instance of the specified class. Global methods should start with; ""::"" in their name, like ""::CreateFitter()"".; Instead of being a shared library a plugin can also be a CINT; script, so instead of libDialog.so one can have Dialog.C.; The * is a placeholder in case there is no need for a URI to; differentiate between different plugins for the same base class.; For the default plugins see $ROOTSYS/etc/system.rootrc. Plugin handlers can also be registered at run time, e.g.:. gPluginMgr->AddHandler(""TSQLServer"", ""^sapdb:"",; ""TSapDBServer"", ""SapDB"",; ""TSapDBServer(const char*,const char*, const char*)"");. A list of currently defined handlers can be printed using:. gPluginMgr->Print(); // use option=""a"" to see ctors. The use of the plugin library manager removes all textual references; to hard-coded class and library names and the r",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:2635,Modifiability,plugin,plugin,2635,"ed.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: TRFIOFile RFIO ""<constructor>""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""<constructor>""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""<constructor>""; Plugin.TVirtualFitter: * TFitter Minuit ""TFitter(Int_t)"". Where the + in front of Plugin.TSQLServer says that it extends the; existing definition of TSQLServer, useful when there is more than; one plugin that can extend the same base class. The ""<constructor>""; should be the constructor or a static method that generates an; instance of the specified class. Global methods should start with; ""::"" in their name, like ""::CreateFitter()"".; Instead of being a shared library a plugin can also be a CINT; script, so instead of libDialog.so one can have Dialog.C.; The * is a placeholder in case there is no need for a URI to; differentiate between different plugins for the same base class.; For the default plugins see $ROOTSYS/etc/system.rootrc. Plugin handlers can also be registered at run time, e.g.:. gPluginMgr->AddHandler(""TSQLServer"", ""^sapdb:"",; ""TSapDBServer"", ""SapDB"",; ""TSapDBServer(const char*,const char*, const char*)"");. A list of currently defined handlers can be printed using:. gPluginMgr->Print(); // use option=""a"" to see ctors. The use of the plugin library manager removes all textual references; to hard-coded class and library names and the resulting dependencies; in the base classes. The plugin manager is used to extend a.o.; TFile, TSQLServer, TGrid, etc. functionality. Function Members (Methods); public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b);",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:2815,Modifiability,plugin,plugins,2815,"DCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: TRFIOFile RFIO ""<constructor>""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""<constructor>""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""<constructor>""; Plugin.TVirtualFitter: * TFitter Minuit ""TFitter(Int_t)"". Where the + in front of Plugin.TSQLServer says that it extends the; existing definition of TSQLServer, useful when there is more than; one plugin that can extend the same base class. The ""<constructor>""; should be the constructor or a static method that generates an; instance of the specified class. Global methods should start with; ""::"" in their name, like ""::CreateFitter()"".; Instead of being a shared library a plugin can also be a CINT; script, so instead of libDialog.so one can have Dialog.C.; The * is a placeholder in case there is no need for a URI to; differentiate between different plugins for the same base class.; For the default plugins see $ROOTSYS/etc/system.rootrc. Plugin handlers can also be registered at run time, e.g.:. gPluginMgr->AddHandler(""TSQLServer"", ""^sapdb:"",; ""TSapDBServer"", ""SapDB"",; ""TSapDBServer(const char*,const char*, const char*)"");. A list of currently defined handlers can be printed using:. gPluginMgr->Print(); // use option=""a"" to see ctors. The use of the plugin library manager removes all textual references; to hard-coded class and library names and the resulting dependencies; in the base classes. The plugin manager is used to extend a.o.; TFile, TSQLServer, TGrid, etc. functionality. Function Members (Methods); public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Int_tCheckPlugin() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """,MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:2865,Modifiability,plugin,plugins,2865,"s in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: TRFIOFile RFIO ""<constructor>""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""<constructor>""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""<constructor>""; Plugin.TVirtualFitter: * TFitter Minuit ""TFitter(Int_t)"". Where the + in front of Plugin.TSQLServer says that it extends the; existing definition of TSQLServer, useful when there is more than; one plugin that can extend the same base class. The ""<constructor>""; should be the constructor or a static method that generates an; instance of the specified class. Global methods should start with; ""::"" in their name, like ""::CreateFitter()"".; Instead of being a shared library a plugin can also be a CINT; script, so instead of libDialog.so one can have Dialog.C.; The * is a placeholder in case there is no need for a URI to; differentiate between different plugins for the same base class.; For the default plugins see $ROOTSYS/etc/system.rootrc. Plugin handlers can also be registered at run time, e.g.:. gPluginMgr->AddHandler(""TSQLServer"", ""^sapdb:"",; ""TSapDBServer"", ""SapDB"",; ""TSapDBServer(const char*,const char*, const char*)"");. A list of currently defined handlers can be printed using:. gPluginMgr->Print(); // use option=""a"" to see ctors. The use of the plugin library manager removes all textual references; to hard-coded class and library names and the resulting dependencies; in the base classes. The plugin manager is used to extend a.o.; TFile, TSQLServer, TGrid, etc. functionality. Function Members (Methods); public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Int_tCheckPlugin() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject:",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:3223,Modifiability,plugin,plugin,3223,"xisting definition of TSQLServer, useful when there is more than; one plugin that can extend the same base class. The ""<constructor>""; should be the constructor or a static method that generates an; instance of the specified class. Global methods should start with; ""::"" in their name, like ""::CreateFitter()"".; Instead of being a shared library a plugin can also be a CINT; script, so instead of libDialog.so one can have Dialog.C.; The * is a placeholder in case there is no need for a URI to; differentiate between different plugins for the same base class.; For the default plugins see $ROOTSYS/etc/system.rootrc. Plugin handlers can also be registered at run time, e.g.:. gPluginMgr->AddHandler(""TSQLServer"", ""^sapdb:"",; ""TSapDBServer"", ""SapDB"",; ""TSapDBServer(const char*,const char*, const char*)"");. A list of currently defined handlers can be printed using:. gPluginMgr->Print(); // use option=""a"" to see ctors. The use of the plugin library manager removes all textual references; to hard-coded class and library names and the resulting dependencies; in the base classes. The plugin manager is used to extend a.o.; TFile, TSQLServer, TGrid, etc. functionality. Function Members (Methods); public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Int_tCheckPlugin() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtu",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:3373,Modifiability,plugin,plugin,3373," base class. The ""<constructor>""; should be the constructor or a static method that generates an; instance of the specified class. Global methods should start with; ""::"" in their name, like ""::CreateFitter()"".; Instead of being a shared library a plugin can also be a CINT; script, so instead of libDialog.so one can have Dialog.C.; The * is a placeholder in case there is no need for a URI to; differentiate between different plugins for the same base class.; For the default plugins see $ROOTSYS/etc/system.rootrc. Plugin handlers can also be registered at run time, e.g.:. gPluginMgr->AddHandler(""TSQLServer"", ""^sapdb:"",; ""TSapDBServer"", ""SapDB"",; ""TSapDBServer(const char*,const char*, const char*)"");. A list of currently defined handlers can be printed using:. gPluginMgr->Print(); // use option=""a"" to see ctors. The use of the plugin library manager removes all textual references; to hard-coded class and library names and the resulting dependencies; in the base classes. The plugin manager is used to extend a.o.; TFile, TSQLServer, TGrid, etc. functionality. Function Members (Methods); public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Int_tCheckPlugin() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Long_tExecPlugin<>(int nargs); ",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:3399,Modifiability,extend,extend,3399," base class. The ""<constructor>""; should be the constructor or a static method that generates an; instance of the specified class. Global methods should start with; ""::"" in their name, like ""::CreateFitter()"".; Instead of being a shared library a plugin can also be a CINT; script, so instead of libDialog.so one can have Dialog.C.; The * is a placeholder in case there is no need for a URI to; differentiate between different plugins for the same base class.; For the default plugins see $ROOTSYS/etc/system.rootrc. Plugin handlers can also be registered at run time, e.g.:. gPluginMgr->AddHandler(""TSQLServer"", ""^sapdb:"",; ""TSapDBServer"", ""SapDB"",; ""TSapDBServer(const char*,const char*, const char*)"");. A list of currently defined handlers can be printed using:. gPluginMgr->Print(); // use option=""a"" to see ctors. The use of the plugin library manager removes all textual references; to hard-coded class and library names and the resulting dependencies; in the base classes. The plugin manager is used to extend a.o.; TFile, TSQLServer, TGrid, etc. functionality. Function Members (Methods); public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Int_tCheckPlugin() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Long_tExecPlugin<>(int nargs); ",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:8444,Modifiability,plugin,pluginName,8444,"ShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. virtual~TPluginHandler(); Bool_tCanHandle(const char* base, const char* uri); Bool_tCheckForExecPlugin(Int_t nargs); const char*GetBase() const; const char*GetCtor() const; const char*GetOrigin() const; const char*GetPlugin() const; const char*GetRegexp() const; TPluginHandler&operator=(const TPluginHandler&); voidSetupCallEnv(); TPluginHandler(); TPluginHandler(const TPluginHandler&); TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:9296,Modifiability,extend,extended,9296,"itMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfBasebase class which will be extended by plugin; TMethodCall*fCallEnv!ctor method call environment; Int_tfCanCall!if 1 fCallEnv is ok, -1 fCallEnv is not ok; TStringfClassclass to be loaded from plugin library; TStringfCtorctor used to instantiate object of fClass; Bool_tfIsGlobalplugin ctor is a global function; Bool_tfIsMacroplugin is a macro and not a library; TFunction*fMethod!ctor method or global function; TStringfOriginorigin of plugin handler definition; TStringfPluginplugin library which should contain fClass; TStringfRegexpregular expression which must be matched in URI. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin); Create a plugin handler. Called by TPluginManager. ~TPluginHandler(); Cleanup plugin handler object. Bool_t CanHandle(const char* base, const char* uri); Check if regular expression appears in the URI, if so return kTRUE.; If URI = 0 always return kTRUE. void SetupCallEnv(); Setup ctor or static method call environment. Int_t CheckPlugin() const; Check if the plugin library for this handler exits. Returns 0; when it exists and -1 in case the plugin does not exist. In",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:9308,Modifiability,plugin,plugin,9308,"itMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfBasebase class which will be extended by plugin; TMethodCall*fCallEnv!ctor method call environment; Int_tfCanCall!if 1 fCallEnv is ok, -1 fCallEnv is not ok; TStringfClassclass to be loaded from plugin library; TStringfCtorctor used to instantiate object of fClass; Bool_tfIsGlobalplugin ctor is a global function; Bool_tfIsMacroplugin is a macro and not a library; TFunction*fMethod!ctor method or global function; TStringfOriginorigin of plugin handler definition; TStringfPluginplugin library which should contain fClass; TStringfRegexpregular expression which must be matched in URI. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin); Create a plugin handler. Called by TPluginManager. ~TPluginHandler(); Cleanup plugin handler object. Bool_t CanHandle(const char* base, const char* uri); Check if regular expression appears in the URI, if so return kTRUE.; If URI = 0 always return kTRUE. void SetupCallEnv(); Setup ctor or static method call environment. Int_t CheckPlugin() const; Check if the plugin library for this handler exits. Returns 0; when it exists and -1 in case the plugin does not exist. In",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:9462,Modifiability,plugin,plugin,9462,"itMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfBasebase class which will be extended by plugin; TMethodCall*fCallEnv!ctor method call environment; Int_tfCanCall!if 1 fCallEnv is ok, -1 fCallEnv is not ok; TStringfClassclass to be loaded from plugin library; TStringfCtorctor used to instantiate object of fClass; Bool_tfIsGlobalplugin ctor is a global function; Bool_tfIsMacroplugin is a macro and not a library; TFunction*fMethod!ctor method or global function; TStringfOriginorigin of plugin handler definition; TStringfPluginplugin library which should contain fClass; TStringfRegexpregular expression which must be matched in URI. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin); Create a plugin handler. Called by TPluginManager. ~TPluginHandler(); Cleanup plugin handler object. Bool_t CanHandle(const char* base, const char* uri); Check if regular expression appears in the URI, if so return kTRUE.; If URI = 0 always return kTRUE. void SetupCallEnv(); Setup ctor or static method call environment. Int_t CheckPlugin() const; Check if the plugin library for this handler exits. Returns 0; when it exists and -1 in case the plugin does not exist. In",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:9707,Modifiability,plugin,plugin,9707,"itMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfBasebase class which will be extended by plugin; TMethodCall*fCallEnv!ctor method call environment; Int_tfCanCall!if 1 fCallEnv is ok, -1 fCallEnv is not ok; TStringfClassclass to be loaded from plugin library; TStringfCtorctor used to instantiate object of fClass; Bool_tfIsGlobalplugin ctor is a global function; Bool_tfIsMacroplugin is a macro and not a library; TFunction*fMethod!ctor method or global function; TStringfOriginorigin of plugin handler definition; TStringfPluginplugin library which should contain fClass; TStringfRegexpregular expression which must be matched in URI. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin); Create a plugin handler. Called by TPluginManager. ~TPluginHandler(); Cleanup plugin handler object. Bool_t CanHandle(const char* base, const char* uri); Check if regular expression appears in the URI, if so return kTRUE.; If URI = 0 always return kTRUE. void SetupCallEnv(); Setup ctor or static method call environment. Int_t CheckPlugin() const; Check if the plugin library for this handler exits. Returns 0; when it exists and -1 in case the plugin does not exist. In",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:10034,Modifiability,plugin,pluginName,10034,"TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfBasebase class which will be extended by plugin; TMethodCall*fCallEnv!ctor method call environment; Int_tfCanCall!if 1 fCallEnv is ok, -1 fCallEnv is not ok; TStringfClassclass to be loaded from plugin library; TStringfCtorctor used to instantiate object of fClass; Bool_tfIsGlobalplugin ctor is a global function; Bool_tfIsMacroplugin is a macro and not a library; TFunction*fMethod!ctor method or global function; TStringfOriginorigin of plugin handler definition; TStringfPluginplugin library which should contain fClass; TStringfRegexpregular expression which must be matched in URI. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin); Create a plugin handler. Called by TPluginManager. ~TPluginHandler(); Cleanup plugin handler object. Bool_t CanHandle(const char* base, const char* uri); Check if regular expression appears in the URI, if so return kTRUE.; If URI = 0 always return kTRUE. void SetupCallEnv(); Setup ctor or static method call environment. Int_t CheckPlugin() const; Check if the plugin library for this handler exits. Returns 0; when it exists and -1 in case the plugin does not exist. Int_t LoadPlugin(); Load the plugin library for this handler. Returns 0 on successful loading; and -1 in case the library does not exist or in case of error. Bool_t CheckForExecPlugin(Int_t nargs); Check that we can properly run ExecPlugin. void Print(Option_t* opt = """") const; Print info about the plugin handler. If option is ""a"" print; also the ctor's that will be used. TPluginHandler(); { }. TPluginHandler(const char* base, const char* regexp, const char",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:10094,Modifiability,plugin,plugin,10094,"TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfBasebase class which will be extended by plugin; TMethodCall*fCallEnv!ctor method call environment; Int_tfCanCall!if 1 fCallEnv is ok, -1 fCallEnv is not ok; TStringfClassclass to be loaded from plugin library; TStringfCtorctor used to instantiate object of fClass; Bool_tfIsGlobalplugin ctor is a global function; Bool_tfIsMacroplugin is a macro and not a library; TFunction*fMethod!ctor method or global function; TStringfOriginorigin of plugin handler definition; TStringfPluginplugin library which should contain fClass; TStringfRegexpregular expression which must be matched in URI. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin); Create a plugin handler. Called by TPluginManager. ~TPluginHandler(); Cleanup plugin handler object. Bool_t CanHandle(const char* base, const char* uri); Check if regular expression appears in the URI, if so return kTRUE.; If URI = 0 always return kTRUE. void SetupCallEnv(); Setup ctor or static method call environment. Int_t CheckPlugin() const; Check if the plugin library for this handler exits. Returns 0; when it exists and -1 in case the plugin does not exist. Int_t LoadPlugin(); Load the plugin library for this handler. Returns 0 on successful loading; and -1 in case the library does not exist or in case of error. Bool_t CheckForExecPlugin(Int_t nargs); Check that we can properly run ExecPlugin. void Print(Option_t* opt = """") const; Print info about the plugin handler. If option is ""a"" print; also the ctor's that will be used. TPluginHandler(); { }. TPluginHandler(const char* base, const char* regexp, const char",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:10163,Modifiability,plugin,plugin,10163," TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfBasebase class which will be extended by plugin; TMethodCall*fCallEnv!ctor method call environment; Int_tfCanCall!if 1 fCallEnv is ok, -1 fCallEnv is not ok; TStringfClassclass to be loaded from plugin library; TStringfCtorctor used to instantiate object of fClass; Bool_tfIsGlobalplugin ctor is a global function; Bool_tfIsMacroplugin is a macro and not a library; TFunction*fMethod!ctor method or global function; TStringfOriginorigin of plugin handler definition; TStringfPluginplugin library which should contain fClass; TStringfRegexpregular expression which must be matched in URI. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin); Create a plugin handler. Called by TPluginManager. ~TPluginHandler(); Cleanup plugin handler object. Bool_t CanHandle(const char* base, const char* uri); Check if regular expression appears in the URI, if so return kTRUE.; If URI = 0 always return kTRUE. void SetupCallEnv(); Setup ctor or static method call environment. Int_t CheckPlugin() const; Check if the plugin library for this handler exits. Returns 0; when it exists and -1 in case the plugin does not exist. Int_t LoadPlugin(); Load the plugin library for this handler. Returns 0 on successful loading; and -1 in case the library does not exist or in case of error. Bool_t CheckForExecPlugin(Int_t nargs); Check that we can properly run ExecPlugin. void Print(Option_t* opt = """") const; Print info about the plugin handler. If option is ""a"" print; also the ctor's that will be used. TPluginHandler(); { }. TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin). TPluginHandler& operator=(const TPluginHandler& ). const char * GetBa",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:10447,Modifiability,plugin,plugin,10447,"o be loaded from plugin library; TStringfCtorctor used to instantiate object of fClass; Bool_tfIsGlobalplugin ctor is a global function; Bool_tfIsMacroplugin is a macro and not a library; TFunction*fMethod!ctor method or global function; TStringfOriginorigin of plugin handler definition; TStringfPluginplugin library which should contain fClass; TStringfRegexpregular expression which must be matched in URI. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin); Create a plugin handler. Called by TPluginManager. ~TPluginHandler(); Cleanup plugin handler object. Bool_t CanHandle(const char* base, const char* uri); Check if regular expression appears in the URI, if so return kTRUE.; If URI = 0 always return kTRUE. void SetupCallEnv(); Setup ctor or static method call environment. Int_t CheckPlugin() const; Check if the plugin library for this handler exits. Returns 0; when it exists and -1 in case the plugin does not exist. Int_t LoadPlugin(); Load the plugin library for this handler. Returns 0 on successful loading; and -1 in case the library does not exist or in case of error. Bool_t CheckForExecPlugin(Int_t nargs); Check that we can properly run ExecPlugin. void Print(Option_t* opt = """") const; Print info about the plugin handler. If option is ""a"" print; also the ctor's that will be used. TPluginHandler(); { }. TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin). TPluginHandler& operator=(const TPluginHandler& ). const char * GetBase() const; { return fBase; }. const char * GetRegexp() const; { return fRegexp; }. const char * GetPlugin() const; { return fPlugin; }. const char * GetCtor() const; { return fCtor; }. const char * GetOrigin() const; { return fOrigin; }. const char * GetClass() const; { return fClass;",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:10531,Modifiability,plugin,plugin,10531,"ct of fClass; Bool_tfIsGlobalplugin ctor is a global function; Bool_tfIsMacroplugin is a macro and not a library; TFunction*fMethod!ctor method or global function; TStringfOriginorigin of plugin handler definition; TStringfPluginplugin library which should contain fClass; TStringfRegexpregular expression which must be matched in URI. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin); Create a plugin handler. Called by TPluginManager. ~TPluginHandler(); Cleanup plugin handler object. Bool_t CanHandle(const char* base, const char* uri); Check if regular expression appears in the URI, if so return kTRUE.; If URI = 0 always return kTRUE. void SetupCallEnv(); Setup ctor or static method call environment. Int_t CheckPlugin() const; Check if the plugin library for this handler exits. Returns 0; when it exists and -1 in case the plugin does not exist. Int_t LoadPlugin(); Load the plugin library for this handler. Returns 0 on successful loading; and -1 in case the library does not exist or in case of error. Bool_t CheckForExecPlugin(Int_t nargs); Check that we can properly run ExecPlugin. void Print(Option_t* opt = """") const; Print info about the plugin handler. If option is ""a"" print; also the ctor's that will be used. TPluginHandler(); { }. TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin). TPluginHandler& operator=(const TPluginHandler& ). const char * GetBase() const; { return fBase; }. const char * GetRegexp() const; { return fRegexp; }. const char * GetPlugin() const; { return fPlugin; }. const char * GetCtor() const; { return fCtor; }. const char * GetOrigin() const; { return fOrigin; }. const char * GetClass() const; { return fClass; }. » Author: Fons Rademakers 26/1/2002 » Copyright (C) 1995-2002, Rene B",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:10583,Modifiability,plugin,plugin,10583,"ol_tfIsMacroplugin is a macro and not a library; TFunction*fMethod!ctor method or global function; TStringfOriginorigin of plugin handler definition; TStringfPluginplugin library which should contain fClass; TStringfRegexpregular expression which must be matched in URI. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin); Create a plugin handler. Called by TPluginManager. ~TPluginHandler(); Cleanup plugin handler object. Bool_t CanHandle(const char* base, const char* uri); Check if regular expression appears in the URI, if so return kTRUE.; If URI = 0 always return kTRUE. void SetupCallEnv(); Setup ctor or static method call environment. Int_t CheckPlugin() const; Check if the plugin library for this handler exits. Returns 0; when it exists and -1 in case the plugin does not exist. Int_t LoadPlugin(); Load the plugin library for this handler. Returns 0 on successful loading; and -1 in case the library does not exist or in case of error. Bool_t CheckForExecPlugin(Int_t nargs); Check that we can properly run ExecPlugin. void Print(Option_t* opt = """") const; Print info about the plugin handler. If option is ""a"" print; also the ctor's that will be used. TPluginHandler(); { }. TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin). TPluginHandler& operator=(const TPluginHandler& ). const char * GetBase() const; { return fBase; }. const char * GetRegexp() const; { return fRegexp; }. const char * GetPlugin() const; { return fPlugin; }. const char * GetCtor() const; { return fCtor; }. const char * GetOrigin() const; { return fOrigin; }. const char * GetClass() const; { return fClass; }. » Author: Fons Rademakers 26/1/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:10854,Modifiability,plugin,plugin,10854,"should contain fClass; TStringfRegexpregular expression which must be matched in URI. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin); Create a plugin handler. Called by TPluginManager. ~TPluginHandler(); Cleanup plugin handler object. Bool_t CanHandle(const char* base, const char* uri); Check if regular expression appears in the URI, if so return kTRUE.; If URI = 0 always return kTRUE. void SetupCallEnv(); Setup ctor or static method call environment. Int_t CheckPlugin() const; Check if the plugin library for this handler exits. Returns 0; when it exists and -1 in case the plugin does not exist. Int_t LoadPlugin(); Load the plugin library for this handler. Returns 0 on successful loading; and -1 in case the library does not exist or in case of error. Bool_t CheckForExecPlugin(Int_t nargs); Check that we can properly run ExecPlugin. void Print(Option_t* opt = """") const; Print info about the plugin handler. If option is ""a"" print; also the ctor's that will be used. TPluginHandler(); { }. TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin). TPluginHandler& operator=(const TPluginHandler& ). const char * GetBase() const; { return fBase; }. const char * GetRegexp() const; { return fRegexp; }. const char * GetPlugin() const; { return fPlugin; }. const char * GetCtor() const; { return fCtor; }. const char * GetOrigin() const; { return fOrigin; }. const char * GetClass() const; { return fClass; }. » Author: Fons Rademakers 26/1/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:11040,Modifiability,plugin,pluginName,11040,"should contain fClass; TStringfRegexpregular expression which must be matched in URI. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin); Create a plugin handler. Called by TPluginManager. ~TPluginHandler(); Cleanup plugin handler object. Bool_t CanHandle(const char* base, const char* uri); Check if regular expression appears in the URI, if so return kTRUE.; If URI = 0 always return kTRUE. void SetupCallEnv(); Setup ctor or static method call environment. Int_t CheckPlugin() const; Check if the plugin library for this handler exits. Returns 0; when it exists and -1 in case the plugin does not exist. Int_t LoadPlugin(); Load the plugin library for this handler. Returns 0 on successful loading; and -1 in case the library does not exist or in case of error. Bool_t CheckForExecPlugin(Int_t nargs); Check that we can properly run ExecPlugin. void Print(Option_t* opt = """") const; Print info about the plugin handler. If option is ""a"" print; also the ctor's that will be used. TPluginHandler(); { }. TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin). TPluginHandler& operator=(const TPluginHandler& ). const char * GetBase() const; { return fBase; }. const char * GetRegexp() const; { return fRegexp; }. const char * GetPlugin() const; { return fPlugin; }. const char * GetCtor() const; { return fCtor; }. const char * GetOrigin() const; { return fOrigin; }. const char * GetClass() const; { return fClass; }. » Author: Fons Rademakers 26/1/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:461,Performance,load,load,461,". TPluginHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginHandler. class TPluginHandler: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:689,Performance,load,load,689,". TPluginHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginHandler. class TPluginHandler: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:765,Performance,load,loading,765,". TPluginHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginHandler. class TPluginHandler: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:9450,Performance,load,loaded,9450,"itMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfBasebase class which will be extended by plugin; TMethodCall*fCallEnv!ctor method call environment; Int_tfCanCall!if 1 fCallEnv is ok, -1 fCallEnv is not ok; TStringfClassclass to be loaded from plugin library; TStringfCtorctor used to instantiate object of fClass; Bool_tfIsGlobalplugin ctor is a global function; Bool_tfIsMacroplugin is a macro and not a library; TFunction*fMethod!ctor method or global function; TStringfOriginorigin of plugin handler definition; TStringfPluginplugin library which should contain fClass; TStringfRegexpregular expression which must be matched in URI. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin); Create a plugin handler. Called by TPluginManager. ~TPluginHandler(); Cleanup plugin handler object. Bool_t CanHandle(const char* base, const char* uri); Check if regular expression appears in the URI, if so return kTRUE.; If URI = 0 always return kTRUE. void SetupCallEnv(); Setup ctor or static method call environment. Int_t CheckPlugin() const; Check if the plugin library for this handler exits. Returns 0; when it exists and -1 in case the plugin does not exist. In",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginHandler.html:10640,Performance,load,loading,10640,"or global function; TStringfOriginorigin of plugin handler definition; TStringfPluginplugin library which should contain fClass; TStringfRegexpregular expression which must be matched in URI. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin); Create a plugin handler. Called by TPluginManager. ~TPluginHandler(); Cleanup plugin handler object. Bool_t CanHandle(const char* base, const char* uri); Check if regular expression appears in the URI, if so return kTRUE.; If URI = 0 always return kTRUE. void SetupCallEnv(); Setup ctor or static method call environment. Int_t CheckPlugin() const; Check if the plugin library for this handler exits. Returns 0; when it exists and -1 in case the plugin does not exist. Int_t LoadPlugin(); Load the plugin library for this handler. Returns 0 on successful loading; and -1 in case the library does not exist or in case of error. Bool_t CheckForExecPlugin(Int_t nargs); Check that we can properly run ExecPlugin. void Print(Option_t* opt = """") const; Print info about the plugin handler. If option is ""a"" print; also the ctor's that will be used. TPluginHandler(); { }. TPluginHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor, const char* origin). TPluginHandler& operator=(const TPluginHandler& ). const char * GetBase() const; { return fBase; }. const char * GetRegexp() const; { return fRegexp; }. const char * GetPlugin() const; { return fPlugin; }. const char * GetCtor() const; { return fCtor; }. const char * GetOrigin() const; { return fOrigin; }. const char * GetClass() const; { return fClass; }. » Author: Fons Rademakers 26/1/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:27; This page has been automatically generated. For c",MatchSource.WIKI,root/html604/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginHandler.html
https://root.cern/root/html604/TPluginManager.html:4580,Availability,error,error,4580,"Handler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor = 0, const char* origin = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TPluginHandler*FindHandler(const char* base, const char* uri = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) co",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:4664,Availability,error,error,4664,"ginName, const char* ctor = 0, const char* origin = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TPluginHandler*FindHandler(const char* base, const char* uri = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:11236,Availability,down,downloading,11236,". The $ROOTSYS/etc/plugins is the default top plugin directory; specified in $ROOTSYS/etc/system.rootrc. The macros must have names; like <BaseClass>/PX0_<PluginClass>.C, e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a namespace; the directory must have the name NameSpace@@BaseClass as : is a reserved; pathname character on some operating systems. Macros not beginning with; 'P' and ending with "".C"" are ignored. If base is specified only plugin; macros for that base class are loaded. The macros typically; should look like:; void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*,const char*,Int_t)"");; }; In general these macros should not cause side effects, by changing global; ROOT state via, e.g. gSystem calls, etc. However, in specific cases; this might be useful, e.g. adding a library search path, adding a specific; dependency, check on some OS or ROOT capability or downloading; of the plugin. void AddHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor = 0, const char* origin = 0); Add plugin handler to the list of handlers. If there is already a; handler defined for the same base and regexp it will be replaced. void RemoveHandler(const char* base, const char* regexp = 0); Remove handler for the specified base class and the specified; regexp. If regexp=0 remove all handlers for the specified base. TPluginHandler * FindHandler(const char* base, const char* uri = 0); Returns the handler if there exists a handler for the specified URI.; The uri can be 0 in which case the first matching plugin handler; will be returned. Returns 0 in case handler is not found. void Print(Option_t* opt = """") const; Print list of registered plugin handlers. If option is ""a"" print; also the ctor's that will be used. Int_t WritePluginMacros(const char* dir, const char* plugin = 0",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:3334,Integrability,depend,dependencies,3334,"xisting definition of TSQLServer, useful when there is more than; one plugin that can extend the same base class. The ""<constructor>""; should be the constructor or a static method that generates an; instance of the specified class. Global methods should start with; ""::"" in their name, like ""::CreateFitter()"".; Instead of being a shared library a plugin can also be a CINT; script, so instead of libDialog.so one can have Dialog.C.; The * is a placeholder in case there is no need for a URI to; differentiate between different plugins for the same base class.; For the default plugins see $ROOTSYS/etc/system.rootrc. Plugin handlers can also be registered at run time, e.g.:. gPluginMgr->AddHandler(""TSQLServer"", ""^sapdb:"",; ""TSapDBServer"", ""SapDB"",; ""TSapDBServer(const char*,const char*, const char*)"");. A list of currently defined handlers can be printed using:. gPluginMgr->Print(); // use option=""a"" to see ctors. The use of the plugin library manager removes all textual references; to hard-coded class and library names and the resulting dependencies; in the base classes. The plugin manager is used to extend a.o.; TFile, TSQLServer, TGrid, etc. functionality. Function Members (Methods); public:. virtual~TPluginManager(); voidTObject::AbstractMethod(const char* method) const; voidAddHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor = 0, const char* origin = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidT",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:11185,Integrability,depend,dependency,11185,". The $ROOTSYS/etc/plugins is the default top plugin directory; specified in $ROOTSYS/etc/system.rootrc. The macros must have names; like <BaseClass>/PX0_<PluginClass>.C, e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a namespace; the directory must have the name NameSpace@@BaseClass as : is a reserved; pathname character on some operating systems. Macros not beginning with; 'P' and ending with "".C"" are ignored. If base is specified only plugin; macros for that base class are loaded. The macros typically; should look like:; void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*,const char*,Int_t)"");; }; In general these macros should not cause side effects, by changing global; ROOT state via, e.g. gSystem calls, etc. However, in specific cases; this might be useful, e.g. adding a library search path, adding a specific; dependency, check on some OS or ROOT capability or downloading; of the plugin. void AddHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor = 0, const char* origin = 0); Add plugin handler to the list of handlers. If there is already a; handler defined for the same base and regexp it will be replaced. void RemoveHandler(const char* base, const char* regexp = 0); Remove handler for the specified base class and the specified; regexp. If regexp=0 remove all handlers for the specified base. TPluginHandler * FindHandler(const char* base, const char* uri = 0); Returns the handler if there exists a handler for the specified URI.; The uri can be 0 in which case the first matching plugin handler; will be returned. Returns 0 in case handler is not found. void Print(Option_t* opt = """") const; Print list of registered plugin handlers. If option is ""a"" print; also the ctor's that will be used. Int_t WritePluginMacros(const char* dir, const char* plugin = 0",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:343,Modifiability,plugin,plugin,343,". TPluginManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginManager. class TPluginManager: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:396,Modifiability,plugin,plugin,396,". TPluginManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginManager. class TPluginManager: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:415,Modifiability,plugin,plugin,415,". TPluginManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginManager. class TPluginManager: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:442,Modifiability,plugin,plugin,442,". TPluginManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginManager. class TPluginManager: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:506,Modifiability,extend,extend,506,". TPluginManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginManager. class TPluginManager: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:617,Modifiability,extend,extend,617,". TPluginManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginManager. class TPluginManager: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:698,Modifiability,plugin,plugin,698,". TPluginManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginManager. class TPluginManager: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:922,Modifiability,plugin,plugin,922,". TPluginManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginManager. class TPluginManager: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:961,Modifiability,plugin,plugins,961,". TPluginManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginManager. class TPluginManager: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:985,Modifiability,plugin,plugin,985,". TPluginManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginManager. class TPluginManager: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:1146,Modifiability,plugin,plugin,1146,"mbers; data members; class charts. ROOT; » CORE; » BASE; » TPluginManager. class TPluginManager: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: TRFIOFile RFIO ""<constructor>""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""<constructor>""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""<constructor>""; Plugin.TVirtualFitter: * TFitt",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:2273,Modifiability,extend,extends,2273," e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: TRFIOFile RFIO ""<constructor>""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""<constructor>""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""<constructor>""; Plugin.TVirtualFitter: * TFitter Minuit ""TFitter(Int_t)"". Where the + in front of Plugin.TSQLServer says that it extends the; existing definition of TSQLServer, useful when there is more than; one plugin that can extend the same base class. The ""<constructor>""; should be the constructor or a static method that generates an; instance of the specified class. Global methods should start with; ""::"" in their name, like ""::CreateFitter()"".; Instead of being a shared library a plugin can also be a CINT; script, so instead of libDialog.so one can have Dialog.C.; The * is a placeholder in case there is no need for a URI to; differentiate between different plugins for the same base class.; For the default plugins see $ROOTSYS/etc/system.rootrc. Plugin handlers can also be registered at run time, e.g.:. gPluginMgr->AddHandler(""TSQLServer"", ""^sapdb:"",; ""TSapDBServer"", ""SapDB"",; ""TSapDBServer(const char*,const char*, const char*)"");. A list of currently defined handlers can be printed using:. gPluginMgr->Print(); // use option=""a"" to see ctors. The use of the plugin library manager removes all textual references; to hard-coded class and library names and the r",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:2357,Modifiability,plugin,plugin,2357," e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: TRFIOFile RFIO ""<constructor>""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""<constructor>""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""<constructor>""; Plugin.TVirtualFitter: * TFitter Minuit ""TFitter(Int_t)"". Where the + in front of Plugin.TSQLServer says that it extends the; existing definition of TSQLServer, useful when there is more than; one plugin that can extend the same base class. The ""<constructor>""; should be the constructor or a static method that generates an; instance of the specified class. Global methods should start with; ""::"" in their name, like ""::CreateFitter()"".; Instead of being a shared library a plugin can also be a CINT; script, so instead of libDialog.so one can have Dialog.C.; The * is a placeholder in case there is no need for a URI to; differentiate between different plugins for the same base class.; For the default plugins see $ROOTSYS/etc/system.rootrc. Plugin handlers can also be registered at run time, e.g.:. gPluginMgr->AddHandler(""TSQLServer"", ""^sapdb:"",; ""TSapDBServer"", ""SapDB"",; ""TSapDBServer(const char*,const char*, const char*)"");. A list of currently defined handlers can be printed using:. gPluginMgr->Print(); // use option=""a"" to see ctors. The use of the plugin library manager removes all textual references; to hard-coded class and library names and the r",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:2373,Modifiability,extend,extend,2373," e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: TRFIOFile RFIO ""<constructor>""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""<constructor>""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""<constructor>""; Plugin.TVirtualFitter: * TFitter Minuit ""TFitter(Int_t)"". Where the + in front of Plugin.TSQLServer says that it extends the; existing definition of TSQLServer, useful when there is more than; one plugin that can extend the same base class. The ""<constructor>""; should be the constructor or a static method that generates an; instance of the specified class. Global methods should start with; ""::"" in their name, like ""::CreateFitter()"".; Instead of being a shared library a plugin can also be a CINT; script, so instead of libDialog.so one can have Dialog.C.; The * is a placeholder in case there is no need for a URI to; differentiate between different plugins for the same base class.; For the default plugins see $ROOTSYS/etc/system.rootrc. Plugin handlers can also be registered at run time, e.g.:. gPluginMgr->AddHandler(""TSQLServer"", ""^sapdb:"",; ""TSapDBServer"", ""SapDB"",; ""TSapDBServer(const char*,const char*, const char*)"");. A list of currently defined handlers can be printed using:. gPluginMgr->Print(); // use option=""a"" to see ctors. The use of the plugin library manager removes all textual references; to hard-coded class and library names and the r",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:2635,Modifiability,plugin,plugin,2635,"ed.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: TRFIOFile RFIO ""<constructor>""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""<constructor>""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""<constructor>""; Plugin.TVirtualFitter: * TFitter Minuit ""TFitter(Int_t)"". Where the + in front of Plugin.TSQLServer says that it extends the; existing definition of TSQLServer, useful when there is more than; one plugin that can extend the same base class. The ""<constructor>""; should be the constructor or a static method that generates an; instance of the specified class. Global methods should start with; ""::"" in their name, like ""::CreateFitter()"".; Instead of being a shared library a plugin can also be a CINT; script, so instead of libDialog.so one can have Dialog.C.; The * is a placeholder in case there is no need for a URI to; differentiate between different plugins for the same base class.; For the default plugins see $ROOTSYS/etc/system.rootrc. Plugin handlers can also be registered at run time, e.g.:. gPluginMgr->AddHandler(""TSQLServer"", ""^sapdb:"",; ""TSapDBServer"", ""SapDB"",; ""TSapDBServer(const char*,const char*, const char*)"");. A list of currently defined handlers can be printed using:. gPluginMgr->Print(); // use option=""a"" to see ctors. The use of the plugin library manager removes all textual references; to hard-coded class and library names and the resulting dependencies; in the base classes. The plugin manager is used to extend a.o.; TFile, TSQLServer, TGrid, etc. functionality. Function Members (Methods); public:. virtual~TPluginManager(); voidTObject::AbstractMethod(const char* method) const; voidAddHandler(const char* base, const char* regexp, const char* class",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:2815,Modifiability,plugin,plugins,2815,"DCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: TRFIOFile RFIO ""<constructor>""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""<constructor>""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""<constructor>""; Plugin.TVirtualFitter: * TFitter Minuit ""TFitter(Int_t)"". Where the + in front of Plugin.TSQLServer says that it extends the; existing definition of TSQLServer, useful when there is more than; one plugin that can extend the same base class. The ""<constructor>""; should be the constructor or a static method that generates an; instance of the specified class. Global methods should start with; ""::"" in their name, like ""::CreateFitter()"".; Instead of being a shared library a plugin can also be a CINT; script, so instead of libDialog.so one can have Dialog.C.; The * is a placeholder in case there is no need for a URI to; differentiate between different plugins for the same base class.; For the default plugins see $ROOTSYS/etc/system.rootrc. Plugin handlers can also be registered at run time, e.g.:. gPluginMgr->AddHandler(""TSQLServer"", ""^sapdb:"",; ""TSapDBServer"", ""SapDB"",; ""TSapDBServer(const char*,const char*, const char*)"");. A list of currently defined handlers can be printed using:. gPluginMgr->Print(); // use option=""a"" to see ctors. The use of the plugin library manager removes all textual references; to hard-coded class and library names and the resulting dependencies; in the base classes. The plugin manager is used to extend a.o.; TFile, TSQLServer, TGrid, etc. functionality. Function Members (Methods); public:. virtual~TPluginManager(); voidTObject::AbstractMethod(const char* method) const; voidAddHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor = 0, const char* origin = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtu",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:2865,Modifiability,plugin,plugins,2865,"s in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: TRFIOFile RFIO ""<constructor>""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""<constructor>""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""<constructor>""; Plugin.TVirtualFitter: * TFitter Minuit ""TFitter(Int_t)"". Where the + in front of Plugin.TSQLServer says that it extends the; existing definition of TSQLServer, useful when there is more than; one plugin that can extend the same base class. The ""<constructor>""; should be the constructor or a static method that generates an; instance of the specified class. Global methods should start with; ""::"" in their name, like ""::CreateFitter()"".; Instead of being a shared library a plugin can also be a CINT; script, so instead of libDialog.so one can have Dialog.C.; The * is a placeholder in case there is no need for a URI to; differentiate between different plugins for the same base class.; For the default plugins see $ROOTSYS/etc/system.rootrc. Plugin handlers can also be registered at run time, e.g.:. gPluginMgr->AddHandler(""TSQLServer"", ""^sapdb:"",; ""TSapDBServer"", ""SapDB"",; ""TSapDBServer(const char*,const char*, const char*)"");. A list of currently defined handlers can be printed using:. gPluginMgr->Print(); // use option=""a"" to see ctors. The use of the plugin library manager removes all textual references; to hard-coded class and library names and the resulting dependencies; in the base classes. The plugin manager is used to extend a.o.; TFile, TSQLServer, TGrid, etc. functionality. Function Members (Methods); public:. virtual~TPluginManager(); voidTObject::AbstractMethod(const char* method) const; voidAddHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor = 0, const char* origin = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::C",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:3223,Modifiability,plugin,plugin,3223,"xisting definition of TSQLServer, useful when there is more than; one plugin that can extend the same base class. The ""<constructor>""; should be the constructor or a static method that generates an; instance of the specified class. Global methods should start with; ""::"" in their name, like ""::CreateFitter()"".; Instead of being a shared library a plugin can also be a CINT; script, so instead of libDialog.so one can have Dialog.C.; The * is a placeholder in case there is no need for a URI to; differentiate between different plugins for the same base class.; For the default plugins see $ROOTSYS/etc/system.rootrc. Plugin handlers can also be registered at run time, e.g.:. gPluginMgr->AddHandler(""TSQLServer"", ""^sapdb:"",; ""TSapDBServer"", ""SapDB"",; ""TSapDBServer(const char*,const char*, const char*)"");. A list of currently defined handlers can be printed using:. gPluginMgr->Print(); // use option=""a"" to see ctors. The use of the plugin library manager removes all textual references; to hard-coded class and library names and the resulting dependencies; in the base classes. The plugin manager is used to extend a.o.; TFile, TSQLServer, TGrid, etc. functionality. Function Members (Methods); public:. virtual~TPluginManager(); voidTObject::AbstractMethod(const char* method) const; voidAddHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor = 0, const char* origin = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidT",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:3373,Modifiability,plugin,plugin,3373," base class. The ""<constructor>""; should be the constructor or a static method that generates an; instance of the specified class. Global methods should start with; ""::"" in their name, like ""::CreateFitter()"".; Instead of being a shared library a plugin can also be a CINT; script, so instead of libDialog.so one can have Dialog.C.; The * is a placeholder in case there is no need for a URI to; differentiate between different plugins for the same base class.; For the default plugins see $ROOTSYS/etc/system.rootrc. Plugin handlers can also be registered at run time, e.g.:. gPluginMgr->AddHandler(""TSQLServer"", ""^sapdb:"",; ""TSapDBServer"", ""SapDB"",; ""TSapDBServer(const char*,const char*, const char*)"");. A list of currently defined handlers can be printed using:. gPluginMgr->Print(); // use option=""a"" to see ctors. The use of the plugin library manager removes all textual references; to hard-coded class and library names and the resulting dependencies; in the base classes. The plugin manager is used to extend a.o.; TFile, TSQLServer, TGrid, etc. functionality. Function Members (Methods); public:. virtual~TPluginManager(); voidTObject::AbstractMethod(const char* method) const; voidAddHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor = 0, const char* origin = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:3399,Modifiability,extend,extend,3399," base class. The ""<constructor>""; should be the constructor or a static method that generates an; instance of the specified class. Global methods should start with; ""::"" in their name, like ""::CreateFitter()"".; Instead of being a shared library a plugin can also be a CINT; script, so instead of libDialog.so one can have Dialog.C.; The * is a placeholder in case there is no need for a URI to; differentiate between different plugins for the same base class.; For the default plugins see $ROOTSYS/etc/system.rootrc. Plugin handlers can also be registered at run time, e.g.:. gPluginMgr->AddHandler(""TSQLServer"", ""^sapdb:"",; ""TSapDBServer"", ""SapDB"",; ""TSapDBServer(const char*,const char*, const char*)"");. A list of currently defined handlers can be printed using:. gPluginMgr->Print(); // use option=""a"" to see ctors. The use of the plugin library manager removes all textual references; to hard-coded class and library names and the resulting dependencies; in the base classes. The plugin manager is used to extend a.o.; TFile, TSQLServer, TGrid, etc. functionality. Function Members (Methods); public:. virtual~TPluginManager(); voidTObject::AbstractMethod(const char* method) const; voidAddHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor = 0, const char* origin = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:3664,Modifiability,plugin,pluginName,3664,,MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:8150,Modifiability,plugin,plugin,8150,"::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* opt = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRemoveHandler(const char* base, const char* regexp = 0); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TPluginManager(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Int_tWritePluginMacros(const char* dir, const char* plugin = 0) const; Int_tWritePluginRecords(const char* envFile, const char* plugin = 0) const.",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:8226,Modifiability,plugin,plugin,8226,"::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* opt = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRemoveHandler(const char* base, const char* regexp = 0); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TPluginManager(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Int_tWritePluginMacros(const char* dir, const char* plugin = 0) const; Int_tWritePluginRecords(const char* envFile, const char* plugin = 0) const.",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:9388,Modifiability,plugin,plugin,9388,"private:. voidLoadHandlerMacros(const char* path); TPluginManager&operator=(const TPluginManager& pm); TPluginManager(const TPluginManager& pm). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. THashTable*fBasesLoaded! table of base classes already checked or loaded; TList*fHandlerslist of plugin handlers; Bool_tfReadingDirs! true if we are running LoadHandlersFromPluginDirs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TPluginManager(); Clean up the plugin manager. void LoadHandlersFromEnv(TEnv* env); Load plugin handlers specified in config file, like:; Plugin.TFile: ^rfio: TRFIOFile RFIO ""TRFIOFile(...)""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""TMySQLServer(...)""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""TPgSQLServer(...)""; The + allows the extension of an already defined resource (see TEnv). void LoadHandlerMacros(const char* path); Load all plugin macros from the specified path/base directory. void LoadHandlersFromPluginDirs(const char* base = 0); Load plugin handlers specified via macros in a list of plugin; directories. The $ROOTSYS/etc/plugins is the default top plugin directory; specified in $ROOTSYS/etc/system.rootrc. The macros must have names; like <BaseClass>/PX0_<PluginClass>.C, e.g.:; TFile/",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:9599,Modifiability,plugin,plugin,9599,"Object::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. THashTable*fBasesLoaded! table of base classes already checked or loaded; TList*fHandlerslist of plugin handlers; Bool_tfReadingDirs! true if we are running LoadHandlersFromPluginDirs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TPluginManager(); Clean up the plugin manager. void LoadHandlersFromEnv(TEnv* env); Load plugin handlers specified in config file, like:; Plugin.TFile: ^rfio: TRFIOFile RFIO ""TRFIOFile(...)""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""TMySQLServer(...)""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""TPgSQLServer(...)""; The + allows the extension of an already defined resource (see TEnv). void LoadHandlerMacros(const char* path); Load all plugin macros from the specified path/base directory. void LoadHandlersFromPluginDirs(const char* base = 0); Load plugin handlers specified via macros in a list of plugin; directories. The $ROOTSYS/etc/plugins is the default top plugin directory; specified in $ROOTSYS/etc/system.rootrc. The macros must have names; like <BaseClass>/PX0_<PluginClass>.C, e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a namespace; the directory must have the name NameSpace@@BaseClass as : is a reser",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:9657,Modifiability,plugin,plugin,9657,"atusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. THashTable*fBasesLoaded! table of base classes already checked or loaded; TList*fHandlerslist of plugin handlers; Bool_tfReadingDirs! true if we are running LoadHandlersFromPluginDirs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TPluginManager(); Clean up the plugin manager. void LoadHandlersFromEnv(TEnv* env); Load plugin handlers specified in config file, like:; Plugin.TFile: ^rfio: TRFIOFile RFIO ""TRFIOFile(...)""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""TMySQLServer(...)""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""TPgSQLServer(...)""; The + allows the extension of an already defined resource (see TEnv). void LoadHandlerMacros(const char* path); Load all plugin macros from the specified path/base directory. void LoadHandlersFromPluginDirs(const char* base = 0); Load plugin handlers specified via macros in a list of plugin; directories. The $ROOTSYS/etc/plugins is the default top plugin directory; specified in $ROOTSYS/etc/system.rootrc. The macros must have names; like <BaseClass>/PX0_<PluginClass>.C, e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a namespace; the directory must have the name NameSpace@@BaseClass as : is a reserved; pathname character on some operating systems. Macros not beginning with; 'P' and ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:9686,Modifiability,config,config,9686,"atusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. THashTable*fBasesLoaded! table of base classes already checked or loaded; TList*fHandlerslist of plugin handlers; Bool_tfReadingDirs! true if we are running LoadHandlersFromPluginDirs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TPluginManager(); Clean up the plugin manager. void LoadHandlersFromEnv(TEnv* env); Load plugin handlers specified in config file, like:; Plugin.TFile: ^rfio: TRFIOFile RFIO ""TRFIOFile(...)""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""TMySQLServer(...)""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""TPgSQLServer(...)""; The + allows the extension of an already defined resource (see TEnv). void LoadHandlerMacros(const char* path); Load all plugin macros from the specified path/base directory. void LoadHandlersFromPluginDirs(const char* base = 0); Load plugin handlers specified via macros in a list of plugin; directories. The $ROOTSYS/etc/plugins is the default top plugin directory; specified in $ROOTSYS/etc/system.rootrc. The macros must have names; like <BaseClass>/PX0_<PluginClass>.C, e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a namespace; the directory must have the name NameSpace@@BaseClass as : is a reserved; pathname character on some operating systems. Macros not beginning with; 'P' and ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:10016,Modifiability,plugin,plugin,10016,"s)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. THashTable*fBasesLoaded! table of base classes already checked or loaded; TList*fHandlerslist of plugin handlers; Bool_tfReadingDirs! true if we are running LoadHandlersFromPluginDirs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TPluginManager(); Clean up the plugin manager. void LoadHandlersFromEnv(TEnv* env); Load plugin handlers specified in config file, like:; Plugin.TFile: ^rfio: TRFIOFile RFIO ""TRFIOFile(...)""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""TMySQLServer(...)""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""TPgSQLServer(...)""; The + allows the extension of an already defined resource (see TEnv). void LoadHandlerMacros(const char* path); Load all plugin macros from the specified path/base directory. void LoadHandlersFromPluginDirs(const char* base = 0); Load plugin handlers specified via macros in a list of plugin; directories. The $ROOTSYS/etc/plugins is the default top plugin directory; specified in $ROOTSYS/etc/system.rootrc. The macros must have names; like <BaseClass>/PX0_<PluginClass>.C, e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a namespace; the directory must have the name NameSpace@@BaseClass as : is a reserved; pathname character on some operating systems. Macros not beginning with; 'P' and ending with "".C"" are ignored. If base is specified only plugin; macros for that base class are loaded. The macros typically; should look like:; void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*,const char*,Int_t)"");; }; In general these macros should not cause side effect",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:10130,Modifiability,plugin,plugin,10130,"te; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. THashTable*fBasesLoaded! table of base classes already checked or loaded; TList*fHandlerslist of plugin handlers; Bool_tfReadingDirs! true if we are running LoadHandlersFromPluginDirs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TPluginManager(); Clean up the plugin manager. void LoadHandlersFromEnv(TEnv* env); Load plugin handlers specified in config file, like:; Plugin.TFile: ^rfio: TRFIOFile RFIO ""TRFIOFile(...)""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""TMySQLServer(...)""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""TPgSQLServer(...)""; The + allows the extension of an already defined resource (see TEnv). void LoadHandlerMacros(const char* path); Load all plugin macros from the specified path/base directory. void LoadHandlersFromPluginDirs(const char* base = 0); Load plugin handlers specified via macros in a list of plugin; directories. The $ROOTSYS/etc/plugins is the default top plugin directory; specified in $ROOTSYS/etc/system.rootrc. The macros must have names; like <BaseClass>/PX0_<PluginClass>.C, e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a namespace; the directory must have the name NameSpace@@BaseClass as : is a reserved; pathname character on some operating systems. Macros not beginning with; 'P' and ending with "".C"" are ignored. If base is specified only plugin; macros for that base class are loaded. The macros typically; should look like:; void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*,const char*,Int_t)"");; }; In general these macros should not cause side effects, by changing global; ROOT state via, e.g. gSystem calls, etc. However, in specific cases; this might be useful, e.g.",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:10180,Modifiability,plugin,plugin,10180,"te; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. THashTable*fBasesLoaded! table of base classes already checked or loaded; TList*fHandlerslist of plugin handlers; Bool_tfReadingDirs! true if we are running LoadHandlersFromPluginDirs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TPluginManager(); Clean up the plugin manager. void LoadHandlersFromEnv(TEnv* env); Load plugin handlers specified in config file, like:; Plugin.TFile: ^rfio: TRFIOFile RFIO ""TRFIOFile(...)""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""TMySQLServer(...)""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""TPgSQLServer(...)""; The + allows the extension of an already defined resource (see TEnv). void LoadHandlerMacros(const char* path); Load all plugin macros from the specified path/base directory. void LoadHandlersFromPluginDirs(const char* base = 0); Load plugin handlers specified via macros in a list of plugin; directories. The $ROOTSYS/etc/plugins is the default top plugin directory; specified in $ROOTSYS/etc/system.rootrc. The macros must have names; like <BaseClass>/PX0_<PluginClass>.C, e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a namespace; the directory must have the name NameSpace@@BaseClass as : is a reserved; pathname character on some operating systems. Macros not beginning with; 'P' and ending with "".C"" are ignored. If base is specified only plugin; macros for that base class are loaded. The macros typically; should look like:; void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*,const char*,Int_t)"");; }; In general these macros should not cause side effects, by changing global; ROOT state via, e.g. gSystem calls, etc. However, in specific cases; this might be useful, e.g.",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:10218,Modifiability,plugin,plugins,10218,"ct::(anonymous)TObject::kZombie. private:. THashTable*fBasesLoaded! table of base classes already checked or loaded; TList*fHandlerslist of plugin handlers; Bool_tfReadingDirs! true if we are running LoadHandlersFromPluginDirs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TPluginManager(); Clean up the plugin manager. void LoadHandlersFromEnv(TEnv* env); Load plugin handlers specified in config file, like:; Plugin.TFile: ^rfio: TRFIOFile RFIO ""TRFIOFile(...)""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""TMySQLServer(...)""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""TPgSQLServer(...)""; The + allows the extension of an already defined resource (see TEnv). void LoadHandlerMacros(const char* path); Load all plugin macros from the specified path/base directory. void LoadHandlersFromPluginDirs(const char* base = 0); Load plugin handlers specified via macros in a list of plugin; directories. The $ROOTSYS/etc/plugins is the default top plugin directory; specified in $ROOTSYS/etc/system.rootrc. The macros must have names; like <BaseClass>/PX0_<PluginClass>.C, e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a namespace; the directory must have the name NameSpace@@BaseClass as : is a reserved; pathname character on some operating systems. Macros not beginning with; 'P' and ending with "".C"" are ignored. If base is specified only plugin; macros for that base class are loaded. The macros typically; should look like:; void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*,const char*,Int_t)"");; }; In general these macros should not cause side effects, by changing global; ROOT state via, e.g. gSystem calls, etc. However, in specific cases; this might be useful, e.g. adding a library search path, adding a specific; dependency, check on some OS or ROOT capability or downloading;",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:10245,Modifiability,plugin,plugin,10245,"ct::(anonymous)TObject::kZombie. private:. THashTable*fBasesLoaded! table of base classes already checked or loaded; TList*fHandlerslist of plugin handlers; Bool_tfReadingDirs! true if we are running LoadHandlersFromPluginDirs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TPluginManager(); Clean up the plugin manager. void LoadHandlersFromEnv(TEnv* env); Load plugin handlers specified in config file, like:; Plugin.TFile: ^rfio: TRFIOFile RFIO ""TRFIOFile(...)""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""TMySQLServer(...)""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""TPgSQLServer(...)""; The + allows the extension of an already defined resource (see TEnv). void LoadHandlerMacros(const char* path); Load all plugin macros from the specified path/base directory. void LoadHandlersFromPluginDirs(const char* base = 0); Load plugin handlers specified via macros in a list of plugin; directories. The $ROOTSYS/etc/plugins is the default top plugin directory; specified in $ROOTSYS/etc/system.rootrc. The macros must have names; like <BaseClass>/PX0_<PluginClass>.C, e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a namespace; the directory must have the name NameSpace@@BaseClass as : is a reserved; pathname character on some operating systems. Macros not beginning with; 'P' and ending with "".C"" are ignored. If base is specified only plugin; macros for that base class are loaded. The macros typically; should look like:; void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*,const char*,Int_t)"");; }; In general these macros should not cause side effects, by changing global; ROOT state via, e.g. gSystem calls, etc. However, in specific cases; this might be useful, e.g. adding a library search path, adding a specific; dependency, check on some OS or ROOT capability or downloading;",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:10720,Modifiability,plugin,plugin,10720,"FIOFile RFIO ""TRFIOFile(...)""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""TMySQLServer(...)""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""TPgSQLServer(...)""; The + allows the extension of an already defined resource (see TEnv). void LoadHandlerMacros(const char* path); Load all plugin macros from the specified path/base directory. void LoadHandlersFromPluginDirs(const char* base = 0); Load plugin handlers specified via macros in a list of plugin; directories. The $ROOTSYS/etc/plugins is the default top plugin directory; specified in $ROOTSYS/etc/system.rootrc. The macros must have names; like <BaseClass>/PX0_<PluginClass>.C, e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a namespace; the directory must have the name NameSpace@@BaseClass as : is a reserved; pathname character on some operating systems. Macros not beginning with; 'P' and ending with "".C"" are ignored. If base is specified only plugin; macros for that base class are loaded. The macros typically; should look like:; void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*,const char*,Int_t)"");; }; In general these macros should not cause side effects, by changing global; ROOT state via, e.g. gSystem calls, etc. However, in specific cases; this might be useful, e.g. adding a library search path, adding a specific; dependency, check on some OS or ROOT capability or downloading; of the plugin. void AddHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor = 0, const char* origin = 0); Add plugin handler to the list of handlers. If there is already a; handler defined for the same base and regexp it will be replaced. void RemoveHandler(const char* base, const char* regexp = 0); Remove handler for the specified base class and the specified; regexp. If regexp=0 remove all handlers for the specified ba",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:11256,Modifiability,plugin,plugin,11256,". The $ROOTSYS/etc/plugins is the default top plugin directory; specified in $ROOTSYS/etc/system.rootrc. The macros must have names; like <BaseClass>/PX0_<PluginClass>.C, e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a namespace; the directory must have the name NameSpace@@BaseClass as : is a reserved; pathname character on some operating systems. Macros not beginning with; 'P' and ending with "".C"" are ignored. If base is specified only plugin; macros for that base class are loaded. The macros typically; should look like:; void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*,const char*,Int_t)"");; }; In general these macros should not cause side effects, by changing global; ROOT state via, e.g. gSystem calls, etc. However, in specific cases; this might be useful, e.g. adding a library search path, adding a specific; dependency, check on some OS or ROOT capability or downloading; of the plugin. void AddHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor = 0, const char* origin = 0); Add plugin handler to the list of handlers. If there is already a; handler defined for the same base and regexp it will be replaced. void RemoveHandler(const char* base, const char* regexp = 0); Remove handler for the specified base class and the specified; regexp. If regexp=0 remove all handlers for the specified base. TPluginHandler * FindHandler(const char* base, const char* uri = 0); Returns the handler if there exists a handler for the specified URI.; The uri can be 0 in which case the first matching plugin handler; will be returned. Returns 0 in case handler is not found. void Print(Option_t* opt = """") const; Print list of registered plugin handlers. If option is ""a"" print; also the ctor's that will be used. Int_t WritePluginMacros(const char* dir, const char* plugin = 0",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:11353,Modifiability,plugin,pluginName,11353,"nClass>.C, e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a namespace; the directory must have the name NameSpace@@BaseClass as : is a reserved; pathname character on some operating systems. Macros not beginning with; 'P' and ending with "".C"" are ignored. If base is specified only plugin; macros for that base class are loaded. The macros typically; should look like:; void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*,const char*,Int_t)"");; }; In general these macros should not cause side effects, by changing global; ROOT state via, e.g. gSystem calls, etc. However, in specific cases; this might be useful, e.g. adding a library search path, adding a specific; dependency, check on some OS or ROOT capability or downloading; of the plugin. void AddHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor = 0, const char* origin = 0); Add plugin handler to the list of handlers. If there is already a; handler defined for the same base and regexp it will be replaced. void RemoveHandler(const char* base, const char* regexp = 0); Remove handler for the specified base class and the specified; regexp. If regexp=0 remove all handlers for the specified base. TPluginHandler * FindHandler(const char* base, const char* uri = 0); Returns the handler if there exists a handler for the specified URI.; The uri can be 0 in which case the first matching plugin handler; will be returned. Returns 0 in case handler is not found. void Print(Option_t* opt = """") const; Print list of registered plugin handlers. If option is ""a"" print; also the ctor's that will be used. Int_t WritePluginMacros(const char* dir, const char* plugin = 0) const; Write in the specified directory the plugin macros. If plugin is specified; and if it is a base class all macros for that base will be written. If it; ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:11416,Modifiability,plugin,plugin,11416,"nClass>.C, e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a namespace; the directory must have the name NameSpace@@BaseClass as : is a reserved; pathname character on some operating systems. Macros not beginning with; 'P' and ending with "".C"" are ignored. If base is specified only plugin; macros for that base class are loaded. The macros typically; should look like:; void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*,const char*,Int_t)"");; }; In general these macros should not cause side effects, by changing global; ROOT state via, e.g. gSystem calls, etc. However, in specific cases; this might be useful, e.g. adding a library search path, adding a specific; dependency, check on some OS or ROOT capability or downloading; of the plugin. void AddHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor = 0, const char* origin = 0); Add plugin handler to the list of handlers. If there is already a; handler defined for the same base and regexp it will be replaced. void RemoveHandler(const char* base, const char* regexp = 0); Remove handler for the specified base class and the specified; regexp. If regexp=0 remove all handlers for the specified base. TPluginHandler * FindHandler(const char* base, const char* uri = 0); Returns the handler if there exists a handler for the specified URI.; The uri can be 0 in which case the first matching plugin handler; will be returned. Returns 0 in case handler is not found. void Print(Option_t* opt = """") const; Print list of registered plugin handlers. If option is ""a"" print; also the ctor's that will be used. Int_t WritePluginMacros(const char* dir, const char* plugin = 0) const; Write in the specified directory the plugin macros. If plugin is specified; and if it is a base class all macros for that base will be written. If it; ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:11923,Modifiability,plugin,plugin,11923,"ile(const char*,Option_t*,const char*,Int_t)"");; }; In general these macros should not cause side effects, by changing global; ROOT state via, e.g. gSystem calls, etc. However, in specific cases; this might be useful, e.g. adding a library search path, adding a specific; dependency, check on some OS or ROOT capability or downloading; of the plugin. void AddHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor = 0, const char* origin = 0); Add plugin handler to the list of handlers. If there is already a; handler defined for the same base and regexp it will be replaced. void RemoveHandler(const char* base, const char* regexp = 0); Remove handler for the specified base class and the specified; regexp. If regexp=0 remove all handlers for the specified base. TPluginHandler * FindHandler(const char* base, const char* uri = 0); Returns the handler if there exists a handler for the specified URI.; The uri can be 0 in which case the first matching plugin handler; will be returned. Returns 0 in case handler is not found. void Print(Option_t* opt = """") const; Print list of registered plugin handlers. If option is ""a"" print; also the ctor's that will be used. Int_t WritePluginMacros(const char* dir, const char* plugin = 0) const; Write in the specified directory the plugin macros. If plugin is specified; and if it is a base class all macros for that base will be written. If it; is a plugin class name, only that one macro will be written. If plugin; is 0 all macros are written. Returns -1 if dir does not exist, 0 otherwise. Int_t WritePluginRecords(const char* envFile, const char* plugin = 0) const; Write in the specified environment config file the plugin records. If; plugin is specified and if it is a base class all records for that; base will be written. If it is a plugin class name, only that one; record will be written. If plugin is 0 all macros are written.; If envFile is 0 or """" the records are written to stdout.; Re",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:12060,Modifiability,plugin,plugin,12060,"al; ROOT state via, e.g. gSystem calls, etc. However, in specific cases; this might be useful, e.g. adding a library search path, adding a specific; dependency, check on some OS or ROOT capability or downloading; of the plugin. void AddHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor = 0, const char* origin = 0); Add plugin handler to the list of handlers. If there is already a; handler defined for the same base and regexp it will be replaced. void RemoveHandler(const char* base, const char* regexp = 0); Remove handler for the specified base class and the specified; regexp. If regexp=0 remove all handlers for the specified base. TPluginHandler * FindHandler(const char* base, const char* uri = 0); Returns the handler if there exists a handler for the specified URI.; The uri can be 0 in which case the first matching plugin handler; will be returned. Returns 0 in case handler is not found. void Print(Option_t* opt = """") const; Print list of registered plugin handlers. If option is ""a"" print; also the ctor's that will be used. Int_t WritePluginMacros(const char* dir, const char* plugin = 0) const; Write in the specified directory the plugin macros. If plugin is specified; and if it is a base class all macros for that base will be written. If it; is a plugin class name, only that one macro will be written. If plugin; is 0 all macros are written. Returns -1 if dir does not exist, 0 otherwise. Int_t WritePluginRecords(const char* envFile, const char* plugin = 0) const; Write in the specified environment config file the plugin records. If; plugin is specified and if it is a base class all records for that; base will be written. If it is a plugin class name, only that one; record will be written. If plugin is 0 all macros are written.; If envFile is 0 or """" the records are written to stdout.; Returns -1 if envFile cannot be created or opened, 0 otherwise. TPluginHandler& operator=(const TPluginManager& pm). TPlugin",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:12189,Modifiability,plugin,plugin,12189,"check on some OS or ROOT capability or downloading; of the plugin. void AddHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor = 0, const char* origin = 0); Add plugin handler to the list of handlers. If there is already a; handler defined for the same base and regexp it will be replaced. void RemoveHandler(const char* base, const char* regexp = 0); Remove handler for the specified base class and the specified; regexp. If regexp=0 remove all handlers for the specified base. TPluginHandler * FindHandler(const char* base, const char* uri = 0); Returns the handler if there exists a handler for the specified URI.; The uri can be 0 in which case the first matching plugin handler; will be returned. Returns 0 in case handler is not found. void Print(Option_t* opt = """") const; Print list of registered plugin handlers. If option is ""a"" print; also the ctor's that will be used. Int_t WritePluginMacros(const char* dir, const char* plugin = 0) const; Write in the specified directory the plugin macros. If plugin is specified; and if it is a base class all macros for that base will be written. If it; is a plugin class name, only that one macro will be written. If plugin; is 0 all macros are written. Returns -1 if dir does not exist, 0 otherwise. Int_t WritePluginRecords(const char* envFile, const char* plugin = 0) const; Write in the specified environment config file the plugin records. If; plugin is specified and if it is a base class all records for that; base will be written. If it is a plugin class name, only that one; record will be written. If plugin is 0 all macros are written.; If envFile is 0 or """" the records are written to stdout.; Returns -1 if envFile cannot be created or opened, 0 otherwise. TPluginHandler& operator=(const TPluginManager& pm). TPluginManager(const TPluginManager& pm). TPluginManager(); { }. » Author: Fons Rademakers 26/1/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:12245,Modifiability,plugin,plugin,12245,"check on some OS or ROOT capability or downloading; of the plugin. void AddHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor = 0, const char* origin = 0); Add plugin handler to the list of handlers. If there is already a; handler defined for the same base and regexp it will be replaced. void RemoveHandler(const char* base, const char* regexp = 0); Remove handler for the specified base class and the specified; regexp. If regexp=0 remove all handlers for the specified base. TPluginHandler * FindHandler(const char* base, const char* uri = 0); Returns the handler if there exists a handler for the specified URI.; The uri can be 0 in which case the first matching plugin handler; will be returned. Returns 0 in case handler is not found. void Print(Option_t* opt = """") const; Print list of registered plugin handlers. If option is ""a"" print; also the ctor's that will be used. Int_t WritePluginMacros(const char* dir, const char* plugin = 0) const; Write in the specified directory the plugin macros. If plugin is specified; and if it is a base class all macros for that base will be written. If it; is a plugin class name, only that one macro will be written. If plugin; is 0 all macros are written. Returns -1 if dir does not exist, 0 otherwise. Int_t WritePluginRecords(const char* envFile, const char* plugin = 0) const; Write in the specified environment config file the plugin records. If; plugin is specified and if it is a base class all records for that; base will be written. If it is a plugin class name, only that one; record will be written. If plugin is 0 all macros are written.; If envFile is 0 or """" the records are written to stdout.; Returns -1 if envFile cannot be created or opened, 0 otherwise. TPluginHandler& operator=(const TPluginManager& pm). TPluginManager(const TPluginManager& pm). TPluginManager(); { }. » Author: Fons Rademakers 26/1/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:12263,Modifiability,plugin,plugin,12263,"har* regexp, const char* className, const char* pluginName, const char* ctor = 0, const char* origin = 0); Add plugin handler to the list of handlers. If there is already a; handler defined for the same base and regexp it will be replaced. void RemoveHandler(const char* base, const char* regexp = 0); Remove handler for the specified base class and the specified; regexp. If regexp=0 remove all handlers for the specified base. TPluginHandler * FindHandler(const char* base, const char* uri = 0); Returns the handler if there exists a handler for the specified URI.; The uri can be 0 in which case the first matching plugin handler; will be returned. Returns 0 in case handler is not found. void Print(Option_t* opt = """") const; Print list of registered plugin handlers. If option is ""a"" print; also the ctor's that will be used. Int_t WritePluginMacros(const char* dir, const char* plugin = 0) const; Write in the specified directory the plugin macros. If plugin is specified; and if it is a base class all macros for that base will be written. If it; is a plugin class name, only that one macro will be written. If plugin; is 0 all macros are written. Returns -1 if dir does not exist, 0 otherwise. Int_t WritePluginRecords(const char* envFile, const char* plugin = 0) const; Write in the specified environment config file the plugin records. If; plugin is specified and if it is a base class all records for that; base will be written. If it is a plugin class name, only that one; record will be written. If plugin is 0 all macros are written.; If envFile is 0 or """" the records are written to stdout.; Returns -1 if envFile cannot be created or opened, 0 otherwise. TPluginHandler& operator=(const TPluginManager& pm). TPluginManager(const TPluginManager& pm). TPluginManager(); { }. » Author: Fons Rademakers 26/1/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:27; This page has been automatically generated. For",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:12364,Modifiability,plugin,plugin,12364,", const char* origin = 0); Add plugin handler to the list of handlers. If there is already a; handler defined for the same base and regexp it will be replaced. void RemoveHandler(const char* base, const char* regexp = 0); Remove handler for the specified base class and the specified; regexp. If regexp=0 remove all handlers for the specified base. TPluginHandler * FindHandler(const char* base, const char* uri = 0); Returns the handler if there exists a handler for the specified URI.; The uri can be 0 in which case the first matching plugin handler; will be returned. Returns 0 in case handler is not found. void Print(Option_t* opt = """") const; Print list of registered plugin handlers. If option is ""a"" print; also the ctor's that will be used. Int_t WritePluginMacros(const char* dir, const char* plugin = 0) const; Write in the specified directory the plugin macros. If plugin is specified; and if it is a base class all macros for that base will be written. If it; is a plugin class name, only that one macro will be written. If plugin; is 0 all macros are written. Returns -1 if dir does not exist, 0 otherwise. Int_t WritePluginRecords(const char* envFile, const char* plugin = 0) const; Write in the specified environment config file the plugin records. If; plugin is specified and if it is a base class all records for that; base will be written. If it is a plugin class name, only that one; record will be written. If plugin is 0 all macros are written.; If envFile is 0 or """" the records are written to stdout.; Returns -1 if envFile cannot be created or opened, 0 otherwise. TPluginHandler& operator=(const TPluginManager& pm). TPluginManager(const TPluginManager& pm). TPluginManager(); { }. » Author: Fons Rademakers 26/1/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please s",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:12423,Modifiability,plugin,plugin,12423,"dd plugin handler to the list of handlers. If there is already a; handler defined for the same base and regexp it will be replaced. void RemoveHandler(const char* base, const char* regexp = 0); Remove handler for the specified base class and the specified; regexp. If regexp=0 remove all handlers for the specified base. TPluginHandler * FindHandler(const char* base, const char* uri = 0); Returns the handler if there exists a handler for the specified URI.; The uri can be 0 in which case the first matching plugin handler; will be returned. Returns 0 in case handler is not found. void Print(Option_t* opt = """") const; Print list of registered plugin handlers. If option is ""a"" print; also the ctor's that will be used. Int_t WritePluginMacros(const char* dir, const char* plugin = 0) const; Write in the specified directory the plugin macros. If plugin is specified; and if it is a base class all macros for that base will be written. If it; is a plugin class name, only that one macro will be written. If plugin; is 0 all macros are written. Returns -1 if dir does not exist, 0 otherwise. Int_t WritePluginRecords(const char* envFile, const char* plugin = 0) const; Write in the specified environment config file the plugin records. If; plugin is specified and if it is a base class all records for that; base will be written. If it is a plugin class name, only that one; record will be written. If plugin is 0 all macros are written.; If envFile is 0 or """" the records are written to stdout.; Returns -1 if envFile cannot be created or opened, 0 otherwise. TPluginHandler& operator=(const TPluginManager& pm). TPluginManager(const TPluginManager& pm). TPluginManager(); { }. » Author: Fons Rademakers 26/1/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:12565,Modifiability,plugin,plugin,12565,"dd plugin handler to the list of handlers. If there is already a; handler defined for the same base and regexp it will be replaced. void RemoveHandler(const char* base, const char* regexp = 0); Remove handler for the specified base class and the specified; regexp. If regexp=0 remove all handlers for the specified base. TPluginHandler * FindHandler(const char* base, const char* uri = 0); Returns the handler if there exists a handler for the specified URI.; The uri can be 0 in which case the first matching plugin handler; will be returned. Returns 0 in case handler is not found. void Print(Option_t* opt = """") const; Print list of registered plugin handlers. If option is ""a"" print; also the ctor's that will be used. Int_t WritePluginMacros(const char* dir, const char* plugin = 0) const; Write in the specified directory the plugin macros. If plugin is specified; and if it is a base class all macros for that base will be written. If it; is a plugin class name, only that one macro will be written. If plugin; is 0 all macros are written. Returns -1 if dir does not exist, 0 otherwise. Int_t WritePluginRecords(const char* envFile, const char* plugin = 0) const; Write in the specified environment config file the plugin records. If; plugin is specified and if it is a base class all records for that; base will be written. If it is a plugin class name, only that one; record will be written. If plugin is 0 all macros are written.; If envFile is 0 or """" the records are written to stdout.; Returns -1 if envFile cannot be created or opened, 0 otherwise. TPluginHandler& operator=(const TPluginManager& pm). TPluginManager(const TPluginManager& pm). TPluginManager(); { }. » Author: Fons Rademakers 26/1/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:12619,Modifiability,config,config,12619,"dd plugin handler to the list of handlers. If there is already a; handler defined for the same base and regexp it will be replaced. void RemoveHandler(const char* base, const char* regexp = 0); Remove handler for the specified base class and the specified; regexp. If regexp=0 remove all handlers for the specified base. TPluginHandler * FindHandler(const char* base, const char* uri = 0); Returns the handler if there exists a handler for the specified URI.; The uri can be 0 in which case the first matching plugin handler; will be returned. Returns 0 in case handler is not found. void Print(Option_t* opt = """") const; Print list of registered plugin handlers. If option is ""a"" print; also the ctor's that will be used. Int_t WritePluginMacros(const char* dir, const char* plugin = 0) const; Write in the specified directory the plugin macros. If plugin is specified; and if it is a base class all macros for that base will be written. If it; is a plugin class name, only that one macro will be written. If plugin; is 0 all macros are written. Returns -1 if dir does not exist, 0 otherwise. Int_t WritePluginRecords(const char* envFile, const char* plugin = 0) const; Write in the specified environment config file the plugin records. If; plugin is specified and if it is a base class all records for that; base will be written. If it is a plugin class name, only that one; record will be written. If plugin is 0 all macros are written.; If envFile is 0 or """" the records are written to stdout.; Returns -1 if envFile cannot be created or opened, 0 otherwise. TPluginHandler& operator=(const TPluginManager& pm). TPluginManager(const TPluginManager& pm). TPluginManager(); { }. » Author: Fons Rademakers 26/1/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:12635,Modifiability,plugin,plugin,12635,"dd plugin handler to the list of handlers. If there is already a; handler defined for the same base and regexp it will be replaced. void RemoveHandler(const char* base, const char* regexp = 0); Remove handler for the specified base class and the specified; regexp. If regexp=0 remove all handlers for the specified base. TPluginHandler * FindHandler(const char* base, const char* uri = 0); Returns the handler if there exists a handler for the specified URI.; The uri can be 0 in which case the first matching plugin handler; will be returned. Returns 0 in case handler is not found. void Print(Option_t* opt = """") const; Print list of registered plugin handlers. If option is ""a"" print; also the ctor's that will be used. Int_t WritePluginMacros(const char* dir, const char* plugin = 0) const; Write in the specified directory the plugin macros. If plugin is specified; and if it is a base class all macros for that base will be written. If it; is a plugin class name, only that one macro will be written. If plugin; is 0 all macros are written. Returns -1 if dir does not exist, 0 otherwise. Int_t WritePluginRecords(const char* envFile, const char* plugin = 0) const; Write in the specified environment config file the plugin records. If; plugin is specified and if it is a base class all records for that; base will be written. If it is a plugin class name, only that one; record will be written. If plugin is 0 all macros are written.; If envFile is 0 or """" the records are written to stdout.; Returns -1 if envFile cannot be created or opened, 0 otherwise. TPluginHandler& operator=(const TPluginManager& pm). TPluginManager(const TPluginManager& pm). TPluginManager(); { }. » Author: Fons Rademakers 26/1/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:12655,Modifiability,plugin,plugin,12655,"dd plugin handler to the list of handlers. If there is already a; handler defined for the same base and regexp it will be replaced. void RemoveHandler(const char* base, const char* regexp = 0); Remove handler for the specified base class and the specified; regexp. If regexp=0 remove all handlers for the specified base. TPluginHandler * FindHandler(const char* base, const char* uri = 0); Returns the handler if there exists a handler for the specified URI.; The uri can be 0 in which case the first matching plugin handler; will be returned. Returns 0 in case handler is not found. void Print(Option_t* opt = """") const; Print list of registered plugin handlers. If option is ""a"" print; also the ctor's that will be used. Int_t WritePluginMacros(const char* dir, const char* plugin = 0) const; Write in the specified directory the plugin macros. If plugin is specified; and if it is a base class all macros for that base will be written. If it; is a plugin class name, only that one macro will be written. If plugin; is 0 all macros are written. Returns -1 if dir does not exist, 0 otherwise. Int_t WritePluginRecords(const char* envFile, const char* plugin = 0) const; Write in the specified environment config file the plugin records. If; plugin is specified and if it is a base class all records for that; base will be written. If it is a plugin class name, only that one; record will be written. If plugin is 0 all macros are written.; If envFile is 0 or """" the records are written to stdout.; Returns -1 if envFile cannot be created or opened, 0 otherwise. TPluginHandler& operator=(const TPluginManager& pm). TPluginManager(const TPluginManager& pm). TPluginManager(); { }. » Author: Fons Rademakers 26/1/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:12756,Modifiability,plugin,plugin,12756,"dd plugin handler to the list of handlers. If there is already a; handler defined for the same base and regexp it will be replaced. void RemoveHandler(const char* base, const char* regexp = 0); Remove handler for the specified base class and the specified; regexp. If regexp=0 remove all handlers for the specified base. TPluginHandler * FindHandler(const char* base, const char* uri = 0); Returns the handler if there exists a handler for the specified URI.; The uri can be 0 in which case the first matching plugin handler; will be returned. Returns 0 in case handler is not found. void Print(Option_t* opt = """") const; Print list of registered plugin handlers. If option is ""a"" print; also the ctor's that will be used. Int_t WritePluginMacros(const char* dir, const char* plugin = 0) const; Write in the specified directory the plugin macros. If plugin is specified; and if it is a base class all macros for that base will be written. If it; is a plugin class name, only that one macro will be written. If plugin; is 0 all macros are written. Returns -1 if dir does not exist, 0 otherwise. Int_t WritePluginRecords(const char* envFile, const char* plugin = 0) const; Write in the specified environment config file the plugin records. If; plugin is specified and if it is a base class all records for that; base will be written. If it is a plugin class name, only that one; record will be written. If plugin is 0 all macros are written.; If envFile is 0 or """" the records are written to stdout.; Returns -1 if envFile cannot be created or opened, 0 otherwise. TPluginHandler& operator=(const TPluginManager& pm). TPluginManager(const TPluginManager& pm). TPluginManager(); { }. » Author: Fons Rademakers 26/1/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:12817,Modifiability,plugin,plugin,12817,"dd plugin handler to the list of handlers. If there is already a; handler defined for the same base and regexp it will be replaced. void RemoveHandler(const char* base, const char* regexp = 0); Remove handler for the specified base class and the specified; regexp. If regexp=0 remove all handlers for the specified base. TPluginHandler * FindHandler(const char* base, const char* uri = 0); Returns the handler if there exists a handler for the specified URI.; The uri can be 0 in which case the first matching plugin handler; will be returned. Returns 0 in case handler is not found. void Print(Option_t* opt = """") const; Print list of registered plugin handlers. If option is ""a"" print; also the ctor's that will be used. Int_t WritePluginMacros(const char* dir, const char* plugin = 0) const; Write in the specified directory the plugin macros. If plugin is specified; and if it is a base class all macros for that base will be written. If it; is a plugin class name, only that one macro will be written. If plugin; is 0 all macros are written. Returns -1 if dir does not exist, 0 otherwise. Int_t WritePluginRecords(const char* envFile, const char* plugin = 0) const; Write in the specified environment config file the plugin records. If; plugin is specified and if it is a base class all records for that; base will be written. If it is a plugin class name, only that one; record will be written. If plugin is 0 all macros are written.; If envFile is 0 or """" the records are written to stdout.; Returns -1 if envFile cannot be created or opened, 0 otherwise. TPluginHandler& operator=(const TPluginManager& pm). TPluginManager(const TPluginManager& pm). TPluginManager(); { }. » Author: Fons Rademakers 26/1/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:461,Performance,load,load,461,". TPluginManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginManager. class TPluginManager: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:689,Performance,load,load,689,". TPluginManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginManager. class TPluginManager: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:765,Performance,load,loading,765,". TPluginManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginManager. class TPluginManager: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:9357,Performance,load,loaded,9357,"private:. voidLoadHandlerMacros(const char* path); TPluginManager&operator=(const TPluginManager& pm); TPluginManager(const TPluginManager& pm). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. THashTable*fBasesLoaded! table of base classes already checked or loaded; TList*fHandlerslist of plugin handlers; Bool_tfReadingDirs! true if we are running LoadHandlersFromPluginDirs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TPluginManager(); Clean up the plugin manager. void LoadHandlersFromEnv(TEnv* env); Load plugin handlers specified in config file, like:; Plugin.TFile: ^rfio: TRFIOFile RFIO ""TRFIOFile(...)""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""TMySQLServer(...)""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""TPgSQLServer(...)""; The + allows the extension of an already defined resource (see TEnv). void LoadHandlerMacros(const char* path); Load all plugin macros from the specified path/base directory. void LoadHandlersFromPluginDirs(const char* base = 0); Load plugin handlers specified via macros in a list of plugin; directories. The $ROOTSYS/etc/plugins is the default top plugin directory; specified in $ROOTSYS/etc/system.rootrc. The macros must have names; like <BaseClass>/PX0_<PluginClass>.C, e.g.:; TFile/",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPluginManager.html:10759,Performance,load,loaded,10759,"FIOFile RFIO ""TRFIOFile(...)""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""TMySQLServer(...)""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""TPgSQLServer(...)""; The + allows the extension of an already defined resource (see TEnv). void LoadHandlerMacros(const char* path); Load all plugin macros from the specified path/base directory. void LoadHandlersFromPluginDirs(const char* base = 0); Load plugin handlers specified via macros in a list of plugin; directories. The $ROOTSYS/etc/plugins is the default top plugin directory; specified in $ROOTSYS/etc/system.rootrc. The macros must have names; like <BaseClass>/PX0_<PluginClass>.C, e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a namespace; the directory must have the name NameSpace@@BaseClass as : is a reserved; pathname character on some operating systems. Macros not beginning with; 'P' and ending with "".C"" are ignored. If base is specified only plugin; macros for that base class are loaded. The macros typically; should look like:; void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*,const char*,Int_t)"");; }; In general these macros should not cause side effects, by changing global; ROOT state via, e.g. gSystem calls, etc. However, in specific cases; this might be useful, e.g. adding a library search path, adding a specific; dependency, check on some OS or ROOT capability or downloading; of the plugin. void AddHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor = 0, const char* origin = 0); Add plugin handler to the list of handlers. If there is already a; handler defined for the same base and regexp it will be replaced. void RemoveHandler(const char* base, const char* regexp = 0); Remove handler for the specified base class and the specified; regexp. If regexp=0 remove all handlers for the specified ba",MatchSource.WIKI,root/html604/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPluginManager.html
https://root.cern/root/html604/TPMERegexp.html:6285,Performance,perform,performed,6285,"into at most maxfields. If maxfields is unspecified or; 0, trailing empty matches are discarded. If maxfields is; positive, no more than maxfields fields will be returned and; trailing empty matches are preserved. If maxfields is empty,; all fields (including trailing empty ones) are returned. This; *should* be the same as the perl behaviour. If pattern produces sub-matches, these are also stored in; the result. A pattern matching the null string will split the value of EXPR; into separate characters at each point it matches that way. Args:; s - string to split; maxfields - maximum number of fields to be split out. 0 means; split all fields, but discard any trailing empty bits.; Negative means split all fields and keep trailing empty bits.; Positive means keep up to N fields including any empty fields; less than N. Anything remaining is in the last field.; Returns: - number of fields found. Int_t Substitute(TString& s, const TString& r, Bool_t doDollarSubst = kTRUE); Substitute matching part of s with r, dollar back-ref; substitution is performed if doDollarSubst is true (default).; Returns the number of substitutions made. After the substitution, another pass is made over the resulting; string and the following special tokens are interpreted:; \l - lowercase next char,; \u - uppercase next char,; \L - lowercase till \E,; \U - uppercase till \E, and; \E - end case modification. TString operator[](Int_t ); Returns the sub-string from the internal fMarkers vector.; Requires having run match or split first. void Print(Option_t* option = """"); Print the regular expression and modifier options.; If 'option' contains ""all"", prints also last string match and; match results. TPRegexp & operator=(const TPMERegexp& ). virtual ~TPMERegexp(); {}. Int_t GetNMaxMatches() const; { return fNMaxMatches; }. void SetNMaxMatches(Int_t nm); { fNMaxMatches = nm; }. Int_t GetGlobalPosition() const; { return fLastGlobalPosition; }. Int_t NMatches() const; { return fNMatches; }. » Author: Edd",MatchSource.WIKI,root/html604/TPMERegexp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPMERegexp.html
https://root.cern/root/html604/TPMERegexp.html:529,Usability,simpl,simply,529,". TPMERegexp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPMERegexp. class TPMERegexp: protected TPRegexp. Wrapper for PCRE library (Perl Compatible Regular Expressions).; Based on PME - PCRE Made Easy by Zachary Hansen. Supports main Perl operations using regular expressions (Match,; Substitute and Split). To retrieve the results one can simply use; operator[] returning a TString. See $ROOTSYS/tutorials/regexp_pme.C for examples. Function Members (Methods); public:. virtual~TPMERegexp(); voidAssignGlobalState(const TPMERegexp& re); static TClass*Class(); Int_tGetGlobalPosition() const; Int_tGetNMaxMatches() const; virtual TClass*IsA() const; Int_tMatch(const TString& s, UInt_t start = 0); Int_tNMatches() const; TStringoperator[](Int_t); virtual voidPrint(Option_t* option = """"); voidReset(const TString& s, const TString& opts = """", Int_t nMatchMax = -1); voidReset(const TString& s, UInt_t opts, Int_t nMatchMax = -1); voidResetGlobalState(); voidSetNMaxMatches(Int_t nm); virtual voidShowMembers(TMemberInspector& insp) const; Int_tSplit(const TString& s, Int_t maxfields = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Int_tSubstitute(TString& s, const TString& r, Bool_t doDollarSubst = kTRUE); TPMERegexp(); TPMERegexp(const TPMERegexp& r); TPMERegexp(const TString& s, const TString& opts = """", Int_t nMatchMax = 10); TPMERegexp(const TString& s, UInt_t opts, Int_t nMatchMax = 10). protected:. voidTPRegexp::Compile(); TStringTPRegexp::GetModifiers() const; TStringTPRegexp::GetPattern() const; static Bool_tTPRegexp::GetThrowAtCompileError(); Bool_tTPRegexp::IsValid() const; Bool_tTPRegexp::MatchB(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10); Int_tTPRegexp::MatchInternal(const TString& s, Int_t start, I",MatchSource.WIKI,root/html604/TPMERegexp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPMERegexp.html
https://root.cern/root/html604/TPoint.html:556,Integrability,rout,routines,556,". TPoint. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPoint. class TPoint. TPoint. TPoint implements a 2D screen (device) point (see also TPoints). Don't add in dictionary since that will add a virtual table pointer; and that will destroy the data layout of an array of TPoint's which; should match the layout of an array of XPoint's (so no extra copying; needs to be done in the X11 drawing routines). Function Members (Methods); public:. ~TPoint(); SCoord_tGetX() const; SCoord_tGetY() const; TPoint&operator=(const TPoint& p); voidSetX(SCoord_t x); voidSetY(SCoord_t y); TPoint(); TPoint(SCoord_t xy); TPoint(const TPoint&); TPoint(SCoord_t x, SCoord_t y). Data Members; public:. SCoord_tfXX device coordinate; SCoord_tfYY device coordinate. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPoint(); { }. TPoint(SCoord_t xy); { }. TPoint(SCoord_t x, SCoord_t y); { }. ~TPoint(); { }. SCoord_t GetX() const; { return (SCoord_t)fX; }. SCoord_t GetY() const; { return (SCoord_t)fY; }. void SetX(SCoord_t x); { fX = x; }. void SetY(SCoord_t y); { fY = y; }. TPoint& operator=(const TPoint& p); { fX = p.fX; fY = p.fY; return *this; }. » Last changed: Tue Sep 8 17:48:19 2015 » Last generated: 2015-09-08 17:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TPoint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPoint.html
https://root.cern/root/html604/TPoints3D.html:2447,Availability,error,error,2447,"at_t x, Float_t y, Float_t z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& points) const; virtual voidDelete(); virtual voidDelete(Option_t*); static Int_tTPoints3DABC::DistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLastPosition() const; virtual Int_tGetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; virtual Float_t*GetP() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Float_tGetX(Int_t idx) const; virtual const Float_t*GetXYZ(Int_t idx); virtual Float_t*GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const",MatchSource.WIKI,root/html604/TPoints3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPoints3D.html
https://root.cern/root/html604/TPoints3D.html:2531,Availability,error,error,2531,"; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& points) const; virtual voidDelete(); virtual voidDelete(Option_t*); static Int_tTPoints3DABC::DistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLastPosition() const; virtual Int_tGetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; virtual Float_t*GetP() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Float_tGetX(Int_t idx) const; virtual const Float_t*GetXYZ(Int_t idx); virtual Float_t*GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const; virtual Float_tGetY(Int_t idx) const; virtual Float_tGetZ(Int_t idx) const; virtua",MatchSource.WIKI,root/html604/TPoints3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPoints3D.html
https://root.cern/root/html604/TPoints3D.html:786,Energy Efficiency,allocate,allocates,786,". TPoints3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TPoints3D. class TPoints3D: public TPoints3DABC. TPoints3D is an abstract class of the array of 3-dimensional points.; It has 4 different constructors. This class has no implemenatation for Paint, Draw, and SavePrimitive methods. First one, without any parameters TPoints3D(), we call 'default; constructor' and it's used in a case that just an initialisation is; needed (i.e. pointer declaration). Example:; TPoints3D *pl1 = new TPoints3D;. Second one is 'normal constructor' with, usually, one parameter; n (number of points), and it just allocates a space for the points. Example:; TPoints3D pl1(150);. Third one allocates a space for the points, and also makes; initialisation from the given array. Example:; TPoints3D pl1(150, pointerToAnArray);. Fourth one is, almost, similar to the constructor above, except; initialisation is provided with three independent arrays (array of; x coordinates, y coordinates and z coordinates). Example:; TPoints3D pl1(150, xArray, yArray, zArray);. Function Members (Methods); public:. virtual~TPoints3D(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTPoints3DABC::Add(Float_t x, Float_t y, Float_t z); virtual Int_tTPoints3DABC::AddLast(Float_t x, Float_t y, Float_t z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& points) const; virtual voidDelete(); virtual voidDelete(Option_t*); static Int_tTPoints3DABC::DistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x",MatchSource.WIKI,root/html604/TPoints3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPoints3D.html
https://root.cern/root/html604/TPoints3D.html:861,Energy Efficiency,allocate,allocates,861,". TPoints3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TPoints3D. class TPoints3D: public TPoints3DABC. TPoints3D is an abstract class of the array of 3-dimensional points.; It has 4 different constructors. This class has no implemenatation for Paint, Draw, and SavePrimitive methods. First one, without any parameters TPoints3D(), we call 'default; constructor' and it's used in a case that just an initialisation is; needed (i.e. pointer declaration). Example:; TPoints3D *pl1 = new TPoints3D;. Second one is 'normal constructor' with, usually, one parameter; n (number of points), and it just allocates a space for the points. Example:; TPoints3D pl1(150);. Third one allocates a space for the points, and also makes; initialisation from the given array. Example:; TPoints3D pl1(150, pointerToAnArray);. Fourth one is, almost, similar to the constructor above, except; initialisation is provided with three independent arrays (array of; x coordinates, y coordinates and z coordinates). Example:; TPoints3D pl1(150, xArray, yArray, zArray);. Function Members (Methods); public:. virtual~TPoints3D(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTPoints3DABC::Add(Float_t x, Float_t y, Float_t z); virtual Int_tTPoints3DABC::AddLast(Float_t x, Float_t y, Float_t z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& points) const; virtual voidDelete(); virtual voidDelete(Option_t*); static Int_tTPoints3DABC::DistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x",MatchSource.WIKI,root/html604/TPoints3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPoints3D.html
https://root.cern/root/html604/TPoints3DABC.html:505,Availability,avail,available,505,". TPoints3DABC. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TPoints3DABC. class TPoints3DABC: public TObject. The TPoints3DABC class; Abstract class to define Arrays of 3D points.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TPoints3DABC(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAdd(Float_t x, Float_t y, Float_t z); virtual Int_tAddLast(Float_t x, Float_t y, Float_t z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static Int_tDistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObje",MatchSource.WIKI,root/html604/TPoints3DABC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPoints3DABC.html
https://root.cern/root/html604/TPoints3DABC.html:1689,Availability,error,error,1689,"oat_t x, Float_t y, Float_t z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static Int_tDistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLastPosition() const; virtual Int_tGetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; virtual Float_t*GetP() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Float_tGetX(Int_t idx) const; virtual const Float_t*GetXYZ(Int_t idx); virtual Float_t*GetXYZ(Float_t* xyz, Int_t idx, Int_t num =",MatchSource.WIKI,root/html604/TPoints3DABC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPoints3DABC.html
https://root.cern/root/html604/TPoints3DABC.html:1773,Availability,error,error,1773,"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static Int_tDistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLastPosition() const; virtual Int_tGetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; virtual Float_t*GetP() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Float_tGetX(Int_t idx) const; virtual const Float_t*GetXYZ(Int_t idx); virtual Float_t*GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const; virtual Float_tGetY(Int_t idx) const; virtual Float_tGetZ(Int_t idx) cons",MatchSource.WIKI,root/html604/TPoints3DABC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPoints3DABC.html
https://root.cern/root/html604/TPoints3DABC.html:8075,Availability,avail,available,8075,"loat_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); Compute distance from point px,py to an axis of the band defined.; by pair points (x1,y1),(x2,y2) where lineWidth is the width of the band. Compute the closest distance of approach from point px,py to this line.; The distance is computed in pixels units. Algorithm:. A(x1,y1) P B(x2,y2). I; I; I; I; M(x,y). Let us call a = distance AM a2=a**2; b = distance BM b2=b**2; c = distance AB c2=c**2; d = distance PM d2=d**2; u = distance AP u2=u**2; v = distance BP v2=v**2 c = u + v. d2 = a2 - u2; d2 = b2 - v2 = b2 -(c-u)**2; ==> u = (a2 -b2 +c2)/2c. Float_t x1 = gPad->XtoAbsPixel(xp1);; Float_t y1 = gPad->YtoAbsPixel(yp1);; Float_t x2 = gPad->XtoAbsPixel(xp2);; Float_t y2 = gPad->YtoAbsPixel(yp2);. Int_t SetNextPoint(Float_t x, Float_t y, Float_t z); Add one 3D point defined by x,y,z to the array of the points; as its last element. Int_t GetN() const; GetN() returns the number of allocated cells if any.; GetN() > 0 shows how many cells; can be available via GetP() method.; GetN() == 0 then GetP() must return 0 as well. Float_t * GetP() const; GetP() returns the pointer to the float point array; of points if available; The number of the available celss can be found via; GetN() method.; GetN() > 0 shows how many cells. Float_t * GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const; GetXYZ(Float_t *xyz,Int_t idx,Int_t num=1) fills the buffer supplied; by the calling code with the points information. Input parameters:. Float_t *xyz - an external user supplied floating point array.; Int_t num - the total number of the points to be copied; the dimension of that array the size of the; array is num*sizeof(Float_t) at least; Int_t idx - The index of the first copy to be taken. Return: The pointer to the buffer array supplied. TPoints3DABC(); {;}. virtual ~TPoints3DABC(); {;}. Int_t DistancetoPrimitive(Int_t px, Int_t py). Int_t GetLastPosition() const; GetN() returns the number of allocated cells if any.; GetN() > 0 shows how ",MatchSource.WIKI,root/html604/TPoints3DABC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPoints3DABC.html
https://root.cern/root/html604/TPoints3DABC.html:8242,Availability,avail,available,8242,"dth is the width of the band. Compute the closest distance of approach from point px,py to this line.; The distance is computed in pixels units. Algorithm:. A(x1,y1) P B(x2,y2). I; I; I; I; M(x,y). Let us call a = distance AM a2=a**2; b = distance BM b2=b**2; c = distance AB c2=c**2; d = distance PM d2=d**2; u = distance AP u2=u**2; v = distance BP v2=v**2 c = u + v. d2 = a2 - u2; d2 = b2 - v2 = b2 -(c-u)**2; ==> u = (a2 -b2 +c2)/2c. Float_t x1 = gPad->XtoAbsPixel(xp1);; Float_t y1 = gPad->YtoAbsPixel(yp1);; Float_t x2 = gPad->XtoAbsPixel(xp2);; Float_t y2 = gPad->YtoAbsPixel(yp2);. Int_t SetNextPoint(Float_t x, Float_t y, Float_t z); Add one 3D point defined by x,y,z to the array of the points; as its last element. Int_t GetN() const; GetN() returns the number of allocated cells if any.; GetN() > 0 shows how many cells; can be available via GetP() method.; GetN() == 0 then GetP() must return 0 as well. Float_t * GetP() const; GetP() returns the pointer to the float point array; of points if available; The number of the available celss can be found via; GetN() method.; GetN() > 0 shows how many cells. Float_t * GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const; GetXYZ(Float_t *xyz,Int_t idx,Int_t num=1) fills the buffer supplied; by the calling code with the points information. Input parameters:. Float_t *xyz - an external user supplied floating point array.; Int_t num - the total number of the points to be copied; the dimension of that array the size of the; array is num*sizeof(Float_t) at least; Int_t idx - The index of the first copy to be taken. Return: The pointer to the buffer array supplied. TPoints3DABC(); {;}. virtual ~TPoints3DABC(); {;}. Int_t DistancetoPrimitive(Int_t px, Int_t py). Int_t GetLastPosition() const; GetN() returns the number of allocated cells if any.; GetN() > 0 shows how many cells; can be available via GetP() method.; GetN() == 0 then GetP() must return 0 as well. Float_t GetX(Int_t idx) const. Float_t GetY(Int_t idx) const. Float_t G",MatchSource.WIKI,root/html604/TPoints3DABC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPoints3DABC.html
https://root.cern/root/html604/TPoints3DABC.html:8271,Availability,avail,available,8271,"dth is the width of the band. Compute the closest distance of approach from point px,py to this line.; The distance is computed in pixels units. Algorithm:. A(x1,y1) P B(x2,y2). I; I; I; I; M(x,y). Let us call a = distance AM a2=a**2; b = distance BM b2=b**2; c = distance AB c2=c**2; d = distance PM d2=d**2; u = distance AP u2=u**2; v = distance BP v2=v**2 c = u + v. d2 = a2 - u2; d2 = b2 - v2 = b2 -(c-u)**2; ==> u = (a2 -b2 +c2)/2c. Float_t x1 = gPad->XtoAbsPixel(xp1);; Float_t y1 = gPad->YtoAbsPixel(yp1);; Float_t x2 = gPad->XtoAbsPixel(xp2);; Float_t y2 = gPad->YtoAbsPixel(yp2);. Int_t SetNextPoint(Float_t x, Float_t y, Float_t z); Add one 3D point defined by x,y,z to the array of the points; as its last element. Int_t GetN() const; GetN() returns the number of allocated cells if any.; GetN() > 0 shows how many cells; can be available via GetP() method.; GetN() == 0 then GetP() must return 0 as well. Float_t * GetP() const; GetP() returns the pointer to the float point array; of points if available; The number of the available celss can be found via; GetN() method.; GetN() > 0 shows how many cells. Float_t * GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const; GetXYZ(Float_t *xyz,Int_t idx,Int_t num=1) fills the buffer supplied; by the calling code with the points information. Input parameters:. Float_t *xyz - an external user supplied floating point array.; Int_t num - the total number of the points to be copied; the dimension of that array the size of the; array is num*sizeof(Float_t) at least; Int_t idx - The index of the first copy to be taken. Return: The pointer to the buffer array supplied. TPoints3DABC(); {;}. virtual ~TPoints3DABC(); {;}. Int_t DistancetoPrimitive(Int_t px, Int_t py). Int_t GetLastPosition() const; GetN() returns the number of allocated cells if any.; GetN() > 0 shows how many cells; can be available via GetP() method.; GetN() == 0 then GetP() must return 0 as well. Float_t GetX(Int_t idx) const. Float_t GetY(Int_t idx) const. Float_t G",MatchSource.WIKI,root/html604/TPoints3DABC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPoints3DABC.html
https://root.cern/root/html604/TPoints3DABC.html:9087,Availability,avail,available,9087,"t GetN() const; GetN() returns the number of allocated cells if any.; GetN() > 0 shows how many cells; can be available via GetP() method.; GetN() == 0 then GetP() must return 0 as well. Float_t * GetP() const; GetP() returns the pointer to the float point array; of points if available; The number of the available celss can be found via; GetN() method.; GetN() > 0 shows how many cells. Float_t * GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const; GetXYZ(Float_t *xyz,Int_t idx,Int_t num=1) fills the buffer supplied; by the calling code with the points information. Input parameters:. Float_t *xyz - an external user supplied floating point array.; Int_t num - the total number of the points to be copied; the dimension of that array the size of the; array is num*sizeof(Float_t) at least; Int_t idx - The index of the first copy to be taken. Return: The pointer to the buffer array supplied. TPoints3DABC(); {;}. virtual ~TPoints3DABC(); {;}. Int_t DistancetoPrimitive(Int_t px, Int_t py). Int_t GetLastPosition() const; GetN() returns the number of allocated cells if any.; GetN() > 0 shows how many cells; can be available via GetP() method.; GetN() == 0 then GetP() must return 0 as well. Float_t GetX(Int_t idx) const. Float_t GetY(Int_t idx) const. Float_t GetZ(Int_t idx) const. Float_t * GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const. Option_t * GetOption() const. void PaintPoints(Int_t n, Float_t* p, Option_t* option = """"). Int_t SetLastPosition(Int_t idx). void SetOption(Option_t* option = """"). Int_t SetPoint(Int_t point, Float_t x, Float_t y, Float_t z). Int_t SetPoints(Int_t n, Float_t* p = 0, Option_t* option = """"). Int_t Size() const. » Author: Valery Fine(fine@mail.cern.ch) 24/04/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-06-02 16:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TPoints3DABC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPoints3DABC.html
https://root.cern/root/html604/TPoints3DABC.html:8010,Energy Efficiency,allocate,allocated,8010,"its last element. Int_t DistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); Compute distance from point px,py to an axis of the band defined.; by pair points (x1,y1),(x2,y2) where lineWidth is the width of the band. Compute the closest distance of approach from point px,py to this line.; The distance is computed in pixels units. Algorithm:. A(x1,y1) P B(x2,y2). I; I; I; I; M(x,y). Let us call a = distance AM a2=a**2; b = distance BM b2=b**2; c = distance AB c2=c**2; d = distance PM d2=d**2; u = distance AP u2=u**2; v = distance BP v2=v**2 c = u + v. d2 = a2 - u2; d2 = b2 - v2 = b2 -(c-u)**2; ==> u = (a2 -b2 +c2)/2c. Float_t x1 = gPad->XtoAbsPixel(xp1);; Float_t y1 = gPad->YtoAbsPixel(yp1);; Float_t x2 = gPad->XtoAbsPixel(xp2);; Float_t y2 = gPad->YtoAbsPixel(yp2);. Int_t SetNextPoint(Float_t x, Float_t y, Float_t z); Add one 3D point defined by x,y,z to the array of the points; as its last element. Int_t GetN() const; GetN() returns the number of allocated cells if any.; GetN() > 0 shows how many cells; can be available via GetP() method.; GetN() == 0 then GetP() must return 0 as well. Float_t * GetP() const; GetP() returns the pointer to the float point array; of points if available; The number of the available celss can be found via; GetN() method.; GetN() > 0 shows how many cells. Float_t * GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const; GetXYZ(Float_t *xyz,Int_t idx,Int_t num=1) fills the buffer supplied; by the calling code with the points information. Input parameters:. Float_t *xyz - an external user supplied floating point array.; Int_t num - the total number of the points to be copied; the dimension of that array the size of the; array is num*sizeof(Float_t) at least; Int_t idx - The index of the first copy to be taken. Return: The pointer to the buffer array supplied. TPoints3DABC(); {;}. virtual ~TPoints3DABC(); {;}. Int_t DistancetoPrimitive(Int_t px, Int_t py). Int_t GetLastPosition() const; GetN",MatchSource.WIKI,root/html604/TPoints3DABC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPoints3DABC.html
https://root.cern/root/html604/TPoints3DABC.html:9022,Energy Efficiency,allocate,allocated,9022,"t GetN() const; GetN() returns the number of allocated cells if any.; GetN() > 0 shows how many cells; can be available via GetP() method.; GetN() == 0 then GetP() must return 0 as well. Float_t * GetP() const; GetP() returns the pointer to the float point array; of points if available; The number of the available celss can be found via; GetN() method.; GetN() > 0 shows how many cells. Float_t * GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const; GetXYZ(Float_t *xyz,Int_t idx,Int_t num=1) fills the buffer supplied; by the calling code with the points information. Input parameters:. Float_t *xyz - an external user supplied floating point array.; Int_t num - the total number of the points to be copied; the dimension of that array the size of the; array is num*sizeof(Float_t) at least; Int_t idx - The index of the first copy to be taken. Return: The pointer to the buffer array supplied. TPoints3DABC(); {;}. virtual ~TPoints3DABC(); {;}. Int_t DistancetoPrimitive(Int_t px, Int_t py). Int_t GetLastPosition() const; GetN() returns the number of allocated cells if any.; GetN() > 0 shows how many cells; can be available via GetP() method.; GetN() == 0 then GetP() must return 0 as well. Float_t GetX(Int_t idx) const. Float_t GetY(Int_t idx) const. Float_t GetZ(Int_t idx) const. Float_t * GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const. Option_t * GetOption() const. void PaintPoints(Int_t n, Float_t* p, Option_t* option = """"). Int_t SetLastPosition(Int_t idx). void SetOption(Option_t* option = """"). Int_t SetPoint(Int_t point, Float_t x, Float_t y, Float_t z). Int_t SetPoints(Int_t n, Float_t* p = 0, Option_t* option = """"). Int_t Size() const. » Author: Valery Fine(fine@mail.cern.ch) 24/04/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-06-02 16:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TPoints3DABC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPoints3DABC.html
https://root.cern/root/html604/TPointsArray3D.html:2505,Availability,error,error,2505," x, Float_t y, Float_t z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& points) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static Int_tTPoints3DABC::DistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLastPosition() const; virtual Int_tGetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; virtual Float_t*GetP() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Float_tGetX(Int_t idx) const; virtual const Float_t*GetXYZ(Int_t idx); virtual Float_t*GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const",MatchSource.WIKI,root/html604/TPointsArray3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPointsArray3D.html
https://root.cern/root/html604/TPointsArray3D.html:2589,Availability,error,error,2589,"rtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& points) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static Int_tTPoints3DABC::DistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLastPosition() const; virtual Int_tGetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; virtual Float_t*GetP() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Float_tGetX(Int_t idx) const; virtual const Float_t*GetXYZ(Int_t idx); virtual Float_t*GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const; virtual Float_tGetY(Int_t idx) const; virtual Float_tGetZ(Int_t idx) const; virtua",MatchSource.WIKI,root/html604/TPointsArray3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPointsArray3D.html
https://root.cern/root/html604/TPointsArray3D.html:820,Energy Efficiency,allocate,allocates,820,". TPointsArray3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TPointsArray3D. class TPointsArray3D: public TPoints3DABC. TPointsArray3D is an abstract class of the array of 3-dimensional points.; It has 4 different constructors. This class has no implementation for Paint, Draw, and SavePrimitive methods. First one, without any parameters TPointsArray3D(), we call 'default; constructor' and it's used in a case that just an initialisation is; needed (i.e. pointer declaration). Example:; TPointsArray3D *pl1 = new TPointsArray3D;. Second one is 'normal constructor' with, usually, one parameter; n (number of points), and it just allocates a space for the points. Example:; TPointsArray3D pl1(150);. Third one allocates a space for the points, and also makes; initialisation from the given array. Example:; TPointsArray3D pl1(150, pointerToAnArray);. Fourth one is, almost, similar to the constructor above, except; initialisation is provided with three independent arrays (array of; x coordinates, y coordinates and z coordinates). Example:; TPointsArray3D pl1(150, xArray, yArray, zArray);. Function Members (Methods); public:. virtual~TPointsArray3D(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTPoints3DABC::Add(Float_t x, Float_t y, Float_t z); virtual Int_tTPoints3DABC::AddLast(Float_t x, Float_t y, Float_t z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& points) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static Int_tTPoints3DABC::Distanceto",MatchSource.WIKI,root/html604/TPointsArray3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPointsArray3D.html
https://root.cern/root/html604/TPointsArray3D.html:900,Energy Efficiency,allocate,allocates,900,". TPointsArray3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TPointsArray3D. class TPointsArray3D: public TPoints3DABC. TPointsArray3D is an abstract class of the array of 3-dimensional points.; It has 4 different constructors. This class has no implementation for Paint, Draw, and SavePrimitive methods. First one, without any parameters TPointsArray3D(), we call 'default; constructor' and it's used in a case that just an initialisation is; needed (i.e. pointer declaration). Example:; TPointsArray3D *pl1 = new TPointsArray3D;. Second one is 'normal constructor' with, usually, one parameter; n (number of points), and it just allocates a space for the points. Example:; TPointsArray3D pl1(150);. Third one allocates a space for the points, and also makes; initialisation from the given array. Example:; TPointsArray3D pl1(150, pointerToAnArray);. Fourth one is, almost, similar to the constructor above, except; initialisation is provided with three independent arrays (array of; x coordinates, y coordinates and z coordinates). Example:; TPointsArray3D pl1(150, xArray, yArray, zArray);. Function Members (Methods); public:. virtual~TPointsArray3D(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTPoints3DABC::Add(Float_t x, Float_t y, Float_t z); virtual Int_tTPoints3DABC::AddLast(Float_t x, Float_t y, Float_t z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& points) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static Int_tTPoints3DABC::Distanceto",MatchSource.WIKI,root/html604/TPointsArray3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPointsArray3D.html
https://root.cern/root/html604/TPointsArray3D.html:10015,Energy Efficiency,allocate,allocate,10015,"Primitive(Int_t px, Int_t py); Compute distance from point px,py to a 3-D points ; *-* =====================================================; -; *-* Compute the closest distance of approach from point px,py to each segment; *-* of the polyline.; *-* Returns when the distance found is below DistanceMaximum.; *-* The distance is computed in pixels units.; -; -. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event; *-* =========================================. void ls(Option_t* option = """") const; -*-*-*List this 3-D polyline with its attributes; *-* ==========================================. void Print(Option_t* option = """") const; -*Dump this 3-D polyline with its attributes; *-* ==========================================. Int_t SetLastPosition(Int_t idx); to be documented. Int_t SetPoint(Int_t point, Float_t x, Float_t y, Float_t z); Initialize one point of the 3-D polyline; *-* ========================================; *-* if n is more then the current TPointsArray3D size (n > fN) - re-allocate this; *-* The new size of the object will be fN += min(10,fN/4); -; *-* return the total number of points introduced; -. Int_t SetPoints(Int_t n, Float_t* p = 0, Option_t* option = """"); Set new values for this 3-D polyline; *-* ====================================; *-* return the total number of points introduced; -. void Streamer(TBuffer& ); Stream a class object*-*-*-*-*-*-*-; *-* =========================================. Int_t GetLastPosition() const; {return fLastPoint;}. Int_t GetN() const; {return fN;}. Float_t * GetP() const; {return fP;}. Float_t GetX(Int_t idx) const; {return fP[3*idx+0];}. Float_t GetY(Int_t idx) const; {return fP[3*idx+1];}. Float_t GetZ(Int_t idx) const; {return fP[3*idx+2];}. const Float_t * GetXYZ(Int_t idx); {return &fP[3*idx+0];}. Float_t * GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const; {return (Float_t *)memcpy(xyz,&fP[3*idx],3*num*sizeof(Float_t));}. Option_t * GetOption() const; {return fO",MatchSource.WIKI,root/html604/TPointsArray3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPointsArray3D.html
https://root.cern/root/html604/TPointSet3D.html:2163,Availability,error,error,2163,"t*TAttBBox::AssertBBox(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearIds(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(); virtual voidTPolyMarker3D::Copy(TObject& polymarker) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTPolyMarker3D::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTPolyMarker3D::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPolyMarker3D::DrawPolyMarker(Int_t n, Float_t* p, Marker_t marker, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPolyMarker3D::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Float_t*TAttBBox::GetBBox(); Bool_tTAttBBox::GetBBoxOK() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tTPolyMarker3D::GetLastPoint() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Int_tTPolyMarker3D::GetN() const; virtual const char*TPolyMarker3D::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TPolyMarker3D::GetOptio",MatchSource.WIKI,root/html604/TPointSet3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPointSet3D.html
https://root.cern/root/html604/TPointSet3D.html:2247,Availability,error,error,2247,"ass(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearIds(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(); virtual voidTPolyMarker3D::Copy(TObject& polymarker) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTPolyMarker3D::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTPolyMarker3D::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPolyMarker3D::DrawPolyMarker(Int_t n, Float_t* p, Marker_t marker, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPolyMarker3D::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Float_t*TAttBBox::GetBBox(); Bool_tTAttBBox::GetBBoxOK() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tTPolyMarker3D::GetLastPoint() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Int_tTPolyMarker3D::GetN() const; virtual const char*TPolyMarker3D::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TPolyMarker3D::GetOption() const; Bool_tGetOwnIds() const; virtual Float_t*TPolyMarker3D::GetP() const; vir",MatchSource.WIKI,root/html604/TPointSet3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPointSet3D.html
https://root.cern/root/html604/TPointSet3D.html:9355,Energy Efficiency,allocate,allocated,9355,"Mask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_t*TAttBBox::fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max); TRefArrayfIdsUser-provided point identifications; Int_tTPolyMarker3D::fLastPointThe index of the last filled point; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTPolyMarker3D::fNNumber of allocated points; TStringTPolyMarker3D::fNameName of polymarker; TStringTPolyMarker3D::fOptionOptions; Bool_tfOwnIdsFlag specifying id-objects are owned by the point-set; Float_t*TPolyMarker3D::fP[3*fN] Array of X,Y,Z coordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPointSet3D(const TPointSet3D& t); Copy constructor. ~TPointSet3D(); Destructor. void CopyIds(const TPointSet3D& t); Copy id objects from point-set 't'. TPointSet3D& operator=(const TPointSet3D& t); Assignement operator. void ComputeBBox(); Compute the bounding box of this points set. void SetPointId(TObject* id); Set id of last point.; Use this method if you also use TPolyMarker3D::SetNextPoint(). void SetPointId(Int_t n, TObject* id); Set id of point n. void ClearIds(); Clears the id-array. If ids are owned the TObjects are deleted. void PointSelected(Int_t n); This virtual method is called from TPoin",MatchSource.WIKI,root/html604/TPointSet3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPointSet3D.html
https://root.cern/root/html604/TPointSet3D.html:10484,Modifiability,extend,extend,10484,"eName of polymarker; TStringTPolyMarker3D::fOptionOptions; Bool_tfOwnIdsFlag specifying id-objects are owned by the point-set; Float_t*TPolyMarker3D::fP[3*fN] Array of X,Y,Z coordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPointSet3D(const TPointSet3D& t); Copy constructor. ~TPointSet3D(); Destructor. void CopyIds(const TPointSet3D& t); Copy id objects from point-set 't'. TPointSet3D& operator=(const TPointSet3D& t); Assignement operator. void ComputeBBox(); Compute the bounding box of this points set. void SetPointId(TObject* id); Set id of last point.; Use this method if you also use TPolyMarker3D::SetNextPoint(). void SetPointId(Int_t n, TObject* id); Set id of point n. void ClearIds(); Clears the id-array. If ids are owned the TObjects are deleted. void PointSelected(Int_t n); This virtual method is called from TPointSet3DGL when a point is; selected.; At this point it just prints out n and id of the point (if it exists).; To make something useful out of this do:; a) subclass and re-implement this method;; b) extend this class to include TExec or some other kind of callback. void Streamer(TBuffer& ); Stream an object of class TPointSet3D. TPointSet3D(); { fName=""TPointSet3D""; }. TPointSet3D(Int_t n, Marker_t m = 1, Option_t* opt = """"); { fName=""TPointSet3D""; }. TPointSet3D(Int_t n, Float_t* p, Marker_t m = 1, Option_t* opt = """"); { fName=""TPointSet3D""; }. TPointSet3D(Int_t n, Double_t* p, Marker_t m = 1, Option_t* opt = """"); { fName=""TPointSet3D""; }. TObject* GetPointId(Int_t n) const; { return fIds.At(n); }. Bool_t GetOwnIds() const; { return fOwnIds; }. void SetOwnIds(Bool_t o); { fOwnIds = o; }. » Author: Matevz Tadel 7/4/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-06-02 16:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TPointSet3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPointSet3D.html
https://root.cern/root/html604/TPointSet3D.html:827,Usability,clear,cleared,827,". TPointSet3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TPointSet3D. class TPointSet3D: public TPolyMarker3D, public TAttBBox. TPolyMarker3D using TPointSet3DGL for direct OpenGL rendering.; Supports only elementary marker types:; 4, 20, 24 : round points, size in pixels;; 2, 3, 5 : crosses, size in scene units;; 28 : as above, line width 2 pixels;; all other : square points, size in pixels. Marker-size (from TAttMarker) is multiplied by 5!. An identification of type TObject* can be assigned to each point; via SetPointId() method. Set the fOwnIds flag if the ids are owned; by the point-set and should be deleted when pointset is cleared or; destructed. Copy-constructor and assignment operator COPIES the ids if the are; not owned and CLONES them if they are owned. The ids are not streamed. Function Members (Methods); public:. virtual~TPointSet3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Float_t*TAttBBox::AssertBBox(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearIds(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(); virtual voidTPolyMarker3D::Copy(TObject& polymarker) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTPolyMarker3D::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTPolyMarker3D::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPolyMarker3D::DrawPolyMarker(Int_t n, Float_t* p, Marker_t marker, Option_t* option = """"); virtual voidTObject::Dump() ",MatchSource.WIKI,root/html604/TPointSet3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPointSet3D.html
https://root.cern/root/html604/TPointSet3DGL.html:1925,Performance,cache,cached,1925," virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; TPointSet3DGL&operator=(const TPointSet3DGL&); TPointSet3DGL&operator=(TPointSet3DGL&&); virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, const Option_t* opt = 0); virtual Bool_tShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tSupportsSecondarySelect() const; TPointSet3DGL(); TPointSet3DGL(const TPointSet3DGL&); TPointSet3DGL(TPointSet3DGL&&); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html604/TPointSet3DGL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPointSet3DGL.html
https://root.cern/root/html604/TPolyLine.html:1826,Availability,error,error,1826,"dPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& polyline) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Int_tGetLastPoint() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; Int_tGetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; virtual const char*TObject::GetTitle() cons",MatchSource.WIKI,root/html604/TPolyLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPolyLine.html
https://root.cern/root/html604/TPolyLine.html:1910,Availability,error,error,1910,"*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& polyline) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Int_tGetLastPoint() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; Int_tGetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_t*GetX() const; Double_t*GetY(",MatchSource.WIKI,root/html604/TPolyLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPolyLine.html
https://root.cern/root/html604/TPolyLine.html:10660,Deployability,release,released,10660,"polyline. First looks for distances to the points of the polyline. Stops search; and returns if a vertex of the polyline is found to be closer than 10; pixels. Thus the return value may depend on the ordering of points; in the polyline. Then looks for distances to the lines of the polyline. There is no; arbitrary cutoff; any distance may be found. Finally checks whether (px, py) is inside a closed and filled polyline.; (Must be EXACTLY closed. ""Filled"" means fill color and fill style are; both non-zero.) If so, returns zero. Returns 9999 if the polyline has no points. void Draw(Option_t* option = """"); Draw this polyline with its current attributes. void DrawPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); Draw this polyline with new coordinates. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a polyline is clicked with the locator. If Left button clicked on one of the line end points, this point; follows the cursor until button is released. if Middle button clicked, the line is moved parallel to itself; until the button is released. void ls(Option_t* option = """") const; List this polyline with its attributes.; The option string is ignored. Int_t Merge(TCollection* list); Merge polylines in the collection in this polyline. void Paint(Option_t* option = """"); Paint this polyline with its current attributes. void PaintPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); Draw this polyline with new coordinates. If option = 'f' or 'F' the fill area is drawn.; The default is to draw the lines only. void PaintPolyLineNDC(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); Draw this polyline with new coordinates in NDC. void Print(Option_t* option = """") const; Dump this polyline with its attributes.; The option string is ignored. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetND",MatchSource.WIKI,root/html604/TPolyLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPolyLine.html
https://root.cern/root/html604/TPolyLine.html:10754,Deployability,release,released,10754,"x of the polyline is found to be closer than 10; pixels. Thus the return value may depend on the ordering of points; in the polyline. Then looks for distances to the lines of the polyline. There is no; arbitrary cutoff; any distance may be found. Finally checks whether (px, py) is inside a closed and filled polyline.; (Must be EXACTLY closed. ""Filled"" means fill color and fill style are; both non-zero.) If so, returns zero. Returns 9999 if the polyline has no points. void Draw(Option_t* option = """"); Draw this polyline with its current attributes. void DrawPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); Draw this polyline with new coordinates. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a polyline is clicked with the locator. If Left button clicked on one of the line end points, this point; follows the cursor until button is released. if Middle button clicked, the line is moved parallel to itself; until the button is released. void ls(Option_t* option = """") const; List this polyline with its attributes.; The option string is ignored. Int_t Merge(TCollection* list); Merge polylines in the collection in this polyline. void Paint(Option_t* option = """"); Paint this polyline with its current attributes. void PaintPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); Draw this polyline with new coordinates. If option = 'f' or 'F' the fill area is drawn.; The default is to draw the lines only. void PaintPolyLineNDC(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); Draw this polyline with new coordinates in NDC. void Print(Option_t* option = """") const; Dump this polyline with its attributes.; The option string is ignored. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetNDC(Bool_t isNDC = kTRUE); Set NDC mode on if isNDC = kTRUE, off otherwise. Int_t SetNextPoint(Double_t ",MatchSource.WIKI,root/html604/TPolyLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPolyLine.html
https://root.cern/root/html604/TPolyLine.html:9799,Integrability,depend,depend,9799,"ion.; Allocates n points. The option string is ignored. TPolyLine(Int_t n, Float_t* x, Float_t* y, Option_t* option = """"); PolyLine normal constructor (single precision).; Makes n points with (x, y) coordinates from x and y.; The option string is ignored. TPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); PolyLine normal constructor (double precision).; Makes n points with (x, y) coordinates from x and y.; The option string is ignored. TPolyLine& operator=(const TPolyLine& ); assignment operator. ~TPolyLine(); PolyLine default destructor. TPolyLine(const TPolyLine& polyline); PolyLine copy constructor. void Copy(TObject& polyline) const; Copy this polyline to polyline. Int_t DistancetoPrimitive(Int_t px, Int_t py); Returns closest distance in pixels from point (px, py) to a polyline. First looks for distances to the points of the polyline. Stops search; and returns if a vertex of the polyline is found to be closer than 10; pixels. Thus the return value may depend on the ordering of points; in the polyline. Then looks for distances to the lines of the polyline. There is no; arbitrary cutoff; any distance may be found. Finally checks whether (px, py) is inside a closed and filled polyline.; (Must be EXACTLY closed. ""Filled"" means fill color and fill style are; both non-zero.) If so, returns zero. Returns 9999 if the polyline has no points. void Draw(Option_t* option = """"); Draw this polyline with its current attributes. void DrawPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); Draw this polyline with new coordinates. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a polyline is clicked with the locator. If Left button clicked on one of the line end points, this point; follows the cursor until button is released. if Middle button clicked, the line is moved parallel to itself; until the button is released. void ls(Option_t* option = """") const; List this",MatchSource.WIKI,root/html604/TPolyLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPolyLine.html
https://root.cern/root/html604/TPolyLine.html:11968,Modifiability,extend,extended,11968,"* list); Merge polylines in the collection in this polyline. void Paint(Option_t* option = """"); Paint this polyline with its current attributes. void PaintPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); Draw this polyline with new coordinates. If option = 'f' or 'F' the fill area is drawn.; The default is to draw the lines only. void PaintPolyLineNDC(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); Draw this polyline with new coordinates in NDC. void Print(Option_t* option = """") const; Dump this polyline with its attributes.; The option string is ignored. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetNDC(Bool_t isNDC = kTRUE); Set NDC mode on if isNDC = kTRUE, off otherwise. Int_t SetNextPoint(Double_t x, Double_t y); Set point following LastPoint to x, y.; Returns index of the point (new last point). void SetPoint(Int_t point, Double_t x, Double_t y); Set point number n to (x, y); If n is greater than the current size, the arrays are automatically; extended. void SetPolyLine(Int_t n); Resize this polyline to size n.; If n <= 0 the current arrays of points are deleted.; If n is greater than the current size, the new points are set to (0, 0). void SetPolyLine(Int_t n, Float_t* x, Float_t* y, Option_t* option = """"); Set new values for this polyline (single precision). If n <= 0 the current arrays of points are deleted. void SetPolyLine(Int_t n, Double_t* x, Double_t* y3, Option_t* option = """"); Set new values for this polyline (double precision). If n <= 0 the current arrays of points are deleted. void Streamer(TBuffer& ); Stream a class object. Int_t GetLastPoint() const; { return fLastPoint;}. Int_t GetN() const; {return fN;}. Double_t * GetX() const; {return fX;}. Double_t * GetY() const; {return fY;}. Option_t * GetOption() const; {return fOption.Data();}. void SetOption(Option_t* option = """"); {fOption = option;}. Int_t Size() const; {return fLastPoint+1;}. ",MatchSource.WIKI,root/html604/TPolyLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPolyLine.html
https://root.cern/root/html604/TPolyLine3D.html:2723,Availability,error,error,2723,"ser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& polyline) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; static voidDrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidDrawPolyLine(Int_t n, Float_t* p, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLastPoint() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; Int_tGetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; Float_t*GetP() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTime",MatchSource.WIKI,root/html604/TPolyLine3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPolyLine3D.html
https://root.cern/root/html604/TPolyLine3D.html:2807,Availability,error,error,2807,"al voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& polyline) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; static voidDrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidDrawPolyLine(Int_t n, Float_t* p, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLastPoint() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; Int_tGetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; Float_t*GetP() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(co",MatchSource.WIKI,root/html604/TPolyLine3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPolyLine3D.html
https://root.cern/root/html604/TPolyLine3D.html:717,Energy Efficiency,allocate,allocates,717,". TPolyLine3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TPolyLine3D. class TPolyLine3D: public TObject, public TAttLine, public TAtt3D. PolyLine3D is a 3-dimensional polyline. It has 4 different constructors. First one, without any parameters TPolyLine3D(), we call 'default; constructor' and it's used in a case that just an initialisation is; needed (i.e. pointer declaration). Example:; TPolyLine3D *pl1 = new TPolyLine3D;. Second one is 'normal constructor' with, usually, one parameter; n (number of points), and it just allocates a space for the points. Example:; TPolyLine3D pl1(150);. Third one allocates a space for the points, and also makes; initialisation from the given array. Example:; TPolyLine3D pl1(150, pointerToAnArray);. Fourth one is, almost, similar to the constructor above, except; initialisation is provided with three independent arrays (array of; x coordinates, y coordinates and z coordinates). Example:; TPolyLine3D pl1(150, xArray, yArray, zArray);. Example:; void pl3() {; TCanvas *c1 = new TCanvas(""c1"");; TView *view = TView::CreateView(1);; view->SetRange(0,0,0,2,2,2);; const Int_t n = 100;; TPolyLine3D *l = new TPolyLine3D(n);; for (Int_t i=0;i<n;i++) {; Double_t x = 2*gRandom->Rndm();; Double_t y = 2*gRandom->Rndm();; Double_t z = 2*gRandom->Rndm();; l->SetPoint(i,x,y,z);; }; l->Draw();; }. Function Members (Methods); public:. virtual~TPolyLine3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& polyl",MatchSource.WIKI,root/html604/TPolyLine3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPolyLine3D.html
https://root.cern/root/html604/TPolyLine3D.html:794,Energy Efficiency,allocate,allocates,794,". TPolyLine3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TPolyLine3D. class TPolyLine3D: public TObject, public TAttLine, public TAtt3D. PolyLine3D is a 3-dimensional polyline. It has 4 different constructors. First one, without any parameters TPolyLine3D(), we call 'default; constructor' and it's used in a case that just an initialisation is; needed (i.e. pointer declaration). Example:; TPolyLine3D *pl1 = new TPolyLine3D;. Second one is 'normal constructor' with, usually, one parameter; n (number of points), and it just allocates a space for the points. Example:; TPolyLine3D pl1(150);. Third one allocates a space for the points, and also makes; initialisation from the given array. Example:; TPolyLine3D pl1(150, pointerToAnArray);. Fourth one is, almost, similar to the constructor above, except; initialisation is provided with three independent arrays (array of; x coordinates, y coordinates and z coordinates). Example:; TPolyLine3D pl1(150, xArray, yArray, zArray);. Example:; void pl3() {; TCanvas *c1 = new TCanvas(""c1"");; TView *view = TView::CreateView(1);; view->SetRange(0,0,0,2,2,2);; const Int_t n = 100;; TPolyLine3D *l = new TPolyLine3D(n);; for (Int_t i=0;i<n;i++) {; Double_t x = 2*gRandom->Rndm();; Double_t y = 2*gRandom->Rndm();; Double_t z = 2*gRandom->Rndm();; l->SetPoint(i,x,y,z);; }; l->Draw();; }. Function Members (Methods); public:. virtual~TPolyLine3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& polyl",MatchSource.WIKI,root/html604/TPolyLine3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TPolyLine3D.html
